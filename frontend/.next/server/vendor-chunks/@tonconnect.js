"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tonconnect";
exports.ids = ["vendor-chunks/@tonconnect"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tonconnect/isomorphic-eventsource/index.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@tonconnect/isomorphic-eventsource/index.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var eventsource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventsource */ \"(ssr)/./node_modules/eventsource/lib/eventsource.js\");\n\n\nif (!global.EventSource) {\n    global.EventSource = eventsource__WEBPACK_IMPORTED_MODULE_0__;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvbmNvbm5lY3QvaXNvbW9ycGhpYy1ldmVudHNvdXJjZS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7QUFBc0M7O0FBRXRDO0FBQ0EseUJBQXlCLHdDQUFXO0FBQ3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG1hLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0b25jb25uZWN0L2lzb21vcnBoaWMtZXZlbnRzb3VyY2UvaW5kZXgubWpzPzRkYmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEV2ZW50U291cmNlIGZyb20gJ2V2ZW50c291cmNlJztcblxuaWYgKCFnbG9iYWwuRXZlbnRTb3VyY2UpIHtcbiAgICBnbG9iYWwuRXZlbnRTb3VyY2UgPSBFdmVudFNvdXJjZTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tonconnect/isomorphic-eventsource/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tonconnect/isomorphic-fetch/index.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@tonconnect/isomorphic-fetch/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node-fetch */ \"(ssr)/./node_modules/node-fetch/lib/index.mjs\");\n\nfunction fetch(url, options) {\n    if (/^\\/\\//.test(url)) {\n        url = 'https:' + url;\n    }\n    return node_fetch__WEBPACK_IMPORTED_MODULE_0__[\"default\"].call(this, url, options);\n}\n\nif (!global.fetch) {\n    global.fetch = fetch;\n    global.Response = node_fetch__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Response;\n    global.Headers = node_fetch__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Headers;\n    global.Request = node_fetch__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Request;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvbmNvbm5lY3QvaXNvbW9ycGhpYy1mZXRjaC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7QUFBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtEQUFTO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQWtCO0FBQ3hDLHFCQUFxQiwwREFBaUI7QUFDdEMscUJBQXFCLDBEQUFpQjtBQUN0QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RtYS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdG9uY29ubmVjdC9pc29tb3JwaGljLWZldGNoL2luZGV4Lm1qcz8yN2FkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCByZWFsRmV0Y2ggZnJvbSAnbm9kZS1mZXRjaCc7XG5mdW5jdGlvbiBmZXRjaCh1cmwsIG9wdGlvbnMpIHtcbiAgICBpZiAoL15cXC9cXC8vLnRlc3QodXJsKSkge1xuICAgICAgICB1cmwgPSAnaHR0cHM6JyArIHVybDtcbiAgICB9XG4gICAgcmV0dXJuIHJlYWxGZXRjaC5jYWxsKHRoaXMsIHVybCwgb3B0aW9ucyk7XG59XG5cbmlmICghZ2xvYmFsLmZldGNoKSB7XG4gICAgZ2xvYmFsLmZldGNoID0gZmV0Y2g7XG4gICAgZ2xvYmFsLlJlc3BvbnNlID0gcmVhbEZldGNoLlJlc3BvbnNlO1xuICAgIGdsb2JhbC5IZWFkZXJzID0gcmVhbEZldGNoLkhlYWRlcnM7XG4gICAgZ2xvYmFsLlJlcXVlc3QgPSByZWFsRmV0Y2guUmVxdWVzdDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tonconnect/isomorphic-fetch/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tonconnect/protocol/lib/esm/index.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@tonconnect/protocol/lib/esm/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Base64: () => (/* binding */ Base64),\n/* harmony export */   CHAIN: () => (/* binding */ CHAIN),\n/* harmony export */   CONNECT_EVENT_ERROR_CODES: () => (/* binding */ CONNECT_EVENT_ERROR_CODES),\n/* harmony export */   CONNECT_ITEM_ERROR_CODES: () => (/* binding */ CONNECT_ITEM_ERROR_CODES),\n/* harmony export */   DISCONNECT_ERROR_CODES: () => (/* binding */ DISCONNECT_ERROR_CODES),\n/* harmony export */   SEND_TRANSACTION_ERROR_CODES: () => (/* binding */ SEND_TRANSACTION_ERROR_CODES),\n/* harmony export */   SIGN_DATA_ERROR_CODES: () => (/* binding */ SIGN_DATA_ERROR_CODES),\n/* harmony export */   SessionCrypto: () => (/* binding */ SessionCrypto),\n/* harmony export */   concatUint8Arrays: () => (/* binding */ concatUint8Arrays),\n/* harmony export */   hexToByteArray: () => (/* binding */ hexToByteArray),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   splitToUint8Arrays: () => (/* binding */ splitToUint8Arrays),\n/* harmony export */   toHexString: () => (/* binding */ toHexString)\n/* harmony export */ });\n/* harmony import */ var tweetnacl_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tweetnacl-util */ \"(ssr)/./node_modules/tweetnacl-util/nacl-util.js\");\n/* harmony import */ var tweetnacl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tweetnacl */ \"(ssr)/./node_modules/tweetnacl/nacl-fast.js\");\n\n\n\nvar CONNECT_EVENT_ERROR_CODES;\n(function (CONNECT_EVENT_ERROR_CODES) {\n    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"UNKNOWN_ERROR\"] = 0] = \"UNKNOWN_ERROR\";\n    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"BAD_REQUEST_ERROR\"] = 1] = \"BAD_REQUEST_ERROR\";\n    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"MANIFEST_NOT_FOUND_ERROR\"] = 2] = \"MANIFEST_NOT_FOUND_ERROR\";\n    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"MANIFEST_CONTENT_ERROR\"] = 3] = \"MANIFEST_CONTENT_ERROR\";\n    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"UNKNOWN_APP_ERROR\"] = 100] = \"UNKNOWN_APP_ERROR\";\n    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"USER_REJECTS_ERROR\"] = 300] = \"USER_REJECTS_ERROR\";\n    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"METHOD_NOT_SUPPORTED\"] = 400] = \"METHOD_NOT_SUPPORTED\";\n})(CONNECT_EVENT_ERROR_CODES || (CONNECT_EVENT_ERROR_CODES = {}));\nvar CONNECT_ITEM_ERROR_CODES;\n(function (CONNECT_ITEM_ERROR_CODES) {\n    CONNECT_ITEM_ERROR_CODES[CONNECT_ITEM_ERROR_CODES[\"UNKNOWN_ERROR\"] = 0] = \"UNKNOWN_ERROR\";\n    CONNECT_ITEM_ERROR_CODES[CONNECT_ITEM_ERROR_CODES[\"METHOD_NOT_SUPPORTED\"] = 400] = \"METHOD_NOT_SUPPORTED\";\n})(CONNECT_ITEM_ERROR_CODES || (CONNECT_ITEM_ERROR_CODES = {}));\n\nvar SEND_TRANSACTION_ERROR_CODES;\n(function (SEND_TRANSACTION_ERROR_CODES) {\n    SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES[\"UNKNOWN_ERROR\"] = 0] = \"UNKNOWN_ERROR\";\n    SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES[\"BAD_REQUEST_ERROR\"] = 1] = \"BAD_REQUEST_ERROR\";\n    SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES[\"UNKNOWN_APP_ERROR\"] = 100] = \"UNKNOWN_APP_ERROR\";\n    SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES[\"USER_REJECTS_ERROR\"] = 300] = \"USER_REJECTS_ERROR\";\n    SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES[\"METHOD_NOT_SUPPORTED\"] = 400] = \"METHOD_NOT_SUPPORTED\";\n})(SEND_TRANSACTION_ERROR_CODES || (SEND_TRANSACTION_ERROR_CODES = {}));\n\nvar SIGN_DATA_ERROR_CODES;\n(function (SIGN_DATA_ERROR_CODES) {\n    SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES[\"UNKNOWN_ERROR\"] = 0] = \"UNKNOWN_ERROR\";\n    SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES[\"BAD_REQUEST_ERROR\"] = 1] = \"BAD_REQUEST_ERROR\";\n    SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES[\"UNKNOWN_APP_ERROR\"] = 100] = \"UNKNOWN_APP_ERROR\";\n    SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES[\"USER_REJECTS_ERROR\"] = 300] = \"USER_REJECTS_ERROR\";\n    SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES[\"METHOD_NOT_SUPPORTED\"] = 400] = \"METHOD_NOT_SUPPORTED\";\n})(SIGN_DATA_ERROR_CODES || (SIGN_DATA_ERROR_CODES = {}));\n\nvar DISCONNECT_ERROR_CODES;\n(function (DISCONNECT_ERROR_CODES) {\n    DISCONNECT_ERROR_CODES[DISCONNECT_ERROR_CODES[\"UNKNOWN_ERROR\"] = 0] = \"UNKNOWN_ERROR\";\n    DISCONNECT_ERROR_CODES[DISCONNECT_ERROR_CODES[\"BAD_REQUEST_ERROR\"] = 1] = \"BAD_REQUEST_ERROR\";\n    DISCONNECT_ERROR_CODES[DISCONNECT_ERROR_CODES[\"UNKNOWN_APP_ERROR\"] = 100] = \"UNKNOWN_APP_ERROR\";\n    DISCONNECT_ERROR_CODES[DISCONNECT_ERROR_CODES[\"METHOD_NOT_SUPPORTED\"] = 400] = \"METHOD_NOT_SUPPORTED\";\n})(DISCONNECT_ERROR_CODES || (DISCONNECT_ERROR_CODES = {}));\n\nvar CHAIN;\n(function (CHAIN) {\n    CHAIN[\"MAINNET\"] = \"-239\";\n    CHAIN[\"TESTNET\"] = \"-3\";\n})(CHAIN || (CHAIN = {}));\n\nfunction encodeUint8Array(value, urlSafe) {\n    const encoded = tweetnacl_util__WEBPACK_IMPORTED_MODULE_0__.encodeBase64(value);\n    if (!urlSafe) {\n        return encoded;\n    }\n    return encodeURIComponent(encoded);\n}\nfunction decodeToUint8Array(value, urlSafe) {\n    if (urlSafe) {\n        value = decodeURIComponent(value);\n    }\n    return tweetnacl_util__WEBPACK_IMPORTED_MODULE_0__.decodeBase64(value);\n}\nfunction encode(value, urlSafe = false) {\n    let uint8Array;\n    if (value instanceof Uint8Array) {\n        uint8Array = value;\n    }\n    else {\n        if (typeof value !== 'string') {\n            value = JSON.stringify(value);\n        }\n        uint8Array = tweetnacl_util__WEBPACK_IMPORTED_MODULE_0__.decodeUTF8(value);\n    }\n    return encodeUint8Array(uint8Array, urlSafe);\n}\nfunction decode(value, urlSafe = false) {\n    const decodedUint8Array = decodeToUint8Array(value, urlSafe);\n    return {\n        toString() {\n            return tweetnacl_util__WEBPACK_IMPORTED_MODULE_0__.encodeUTF8(decodedUint8Array);\n        },\n        toObject() {\n            try {\n                return JSON.parse(tweetnacl_util__WEBPACK_IMPORTED_MODULE_0__.encodeUTF8(decodedUint8Array));\n            }\n            catch (e) {\n                return null;\n            }\n        },\n        toUint8Array() {\n            return decodedUint8Array;\n        }\n    };\n}\nconst Base64 = {\n    encode,\n    decode\n};\n\nfunction concatUint8Arrays(buffer1, buffer2) {\n    const mergedArray = new Uint8Array(buffer1.length + buffer2.length);\n    mergedArray.set(buffer1);\n    mergedArray.set(buffer2, buffer1.length);\n    return mergedArray;\n}\nfunction splitToUint8Arrays(array, index) {\n    if (index >= array.length) {\n        throw new Error('Index is out of buffer');\n    }\n    const subArray1 = array.slice(0, index);\n    const subArray2 = array.slice(index);\n    return [subArray1, subArray2];\n}\nfunction toHexString(byteArray) {\n    let hexString = '';\n    byteArray.forEach(byte => {\n        hexString += ('0' + (byte & 0xff).toString(16)).slice(-2);\n    });\n    return hexString;\n}\nfunction hexToByteArray(hexString) {\n    if (hexString.length % 2 !== 0) {\n        throw new Error(`Cannot convert ${hexString} to bytesArray`);\n    }\n    const result = new Uint8Array(hexString.length / 2);\n    for (let i = 0; i < hexString.length; i += 2) {\n        result[i / 2] = parseInt(hexString.slice(i, i + 2), 16);\n    }\n    return result;\n}\n\nfunction isNode() {\n    return (typeof process !== 'undefined' && process.versions != null && process.versions.node != null);\n}\n\nclass SessionCrypto {\n    constructor(keyPair) {\n        this.nonceLength = 24;\n        this.keyPair = keyPair ? this.createKeypairFromString(keyPair) : this.createKeypair();\n        this.sessionId = toHexString(this.keyPair.publicKey);\n    }\n    createKeypair() {\n        return tweetnacl__WEBPACK_IMPORTED_MODULE_1__.box.keyPair();\n    }\n    createKeypairFromString(keyPair) {\n        return {\n            publicKey: hexToByteArray(keyPair.publicKey),\n            secretKey: hexToByteArray(keyPair.secretKey)\n        };\n    }\n    createNonce() {\n        return tweetnacl__WEBPACK_IMPORTED_MODULE_1__.randomBytes(this.nonceLength);\n    }\n    encrypt(message, receiverPublicKey) {\n        const encodedMessage = new TextEncoder().encode(message);\n        const nonce = this.createNonce();\n        const encrypted = tweetnacl__WEBPACK_IMPORTED_MODULE_1__.box(encodedMessage, nonce, receiverPublicKey, this.keyPair.secretKey);\n        return concatUint8Arrays(nonce, encrypted);\n    }\n    decrypt(message, senderPublicKey) {\n        const [nonce, internalMessage] = splitToUint8Arrays(message, this.nonceLength);\n        const decrypted = tweetnacl__WEBPACK_IMPORTED_MODULE_1__.box.open(internalMessage, nonce, senderPublicKey, this.keyPair.secretKey);\n        if (!decrypted) {\n            throw new Error(`Decryption error: \\n message: ${message.toString()} \\n sender pubkey: ${senderPublicKey.toString()} \\n keypair pubkey: ${this.keyPair.publicKey.toString()} \\n keypair secretkey: ${this.keyPair.secretKey.toString()}`);\n        }\n        return new TextDecoder().decode(decrypted);\n    }\n    stringifyKeypair() {\n        return {\n            publicKey: toHexString(this.keyPair.publicKey),\n            secretKey: toHexString(this.keyPair.secretKey)\n        };\n    }\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvbmNvbm5lY3QvcHJvdG9jb2wvbGliL2VzbS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ0g7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOERBQThEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0REFBNEQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvRUFBb0U7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0Q7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0RBQXdEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCOztBQUV2QjtBQUNBLG9CQUFvQix3REFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3REFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0RBQWU7QUFDbEMsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQ0FBa0Msc0RBQWU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMENBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0RBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBDQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBDQUFVO0FBQ3BDO0FBQ0EsNkRBQTZELG9CQUFvQixvQkFBb0IsNEJBQTRCLHFCQUFxQixtQ0FBbUMsd0JBQXdCLGtDQUFrQztBQUNuUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc1A7QUFDdFAiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90bWEtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRvbmNvbm5lY3QvcHJvdG9jb2wvbGliL2VzbS9pbmRleC5tanM/YWYwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbmFjbCBmcm9tICd0d2VldG5hY2wtdXRpbCc7XG5pbXBvcnQgbmFjbCQxIGZyb20gJ3R3ZWV0bmFjbCc7XG5cbnZhciBDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTO1xuKGZ1bmN0aW9uIChDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTKSB7XG4gICAgQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFU1tDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTW1wiVU5LTk9XTl9FUlJPUlwiXSA9IDBdID0gXCJVTktOT1dOX0VSUk9SXCI7XG4gICAgQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFU1tDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTW1wiQkFEX1JFUVVFU1RfRVJST1JcIl0gPSAxXSA9IFwiQkFEX1JFUVVFU1RfRVJST1JcIjtcbiAgICBDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTW0NPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVNbXCJNQU5JRkVTVF9OT1RfRk9VTkRfRVJST1JcIl0gPSAyXSA9IFwiTUFOSUZFU1RfTk9UX0ZPVU5EX0VSUk9SXCI7XG4gICAgQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFU1tDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTW1wiTUFOSUZFU1RfQ09OVEVOVF9FUlJPUlwiXSA9IDNdID0gXCJNQU5JRkVTVF9DT05URU5UX0VSUk9SXCI7XG4gICAgQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFU1tDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTW1wiVU5LTk9XTl9BUFBfRVJST1JcIl0gPSAxMDBdID0gXCJVTktOT1dOX0FQUF9FUlJPUlwiO1xuICAgIENPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVNbQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFU1tcIlVTRVJfUkVKRUNUU19FUlJPUlwiXSA9IDMwMF0gPSBcIlVTRVJfUkVKRUNUU19FUlJPUlwiO1xuICAgIENPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVNbQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFU1tcIk1FVEhPRF9OT1RfU1VQUE9SVEVEXCJdID0gNDAwXSA9IFwiTUVUSE9EX05PVF9TVVBQT1JURURcIjtcbn0pKENPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVMgfHwgKENPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVMgPSB7fSkpO1xudmFyIENPTk5FQ1RfSVRFTV9FUlJPUl9DT0RFUztcbihmdW5jdGlvbiAoQ09OTkVDVF9JVEVNX0VSUk9SX0NPREVTKSB7XG4gICAgQ09OTkVDVF9JVEVNX0VSUk9SX0NPREVTW0NPTk5FQ1RfSVRFTV9FUlJPUl9DT0RFU1tcIlVOS05PV05fRVJST1JcIl0gPSAwXSA9IFwiVU5LTk9XTl9FUlJPUlwiO1xuICAgIENPTk5FQ1RfSVRFTV9FUlJPUl9DT0RFU1tDT05ORUNUX0lURU1fRVJST1JfQ09ERVNbXCJNRVRIT0RfTk9UX1NVUFBPUlRFRFwiXSA9IDQwMF0gPSBcIk1FVEhPRF9OT1RfU1VQUE9SVEVEXCI7XG59KShDT05ORUNUX0lURU1fRVJST1JfQ09ERVMgfHwgKENPTk5FQ1RfSVRFTV9FUlJPUl9DT0RFUyA9IHt9KSk7XG5cbnZhciBTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTO1xuKGZ1bmN0aW9uIChTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTKSB7XG4gICAgU0VORF9UUkFOU0FDVElPTl9FUlJPUl9DT0RFU1tTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTW1wiVU5LTk9XTl9FUlJPUlwiXSA9IDBdID0gXCJVTktOT1dOX0VSUk9SXCI7XG4gICAgU0VORF9UUkFOU0FDVElPTl9FUlJPUl9DT0RFU1tTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTW1wiQkFEX1JFUVVFU1RfRVJST1JcIl0gPSAxXSA9IFwiQkFEX1JFUVVFU1RfRVJST1JcIjtcbiAgICBTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTW1NFTkRfVFJBTlNBQ1RJT05fRVJST1JfQ09ERVNbXCJVTktOT1dOX0FQUF9FUlJPUlwiXSA9IDEwMF0gPSBcIlVOS05PV05fQVBQX0VSUk9SXCI7XG4gICAgU0VORF9UUkFOU0FDVElPTl9FUlJPUl9DT0RFU1tTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTW1wiVVNFUl9SRUpFQ1RTX0VSUk9SXCJdID0gMzAwXSA9IFwiVVNFUl9SRUpFQ1RTX0VSUk9SXCI7XG4gICAgU0VORF9UUkFOU0FDVElPTl9FUlJPUl9DT0RFU1tTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTW1wiTUVUSE9EX05PVF9TVVBQT1JURURcIl0gPSA0MDBdID0gXCJNRVRIT0RfTk9UX1NVUFBPUlRFRFwiO1xufSkoU0VORF9UUkFOU0FDVElPTl9FUlJPUl9DT0RFUyB8fCAoU0VORF9UUkFOU0FDVElPTl9FUlJPUl9DT0RFUyA9IHt9KSk7XG5cbnZhciBTSUdOX0RBVEFfRVJST1JfQ09ERVM7XG4oZnVuY3Rpb24gKFNJR05fREFUQV9FUlJPUl9DT0RFUykge1xuICAgIFNJR05fREFUQV9FUlJPUl9DT0RFU1tTSUdOX0RBVEFfRVJST1JfQ09ERVNbXCJVTktOT1dOX0VSUk9SXCJdID0gMF0gPSBcIlVOS05PV05fRVJST1JcIjtcbiAgICBTSUdOX0RBVEFfRVJST1JfQ09ERVNbU0lHTl9EQVRBX0VSUk9SX0NPREVTW1wiQkFEX1JFUVVFU1RfRVJST1JcIl0gPSAxXSA9IFwiQkFEX1JFUVVFU1RfRVJST1JcIjtcbiAgICBTSUdOX0RBVEFfRVJST1JfQ09ERVNbU0lHTl9EQVRBX0VSUk9SX0NPREVTW1wiVU5LTk9XTl9BUFBfRVJST1JcIl0gPSAxMDBdID0gXCJVTktOT1dOX0FQUF9FUlJPUlwiO1xuICAgIFNJR05fREFUQV9FUlJPUl9DT0RFU1tTSUdOX0RBVEFfRVJST1JfQ09ERVNbXCJVU0VSX1JFSkVDVFNfRVJST1JcIl0gPSAzMDBdID0gXCJVU0VSX1JFSkVDVFNfRVJST1JcIjtcbiAgICBTSUdOX0RBVEFfRVJST1JfQ09ERVNbU0lHTl9EQVRBX0VSUk9SX0NPREVTW1wiTUVUSE9EX05PVF9TVVBQT1JURURcIl0gPSA0MDBdID0gXCJNRVRIT0RfTk9UX1NVUFBPUlRFRFwiO1xufSkoU0lHTl9EQVRBX0VSUk9SX0NPREVTIHx8IChTSUdOX0RBVEFfRVJST1JfQ09ERVMgPSB7fSkpO1xuXG52YXIgRElTQ09OTkVDVF9FUlJPUl9DT0RFUztcbihmdW5jdGlvbiAoRElTQ09OTkVDVF9FUlJPUl9DT0RFUykge1xuICAgIERJU0NPTk5FQ1RfRVJST1JfQ09ERVNbRElTQ09OTkVDVF9FUlJPUl9DT0RFU1tcIlVOS05PV05fRVJST1JcIl0gPSAwXSA9IFwiVU5LTk9XTl9FUlJPUlwiO1xuICAgIERJU0NPTk5FQ1RfRVJST1JfQ09ERVNbRElTQ09OTkVDVF9FUlJPUl9DT0RFU1tcIkJBRF9SRVFVRVNUX0VSUk9SXCJdID0gMV0gPSBcIkJBRF9SRVFVRVNUX0VSUk9SXCI7XG4gICAgRElTQ09OTkVDVF9FUlJPUl9DT0RFU1tESVNDT05ORUNUX0VSUk9SX0NPREVTW1wiVU5LTk9XTl9BUFBfRVJST1JcIl0gPSAxMDBdID0gXCJVTktOT1dOX0FQUF9FUlJPUlwiO1xuICAgIERJU0NPTk5FQ1RfRVJST1JfQ09ERVNbRElTQ09OTkVDVF9FUlJPUl9DT0RFU1tcIk1FVEhPRF9OT1RfU1VQUE9SVEVEXCJdID0gNDAwXSA9IFwiTUVUSE9EX05PVF9TVVBQT1JURURcIjtcbn0pKERJU0NPTk5FQ1RfRVJST1JfQ09ERVMgfHwgKERJU0NPTk5FQ1RfRVJST1JfQ09ERVMgPSB7fSkpO1xuXG52YXIgQ0hBSU47XG4oZnVuY3Rpb24gKENIQUlOKSB7XG4gICAgQ0hBSU5bXCJNQUlOTkVUXCJdID0gXCItMjM5XCI7XG4gICAgQ0hBSU5bXCJURVNUTkVUXCJdID0gXCItM1wiO1xufSkoQ0hBSU4gfHwgKENIQUlOID0ge30pKTtcblxuZnVuY3Rpb24gZW5jb2RlVWludDhBcnJheSh2YWx1ZSwgdXJsU2FmZSkge1xuICAgIGNvbnN0IGVuY29kZWQgPSBuYWNsLmVuY29kZUJhc2U2NCh2YWx1ZSk7XG4gICAgaWYgKCF1cmxTYWZlKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVkO1xuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGVuY29kZWQpO1xufVxuZnVuY3Rpb24gZGVjb2RlVG9VaW50OEFycmF5KHZhbHVlLCB1cmxTYWZlKSB7XG4gICAgaWYgKHVybFNhZmUpIHtcbiAgICAgICAgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbmFjbC5kZWNvZGVCYXNlNjQodmFsdWUpO1xufVxuZnVuY3Rpb24gZW5jb2RlKHZhbHVlLCB1cmxTYWZlID0gZmFsc2UpIHtcbiAgICBsZXQgdWludDhBcnJheTtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHVpbnQ4QXJyYXkgPSB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB1aW50OEFycmF5ID0gbmFjbC5kZWNvZGVVVEY4KHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZVVpbnQ4QXJyYXkodWludDhBcnJheSwgdXJsU2FmZSk7XG59XG5mdW5jdGlvbiBkZWNvZGUodmFsdWUsIHVybFNhZmUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGRlY29kZWRVaW50OEFycmF5ID0gZGVjb2RlVG9VaW50OEFycmF5KHZhbHVlLCB1cmxTYWZlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiBuYWNsLmVuY29kZVVURjgoZGVjb2RlZFVpbnQ4QXJyYXkpO1xuICAgICAgICB9LFxuICAgICAgICB0b09iamVjdCgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UobmFjbC5lbmNvZGVVVEY4KGRlY29kZWRVaW50OEFycmF5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0b1VpbnQ4QXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlZFVpbnQ4QXJyYXk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuY29uc3QgQmFzZTY0ID0ge1xuICAgIGVuY29kZSxcbiAgICBkZWNvZGVcbn07XG5cbmZ1bmN0aW9uIGNvbmNhdFVpbnQ4QXJyYXlzKGJ1ZmZlcjEsIGJ1ZmZlcjIpIHtcbiAgICBjb25zdCBtZXJnZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcjEubGVuZ3RoICsgYnVmZmVyMi5sZW5ndGgpO1xuICAgIG1lcmdlZEFycmF5LnNldChidWZmZXIxKTtcbiAgICBtZXJnZWRBcnJheS5zZXQoYnVmZmVyMiwgYnVmZmVyMS5sZW5ndGgpO1xuICAgIHJldHVybiBtZXJnZWRBcnJheTtcbn1cbmZ1bmN0aW9uIHNwbGl0VG9VaW50OEFycmF5cyhhcnJheSwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPj0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5kZXggaXMgb3V0IG9mIGJ1ZmZlcicpO1xuICAgIH1cbiAgICBjb25zdCBzdWJBcnJheTEgPSBhcnJheS5zbGljZSgwLCBpbmRleCk7XG4gICAgY29uc3Qgc3ViQXJyYXkyID0gYXJyYXkuc2xpY2UoaW5kZXgpO1xuICAgIHJldHVybiBbc3ViQXJyYXkxLCBzdWJBcnJheTJdO1xufVxuZnVuY3Rpb24gdG9IZXhTdHJpbmcoYnl0ZUFycmF5KSB7XG4gICAgbGV0IGhleFN0cmluZyA9ICcnO1xuICAgIGJ5dGVBcnJheS5mb3JFYWNoKGJ5dGUgPT4ge1xuICAgICAgICBoZXhTdHJpbmcgKz0gKCcwJyArIChieXRlICYgMHhmZikudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGhleFN0cmluZztcbn1cbmZ1bmN0aW9uIGhleFRvQnl0ZUFycmF5KGhleFN0cmluZykge1xuICAgIGlmIChoZXhTdHJpbmcubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb252ZXJ0ICR7aGV4U3RyaW5nfSB0byBieXRlc0FycmF5YCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGhleFN0cmluZy5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhleFN0cmluZy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICByZXN1bHRbaSAvIDJdID0gcGFyc2VJbnQoaGV4U3RyaW5nLnNsaWNlKGksIGkgKyAyKSwgMTYpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc05vZGUoKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAhPSBudWxsICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSAhPSBudWxsKTtcbn1cblxuY2xhc3MgU2Vzc2lvbkNyeXB0byB7XG4gICAgY29uc3RydWN0b3Ioa2V5UGFpcikge1xuICAgICAgICB0aGlzLm5vbmNlTGVuZ3RoID0gMjQ7XG4gICAgICAgIHRoaXMua2V5UGFpciA9IGtleVBhaXIgPyB0aGlzLmNyZWF0ZUtleXBhaXJGcm9tU3RyaW5nKGtleVBhaXIpIDogdGhpcy5jcmVhdGVLZXlwYWlyKCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbklkID0gdG9IZXhTdHJpbmcodGhpcy5rZXlQYWlyLnB1YmxpY0tleSk7XG4gICAgfVxuICAgIGNyZWF0ZUtleXBhaXIoKSB7XG4gICAgICAgIHJldHVybiBuYWNsJDEuYm94LmtleVBhaXIoKTtcbiAgICB9XG4gICAgY3JlYXRlS2V5cGFpckZyb21TdHJpbmcoa2V5UGFpcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHVibGljS2V5OiBoZXhUb0J5dGVBcnJheShrZXlQYWlyLnB1YmxpY0tleSksXG4gICAgICAgICAgICBzZWNyZXRLZXk6IGhleFRvQnl0ZUFycmF5KGtleVBhaXIuc2VjcmV0S2V5KVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjcmVhdGVOb25jZSgpIHtcbiAgICAgICAgcmV0dXJuIG5hY2wkMS5yYW5kb21CeXRlcyh0aGlzLm5vbmNlTGVuZ3RoKTtcbiAgICB9XG4gICAgZW5jcnlwdChtZXNzYWdlLCByZWNlaXZlclB1YmxpY0tleSkge1xuICAgICAgICBjb25zdCBlbmNvZGVkTWVzc2FnZSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShtZXNzYWdlKTtcbiAgICAgICAgY29uc3Qgbm9uY2UgPSB0aGlzLmNyZWF0ZU5vbmNlKCk7XG4gICAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IG5hY2wkMS5ib3goZW5jb2RlZE1lc3NhZ2UsIG5vbmNlLCByZWNlaXZlclB1YmxpY0tleSwgdGhpcy5rZXlQYWlyLnNlY3JldEtleSk7XG4gICAgICAgIHJldHVybiBjb25jYXRVaW50OEFycmF5cyhub25jZSwgZW5jcnlwdGVkKTtcbiAgICB9XG4gICAgZGVjcnlwdChtZXNzYWdlLCBzZW5kZXJQdWJsaWNLZXkpIHtcbiAgICAgICAgY29uc3QgW25vbmNlLCBpbnRlcm5hbE1lc3NhZ2VdID0gc3BsaXRUb1VpbnQ4QXJyYXlzKG1lc3NhZ2UsIHRoaXMubm9uY2VMZW5ndGgpO1xuICAgICAgICBjb25zdCBkZWNyeXB0ZWQgPSBuYWNsJDEuYm94Lm9wZW4oaW50ZXJuYWxNZXNzYWdlLCBub25jZSwgc2VuZGVyUHVibGljS2V5LCB0aGlzLmtleVBhaXIuc2VjcmV0S2V5KTtcbiAgICAgICAgaWYgKCFkZWNyeXB0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGVjcnlwdGlvbiBlcnJvcjogXFxuIG1lc3NhZ2U6ICR7bWVzc2FnZS50b1N0cmluZygpfSBcXG4gc2VuZGVyIHB1YmtleTogJHtzZW5kZXJQdWJsaWNLZXkudG9TdHJpbmcoKX0gXFxuIGtleXBhaXIgcHVia2V5OiAke3RoaXMua2V5UGFpci5wdWJsaWNLZXkudG9TdHJpbmcoKX0gXFxuIGtleXBhaXIgc2VjcmV0a2V5OiAke3RoaXMua2V5UGFpci5zZWNyZXRLZXkudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRlY3J5cHRlZCk7XG4gICAgfVxuICAgIHN0cmluZ2lmeUtleXBhaXIoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwdWJsaWNLZXk6IHRvSGV4U3RyaW5nKHRoaXMua2V5UGFpci5wdWJsaWNLZXkpLFxuICAgICAgICAgICAgc2VjcmV0S2V5OiB0b0hleFN0cmluZyh0aGlzLmtleVBhaXIuc2VjcmV0S2V5KVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQmFzZTY0LCBDSEFJTiwgQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFUywgQ09OTkVDVF9JVEVNX0VSUk9SX0NPREVTLCBESVNDT05ORUNUX0VSUk9SX0NPREVTLCBTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTLCBTSUdOX0RBVEFfRVJST1JfQ09ERVMsIFNlc3Npb25DcnlwdG8sIGNvbmNhdFVpbnQ4QXJyYXlzLCBoZXhUb0J5dGVBcnJheSwgaXNOb2RlLCBzcGxpdFRvVWludDhBcnJheXMsIHRvSGV4U3RyaW5nIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tonconnect/protocol/lib/esm/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tonconnect/sdk/lib/esm/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@tonconnect/sdk/lib/esm/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BadRequestError: () => (/* binding */ BadRequestError),\n/* harmony export */   BrowserEventDispatcher: () => (/* binding */ BrowserEventDispatcher),\n/* harmony export */   CHAIN: () => (/* reexport safe */ _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CHAIN),\n/* harmony export */   CONNECT_EVENT_ERROR_CODES: () => (/* reexport safe */ _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES),\n/* harmony export */   CONNECT_ITEM_ERROR_CODES: () => (/* reexport safe */ _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_ITEM_ERROR_CODES),\n/* harmony export */   FetchWalletsError: () => (/* binding */ FetchWalletsError),\n/* harmony export */   LocalstorageNotFoundError: () => (/* binding */ LocalstorageNotFoundError),\n/* harmony export */   ParseHexError: () => (/* binding */ ParseHexError),\n/* harmony export */   SEND_TRANSACTION_ERROR_CODES: () => (/* reexport safe */ _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES),\n/* harmony export */   SIGN_DATA_ERROR_CODES: () => (/* reexport safe */ _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SIGN_DATA_ERROR_CODES),\n/* harmony export */   SessionCrypto: () => (/* reexport safe */ _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SessionCrypto),\n/* harmony export */   TonConnect: () => (/* binding */ TonConnect),\n/* harmony export */   TonConnectError: () => (/* binding */ TonConnectError),\n/* harmony export */   UUIDv7: () => (/* binding */ UUIDv7),\n/* harmony export */   UnknownAppError: () => (/* binding */ UnknownAppError),\n/* harmony export */   UnknownError: () => (/* binding */ UnknownError),\n/* harmony export */   UserRejectsError: () => (/* binding */ UserRejectsError),\n/* harmony export */   WalletAlreadyConnectedError: () => (/* binding */ WalletAlreadyConnectedError),\n/* harmony export */   WalletMissingRequiredFeaturesError: () => (/* binding */ WalletMissingRequiredFeaturesError),\n/* harmony export */   WalletNotConnectedError: () => (/* binding */ WalletNotConnectedError),\n/* harmony export */   WalletNotInjectedError: () => (/* binding */ WalletNotInjectedError),\n/* harmony export */   WalletNotSupportFeatureError: () => (/* binding */ WalletNotSupportFeatureError),\n/* harmony export */   WalletWrongNetworkError: () => (/* binding */ WalletWrongNetworkError),\n/* harmony export */   WalletsListManager: () => (/* binding */ WalletsListManager),\n/* harmony export */   WrongAddressError: () => (/* binding */ WrongAddressError),\n/* harmony export */   checkRequiredWalletFeatures: () => (/* binding */ checkRequiredWalletFeatures),\n/* harmony export */   createConnectionCompletedEvent: () => (/* binding */ createConnectionCompletedEvent),\n/* harmony export */   createConnectionErrorEvent: () => (/* binding */ createConnectionErrorEvent),\n/* harmony export */   createConnectionRestoringCompletedEvent: () => (/* binding */ createConnectionRestoringCompletedEvent),\n/* harmony export */   createConnectionRestoringErrorEvent: () => (/* binding */ createConnectionRestoringErrorEvent),\n/* harmony export */   createConnectionRestoringStartedEvent: () => (/* binding */ createConnectionRestoringStartedEvent),\n/* harmony export */   createConnectionStartedEvent: () => (/* binding */ createConnectionStartedEvent),\n/* harmony export */   createDataSentForSignatureEvent: () => (/* binding */ createDataSentForSignatureEvent),\n/* harmony export */   createDataSignedEvent: () => (/* binding */ createDataSignedEvent),\n/* harmony export */   createDataSigningFailedEvent: () => (/* binding */ createDataSigningFailedEvent),\n/* harmony export */   createDisconnectionEvent: () => (/* binding */ createDisconnectionEvent),\n/* harmony export */   createRequestVersionEvent: () => (/* binding */ createRequestVersionEvent),\n/* harmony export */   createResponseVersionEvent: () => (/* binding */ createResponseVersionEvent),\n/* harmony export */   createSelectedWalletEvent: () => (/* binding */ createSelectedWalletEvent),\n/* harmony export */   createTransactionSentForSignatureEvent: () => (/* binding */ createTransactionSentForSignatureEvent),\n/* harmony export */   createTransactionSignedEvent: () => (/* binding */ createTransactionSignedEvent),\n/* harmony export */   createTransactionSigningFailedEvent: () => (/* binding */ createTransactionSigningFailedEvent),\n/* harmony export */   createVersionInfo: () => (/* binding */ createVersionInfo),\n/* harmony export */   createWalletModalOpenedEvent: () => (/* binding */ createWalletModalOpenedEvent),\n/* harmony export */   decodeTelegramUrlParameters: () => (/* binding */ decodeTelegramUrlParameters),\n/* harmony export */   \"default\": () => (/* binding */ TonConnect),\n/* harmony export */   enableQaMode: () => (/* binding */ enableQaMode),\n/* harmony export */   encodeTelegramUrlParameters: () => (/* binding */ encodeTelegramUrlParameters),\n/* harmony export */   initializeWalletConnect: () => (/* binding */ initializeWalletConnect),\n/* harmony export */   isConnectUrl: () => (/* binding */ isConnectUrl),\n/* harmony export */   isQaModeEnabled: () => (/* binding */ isQaModeEnabled),\n/* harmony export */   isTelegramUrl: () => (/* binding */ isTelegramUrl),\n/* harmony export */   isWalletConnectInitialized: () => (/* binding */ isWalletConnectInitialized),\n/* harmony export */   isWalletInfoCurrentlyEmbedded: () => (/* binding */ isWalletInfoCurrentlyEmbedded),\n/* harmony export */   isWalletInfoCurrentlyInjected: () => (/* binding */ isWalletInfoCurrentlyInjected),\n/* harmony export */   isWalletInfoInjectable: () => (/* binding */ isWalletInfoInjectable),\n/* harmony export */   isWalletInfoInjected: () => (/* binding */ isWalletInfoInjected),\n/* harmony export */   isWalletInfoRemote: () => (/* binding */ isWalletInfoRemote),\n/* harmony export */   toUserFriendlyAddress: () => (/* binding */ toUserFriendlyAddress)\n/* harmony export */ });\n/* harmony import */ var _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tonconnect/protocol */ \"(ssr)/./node_modules/@tonconnect/protocol/lib/esm/index.mjs\");\n/* harmony import */ var _tonconnect_isomorphic_eventsource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tonconnect/isomorphic-eventsource */ \"(ssr)/./node_modules/@tonconnect/isomorphic-eventsource/index.mjs\");\n/* harmony import */ var _tonconnect_isomorphic_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tonconnect/isomorphic-fetch */ \"(ssr)/./node_modules/@tonconnect/isomorphic-fetch/index.mjs\");\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\n/**\n * Base class for TonConnect errors. You can check if the error was triggered by the @tonconnect/sdk using `err instanceof TonConnectError`.\n */\nclass TonConnectError extends Error {\n    get info() {\n        return '';\n    }\n    constructor(message, options) {\n        super(message, options);\n        this.message = `${TonConnectError.prefix} ${this.constructor.name}${this.info ? ': ' + this.info : ''}${message ? '\\n' + message : ''}`;\n        Object.setPrototypeOf(this, TonConnectError.prototype);\n    }\n}\nTonConnectError.prefix = '[TON_CONNECT_SDK_ERROR]';\n\n/**\n * Thrown when passed DappMetadata is in incorrect format.\n */\nclass DappMetadataError extends TonConnectError {\n    get info() {\n        return 'Passed DappMetadata is in incorrect format.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, DappMetadataError.prototype);\n    }\n}\n\n/**\n * Thrown when passed manifest contains errors.\n */\nclass ManifestContentErrorError extends TonConnectError {\n    get info() {\n        return 'Passed `tonconnect-manifest.json` contains errors. Check format of your manifest. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, ManifestContentErrorError.prototype);\n    }\n}\n\n/**\n * Thrown when wallet can't get manifest by passed manifestUrl.\n */\nclass ManifestNotFoundError extends TonConnectError {\n    get info() {\n        return 'Manifest not found. Make sure you added `tonconnect-manifest.json` to the root of your app or passed correct manifestUrl. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, ManifestNotFoundError.prototype);\n    }\n}\n\n/**\n * Thrown when wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection.\n */\nclass WalletAlreadyConnectedError extends TonConnectError {\n    get info() {\n        return 'Wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, WalletAlreadyConnectedError.prototype);\n    }\n}\n\n/**\n * Thrown when send transaction or other protocol methods called while wallet is not connected.\n */\nclass WalletNotConnectedError extends TonConnectError {\n    get info() {\n        return 'Send transaction or other protocol methods called while wallet is not connected.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, WalletNotConnectedError.prototype);\n    }\n}\n\n/**\n * Thrown when there is an attempt to connect to the injected wallet while it is not exists in the webpage.\n */\nclass WalletNotInjectedError extends TonConnectError {\n    get info() {\n        return 'There is an attempt to connect to the injected wallet while it is not exists in the webpage.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, WalletNotInjectedError.prototype);\n    }\n}\n\n/**\n * Thrown when wallet doesn't support requested feature method.\n */\nclass WalletNotSupportFeatureError extends TonConnectError {\n    get info() {\n        return \"Wallet doesn't support requested feature method.\";\n    }\n    constructor(message, options) {\n        super(message, options);\n        Object.setPrototypeOf(this, WalletNotSupportFeatureError.prototype);\n    }\n}\n\n/**\n * Thrown when wallet can't get manifest by passed manifestUrl.\n */\nclass WalletMissingRequiredFeaturesError extends TonConnectError {\n    get info() {\n        return 'Missing required features. You need to update your wallet.';\n    }\n    constructor(message, options) {\n        super(message, options);\n        Object.setPrototypeOf(this, WalletMissingRequiredFeaturesError.prototype);\n    }\n}\n\nclass WalletWrongNetworkError extends TonConnectError {\n    constructor(message, options) {\n        super(message, options);\n        this.name = 'WalletWrongNetworkError';\n        Object.setPrototypeOf(this, WalletWrongNetworkError.prototype);\n    }\n}\n\nfunction isWalletConnectionSourceJS(value) {\n    return 'jsBridgeKey' in value;\n}\nfunction isWalletConnectionSourceWalletConnect(value) {\n    return 'type' in value && value.type === 'wallet-connect';\n}\n\n/**\n * Thrown when user rejects the action in the wallet.\n */\nclass UserRejectsError extends TonConnectError {\n    get info() {\n        return 'User rejects the action in the wallet.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, UserRejectsError.prototype);\n    }\n}\n\n/**\n * Thrown when request to the wallet contains errors.\n */\nclass BadRequestError extends TonConnectError {\n    get info() {\n        return 'Request to the wallet contains errors.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, BadRequestError.prototype);\n    }\n}\n\n/**\n * Thrown when app tries to send rpc request to the injected wallet while not connected.\n */\nclass UnknownAppError extends TonConnectError {\n    get info() {\n        return 'App tries to send rpc request to the injected wallet while not connected.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, UnknownAppError.prototype);\n    }\n}\n\n/**\n * Thrown when `Storage` was not specified in the `DappMetadata` and default `localStorage` was not detected in the Node.js environment.\n */\nclass LocalstorageNotFoundError extends TonConnectError {\n    get info() {\n        return 'Storage was not specified in the `DappMetadata` and default `localStorage` was not detected in the environment.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, LocalstorageNotFoundError.prototype);\n    }\n}\n\n/**\n * Thrown when an error occurred while fetching the wallets list.\n */\nclass FetchWalletsError extends TonConnectError {\n    get info() {\n        return 'An error occurred while fetching the wallets list.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, FetchWalletsError.prototype);\n    }\n}\n\n/**\n * Thrown when passed address is in incorrect format.\n */\nclass WrongAddressError extends TonConnectError {\n    get info() {\n        return 'Passed address is in incorrect format.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, WrongAddressError.prototype);\n    }\n}\n\n/**\n * Thrown when passed hex is in incorrect format.\n */\nclass ParseHexError extends TonConnectError {\n    get info() {\n        return 'Passed hex is in incorrect format.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, ParseHexError.prototype);\n    }\n}\n\n/**\n * Unhanded unknown error.\n */\nclass UnknownError extends TonConnectError {\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, UnknownError.prototype);\n    }\n}\n\nconst connectEventErrorsCodes = {\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.MANIFEST_NOT_FOUND_ERROR]: ManifestNotFoundError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR]: ManifestContentErrorError\n};\nclass ConnectErrorsParser {\n    parseError(error) {\n        let ErrorConstructor = UnknownError;\n        if (error.code in connectEventErrorsCodes) {\n            ErrorConstructor = connectEventErrorsCodes[error.code] || UnknownError;\n        }\n        return new ErrorConstructor(error.message);\n    }\n}\nconst connectErrorsParser = new ConnectErrorsParser();\n\nclass RpcParser {\n    isError(response) {\n        return 'error' in response;\n    }\n}\n\nconst sendTransactionErrors = {\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError\n};\nclass SendTransactionParser extends RpcParser {\n    convertToRpcRequest(request) {\n        return {\n            method: 'sendTransaction',\n            params: [JSON.stringify(request)]\n        };\n    }\n    parseAndThrowError(response) {\n        let ErrorConstructor = UnknownError;\n        if (response.error.code in sendTransactionErrors) {\n            ErrorConstructor = sendTransactionErrors[response.error.code] || UnknownError;\n        }\n        throw new ErrorConstructor(response.error.message);\n    }\n    convertFromRpcResponse(rpcResponse) {\n        return {\n            boc: rpcResponse.result\n        };\n    }\n}\nconst sendTransactionParser = new SendTransactionParser();\n\nconst signDataErrors = {\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SIGN_DATA_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SIGN_DATA_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SIGN_DATA_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SIGN_DATA_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError\n};\nclass SignDataParser extends RpcParser {\n    convertToRpcRequest(payload) {\n        return {\n            method: 'signData',\n            params: [JSON.stringify(payload)]\n        };\n    }\n    parseAndThrowError(response) {\n        let ErrorConstructor = UnknownError;\n        if (response.error.code in signDataErrors) {\n            ErrorConstructor = signDataErrors[response.error.code] || UnknownError;\n        }\n        throw new ErrorConstructor(response.error.message);\n    }\n    convertFromRpcResponse(rpcResponse) {\n        return rpcResponse.result;\n    }\n}\nconst signDataParser = new SignDataParser();\n\nclass HttpBridgeGatewayStorage {\n    constructor(storage, bridgeUrl) {\n        this.storage = storage;\n        this.storeKey = 'ton-connect-storage_http-bridge-gateway::' + bridgeUrl;\n    }\n    storeLastEventId(lastEventId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.storage.setItem(this.storeKey, lastEventId);\n        });\n    }\n    removeLastEventId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.storage.removeItem(this.storeKey);\n        });\n    }\n    getLastEventId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const stored = yield this.storage.getItem(this.storeKey);\n            if (!stored) {\n                return null;\n            }\n            return stored;\n        });\n    }\n}\n\nfunction removeUrlLastSlash(url) {\n    if (url.slice(-1) === '/') {\n        return url.slice(0, -1);\n    }\n    return url;\n}\nfunction addPathToUrl(url, path) {\n    return removeUrlLastSlash(url) + '/' + path;\n}\nfunction isTelegramUrl(link) {\n    if (!link) {\n        return false;\n    }\n    const url = new URL(link);\n    return url.protocol === 'tg:' || url.hostname === 't.me';\n}\nfunction isConnectUrl(link) {\n    if (!link) {\n        return false;\n    }\n    return link.includes('ton_addr') || link.includes('ton--5Faddr');\n}\nfunction encodeTelegramUrlParameters(parameters) {\n    return parameters\n        .replaceAll('.', '%2E')\n        .replaceAll('-', '%2D')\n        .replaceAll('_', '%5F')\n        .replaceAll('&', '-')\n        .replaceAll('=', '__')\n        .replaceAll('%', '--');\n}\nfunction decodeTelegramUrlParameters(parameters) {\n    return parameters\n        .replaceAll('--', '%')\n        .replaceAll('__', '=')\n        .replaceAll('-', '&')\n        .replaceAll('%5F', '_')\n        .replaceAll('%2D', '-')\n        .replaceAll('%2E', '.');\n}\n\n/**\n * Delays the execution of code for a specified number of milliseconds.\n * @param {number} timeout - The number of milliseconds to delay the execution.\n * @param {DelayOptions} [options] - Optional configuration options for the delay.\n * @return {Promise<void>} - A promise that resolves after the specified delay, or rejects if the delay is aborted.\n */\nfunction delay(timeout, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            var _a, _b;\n            if ((_a = void 0 ) === null || _a === void 0 ? void 0 : _a.aborted) {\n                reject(new TonConnectError('Delay aborted'));\n                return;\n            }\n            const timeoutId = setTimeout(() => resolve(), timeout);\n            (_b = void 0 ) === null || _b === void 0 ? void 0 : _b.addEventListener('abort', () => {\n                clearTimeout(timeoutId);\n                reject(new TonConnectError('Delay aborted'));\n            });\n        });\n    });\n}\n\n/**\n * Creates an AbortController instance with an optional AbortSignal.\n *\n * @param {AbortSignal} [signal] - An optional AbortSignal to use for aborting the controller.\n * @returns {AbortController} - An instance of AbortController.\n */\nfunction createAbortController(signal) {\n    const abortController = new AbortController();\n    if (signal === null || signal === void 0 ? void 0 : signal.aborted) {\n        abortController.abort();\n    }\n    else {\n        signal === null || signal === void 0 ? void 0 : signal.addEventListener('abort', () => abortController.abort(), { once: true });\n    }\n    return abortController;\n}\n\n/**\n * Function to call ton api until we get response.\n * Because ton network is pretty unstable we need to make sure response is final.\n * @param {T} fn - function to call\n * @param {CallForSuccessOptions} [options] - optional configuration options\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction callForSuccess(fn, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        const attempts = (_a = options === null || options === void 0 ? void 0 : options.attempts) !== null && _a !== void 0 ? _a : 10;\n        const delayMs = (_b = options === null || options === void 0 ? void 0 : options.delayMs) !== null && _b !== void 0 ? _b : 200;\n        const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n        if (typeof fn !== 'function') {\n            throw new TonConnectError(`Expected a function, got ${typeof fn}`);\n        }\n        let i = 0;\n        let lastError;\n        while (i < attempts) {\n            if (abortController.signal.aborted) {\n                throw new TonConnectError(`Aborted after attempts ${i}`);\n            }\n            try {\n                return yield fn({ signal: abortController.signal });\n            }\n            catch (err) {\n                lastError = err;\n                i++;\n                if (i < attempts) {\n                    yield delay(delayMs);\n                }\n            }\n        }\n        throw lastError;\n    });\n}\n\nfunction logDebug(...args) {\n    {\n        try {\n            console.debug('[TON_CONNECT_SDK]', ...args);\n        }\n        catch (_a) { }\n    }\n}\nfunction logError(...args) {\n    {\n        try {\n            console.error('[TON_CONNECT_SDK]', ...args);\n        }\n        catch (_a) { }\n    }\n}\nfunction logWarning(...args) {\n    {\n        try {\n            console.warn('[TON_CONNECT_SDK]', ...args);\n        }\n        catch (_a) { }\n    }\n}\n\n/**\n * Create a resource.\n *\n * @template T - The type of the resource.\n * @template Args - The type of the arguments for creating the resource.\n *\n * @param {(...args: Args) => Promise<T>} createFn - A function that creates the resource.\n * @param {(resource: T) => Promise<void>} [disposeFn] - An optional function that disposes the resource.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction createResource(createFn, disposeFn) {\n    let currentResource = null;\n    let currentArgs = null;\n    let currentPromise = null;\n    let currentSignal = null;\n    let abortController = null;\n    // create a new resource\n    const create = (signal, ...args) => __awaiter(this, void 0, void 0, function* () {\n        currentSignal = signal !== null && signal !== void 0 ? signal : null;\n        abortController === null || abortController === void 0 ? void 0 : abortController.abort();\n        abortController = createAbortController(signal);\n        if (abortController.signal.aborted) {\n            throw new TonConnectError('Resource creation was aborted');\n        }\n        currentArgs = args !== null && args !== void 0 ? args : null;\n        const promise = createFn(abortController.signal, ...args);\n        currentPromise = promise;\n        const resource = yield promise;\n        if (currentPromise !== promise && resource !== currentResource) {\n            yield disposeFn(resource);\n            throw new TonConnectError('Resource creation was aborted by a new resource creation');\n        }\n        currentResource = resource;\n        return currentResource;\n    });\n    // get the current resource\n    const current = () => {\n        return currentResource !== null && currentResource !== void 0 ? currentResource : null;\n    };\n    // dispose the current resource\n    const dispose = () => __awaiter(this, void 0, void 0, function* () {\n        try {\n            const resource = currentResource;\n            currentResource = null;\n            const promise = currentPromise;\n            currentPromise = null;\n            try {\n                abortController === null || abortController === void 0 ? void 0 : abortController.abort();\n            }\n            catch (e) { }\n            yield Promise.allSettled([\n                resource ? disposeFn(resource) : Promise.resolve(),\n                promise ? disposeFn(yield promise) : Promise.resolve()\n            ]);\n        }\n        catch (e) { }\n    });\n    // recreate the current resource\n    const recreate = (delayMs) => __awaiter(this, void 0, void 0, function* () {\n        const resource = currentResource;\n        const promise = currentPromise;\n        const args = currentArgs;\n        const signal = currentSignal;\n        yield delay(delayMs);\n        if (resource === currentResource &&\n            promise === currentPromise &&\n            args === currentArgs &&\n            signal === currentSignal) {\n            return yield create(currentSignal, ...(args !== null && args !== void 0 ? args : []));\n        }\n        throw new TonConnectError('Resource recreation was aborted by a new resource creation');\n    });\n    return {\n        create,\n        current,\n        dispose,\n        recreate\n    };\n}\n\n/**\n * Executes a function and provides deferred behavior, allowing for a timeout and abort functionality.\n *\n * @param {Deferrable<T>} fn - The function to execute. It should return a promise that resolves with the desired result.\n * @param {DeferOptions} options - Optional configuration options for the defer behavior.\n * @returns {Promise<T>} - A promise that resolves with the result of the executed function, or rejects with an error if it times out or is aborted.\n */\nfunction timeout(fn, options) {\n    const timeout = options === null || options === void 0 ? void 0 : options.timeout;\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    const abortController = createAbortController(signal);\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n        if (abortController.signal.aborted) {\n            reject(new TonConnectError('Operation aborted'));\n            return;\n        }\n        let timeoutId;\n        if (typeof timeout !== 'undefined') {\n            timeoutId = setTimeout(() => {\n                abortController.abort();\n                reject(new TonConnectError(`Timeout after ${timeout}ms`));\n            }, timeout);\n        }\n        abortController.signal.addEventListener('abort', () => {\n            clearTimeout(timeoutId);\n            reject(new TonConnectError('Operation aborted'));\n        }, { once: true });\n        const deferOptions = { timeout, abort: abortController.signal };\n        yield fn((...args) => {\n            clearTimeout(timeoutId);\n            resolve(...args);\n        }, () => {\n            clearTimeout(timeoutId);\n            reject();\n        }, deferOptions);\n    }));\n}\n\nclass BridgeGateway {\n    get isReady() {\n        const eventSource = this.eventSource.current();\n        return (eventSource === null || eventSource === void 0 ? void 0 : eventSource.readyState) === EventSource.OPEN;\n    }\n    get isClosed() {\n        const eventSource = this.eventSource.current();\n        return (eventSource === null || eventSource === void 0 ? void 0 : eventSource.readyState) !== EventSource.OPEN;\n    }\n    get isConnecting() {\n        const eventSource = this.eventSource.current();\n        return (eventSource === null || eventSource === void 0 ? void 0 : eventSource.readyState) === EventSource.CONNECTING;\n    }\n    constructor(storage, bridgeUrl, sessionId, listener, errorsListener, analyticsManager) {\n        this.bridgeUrl = bridgeUrl;\n        this.sessionId = sessionId;\n        this.listener = listener;\n        this.errorsListener = errorsListener;\n        this.ssePath = 'events';\n        this.postPath = 'message';\n        this.heartbeatMessage = 'heartbeat';\n        this.defaultTtl = 300;\n        this.defaultReconnectDelay = 2000;\n        this.defaultResendDelay = 5000;\n        this.eventSource = createResource((signal, openingDeadlineMS, traceId) => __awaiter(this, void 0, void 0, function* () {\n            const eventSourceConfig = {\n                bridgeUrl: this.bridgeUrl,\n                ssePath: this.ssePath,\n                sessionId: this.sessionId,\n                bridgeGatewayStorage: this.bridgeGatewayStorage,\n                errorHandler: this.errorsHandler.bind(this),\n                messageHandler: this.messagesHandler.bind(this),\n                signal: signal,\n                openingDeadlineMS: openingDeadlineMS,\n                traceId\n            };\n            return yield createEventSource(eventSourceConfig);\n        }), (resource) => __awaiter(this, void 0, void 0, function* () {\n            resource.close();\n        }));\n        this.bridgeGatewayStorage = new HttpBridgeGatewayStorage(storage, bridgeUrl);\n        this.analytics = analyticsManager === null || analyticsManager === void 0 ? void 0 : analyticsManager.scoped({\n            bridge_url: bridgeUrl,\n            client_id: sessionId\n        });\n    }\n    registerSession(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            try {\n                (_a = this.analytics) === null || _a === void 0 ? void 0 : _a.emitBridgeClientConnectStarted({\n                    trace_id: options === null || options === void 0 ? void 0 : options.traceId\n                });\n                const connectionStarted = Date.now();\n                yield this.eventSource.create(options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.openingDeadlineMS, options === null || options === void 0 ? void 0 : options.traceId);\n                const bridgeConnectDuration = Date.now() - connectionStarted;\n                (_b = this.analytics) === null || _b === void 0 ? void 0 : _b.emitBridgeClientConnectEstablished({\n                    bridge_connect_duration: bridgeConnectDuration,\n                    trace_id: options === null || options === void 0 ? void 0 : options.traceId\n                });\n            }\n            catch (error) {\n                (_c = this.analytics) === null || _c === void 0 ? void 0 : _c.emitBridgeClientConnectError({\n                    trace_id: options === null || options === void 0 ? void 0 : options.traceId,\n                    error_message: String(error)\n                });\n                throw error;\n            }\n        });\n    }\n    send(message, receiver, topic, ttlOrOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            // TODO: remove deprecated method\n            const options = {};\n            if (typeof ttlOrOptions === 'number') {\n                options.ttl = ttlOrOptions;\n            }\n            else {\n                options.ttl = ttlOrOptions === null || ttlOrOptions === void 0 ? void 0 : ttlOrOptions.ttl;\n                options.signal = ttlOrOptions === null || ttlOrOptions === void 0 ? void 0 : ttlOrOptions.signal;\n                options.attempts = ttlOrOptions === null || ttlOrOptions === void 0 ? void 0 : ttlOrOptions.attempts;\n                options.traceId = ttlOrOptions === null || ttlOrOptions === void 0 ? void 0 : ttlOrOptions.traceId;\n            }\n            const url = new URL(addPathToUrl(this.bridgeUrl, this.postPath));\n            url.searchParams.append('client_id', this.sessionId);\n            url.searchParams.append('to', receiver);\n            url.searchParams.append('ttl', ((options === null || options === void 0 ? void 0 : options.ttl) || this.defaultTtl).toString());\n            url.searchParams.append('topic', topic);\n            if (options === null || options === void 0 ? void 0 : options.traceId) {\n                url.searchParams.append('trace_id', options.traceId);\n            }\n            const body = _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.Base64.encode(message);\n            yield callForSuccess((options) => __awaiter(this, void 0, void 0, function* () {\n                const response = yield this.post(url, body, options.signal);\n                if (!response.ok) {\n                    throw new TonConnectError(`Bridge send failed, status ${response.status}`);\n                }\n            }), {\n                attempts: (_a = options === null || options === void 0 ? void 0 : options.attempts) !== null && _a !== void 0 ? _a : Number.MAX_SAFE_INTEGER,\n                delayMs: this.defaultResendDelay,\n                signal: options === null || options === void 0 ? void 0 : options.signal\n            });\n        });\n    }\n    pause() {\n        this.eventSource.dispose().catch(e => logError(`Bridge pause failed, ${e}`));\n    }\n    unPause() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const RECREATE_WITHOUT_DELAY = 0;\n            yield this.eventSource.recreate(RECREATE_WITHOUT_DELAY);\n        });\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.eventSource.dispose().catch(e => logError(`Bridge close failed, ${e}`));\n        });\n    }\n    setListener(listener) {\n        this.listener = listener;\n    }\n    setErrorsListener(errorsListener) {\n        this.errorsListener = errorsListener;\n    }\n    post(url, body, signal) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(url, {\n                method: 'post',\n                body: body,\n                signal: signal\n            });\n            if (!response.ok) {\n                throw new TonConnectError(`Bridge send failed, status ${response.status}`);\n            }\n            return response;\n        });\n    }\n    errorsHandler(eventSource, e) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.isConnecting) {\n                eventSource.close();\n                throw new TonConnectError('Bridge error, failed to connect');\n            }\n            if (this.isReady) {\n                try {\n                    this.errorsListener(e);\n                }\n                catch (e) { }\n                return;\n            }\n            if (this.isClosed) {\n                eventSource.close();\n                logDebug(`Bridge reconnecting, ${this.defaultReconnectDelay}ms delay`);\n                return yield this.eventSource.recreate(this.defaultReconnectDelay);\n            }\n            throw new TonConnectError('Bridge error, unknown state');\n        });\n    }\n    messagesHandler(e) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (e.data === this.heartbeatMessage) {\n                return;\n            }\n            yield this.bridgeGatewayStorage.storeLastEventId(e.lastEventId);\n            if (this.isClosed) {\n                return;\n            }\n            let bridgeIncomingMessage;\n            try {\n                const bridgeIncomingMessageRaw = JSON.parse(e.data);\n                bridgeIncomingMessage = {\n                    message: bridgeIncomingMessageRaw.message,\n                    from: bridgeIncomingMessageRaw.from,\n                    traceId: bridgeIncomingMessageRaw.trace_id\n                };\n            }\n            catch (_) {\n                throw new TonConnectError(`Bridge message parse failed, message ${e.data}`);\n            }\n            this.listener(bridgeIncomingMessage);\n        });\n    }\n}\n/**\n * Creates an event source.\n * @param {CreateEventSourceConfig} config - Configuration for creating an event source.\n */\nfunction createEventSource(config) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield timeout((resolve, reject, deferOptions) => __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const abortController = createAbortController(deferOptions.signal);\n            const signal = abortController.signal;\n            if (signal.aborted) {\n                reject(new TonConnectError('Bridge connection aborted'));\n                return;\n            }\n            const url = new URL(addPathToUrl(config.bridgeUrl, config.ssePath));\n            url.searchParams.append('client_id', config.sessionId);\n            const lastEventId = yield config.bridgeGatewayStorage.getLastEventId();\n            if (lastEventId) {\n                url.searchParams.append('last_event_id', lastEventId);\n            }\n            if (config.traceId) {\n                url.searchParams.append('trace_id', config.traceId);\n            }\n            if (signal.aborted) {\n                reject(new TonConnectError('Bridge connection aborted'));\n                return;\n            }\n            const eventSource = new EventSource(url.toString());\n            eventSource.onerror = (reason) => __awaiter(this, void 0, void 0, function* () {\n                if (signal.aborted) {\n                    eventSource.close();\n                    reject(new TonConnectError('Bridge connection aborted'));\n                    return;\n                }\n                try {\n                    const newInstance = yield config.errorHandler(eventSource, reason);\n                    if (newInstance !== eventSource) {\n                        eventSource.close();\n                    }\n                    if (newInstance && newInstance !== eventSource) {\n                        resolve(newInstance);\n                    }\n                }\n                catch (e) {\n                    eventSource.close();\n                    reject(e);\n                }\n            });\n            eventSource.onopen = () => {\n                if (signal.aborted) {\n                    eventSource.close();\n                    reject(new TonConnectError('Bridge connection aborted'));\n                    return;\n                }\n                resolve(eventSource);\n            };\n            eventSource.onmessage = (event) => {\n                if (signal.aborted) {\n                    eventSource.close();\n                    reject(new TonConnectError('Bridge connection aborted'));\n                    return;\n                }\n                config.messageHandler(event);\n            };\n            (_a = config.signal) === null || _a === void 0 ? void 0 : _a.addEventListener('abort', () => {\n                eventSource.close();\n                reject(new TonConnectError('Bridge connection aborted'));\n            });\n        }), { timeout: config.openingDeadlineMS, signal: config.signal });\n    });\n}\n\nconst CONNECTION_HTTP_EXPIRATION_TIME = 5 * 60 * 1000;\nfunction isPendingConnectionHttp(connection) {\n    return !('connectEvent' in connection);\n}\nfunction isPendingConnectionHttpRaw(connection) {\n    return !('connectEvent' in connection);\n}\nfunction isExpiredPendingConnectionHttpRaw(connection) {\n    var _a;\n    return Date.now() - ((_a = connection.createdAt) !== null && _a !== void 0 ? _a : 0) > CONNECTION_HTTP_EXPIRATION_TIME;\n}\n\nconst PROTOCOL_VERSION = 2;\n\n/**\n * The MIT License (MIT)\n *\n * Copyright (c) 2010-2020 Robert Kieffer and other contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nfunction rng() {\n    // lazy load so that environments that need to polyfill have a chance to do so\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n\n/**\n * The MIT License (MIT)\n *\n * Copyright (c) 2010-2020 Robert Kieffer and other contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n    // Note: Be careful editing this code!  It's been tuned for performance\n    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n    //\n    // Note to future-self: No, you can't remove the `toLowerCase()` call.\n    // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\n\n/**\n * The MIT License (MIT)\n *\n * Copyright (c) 2010-2020 Robert Kieffer and other contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nconst _state = {};\nfunction UUIDv7(options, buf, offset) {\n    var _a, _b, _c;\n    let bytes;\n    if (options) {\n        // With options: Make UUID independent of internal state\n        bytes = v7Bytes((_c = (_a = options.random) !== null && _a !== void 0 ? _a : (_b = options.rng) === null || _b === void 0 ? void 0 : _b.call(options)) !== null && _c !== void 0 ? _c : rng(), options.msecs, options.seq, buf, offset);\n    }\n    else {\n        // No options: Use internal state\n        const now = Date.now();\n        const rnds = rng();\n        updateV7State(_state, now, rnds);\n        bytes = v7Bytes(rnds, _state.msecs, _state.seq, buf, offset);\n    }\n    return buf !== null && buf !== void 0 ? buf : unsafeStringify(bytes);\n}\n// (Private!)  Do not use.  This method is only exported for testing purposes\n// and may change without notice.\nfunction updateV7State(state, now, rnds) {\n    var _a, _b;\n    (_a = state.msecs) !== null && _a !== void 0 ? _a : (state.msecs = -Infinity);\n    (_b = state.seq) !== null && _b !== void 0 ? _b : (state.seq = 0);\n    if (now > state.msecs) {\n        // Time has moved on! Pick a new random sequence number\n        state.seq = (rnds[6] << 23) | (rnds[7] << 16) | (rnds[8] << 8) | rnds[9];\n        state.msecs = now;\n    }\n    else {\n        // Bump sequence counter w/ 32-bit rollover\n        state.seq = (state.seq + 1) | 0;\n        // In case of rollover, bump timestamp to preserve monotonicity. This is\n        // allowed by the RFC and should self-correct as the system clock catches\n        // up. See https://www.rfc-editor.org/rfc/rfc9562.html#section-6.2-9.4\n        if (state.seq === 0) {\n            state.msecs++;\n        }\n    }\n    return state;\n}\nfunction v7Bytes(rnds, msecs, seq, buf, offset = 0) {\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    if (!buf) {\n        buf = new Uint8Array(16);\n        offset = 0;\n    }\n    else {\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n    }\n    // Defaults\n    msecs !== null && msecs !== void 0 ? msecs : (msecs = Date.now());\n    seq !== null && seq !== void 0 ? seq : (seq = ((rnds[6] * 0x7f) << 24) | (rnds[7] << 16) | (rnds[8] << 8) | rnds[9]);\n    // byte 0-5: timestamp (48 bits)\n    buf[offset++] = (msecs / 0x10000000000) & 0xff;\n    buf[offset++] = (msecs / 0x100000000) & 0xff;\n    buf[offset++] = (msecs / 0x1000000) & 0xff;\n    buf[offset++] = (msecs / 0x10000) & 0xff;\n    buf[offset++] = (msecs / 0x100) & 0xff;\n    buf[offset++] = msecs & 0xff;\n    // byte 6: `version` (4 bits) | sequence bits 28-31 (4 bits)\n    buf[offset++] = 0x70 | ((seq >>> 28) & 0x0f);\n    // byte 7: sequence bits 20-27 (8 bits)\n    buf[offset++] = (seq >>> 20) & 0xff;\n    // byte 8: `variant` (2 bits) | sequence bits 14-19 (6 bits)\n    buf[offset++] = 0x80 | ((seq >>> 14) & 0x3f);\n    // byte 9: sequence bits 6-13 (8 bits)\n    buf[offset++] = (seq >>> 6) & 0xff;\n    // byte 10: sequence bits 0-5 (6 bits) | random (2 bits)\n    buf[offset++] = ((seq << 2) & 0xff) | (rnds[10] & 0x03);\n    // bytes 11-15: random (40 bits)\n    buf[offset++] = rnds[11];\n    buf[offset++] = rnds[12];\n    buf[offset++] = rnds[13];\n    buf[offset++] = rnds[14];\n    buf[offset++] = rnds[15];\n    return buf;\n}\n\nfunction waitForSome(promises, count) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (count <= 0)\n            return [];\n        if (count > promises.length) {\n            throw new RangeError('count cannot be greater than the number of promises');\n        }\n        const results = new Array(promises.length);\n        let settledCount = 0;\n        return new Promise(resolve => {\n            promises.forEach((p, index) => {\n                Promise.resolve(p)\n                    .then(value => ({ status: 'fulfilled', value }))\n                    .catch(reason => ({ status: 'rejected', reason }))\n                    .then(result => {\n                    results[index] = result;\n                    settledCount++;\n                    if (settledCount === count) {\n                        resolve(results);\n                    }\n                });\n            });\n        });\n    });\n}\n\nclass BridgeProvider {\n    static fromStorage(storage, analyticsManager) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield storage.getHttpConnection();\n            if (isPendingConnectionHttp(connection)) {\n                return new BridgeProvider(storage, connection.connectionSource, analyticsManager);\n            }\n            return new BridgeProvider(storage, { bridgeUrl: connection.session.bridgeUrl }, analyticsManager);\n        });\n    }\n    constructor(connectionStorage, walletConnectionSource, analyticsManager) {\n        var _a;\n        this.connectionStorage = connectionStorage;\n        this.walletConnectionSource = walletConnectionSource;\n        this.analyticsManager = analyticsManager;\n        this.type = 'http';\n        this.standardUniversalLink = 'tc://';\n        this.pendingRequests = new Map();\n        this.session = null;\n        this.gateway = null;\n        this.pendingGateways = [];\n        this.listeners = [];\n        this.defaultOpeningDeadlineMS = 12000;\n        this.defaultRetryTimeoutMS = 2000;\n        this.optionalOpenGateways = 3;\n        this.analytics = (_a = this.analyticsManager) === null || _a === void 0 ? void 0 : _a.scoped();\n    }\n    connect(message, options) {\n        var _a, _b;\n        const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n        const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n        (_b = this.abortController) === null || _b === void 0 ? void 0 : _b.abort();\n        this.abortController = abortController;\n        this.closeGateways();\n        const sessionCrypto = new _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SessionCrypto();\n        this.session = {\n            sessionCrypto,\n            bridgeUrl: 'bridgeUrl' in this.walletConnectionSource\n                ? this.walletConnectionSource.bridgeUrl\n                : ''\n        };\n        this.connectionStorage\n            .storeConnection({\n            type: 'http',\n            connectionSource: this.walletConnectionSource,\n            sessionCrypto\n        })\n            .then(() => __awaiter(this, void 0, void 0, function* () {\n            if (abortController.signal.aborted) {\n                return;\n            }\n            yield callForSuccess(_options => {\n                var _a;\n                return this.openGateways(sessionCrypto, {\n                    openingDeadlineMS: (_a = options === null || options === void 0 ? void 0 : options.openingDeadlineMS) !== null && _a !== void 0 ? _a : this.defaultOpeningDeadlineMS,\n                    signal: _options === null || _options === void 0 ? void 0 : _options.signal,\n                    traceId\n                });\n            }, {\n                attempts: Number.MAX_SAFE_INTEGER,\n                delayMs: this.defaultRetryTimeoutMS,\n                signal: abortController.signal\n            });\n        }));\n        const universalLink = 'universalLink' in this.walletConnectionSource &&\n            this.walletConnectionSource.universalLink\n            ? this.walletConnectionSource.universalLink\n            : this.standardUniversalLink;\n        return this.generateUniversalLink(universalLink, message, { traceId });\n    }\n    restoreConnection(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n            (_b = this.abortController) === null || _b === void 0 ? void 0 : _b.abort();\n            this.abortController = abortController;\n            if (abortController.signal.aborted) {\n                return;\n            }\n            this.closeGateways();\n            const storedConnection = yield this.connectionStorage.getHttpConnection();\n            if (!storedConnection) {\n                return;\n            }\n            if (abortController.signal.aborted) {\n                return;\n            }\n            const openingDeadlineMS = (_c = options === null || options === void 0 ? void 0 : options.openingDeadlineMS) !== null && _c !== void 0 ? _c : this.defaultOpeningDeadlineMS;\n            if (isPendingConnectionHttp(storedConnection)) {\n                this.session = {\n                    sessionCrypto: storedConnection.sessionCrypto,\n                    bridgeUrl: 'bridgeUrl' in this.walletConnectionSource\n                        ? this.walletConnectionSource.bridgeUrl\n                        : ''\n                };\n                return yield this.openGateways(storedConnection.sessionCrypto, {\n                    openingDeadlineMS: openingDeadlineMS,\n                    signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal,\n                    traceId: options === null || options === void 0 ? void 0 : options.traceId\n                });\n            }\n            if (Array.isArray(this.walletConnectionSource)) {\n                throw new TonConnectError('Internal error. Connection source is array while WalletConnectionSourceHTTP was expected.');\n            }\n            this.session = storedConnection.session;\n            if (this.gateway) {\n                logDebug('Gateway is already opened, closing previous gateway');\n                yield this.gateway.close();\n            }\n            this.gateway = new BridgeGateway(this.connectionStorage.storage, this.walletConnectionSource.bridgeUrl, storedConnection.session.sessionCrypto.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this), this.analyticsManager);\n            if (abortController.signal.aborted) {\n                return;\n            }\n            // notify listeners about stored connection\n            this.listeners.forEach(listener => listener(Object.assign(Object.assign({}, storedConnection.connectEvent), { traceId })));\n            // wait for the connection to be opened\n            try {\n                yield callForSuccess(options => this.gateway.registerSession({\n                    openingDeadlineMS: openingDeadlineMS,\n                    signal: options.signal,\n                    traceId\n                }), {\n                    attempts: Number.MAX_SAFE_INTEGER,\n                    delayMs: this.defaultRetryTimeoutMS,\n                    signal: abortController.signal\n                });\n            }\n            catch (e) {\n                yield this.disconnect({ signal: abortController.signal, traceId });\n                return;\n            }\n        });\n    }\n    sendRequest(request, optionsOrOnRequestSent) {\n        var _a;\n        // TODO: remove deprecated method\n        const options = {};\n        if (typeof optionsOrOnRequestSent === 'function') {\n            options.onRequestSent = optionsOrOnRequestSent;\n        }\n        else {\n            options.onRequestSent = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.onRequestSent;\n            options.signal = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.signal;\n            options.attempts = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.attempts;\n            options.traceId = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.traceId;\n        }\n        (_a = options.traceId) !== null && _a !== void 0 ? _a : (options.traceId = UUIDv7());\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            if (!this.gateway || !this.session || !('walletPublicKey' in this.session)) {\n                throw new TonConnectError('Trying to send bridge request without session');\n            }\n            const id = (yield this.connectionStorage.getNextRpcRequestId()).toString();\n            yield this.connectionStorage.increaseNextRpcRequestId();\n            logDebug('Send http-bridge request:', Object.assign(Object.assign({}, request), { id }));\n            const encodedRequest = this.session.sessionCrypto.encrypt(JSON.stringify(Object.assign(Object.assign({}, request), { id })), (0,_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.hexToByteArray)(this.session.walletPublicKey));\n            try {\n                (_a = this.analytics) === null || _a === void 0 ? void 0 : _a.emitBridgeClientMessageSent({\n                    bridge_url: this.gateway.bridgeUrl,\n                    client_id: this.session.sessionCrypto.sessionId,\n                    wallet_id: this.session.walletPublicKey,\n                    message_id: id,\n                    request_type: request.method,\n                    trace_id: options.traceId\n                });\n                yield this.gateway.send(encodedRequest, this.session.walletPublicKey, request.method, {\n                    attempts: options === null || options === void 0 ? void 0 : options.attempts,\n                    signal: options === null || options === void 0 ? void 0 : options.signal,\n                    traceId: options.traceId\n                });\n                (_b = options === null || options === void 0 ? void 0 : options.onRequestSent) === null || _b === void 0 ? void 0 : _b.call(options);\n                this.pendingRequests.set(id.toString(), resolve);\n            }\n            catch (e) {\n                reject(e);\n            }\n        }));\n    }\n    closeConnection() {\n        this.closeGateways();\n        this.listeners = [];\n        this.session = null;\n        this.gateway = null;\n    }\n    disconnect(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                let called = false;\n                let timeoutId = null;\n                const onRequestSent = () => {\n                    if (!called) {\n                        called = true;\n                        this.removeBridgeAndSession().then(resolve);\n                    }\n                };\n                try {\n                    this.closeGateways();\n                    const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n                    timeoutId = setTimeout(() => {\n                        abortController.abort();\n                    }, this.defaultOpeningDeadlineMS);\n                    yield this.sendRequest({ method: 'disconnect', params: [] }, {\n                        onRequestSent: onRequestSent,\n                        signal: abortController.signal,\n                        attempts: 1,\n                        traceId\n                    });\n                }\n                catch (e) {\n                    logDebug('Disconnect error:', e);\n                    if (!called) {\n                        this.removeBridgeAndSession().then(resolve);\n                    }\n                }\n                finally {\n                    if (timeoutId) {\n                        clearTimeout(timeoutId);\n                    }\n                    onRequestSent();\n                }\n            }));\n        });\n    }\n    listen(callback) {\n        this.listeners.push(callback);\n        return () => (this.listeners = this.listeners.filter(listener => listener !== callback));\n    }\n    pause() {\n        var _a;\n        (_a = this.gateway) === null || _a === void 0 ? void 0 : _a.pause();\n        this.pendingGateways.forEach(bridge => bridge.pause());\n    }\n    unPause() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const promises = this.pendingGateways.map(bridge => bridge.unPause());\n            if (this.gateway) {\n                promises.push(this.gateway.unPause());\n            }\n            yield Promise.all(promises);\n        });\n    }\n    pendingGatewaysListener(gateway, bridgeUrl, bridgeIncomingMessage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.pendingGateways.includes(gateway)) {\n                yield gateway.close();\n                return;\n            }\n            this.closeGateways({ except: gateway });\n            if (this.gateway) {\n                logDebug('Gateway is already opened, closing previous gateway');\n                yield this.gateway.close();\n            }\n            this.session.bridgeUrl = bridgeUrl;\n            this.gateway = gateway;\n            this.gateway.setErrorsListener(this.gatewayErrorsListener.bind(this));\n            this.gateway.setListener(this.gatewayListener.bind(this));\n            return this.gatewayListener(bridgeIncomingMessage);\n        });\n    }\n    gatewayListener(bridgeIncomingMessage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            const traceId = (_a = bridgeIncomingMessage.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            let walletMessage;\n            try {\n                walletMessage = JSON.parse(this.session.sessionCrypto.decrypt(_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.Base64.decode(bridgeIncomingMessage.message).toUint8Array(), (0,_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.hexToByteArray)(bridgeIncomingMessage.from)));\n            }\n            catch (err) {\n                (_b = this.analytics) === null || _b === void 0 ? void 0 : _b.emitBridgeClientMessageDecodeError({\n                    bridge_url: this.session.bridgeUrl,\n                    client_id: this.session.sessionCrypto.sessionId,\n                    wallet_id: bridgeIncomingMessage.from,\n                    error_message: String(err),\n                    trace_id: bridgeIncomingMessage === null || bridgeIncomingMessage === void 0 ? void 0 : bridgeIncomingMessage.traceId\n                });\n                throw err;\n            }\n            logDebug('Wallet message received:', walletMessage);\n            const requestType = 'event' in walletMessage ? walletMessage.event : '';\n            (_c = this.analytics) === null || _c === void 0 ? void 0 : _c.emitBridgeClientMessageReceived({\n                bridge_url: this.session.bridgeUrl,\n                client_id: this.session.sessionCrypto.sessionId,\n                wallet_id: bridgeIncomingMessage.from,\n                message_id: String(walletMessage.id),\n                request_type: requestType,\n                trace_id: bridgeIncomingMessage === null || bridgeIncomingMessage === void 0 ? void 0 : bridgeIncomingMessage.traceId\n            });\n            if (!('event' in walletMessage)) {\n                const id = walletMessage.id.toString();\n                const resolve = this.pendingRequests.get(id);\n                if (!resolve) {\n                    logDebug(`Response id ${id} doesn't match any request's id`);\n                    return;\n                }\n                resolve(Object.assign(Object.assign({}, walletMessage), { traceId }));\n                this.pendingRequests.delete(id);\n                return;\n            }\n            if (walletMessage.id !== undefined) {\n                const lastId = yield this.connectionStorage.getLastWalletEventId();\n                if (lastId !== undefined && walletMessage.id <= lastId) {\n                    logError(`Received event id (=${walletMessage.id}) must be greater than stored last wallet event id (=${lastId}) `);\n                    return;\n                }\n                if (walletMessage.event !== 'connect') {\n                    yield this.connectionStorage.storeLastWalletEventId(walletMessage.id);\n                }\n            }\n            // `this.listeners` might be modified in the event handler\n            const listeners = this.listeners;\n            if (walletMessage.event === 'connect') {\n                yield this.updateSession(walletMessage, bridgeIncomingMessage.from);\n            }\n            if (walletMessage.event === 'disconnect') {\n                logDebug(`Removing bridge and session: received disconnect event`);\n                yield this.removeBridgeAndSession();\n            }\n            listeners.forEach(listener => listener(Object.assign(Object.assign({}, walletMessage), { traceId })));\n        });\n    }\n    gatewayErrorsListener(e) {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new TonConnectError(`Bridge error ${JSON.stringify(e)}`);\n        });\n    }\n    updateSession(connectEvent, walletPublicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.session = Object.assign(Object.assign({}, this.session), { walletPublicKey });\n            const tonAddrItem = connectEvent.payload.items.find(item => item.name === 'ton_addr');\n            const connectEventToSave = Object.assign(Object.assign({}, connectEvent), { payload: Object.assign(Object.assign({}, connectEvent.payload), { items: [tonAddrItem] }) });\n            yield this.connectionStorage.storeConnection({\n                type: 'http',\n                session: this.session,\n                lastWalletEventId: connectEvent.id,\n                connectEvent: connectEventToSave,\n                nextRpcRequestId: 0\n            });\n        });\n    }\n    removeBridgeAndSession() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.closeConnection();\n            yield this.connectionStorage.removeConnection();\n        });\n    }\n    generateUniversalLink(universalLink, message, options) {\n        if (isTelegramUrl(universalLink)) {\n            return this.generateTGUniversalLink(universalLink, message, options);\n        }\n        return this.generateRegularUniversalLink(universalLink, message, options);\n    }\n    generateRegularUniversalLink(universalLink, message, options) {\n        const url = new URL(universalLink);\n        url.searchParams.append('v', PROTOCOL_VERSION.toString());\n        url.searchParams.append('id', this.session.sessionCrypto.sessionId);\n        url.searchParams.append('trace_id', options.traceId);\n        url.searchParams.append('r', JSON.stringify(message));\n        return url.toString();\n    }\n    generateTGUniversalLink(universalLink, message, options) {\n        const urlToWrap = this.generateRegularUniversalLink('about:blank', message, options);\n        const linkParams = urlToWrap.split('?')[1];\n        const startapp = 'tonconnect-' + encodeTelegramUrlParameters(linkParams);\n        // TODO: Remove this line after all dApps and the wallets-list.json have been updated\n        const updatedUniversalLink = this.convertToDirectLink(universalLink);\n        const url = new URL(updatedUniversalLink);\n        url.searchParams.append('startapp', startapp);\n        return url.toString();\n    }\n    // TODO: Remove this method after all dApps and the wallets-list.json have been updated\n    convertToDirectLink(universalLink) {\n        const url = new URL(universalLink);\n        if (url.searchParams.has('attach')) {\n            url.searchParams.delete('attach');\n            url.pathname += '/start';\n        }\n        return url.toString();\n    }\n    openGateways(sessionCrypto, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            if (Array.isArray(this.walletConnectionSource)) {\n                // close all gateways before opening new ones\n                this.pendingGateways.map(bridge => bridge.close().catch());\n                // open new gateways\n                this.pendingGateways = this.walletConnectionSource.map(source => {\n                    const gateway = new BridgeGateway(this.connectionStorage.storage, source.bridgeUrl, sessionCrypto.sessionId, () => { }, () => { }, this.analyticsManager);\n                    gateway.setListener(message => this.pendingGatewaysListener(gateway, source.bridgeUrl, message));\n                    return gateway;\n                });\n                // Wait until the specified optional gateways are opened, not necessarily all gateways\n                const gatewaysToWaitFor = Math.max(this.pendingGateways.length - this.optionalOpenGateways, 1);\n                yield waitForSome(this.pendingGateways.map(bridge => callForSuccess((_options) => {\n                    var _a;\n                    if (!this.pendingGateways.some(item => item === bridge)) {\n                        return bridge.close();\n                    }\n                    return bridge.registerSession({\n                        openingDeadlineMS: (_a = options === null || options === void 0 ? void 0 : options.openingDeadlineMS) !== null && _a !== void 0 ? _a : this.defaultOpeningDeadlineMS,\n                        signal: _options.signal,\n                        traceId\n                    });\n                }, {\n                    attempts: Number.MAX_SAFE_INTEGER,\n                    delayMs: this.defaultRetryTimeoutMS,\n                    signal: options === null || options === void 0 ? void 0 : options.signal\n                })), gatewaysToWaitFor);\n                return;\n            }\n            else {\n                if (this.gateway) {\n                    logDebug(`Gateway is already opened, closing previous gateway`);\n                    yield this.gateway.close();\n                }\n                this.gateway = new BridgeGateway(this.connectionStorage.storage, this.walletConnectionSource.bridgeUrl, sessionCrypto.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this), this.analyticsManager);\n                return yield this.gateway.registerSession({\n                    openingDeadlineMS: options === null || options === void 0 ? void 0 : options.openingDeadlineMS,\n                    signal: options === null || options === void 0 ? void 0 : options.signal,\n                    traceId\n                });\n            }\n        });\n    }\n    closeGateways(options) {\n        var _a;\n        (_a = this.gateway) === null || _a === void 0 ? void 0 : _a.close();\n        this.pendingGateways\n            .filter(item => item !== (options === null || options === void 0 ? void 0 : options.except))\n            .forEach(bridge => bridge.close());\n        this.pendingGateways = [];\n    }\n}\n\nfunction hasProperty(value, propertyKey) {\n    return hasProperties(value, [propertyKey]);\n}\nfunction hasProperties(value, propertyKeys) {\n    if (!value || typeof value !== 'object') {\n        return false;\n    }\n    return propertyKeys.every(propertyKey => propertyKey in value);\n}\n\nfunction isJSBridgeWithMetadata(value) {\n    try {\n        if (!hasProperty(value, 'tonconnect') || !hasProperty(value.tonconnect, 'walletInfo')) {\n            return false;\n        }\n        return hasProperties(value.tonconnect.walletInfo, [\n            'name',\n            'app_name',\n            'image',\n            'about_url',\n            'platforms'\n        ]);\n    }\n    catch (_a) {\n        return false;\n    }\n}\n\n/**\n * In memory storage like localStorage, but without persistence.\n * Uses as a fallback for localStorage in Safari's private mode.\n */\nclass InMemoryStorage {\n    static getInstance() {\n        if (!InMemoryStorage.instance) {\n            InMemoryStorage.instance = new InMemoryStorage();\n        }\n        return InMemoryStorage.instance;\n    }\n    constructor() {\n        this.storage = {};\n    }\n    get length() {\n        return Object.keys(this.storage).length;\n    }\n    clear() {\n        this.storage = {};\n    }\n    getItem(key) {\n        var _a;\n        return (_a = this.storage[key]) !== null && _a !== void 0 ? _a : null;\n    }\n    key(index) {\n        var _a;\n        const keys = Object.keys(this.storage);\n        if (index < 0 || index >= keys.length) {\n            return null;\n        }\n        return (_a = keys[index]) !== null && _a !== void 0 ? _a : null;\n    }\n    removeItem(key) {\n        delete this.storage[key];\n    }\n    setItem(key, value) {\n        this.storage[key] = value;\n    }\n}\n\nfunction getWindow() {\n    if (typeof window === 'undefined') {\n        return undefined;\n    }\n    return window;\n}\nfunction getDocument() {\n    if (typeof document === 'undefined') {\n        return undefined;\n    }\n    return document;\n}\nfunction getWebPageManifest() {\n    var _a;\n    const origin = (_a = getWindow()) === null || _a === void 0 ? void 0 : _a.location.origin;\n    if (origin) {\n        return origin + '/tonconnect-manifest.json';\n    }\n    return '';\n}\nfunction getOriginWithPath() {\n    var _a, _b, _c, _d;\n    const origin = (_b = (_a = getWindow()) === null || _a === void 0 ? void 0 : _a.location) === null || _b === void 0 ? void 0 : _b.origin;\n    const path = (_d = (_c = getWindow()) === null || _c === void 0 ? void 0 : _c.location) === null || _d === void 0 ? void 0 : _d.pathname;\n    if (origin && path) {\n        return origin + path;\n    }\n    return '';\n}\n/**\n * Returns `localStorage` if it is available. In Safari's private mode, it returns `InMemoryStorage`. In Node.js, it throws an error.\n */\nfunction tryGetLocalStorage() {\n    if (isLocalStorageAvailable()) {\n        return localStorage;\n    }\n    if (isNodeJs()) {\n        throw new TonConnectError('`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector');\n    }\n    return InMemoryStorage.getInstance();\n}\n/**\n * Checks if `localStorage` is available.\n */\nfunction isLocalStorageAvailable() {\n    // We use a try/catch block because Safari's private mode throws an error when attempting to access localStorage.\n    try {\n        return typeof localStorage !== 'undefined';\n    }\n    catch (_a) {\n        return false;\n    }\n}\n/**\n * Checks if the environment is Node.js.\n */\nfunction isNodeJs() {\n    return (typeof process !== 'undefined' && process.versions != null && process.versions.node != null);\n}\n/**\n * Returns the current domain (hostname) if available.\n * In browser environment, returns window.location.hostname.\n * In Node.js environment or when window is not available, returns null.\n */\nfunction getDomain() {\n    try {\n        // In browser environment\n        if (typeof window !== 'undefined' && window.location) {\n            return window.location.hostname;\n        }\n        else {\n            // In Node.js environment, skip domain validation\n            return null;\n        }\n    }\n    catch (_a) {\n        return null;\n    }\n}\n/**\n * Returns an array of [key, value] pairs from window object if available.\n * In browser environment, returns Object.entries(window).\n * In Node.js environment or when window is not available, returns empty array.\n */\nfunction getWindowEntries() {\n    const window = getWindow();\n    if (!window) {\n        return [];\n    }\n    try {\n        return Object.entries(window);\n    }\n    catch (_a) {\n        return [];\n    }\n}\n\nclass InjectedProvider {\n    static fromStorage(storage, analyticsManager) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield storage.getInjectedConnection();\n            return new InjectedProvider(storage, connection.jsBridgeKey, analyticsManager);\n        });\n    }\n    static isWalletInjected(injectedWalletKey) {\n        return InjectedProvider.isWindowContainsWallet(this.window, injectedWalletKey);\n    }\n    static isInsideWalletBrowser(injectedWalletKey) {\n        if (InjectedProvider.isWindowContainsWallet(this.window, injectedWalletKey)) {\n            return this.window[injectedWalletKey].tonconnect.isWalletBrowser;\n        }\n        return false;\n    }\n    static getCurrentlyInjectedWallets() {\n        if (!this.window) {\n            return [];\n        }\n        const windowEntries = getWindowEntries();\n        const wallets = windowEntries.filter(([_key, value]) => isJSBridgeWithMetadata(value));\n        return wallets.map(([jsBridgeKey, wallet]) => ({\n            name: wallet.tonconnect.walletInfo.name,\n            appName: wallet.tonconnect.walletInfo.app_name,\n            aboutUrl: wallet.tonconnect.walletInfo.about_url,\n            imageUrl: wallet.tonconnect.walletInfo.image,\n            tondns: wallet.tonconnect.walletInfo.tondns,\n            jsBridgeKey,\n            injected: true,\n            embedded: wallet.tonconnect.isWalletBrowser,\n            platforms: wallet.tonconnect.walletInfo.platforms,\n            features: wallet.tonconnect.walletInfo.features\n        }));\n    }\n    static isWindowContainsWallet(window, injectedWalletKey) {\n        return (!!window &&\n            injectedWalletKey in window &&\n            typeof window[injectedWalletKey] === 'object' &&\n            'tonconnect' in window[injectedWalletKey]);\n    }\n    constructor(connectionStorage, injectedWalletKey, analyticsManager) {\n        this.connectionStorage = connectionStorage;\n        this.injectedWalletKey = injectedWalletKey;\n        this.type = 'injected';\n        this.unsubscribeCallback = null;\n        this.listenSubscriptions = false;\n        this.listeners = [];\n        const window = InjectedProvider.window;\n        if (!InjectedProvider.isWindowContainsWallet(window, injectedWalletKey)) {\n            throw new WalletNotInjectedError();\n        }\n        this.injectedWallet = window[injectedWalletKey].tonconnect;\n        if (analyticsManager) {\n            this.analytics = analyticsManager.scoped({\n                bridge_key: injectedWalletKey,\n                wallet_app_name: this.injectedWallet.deviceInfo.appName,\n                wallet_app_version: this.injectedWallet.deviceInfo.appVersion\n            });\n        }\n    }\n    connect(message, options) {\n        this._connect(PROTOCOL_VERSION, message, options);\n    }\n    restoreConnection(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d;\n            const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            try {\n                logDebug(`Injected Provider restoring connection...`);\n                (_b = this.analytics) === null || _b === void 0 ? void 0 : _b.emitJsBridgeCall({\n                    js_bridge_method: 'restoreConnection',\n                    trace_id: traceId\n                });\n                const connectEvent = yield this.injectedWallet.restoreConnection();\n                (_c = this.analytics) === null || _c === void 0 ? void 0 : _c.emitJsBridgeResponse({\n                    js_bridge_method: 'restoreConnection',\n                    trace_id: traceId\n                });\n                logDebug('Injected Provider restoring connection response', connectEvent);\n                if (connectEvent.event === 'connect') {\n                    this.makeSubscriptions({ traceId });\n                    this.listeners.forEach(listener => listener(Object.assign(Object.assign({}, connectEvent), { traceId })));\n                }\n                else {\n                    yield this.connectionStorage.removeConnection();\n                }\n            }\n            catch (e) {\n                (_d = this.analytics) === null || _d === void 0 ? void 0 : _d.emitJsBridgeError({\n                    js_bridge_method: 'restoreConnection',\n                    error_message: String(e),\n                    trace_id: traceId\n                });\n                yield this.connectionStorage.removeConnection();\n                console.error(e);\n            }\n        });\n    }\n    closeConnection() {\n        if (this.listenSubscriptions) {\n            this.injectedWallet.disconnect();\n        }\n        this.closeAllListeners();\n    }\n    disconnect(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            return new Promise(resolve => {\n                const onRequestSent = () => {\n                    this.closeAllListeners();\n                    this.connectionStorage.removeConnection().then(resolve);\n                };\n                try {\n                    this.injectedWallet.disconnect();\n                    onRequestSent();\n                }\n                catch (e) {\n                    logDebug(e);\n                    this.sendRequest({\n                        method: 'disconnect',\n                        params: []\n                    }, { onRequestSent, traceId });\n                }\n            });\n        });\n    }\n    closeAllListeners() {\n        var _a;\n        this.listenSubscriptions = false;\n        this.listeners = [];\n        (_a = this.unsubscribeCallback) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    listen(eventsCallback) {\n        this.listeners.push(eventsCallback);\n        return () => (this.listeners = this.listeners.filter(listener => listener !== eventsCallback));\n    }\n    sendRequest(request, optionsOrOnRequestSent) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            // TODO: remove deprecated method\n            const options = {};\n            if (typeof optionsOrOnRequestSent === 'function') {\n                options.onRequestSent = optionsOrOnRequestSent;\n                options.traceId = UUIDv7();\n            }\n            else {\n                options.onRequestSent = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.onRequestSent;\n                options.signal = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.signal;\n                options.attempts = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.attempts;\n                options.traceId = (_a = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            }\n            const id = (yield this.connectionStorage.getNextRpcRequestId()).toString();\n            yield this.connectionStorage.increaseNextRpcRequestId();\n            logDebug('Send injected-bridge request:', Object.assign(Object.assign({}, request), { id }));\n            (_b = this.analytics) === null || _b === void 0 ? void 0 : _b.emitJsBridgeCall({\n                js_bridge_method: 'send'\n            });\n            const result = this.injectedWallet.send(Object.assign(Object.assign({}, request), { id }));\n            result\n                .then(response => {\n                var _a;\n                (_a = this.analytics) === null || _a === void 0 ? void 0 : _a.emitJsBridgeResponse({\n                    js_bridge_method: 'send'\n                });\n                logDebug('Wallet message received:', response);\n            })\n                .catch(error => {\n                var _a;\n                (_a = this.analytics) === null || _a === void 0 ? void 0 : _a.emitJsBridgeError({\n                    js_bridge_method: 'send',\n                    error_message: String(error)\n                });\n            });\n            (_c = options === null || options === void 0 ? void 0 : options.onRequestSent) === null || _c === void 0 ? void 0 : _c.call(options);\n            return result;\n        });\n    }\n    _connect(protocolVersion, message, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d;\n            const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            try {\n                logDebug(`Injected Provider connect request: protocolVersion: ${protocolVersion}, message:`, message);\n                (_b = this.analytics) === null || _b === void 0 ? void 0 : _b.emitJsBridgeCall({\n                    js_bridge_method: 'connect',\n                    trace_id: traceId\n                });\n                const connectEvent = yield this.injectedWallet.connect(protocolVersion, message);\n                (_c = this.analytics) === null || _c === void 0 ? void 0 : _c.emitJsBridgeResponse({\n                    js_bridge_method: 'connect'\n                });\n                logDebug('Injected Provider connect response:', connectEvent);\n                if (connectEvent.event === 'connect') {\n                    yield this.updateSession();\n                    this.makeSubscriptions({ traceId });\n                }\n                this.listeners.forEach(listener => listener(Object.assign(Object.assign({}, connectEvent), { traceId })));\n            }\n            catch (e) {\n                (_d = this.analytics) === null || _d === void 0 ? void 0 : _d.emitJsBridgeError({\n                    js_bridge_method: 'connect',\n                    error_message: String(e),\n                    trace_id: traceId\n                });\n                logDebug('Injected Provider connect error:', e);\n                const connectEventError = {\n                    event: 'connect_error',\n                    payload: {\n                        code: 0,\n                        message: e === null || e === void 0 ? void 0 : e.toString()\n                    }\n                };\n                this.listeners.forEach(listener => listener(Object.assign(Object.assign({}, connectEventError), { traceId })));\n            }\n        });\n    }\n    makeSubscriptions(options) {\n        var _a, _b, _c;\n        this.listenSubscriptions = true;\n        (_a = this.analytics) === null || _a === void 0 ? void 0 : _a.emitJsBridgeCall({\n            js_bridge_method: 'listen',\n            trace_id: options.traceId\n        });\n        try {\n            this.unsubscribeCallback = this.injectedWallet.listen(e => {\n                var _a;\n                const traceId = (_a = e.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n                logDebug('Wallet message received:', e);\n                if (this.listenSubscriptions) {\n                    this.listeners.forEach(listener => listener(Object.assign(Object.assign({}, e), { traceId })));\n                }\n                if (e.event === 'disconnect') {\n                    this.disconnect({ traceId });\n                }\n            });\n            (_b = this.analytics) === null || _b === void 0 ? void 0 : _b.emitJsBridgeResponse({\n                js_bridge_method: 'listen',\n                trace_id: options.traceId\n            });\n        }\n        catch (err) {\n            (_c = this.analytics) === null || _c === void 0 ? void 0 : _c.emitJsBridgeError({\n                js_bridge_method: 'listen',\n                error_message: String(err),\n                trace_id: options.traceId\n            });\n            throw err;\n        }\n    }\n    updateSession() {\n        return this.connectionStorage.storeConnection({\n            type: 'injected',\n            jsBridgeKey: this.injectedWalletKey,\n            nextRpcRequestId: 0\n        });\n    }\n}\nInjectedProvider.window = getWindow();\n\nclass BridgeConnectionStorage {\n    constructor(storage, walletsListManager) {\n        this.storage = storage;\n        this.walletsListManager = walletsListManager;\n        this.storeKey = 'ton-connect-storage_bridge-connection';\n    }\n    storeConnection(connection) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (connection.type === 'injected' || connection.type === 'wallet-connect') {\n                return this.storage.setItem(this.storeKey, JSON.stringify(connection));\n            }\n            if (!isPendingConnectionHttp(connection)) {\n                const rawSession = {\n                    sessionKeyPair: connection.session.sessionCrypto.stringifyKeypair(),\n                    walletPublicKey: connection.session.walletPublicKey,\n                    bridgeUrl: connection.session.bridgeUrl\n                };\n                const rawConnection = {\n                    type: 'http',\n                    connectEvent: connection.connectEvent,\n                    session: rawSession,\n                    lastWalletEventId: connection.lastWalletEventId,\n                    nextRpcRequestId: connection.nextRpcRequestId\n                };\n                return this.storage.setItem(this.storeKey, JSON.stringify(rawConnection));\n            }\n            const rawConnection = {\n                type: 'http',\n                connectionSource: connection.connectionSource,\n                sessionCrypto: connection.sessionCrypto.stringifyKeypair(),\n                createdAt: Date.now()\n            };\n            return this.storage.setItem(this.storeKey, JSON.stringify(rawConnection));\n        });\n    }\n    removeConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.storage.removeItem(this.storeKey);\n        });\n    }\n    getConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const stored = yield this.storage.getItem(this.storeKey);\n                if (!stored) {\n                    return null;\n                }\n                const connection = JSON.parse(stored);\n                if (connection.type === 'injected' || connection.type === 'wallet-connect') {\n                    return connection;\n                }\n                if (!isPendingConnectionHttpRaw(connection)) {\n                    const sessionCrypto = new _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SessionCrypto(connection.session.sessionKeyPair);\n                    return yield this.actualizeBridgeConnection({\n                        type: 'http',\n                        connectEvent: connection.connectEvent,\n                        lastWalletEventId: connection.lastWalletEventId,\n                        nextRpcRequestId: connection.nextRpcRequestId,\n                        session: {\n                            sessionCrypto,\n                            bridgeUrl: connection.session.bridgeUrl,\n                            walletPublicKey: connection.session.walletPublicKey\n                        }\n                    });\n                }\n                if (isExpiredPendingConnectionHttpRaw(connection)) {\n                    yield this.removeConnection();\n                    return null;\n                }\n                return {\n                    type: 'http',\n                    sessionCrypto: new _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SessionCrypto(connection.sessionCrypto),\n                    connectionSource: connection.connectionSource\n                };\n            }\n            catch (err) {\n                logDebug('Error retrieving connection', err);\n                return null;\n            }\n        });\n    }\n    getHttpConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (!connection) {\n                throw new TonConnectError('Trying to read HTTP connection source while nothing is stored');\n            }\n            if (connection.type !== 'http') {\n                throw new TonConnectError(`Trying to read HTTP connection source while ${connection.type} connection is stored`);\n            }\n            return connection;\n        });\n    }\n    getHttpPendingConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (!connection) {\n                throw new TonConnectError('Trying to read HTTP connection source while nothing is stored');\n            }\n            if (connection.type !== 'http') {\n                throw new TonConnectError(`Trying to read HTTP connection source while ${connection.type} connection is stored`);\n            }\n            if (!isPendingConnectionHttp(connection)) {\n                throw new TonConnectError('Trying to read HTTP-pending connection while http connection is stored');\n            }\n            return connection;\n        });\n    }\n    getInjectedConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (!connection) {\n                throw new TonConnectError('Trying to read Injected bridge connection source while nothing is stored');\n            }\n            if ((connection === null || connection === void 0 ? void 0 : connection.type) !== 'injected') {\n                throw new TonConnectError(`Trying to read Injected bridge connection source while ${connection.type} connection is stored`);\n            }\n            return connection;\n        });\n    }\n    getWalletConnectConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (!connection) {\n                throw new TonConnectError('Trying to read wallet connect bridge connection source while nothing is stored');\n            }\n            if ((connection === null || connection === void 0 ? void 0 : connection.type) !== 'wallet-connect') {\n                throw new TonConnectError(`Trying to read wallet connect bridge connection source while ${connection.type} connection is stored`);\n            }\n            return connection;\n        });\n    }\n    storedConnectionType() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const stored = yield this.storage.getItem(this.storeKey);\n            if (!stored) {\n                return null;\n            }\n            const connection = JSON.parse(stored);\n            return connection.type;\n        });\n    }\n    storeLastWalletEventId(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (connection && connection.type === 'http' && !isPendingConnectionHttp(connection)) {\n                connection.lastWalletEventId = id;\n                return this.storeConnection(connection);\n            }\n        });\n    }\n    getLastWalletEventId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (connection && 'lastWalletEventId' in connection) {\n                return connection.lastWalletEventId;\n            }\n            return undefined;\n        });\n    }\n    increaseNextRpcRequestId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (connection && 'nextRpcRequestId' in connection) {\n                const lastId = connection.nextRpcRequestId || 0;\n                connection.nextRpcRequestId = lastId + 1;\n                return this.storeConnection(connection);\n            }\n        });\n    }\n    getNextRpcRequestId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (connection && 'nextRpcRequestId' in connection) {\n                return connection.nextRpcRequestId || 0;\n            }\n            return 0;\n        });\n    }\n    actualizeBridgeConnection(connection) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const appName = connection.connectEvent.payload.device.appName;\n                const wallet = yield this.walletsListManager.getRemoteWallet(appName);\n                if (wallet.bridgeUrl === connection.session.bridgeUrl) {\n                    return connection;\n                }\n                const actualizedConnection = Object.assign(Object.assign({}, connection), { session: Object.assign(Object.assign({}, connection.session), { bridgeUrl: wallet.bridgeUrl }) });\n                yield this.storeConnection(actualizedConnection);\n                return actualizedConnection;\n            }\n            catch (error) {\n                logDebug('Failed to actualize bridge connection', error);\n                return connection;\n            }\n        });\n    }\n}\n\n/**\n * Default storage to save protocol data, uses `localStorage` if it is available. In Safari's private mode, it uses `InMemoryStorage`. In Node.js, it throws an error.\n */\nclass DefaultStorage {\n    constructor() {\n        this.localStorage = tryGetLocalStorage();\n    }\n    getItem(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.localStorage.getItem(key);\n        });\n    }\n    removeItem(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.localStorage.removeItem(key);\n        });\n    }\n    setItem(key, value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.localStorage.setItem(key, value);\n        });\n    }\n}\n\n/**\n * Checks if `WalletInfo` is `WalletInfoInjectable` and `WalletInfo` is injected to the current webpage (`walletInfo.injected === true`).\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoCurrentlyInjected(value) {\n    return isWalletInfoInjectable(value) && value.injected;\n}\n/**\n * Checks if `WalletInfo` is `WalletInfoInjectable` and dApp is opened inside this wallet's browser.\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoCurrentlyEmbedded(value) {\n    return isWalletInfoCurrentlyInjected(value) && value.embedded;\n}\n/**\n * Checks if `WalletInfo` is `WalletInfoInjected`, but doesn't check if it is injected to the page or not.\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoInjectable(value) {\n    return 'jsBridgeKey' in value;\n}\n/**\n * Checks if `WalletInfo` is `WalletInfoRemote`.\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoRemote(value) {\n    return 'bridgeUrl' in value;\n}\n/**\n * @deprecated use `isWalletInfoInjectable` or `isWalletInfoCurrentlyInjected` instead.\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoInjected(value) {\n    return 'jsBridgeKey' in value;\n}\n\nconst FALLBACK_WALLETS_LIST = [\n    {\n        app_name: 'telegram-wallet',\n        name: 'Wallet',\n        image: 'https://wallet.tg/images/logo-288.png',\n        about_url: 'https://wallet.tg/',\n        universal_url: 'https://t.me/wallet?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://walletbot.me/tonconnect-bridge/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: true\n            },\n            {\n                name: 'SignData',\n                types: ['text', 'binary', 'cell']\n            }\n        ]\n    },\n    {\n        app_name: 'tonkeeper',\n        name: 'Tonkeeper',\n        image: 'https://tonkeeper.com/assets/tonconnect-icon.png',\n        tondns: 'tonkeeper.ton',\n        about_url: 'https://tonkeeper.com',\n        universal_url: 'https://app.tonkeeper.com/ton-connect',\n        deepLink: 'tonkeeper-tc://',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://bridge.tonapi.io/bridge'\n            },\n            {\n                type: 'js',\n                key: 'tonkeeper'\n            }\n        ],\n        platforms: ['ios', 'android', 'chrome', 'firefox', 'macos'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: true\n            },\n            {\n                name: 'SignData',\n                types: ['text', 'binary', 'cell']\n            }\n        ]\n    },\n    {\n        app_name: 'mytonwallet',\n        name: 'MyTonWallet',\n        image: 'https://static.mytonwallet.io/icon-256.png',\n        about_url: 'https://mytonwallet.io',\n        universal_url: 'https://connect.mytonwallet.org',\n        deepLink: 'mytonwallet-tc://',\n        bridge: [\n            {\n                type: 'js',\n                key: 'mytonwallet'\n            },\n            {\n                type: 'sse',\n                url: 'https://tonconnectbridge.mytonwallet.org/bridge/'\n            }\n        ],\n        platforms: ['chrome', 'windows', 'macos', 'linux', 'ios', 'android', 'firefox'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: false\n            },\n            {\n                name: 'SignData',\n                types: ['text', 'binary', 'cell']\n            }\n        ]\n    },\n    {\n        app_name: 'tonhub',\n        name: 'Tonhub',\n        image: 'https://tonhub.com/tonconnect_logo.png',\n        about_url: 'https://tonhub.com',\n        universal_url: 'https://tonhub.com/ton-connect',\n        bridge: [\n            {\n                type: 'js',\n                key: 'tonhub'\n            },\n            {\n                type: 'sse',\n                url: 'https://connect.tonhubapi.com/tonconnect'\n            }\n        ],\n        platforms: ['ios', 'android'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: true\n            },\n            {\n                name: 'SignData',\n                types: ['text', 'binary', 'cell']\n            }\n        ]\n    },\n    {\n        app_name: 'bitgetTonWallet',\n        name: 'Bitget Wallet',\n        image: 'https://raw.githubusercontent.com/bitgetwallet/download/refs/heads/main/logo/png/bitget_wallet_logo_288_mini.png',\n        about_url: 'https://web3.bitget.com',\n        deepLink: 'bitkeep://',\n        bridge: [\n            {\n                type: 'js',\n                key: 'bitgetTonWallet'\n            },\n            {\n                type: 'sse',\n                url: 'https://ton-connect-bridge.bgwapi.io/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'chrome'],\n        universal_url: 'https://bkcode.vip/ton-connect',\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'okxMiniWallet',\n        name: 'OKX Mini Wallet',\n        image: 'https://static.okx.com/cdn/assets/imgs/2411/8BE1A4A434D8F58A.png',\n        about_url: 'https://www.okx.com/web3',\n        universal_url: 'https://t.me/OKX_WALLET_BOT?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://www.okx.com/tonbridge/discover/rpc/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'binanceWeb3TonWallet',\n        name: 'Binance Wallet',\n        image: 'https://public.bnbstatic.com/static/binance-w3w/ton-provider/binancew3w.png',\n        about_url: 'https://www.binance.com/en/web3wallet',\n        deepLink: 'bnc://app.binance.com/cedefi/ton-connect',\n        bridge: [\n            {\n                type: 'js',\n                key: 'binancew3w'\n            },\n            {\n                type: 'sse',\n                url: 'https://wallet.binance.com/tonbridge/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        universal_url: 'https://app.binance.com/cedefi/ton-connect',\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'fintopio-tg',\n        name: 'Fintopio',\n        image: 'https://raw.githubusercontent.com/fintopio/ton-pub/refs/heads/main/logos/tonconnect-icon.png',\n        about_url: 'https://fintopio.com',\n        universal_url: 'https://t.me/fintopio?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://wallet-bridge.fintopio.com/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'okxTonWallet',\n        name: 'OKX Wallet',\n        image: 'https://static.okx.com/cdn/assets/imgs/247/58E63FEA47A2B7D7.png',\n        about_url: 'https://www.okx.com/web3',\n        universal_url: 'https://www.okx.com/download?appendQuery=true&deeplink=okx://web3/wallet/tonconnect',\n        bridge: [\n            {\n                type: 'js',\n                key: 'okxTonWallet'\n            },\n            {\n                type: 'sse',\n                url: 'https://www.okx.com/tonbridge/discover/rpc/bridge'\n            }\n        ],\n        platforms: ['chrome', 'safari', 'firefox', 'ios', 'android'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'hot',\n        name: 'HOT',\n        image: 'https://raw.githubusercontent.com/hot-dao/media/main/logo.png',\n        about_url: 'https://hot-labs.org/',\n        universal_url: 'https://t.me/herewalletbot?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://sse-bridge.hot-labs.org'\n            },\n            {\n                type: 'js',\n                key: 'hotWallet'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'bybitTonWallet',\n        name: 'Bybit Wallet',\n        image: 'https://raw.githubusercontent.com/bybit-web3/bybit-web3.github.io/main/docs/images/bybit-logo.png',\n        about_url: 'https://www.bybit.com/web3',\n        universal_url: 'https://app.bybit.com/ton-connect',\n        deepLink: 'bybitapp://',\n        bridge: [\n            {\n                type: 'js',\n                key: 'bybitTonWallet'\n            },\n            {\n                type: 'sse',\n                url: 'https://api-node.bybit.com/spot/api/web3/bridge/ton/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'chrome'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'dewallet',\n        name: 'DeWallet',\n        image: 'https://raw.githubusercontent.com/delab-team/manifests-images/main/WalletAvatar.png',\n        about_url: 'https://delabwallet.com',\n        universal_url: 'https://t.me/dewallet?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://bridge.dewallet.pro/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'safepalwallet',\n        name: 'SafePal',\n        image: 'https://s.pvcliping.com/web/public_image/SafePal_x288.png',\n        tondns: '',\n        about_url: 'https://www.safepal.com',\n        universal_url: 'https://link.safepal.io/ton-connect',\n        deepLink: 'safepal-tc://',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://ton-bridge.safepal.com/tonbridge/v1/bridge'\n            },\n            {\n                type: 'js',\n                key: 'safepalwallet'\n            }\n        ],\n        platforms: ['ios', 'android', 'chrome', 'firefox'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 1,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'GateWallet',\n        name: 'GateWallet',\n        image: 'https://img.gatedataimg.com/prd-ordinal-imgs/036f07bb8730716e/gateio-0925.png',\n        about_url: 'https://www.gate.io/',\n        bridge: [\n            {\n                type: 'js',\n                key: 'gatetonwallet'\n            },\n            {\n                type: 'sse',\n                url: 'https://dapp.gateio.services/tonbridge_api/bridge/v1'\n            }\n        ],\n        platforms: ['ios', 'android'],\n        universal_url: 'https://gate.onelink.me/Hls0/web3?gate_web3_wallet_universal_type=ton_connect',\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'openmask',\n        name: 'OpenMask',\n        image: 'https://raw.githubusercontent.com/OpenProduct/openmask-extension/main/public/openmask-logo-288.png',\n        about_url: 'https://www.openmask.app/',\n        bridge: [\n            {\n                type: 'js',\n                key: 'openmask'\n            }\n        ],\n        platforms: ['chrome'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'BitgetWeb3',\n        name: 'BitgetWeb3',\n        image: 'https://img.bitgetimg.com/image/third/1731638059795.png',\n        about_url: 'https://www.bitget.com',\n        universal_url: 'https://t.me/BitgetOfficialBot?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://ton-connect-bridge.bgwapi.io/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'windows', 'macos', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'xtonwallet',\n        name: 'XTONWallet',\n        image: 'https://xtonwallet.com/assets/img/icon-256-back.png',\n        about_url: 'https://xtonwallet.com',\n        bridge: [\n            {\n                type: 'js',\n                key: 'xtonwallet'\n            }\n        ],\n        platforms: ['chrome', 'firefox'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 1,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'tonwallet',\n        name: 'TON Wallet',\n        image: 'https://wallet.ton.org/assets/ui/qr-logo.png',\n        about_url: 'https://chrome.google.com/webstore/detail/ton-wallet/nphplpgoakhhjchkkhmiggakijnkhfnd',\n        bridge: [\n            {\n                type: 'js',\n                key: 'tonwallet'\n            }\n        ],\n        platforms: ['chrome'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'bitgetWalletLite',\n        name: 'Bitget Wallet Lite',\n        image: 'https://raw.githubusercontent.com/bitgetwallet/download/refs/heads/main/logo/png/bitget_wallet_lite_logo_288.png',\n        about_url: 'https://web3.bitget.com',\n        universal_url: 'https://t.me/BitgetWallet_TGBot?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://ton-connect-bridge.bgwapi.io/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'tomoWallet',\n        name: 'Tomo Wallet',\n        image: 'https://pub.tomo.inc/logo.png',\n        about_url: 'https://www.tomo.inc/',\n        universal_url: 'https://t.me/tomowalletbot?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://go-bridge.tomo.inc/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'miraiapp-tg',\n        name: 'Mirai Mini App',\n        image: 'https://cdn.mirailabs.co/miraihub/miraiapp-tg-icon-288.png',\n        about_url: 'https://mirai.app',\n        universal_url: 'https://t.me/MiraiAppBot?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://bridge.mirai.app'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: false\n            },\n            {\n                name: 'SignData',\n                types: ['text', 'binary', 'cell']\n            }\n        ]\n    },\n    {\n        app_name: 'Architec.ton',\n        name: 'Architec.ton',\n        image: 'https://raw.githubusercontent.com/Architec-Ton/wallet-tma/refs/heads/dev/public/images/arcwallet_logo.png',\n        about_url: 'https://architecton.tech',\n        universal_url: 'https://t.me/architec_ton_bot?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://tc.architecton.su/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'tokenpocket',\n        name: 'TokenPocket',\n        image: 'https://hk.tpstatic.net/logo/tokenpocket.png',\n        about_url: 'https://www.tokenpocket.pro',\n        universal_url: 'https://tp-lab.tptool.pro/ton-connect/',\n        bridge: [\n            {\n                type: 'js',\n                key: 'tokenpocket'\n            },\n            {\n                type: 'sse',\n                url: 'https://ton-connect.mytokenpocket.vip/bridge'\n            }\n        ],\n        platforms: ['ios', 'android'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'uxuyWallet',\n        name: 'UXUY Wallet',\n        image: 'https://chain-cdn.uxuy.com/logo/square_288.png',\n        about_url: 'https://docs.uxuy.com',\n        universal_url: 'https://t.me/UXUYbot?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://bridge.uxuy.me/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'tonkeeper-pro',\n        name: 'Tonkeeper Pro',\n        image: 'https://tonkeeper.com/assets/tonconnect-icon-pro.png',\n        tondns: 'tonkeeper.ton',\n        about_url: 'https://tonkeeper.com/pro',\n        universal_url: 'https://app.tonkeeper.com/pro/ton-connect',\n        deepLink: 'tonkeeper-pro-tc://',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://bridge.tonapi.io/bridge'\n            }\n        ],\n        platforms: ['ios', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: true\n            },\n            {\n                name: 'SignData',\n                types: ['text', 'binary', 'cell']\n            }\n        ]\n    },\n    {\n        app_name: 'nicegramWallet',\n        name: 'Nicegram Wallet',\n        image: 'https://static.nicegram.app/icon.png',\n        about_url: 'https://nicegram.app',\n        universal_url: 'https://nicegram.app/tc',\n        deepLink: 'nicegram-tc://',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://tc.nicegram.app/bridge'\n            },\n            {\n                type: 'js',\n                key: 'nicegramWallet'\n            }\n        ],\n        platforms: ['ios', 'android'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'echoooTonWallet',\n        name: 'EchoooWallet',\n        image: 'https://cdn.echooo.xyz/front-end/source/images/logo/echooo-ton.png',\n        about_url: 'https://www.echooo.xyz',\n        universal_url: 'https://www.echooo.xyz/ton-connect',\n        deepLink: 'echooo://',\n        bridge: [\n            {\n                type: 'js',\n                key: 'echoooTonWallet'\n            },\n            {\n                type: 'sse',\n                url: 'https://ton-connect-bridge.echooo.link/bridge'\n            }\n        ],\n        platforms: ['ios', 'android'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'blitzwallet',\n        name: 'BLITZ wallet',\n        image: 'https://blitzwallet.cfd/wallet/public/logo.png',\n        about_url: 'https://blitzwallet.cfd',\n        universal_url: 'https://t.me/blitz_wallet_bot?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://blitzwallet.cfd/bridge/'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'koloWeb3Wallet',\n        name: 'Kolo',\n        image: 'https://raw.githubusercontent.com/onidev1/tc-assets/refs/heads/main/kolo_logo_288.png',\n        about_url: 'https://kolo.xyz',\n        universal_url: 'https://t.me/kolo?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://web3-bridge.kolo.in/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'imToken',\n        name: 'imToken',\n        image: 'https://aws-v2-cdn.token.im/orbit/token-v2/icons/logo-ton-connect.png',\n        about_url: 'https://token.im',\n        universal_url: 'https://connect.token.im/link/ton-connect',\n        deepLink: 'imtokenv2://link/ton-connect',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://connect.token.im/tonbridge'\n            },\n            {\n                type: 'js',\n                key: 'imToken'\n            }\n        ],\n        platforms: ['ios', 'android'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'cactuslink',\n        name: 'Cactus Link',\n        image: 'https://downloads.mycactus.com/288_cactus_link.png',\n        about_url: 'https://www.mycactus.com/defi-connector',\n        bridge: [\n            {\n                type: 'js',\n                key: 'cactuslink_ton'\n            }\n        ],\n        platforms: ['chrome'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            },\n            {\n                name: 'SignData',\n                types: ['text', 'binary']\n            }\n        ]\n    },\n    {\n        app_name: 'onekey',\n        name: 'OneKey',\n        image: 'https://uni.onekey-asset.com/static/logo/onekey-x288.png',\n        about_url: 'https://onekey.so',\n        bridge: [\n            {\n                type: 'js',\n                key: 'onekeyTonWallet'\n            }\n        ],\n        platforms: ['chrome'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    }\n];\n\nlet qaModeEnabled = false;\nlet bannerObserver = null;\nfunction enableQaMode() {\n    qaModeEnabled = true;\n    console.warn(' QA Mode enabled - validation is disabled. This is unsafe for production!');\n    showQaModeBanner();\n    startBannerObserver();\n    addQaModeStyles();\n}\nfunction isQaModeEnabled() {\n    return qaModeEnabled;\n}\nfunction showQaModeBanner() {\n    if (typeof window === 'undefined')\n        return;\n    const existingBanner = document.getElementById('ton-connect-qa-banner');\n    if (existingBanner)\n        return;\n    const banner = document.createElement('div');\n    banner.id = 'ton-connect-qa-banner';\n    banner.style.cssText = `\n        position: fixed;\n        top: 0;\n        left: 0;\n        right: 0;\n        background: linear-gradient(90deg, #ff6b6b, #ff8e8e);\n        color: white;\n        padding: 12px 20px;\n        text-align: center;\n        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n        font-weight: 600;\n        font-size: 14px;\n        z-index: 999999;\n        box-shadow: 0 2px 8px rgba(0,0,0,0.2);\n        animation: slideDown 0.3s ease-out;\n        user-select: none;\n        pointer-events: none;\n    `;\n    banner.innerHTML = `\n         QA Mode Active - Validation Disabled (Unsafe for Production)\n    `;\n    // Add CSS animation\n    const style = document.createElement('style');\n    style.textContent = `\n        @keyframes slideDown {\n            from { transform: translateY(-100%); }\n            to { transform: translateY(0); }\n        }\n    `;\n    document.head.appendChild(style);\n    document.body.appendChild(banner);\n    addQaModeStyles();\n}\nfunction addQaModeStyles() {\n    if (typeof window === 'undefined')\n        return;\n    const existingStyle = document.getElementById('ton-connect-qa-mode-styles');\n    if (existingStyle)\n        return;\n    const style = document.createElement('style');\n    style.id = 'ton-connect-qa-mode-styles';\n    style.textContent = `\n        body.qa-mode-active {\n            padding-top: 48px !important;\n        }\n        \n        body.qa-mode-active header {\n            margin-top: 48px !important;\n        }\n        \n        body.qa-mode-active .qa-mode-control {\n            top: 128px !important;\n        }\n    `;\n    document.head.appendChild(style);\n    document.body.classList.add('qa-mode-active');\n}\nfunction startBannerObserver() {\n    if (typeof window === 'undefined' || bannerObserver)\n        return;\n    bannerObserver = new MutationObserver(mutations => {\n        mutations.forEach(mutation => {\n            if (mutation.type === 'childList') {\n                mutation.removedNodes.forEach(node => {\n                    if (node.nodeType === Node.ELEMENT_NODE) {\n                        const element = node;\n                        if (element.id === 'ton-connect-qa-banner' && qaModeEnabled) {\n                            console.warn('QA Mode banner was removed, restoring...');\n                            setTimeout(() => showQaModeBanner(), 100);\n                        }\n                        else if (element.id === 'ton-connect-qa-mode-styles' && qaModeEnabled) {\n                            console.warn('QA Mode styles were removed, restoring...');\n                            setTimeout(() => addQaModeStyles(), 100);\n                        }\n                    }\n                });\n            }\n        });\n    });\n    bannerObserver.observe(document.body, {\n        childList: true,\n        subtree: false\n    });\n    bannerObserver.observe(document.head, {\n        childList: true,\n        subtree: false\n    });\n}\n\nclass WalletsListManager {\n    constructor(options) {\n        var _a;\n        this.walletsListDTOCache = null;\n        this.walletsListDTOCacheCreationTimestamp = null;\n        if (isQaModeEnabled()) {\n            this.walletsListSource =\n                'https://raw.githubusercontent.com/ton-connect/wallets-list-staging/refs/heads/main/wallets-v2.json';\n        }\n        else {\n            this.walletsListSource =\n                (_a = options === null || options === void 0 ? void 0 : options.walletsListSource) !== null && _a !== void 0 ? _a : 'https://config.ton.org/wallets-v2.json';\n        }\n        this.cacheTTLMs = options === null || options === void 0 ? void 0 : options.cacheTTLMs;\n        this.onDownloadDurationMeasured = options === null || options === void 0 ? void 0 : options.onDownloadDurationMeasured;\n    }\n    getWallets() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const [walletsListDTO, currentlyInjectedWallets] = yield Promise.all([\n                this.fetchWalletsListDTO(),\n                this.getCurrentlyInjectedWallets()\n            ]);\n            return this.mergeWalletsLists(this.walletConfigDTOListToWalletConfigList(walletsListDTO), currentlyInjectedWallets);\n        });\n    }\n    getEmbeddedWallet() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const walletsList = yield this.getWallets();\n            const embeddedWallets = walletsList.filter(isWalletInfoCurrentlyEmbedded);\n            return embeddedWallets.length === 1 ? embeddedWallets[0] : null;\n        });\n    }\n    fetchWalletsListDTO() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.cacheTTLMs &&\n                this.walletsListDTOCacheCreationTimestamp &&\n                Date.now() > this.walletsListDTOCacheCreationTimestamp + this.cacheTTLMs) {\n                this.walletsListDTOCache = null;\n            }\n            if (!this.walletsListDTOCache) {\n                this.walletsListDTOCache = this.fetchWalletsListFromSource();\n                this.walletsListDTOCache\n                    .then(() => {\n                    this.walletsListDTOCacheCreationTimestamp = Date.now();\n                })\n                    .catch(() => {\n                    this.walletsListDTOCache = null;\n                    this.walletsListDTOCacheCreationTimestamp = null;\n                });\n            }\n            return this.walletsListDTOCache;\n        });\n    }\n    getRemoteWallet(appName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const walletsList = yield this.getWallets();\n            const wallet = walletsList.find(wallet => wallet.appName === appName);\n            if (!wallet) {\n                throw new TonConnectError(`Wallet info not found for appName: \"${appName}\"`);\n            }\n            if (!isWalletInfoRemote(wallet)) {\n                throw new TonConnectError(`Wallet \"${appName}\" is not remote`);\n            }\n            return wallet;\n        });\n    }\n    fetchWalletsListFromSource() {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            let walletsList = [];\n            const startTime = performance.now();\n            try {\n                const walletsResponse = yield fetch(this.walletsListSource);\n                walletsList = yield walletsResponse.json();\n                if (!Array.isArray(walletsList)) {\n                    throw new FetchWalletsError('Wrong wallets list format, wallets list must be an array.');\n                }\n                const wrongFormatWallets = walletsList.filter(wallet => !this.isCorrectWalletConfigDTO(wallet));\n                if (wrongFormatWallets.length) {\n                    logError(`Wallet(s) ${wrongFormatWallets\n                        .map(wallet => (wallet === null || wallet === void 0 ? void 0 : wallet.name) || 'unknown')\n                        .join(', ')} config format is wrong. They were removed from the wallets list.`);\n                    walletsList = walletsList.filter(wallet => this.isCorrectWalletConfigDTO(wallet));\n                }\n                const endTime = performance.now();\n                const duration = Math.round(endTime - startTime);\n                (_a = this.onDownloadDurationMeasured) === null || _a === void 0 ? void 0 : _a.call(this, duration);\n            }\n            catch (e) {\n                logError(e);\n                walletsList = FALLBACK_WALLETS_LIST;\n                (_b = this.onDownloadDurationMeasured) === null || _b === void 0 ? void 0 : _b.call(this, undefined);\n            }\n            return walletsList;\n        });\n    }\n    getCurrentlyInjectedWallets() {\n        if (!isQaModeEnabled()) {\n            return [];\n        }\n        try {\n            return InjectedProvider.getCurrentlyInjectedWallets();\n        }\n        catch (e) {\n            logError(e);\n            return [];\n        }\n    }\n    walletConfigDTOListToWalletConfigList(walletConfigDTO) {\n        return walletConfigDTO.map(walletConfigDTO => {\n            const walletConfig = {\n                name: walletConfigDTO.name,\n                appName: walletConfigDTO.app_name,\n                imageUrl: walletConfigDTO.image,\n                aboutUrl: walletConfigDTO.about_url,\n                tondns: walletConfigDTO.tondns,\n                platforms: walletConfigDTO.platforms,\n                features: walletConfigDTO.features\n            };\n            walletConfigDTO.bridge.forEach(bridge => {\n                if (bridge.type === 'sse') {\n                    walletConfig.bridgeUrl = bridge.url;\n                    walletConfig.universalLink =\n                        walletConfigDTO.universal_url;\n                    walletConfig.deepLink = walletConfigDTO.deepLink;\n                }\n                if (bridge.type === 'js') {\n                    const jsBridgeKey = bridge.key;\n                    walletConfig.jsBridgeKey = jsBridgeKey;\n                    walletConfig.injected =\n                        InjectedProvider.isWalletInjected(jsBridgeKey);\n                    walletConfig.embedded =\n                        InjectedProvider.isInsideWalletBrowser(jsBridgeKey);\n                }\n            });\n            return walletConfig;\n        });\n    }\n    mergeWalletsLists(list1, list2) {\n        const names = new Set(list1.concat(list2).map(item => item.name));\n        return [...names.values()].map(name => {\n            const list1Item = list1.find(item => item.name === name);\n            const list2Item = list2.find(item => item.name === name);\n            return Object.assign(Object.assign({}, (list1Item && Object.assign({}, list1Item))), (list2Item && Object.assign({}, list2Item)));\n        });\n    }\n    // eslint-disable-next-line complexity\n    isCorrectWalletConfigDTO(value) {\n        if (!value || !(typeof value === 'object')) {\n            return false;\n        }\n        const containsName = 'name' in value;\n        const containsAppName = 'app_name' in value;\n        const containsImage = 'image' in value;\n        const containsAbout = 'about_url' in value;\n        const containsPlatforms = 'platforms' in value;\n        if (!containsName ||\n            !containsImage ||\n            !containsAbout ||\n            !containsPlatforms ||\n            !containsAppName) {\n            return false;\n        }\n        if (!value.platforms ||\n            !Array.isArray(value.platforms) ||\n            !value.platforms.length) {\n            return false;\n        }\n        if (!('bridge' in value) ||\n            !Array.isArray(value.bridge) ||\n            !value.bridge.length) {\n            return false;\n        }\n        const bridge = value.bridge;\n        if (bridge.some(item => !item || typeof item !== 'object' || !('type' in item))) {\n            return false;\n        }\n        const sseBridge = bridge.find(item => item.type === 'sse');\n        if (sseBridge) {\n            if (!(typeof sseBridge === 'object' && 'url' in sseBridge) ||\n                !sseBridge.url ||\n                !value.universal_url) {\n                return false;\n            }\n        }\n        const jsBridge = bridge.find(item => item.type === 'js');\n        if (jsBridge) {\n            if (typeof jsBridge !== 'object' ||\n                !('key' in jsBridge) ||\n                !jsBridge.key) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\nfunction checkSendTransactionSupport(features, options) {\n    const supportsDeprecatedSendTransactionFeature = features.includes('SendTransaction');\n    const sendTransactionFeature = findFeature(features, 'SendTransaction');\n    const requiredFeature = {\n        minMessages: options.requiredMessagesNumber,\n        extraCurrencyRequired: options.requireExtraCurrencies\n    };\n    if (!supportsDeprecatedSendTransactionFeature && !sendTransactionFeature) {\n        throw new WalletNotSupportFeatureError(\"Wallet doesn't support SendTransaction feature.\", {\n            cause: { requiredFeature: { featureName: 'SendTransaction', value: requiredFeature } }\n        });\n    }\n    if (options.requireExtraCurrencies) {\n        if (!sendTransactionFeature || !sendTransactionFeature.extraCurrencySupported) {\n            throw new WalletNotSupportFeatureError(`Wallet is not able to handle such SendTransaction request. Extra currencies support is required.`, {\n                cause: {\n                    requiredFeature: { featureName: 'SendTransaction', value: requiredFeature }\n                }\n            });\n        }\n    }\n    if (sendTransactionFeature && sendTransactionFeature.maxMessages !== undefined) {\n        if (sendTransactionFeature.maxMessages < options.requiredMessagesNumber) {\n            throw new WalletNotSupportFeatureError(`Wallet is not able to handle such SendTransaction request. Max support messages number is ${sendTransactionFeature.maxMessages}, but ${options.requiredMessagesNumber} is required.`, {\n                cause: {\n                    requiredFeature: { featureName: 'SendTransaction', value: requiredFeature }\n                }\n            });\n        }\n        return;\n    }\n    logWarning(\"Connected wallet didn't provide information about max allowed messages in the SendTransaction request. Request may be rejected by the wallet.\");\n}\nfunction checkSignDataSupport(features, options) {\n    const signDataFeature = features.find(feature => feature && typeof feature === 'object' && feature.name === 'SignData');\n    if (!signDataFeature) {\n        throw new WalletNotSupportFeatureError(\"Wallet doesn't support SignData feature.\", {\n            cause: {\n                requiredFeature: {\n                    featureName: 'SignData',\n                    value: { types: options.requiredTypes }\n                }\n            }\n        });\n    }\n    const unsupportedTypes = options.requiredTypes.filter(requiredType => !signDataFeature.types.includes(requiredType));\n    if (unsupportedTypes.length) {\n        throw new WalletNotSupportFeatureError(`Wallet doesn't support required SignData types: ${unsupportedTypes.join(', ')}.`, {\n            cause: {\n                requiredFeature: { featureName: 'SignData', value: { types: unsupportedTypes } }\n            }\n        });\n    }\n}\nfunction checkRequiredWalletFeatures(features, walletsRequiredFeatures) {\n    if (typeof walletsRequiredFeatures !== 'object') {\n        return true;\n    }\n    const { sendTransaction, signData } = walletsRequiredFeatures;\n    if (sendTransaction) {\n        const feature = findFeature(features, 'SendTransaction');\n        if (!feature) {\n            return false;\n        }\n        if (!checkSendTransaction(feature, sendTransaction)) {\n            return false;\n        }\n    }\n    if (signData) {\n        const feature = findFeature(features, 'SignData');\n        if (!feature) {\n            return false;\n        }\n        if (!checkSignData(feature, signData)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction findFeature(features, requiredFeatureName) {\n    return features.find(f => f && typeof f === 'object' && f.name === requiredFeatureName);\n}\nfunction checkSendTransaction(feature, requiredFeature) {\n    const correctMessagesNumber = requiredFeature.minMessages === undefined ||\n        requiredFeature.minMessages <= feature.maxMessages;\n    const correctExtraCurrency = !requiredFeature.extraCurrencyRequired || feature.extraCurrencySupported;\n    return !!(correctMessagesNumber && correctExtraCurrency);\n}\nfunction checkSignData(feature, requiredFeature) {\n    return requiredFeature.types.every(requiredType => feature.types.includes(requiredType));\n}\n\n/**\n * Create a request version event.\n */\nfunction createRequestVersionEvent() {\n    return {\n        type: 'request-version'\n    };\n}\n/**\n * Create a response version event.\n * @param version\n */\nfunction createResponseVersionEvent(version) {\n    return {\n        type: 'response-version',\n        version: version\n    };\n}\n/**\n * Create a version info.\n * @param version\n */\nfunction createVersionInfo(version) {\n    return {\n        ton_connect_sdk_lib: version.ton_connect_sdk_lib,\n        ton_connect_ui_lib: version.ton_connect_ui_lib\n    };\n}\n// eslint-disable-next-line complexity\nfunction createConnectionInfo(version, wallet, sessionInfo) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n    const isTonProof = ((_a = wallet === null || wallet === void 0 ? void 0 : wallet.connectItems) === null || _a === void 0 ? void 0 : _a.tonProof) && 'proof' in wallet.connectItems.tonProof;\n    const authType = isTonProof ? 'ton_proof' : 'ton_addr';\n    return {\n        wallet_address: (_c = (_b = wallet === null || wallet === void 0 ? void 0 : wallet.account) === null || _b === void 0 ? void 0 : _b.address) !== null && _c !== void 0 ? _c : null,\n        wallet_state_init: (_d = wallet === null || wallet === void 0 ? void 0 : wallet.account.walletStateInit) !== null && _d !== void 0 ? _d : null,\n        wallet_type: (_e = wallet === null || wallet === void 0 ? void 0 : wallet.device.appName) !== null && _e !== void 0 ? _e : null,\n        wallet_version: (_f = wallet === null || wallet === void 0 ? void 0 : wallet.device.appVersion) !== null && _f !== void 0 ? _f : null,\n        auth_type: authType,\n        custom_data: Object.assign({ client_id: (_g = sessionInfo === null || sessionInfo === void 0 ? void 0 : sessionInfo.clientId) !== null && _g !== void 0 ? _g : null, wallet_id: (_h = sessionInfo === null || sessionInfo === void 0 ? void 0 : sessionInfo.walletId) !== null && _h !== void 0 ? _h : null, chain_id: (_k = (_j = wallet === null || wallet === void 0 ? void 0 : wallet.account) === null || _j === void 0 ? void 0 : _j.chain) !== null && _k !== void 0 ? _k : null, provider: (_l = wallet === null || wallet === void 0 ? void 0 : wallet.provider) !== null && _l !== void 0 ? _l : null }, createVersionInfo(version))\n    };\n}\n/**\n * Create a connection init event.\n */\nfunction createConnectionStartedEvent(version, traceId) {\n    return {\n        type: 'connection-started',\n        custom_data: createVersionInfo(version),\n        trace_id: traceId !== null && traceId !== void 0 ? traceId : null\n    };\n}\n/**\n * Create a connection completed event.\n * @param version\n * @param wallet\n * @param sessionInfo\n * @param traceId\n */\nfunction createConnectionCompletedEvent(version, wallet, sessionInfo, traceId) {\n    return Object.assign({ type: 'connection-completed', is_success: true, trace_id: traceId !== null && traceId !== void 0 ? traceId : null }, createConnectionInfo(version, wallet, sessionInfo));\n}\n/**\n * Create a connection error event.\n * @param version\n * @param error_message\n * @param errorCode\n * @param sessionInfo\n * @param traceId\n */\nfunction createConnectionErrorEvent(version, error_message, errorCode, sessionInfo, traceId) {\n    var _a, _b;\n    return {\n        type: 'connection-error',\n        is_success: false,\n        error_message: error_message,\n        error_code: errorCode !== null && errorCode !== void 0 ? errorCode : null,\n        trace_id: traceId !== null && traceId !== void 0 ? traceId : null,\n        custom_data: Object.assign({ client_id: (_a = sessionInfo === null || sessionInfo === void 0 ? void 0 : sessionInfo.clientId) !== null && _a !== void 0 ? _a : null, wallet_id: (_b = sessionInfo === null || sessionInfo === void 0 ? void 0 : sessionInfo.walletId) !== null && _b !== void 0 ? _b : null }, createVersionInfo(version))\n    };\n}\n/**\n * Create a connection restoring started event.\n */\nfunction createConnectionRestoringStartedEvent(version, traceId) {\n    return {\n        type: 'connection-restoring-started',\n        custom_data: createVersionInfo(version),\n        trace_id: traceId !== null && traceId !== void 0 ? traceId : null\n    };\n}\n/**\n * Create a connection restoring completed event.\n * @param version\n * @param wallet\n * @param sessionInfo\n * @param traceId\n */\nfunction createConnectionRestoringCompletedEvent(version, wallet, sessionInfo, traceId) {\n    return Object.assign({ type: 'connection-restoring-completed', is_success: true, trace_id: traceId !== null && traceId !== void 0 ? traceId : null }, createConnectionInfo(version, wallet, sessionInfo));\n}\n/**\n * Create a connection restoring error event.\n * @param version\n * @param errorMessage\n * @param traceId\n */\nfunction createConnectionRestoringErrorEvent(version, errorMessage, traceId) {\n    return {\n        type: 'connection-restoring-error',\n        is_success: false,\n        error_message: errorMessage,\n        trace_id: traceId !== null && traceId !== void 0 ? traceId : null,\n        custom_data: createVersionInfo(version)\n    };\n}\nfunction createTransactionInfo(wallet, transaction) {\n    var _a, _b, _c, _d;\n    return {\n        valid_until: (_a = String(transaction.validUntil)) !== null && _a !== void 0 ? _a : null,\n        from: (_d = (_b = transaction.from) !== null && _b !== void 0 ? _b : (_c = wallet === null || wallet === void 0 ? void 0 : wallet.account) === null || _c === void 0 ? void 0 : _c.address) !== null && _d !== void 0 ? _d : null,\n        messages: transaction.messages.map(message => {\n            var _a, _b;\n            return ({\n                address: (_a = message.address) !== null && _a !== void 0 ? _a : null,\n                amount: (_b = message.amount) !== null && _b !== void 0 ? _b : null\n            });\n        })\n    };\n}\nfunction createTransactionFullInfo(wallet, transaction) {\n    var _a, _b, _c, _d;\n    return {\n        valid_until: (_a = String(transaction.validUntil)) !== null && _a !== void 0 ? _a : null,\n        from: (_d = (_b = transaction.from) !== null && _b !== void 0 ? _b : (_c = wallet === null || wallet === void 0 ? void 0 : wallet.account) === null || _c === void 0 ? void 0 : _c.address) !== null && _d !== void 0 ? _d : null,\n        messages: transaction.messages.map(message => {\n            var _a, _b, _c, _d;\n            return ({\n                address: (_a = message.address) !== null && _a !== void 0 ? _a : null,\n                amount: (_b = message.amount) !== null && _b !== void 0 ? _b : null,\n                payload: (_c = message.payload) !== null && _c !== void 0 ? _c : null,\n                state_init: (_d = message.stateInit) !== null && _d !== void 0 ? _d : null\n            });\n        })\n    };\n}\n/**\n * Create a transaction init event.\n * @param version\n * @param wallet\n * @param transaction\n * @param sessionInfo\n * @param traceId\n */\nfunction createTransactionSentForSignatureEvent(version, wallet, transaction, sessionInfo, traceId) {\n    return Object.assign(Object.assign({ type: 'transaction-sent-for-signature', trace_id: traceId !== null && traceId !== void 0 ? traceId : null }, createConnectionInfo(version, wallet, sessionInfo)), createTransactionInfo(wallet, transaction));\n}\n/**\n * Create a transaction signed event.\n * @param version\n * @param wallet\n * @param transaction\n * @param signedTransaction\n * @param sessionInfo\n * @param traceId\n */\nfunction createTransactionSignedEvent(version, wallet, transaction, signedTransaction, sessionInfo, traceId) {\n    return Object.assign(Object.assign({ type: 'transaction-signed', is_success: true, signed_transaction: signedTransaction.boc, trace_id: traceId !== null && traceId !== void 0 ? traceId : null }, createConnectionInfo(version, wallet, sessionInfo)), createTransactionInfo(wallet, transaction));\n}\n/**\n * Create a transaction error event.\n * @param version\n * @param wallet\n * @param transaction\n * @param errorMessage\n * @param errorCode\n * @param sessionInfo\n * @param traceId\n */\nfunction createTransactionSigningFailedEvent(version, wallet, transaction, errorMessage, errorCode, sessionInfo, traceId) {\n    return Object.assign(Object.assign({ type: 'transaction-signing-failed', is_success: false, error_message: errorMessage, error_code: errorCode !== null && errorCode !== void 0 ? errorCode : null, trace_id: traceId !== null && traceId !== void 0 ? traceId : null }, createConnectionInfo(version, wallet, sessionInfo)), createTransactionFullInfo(wallet, transaction));\n}\nfunction createDataSentForSignatureEvent(version, wallet, data, sessionInfo, traceId) {\n    return Object.assign({ type: 'sign-data-request-initiated', data, trace_id: traceId !== null && traceId !== void 0 ? traceId : null }, createConnectionInfo(version, wallet, sessionInfo));\n}\nfunction createDataSignedEvent(version, wallet, data, signedData, sessionInfo, traceId) {\n    return Object.assign({ type: 'sign-data-request-completed', is_success: true, data, signed_data: signedData, trace_id: traceId !== null && traceId !== void 0 ? traceId : null }, createConnectionInfo(version, wallet, sessionInfo));\n}\nfunction createDataSigningFailedEvent(version, wallet, data, errorMessage, errorCode, sessionInfo, traceId) {\n    return Object.assign({ type: 'sign-data-request-failed', is_success: false, data, error_message: errorMessage, error_code: errorCode !== null && errorCode !== void 0 ? errorCode : null, trace_id: traceId !== null && traceId !== void 0 ? traceId : null }, createConnectionInfo(version, wallet, sessionInfo));\n}\nfunction createDisconnectionEvent(version, wallet, scope, sessionInfo, traceId) {\n    return Object.assign({ type: 'disconnection', scope: scope, trace_id: traceId !== null && traceId !== void 0 ? traceId : null }, createConnectionInfo(version, wallet, sessionInfo));\n}\nfunction createWalletModalOpenedEvent(version, visibleWallets, clientId, traceId) {\n    return {\n        type: 'wallet-modal-opened',\n        visible_wallets: visibleWallets,\n        client_id: clientId !== null && clientId !== void 0 ? clientId : null,\n        custom_data: version,\n        trace_id: traceId !== null && traceId !== void 0 ? traceId : null\n    };\n}\nfunction createSelectedWalletEvent(version, visibleWallets, lastSelectedWallet, walletsMenu, redirectLink, redirectLinkType, clientId, traceId) {\n    var _a;\n    let walletRedirectMethod = redirectLinkType;\n    if (!walletRedirectMethod && redirectLink) {\n        walletRedirectMethod = isTelegramUrl(redirectLink) ? 'tg_link' : 'external_link';\n    }\n    return {\n        type: 'selected-wallet',\n        wallets_menu: walletsMenu,\n        visible_wallets: visibleWallets,\n        client_id: clientId !== null && clientId !== void 0 ? clientId : null,\n        custom_data: version,\n        trace_id: traceId !== null && traceId !== void 0 ? traceId : null,\n        wallet_redirect_method: walletRedirectMethod,\n        wallet_redirect_link: redirectLink || undefined,\n        wallet_type: (_a = lastSelectedWallet === null || lastSelectedWallet === void 0 ? void 0 : lastSelectedWallet.appName) !== null && _a !== void 0 ? _a : null\n    };\n}\n\n/**\n * Tracker for TonConnect user actions, such as transaction signing, connection, etc.\n *\n * List of events:\n *  * `connection-started`: when a user starts connecting a wallet.\n *  * `connection-completed`: when a user successfully connected a wallet.\n *  * `connection-error`: when a user cancels a connection or there is an error during the connection process.\n *  * `connection-restoring-started`: when the dApp starts restoring a connection.\n *  * `connection-restoring-completed`: when the dApp successfully restores a connection.\n *  * `connection-restoring-error`: when the dApp fails to restore a connection.\n *  * `disconnection`: when a user starts disconnecting a wallet.\n *  * `transaction-sent-for-signature`: when a user sends a transaction for signature.\n *  * `transaction-signed`: when a user successfully signs a transaction.\n *  * `transaction-signing-failed`: when a user cancels transaction signing or there is an error during the signing process.\n *  * `sign-data-request-initiated`: when a user sends data for signature.\n *  * `sign-data-request-completed`: when a user successfully signs data.\n *  * `sign-data-request-failed`: when a user cancels data signing or there is an error during the signing process.\n *\n * If you want to track user actions, you can subscribe to the window events with prefix `ton-connect-`:\n *\n * @example\n * window.addEventListener('ton-connect-transaction-sent-for-signature', (event) => {\n *    console.log('Transaction init', event.detail);\n * });\n *\n * @internal\n */\nclass TonConnectTracker {\n    /**\n     * Version of the library.\n     */\n    get version() {\n        return createVersionInfo({\n            ton_connect_sdk_lib: this.tonConnectSdkVersion,\n            ton_connect_ui_lib: this.tonConnectUiVersion\n        });\n    }\n    constructor(options) {\n        /**\n         * Event prefix for user actions.\n         * @private\n         */\n        this.eventPrefix = 'ton-connect-';\n        /**\n         * TonConnect UI version.\n         */\n        this.tonConnectUiVersion = null;\n        this.eventDispatcher = options === null || options === void 0 ? void 0 : options.eventDispatcher;\n        this.tonConnectSdkVersion = options.tonConnectSdkVersion;\n        this.init().catch();\n    }\n    /**\n     * Called once when the tracker is created and request version other libraries.\n     */\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this.setRequestVersionHandler();\n                this.tonConnectUiVersion = yield this.requestTonConnectUiVersion();\n            }\n            catch (e) { }\n        });\n    }\n    /**\n     * Set request version handler.\n     * @private\n     */\n    setRequestVersionHandler() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.eventDispatcher.addEventListener('ton-connect-request-version', () => __awaiter(this, void 0, void 0, function* () {\n                yield this.eventDispatcher.dispatchEvent('ton-connect-response-version', createResponseVersionEvent(this.tonConnectSdkVersion));\n            }));\n        });\n    }\n    /**\n     * Request TonConnect UI version.\n     * @private\n     */\n    requestTonConnectUiVersion() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    yield this.eventDispatcher.addEventListener('ton-connect-ui-response-version', (event) => {\n                        resolve(event.detail.version);\n                    }, { once: true });\n                    yield this.eventDispatcher.dispatchEvent('ton-connect-ui-request-version', createRequestVersionEvent());\n                }\n                catch (e) {\n                    reject(e);\n                }\n            }));\n        });\n    }\n    /**\n     * Emit user action event to the window.\n     * @param eventDetails\n     * @private\n     */\n    dispatchUserActionEvent(eventDetails) {\n        try {\n            this.eventDispatcher\n                .dispatchEvent(`${this.eventPrefix}${eventDetails.type}`, eventDetails)\n                .catch();\n        }\n        catch (e) { }\n    }\n    /**\n     * Track connection init event.\n     * @param args\n     */\n    trackConnectionStarted(...args) {\n        try {\n            const event = createConnectionStartedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track connection success event.\n     * @param args\n     */\n    trackConnectionCompleted(...args) {\n        try {\n            const event = createConnectionCompletedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track connection error event.\n     * @param args\n     */\n    trackConnectionError(...args) {\n        try {\n            const event = createConnectionErrorEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track connection restoring init event.\n     * @param args\n     */\n    trackConnectionRestoringStarted(...args) {\n        try {\n            const event = createConnectionRestoringStartedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track connection restoring success event.\n     * @param args\n     */\n    trackConnectionRestoringCompleted(...args) {\n        try {\n            const event = createConnectionRestoringCompletedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track connection restoring error event.\n     * @param args\n     */\n    trackConnectionRestoringError(...args) {\n        try {\n            const event = createConnectionRestoringErrorEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track disconnect event.\n     * @param args\n     */\n    trackDisconnection(...args) {\n        try {\n            const event = createDisconnectionEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track transaction init event.\n     * @param args\n     */\n    trackTransactionSentForSignature(...args) {\n        try {\n            const event = createTransactionSentForSignatureEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track transaction signed event.\n     * @param args\n     */\n    trackTransactionSigned(...args) {\n        try {\n            const event = createTransactionSignedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track transaction error event.\n     * @param args\n     */\n    trackTransactionSigningFailed(...args) {\n        try {\n            const event = createTransactionSigningFailedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track sign data init event.\n     * @param args\n     */\n    trackDataSentForSignature(...args) {\n        try {\n            const event = createDataSentForSignatureEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track sign data success event.\n     * @param args\n     */\n    trackDataSigned(...args) {\n        try {\n            const event = createDataSignedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track sign data error event.\n     * @param args\n     */\n    trackDataSigningFailed(...args) {\n        try {\n            const event = createDataSigningFailedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n}\n\nconst tonConnectSdkVersion = \"3.4.1\";\n\nconst bounceableTag = 0x11;\nconst noBounceableTag = 0x51;\nconst testOnlyTag = 0x80;\n/**\n * Converts raw TON address to no-bounceable user-friendly format. [See details]{@link https://ton.org/docs/learn/overviews/addresses#user-friendly-address}\n * @param hexAddress raw TON address formatted as \"0:<hex string without 0x>\".\n * @param [testOnly=false] convert address to test-only form. [See details]{@link https://ton.org/docs/learn/overviews/addresses#user-friendly-address}\n */\nfunction toUserFriendlyAddress(hexAddress, testOnly = false) {\n    const { wc, hex } = parseHexAddress(hexAddress);\n    let tag = noBounceableTag;\n    if (testOnly) {\n        tag |= testOnlyTag;\n    }\n    const addr = new Int8Array(34);\n    addr[0] = tag;\n    addr[1] = wc;\n    addr.set(hex, 2);\n    const addressWithChecksum = new Uint8Array(36);\n    addressWithChecksum.set(addr);\n    addressWithChecksum.set(crc16(addr), 34);\n    let addressBase64 = _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.Base64.encode(addressWithChecksum);\n    return addressBase64.replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n/**\n * Validates if the address is in user-friendly format by attempting to parse it.\n * @param address address to validate\n * @returns true if the address is valid user-friendly format, false otherwise\n */\nfunction isValidUserFriendlyAddress(address) {\n    try {\n        parseUserFriendlyAddress(address);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n/**\n * Validates if the address is in raw hex format (e.g., \"0:1234...\" or \"-1:1234...\").\n * @param address address to validate\n * @returns true if the address is valid raw format, false otherwise\n */\nfunction isValidRawAddress(address) {\n    try {\n        parseHexAddress(address);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction toRawAddress({ wc, hex }) {\n    return `${wc}:${hex}`;\n}\n/**\n * Parses user-friendly address and returns its components.\n * @param address user-friendly address\n * @returns parsed address components\n */\nfunction parseUserFriendlyAddress(address) {\n    const base64 = address.replace(/-/g, '+').replace(/_/g, '/');\n    let decoded;\n    try {\n        decoded = _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.Base64.decode(base64).toUint8Array();\n    }\n    catch (_a) {\n        throw new WrongAddressError(`Invalid base64 encoding in address: ${address}`);\n    }\n    if (decoded.length !== 36) {\n        throw new WrongAddressError(`Invalid address length: ${address}`);\n    }\n    const addr = decoded.slice(0, 34);\n    const checksum = decoded.slice(34, 36);\n    const calculatedChecksum = crc16(addr);\n    if (!checksum.every((byte, i) => byte === calculatedChecksum[i])) {\n        throw new WrongAddressError(`Invalid checksum in address: ${address}`);\n    }\n    let tag = addr[0];\n    let isTestOnly = false;\n    let isBounceable = false;\n    if (tag & testOnlyTag) {\n        isTestOnly = true;\n        tag = tag ^ testOnlyTag;\n    }\n    if (tag !== bounceableTag && tag !== noBounceableTag) {\n        throw new WrongAddressError(`Unknown address tag: ${tag}`);\n    }\n    isBounceable = tag === bounceableTag;\n    let wc = null;\n    if (addr[1] === 0xff) {\n        // TODO we should read signed integer here\n        wc = -1;\n    }\n    else {\n        wc = addr[1];\n    }\n    const hex = addr.slice(2);\n    if (wc !== 0 && wc !== -1) {\n        throw new WrongAddressError(`Invalid workchain: ${wc}`);\n    }\n    return {\n        wc,\n        hex: Array.from(hex)\n            .map(b => b.toString(16).padStart(2, '0'))\n            .join(''),\n        testOnly: isTestOnly,\n        isBounceable\n    };\n}\nfunction parseHexAddress(hexAddress) {\n    if (!hexAddress.includes(':')) {\n        throw new WrongAddressError(`Wrong address ${hexAddress}. Address must include \":\".`);\n    }\n    const parts = hexAddress.split(':');\n    if (parts.length !== 2) {\n        throw new WrongAddressError(`Wrong address ${hexAddress}. Address must include \":\" only once.`);\n    }\n    const wc = parseInt(parts[0]);\n    if (wc !== 0 && wc !== -1) {\n        throw new WrongAddressError(`Wrong address ${hexAddress}. WC must be eq 0 or -1, but ${wc} received.`);\n    }\n    const hex = parts[1];\n    if ((hex === null || hex === void 0 ? void 0 : hex.length) !== 64) {\n        throw new WrongAddressError(`Wrong address ${hexAddress}. Hex part must be 64bytes length, but ${hex === null || hex === void 0 ? void 0 : hex.length} received.`);\n    }\n    return {\n        wc,\n        hex: hexToBytes(hex)\n    };\n}\nfunction crc16(data) {\n    const poly = 0x1021;\n    let reg = 0;\n    const message = new Uint8Array(data.length + 2);\n    message.set(data);\n    for (let byte of message) {\n        let mask = 0x80;\n        while (mask > 0) {\n            reg <<= 1;\n            if (byte & mask) {\n                reg += 1;\n            }\n            mask >>= 1;\n            if (reg > 0xffff) {\n                reg &= 0xffff;\n                reg ^= poly;\n            }\n        }\n    }\n    return new Uint8Array([Math.floor(reg / 256), reg % 256]);\n}\nconst toByteMap = {};\nfor (let ord = 0; ord <= 0xff; ord++) {\n    let s = ord.toString(16);\n    if (s.length < 2) {\n        s = '0' + s;\n    }\n    toByteMap[s] = ord;\n}\nfunction hexToBytes(hex) {\n    hex = hex.toLowerCase();\n    const length2 = hex.length;\n    if (length2 % 2 !== 0) {\n        throw new ParseHexError('Hex string must have length a multiple of 2: ' + hex);\n    }\n    const length = length2 / 2;\n    const result = new Uint8Array(length);\n    for (let i = 0; i < length; i++) {\n        const doubled = i * 2;\n        const hexSubstring = hex.substring(doubled, doubled + 2);\n        if (!toByteMap.hasOwnProperty(hexSubstring)) {\n            throw new ParseHexError('Invalid hex character: ' + hexSubstring);\n        }\n        result[i] = toByteMap[hexSubstring];\n    }\n    return result;\n}\n\nconst BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;\nconst BASE64URL_REGEX = /^[A-Za-z0-9\\-_]+$/;\nconst BOC_PREFIX = 'te6cc';\nconst INTEGER_REGEX = /^-?\\d+$/;\nconst POSITIVE_INTEGER_REGEX = /^\\d+$/;\nconst MAX_DOMAIN_BYTES = 128;\nconst MAX_PAYLOAD_BYTES = 128;\nconst MAX_TOTAL_BYTES = 222;\nfunction isValidNumber(value) {\n    return typeof value === 'number' && !isNaN(value);\n}\nfunction isValidString(value) {\n    return typeof value === 'string' && value.length > 0;\n}\nfunction isValidAddress(value) {\n    return isValidString(value) && (isValidRawAddress(value) || isValidUserFriendlyAddress(value));\n}\nfunction isValidNetwork(value) {\n    return isValidString(value) && /^-?\\d+$/.test(value);\n}\nfunction isValidBoc(value) {\n    return (typeof value === 'string' &&\n        (BASE64_REGEX.test(value) || BASE64URL_REGEX.test(value)) &&\n        value.startsWith(BOC_PREFIX));\n}\nfunction isValidObject(value) {\n    return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\nfunction isValidArray(value) {\n    return Array.isArray(value);\n}\nfunction hasExtraProperties(obj, allowedKeys) {\n    return Object.keys(obj).some(key => !allowedKeys.includes(key));\n}\nfunction validateSendTransactionRequest(data) {\n    if (!isValidObject(data)) {\n        return 'Request must be an object';\n    }\n    const allowedKeys = ['validUntil', 'network', 'from', 'messages'];\n    if (hasExtraProperties(data, allowedKeys)) {\n        return 'Request contains extra properties';\n    }\n    if (data.validUntil) {\n        if (!isValidNumber(data.validUntil)) {\n            return \"Incorrect 'validUntil'\";\n        }\n        const now = Math.floor(Date.now() / 1000);\n        const fiveMinutesFromNow = now + 300;\n        if (data.validUntil > fiveMinutesFromNow) {\n            console.warn(`validUntil (${data.validUntil}) is more than 5 minutes from now (${now})`);\n        }\n    }\n    if (data.network !== undefined) {\n        if (!isValidNetwork(data.network)) {\n            return \"Invalid 'network' format\";\n        }\n    }\n    if (data.from !== undefined && !isValidAddress(data.from)) {\n        return \"Invalid 'from' address format\";\n    }\n    if (!isValidArray(data.messages) || data.messages.length === 0) {\n        return \"'messages' is required\";\n    }\n    for (let i = 0; i < data.messages.length; i++) {\n        const message = data.messages[i];\n        const messageError = validateTransactionMessage(message, i);\n        if (messageError) {\n            return messageError;\n        }\n    }\n    return null;\n}\nfunction validateTransactionMessage(message, index) {\n    if (!isValidObject(message)) {\n        return `Message at index ${index} must be an object`;\n    }\n    const allowedKeys = ['address', 'amount', 'stateInit', 'payload', 'extraCurrency'];\n    if (hasExtraProperties(message, allowedKeys)) {\n        return `Message at index ${index} contains extra properties`;\n    }\n    if (!isValidString(message.address)) {\n        return `'address' is required in message at index ${index}`;\n    }\n    if (!isValidUserFriendlyAddress(message.address)) {\n        return `Wrong 'address' format in message at index ${index}`;\n    }\n    if (!isValidString(message.amount)) {\n        return `'amount' is required in message at index ${index}`;\n    }\n    if (!/^[0-9]+$/.test(message.amount)) {\n        return `Incorrect 'amount' in message at index ${index}`;\n    }\n    if (message.stateInit !== undefined) {\n        if (!isValidString(message.stateInit) || !isValidBoc(message.stateInit)) {\n            return `Invalid 'stateInit' in message at index ${index}`;\n        }\n    }\n    if (message.payload !== undefined) {\n        if (!isValidString(message.payload) || !isValidBoc(message.payload)) {\n            return `Invalid 'payload' in message at index ${index}`;\n        }\n    }\n    if (message.extraCurrency !== undefined) {\n        if (!isValidObject(message.extraCurrency)) {\n            return `Invalid 'extraCurrency' in message at index ${index}`;\n        }\n        for (const [key, value] of Object.entries(message.extraCurrency)) {\n            if (!INTEGER_REGEX.test(key) ||\n                typeof value !== 'string' ||\n                !POSITIVE_INTEGER_REGEX.test(value)) {\n                return `Invalid 'extraCurrency' format in message at index ${index}`;\n            }\n        }\n    }\n    return null;\n}\nfunction validateConnectAdditionalRequest(data) {\n    if (!isValidObject(data)) {\n        return 'Request must be an object';\n    }\n    const allowedKeys = ['tonProof'];\n    if (hasExtraProperties(data, allowedKeys)) {\n        return 'Request contains extra properties';\n    }\n    if (data.tonProof !== undefined) {\n        if (typeof data.tonProof !== 'string') {\n            return \"Invalid 'tonProof'\";\n        }\n        const payload = data.tonProof;\n        if (payload.length === 0) {\n            return \"Empty 'tonProof' payload\";\n        }\n        // Get current domain for validation first\n        const domain = getDomain();\n        if (!domain) {\n            // In Node.js environment, skip domain validation\n            return null;\n        }\n        // Validate domain size (max 128 bytes)\n        const domainBytes = new TextEncoder().encode(domain).length;\n        if (domainBytes > MAX_DOMAIN_BYTES) {\n            return 'Current domain exceeds 128 bytes limit';\n        }\n        // Validate payload size (max 128 bytes)\n        const payloadBytes = new TextEncoder().encode(payload).length;\n        if (payloadBytes > MAX_PAYLOAD_BYTES) {\n            return \"'tonProof' payload exceeds 128 bytes limit\";\n        }\n        // Validate total size (domain + payload <= 222 bytes)\n        if (domainBytes + payloadBytes > MAX_TOTAL_BYTES) {\n            return \"'tonProof' domain + payload exceeds 222 bytes limit\";\n        }\n    }\n    return null;\n}\nfunction validateSignDataPayload(data) {\n    if (!isValidObject(data)) {\n        return 'Payload must be an object';\n    }\n    if (!isValidString(data.type)) {\n        return \"'type' is required\";\n    }\n    switch (data.type) {\n        case 'text':\n            return validateSignDataPayloadText(data);\n        case 'binary':\n            return validateSignDataPayloadBinary(data);\n        case 'cell':\n            return validateSignDataPayloadCell(data);\n        default:\n            return \"Invalid 'type' value\";\n    }\n}\nfunction validateSignDataPayloadText(data) {\n    const allowedKeys = ['type', 'text', 'network', 'from'];\n    if (hasExtraProperties(data, allowedKeys)) {\n        return 'Text payload contains extra properties';\n    }\n    if (!isValidString(data.text)) {\n        return \"'text' is required\";\n    }\n    if (data.network !== undefined) {\n        if (!isValidNetwork(data.network)) {\n            return \"Invalid 'network' format\";\n        }\n    }\n    if (data.from !== undefined && !isValidAddress(data.from)) {\n        return \"Invalid 'from'\";\n    }\n    return null;\n}\nfunction validateSignDataPayloadBinary(data) {\n    const allowedKeys = ['type', 'bytes', 'network', 'from'];\n    if (hasExtraProperties(data, allowedKeys)) {\n        return 'Binary payload contains extra properties';\n    }\n    if (!isValidString(data.bytes)) {\n        return \"'bytes' is required\";\n    }\n    if (data.network !== undefined) {\n        if (!isValidNetwork(data.network)) {\n            return \"Invalid 'network' format\";\n        }\n    }\n    if (data.from !== undefined && !isValidAddress(data.from)) {\n        return \"Invalid 'from'\";\n    }\n    return null;\n}\nfunction validateSignDataPayloadCell(data) {\n    const allowedKeys = ['type', 'schema', 'cell', 'network', 'from'];\n    if (hasExtraProperties(data, allowedKeys)) {\n        return 'Cell payload contains extra properties';\n    }\n    if (!isValidString(data.schema)) {\n        return \"'schema' is required\";\n    }\n    if (!isValidString(data.cell)) {\n        return \"'cell' is required\";\n    }\n    if (!isValidBoc(data.cell)) {\n        return \"Invalid 'cell' format (must be valid base64)\";\n    }\n    if (data.network !== undefined) {\n        if (!isValidNetwork(data.network)) {\n            return \"Invalid 'network' format\";\n        }\n    }\n    if (data.from !== undefined && !isValidAddress(data.from)) {\n        return \"Invalid 'from'\";\n    }\n    return null;\n}\n/**\n * Validates ton_proof item received from wallet in connect event.\n */\n// eslint-disable-next-line complexity\nfunction validateTonProofItemReply(data) {\n    if (!isValidObject(data)) {\n        return 'ton_proof item must be an object';\n    }\n    const allowedKeys = ['error', 'proof', 'name'];\n    if (hasExtraProperties(data, allowedKeys)) {\n        return 'ton_proof item contains extra properties';\n    }\n    const hasProof = Object.prototype.hasOwnProperty.call(data, 'proof');\n    const hasError = Object.prototype.hasOwnProperty.call(data, 'error');\n    if (!hasProof && !hasError) {\n        return \"'ton_proof' item must contain either 'proof' or 'error'\";\n    }\n    if (hasProof && hasError) {\n        return \"'ton_proof' item must contain either 'proof' or 'error', not both\";\n    }\n    if (hasProof) {\n        const proof = data.proof;\n        if (!isValidObject(proof)) {\n            return \"Invalid 'proof' object\";\n        }\n        if (!isValidNumber(proof.timestamp)) {\n            return \"Invalid 'proof.timestamp'\";\n        }\n        const domain = proof.domain;\n        if (!isValidObject(domain)) {\n            return \"Invalid 'proof.domain'\";\n        }\n        if (!isValidNumber(domain.lengthBytes)) {\n            return \"Invalid 'proof.domain.lengthBytes'\";\n        }\n        if (!isValidString(domain.value)) {\n            return \"Invalid 'proof.domain.value'\";\n        }\n        // Try to verify that provided byte length matches actual byte length of value\n        try {\n            const encoderAvailable = typeof TextEncoder !== 'undefined';\n            const actualLength = encoderAvailable\n                ? new TextEncoder().encode(domain.value).length\n                : domain.value.length;\n            if (actualLength !== domain.lengthBytes) {\n                return \"'proof.domain.lengthBytes' does not match 'proof.domain.value'\";\n            }\n        }\n        catch (_a) {\n            // Ignore environment issues; best-effort validation\n        }\n        if (!isValidString(proof.payload)) {\n            return \"Invalid 'proof.payload'\";\n        }\n        if (!isValidString(proof.signature) || !BASE64_REGEX.test(proof.signature)) {\n            return \"Invalid 'proof.signature' format\";\n        }\n    }\n    if (hasError) {\n        const error = data.error;\n        if (!isValidObject(error)) {\n            return \"Invalid 'error' object\";\n        }\n        const allowedErrorKeys = ['code', 'message'];\n        if (hasExtraProperties(error, allowedErrorKeys)) {\n            return 'ton_proof error contains extra properties';\n        }\n        if (!isValidNumber(error.code)) {\n            return \"Invalid 'error.code'\";\n        }\n        if (!isValidString(error.message)) {\n            return \"Invalid 'error.message'\";\n        }\n    }\n    return null;\n}\n\nfunction normalizeBase64(data) {\n    if (typeof data !== 'string')\n        return undefined;\n    const paddedLength = data.length + ((4 - (data.length % 4)) % 4);\n    return data.replace(/-/g, '+').replace(/_/g, '/').padEnd(paddedLength, '=');\n}\n\n/**\n * Converts a PascalCase (or camelCase) string to kebab-case.\n *\n * For example:\n * - \"PascalCase\"  \"pascal-case\"\n * - \"camelCaseExample\"  \"camel-case-example\"\n *\n * @param value - The input string in PascalCase or camelCase format.\n * @returns The converted kebab-case string.\n */\nfunction pascalToKebab(value) {\n    return value.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();\n}\n/**\n * Collects static connection metrics from the browser's Performance API.\n * TTFB is measured once at page load and doesn't change.\n * @returns An object containing static connection metrics (TTFB) or empty object if not available.\n */\nfunction getStaticConnectionMetrics() {\n    const metrics = {};\n    // Get TTFB from Navigation Timing API (static, measured once at page load)\n    try {\n        const navEntries = performance.getEntriesByType('navigation');\n        if (navEntries.length > 0) {\n            const nav = navEntries[0];\n            if (nav.responseStart && nav.requestStart) {\n                metrics.conn_ttfb = Math.round(nav.responseStart - nav.requestStart);\n            }\n        }\n    }\n    catch (e) {\n        // Performance API not available or error occurred\n    }\n    return metrics;\n}\n/**\n * Collects dynamic connection metrics from the browser's Network Information API.\n * @returns An object containing dynamic connection metrics (RTT, network type) or empty object if not available.\n */\nfunction getDynamicConnectionMetrics() {\n    const metrics = {};\n    // Get RTT and network type from Network Information API (dynamic, can change)\n    try {\n        const navigatorWithConnection = navigator;\n        const connection = navigatorWithConnection.connection ||\n            navigatorWithConnection.mozConnection ||\n            navigatorWithConnection.webkitConnection;\n        if (connection) {\n            if (connection.rtt !== undefined) {\n                metrics.conn_rtt = connection.rtt;\n            }\n            if (connection.effectiveType) {\n                metrics.conn_network_type = connection.effectiveType;\n            }\n            else if (connection.type) {\n                metrics.conn_network_type = connection.type;\n            }\n        }\n    }\n    catch (e) {\n        // Network Information API not available or error occurred\n    }\n    return metrics;\n}\n\nclass AnalyticsManager {\n    constructor(options = {}) {\n        var _a, _b, _c, _d, _e, _f;\n        this.events = [];\n        this.timeoutId = null;\n        this.isProcessing = false;\n        this.backoff = 1;\n        this.shouldSend = true;\n        this.batchTimeoutMs = (_a = options.batchTimeoutMs) !== null && _a !== void 0 ? _a : 2000;\n        this.currentBatchTimeoutMs = this.batchTimeoutMs;\n        this.maxBatchSize = (_b = options.maxBatchSize) !== null && _b !== void 0 ? _b : 100;\n        this.analyticsUrl = (_c = options.analyticsUrl) !== null && _c !== void 0 ? _c : 'https://analytics.ton.org/events';\n        this.mode = (_d = options.mode) !== null && _d !== void 0 ? _d : 'telemetry';\n        this.baseEvent = Object.assign({ subsystem: 'dapp-sdk', version: tonConnectSdkVersion, client_environment: (_f = (_e = options.environment) === null || _e === void 0 ? void 0 : _e.getClientEnvironment) === null || _f === void 0 ? void 0 : _f.call(_e) }, getStaticConnectionMetrics());\n        this.addWindowFocusAndBlurSubscriptions();\n    }\n    scoped(sharedData) {\n        return new Proxy(this, {\n            get(target, prop) {\n                const propName = prop.toString();\n                if (propName.startsWith('emit')) {\n                    const eventNamePascal = propName.replace('emit', '');\n                    const eventNameKebab = pascalToKebab(eventNamePascal);\n                    return function (event) {\n                        const executedData = Object.fromEntries(Object.entries(sharedData !== null && sharedData !== void 0 ? sharedData : {}).map(([key, value]) => [\n                            key,\n                            typeof value === 'function' ? value() : value\n                        ]));\n                        return target.emit(Object.assign(Object.assign({ event_name: eventNameKebab }, executedData), event));\n                    };\n                }\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                return target[prop];\n            }\n        });\n    }\n    emit(event) {\n        var _a;\n        if (this.mode === 'off') {\n            return;\n        }\n        const traceId = (_a = event.trace_id) !== null && _a !== void 0 ? _a : UUIDv7();\n        const dynamicMetrics = getDynamicConnectionMetrics();\n        const enhancedEvent = Object.assign(Object.assign(Object.assign(Object.assign({}, this.baseEvent), dynamicMetrics), event), { event_id: UUIDv7(), client_timestamp: Math.floor(Date.now() / 1000), trace_id: traceId });\n        const filteredEvent = this.mode === 'telemetry' ? this.filterFullModeFields(enhancedEvent) : enhancedEvent;\n        if (isQaModeEnabled()) {\n            logDebug(filteredEvent);\n        }\n        this.events.push(filteredEvent);\n        if (this.events.length >= this.maxBatchSize) {\n            void this.flush();\n            return;\n        }\n        this.startTimeout();\n    }\n    startTimeout() {\n        if (this.timeoutId || this.isProcessing) {\n            return;\n        }\n        this.timeoutId = setTimeout(() => {\n            void this.flush();\n        }, this.currentBatchTimeoutMs);\n    }\n    flush() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.isProcessing || this.events.length === 0 || !this.shouldSend) {\n                return;\n            }\n            this.clearTimeout();\n            this.isProcessing = true;\n            const eventsToSend = this.extractEventsToSend();\n            try {\n                yield this.processEventsBatch(eventsToSend);\n                logDebug('Analytics events sent successfully');\n            }\n            catch (error) {\n                this.restoreEvents(eventsToSend);\n                logError('Failed to send analytics events:', error);\n            }\n            finally {\n                this.isProcessing = false;\n                this.scheduleNextFlushIfNeeded();\n            }\n        });\n    }\n    clearTimeout() {\n        if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n            this.timeoutId = null;\n        }\n    }\n    extractEventsToSend() {\n        const eventsToSend = this.events.slice(0, this.maxBatchSize);\n        this.events = this.events.slice(this.maxBatchSize);\n        return eventsToSend;\n    }\n    processEventsBatch(eventsToSend) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logDebug('Sending analytics events...', eventsToSend.length);\n            try {\n                const response = yield this.sendEvents(eventsToSend);\n                this.handleResponse(response);\n            }\n            catch (err) {\n                this.handleUnknownError(err);\n            }\n        });\n    }\n    handleResponse(response) {\n        const { status, statusText } = response;\n        if (this.isTooManyRequests(status)) {\n            this.handleTooManyRequests(status, statusText);\n        }\n        else if (this.isClientError(status)) {\n            this.handleClientError(status, statusText);\n        }\n        else if (this.isServerError(status)) {\n            this.handleUnknownError({ status, statusText });\n        }\n    }\n    restoreEvents(eventsToSend) {\n        this.events.unshift(...eventsToSend);\n    }\n    scheduleNextFlushIfNeeded() {\n        if (this.events.length > 0) {\n            this.startTimeout();\n        }\n    }\n    sendEvents(events) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield fetch(this.analyticsUrl, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Client-Timestamp': Math.floor(Date.now() / 1000).toString()\n                },\n                body: JSON.stringify(events)\n            });\n        });\n    }\n    isClientError(status) {\n        return (status >= AnalyticsManager.HTTP_STATUS.CLIENT_ERROR_START &&\n            status < AnalyticsManager.HTTP_STATUS.SERVER_ERROR_START);\n    }\n    isServerError(status) {\n        return status >= AnalyticsManager.HTTP_STATUS.SERVER_ERROR_START;\n    }\n    isTooManyRequests(status) {\n        return status === AnalyticsManager.HTTP_STATUS.TOO_MANY_REQUESTS;\n    }\n    handleClientError(status, statusText) {\n        // Don't retry\n        logError('Failed to send analytics events:', new TonConnectError(`Analytics API error: ${status} ${statusText}`));\n    }\n    handleUnknownError(error) {\n        if (this.backoff < AnalyticsManager.MAX_BACKOFF_ATTEMPTS) {\n            this.backoff++;\n            this.currentBatchTimeoutMs *= AnalyticsManager.BACKOFF_MULTIPLIER;\n            throw new TonConnectError(`Unknown analytics API error: ${error}`);\n        }\n        else {\n            this.currentBatchTimeoutMs = this.batchTimeoutMs;\n            this.backoff = 1;\n            return; // Don't retry\n        }\n    }\n    handleTooManyRequests(status, statusText) {\n        throw new TonConnectError(`Analytics API error: ${status} ${statusText}`);\n    }\n    addWindowFocusAndBlurSubscriptions() {\n        const document = getDocument();\n        if (!document) {\n            return;\n        }\n        try {\n            document.addEventListener('visibilitychange', () => {\n                if (document.hidden) {\n                    this.clearTimeout();\n                    this.shouldSend = false;\n                }\n                else {\n                    this.shouldSend = true;\n                    this.scheduleNextFlushIfNeeded();\n                }\n            });\n        }\n        catch (e) {\n            logError('Cannot subscribe to the document.visibilitychange: ', e);\n        }\n    }\n    getMode() {\n        return this.mode;\n    }\n    getPendingEventsCount() {\n        return this.events.length;\n    }\n    filterFullModeFields(event) {\n        const filtered = Object.assign({}, event);\n        for (const field of AnalyticsManager.FULL_MODE_FIELDS) {\n            delete filtered[field];\n        }\n        // wallet_address is kept for error events, removed for non-error events\n        const eventName = 'event_name' in event ? String(event.event_name) : '';\n        const isErrorEvent = 'error_code' in event ||\n            'error_message' in event ||\n            eventName.includes('error') ||\n            eventName === 'connection-error' ||\n            eventName === 'transaction-signing-failed' ||\n            eventName === 'sign-data-request-failed';\n        if (!isErrorEvent && 'wallet_address' in filtered) {\n            delete filtered.wallet_address;\n        }\n        return filtered;\n    }\n    setWalletListDownloadDuration(duration) {\n        this.baseEvent = Object.assign(Object.assign({}, this.baseEvent), { wallet_list_download_duration: duration });\n    }\n}\nAnalyticsManager.HTTP_STATUS = {\n    TOO_MANY_REQUESTS: 429,\n    CLIENT_ERROR_START: 400,\n    SERVER_ERROR_START: 500\n};\nAnalyticsManager.MAX_BACKOFF_ATTEMPTS = 5;\nAnalyticsManager.BACKOFF_MULTIPLIER = 2;\nAnalyticsManager.FULL_MODE_FIELDS = [\n    'user_id',\n    'tg_id',\n    'locale',\n    'tma_is_premium'\n];\n\n/**\n * A concrete implementation of EventDispatcher that dispatches events to the browser window.\n */\nclass BrowserEventDispatcher {\n    constructor() {\n        /**\n         * The window object, possibly undefined in a server environment.\n         * @private\n         */\n        this.window = getWindow();\n    }\n    /**\n     * Dispatches an event with the given name and details to the browser window.\n     * @param eventName - The name of the event to dispatch.\n     * @param eventDetails - The details of the event to dispatch.\n     * @returns A promise that resolves when the event has been dispatched.\n     */\n    dispatchEvent(eventName, eventDetails) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const event = new CustomEvent(eventName, { detail: eventDetails });\n            (_a = this.window) === null || _a === void 0 ? void 0 : _a.dispatchEvent(event);\n        });\n    }\n    /**\n     * Adds an event listener to the browser window.\n     * @param eventName - The name of the event to listen for.\n     * @param listener - The listener to add.\n     * @param options - The options for the listener.\n     * @returns A function that removes the listener.\n     */\n    addEventListener(eventName, listener, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            (_a = this.window) === null || _a === void 0 ? void 0 : _a.addEventListener(eventName, listener, options);\n            return () => {\n                var _a;\n                return (_a = this.window) === null || _a === void 0 ? void 0 : _a.removeEventListener(eventName, listener);\n            };\n        });\n    }\n}\n\nfunction buildVersionInfo(version) {\n    return {\n        '@tonconnect/sdk': version.ton_connect_sdk_lib || '',\n        '@tonconnect/ui': version.ton_connect_ui_lib || ''\n    };\n}\nfunction buildTonConnectEvent(detail) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    return {\n        versions: buildVersionInfo(detail.custom_data),\n        network_id: (_a = detail.custom_data.chain_id) !== null && _a !== void 0 ? _a : '',\n        client_id: (_b = detail.custom_data.client_id) !== null && _b !== void 0 ? _b : '',\n        wallet_id: (_c = detail.custom_data.wallet_id) !== null && _c !== void 0 ? _c : '',\n        wallet_address: (_d = detail.wallet_address) !== null && _d !== void 0 ? _d : '',\n        wallet_app_name: (_e = detail.wallet_type) !== null && _e !== void 0 ? _e : '',\n        wallet_app_version: (_f = detail.wallet_version) !== null && _f !== void 0 ? _f : '',\n        wallet_state_init: (_g = detail.wallet_state_init) !== null && _g !== void 0 ? _g : '',\n        trace_id: (_h = detail.trace_id) !== null && _h !== void 0 ? _h : undefined\n    };\n}\nfunction bindEventsTo(eventDispatcher, analytics) {\n    eventDispatcher.addEventListener('ton-connect-ui-wallet-modal-opened', event => {\n        var _a;\n        const { detail } = event;\n        analytics.emitConnectionStarted({\n            client_id: detail.client_id || '',\n            versions: buildVersionInfo(detail.custom_data),\n            main_screen: detail.visible_wallets,\n            trace_id: (_a = detail.trace_id) !== null && _a !== void 0 ? _a : undefined\n        });\n    });\n    eventDispatcher.addEventListener('ton-connect-ui-selected-wallet', event => {\n        var _a, _b;\n        const { detail } = event;\n        analytics.emitConnectionSelectedWallet({\n            client_id: detail.client_id || '',\n            versions: buildVersionInfo(detail.custom_data),\n            main_screen: detail.visible_wallets,\n            wallets_menu: detail.wallets_menu,\n            trace_id: (_a = detail.trace_id) !== null && _a !== void 0 ? _a : undefined,\n            wallet_app_name: (_b = detail.wallet_type) !== null && _b !== void 0 ? _b : '',\n            wallet_redirect_method: detail.wallet_redirect_method,\n            wallet_redirect_link: detail.wallet_redirect_link\n        });\n    });\n    eventDispatcher.addEventListener('ton-connect-connection-completed', event => {\n        const { detail } = event;\n        analytics.emitConnectionCompleted(buildTonConnectEvent(detail));\n    });\n    eventDispatcher.addEventListener('ton-connect-connection-error', event => {\n        var _a, _b;\n        const { detail } = event;\n        analytics.emitConnectionError({\n            client_id: detail.custom_data.client_id || '',\n            wallet_id: detail.custom_data.wallet_id || '',\n            error_code: (_a = detail.error_code) !== null && _a !== void 0 ? _a : 0,\n            error_message: detail.error_message,\n            trace_id: (_b = detail.trace_id) !== null && _b !== void 0 ? _b : undefined\n        });\n    });\n    eventDispatcher.addEventListener('ton-connect-disconnection', event => {\n        const { detail } = event;\n        analytics.emitDisconnection(buildTonConnectEvent(detail));\n    });\n    eventDispatcher.addEventListener('ton-connect-transaction-sent-for-signature', event => {\n        const { detail } = event;\n        analytics.emitTransactionSent(buildTonConnectEvent(detail));\n    });\n    eventDispatcher.addEventListener('ton-connect-transaction-signed', event => {\n        const { detail } = event;\n        analytics.emitTransactionSigned(Object.assign(Object.assign({}, buildTonConnectEvent(detail)), { signed_boc: event.detail.signed_transaction }));\n    });\n    eventDispatcher.addEventListener('ton-connect-transaction-signing-failed', event => {\n        var _a;\n        const { detail } = event;\n        analytics.emitTransactionSigningFailed(Object.assign(Object.assign({}, buildTonConnectEvent(detail)), { valid_until: Number(detail.valid_until), messages: detail.messages.map(message => {\n                var _a, _b, _c, _d;\n                return ({\n                    address: (_a = message.address) !== null && _a !== void 0 ? _a : '',\n                    amount: (_b = message.amount) !== null && _b !== void 0 ? _b : '',\n                    payload: (_c = message.payload) !== null && _c !== void 0 ? _c : '',\n                    state_init: (_d = message.state_init) !== null && _d !== void 0 ? _d : ''\n                });\n            }), error_message: detail.error_message, error_code: (_a = detail.error_code) !== null && _a !== void 0 ? _a : 0 }));\n    });\n    eventDispatcher.addEventListener('ton-connect-sign-data-request-initiated', event => {\n        const { detail } = event;\n        analytics === null || analytics === void 0 ? void 0 : analytics.emitSignDataRequestInitiated(buildTonConnectEvent(detail));\n    });\n    eventDispatcher.addEventListener('ton-connect-sign-data-request-completed', event => {\n        const { detail } = event;\n        analytics === null || analytics === void 0 ? void 0 : analytics.emitSignDataRequestCompleted(buildTonConnectEvent(detail));\n    });\n    eventDispatcher.addEventListener('ton-connect-sign-data-request-failed', event => {\n        var _a;\n        const { detail } = event;\n        let signDataValue = '';\n        let signDataSchema = undefined;\n        if (detail.data.type === 'text') {\n            signDataValue = detail.data.text;\n        }\n        if (detail.data.type === 'cell') {\n            signDataValue = detail.data.cell;\n            signDataSchema = detail.data.schema;\n        }\n        if (detail.data.type === 'binary') {\n            signDataValue = detail.data.bytes;\n        }\n        analytics === null || analytics === void 0 ? void 0 : analytics.emitSignDataRequestFailed(Object.assign(Object.assign({}, buildTonConnectEvent(detail)), { sign_data_type: detail.data.type, sign_data_value: signDataValue, sign_data_schema: signDataSchema, error_code: (_a = detail.error_code) !== null && _a !== void 0 ? _a : 0, error_message: detail.error_message }));\n    });\n}\n\nclass DefaultEnvironment {\n    getClientEnvironment() {\n        return '';\n    }\n    getBrowser() {\n        return '';\n    }\n    getLocale() {\n        return '';\n    }\n    getPlatform() {\n        return '';\n    }\n    getTelegramUser() {\n        return undefined;\n    }\n}\n\nconst state = {};\n/**\n * Initializes the WalletConnect integration.\n *\n * This function must be called once before using WalletConnect features.\n * A second call will throw an error to prevent accidental re-initialization.\n *\n * @param UniversalConnectorCls - A UniversalConnector class imported from '@reown/appkit-universal-connector'\n * @param {WalletConnectOptions} walletConnectOptions - Configuration options used for initializing WalletConnect.\n * @example\n * import { UniversalConnector } from '@reown/appkit-universal-connector';\n *\n * initializeWalletConnect(UniversalConnector, {\n *     projectId: 'abcd1234abcd1234abcd1234abcd1234',\n *     metadata: {\n *         name: 'Demo DApp',\n *         icons: [\n *             'https://example.com/my-icon.png'\n *         ],\n *         url: window.location.origin,\n *         description: 'Demo DApp'\n *     }\n * });\n */\nfunction initializeWalletConnect(UniversalConnectorCls, walletConnectOptions) {\n    if ((state === null || state === void 0 ? void 0 : state.walletConnectOptions) !== undefined || (state === null || state === void 0 ? void 0 : state.UniversalConnectorCls) !== undefined) {\n        throw new TonConnectError('Wallet Connect already initialized.');\n    }\n    if (typeof UniversalConnectorCls !== 'function' || !('init' in UniversalConnectorCls)) {\n        throw new TonConnectError('Initialize UniversalConnectorCls must be set');\n    }\n    state.UniversalConnectorCls = UniversalConnectorCls;\n    state.walletConnectOptions = walletConnectOptions;\n}\nfunction isWalletConnectInitialized() {\n    return state.UniversalConnectorCls !== undefined && state.walletConnectOptions !== undefined;\n}\nfunction getUniversalConnector() {\n    if (state.UniversalConnectorCls === undefined) {\n        throw new TonConnectError('Wallet Connect is not initialized.');\n    }\n    return state.UniversalConnectorCls;\n}\nfunction getWalletConnectOptions() {\n    if (state.walletConnectOptions === undefined) {\n        throw new TonConnectError('Wallet Connect is not initialized.');\n    }\n    return state.walletConnectOptions;\n}\n\nconst DEFAULT_REQUEST_ID = '0';\nconst DEFAULT_EVENT_ID = 0;\nclass WalletConnectProvider {\n    constructor(connectionStorage) {\n        this.connectionStorage = connectionStorage;\n        this.type = 'injected';\n        this.listeners = [];\n        this.connector = undefined;\n        const { projectId, metadata } = getWalletConnectOptions();\n        this.config = {\n            networks: [\n                {\n                    namespace: 'ton',\n                    chains: [\n                        {\n                            id: -239,\n                            chainNamespace: 'ton',\n                            caipNetworkId: 'ton:-239',\n                            name: 'TON',\n                            nativeCurrency: { name: 'TON', symbol: 'TON', decimals: 9 },\n                            rpcUrls: { default: { http: [] } }\n                        },\n                        {\n                            id: -3,\n                            chainNamespace: 'ton',\n                            caipNetworkId: 'ton:-3',\n                            name: 'TON',\n                            nativeCurrency: { name: 'TON', symbol: 'TON', decimals: 9 },\n                            rpcUrls: { default: { http: [] } }\n                        }\n                    ],\n                    methods: ['ton_sendMessage', 'ton_signData'],\n                    events: []\n                }\n            ],\n            projectId,\n            metadata\n        };\n    }\n    static fromStorage(storage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new WalletConnectProvider(storage);\n        });\n    }\n    initialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.connector) {\n                this.connector = yield getUniversalConnector().init(this.config);\n            }\n            return this.connector;\n        });\n    }\n    connect(message, options) {\n        var _a, _b;\n        const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n        const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n        (_b = this.abortController) === null || _b === void 0 ? void 0 : _b.abort();\n        this.abortController = abortController;\n        void this._connect(message, {\n            traceId,\n            signal: abortController.signal,\n            abortController\n        }).catch(error => logDebug('WalletConnect connect unexpected error', error));\n    }\n    _connect(message, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            const connector = yield this.initialize();\n            if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {\n                logDebug('WalletConnect connect aborted before start');\n                this.clearAbortController(options.abortController);\n                return;\n            }\n            const tonProof = message.items.find(item => item.name === 'ton_proof');\n            const authentication = tonProof\n                ? [\n                    {\n                        domain: new URL(this.config.metadata.url).hostname,\n                        chains: ['ton:-239'],\n                        nonce: '',\n                        uri: 'ton_proof',\n                        ttl: 0,\n                        statement: tonProof.payload\n                    }\n                ]\n                : undefined;\n            logDebug('Connecting through this.connector.connect');\n            try {\n                yield connector.connect({ authentication });\n            }\n            catch (error) {\n                if ((_b = options.signal) === null || _b === void 0 ? void 0 : _b.aborted) {\n                    logDebug('WalletConnect connect aborted via signal');\n                    this.clearAbortController(options.abortController);\n                    return;\n                }\n                logDebug('WalletConnect connect error', error);\n                const event = {\n                    id: DEFAULT_EVENT_ID,\n                    event: 'connect_error',\n                    traceId: options.traceId,\n                    payload: {\n                        code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.USER_REJECTS_ERROR,\n                        message: 'User declined the connection'\n                    }\n                };\n                logDebug('WalletConnect connect response:', event);\n                this.emit(event);\n                this.clearAbortController(options.abortController);\n                return;\n            }\n            logDebug('Connected through this.connector.connect');\n            try {\n                yield this.onConnect(connector, Object.assign(Object.assign({}, options), { includeTonProof: true }));\n            }\n            catch (error) {\n                logDebug('WalletConnect onConnect error', error);\n                yield this.disconnect({ traceId: options.traceId, signal: options.signal });\n            }\n            finally {\n                this.clearAbortController(options.abortController);\n            }\n        });\n    }\n    restoreConnection(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n            (_b = this.abortController) === null || _b === void 0 ? void 0 : _b.abort();\n            this.abortController = abortController;\n            if (abortController.signal.aborted) {\n                return;\n            }\n            try {\n                logDebug('Restoring WalletConnect connection...');\n                const storedConnection = yield this.connectionStorage.getWalletConnectConnection();\n                if (!storedConnection || abortController.signal.aborted) {\n                    return;\n                }\n                const connector = yield this.initialize();\n                if (abortController.signal.aborted) {\n                    return;\n                }\n                yield this.onConnect(connector, {\n                    includeTonProof: false,\n                    traceId,\n                    signal: abortController.signal\n                });\n                logDebug('WalletConnect successfully restored.');\n            }\n            catch (error) {\n                logDebug('WalletConnect restore error', error);\n                yield this.disconnect({ traceId, signal: abortController.signal });\n            }\n            finally {\n                this.clearAbortController(abortController);\n            }\n        });\n    }\n    closeConnection() {\n        var _a;\n        (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort();\n        this.abortController = undefined;\n        void this.disconnect();\n    }\n    disconnect(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n            (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort();\n            this.abortController = abortController;\n            if (abortController.signal.aborted) {\n                return;\n            }\n            try {\n                yield this.connectionStorage.removeConnection();\n                if (abortController.signal.aborted) {\n                    return;\n                }\n                yield ((_b = this.connector) === null || _b === void 0 ? void 0 : _b.disconnect());\n            }\n            catch (error) {\n                logDebug('WalletConnect disconnect error', error);\n            }\n            finally {\n                this.clearAbortController(abortController);\n            }\n        });\n    }\n    sendRequest(request, optionsOrOnRequestSent) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d;\n            if (!this.connector) {\n                throw new TonConnectError('Wallet Connect not initialized');\n            }\n            const options = {};\n            if (typeof optionsOrOnRequestSent === 'function') {\n                options.onRequestSent = optionsOrOnRequestSent;\n            }\n            else {\n                options.onRequestSent = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.onRequestSent;\n                options.signal = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.signal;\n                options.attempts = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.attempts;\n                options.traceId = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.traceId;\n            }\n            (_a = options.traceId) !== null && _a !== void 0 ? _a : (options.traceId = UUIDv7());\n            try {\n                if ((_b = options.signal) === null || _b === void 0 ? void 0 : _b.aborted) {\n                    throw new TonConnectError('WalletConnect request aborted');\n                }\n                logDebug('Send wallet-connect request:', Object.assign(Object.assign({}, request), { id: DEFAULT_REQUEST_ID }));\n                if (request.method === 'sendTransaction') {\n                    const _e = JSON.parse(request.params[0]), { network } = _e, sendTransactionPayload = __rest(_e, [\"network\"]);\n                    const promise = this.connector.request({\n                        method: 'ton_sendMessage',\n                        params: sendTransactionPayload\n                    }, `ton:${network}`);\n                    (_c = options === null || options === void 0 ? void 0 : options.onRequestSent) === null || _c === void 0 ? void 0 : _c.call(options);\n                    const result = (yield promise);\n                    logDebug('Wallet message received:', { result, id: DEFAULT_REQUEST_ID });\n                    return {\n                        result,\n                        id: DEFAULT_REQUEST_ID,\n                        traceId: options.traceId\n                    };\n                }\n                else if (request.method === 'signData') {\n                    const _f = JSON.parse(request.params[0]), { network } = _f, signDataPayload = __rest(_f, [\"network\"]);\n                    const promise = this.connector.request({\n                        method: 'ton_signData',\n                        params: signDataPayload\n                    }, `ton:${network}`);\n                    (_d = options === null || options === void 0 ? void 0 : options.onRequestSent) === null || _d === void 0 ? void 0 : _d.call(options);\n                    const result = (yield promise);\n                    logDebug('Wallet message received:', { result, id: DEFAULT_REQUEST_ID });\n                    return { result, traceId: options.traceId, id: DEFAULT_REQUEST_ID };\n                }\n                else if (request.method === 'disconnect') {\n                    return {\n                        id: DEFAULT_REQUEST_ID,\n                        traceId: options.traceId\n                    };\n                }\n            }\n            catch (error) {\n                logDebug('WalletConnect request error', error, error.stack);\n                const result = (yield this.handleWalletConnectError(error, {\n                    traceId: options.traceId\n                }));\n                logDebug('Wallet message received:', result);\n                return result;\n            }\n            return {\n                id: DEFAULT_REQUEST_ID,\n                error: { code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.DISCONNECT_ERROR_CODES.UNKNOWN_ERROR, message: 'Not implemented.' },\n                traceId: options.traceId\n            };\n        });\n    }\n    handleWalletConnectError(error, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof error === 'object' && error !== null) {\n                const message = String('message' in error ? error.message : 'msg' in error ? error.msg : error);\n                if (message.toLowerCase().includes('reject')) {\n                    return {\n                        id: DEFAULT_REQUEST_ID,\n                        traceId: options.traceId,\n                        error: {\n                            code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.USER_REJECTS_ERROR,\n                            message\n                        }\n                    };\n                }\n                if (message.toLowerCase().includes('tonvalidationerror')) {\n                    return {\n                        id: DEFAULT_REQUEST_ID,\n                        traceId: options.traceId,\n                        error: {\n                            code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.BAD_REQUEST_ERROR,\n                            message\n                        }\n                    };\n                }\n                return {\n                    id: DEFAULT_REQUEST_ID,\n                    traceId: options.traceId,\n                    error: {\n                        code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.UNKNOWN_ERROR,\n                        message\n                    }\n                };\n            }\n            return {\n                id: DEFAULT_REQUEST_ID,\n                traceId: options.traceId,\n                error: {\n                    code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.UNKNOWN_ERROR,\n                    message: String(error)\n                }\n            };\n        });\n    }\n    listen(callback) {\n        this.listeners.push(callback);\n        return () => (this.listeners = this.listeners.filter(listener => listener !== callback));\n    }\n    buildTonProof(connector) {\n        var _a, _b, _c;\n        const auth = (_a = connector.provider.session.authentication) === null || _a === void 0 ? void 0 : _a[0];\n        const iat = (_b = auth === null || auth === void 0 ? void 0 : auth.p) === null || _b === void 0 ? void 0 : _b.iat;\n        const statement = (_c = auth === null || auth === void 0 ? void 0 : auth.p) === null || _c === void 0 ? void 0 : _c.statement;\n        if (!iat || !statement) {\n            return;\n        }\n        const domain = auth.p.domain;\n        return {\n            name: 'ton_proof',\n            proof: {\n                timestamp: Math.floor(new Date(iat).getTime() / 1000),\n                domain: {\n                    lengthBytes: domain.length,\n                    value: domain\n                },\n                payload: statement,\n                signature: auth.s.s\n            }\n        };\n    }\n    onConnect(connector, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d;\n            if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {\n                logDebug('WalletConnect onConnect aborted');\n                return;\n            }\n            const session = connector.provider.session;\n            const tonNamespace = session.namespaces['ton'];\n            if (!((_b = tonNamespace === null || tonNamespace === void 0 ? void 0 : tonNamespace.accounts) === null || _b === void 0 ? void 0 : _b[0])) {\n                yield this.disconnectWithError({\n                    traceId: options.traceId,\n                    code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.BAD_REQUEST_ERROR,\n                    message: 'Connection error. No TON accounts connected.'\n                });\n                return;\n            }\n            const account = tonNamespace.accounts[0];\n            const [, network, address] = account.split(':', 3);\n            const publicKey = (_c = session.sessionProperties) === null || _c === void 0 ? void 0 : _c.ton_getPublicKey;\n            if (!publicKey) {\n                yield this.disconnectWithError({\n                    traceId: options.traceId,\n                    code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.BAD_REQUEST_ERROR,\n                    message: 'Connection error. No sessionProperties.ton_getPublicKey provided.'\n                });\n                return;\n            }\n            const stateInit = (_d = session.sessionProperties) === null || _d === void 0 ? void 0 : _d.ton_getStateInit;\n            if (!stateInit) {\n                yield this.disconnectWithError({\n                    traceId: options.traceId,\n                    code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.BAD_REQUEST_ERROR,\n                    message: 'Connection error. No sessionProperties.ton_getStateInit provided.'\n                });\n                return;\n            }\n            connector.provider.once('session_delete', () => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    yield this.connectionStorage.removeConnection();\n                    const event = {\n                        event: 'disconnect',\n                        traceId: UUIDv7(),\n                        payload: {}\n                    };\n                    logDebug('Wallet message received:', event);\n                    this.emit(event);\n                }\n                catch (err) {\n                    logDebug('Error while deleting session', err);\n                }\n            }));\n            const tonProof = (options === null || options === void 0 ? void 0 : options.includeTonProof) ? this.buildTonProof(connector) : undefined;\n            const parsedAddress = isValidUserFriendlyAddress(address)\n                ? toRawAddress(parseUserFriendlyAddress(address))\n                : address;\n            const features = this.buildFeatureList(tonNamespace.methods);\n            const payload = {\n                items: [\n                    {\n                        name: 'ton_addr',\n                        address: parsedAddress,\n                        network: network,\n                        publicKey,\n                        walletStateInit: stateInit\n                    },\n                    ...(tonProof ? [tonProof] : [])\n                ],\n                device: {\n                    appName: 'wallet_connect',\n                    appVersion: '',\n                    maxProtocolVersion: 2,\n                    features,\n                    platform: 'browser'\n                }\n            };\n            logDebug('WalletConnect connect response:', {\n                event: 'connect',\n                payload,\n                id: DEFAULT_EVENT_ID\n            });\n            this.emit({ event: 'connect', payload, traceId: options.traceId });\n            yield this.storeConnection();\n        });\n    }\n    buildFeatureList(methods) {\n        const features = [];\n        if (methods.includes('ton_sendMessage')) {\n            features.push('SendTransaction', {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            });\n        }\n        if (methods.includes('ton_signData')) {\n            features.push({ name: 'SignData', types: ['text', 'binary', 'cell'] });\n        }\n        return features;\n    }\n    disconnectWithError(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.disconnect();\n            const payload = {\n                code: options.code,\n                message: options.message\n            };\n            logDebug('WalletConnect connect response:', {\n                event: 'connect_error',\n                id: DEFAULT_EVENT_ID,\n                payload\n            });\n            this.emit({\n                event: 'connect_error',\n                traceId: options.traceId,\n                payload\n            });\n        });\n    }\n    clearAbortController(abortController) {\n        if (this.abortController === abortController) {\n            this.abortController = undefined;\n        }\n    }\n    emit(event, listeners) {\n        (listeners !== null && listeners !== void 0 ? listeners : this.listeners).forEach(listener => listener(event));\n    }\n    storeConnection() {\n        return this.connectionStorage.storeConnection({\n            type: 'wallet-connect'\n        });\n    }\n}\n\nclass TonConnect {\n    /**\n     * Returns available wallets list.\n     */\n    static getWallets() {\n        return this.walletsList.getWallets();\n    }\n    /**\n     * Shows if the wallet is connected right now.\n     */\n    get connected() {\n        return this._wallet !== null;\n    }\n    /**\n     * Current connected account or null if no account is connected.\n     */\n    get account() {\n        var _a;\n        return ((_a = this._wallet) === null || _a === void 0 ? void 0 : _a.account) || null;\n    }\n    /**\n     * Current connected wallet or null if no account is connected.\n     */\n    get wallet() {\n        return this._wallet;\n    }\n    set wallet(value) {\n        this._wallet = value;\n        this.statusChangeSubscriptions.forEach(callback => callback(this._wallet));\n    }\n    constructor(options) {\n        var _a, _b, _c;\n        this._wallet = null;\n        this.provider = null;\n        this.statusChangeSubscriptions = [];\n        this.statusChangeErrorSubscriptions = [];\n        const manifestUrl = (options === null || options === void 0 ? void 0 : options.manifestUrl) || getWebPageManifest();\n        this.dappSettings = {\n            manifestUrl,\n            storage: (options === null || options === void 0 ? void 0 : options.storage) || new DefaultStorage()\n        };\n        this.walletsRequiredFeatures = options === null || options === void 0 ? void 0 : options.walletsRequiredFeatures;\n        this.environment = (_a = options === null || options === void 0 ? void 0 : options.environment) !== null && _a !== void 0 ? _a : new DefaultEnvironment();\n        this.walletsList = new WalletsListManager({\n            walletsListSource: options === null || options === void 0 ? void 0 : options.walletsListSource,\n            cacheTTLMs: options === null || options === void 0 ? void 0 : options.walletsListCacheTTLMs,\n            onDownloadDurationMeasured: (duration) => {\n                var _a;\n                (_a = this.analytics) === null || _a === void 0 ? void 0 : _a.setWalletListDownloadDuration(duration);\n            }\n        });\n        const eventDispatcher = (_b = options === null || options === void 0 ? void 0 : options.eventDispatcher) !== null && _b !== void 0 ? _b : new BrowserEventDispatcher();\n        this.tracker = new TonConnectTracker({\n            eventDispatcher,\n            tonConnectSdkVersion: tonConnectSdkVersion\n        });\n        this.environment = (_c = options === null || options === void 0 ? void 0 : options.environment) !== null && _c !== void 0 ? _c : new DefaultEnvironment();\n        this.initAnalytics(manifestUrl, eventDispatcher, options);\n        if (!this.dappSettings.manifestUrl) {\n            throw new DappMetadataError('Dapp tonconnect-manifest.json must be specified if window.location.origin is undefined. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest');\n        }\n        this.bridgeConnectionStorage = new BridgeConnectionStorage(this.dappSettings.storage, this.walletsList);\n        if (!(options === null || options === void 0 ? void 0 : options.disableAutoPauseConnection)) {\n            this.addWindowFocusAndBlurSubscriptions();\n        }\n    }\n    /**\n     * Returns available wallets list.\n     */\n    getWallets() {\n        return this.walletsList.getWallets();\n    }\n    /**\n     * Allows to subscribe to connection status changes and handle connection errors.\n     * @param callback will be called after connections status changes with actual wallet or null.\n     * @param errorsHandler (optional) will be called with some instance of TonConnectError when connect error is received.\n     * @returns unsubscribe callback.\n     */\n    onStatusChange(callback, errorsHandler) {\n        this.statusChangeSubscriptions.push(callback);\n        if (errorsHandler) {\n            this.statusChangeErrorSubscriptions.push(errorsHandler);\n        }\n        return () => {\n            this.statusChangeSubscriptions = this.statusChangeSubscriptions.filter(item => item !== callback);\n            if (errorsHandler) {\n                this.statusChangeErrorSubscriptions = this.statusChangeErrorSubscriptions.filter(item => item !== errorsHandler);\n            }\n        };\n    }\n    // eslint-disable-next-line complexity\n    connect(wallet, requestOrOptions, additionalOptions) {\n        var _a, _b, _c;\n        // TODO: remove deprecated method\n        const options = Object.assign({}, additionalOptions);\n        if (typeof requestOrOptions === 'object' &&\n            requestOrOptions !== null &&\n            'tonProof' in requestOrOptions) {\n            options.request = requestOrOptions;\n        }\n        if (typeof requestOrOptions === 'object' &&\n            requestOrOptions !== null &&\n            ('openingDeadlineMS' in requestOrOptions ||\n                'signal' in requestOrOptions ||\n                'request' in requestOrOptions ||\n                'traceId' in requestOrOptions)) {\n            options.request = requestOrOptions === null || requestOrOptions === void 0 ? void 0 : requestOrOptions.request;\n            options.openingDeadlineMS = requestOrOptions === null || requestOrOptions === void 0 ? void 0 : requestOrOptions.openingDeadlineMS;\n            options.signal = requestOrOptions === null || requestOrOptions === void 0 ? void 0 : requestOrOptions.signal;\n        }\n        if (options.request) {\n            const validationError = validateConnectAdditionalRequest(options.request);\n            if (validationError) {\n                if (isQaModeEnabled()) {\n                    console.error('ConnectAdditionalRequest validation failed: ' + validationError);\n                }\n                else {\n                    throw new TonConnectError('ConnectAdditionalRequest validation failed: ' + validationError);\n                }\n            }\n        }\n        if (this.connected) {\n            throw new WalletAlreadyConnectedError();\n        }\n        const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n        (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort();\n        this.abortController = abortController;\n        if (abortController.signal.aborted) {\n            throw new TonConnectError('Connection was aborted');\n        }\n        (_b = this.provider) === null || _b === void 0 ? void 0 : _b.closeConnection();\n        this.provider = this.createProvider(wallet);\n        abortController.signal.addEventListener('abort', () => {\n            var _a;\n            (_a = this.provider) === null || _a === void 0 ? void 0 : _a.closeConnection();\n            this.provider = null;\n        });\n        const traceId = (_c = options === null || options === void 0 ? void 0 : options.traceId) !== null && _c !== void 0 ? _c : UUIDv7();\n        this.tracker.trackConnectionStarted(traceId);\n        return this.provider.connect(this.createConnectRequest(options === null || options === void 0 ? void 0 : options.request), {\n            openingDeadlineMS: options === null || options === void 0 ? void 0 : options.openingDeadlineMS,\n            signal: abortController.signal,\n            traceId\n        });\n    }\n    /**\n     * Try to restore existing session and reconnect to the corresponding wallet. Call it immediately when your app is loaded.\n     */\n    restoreConnection(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            this.tracker.trackConnectionRestoringStarted(traceId);\n            const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n            (_b = this.abortController) === null || _b === void 0 ? void 0 : _b.abort();\n            this.abortController = abortController;\n            if (abortController.signal.aborted) {\n                this.tracker.trackConnectionRestoringError('Connection restoring was aborted', traceId);\n                return;\n            }\n            // TODO: potentially race condition here\n            const [bridgeConnectionType, embeddedWallet] = yield Promise.all([\n                this.bridgeConnectionStorage.storedConnectionType(),\n                this.walletsList.getEmbeddedWallet()\n            ]);\n            if (abortController.signal.aborted) {\n                this.tracker.trackConnectionRestoringError('Connection restoring was aborted', traceId);\n                return;\n            }\n            let provider = null;\n            try {\n                switch (bridgeConnectionType) {\n                    case 'http':\n                        provider = yield BridgeProvider.fromStorage(this.bridgeConnectionStorage, this.analytics);\n                        break;\n                    case 'injected':\n                        provider = yield InjectedProvider.fromStorage(this.bridgeConnectionStorage, this.analytics);\n                        break;\n                    case 'wallet-connect':\n                        provider = yield WalletConnectProvider.fromStorage(this.bridgeConnectionStorage);\n                        break;\n                    default:\n                        if (embeddedWallet) {\n                            provider = this.createProvider(embeddedWallet);\n                        }\n                        else {\n                            return;\n                        }\n                }\n            }\n            catch (err) {\n                logDebug('Provider is not restored', err);\n                this.tracker.trackConnectionRestoringError('Provider is not restored', traceId);\n                yield this.bridgeConnectionStorage.removeConnection();\n                provider === null || provider === void 0 ? void 0 : provider.closeConnection();\n                provider = null;\n                return;\n            }\n            if (abortController.signal.aborted) {\n                provider === null || provider === void 0 ? void 0 : provider.closeConnection();\n                this.tracker.trackConnectionRestoringError('Connection restoring was aborted', traceId);\n                return;\n            }\n            if (!provider) {\n                logError('Provider is not restored');\n                this.tracker.trackConnectionRestoringError('Provider is not restored', traceId);\n                return;\n            }\n            (_c = this.provider) === null || _c === void 0 ? void 0 : _c.closeConnection();\n            this.provider = provider;\n            provider.listen(this.walletEventsListener.bind(this));\n            const onAbortRestore = () => {\n                this.tracker.trackConnectionRestoringError('Connection restoring was aborted', traceId);\n                provider === null || provider === void 0 ? void 0 : provider.closeConnection();\n                provider = null;\n            };\n            abortController.signal.addEventListener('abort', onAbortRestore);\n            const restoreConnectionTask = callForSuccess((_options) => __awaiter(this, void 0, void 0, function* () {\n                yield (provider === null || provider === void 0 ? void 0 : provider.restoreConnection({\n                    openingDeadlineMS: options === null || options === void 0 ? void 0 : options.openingDeadlineMS,\n                    signal: _options.signal,\n                    traceId\n                }));\n                abortController.signal.removeEventListener('abort', onAbortRestore);\n                if (this.connected) {\n                    const sessionInfo = this.getSessionInfo();\n                    this.tracker.trackConnectionRestoringCompleted(this.wallet, sessionInfo, traceId);\n                }\n                else {\n                    this.tracker.trackConnectionRestoringError('Connection restoring failed', traceId);\n                }\n            }), {\n                attempts: Number.MAX_SAFE_INTEGER,\n                delayMs: 2000,\n                signal: options === null || options === void 0 ? void 0 : options.signal\n            });\n            const restoreConnectionTimeout = new Promise(resolve => setTimeout(() => resolve(), 12000) // connection deadline\n            );\n            return Promise.race([restoreConnectionTask, restoreConnectionTimeout]);\n        });\n    }\n    sendTransaction(transaction, optionsOrOnRequestSent) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d;\n            // TODO: remove deprecated method\n            const options = {};\n            if (typeof optionsOrOnRequestSent === 'function') {\n                options.onRequestSent = optionsOrOnRequestSent;\n            }\n            else {\n                options.onRequestSent = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.onRequestSent;\n                options.signal = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.signal;\n                options.traceId = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.traceId;\n            }\n            // Validate transaction\n            const validationError = validateSendTransactionRequest(transaction);\n            if (validationError) {\n                if (isQaModeEnabled()) {\n                    console.error('SendTransactionRequest validation failed: ' + validationError);\n                }\n                else {\n                    throw new TonConnectError('SendTransactionRequest validation failed: ' + validationError);\n                }\n            }\n            const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n            if (abortController.signal.aborted) {\n                throw new TonConnectError('Transaction sending was aborted');\n            }\n            this.checkConnection();\n            const requiredMessagesNumber = transaction.messages.length;\n            const requireExtraCurrencies = transaction.messages.some(m => m.extraCurrency && Object.keys(m.extraCurrency).length > 0);\n            checkSendTransactionSupport(this.wallet.device.features, {\n                requiredMessagesNumber,\n                requireExtraCurrencies\n            });\n            const sessionInfo = this.getSessionInfo();\n            const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            this.tracker.trackTransactionSentForSignature(this.wallet, transaction, sessionInfo, traceId);\n            const { validUntil, messages } = transaction, tx = __rest(transaction, [\"validUntil\", \"messages\"]);\n            const from = transaction.from || this.account.address;\n            const network = transaction.network || this.account.chain;\n            if (((_b = this.wallet) === null || _b === void 0 ? void 0 : _b.account.chain) && network !== this.wallet.account.chain) {\n                if (!isQaModeEnabled()) {\n                    throw new WalletWrongNetworkError('Wallet connected to a wrong network', {\n                        cause: {\n                            expectedChainId: (_c = this.wallet) === null || _c === void 0 ? void 0 : _c.account.chain,\n                            actualChainId: network\n                        }\n                    });\n                }\n                console.error('Wallet connected to a wrong network', {\n                    expectedChainId: (_d = this.wallet) === null || _d === void 0 ? void 0 : _d.account.chain,\n                    actualChainId: network\n                });\n            }\n            const response = yield this.provider.sendRequest(sendTransactionParser.convertToRpcRequest(Object.assign(Object.assign({}, tx), { from,\n                network, valid_until: validUntil, messages: messages.map((_a) => {\n                    var { extraCurrency, payload, stateInit } = _a, msg = __rest(_a, [\"extraCurrency\", \"payload\", \"stateInit\"]);\n                    return (Object.assign(Object.assign({}, msg), { payload: normalizeBase64(payload), stateInit: normalizeBase64(stateInit), extra_currency: extraCurrency }));\n                }) })), {\n                onRequestSent: options.onRequestSent,\n                signal: abortController.signal,\n                traceId\n            });\n            if (sendTransactionParser.isError(response)) {\n                this.tracker.trackTransactionSigningFailed(this.wallet, transaction, response.error.message, response.error.code, sessionInfo, traceId);\n                return sendTransactionParser.parseAndThrowError(response);\n            }\n            const result = sendTransactionParser.convertFromRpcResponse(response);\n            this.tracker.trackTransactionSigned(this.wallet, transaction, result, sessionInfo, traceId);\n            return Object.assign(Object.assign({}, result), { traceId: response.traceId });\n        });\n    }\n    signData(data, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d;\n            const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n            if (abortController.signal.aborted) {\n                throw new TonConnectError('data sending was aborted');\n            }\n            // Validate sign data\n            const validationError = validateSignDataPayload(data);\n            if (validationError) {\n                if (isQaModeEnabled()) {\n                    console.error('SignDataPayload validation failed: ' + validationError);\n                }\n                else {\n                    throw new TonConnectError('SignDataPayload validation failed: ' + validationError);\n                }\n            }\n            this.checkConnection();\n            checkSignDataSupport(this.wallet.device.features, { requiredTypes: [data.type] });\n            const sessionInfo = this.getSessionInfo();\n            const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            this.tracker.trackDataSentForSignature(this.wallet, data, sessionInfo, traceId);\n            const from = data.from || this.account.address;\n            const network = data.network || this.account.chain;\n            if (((_b = this.wallet) === null || _b === void 0 ? void 0 : _b.account.chain) && network !== this.wallet.account.chain) {\n                if (!isQaModeEnabled()) {\n                    throw new WalletWrongNetworkError('Wallet connected to a wrong network', {\n                        cause: {\n                            expectedChainId: (_c = this.wallet) === null || _c === void 0 ? void 0 : _c.account.chain,\n                            actualChainId: network\n                        }\n                    });\n                }\n                console.error('Wallet connected to a wrong network', {\n                    expectedChainId: (_d = this.wallet) === null || _d === void 0 ? void 0 : _d.account.chain,\n                    actualChainId: network\n                });\n            }\n            const response = yield this.provider.sendRequest(signDataParser.convertToRpcRequest(Object.assign(Object.assign(Object.assign({}, data), (data.type === 'cell' ? { cell: normalizeBase64(data.cell) } : {})), { from,\n                network })), { onRequestSent: options === null || options === void 0 ? void 0 : options.onRequestSent, signal: abortController.signal, traceId });\n            if (signDataParser.isError(response)) {\n                this.tracker.trackDataSigningFailed(this.wallet, data, response.error.message, response.error.code, sessionInfo, traceId);\n                return signDataParser.parseAndThrowError(response);\n            }\n            const result = signDataParser.convertFromRpcResponse(response);\n            this.tracker.trackDataSigned(this.wallet, data, result, sessionInfo, traceId);\n            return Object.assign(Object.assign({}, result), { traceId });\n        });\n    }\n    /**\n     * Set desired network for the connection. Can only be set before connecting.\n     * If wallet connects with a different chain, the SDK will throw an error and abort connection.\n     * @param network desired network id (e.g., '-239', '-3', or custom). Pass undefined to allow any network.\n     */\n    setConnectionNetwork(network) {\n        if (this.connected) {\n            throw new TonConnectError('Cannot change network while wallet is connected');\n        }\n        this.desiredChainId = network;\n    }\n    /**\n     * Disconnect form thw connected wallet and drop current session.\n     */\n    disconnect(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            if (!this.connected) {\n                throw new WalletNotConnectedError();\n            }\n            const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n            const prevAbortController = this.abortController;\n            this.abortController = abortController;\n            if (abortController.signal.aborted) {\n                throw new TonConnectError('Disconnect was aborted');\n            }\n            const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            this.onWalletDisconnected('dapp', { traceId });\n            yield ((_b = this.provider) === null || _b === void 0 ? void 0 : _b.disconnect({\n                signal: abortController.signal,\n                traceId\n            }));\n            prevAbortController === null || prevAbortController === void 0 ? void 0 : prevAbortController.abort();\n        });\n    }\n    /**\n     * Gets the current session ID if available.\n     * @returns session ID string or null if not available.\n     */\n    getSessionId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.provider) {\n                return null;\n            }\n            try {\n                const connection = yield this.bridgeConnectionStorage.getConnection();\n                if (!connection || connection.type !== 'http') {\n                    return null;\n                }\n                if ('sessionCrypto' in connection) {\n                    // Pending connection\n                    return connection.sessionCrypto.sessionId;\n                }\n                else {\n                    // Established connection\n                    return connection.session.sessionCrypto.sessionId;\n                }\n            }\n            catch (_a) {\n                return null;\n            }\n        });\n    }\n    getSessionInfo() {\n        var _a;\n        if (((_a = this.provider) === null || _a === void 0 ? void 0 : _a.type) !== 'http') {\n            return null;\n        }\n        if (!('session' in this.provider)) {\n            return null;\n        }\n        try {\n            const session = this.provider.session;\n            if (!session) {\n                return null;\n            }\n            const clientId = session.sessionCrypto.sessionId;\n            let walletId = null;\n            if ('walletPublicKey' in session) {\n                walletId = session.walletPublicKey;\n            }\n            return { clientId, walletId };\n        }\n        catch (_b) {\n            return null;\n        }\n    }\n    /**\n     * Pause bridge HTTP connection. Might be helpful, if you want to pause connections while browser tab is unfocused,\n     * or if you use SDK with NodeJS and want to save server resources.\n     */\n    pauseConnection() {\n        var _a;\n        if (((_a = this.provider) === null || _a === void 0 ? void 0 : _a.type) !== 'http') {\n            return;\n        }\n        this.provider.pause();\n    }\n    /**\n     * Unpause bridge HTTP connection if it is paused.\n     */\n    unPauseConnection() {\n        var _a;\n        if (((_a = this.provider) === null || _a === void 0 ? void 0 : _a.type) !== 'http') {\n            return Promise.resolve();\n        }\n        return this.provider.unPause();\n    }\n    addWindowFocusAndBlurSubscriptions() {\n        const document = getDocument();\n        if (!document) {\n            return;\n        }\n        try {\n            document.addEventListener('visibilitychange', () => {\n                if (document.hidden) {\n                    this.pauseConnection();\n                }\n                else {\n                    this.unPauseConnection().catch(() => { });\n                }\n            });\n        }\n        catch (e) {\n            logError('Cannot subscribe to the document.visibilitychange: ', e);\n        }\n    }\n    initAnalytics(manifestUrl, eventDispatcher, options) {\n        var _a;\n        const analyticsSettings = options === null || options === void 0 ? void 0 : options.analytics;\n        const mode = (_a = analyticsSettings === null || analyticsSettings === void 0 ? void 0 : analyticsSettings.mode) !== null && _a !== void 0 ? _a : 'telemetry';\n        if (mode === 'off') {\n            return;\n        }\n        const analytics = new AnalyticsManager({\n            environment: this.environment,\n            mode\n        });\n        this.analytics = analytics;\n        const telegramUser = this.environment.getTelegramUser();\n        const sharedAnalyticsData = {\n            browser: this.environment.getBrowser(),\n            platform: this.environment.getPlatform(),\n            manifest_json_url: manifestUrl,\n            origin_url: getOriginWithPath,\n            locale: this.environment.getLocale()\n        };\n        if (telegramUser) {\n            sharedAnalyticsData.tg_id = telegramUser.id;\n            sharedAnalyticsData.tma_is_premium = telegramUser.isPremium;\n        }\n        bindEventsTo(eventDispatcher, analytics.scoped(sharedAnalyticsData));\n    }\n    createProvider(wallet) {\n        let provider;\n        if (!Array.isArray(wallet) && isWalletConnectionSourceJS(wallet)) {\n            provider = new InjectedProvider(this.bridgeConnectionStorage, wallet.jsBridgeKey, this.analytics);\n        }\n        else if (!Array.isArray(wallet) && isWalletConnectionSourceWalletConnect(wallet)) {\n            provider = new WalletConnectProvider(this.bridgeConnectionStorage);\n        }\n        else {\n            provider = new BridgeProvider(this.bridgeConnectionStorage, wallet, this.analytics);\n        }\n        provider.listen(this.walletEventsListener.bind(this));\n        return provider;\n    }\n    walletEventsListener(e) {\n        switch (e.event) {\n            case 'connect':\n                this.onWalletConnected(e.payload, { traceId: e.traceId });\n                break;\n            case 'connect_error':\n                this.tracker.trackConnectionError(e.payload.message, e.payload.code, this.getSessionInfo(), e.traceId);\n                const walletError = connectErrorsParser.parseError(e.payload);\n                this.onWalletConnectError(walletError);\n                break;\n            case 'disconnect':\n                this.onWalletDisconnected('wallet', { traceId: e.traceId });\n        }\n    }\n    onWalletConnected(connectEvent, options) {\n        var _a, _b;\n        const tonAccountItem = connectEvent.items.find(item => item.name === 'ton_addr');\n        const tonProofItem = connectEvent.items.find(item => item.name === 'ton_proof');\n        if (!tonAccountItem) {\n            throw new TonConnectError('ton_addr connection item was not found');\n        }\n        const hasRequiredFeatures = checkRequiredWalletFeatures(connectEvent.device.features, this.walletsRequiredFeatures);\n        if (!hasRequiredFeatures) {\n            (_a = this.provider) === null || _a === void 0 ? void 0 : _a.disconnect();\n            this.onWalletConnectError(new WalletMissingRequiredFeaturesError('Wallet does not support required features', { cause: { connectEvent } }));\n            return;\n        }\n        const wallet = {\n            device: connectEvent.device,\n            provider: this.provider.type,\n            account: {\n                address: tonAccountItem.address,\n                chain: tonAccountItem.network,\n                walletStateInit: tonAccountItem.walletStateInit,\n                publicKey: tonAccountItem.publicKey\n            }\n        };\n        if (this.desiredChainId && wallet.account.chain !== this.desiredChainId) {\n            const expectedChainId = this.desiredChainId;\n            const actualChainId = wallet.account.chain;\n            (_b = this.provider) === null || _b === void 0 ? void 0 : _b.disconnect();\n            this.onWalletConnectError(new WalletWrongNetworkError('Wallet connected to a wrong network', {\n                cause: { expectedChainId, actualChainId }\n            }));\n            return;\n        }\n        if (tonProofItem) {\n            const validationError = validateTonProofItemReply(tonProofItem);\n            let tonProof = undefined;\n            if (validationError) {\n                if (isQaModeEnabled()) {\n                    console.error('TonProofItem validation failed: ' + validationError);\n                }\n                tonProof = {\n                    name: 'ton_proof',\n                    error: {\n                        code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_ITEM_ERROR_CODES.UNKNOWN_ERROR,\n                        message: validationError\n                    }\n                };\n            }\n            else {\n                try {\n                    if ('proof' in tonProofItem) {\n                        tonProof = {\n                            name: 'ton_proof',\n                            proof: {\n                                timestamp: tonProofItem.proof.timestamp,\n                                domain: {\n                                    lengthBytes: tonProofItem.proof.domain.lengthBytes,\n                                    value: tonProofItem.proof.domain.value\n                                },\n                                payload: tonProofItem.proof.payload,\n                                signature: tonProofItem.proof.signature\n                            }\n                        };\n                    }\n                    else if ('error' in tonProofItem) {\n                        tonProof = {\n                            name: 'ton_proof',\n                            error: {\n                                code: tonProofItem.error.code,\n                                message: tonProofItem.error.message\n                            }\n                        };\n                    }\n                    else {\n                        throw new TonConnectError('Invalid data format');\n                    }\n                }\n                catch (e) {\n                    tonProof = {\n                        name: 'ton_proof',\n                        error: {\n                            code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_ITEM_ERROR_CODES.UNKNOWN_ERROR,\n                            message: 'Invalid data format'\n                        }\n                    };\n                }\n            }\n            wallet.connectItems = { tonProof };\n        }\n        this.wallet = wallet;\n        const sessionInfo = this.getSessionInfo();\n        this.tracker.trackConnectionCompleted(wallet, sessionInfo, options === null || options === void 0 ? void 0 : options.traceId);\n    }\n    onWalletConnectError(error) {\n        this.statusChangeErrorSubscriptions.forEach(errorsHandler => errorsHandler(error));\n        logDebug(error);\n        if (error instanceof ManifestNotFoundError || error instanceof ManifestContentErrorError) {\n            logError(error);\n            throw error;\n        }\n    }\n    onWalletDisconnected(scope, options) {\n        const sessionInfo = this.getSessionInfo();\n        this.tracker.trackDisconnection(this.wallet, scope, sessionInfo, options === null || options === void 0 ? void 0 : options.traceId);\n        this.wallet = null;\n    }\n    checkConnection() {\n        if (!this.connected) {\n            throw new WalletNotConnectedError();\n        }\n    }\n    createConnectRequest(request) {\n        const items = [\n            Object.assign({ name: 'ton_addr' }, (this.desiredChainId ? { network: this.desiredChainId } : {}))\n        ];\n        if (request === null || request === void 0 ? void 0 : request.tonProof) {\n            items.push({\n                name: 'ton_proof',\n                payload: request.tonProof\n            });\n        }\n        return {\n            manifestUrl: this.dappSettings.manifestUrl,\n            items\n        };\n    }\n}\nTonConnect.walletsList = new WalletsListManager();\n/**\n * Check if specified wallet is injected and available to use with the app.\n * @param walletJSKey target wallet's js bridge key.\n */\nTonConnect.isWalletInjected = (walletJSKey) => InjectedProvider.isWalletInjected(walletJSKey);\n/**\n * Check if the app is opened inside specified wallet's browser.\n * @param walletJSKey target wallet's js bridge key.\n */\nTonConnect.isInsideWalletBrowser = (walletJSKey) => InjectedProvider.isInsideWalletBrowser(walletJSKey);\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvbmNvbm5lY3Qvc2RrL2xpYi9lc20vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStNO0FBQ3pDO0FBQzFIO0FBQ047O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdCQUF3QixFQUFFLHNCQUFzQixFQUFFLGtDQUFrQyxFQUFFLDhCQUE4QjtBQUM5STtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSywyRUFBeUI7QUFDOUIsS0FBSywyRUFBeUI7QUFDOUIsS0FBSywyRUFBeUI7QUFDOUIsS0FBSywyRUFBeUI7QUFDOUIsS0FBSywyRUFBeUI7QUFDOUIsS0FBSywyRUFBeUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUN4RSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPLEdBQUcsYUFBYTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3RELDhGQUE4RixtQkFBbUIsU0FBUztBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSSx3QkFBd0I7QUFDakQ7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLGNBQWMsSUFBSTtBQUN0RztBQUNBO0FBQ0EsYUFBYTtBQUNiLGtGQUFrRixjQUFjLElBQUk7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixnQkFBZ0I7QUFDaEc7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBLDBGQUEwRixtQkFBbUIsU0FBUztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRix3QkFBd0IsU0FBUztBQUMzSDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsUUFBUSxTQUFTO0FBQy9HO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywrREFBYTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywrREFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLGlCQUFpQjtBQUMxRztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsaUJBQWlCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyxpQkFBaUI7QUFDckg7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLGlCQUFpQjtBQUMzSDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGlCQUFpQix1Q0FBdUMseUJBQXlCLDZCQUE2QixHQUFHO0FBQzVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0RBQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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bkQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix3QkFBd0IscURBQXFEO0FBQzdFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDRCQUE0QixxREFBcUQ7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxxSUFBcUksU0FBUztBQUM5STtBQUNBLDBCQUEwQixvQ0FBb0M7QUFDOUQsMERBQTBELFVBQVUseUdBQXlHO0FBQzdLLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYSwyQkFBMkI7QUFDekYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDRCQUE0QjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw0SUFBNEksbUNBQW1DLG1DQUFtQyxJQUFJLE1BQU07QUFDNU4seUJBQXlCLE1BQU0saUlBQWlJO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhLFNBQVM7QUFDdkUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxvQkFBb0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsb0JBQW9CO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SCxTQUFTLGdCQUFnQjtBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMEVBQXdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMEVBQXdCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCLDJCQUEyQiwrQkFBK0IsSUFBSTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeXpDO0FBQ3p6QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RtYS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdG9uY29ubmVjdC9zZGsvbGliL2VzbS9pbmRleC5tanM/MjVhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTLCBTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTLCBTSUdOX0RBVEFfRVJST1JfQ09ERVMsIEJhc2U2NCwgU2Vzc2lvbkNyeXB0bywgaGV4VG9CeXRlQXJyYXksIERJU0NPTk5FQ1RfRVJST1JfQ09ERVMsIENPTk5FQ1RfSVRFTV9FUlJPUl9DT0RFUyB9IGZyb20gJ0B0b25jb25uZWN0L3Byb3RvY29sJztcbmV4cG9ydCB7IENIQUlOLCBDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTLCBDT05ORUNUX0lURU1fRVJST1JfQ09ERVMsIFNFTkRfVFJBTlNBQ1RJT05fRVJST1JfQ09ERVMsIFNJR05fREFUQV9FUlJPUl9DT0RFUywgU2Vzc2lvbkNyeXB0byB9IGZyb20gJ0B0b25jb25uZWN0L3Byb3RvY29sJztcbmltcG9ydCAnQHRvbmNvbm5lY3QvaXNvbW9ycGhpYy1ldmVudHNvdXJjZSc7XG5pbXBvcnQgJ0B0b25jb25uZWN0L2lzb21vcnBoaWMtZmV0Y2gnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sLCBJdGVyYXRvciAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgVG9uQ29ubmVjdCBlcnJvcnMuIFlvdSBjYW4gY2hlY2sgaWYgdGhlIGVycm9yIHdhcyB0cmlnZ2VyZWQgYnkgdGhlIEB0b25jb25uZWN0L3NkayB1c2luZyBgZXJyIGluc3RhbmNlb2YgVG9uQ29ubmVjdEVycm9yYC5cbiAqL1xuY2xhc3MgVG9uQ29ubmVjdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGAke1RvbkNvbm5lY3RFcnJvci5wcmVmaXh9ICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSR7dGhpcy5pbmZvID8gJzogJyArIHRoaXMuaW5mbyA6ICcnfSR7bWVzc2FnZSA/ICdcXG4nICsgbWVzc2FnZSA6ICcnfWA7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBUb25Db25uZWN0RXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5Ub25Db25uZWN0RXJyb3IucHJlZml4ID0gJ1tUT05fQ09OTkVDVF9TREtfRVJST1JdJztcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBwYXNzZWQgRGFwcE1ldGFkYXRhIGlzIGluIGluY29ycmVjdCBmb3JtYXQuXG4gKi9cbmNsYXNzIERhcHBNZXRhZGF0YUVycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuICdQYXNzZWQgRGFwcE1ldGFkYXRhIGlzIGluIGluY29ycmVjdCBmb3JtYXQuJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIERhcHBNZXRhZGF0YUVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIHBhc3NlZCBtYW5pZmVzdCBjb250YWlucyBlcnJvcnMuXG4gKi9cbmNsYXNzIE1hbmlmZXN0Q29udGVudEVycm9yRXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJ1Bhc3NlZCBgdG9uY29ubmVjdC1tYW5pZmVzdC5qc29uYCBjb250YWlucyBlcnJvcnMuIENoZWNrIGZvcm1hdCBvZiB5b3VyIG1hbmlmZXN0LiBTZWUgbW9yZSBodHRwczovL2dpdGh1Yi5jb20vdG9uLWNvbm5lY3QvZG9jcy9ibG9iL21haW4vcmVxdWVzdHMtcmVzcG9uc2VzLm1kI2FwcC1tYW5pZmVzdCc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBNYW5pZmVzdENvbnRlbnRFcnJvckVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIHdhbGxldCBjYW4ndCBnZXQgbWFuaWZlc3QgYnkgcGFzc2VkIG1hbmlmZXN0VXJsLlxuICovXG5jbGFzcyBNYW5pZmVzdE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJ01hbmlmZXN0IG5vdCBmb3VuZC4gTWFrZSBzdXJlIHlvdSBhZGRlZCBgdG9uY29ubmVjdC1tYW5pZmVzdC5qc29uYCB0byB0aGUgcm9vdCBvZiB5b3VyIGFwcCBvciBwYXNzZWQgY29ycmVjdCBtYW5pZmVzdFVybC4gU2VlIG1vcmUgaHR0cHM6Ly9naXRodWIuY29tL3Rvbi1jb25uZWN0L2RvY3MvYmxvYi9tYWluL3JlcXVlc3RzLXJlc3BvbnNlcy5tZCNhcHAtbWFuaWZlc3QnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgTWFuaWZlc3ROb3RGb3VuZEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIHdhbGxldCBjb25uZWN0aW9uIGNhbGxlZCBidXQgd2FsbGV0IGFscmVhZHkgY29ubmVjdGVkLiBUbyBhdm9pZCB0aGUgZXJyb3IsIGRpc2Nvbm5lY3QgdGhlIHdhbGxldCBiZWZvcmUgZG9pbmcgYSBuZXcgY29ubmVjdGlvbi5cbiAqL1xuY2xhc3MgV2FsbGV0QWxyZWFkeUNvbm5lY3RlZEVycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuICdXYWxsZXQgY29ubmVjdGlvbiBjYWxsZWQgYnV0IHdhbGxldCBhbHJlYWR5IGNvbm5lY3RlZC4gVG8gYXZvaWQgdGhlIGVycm9yLCBkaXNjb25uZWN0IHRoZSB3YWxsZXQgYmVmb3JlIGRvaW5nIGEgbmV3IGNvbm5lY3Rpb24uJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFdhbGxldEFscmVhZHlDb25uZWN0ZWRFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiBzZW5kIHRyYW5zYWN0aW9uIG9yIG90aGVyIHByb3RvY29sIG1ldGhvZHMgY2FsbGVkIHdoaWxlIHdhbGxldCBpcyBub3QgY29ubmVjdGVkLlxuICovXG5jbGFzcyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvciBleHRlbmRzIFRvbkNvbm5lY3RFcnJvciB7XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiAnU2VuZCB0cmFuc2FjdGlvbiBvciBvdGhlciBwcm90b2NvbCBtZXRob2RzIGNhbGxlZCB3aGlsZSB3YWxsZXQgaXMgbm90IGNvbm5lY3RlZC4nO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlcmUgaXMgYW4gYXR0ZW1wdCB0byBjb25uZWN0IHRvIHRoZSBpbmplY3RlZCB3YWxsZXQgd2hpbGUgaXQgaXMgbm90IGV4aXN0cyBpbiB0aGUgd2VicGFnZS5cbiAqL1xuY2xhc3MgV2FsbGV0Tm90SW5qZWN0ZWRFcnJvciBleHRlbmRzIFRvbkNvbm5lY3RFcnJvciB7XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiAnVGhlcmUgaXMgYW4gYXR0ZW1wdCB0byBjb25uZWN0IHRvIHRoZSBpbmplY3RlZCB3YWxsZXQgd2hpbGUgaXQgaXMgbm90IGV4aXN0cyBpbiB0aGUgd2VicGFnZS4nO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgV2FsbGV0Tm90SW5qZWN0ZWRFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiB3YWxsZXQgZG9lc24ndCBzdXBwb3J0IHJlcXVlc3RlZCBmZWF0dXJlIG1ldGhvZC5cbiAqL1xuY2xhc3MgV2FsbGV0Tm90U3VwcG9ydEZlYXR1cmVFcnJvciBleHRlbmRzIFRvbkNvbm5lY3RFcnJvciB7XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiBcIldhbGxldCBkb2Vzbid0IHN1cHBvcnQgcmVxdWVzdGVkIGZlYXR1cmUgbWV0aG9kLlwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgV2FsbGV0Tm90U3VwcG9ydEZlYXR1cmVFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiB3YWxsZXQgY2FuJ3QgZ2V0IG1hbmlmZXN0IGJ5IHBhc3NlZCBtYW5pZmVzdFVybC5cbiAqL1xuY2xhc3MgV2FsbGV0TWlzc2luZ1JlcXVpcmVkRmVhdHVyZXNFcnJvciBleHRlbmRzIFRvbkNvbm5lY3RFcnJvciB7XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiAnTWlzc2luZyByZXF1aXJlZCBmZWF0dXJlcy4gWW91IG5lZWQgdG8gdXBkYXRlIHlvdXIgd2FsbGV0Lic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBXYWxsZXRNaXNzaW5nUmVxdWlyZWRGZWF0dXJlc0Vycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG5jbGFzcyBXYWxsZXRXcm9uZ05ldHdvcmtFcnJvciBleHRlbmRzIFRvbkNvbm5lY3RFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldFdyb25nTmV0d29ya0Vycm9yJztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFdhbGxldFdyb25nTmV0d29ya0Vycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc1dhbGxldENvbm5lY3Rpb25Tb3VyY2VKUyh2YWx1ZSkge1xuICAgIHJldHVybiAnanNCcmlkZ2VLZXknIGluIHZhbHVlO1xufVxuZnVuY3Rpb24gaXNXYWxsZXRDb25uZWN0aW9uU291cmNlV2FsbGV0Q29ubmVjdCh2YWx1ZSkge1xuICAgIHJldHVybiAndHlwZScgaW4gdmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gJ3dhbGxldC1jb25uZWN0Jztcbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiB1c2VyIHJlamVjdHMgdGhlIGFjdGlvbiBpbiB0aGUgd2FsbGV0LlxuICovXG5jbGFzcyBVc2VyUmVqZWN0c0Vycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuICdVc2VyIHJlamVjdHMgdGhlIGFjdGlvbiBpbiB0aGUgd2FsbGV0Lic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBVc2VyUmVqZWN0c0Vycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIHJlcXVlc3QgdG8gdGhlIHdhbGxldCBjb250YWlucyBlcnJvcnMuXG4gKi9cbmNsYXNzIEJhZFJlcXVlc3RFcnJvciBleHRlbmRzIFRvbkNvbm5lY3RFcnJvciB7XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiAnUmVxdWVzdCB0byB0aGUgd2FsbGV0IGNvbnRhaW5zIGVycm9ycy4nO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQmFkUmVxdWVzdEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIGFwcCB0cmllcyB0byBzZW5kIHJwYyByZXF1ZXN0IHRvIHRoZSBpbmplY3RlZCB3YWxsZXQgd2hpbGUgbm90IGNvbm5lY3RlZC5cbiAqL1xuY2xhc3MgVW5rbm93bkFwcEVycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuICdBcHAgdHJpZXMgdG8gc2VuZCBycGMgcmVxdWVzdCB0byB0aGUgaW5qZWN0ZWQgd2FsbGV0IHdoaWxlIG5vdCBjb25uZWN0ZWQuJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFVua25vd25BcHBFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiBgU3RvcmFnZWAgd2FzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGBEYXBwTWV0YWRhdGFgIGFuZCBkZWZhdWx0IGBsb2NhbFN0b3JhZ2VgIHdhcyBub3QgZGV0ZWN0ZWQgaW4gdGhlIE5vZGUuanMgZW52aXJvbm1lbnQuXG4gKi9cbmNsYXNzIExvY2Fsc3RvcmFnZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJ1N0b3JhZ2Ugd2FzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGBEYXBwTWV0YWRhdGFgIGFuZCBkZWZhdWx0IGBsb2NhbFN0b3JhZ2VgIHdhcyBub3QgZGV0ZWN0ZWQgaW4gdGhlIGVudmlyb25tZW50Lic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBMb2NhbHN0b3JhZ2VOb3RGb3VuZEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIGFuIGVycm9yIG9jY3VycmVkIHdoaWxlIGZldGNoaW5nIHRoZSB3YWxsZXRzIGxpc3QuXG4gKi9cbmNsYXNzIEZldGNoV2FsbGV0c0Vycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuICdBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBmZXRjaGluZyB0aGUgd2FsbGV0cyBsaXN0Lic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBGZXRjaFdhbGxldHNFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiBwYXNzZWQgYWRkcmVzcyBpcyBpbiBpbmNvcnJlY3QgZm9ybWF0LlxuICovXG5jbGFzcyBXcm9uZ0FkZHJlc3NFcnJvciBleHRlbmRzIFRvbkNvbm5lY3RFcnJvciB7XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiAnUGFzc2VkIGFkZHJlc3MgaXMgaW4gaW5jb3JyZWN0IGZvcm1hdC4nO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgV3JvbmdBZGRyZXNzRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gcGFzc2VkIGhleCBpcyBpbiBpbmNvcnJlY3QgZm9ybWF0LlxuICovXG5jbGFzcyBQYXJzZUhleEVycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuICdQYXNzZWQgaGV4IGlzIGluIGluY29ycmVjdCBmb3JtYXQuJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFBhcnNlSGV4RXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogVW5oYW5kZWQgdW5rbm93biBlcnJvci5cbiAqL1xuY2xhc3MgVW5rbm93bkVycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgVW5rbm93bkVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG5jb25zdCBjb25uZWN0RXZlbnRFcnJvcnNDb2RlcyA9IHtcbiAgICBbQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFUy5VTktOT1dOX0VSUk9SXTogVW5rbm93bkVycm9yLFxuICAgIFtDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTLlVTRVJfUkVKRUNUU19FUlJPUl06IFVzZXJSZWplY3RzRXJyb3IsXG4gICAgW0NPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVMuQkFEX1JFUVVFU1RfRVJST1JdOiBCYWRSZXF1ZXN0RXJyb3IsXG4gICAgW0NPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVMuVU5LTk9XTl9BUFBfRVJST1JdOiBVbmtub3duQXBwRXJyb3IsXG4gICAgW0NPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVMuTUFOSUZFU1RfTk9UX0ZPVU5EX0VSUk9SXTogTWFuaWZlc3ROb3RGb3VuZEVycm9yLFxuICAgIFtDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTLk1BTklGRVNUX0NPTlRFTlRfRVJST1JdOiBNYW5pZmVzdENvbnRlbnRFcnJvckVycm9yXG59O1xuY2xhc3MgQ29ubmVjdEVycm9yc1BhcnNlciB7XG4gICAgcGFyc2VFcnJvcihlcnJvcikge1xuICAgICAgICBsZXQgRXJyb3JDb25zdHJ1Y3RvciA9IFVua25vd25FcnJvcjtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgaW4gY29ubmVjdEV2ZW50RXJyb3JzQ29kZXMpIHtcbiAgICAgICAgICAgIEVycm9yQ29uc3RydWN0b3IgPSBjb25uZWN0RXZlbnRFcnJvcnNDb2Rlc1tlcnJvci5jb2RlXSB8fCBVbmtub3duRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvckNvbnN0cnVjdG9yKGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbn1cbmNvbnN0IGNvbm5lY3RFcnJvcnNQYXJzZXIgPSBuZXcgQ29ubmVjdEVycm9yc1BhcnNlcigpO1xuXG5jbGFzcyBScGNQYXJzZXIge1xuICAgIGlzRXJyb3IocmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuICdlcnJvcicgaW4gcmVzcG9uc2U7XG4gICAgfVxufVxuXG5jb25zdCBzZW5kVHJhbnNhY3Rpb25FcnJvcnMgPSB7XG4gICAgW1NFTkRfVFJBTlNBQ1RJT05fRVJST1JfQ09ERVMuVU5LTk9XTl9FUlJPUl06IFVua25vd25FcnJvcixcbiAgICBbU0VORF9UUkFOU0FDVElPTl9FUlJPUl9DT0RFUy5VU0VSX1JFSkVDVFNfRVJST1JdOiBVc2VyUmVqZWN0c0Vycm9yLFxuICAgIFtTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTLkJBRF9SRVFVRVNUX0VSUk9SXTogQmFkUmVxdWVzdEVycm9yLFxuICAgIFtTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTLlVOS05PV05fQVBQX0VSUk9SXTogVW5rbm93bkFwcEVycm9yXG59O1xuY2xhc3MgU2VuZFRyYW5zYWN0aW9uUGFyc2VyIGV4dGVuZHMgUnBjUGFyc2VyIHtcbiAgICBjb252ZXJ0VG9ScGNSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ3NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICBwYXJhbXM6IFtKU09OLnN0cmluZ2lmeShyZXF1ZXN0KV1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcGFyc2VBbmRUaHJvd0Vycm9yKHJlc3BvbnNlKSB7XG4gICAgICAgIGxldCBFcnJvckNvbnN0cnVjdG9yID0gVW5rbm93bkVycm9yO1xuICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IuY29kZSBpbiBzZW5kVHJhbnNhY3Rpb25FcnJvcnMpIHtcbiAgICAgICAgICAgIEVycm9yQ29uc3RydWN0b3IgPSBzZW5kVHJhbnNhY3Rpb25FcnJvcnNbcmVzcG9uc2UuZXJyb3IuY29kZV0gfHwgVW5rbm93bkVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvckNvbnN0cnVjdG9yKHJlc3BvbnNlLmVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBjb252ZXJ0RnJvbVJwY1Jlc3BvbnNlKHJwY1Jlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBib2M6IHJwY1Jlc3BvbnNlLnJlc3VsdFxuICAgICAgICB9O1xuICAgIH1cbn1cbmNvbnN0IHNlbmRUcmFuc2FjdGlvblBhcnNlciA9IG5ldyBTZW5kVHJhbnNhY3Rpb25QYXJzZXIoKTtcblxuY29uc3Qgc2lnbkRhdGFFcnJvcnMgPSB7XG4gICAgW1NJR05fREFUQV9FUlJPUl9DT0RFUy5VTktOT1dOX0VSUk9SXTogVW5rbm93bkVycm9yLFxuICAgIFtTSUdOX0RBVEFfRVJST1JfQ09ERVMuVVNFUl9SRUpFQ1RTX0VSUk9SXTogVXNlclJlamVjdHNFcnJvcixcbiAgICBbU0lHTl9EQVRBX0VSUk9SX0NPREVTLkJBRF9SRVFVRVNUX0VSUk9SXTogQmFkUmVxdWVzdEVycm9yLFxuICAgIFtTSUdOX0RBVEFfRVJST1JfQ09ERVMuVU5LTk9XTl9BUFBfRVJST1JdOiBVbmtub3duQXBwRXJyb3Jcbn07XG5jbGFzcyBTaWduRGF0YVBhcnNlciBleHRlbmRzIFJwY1BhcnNlciB7XG4gICAgY29udmVydFRvUnBjUmVxdWVzdChwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXRob2Q6ICdzaWduRGF0YScsXG4gICAgICAgICAgICBwYXJhbXM6IFtKU09OLnN0cmluZ2lmeShwYXlsb2FkKV1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcGFyc2VBbmRUaHJvd0Vycm9yKHJlc3BvbnNlKSB7XG4gICAgICAgIGxldCBFcnJvckNvbnN0cnVjdG9yID0gVW5rbm93bkVycm9yO1xuICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IuY29kZSBpbiBzaWduRGF0YUVycm9ycykge1xuICAgICAgICAgICAgRXJyb3JDb25zdHJ1Y3RvciA9IHNpZ25EYXRhRXJyb3JzW3Jlc3BvbnNlLmVycm9yLmNvZGVdIHx8IFVua25vd25FcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3JDb25zdHJ1Y3RvcihyZXNwb25zZS5lcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gICAgY29udmVydEZyb21ScGNSZXNwb25zZShycGNSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gcnBjUmVzcG9uc2UucmVzdWx0O1xuICAgIH1cbn1cbmNvbnN0IHNpZ25EYXRhUGFyc2VyID0gbmV3IFNpZ25EYXRhUGFyc2VyKCk7XG5cbmNsYXNzIEh0dHBCcmlkZ2VHYXRld2F5U3RvcmFnZSB7XG4gICAgY29uc3RydWN0b3Ioc3RvcmFnZSwgYnJpZGdlVXJsKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgICAgIHRoaXMuc3RvcmVLZXkgPSAndG9uLWNvbm5lY3Qtc3RvcmFnZV9odHRwLWJyaWRnZS1nYXRld2F5OjonICsgYnJpZGdlVXJsO1xuICAgIH1cbiAgICBzdG9yZUxhc3RFdmVudElkKGxhc3RFdmVudElkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yZUtleSwgbGFzdEV2ZW50SWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlTGFzdEV2ZW50SWQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5zdG9yZUtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRMYXN0RXZlbnRJZCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZCA9IHlpZWxkIHRoaXMuc3RvcmFnZS5nZXRJdGVtKHRoaXMuc3RvcmVLZXkpO1xuICAgICAgICAgICAgaWYgKCFzdG9yZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdG9yZWQ7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVXJsTGFzdFNsYXNoKHVybCkge1xuICAgIGlmICh1cmwuc2xpY2UoLTEpID09PSAnLycpIHtcbiAgICAgICAgcmV0dXJuIHVybC5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG59XG5mdW5jdGlvbiBhZGRQYXRoVG9VcmwodXJsLCBwYXRoKSB7XG4gICAgcmV0dXJuIHJlbW92ZVVybExhc3RTbGFzaCh1cmwpICsgJy8nICsgcGF0aDtcbn1cbmZ1bmN0aW9uIGlzVGVsZWdyYW1VcmwobGluaykge1xuICAgIGlmICghbGluaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwobGluayk7XG4gICAgcmV0dXJuIHVybC5wcm90b2NvbCA9PT0gJ3RnOicgfHwgdXJsLmhvc3RuYW1lID09PSAndC5tZSc7XG59XG5mdW5jdGlvbiBpc0Nvbm5lY3RVcmwobGluaykge1xuICAgIGlmICghbGluaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBsaW5rLmluY2x1ZGVzKCd0b25fYWRkcicpIHx8IGxpbmsuaW5jbHVkZXMoJ3Rvbi0tNUZhZGRyJyk7XG59XG5mdW5jdGlvbiBlbmNvZGVUZWxlZ3JhbVVybFBhcmFtZXRlcnMocGFyYW1ldGVycykge1xuICAgIHJldHVybiBwYXJhbWV0ZXJzXG4gICAgICAgIC5yZXBsYWNlQWxsKCcuJywgJyUyRScpXG4gICAgICAgIC5yZXBsYWNlQWxsKCctJywgJyUyRCcpXG4gICAgICAgIC5yZXBsYWNlQWxsKCdfJywgJyU1RicpXG4gICAgICAgIC5yZXBsYWNlQWxsKCcmJywgJy0nKVxuICAgICAgICAucmVwbGFjZUFsbCgnPScsICdfXycpXG4gICAgICAgIC5yZXBsYWNlQWxsKCclJywgJy0tJyk7XG59XG5mdW5jdGlvbiBkZWNvZGVUZWxlZ3JhbVVybFBhcmFtZXRlcnMocGFyYW1ldGVycykge1xuICAgIHJldHVybiBwYXJhbWV0ZXJzXG4gICAgICAgIC5yZXBsYWNlQWxsKCctLScsICclJylcbiAgICAgICAgLnJlcGxhY2VBbGwoJ19fJywgJz0nKVxuICAgICAgICAucmVwbGFjZUFsbCgnLScsICcmJylcbiAgICAgICAgLnJlcGxhY2VBbGwoJyU1RicsICdfJylcbiAgICAgICAgLnJlcGxhY2VBbGwoJyUyRCcsICctJylcbiAgICAgICAgLnJlcGxhY2VBbGwoJyUyRScsICcuJyk7XG59XG5cbi8qKlxuICogRGVsYXlzIHRoZSBleGVjdXRpb24gb2YgY29kZSBmb3IgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgdGhlIGV4ZWN1dGlvbi5cbiAqIEBwYXJhbSB7RGVsYXlPcHRpb25zfSBbb3B0aW9uc10gLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBkZWxheS5cbiAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgdGhlIHNwZWNpZmllZCBkZWxheSwgb3IgcmVqZWN0cyBpZiB0aGUgZGVsYXkgaXMgYWJvcnRlZC5cbiAqL1xuZnVuY3Rpb24gZGVsYXkodGltZW91dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKChfYSA9IHZvaWQgMCApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUb25Db25uZWN0RXJyb3IoJ0RlbGF5IGFib3J0ZWQnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKCksIHRpbWVvdXQpO1xuICAgICAgICAgICAgKF9iID0gdm9pZCAwICkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVG9uQ29ubmVjdEVycm9yKCdEZWxheSBhYm9ydGVkJykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gQWJvcnRDb250cm9sbGVyIGluc3RhbmNlIHdpdGggYW4gb3B0aW9uYWwgQWJvcnRTaWduYWwuXG4gKlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gLSBBbiBvcHRpb25hbCBBYm9ydFNpZ25hbCB0byB1c2UgZm9yIGFib3J0aW5nIHRoZSBjb250cm9sbGVyLlxuICogQHJldHVybnMge0Fib3J0Q29udHJvbGxlcn0gLSBBbiBpbnN0YW5jZSBvZiBBYm9ydENvbnRyb2xsZXIuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFib3J0Q29udHJvbGxlcihzaWduYWwpIHtcbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgaWYgKHNpZ25hbCA9PT0gbnVsbCB8fCBzaWduYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2lnbmFsID09PSBudWxsIHx8IHNpZ25hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gYWJvcnRDb250cm9sbGVyLmFib3J0KCksIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFib3J0Q29udHJvbGxlcjtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB0byBjYWxsIHRvbiBhcGkgdW50aWwgd2UgZ2V0IHJlc3BvbnNlLlxuICogQmVjYXVzZSB0b24gbmV0d29yayBpcyBwcmV0dHkgdW5zdGFibGUgd2UgbmVlZCB0byBtYWtlIHN1cmUgcmVzcG9uc2UgaXMgZmluYWwuXG4gKiBAcGFyYW0ge1R9IGZuIC0gZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHtDYWxsRm9yU3VjY2Vzc09wdGlvbnN9IFtvcHRpb25zXSAtIG9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gY2FsbEZvclN1Y2Nlc3MoZm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBhdHRlbXB0cyA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRlbXB0cykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTA7XG4gICAgICAgIGNvbnN0IGRlbGF5TXMgPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVsYXlNcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMjAwO1xuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBjcmVhdGVBYm9ydENvbnRyb2xsZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCk7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoYEV4cGVjdGVkIGEgZnVuY3Rpb24sIGdvdCAke3R5cGVvZiBmbn1gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBsYXN0RXJyb3I7XG4gICAgICAgIHdoaWxlIChpIDwgYXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKGBBYm9ydGVkIGFmdGVyIGF0dGVtcHRzICR7aX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGZuKHsgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGxhc3RFcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBhdHRlbXB0cykge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBkZWxheShkZWxheU1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbGFzdEVycm9yO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBsb2dEZWJ1ZyguLi5hcmdzKSB7XG4gICAge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnW1RPTl9DT05ORUNUX1NES10nLCAuLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGxvZ0Vycm9yKC4uLmFyZ3MpIHtcbiAgICB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbVE9OX0NPTk5FQ1RfU0RLXScsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgfVxufVxuZnVuY3Rpb24gbG9nV2FybmluZyguLi5hcmdzKSB7XG4gICAge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbVE9OX0NPTk5FQ1RfU0RLXScsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJlc291cmNlLlxuICpcbiAqIEB0ZW1wbGF0ZSBUIC0gVGhlIHR5cGUgb2YgdGhlIHJlc291cmNlLlxuICogQHRlbXBsYXRlIEFyZ3MgLSBUaGUgdHlwZSBvZiB0aGUgYXJndW1lbnRzIGZvciBjcmVhdGluZyB0aGUgcmVzb3VyY2UuXG4gKlxuICogQHBhcmFtIHsoLi4uYXJnczogQXJncykgPT4gUHJvbWlzZTxUPn0gY3JlYXRlRm4gLSBBIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGUgcmVzb3VyY2UuXG4gKiBAcGFyYW0geyhyZXNvdXJjZTogVCkgPT4gUHJvbWlzZTx2b2lkPn0gW2Rpc3Bvc2VGbl0gLSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IGRpc3Bvc2VzIHRoZSByZXNvdXJjZS5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGNyZWF0ZVJlc291cmNlKGNyZWF0ZUZuLCBkaXNwb3NlRm4pIHtcbiAgICBsZXQgY3VycmVudFJlc291cmNlID0gbnVsbDtcbiAgICBsZXQgY3VycmVudEFyZ3MgPSBudWxsO1xuICAgIGxldCBjdXJyZW50UHJvbWlzZSA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnRTaWduYWwgPSBudWxsO1xuICAgIGxldCBhYm9ydENvbnRyb2xsZXIgPSBudWxsO1xuICAgIC8vIGNyZWF0ZSBhIG5ldyByZXNvdXJjZVxuICAgIGNvbnN0IGNyZWF0ZSA9IChzaWduYWwsIC4uLmFyZ3MpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY3VycmVudFNpZ25hbCA9IHNpZ25hbCAhPT0gbnVsbCAmJiBzaWduYWwgIT09IHZvaWQgMCA/IHNpZ25hbCA6IG51bGw7XG4gICAgICAgIGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICBhYm9ydENvbnRyb2xsZXIgPSBjcmVhdGVBYm9ydENvbnRyb2xsZXIoc2lnbmFsKTtcbiAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignUmVzb3VyY2UgY3JlYXRpb24gd2FzIGFib3J0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50QXJncyA9IGFyZ3MgIT09IG51bGwgJiYgYXJncyAhPT0gdm9pZCAwID8gYXJncyA6IG51bGw7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBjcmVhdGVGbihhYm9ydENvbnRyb2xsZXIuc2lnbmFsLCAuLi5hcmdzKTtcbiAgICAgICAgY3VycmVudFByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICBjb25zdCByZXNvdXJjZSA9IHlpZWxkIHByb21pc2U7XG4gICAgICAgIGlmIChjdXJyZW50UHJvbWlzZSAhPT0gcHJvbWlzZSAmJiByZXNvdXJjZSAhPT0gY3VycmVudFJlc291cmNlKSB7XG4gICAgICAgICAgICB5aWVsZCBkaXNwb3NlRm4ocmVzb3VyY2UpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignUmVzb3VyY2UgY3JlYXRpb24gd2FzIGFib3J0ZWQgYnkgYSBuZXcgcmVzb3VyY2UgY3JlYXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UmVzb3VyY2UgPSByZXNvdXJjZTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXNvdXJjZTtcbiAgICB9KTtcbiAgICAvLyBnZXQgdGhlIGN1cnJlbnQgcmVzb3VyY2VcbiAgICBjb25zdCBjdXJyZW50ID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gY3VycmVudFJlc291cmNlICE9PSBudWxsICYmIGN1cnJlbnRSZXNvdXJjZSAhPT0gdm9pZCAwID8gY3VycmVudFJlc291cmNlIDogbnVsbDtcbiAgICB9O1xuICAgIC8vIGRpc3Bvc2UgdGhlIGN1cnJlbnQgcmVzb3VyY2VcbiAgICBjb25zdCBkaXNwb3NlID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzb3VyY2UgPSBjdXJyZW50UmVzb3VyY2U7XG4gICAgICAgICAgICBjdXJyZW50UmVzb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IGN1cnJlbnRQcm9taXNlO1xuICAgICAgICAgICAgY3VycmVudFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIgPT09IG51bGwgfHwgYWJvcnRDb250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsU2V0dGxlZChbXG4gICAgICAgICAgICAgICAgcmVzb3VyY2UgPyBkaXNwb3NlRm4ocmVzb3VyY2UpIDogUHJvbWlzZS5yZXNvbHZlKCksXG4gICAgICAgICAgICAgICAgcHJvbWlzZSA/IGRpc3Bvc2VGbih5aWVsZCBwcm9taXNlKSA6IFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfSk7XG4gICAgLy8gcmVjcmVhdGUgdGhlIGN1cnJlbnQgcmVzb3VyY2VcbiAgICBjb25zdCByZWNyZWF0ZSA9IChkZWxheU1zKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHJlc291cmNlID0gY3VycmVudFJlc291cmNlO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gY3VycmVudFByb21pc2U7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBjdXJyZW50QXJncztcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gY3VycmVudFNpZ25hbDtcbiAgICAgICAgeWllbGQgZGVsYXkoZGVsYXlNcyk7XG4gICAgICAgIGlmIChyZXNvdXJjZSA9PT0gY3VycmVudFJlc291cmNlICYmXG4gICAgICAgICAgICBwcm9taXNlID09PSBjdXJyZW50UHJvbWlzZSAmJlxuICAgICAgICAgICAgYXJncyA9PT0gY3VycmVudEFyZ3MgJiZcbiAgICAgICAgICAgIHNpZ25hbCA9PT0gY3VycmVudFNpZ25hbCkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNyZWF0ZShjdXJyZW50U2lnbmFsLCAuLi4oYXJncyAhPT0gbnVsbCAmJiBhcmdzICE9PSB2b2lkIDAgPyBhcmdzIDogW10pKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdSZXNvdXJjZSByZWNyZWF0aW9uIHdhcyBhYm9ydGVkIGJ5IGEgbmV3IHJlc291cmNlIGNyZWF0aW9uJyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlLFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICBkaXNwb3NlLFxuICAgICAgICByZWNyZWF0ZVxuICAgIH07XG59XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBmdW5jdGlvbiBhbmQgcHJvdmlkZXMgZGVmZXJyZWQgYmVoYXZpb3IsIGFsbG93aW5nIGZvciBhIHRpbWVvdXQgYW5kIGFib3J0IGZ1bmN0aW9uYWxpdHkuXG4gKlxuICogQHBhcmFtIHtEZWZlcnJhYmxlPFQ+fSBmbiAtIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlLiBJdCBzaG91bGQgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGRlc2lyZWQgcmVzdWx0LlxuICogQHBhcmFtIHtEZWZlck9wdGlvbnN9IG9wdGlvbnMgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBkZWZlciBiZWhhdmlvci5cbiAqIEByZXR1cm5zIHtQcm9taXNlPFQ+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgZXhlY3V0ZWQgZnVuY3Rpb24sIG9yIHJlamVjdHMgd2l0aCBhbiBlcnJvciBpZiBpdCB0aW1lcyBvdXQgb3IgaXMgYWJvcnRlZC5cbiAqL1xuZnVuY3Rpb24gdGltZW91dChmbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpbWVvdXQgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGltZW91dDtcbiAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsO1xuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IGNyZWF0ZUFib3J0Q29udHJvbGxlcihzaWduYWwpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgVG9uQ29ubmVjdEVycm9yKCdPcGVyYXRpb24gYWJvcnRlZCcpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGltZW91dElkO1xuICAgICAgICBpZiAodHlwZW9mIHRpbWVvdXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IFRvbkNvbm5lY3RFcnJvcihgVGltZW91dCBhZnRlciAke3RpbWVvdXR9bXNgKSk7XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICByZWplY3QobmV3IFRvbkNvbm5lY3RFcnJvcignT3BlcmF0aW9uIGFib3J0ZWQnKSk7XG4gICAgICAgIH0sIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgZGVmZXJPcHRpb25zID0geyB0aW1lb3V0LCBhYm9ydDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCB9O1xuICAgICAgICB5aWVsZCBmbigoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICByZXNvbHZlKC4uLmFyZ3MpO1xuICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9LCBkZWZlck9wdGlvbnMpO1xuICAgIH0pKTtcbn1cblxuY2xhc3MgQnJpZGdlR2F0ZXdheSB7XG4gICAgZ2V0IGlzUmVhZHkoKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50U291cmNlID0gdGhpcy5ldmVudFNvdXJjZS5jdXJyZW50KCk7XG4gICAgICAgIHJldHVybiAoZXZlbnRTb3VyY2UgPT09IG51bGwgfHwgZXZlbnRTb3VyY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50U291cmNlLnJlYWR5U3RhdGUpID09PSBFdmVudFNvdXJjZS5PUEVOO1xuICAgIH1cbiAgICBnZXQgaXNDbG9zZWQoKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50U291cmNlID0gdGhpcy5ldmVudFNvdXJjZS5jdXJyZW50KCk7XG4gICAgICAgIHJldHVybiAoZXZlbnRTb3VyY2UgPT09IG51bGwgfHwgZXZlbnRTb3VyY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50U291cmNlLnJlYWR5U3RhdGUpICE9PSBFdmVudFNvdXJjZS5PUEVOO1xuICAgIH1cbiAgICBnZXQgaXNDb25uZWN0aW5nKCkge1xuICAgICAgICBjb25zdCBldmVudFNvdXJjZSA9IHRoaXMuZXZlbnRTb3VyY2UuY3VycmVudCgpO1xuICAgICAgICByZXR1cm4gKGV2ZW50U291cmNlID09PSBudWxsIHx8IGV2ZW50U291cmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldmVudFNvdXJjZS5yZWFkeVN0YXRlKSA9PT0gRXZlbnRTb3VyY2UuQ09OTkVDVElORztcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc3RvcmFnZSwgYnJpZGdlVXJsLCBzZXNzaW9uSWQsIGxpc3RlbmVyLCBlcnJvcnNMaXN0ZW5lciwgYW5hbHl0aWNzTWFuYWdlcikge1xuICAgICAgICB0aGlzLmJyaWRnZVVybCA9IGJyaWRnZVVybDtcbiAgICAgICAgdGhpcy5zZXNzaW9uSWQgPSBzZXNzaW9uSWQ7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5lcnJvcnNMaXN0ZW5lciA9IGVycm9yc0xpc3RlbmVyO1xuICAgICAgICB0aGlzLnNzZVBhdGggPSAnZXZlbnRzJztcbiAgICAgICAgdGhpcy5wb3N0UGF0aCA9ICdtZXNzYWdlJztcbiAgICAgICAgdGhpcy5oZWFydGJlYXRNZXNzYWdlID0gJ2hlYXJ0YmVhdCc7XG4gICAgICAgIHRoaXMuZGVmYXVsdFR0bCA9IDMwMDtcbiAgICAgICAgdGhpcy5kZWZhdWx0UmVjb25uZWN0RGVsYXkgPSAyMDAwO1xuICAgICAgICB0aGlzLmRlZmF1bHRSZXNlbmREZWxheSA9IDUwMDA7XG4gICAgICAgIHRoaXMuZXZlbnRTb3VyY2UgPSBjcmVhdGVSZXNvdXJjZSgoc2lnbmFsLCBvcGVuaW5nRGVhZGxpbmVNUywgdHJhY2VJZCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRTb3VyY2VDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgYnJpZGdlVXJsOiB0aGlzLmJyaWRnZVVybCxcbiAgICAgICAgICAgICAgICBzc2VQYXRoOiB0aGlzLnNzZVBhdGgsXG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkOiB0aGlzLnNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICBicmlkZ2VHYXRld2F5U3RvcmFnZTogdGhpcy5icmlkZ2VHYXRld2F5U3RvcmFnZSxcbiAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXI6IHRoaXMuZXJyb3JzSGFuZGxlci5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyOiB0aGlzLm1lc3NhZ2VzSGFuZGxlci5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogc2lnbmFsLFxuICAgICAgICAgICAgICAgIG9wZW5pbmdEZWFkbGluZU1TOiBvcGVuaW5nRGVhZGxpbmVNUyxcbiAgICAgICAgICAgICAgICB0cmFjZUlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNyZWF0ZUV2ZW50U291cmNlKGV2ZW50U291cmNlQ29uZmlnKTtcbiAgICAgICAgfSksIChyZXNvdXJjZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmVzb3VyY2UuY2xvc2UoKTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmJyaWRnZUdhdGV3YXlTdG9yYWdlID0gbmV3IEh0dHBCcmlkZ2VHYXRld2F5U3RvcmFnZShzdG9yYWdlLCBicmlkZ2VVcmwpO1xuICAgICAgICB0aGlzLmFuYWx5dGljcyA9IGFuYWx5dGljc01hbmFnZXIgPT09IG51bGwgfHwgYW5hbHl0aWNzTWFuYWdlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5hbHl0aWNzTWFuYWdlci5zY29wZWQoe1xuICAgICAgICAgICAgYnJpZGdlX3VybDogYnJpZGdlVXJsLFxuICAgICAgICAgICAgY2xpZW50X2lkOiBzZXNzaW9uSWRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyU2Vzc2lvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5hbmFseXRpY3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbWl0QnJpZGdlQ2xpZW50Q29ubmVjdFN0YXJ0ZWQoe1xuICAgICAgICAgICAgICAgICAgICB0cmFjZV9pZDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYWNlSWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uU3RhcnRlZCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5ldmVudFNvdXJjZS5jcmVhdGUob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9wZW5pbmdEZWFkbGluZU1TLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnJpZGdlQ29ubmVjdER1cmF0aW9uID0gRGF0ZS5ub3coKSAtIGNvbm5lY3Rpb25TdGFydGVkO1xuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMuYW5hbHl0aWNzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZW1pdEJyaWRnZUNsaWVudENvbm5lY3RFc3RhYmxpc2hlZCh7XG4gICAgICAgICAgICAgICAgICAgIGJyaWRnZV9jb25uZWN0X2R1cmF0aW9uOiBicmlkZ2VDb25uZWN0RHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlX2lkOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgKF9jID0gdGhpcy5hbmFseXRpY3MpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5lbWl0QnJpZGdlQ2xpZW50Q29ubmVjdEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VfaWQ6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFjZUlkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcl9tZXNzYWdlOiBTdHJpbmcoZXJyb3IpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kKG1lc3NhZ2UsIHJlY2VpdmVyLCB0b3BpYywgdHRsT3JPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgZGVwcmVjYXRlZCBtZXRob2RcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHRsT3JPcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudHRsID0gdHRsT3JPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy50dGwgPSB0dGxPck9wdGlvbnMgPT09IG51bGwgfHwgdHRsT3JPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0dGxPck9wdGlvbnMudHRsO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsID0gdHRsT3JPcHRpb25zID09PSBudWxsIHx8IHR0bE9yT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHRsT3JPcHRpb25zLnNpZ25hbDtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmF0dGVtcHRzID0gdHRsT3JPcHRpb25zID09PSBudWxsIHx8IHR0bE9yT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHRsT3JPcHRpb25zLmF0dGVtcHRzO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudHJhY2VJZCA9IHR0bE9yT3B0aW9ucyA9PT0gbnVsbCB8fCB0dGxPck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHR0bE9yT3B0aW9ucy50cmFjZUlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChhZGRQYXRoVG9VcmwodGhpcy5icmlkZ2VVcmwsIHRoaXMucG9zdFBhdGgpKTtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdjbGllbnRfaWQnLCB0aGlzLnNlc3Npb25JZCk7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgndG8nLCByZWNlaXZlcik7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgndHRsJywgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHRsKSB8fCB0aGlzLmRlZmF1bHRUdGwpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ3RvcGljJywgdG9waWMpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFjZUlkKSB7XG4gICAgICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ3RyYWNlX2lkJywgb3B0aW9ucy50cmFjZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBCYXNlNjQuZW5jb2RlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgeWllbGQgY2FsbEZvclN1Y2Nlc3MoKG9wdGlvbnMpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucG9zdCh1cmwsIGJvZHksIG9wdGlvbnMuc2lnbmFsKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoYEJyaWRnZSBzZW5kIGZhaWxlZCwgc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICAgICAgYXR0ZW1wdHM6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRlbXB0cykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICAgICAgZGVsYXlNczogdGhpcy5kZWZhdWx0UmVzZW5kRGVsYXksXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLmV2ZW50U291cmNlLmRpc3Bvc2UoKS5jYXRjaChlID0+IGxvZ0Vycm9yKGBCcmlkZ2UgcGF1c2UgZmFpbGVkLCAke2V9YCkpO1xuICAgIH1cbiAgICB1blBhdXNlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgUkVDUkVBVEVfV0lUSE9VVF9ERUxBWSA9IDA7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmV2ZW50U291cmNlLnJlY3JlYXRlKFJFQ1JFQVRFX1dJVEhPVVRfREVMQVkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmV2ZW50U291cmNlLmRpc3Bvc2UoKS5jYXRjaChlID0+IGxvZ0Vycm9yKGBCcmlkZ2UgY2xvc2UgZmFpbGVkLCAke2V9YCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0TGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgIH1cbiAgICBzZXRFcnJvcnNMaXN0ZW5lcihlcnJvcnNMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmVycm9yc0xpc3RlbmVyID0gZXJyb3JzTGlzdGVuZXI7XG4gICAgfVxuICAgIHBvc3QodXJsLCBib2R5LCBzaWduYWwpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAncG9zdCcsXG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IHNpZ25hbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcihgQnJpZGdlIHNlbmQgZmFpbGVkLCBzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlcnJvcnNIYW5kbGVyKGV2ZW50U291cmNlLCBlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgICAgICBldmVudFNvdXJjZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ0JyaWRnZSBlcnJvciwgZmFpbGVkIHRvIGNvbm5lY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmVhZHkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yc0xpc3RlbmVyKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBldmVudFNvdXJjZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKGBCcmlkZ2UgcmVjb25uZWN0aW5nLCAke3RoaXMuZGVmYXVsdFJlY29ubmVjdERlbGF5fW1zIGRlbGF5YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZXZlbnRTb3VyY2UucmVjcmVhdGUodGhpcy5kZWZhdWx0UmVjb25uZWN0RGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignQnJpZGdlIGVycm9yLCB1bmtub3duIHN0YXRlJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtZXNzYWdlc0hhbmRsZXIoZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKGUuZGF0YSA9PT0gdGhpcy5oZWFydGJlYXRNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgdGhpcy5icmlkZ2VHYXRld2F5U3RvcmFnZS5zdG9yZUxhc3RFdmVudElkKGUubGFzdEV2ZW50SWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYnJpZGdlSW5jb21pbmdNZXNzYWdlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBicmlkZ2VJbmNvbWluZ01lc3NhZ2VSYXcgPSBKU09OLnBhcnNlKGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJpZGdlSW5jb21pbmdNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBicmlkZ2VJbmNvbWluZ01lc3NhZ2VSYXcubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogYnJpZGdlSW5jb21pbmdNZXNzYWdlUmF3LmZyb20sXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlSWQ6IGJyaWRnZUluY29taW5nTWVzc2FnZVJhdy50cmFjZV9pZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoYEJyaWRnZSBtZXNzYWdlIHBhcnNlIGZhaWxlZCwgbWVzc2FnZSAke2UuZGF0YX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXIoYnJpZGdlSW5jb21pbmdNZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGV2ZW50IHNvdXJjZS5cbiAqIEBwYXJhbSB7Q3JlYXRlRXZlbnRTb3VyY2VDb25maWd9IGNvbmZpZyAtIENvbmZpZ3VyYXRpb24gZm9yIGNyZWF0aW5nIGFuIGV2ZW50IHNvdXJjZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXZlbnRTb3VyY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIHlpZWxkIHRpbWVvdXQoKHJlc29sdmUsIHJlamVjdCwgZGVmZXJPcHRpb25zKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBjcmVhdGVBYm9ydENvbnRyb2xsZXIoZGVmZXJPcHRpb25zLnNpZ25hbCk7XG4gICAgICAgICAgICBjb25zdCBzaWduYWwgPSBhYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUb25Db25uZWN0RXJyb3IoJ0JyaWRnZSBjb25uZWN0aW9uIGFib3J0ZWQnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChhZGRQYXRoVG9VcmwoY29uZmlnLmJyaWRnZVVybCwgY29uZmlnLnNzZVBhdGgpKTtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdjbGllbnRfaWQnLCBjb25maWcuc2Vzc2lvbklkKTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RFdmVudElkID0geWllbGQgY29uZmlnLmJyaWRnZUdhdGV3YXlTdG9yYWdlLmdldExhc3RFdmVudElkKCk7XG4gICAgICAgICAgICBpZiAobGFzdEV2ZW50SWQpIHtcbiAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgnbGFzdF9ldmVudF9pZCcsIGxhc3RFdmVudElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcudHJhY2VJZCkge1xuICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCd0cmFjZV9pZCcsIGNvbmZpZy50cmFjZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVG9uQ29ubmVjdEVycm9yKCdCcmlkZ2UgY29ubmVjdGlvbiBhYm9ydGVkJykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50U291cmNlID0gbmV3IEV2ZW50U291cmNlKHVybC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGV2ZW50U291cmNlLm9uZXJyb3IgPSAocmVhc29uKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U291cmNlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVG9uQ29ubmVjdEVycm9yKCdCcmlkZ2UgY29ubmVjdGlvbiBhYm9ydGVkJykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0luc3RhbmNlID0geWllbGQgY29uZmlnLmVycm9ySGFuZGxlcihldmVudFNvdXJjZSwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0luc3RhbmNlICE9PSBldmVudFNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2UuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3SW5zdGFuY2UgJiYgbmV3SW5zdGFuY2UgIT09IGV2ZW50U291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG5ld0luc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudFNvdXJjZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBldmVudFNvdXJjZS5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U291cmNlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVG9uQ29ubmVjdEVycm9yKCdCcmlkZ2UgY29ubmVjdGlvbiBhYm9ydGVkJykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoZXZlbnRTb3VyY2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV2ZW50U291cmNlLm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudFNvdXJjZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFRvbkNvbm5lY3RFcnJvcignQnJpZGdlIGNvbm5lY3Rpb24gYWJvcnRlZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25maWcubWVzc2FnZUhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIChfYSA9IGNvbmZpZy5zaWduYWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudFNvdXJjZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVG9uQ29ubmVjdEVycm9yKCdCcmlkZ2UgY29ubmVjdGlvbiBhYm9ydGVkJykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLCB7IHRpbWVvdXQ6IGNvbmZpZy5vcGVuaW5nRGVhZGxpbmVNUywgc2lnbmFsOiBjb25maWcuc2lnbmFsIH0pO1xuICAgIH0pO1xufVxuXG5jb25zdCBDT05ORUNUSU9OX0hUVFBfRVhQSVJBVElPTl9USU1FID0gNSAqIDYwICogMTAwMDtcbmZ1bmN0aW9uIGlzUGVuZGluZ0Nvbm5lY3Rpb25IdHRwKGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gISgnY29ubmVjdEV2ZW50JyBpbiBjb25uZWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGlzUGVuZGluZ0Nvbm5lY3Rpb25IdHRwUmF3KGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gISgnY29ubmVjdEV2ZW50JyBpbiBjb25uZWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGlzRXhwaXJlZFBlbmRpbmdDb25uZWN0aW9uSHR0cFJhdyhjb25uZWN0aW9uKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBEYXRlLm5vdygpIC0gKChfYSA9IGNvbm5lY3Rpb24uY3JlYXRlZEF0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSA+IENPTk5FQ1RJT05fSFRUUF9FWFBJUkFUSU9OX1RJTUU7XG59XG5cbmNvbnN0IFBST1RPQ09MX1ZFUlNJT04gPSAyO1xuXG4vKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDIwIFJvYmVydCBLaWVmZmVyIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG4vLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiBJbiB0aGUgYnJvd3NlciB3ZSB0aGVyZWZvcmVcbi8vIHJlcXVpcmUgdGhlIGNyeXB0byBBUEkgYW5kIGRvIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGZhbGxiYWNrIHRvIGxvd2VyIHF1YWxpdHkgcmFuZG9tIG51bWJlclxuLy8gZ2VuZXJhdG9ycyAobGlrZSBNYXRoLnJhbmRvbSgpKS5cbmxldCBnZXRSYW5kb21WYWx1ZXM7XG5jb25zdCBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbmZ1bmN0aW9uIHJuZygpIHtcbiAgICAvLyBsYXp5IGxvYWQgc28gdGhhdCBlbnZpcm9ubWVudHMgdGhhdCBuZWVkIHRvIHBvbHlmaWxsIGhhdmUgYSBjaGFuY2UgdG8gZG8gc29cbiAgICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIGNyeXB0byA9PT0gJ3VuZGVmaW5lZCcgfHwgIWNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQjZ2V0cmFuZG9tdmFsdWVzLW5vdC1zdXBwb3J0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRSYW5kb21WYWx1ZXMgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG59XG5cbi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMjAgUm9iZXJ0IEtpZWZmZXIgYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xuY29uc3QgYnl0ZVRvSGV4ID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gICAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnNsaWNlKDEpKTtcbn1cbmZ1bmN0aW9uIHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgICAvLyBOb3RlOiBCZSBjYXJlZnVsIGVkaXRpbmcgdGhpcyBjb2RlISAgSXQncyBiZWVuIHR1bmVkIGZvciBwZXJmb3JtYW5jZVxuICAgIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuICAgIC8vXG4gICAgLy8gTm90ZSB0byBmdXR1cmUtc2VsZjogTm8sIHlvdSBjYW4ndCByZW1vdmUgdGhlIGB0b0xvd2VyQ2FzZSgpYCBjYWxsLlxuICAgIC8vIFJFRjogaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNjc3I2lzc3VlY29tbWVudC0xNzU3MzUxMzUxXG4gICAgcmV0dXJuIChieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArXG4gICAgICAgICctJyArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gK1xuICAgICAgICAnLScgK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICtcbiAgICAgICAgJy0nICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArXG4gICAgICAgICctJyArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXSkudG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAyMCBSb2JlcnQgS2llZmZlciBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuY29uc3QgX3N0YXRlID0ge307XG5mdW5jdGlvbiBVVUlEdjcob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBsZXQgYnl0ZXM7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gV2l0aCBvcHRpb25zOiBNYWtlIFVVSUQgaW5kZXBlbmRlbnQgb2YgaW50ZXJuYWwgc3RhdGVcbiAgICAgICAgYnl0ZXMgPSB2N0J5dGVzKChfYyA9IChfYSA9IG9wdGlvbnMucmFuZG9tKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2IgPSBvcHRpb25zLnJuZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwob3B0aW9ucykpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHJuZygpLCBvcHRpb25zLm1zZWNzLCBvcHRpb25zLnNlcSwgYnVmLCBvZmZzZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTm8gb3B0aW9uczogVXNlIGludGVybmFsIHN0YXRlXG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IHJuZHMgPSBybmcoKTtcbiAgICAgICAgdXBkYXRlVjdTdGF0ZShfc3RhdGUsIG5vdywgcm5kcyk7XG4gICAgICAgIGJ5dGVzID0gdjdCeXRlcyhybmRzLCBfc3RhdGUubXNlY3MsIF9zdGF0ZS5zZXEsIGJ1Ziwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZiAhPT0gbnVsbCAmJiBidWYgIT09IHZvaWQgMCA/IGJ1ZiA6IHVuc2FmZVN0cmluZ2lmeShieXRlcyk7XG59XG4vLyAoUHJpdmF0ZSEpICBEbyBub3QgdXNlLiAgVGhpcyBtZXRob2QgaXMgb25seSBleHBvcnRlZCBmb3IgdGVzdGluZyBwdXJwb3Nlc1xuLy8gYW5kIG1heSBjaGFuZ2Ugd2l0aG91dCBub3RpY2UuXG5mdW5jdGlvbiB1cGRhdGVWN1N0YXRlKHN0YXRlLCBub3csIHJuZHMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIChfYSA9IHN0YXRlLm1zZWNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoc3RhdGUubXNlY3MgPSAtSW5maW5pdHkpO1xuICAgIChfYiA9IHN0YXRlLnNlcSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKHN0YXRlLnNlcSA9IDApO1xuICAgIGlmIChub3cgPiBzdGF0ZS5tc2Vjcykge1xuICAgICAgICAvLyBUaW1lIGhhcyBtb3ZlZCBvbiEgUGljayBhIG5ldyByYW5kb20gc2VxdWVuY2UgbnVtYmVyXG4gICAgICAgIHN0YXRlLnNlcSA9IChybmRzWzZdIDw8IDIzKSB8IChybmRzWzddIDw8IDE2KSB8IChybmRzWzhdIDw8IDgpIHwgcm5kc1s5XTtcbiAgICAgICAgc3RhdGUubXNlY3MgPSBub3c7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBCdW1wIHNlcXVlbmNlIGNvdW50ZXIgdy8gMzItYml0IHJvbGxvdmVyXG4gICAgICAgIHN0YXRlLnNlcSA9IChzdGF0ZS5zZXEgKyAxKSB8IDA7XG4gICAgICAgIC8vIEluIGNhc2Ugb2Ygcm9sbG92ZXIsIGJ1bXAgdGltZXN0YW1wIHRvIHByZXNlcnZlIG1vbm90b25pY2l0eS4gVGhpcyBpc1xuICAgICAgICAvLyBhbGxvd2VkIGJ5IHRoZSBSRkMgYW5kIHNob3VsZCBzZWxmLWNvcnJlY3QgYXMgdGhlIHN5c3RlbSBjbG9jayBjYXRjaGVzXG4gICAgICAgIC8vIHVwLiBTZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzk1NjIuaHRtbCNzZWN0aW9uLTYuMi05LjRcbiAgICAgICAgaWYgKHN0YXRlLnNlcSA9PT0gMCkge1xuICAgICAgICAgICAgc3RhdGUubXNlY3MrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiB2N0J5dGVzKHJuZHMsIG1zZWNzLCBzZXEsIGJ1Ziwgb2Zmc2V0ID0gMCkge1xuICAgIGlmIChybmRzLmxlbmd0aCA8IDE2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmFuZG9tIGJ5dGVzIGxlbmd0aCBtdXN0IGJlID49IDE2Jyk7XG4gICAgfVxuICAgIGlmICghYnVmKSB7XG4gICAgICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDE2ID4gYnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVVSUQgYnl0ZSByYW5nZSAke29mZnNldH06JHtvZmZzZXQgKyAxNX0gaXMgb3V0IG9mIGJ1ZmZlciBib3VuZHNgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBEZWZhdWx0c1xuICAgIG1zZWNzICE9PSBudWxsICYmIG1zZWNzICE9PSB2b2lkIDAgPyBtc2VjcyA6IChtc2VjcyA9IERhdGUubm93KCkpO1xuICAgIHNlcSAhPT0gbnVsbCAmJiBzZXEgIT09IHZvaWQgMCA/IHNlcSA6IChzZXEgPSAoKHJuZHNbNl0gKiAweDdmKSA8PCAyNCkgfCAocm5kc1s3XSA8PCAxNikgfCAocm5kc1s4XSA8PCA4KSB8IHJuZHNbOV0pO1xuICAgIC8vIGJ5dGUgMC01OiB0aW1lc3RhbXAgKDQ4IGJpdHMpXG4gICAgYnVmW29mZnNldCsrXSA9IChtc2VjcyAvIDB4MTAwMDAwMDAwMDApICYgMHhmZjtcbiAgICBidWZbb2Zmc2V0KytdID0gKG1zZWNzIC8gMHgxMDAwMDAwMDApICYgMHhmZjtcbiAgICBidWZbb2Zmc2V0KytdID0gKG1zZWNzIC8gMHgxMDAwMDAwKSAmIDB4ZmY7XG4gICAgYnVmW29mZnNldCsrXSA9IChtc2VjcyAvIDB4MTAwMDApICYgMHhmZjtcbiAgICBidWZbb2Zmc2V0KytdID0gKG1zZWNzIC8gMHgxMDApICYgMHhmZjtcbiAgICBidWZbb2Zmc2V0KytdID0gbXNlY3MgJiAweGZmO1xuICAgIC8vIGJ5dGUgNjogYHZlcnNpb25gICg0IGJpdHMpIHwgc2VxdWVuY2UgYml0cyAyOC0zMSAoNCBiaXRzKVxuICAgIGJ1ZltvZmZzZXQrK10gPSAweDcwIHwgKChzZXEgPj4+IDI4KSAmIDB4MGYpO1xuICAgIC8vIGJ5dGUgNzogc2VxdWVuY2UgYml0cyAyMC0yNyAoOCBiaXRzKVxuICAgIGJ1ZltvZmZzZXQrK10gPSAoc2VxID4+PiAyMCkgJiAweGZmO1xuICAgIC8vIGJ5dGUgODogYHZhcmlhbnRgICgyIGJpdHMpIHwgc2VxdWVuY2UgYml0cyAxNC0xOSAoNiBiaXRzKVxuICAgIGJ1ZltvZmZzZXQrK10gPSAweDgwIHwgKChzZXEgPj4+IDE0KSAmIDB4M2YpO1xuICAgIC8vIGJ5dGUgOTogc2VxdWVuY2UgYml0cyA2LTEzICg4IGJpdHMpXG4gICAgYnVmW29mZnNldCsrXSA9IChzZXEgPj4+IDYpICYgMHhmZjtcbiAgICAvLyBieXRlIDEwOiBzZXF1ZW5jZSBiaXRzIDAtNSAoNiBiaXRzKSB8IHJhbmRvbSAoMiBiaXRzKVxuICAgIGJ1ZltvZmZzZXQrK10gPSAoKHNlcSA8PCAyKSAmIDB4ZmYpIHwgKHJuZHNbMTBdICYgMHgwMyk7XG4gICAgLy8gYnl0ZXMgMTEtMTU6IHJhbmRvbSAoNDAgYml0cylcbiAgICBidWZbb2Zmc2V0KytdID0gcm5kc1sxMV07XG4gICAgYnVmW29mZnNldCsrXSA9IHJuZHNbMTJdO1xuICAgIGJ1ZltvZmZzZXQrK10gPSBybmRzWzEzXTtcbiAgICBidWZbb2Zmc2V0KytdID0gcm5kc1sxNF07XG4gICAgYnVmW29mZnNldCsrXSA9IHJuZHNbMTVdO1xuICAgIHJldHVybiBidWY7XG59XG5cbmZ1bmN0aW9uIHdhaXRGb3JTb21lKHByb21pc2VzLCBjb3VudCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmIChjb3VudCA8PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBpZiAoY291bnQgPiBwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdjb3VudCBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2YgcHJvbWlzZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KHByb21pc2VzLmxlbmd0aCk7XG4gICAgICAgIGxldCBzZXR0bGVkQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBwcm9taXNlcy5mb3JFYWNoKChwLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShwKVxuICAgICAgICAgICAgICAgICAgICAudGhlbih2YWx1ZSA9PiAoeyBzdGF0dXM6ICdmdWxmaWxsZWQnLCB2YWx1ZSB9KSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHJlYXNvbiA9PiAoeyBzdGF0dXM6ICdyZWplY3RlZCcsIHJlYXNvbiB9KSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHNldHRsZWRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGxlZENvdW50ID09PSBjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5jbGFzcyBCcmlkZ2VQcm92aWRlciB7XG4gICAgc3RhdGljIGZyb21TdG9yYWdlKHN0b3JhZ2UsIGFuYWx5dGljc01hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB5aWVsZCBzdG9yYWdlLmdldEh0dHBDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoaXNQZW5kaW5nQ29ubmVjdGlvbkh0dHAoY29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJyaWRnZVByb3ZpZGVyKHN0b3JhZ2UsIGNvbm5lY3Rpb24uY29ubmVjdGlvblNvdXJjZSwgYW5hbHl0aWNzTWFuYWdlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJyaWRnZVByb3ZpZGVyKHN0b3JhZ2UsIHsgYnJpZGdlVXJsOiBjb25uZWN0aW9uLnNlc3Npb24uYnJpZGdlVXJsIH0sIGFuYWx5dGljc01hbmFnZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoY29ubmVjdGlvblN0b3JhZ2UsIHdhbGxldENvbm5lY3Rpb25Tb3VyY2UsIGFuYWx5dGljc01hbmFnZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlID0gY29ubmVjdGlvblN0b3JhZ2U7XG4gICAgICAgIHRoaXMud2FsbGV0Q29ubmVjdGlvblNvdXJjZSA9IHdhbGxldENvbm5lY3Rpb25Tb3VyY2U7XG4gICAgICAgIHRoaXMuYW5hbHl0aWNzTWFuYWdlciA9IGFuYWx5dGljc01hbmFnZXI7XG4gICAgICAgIHRoaXMudHlwZSA9ICdodHRwJztcbiAgICAgICAgdGhpcy5zdGFuZGFyZFVuaXZlcnNhbExpbmsgPSAndGM6Ly8nO1xuICAgICAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5nYXRld2F5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZW5kaW5nR2F0ZXdheXMgPSBbXTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5kZWZhdWx0T3BlbmluZ0RlYWRsaW5lTVMgPSAxMjAwMDtcbiAgICAgICAgdGhpcy5kZWZhdWx0UmV0cnlUaW1lb3V0TVMgPSAyMDAwO1xuICAgICAgICB0aGlzLm9wdGlvbmFsT3BlbkdhdGV3YXlzID0gMztcbiAgICAgICAgdGhpcy5hbmFseXRpY3MgPSAoX2EgPSB0aGlzLmFuYWx5dGljc01hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zY29wZWQoKTtcbiAgICB9XG4gICAgY29ubmVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHRyYWNlSWQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVVVJRHY3KCk7XG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IGNyZWF0ZUFib3J0Q29udHJvbGxlcihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsKTtcbiAgICAgICAgKF9iID0gdGhpcy5hYm9ydENvbnRyb2xsZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydCgpO1xuICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IGFib3J0Q29udHJvbGxlcjtcbiAgICAgICAgdGhpcy5jbG9zZUdhdGV3YXlzKCk7XG4gICAgICAgIGNvbnN0IHNlc3Npb25DcnlwdG8gPSBuZXcgU2Vzc2lvbkNyeXB0bygpO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSB7XG4gICAgICAgICAgICBzZXNzaW9uQ3J5cHRvLFxuICAgICAgICAgICAgYnJpZGdlVXJsOiAnYnJpZGdlVXJsJyBpbiB0aGlzLndhbGxldENvbm5lY3Rpb25Tb3VyY2VcbiAgICAgICAgICAgICAgICA/IHRoaXMud2FsbGV0Q29ubmVjdGlvblNvdXJjZS5icmlkZ2VVcmxcbiAgICAgICAgICAgICAgICA6ICcnXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblN0b3JhZ2VcbiAgICAgICAgICAgIC5zdG9yZUNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgdHlwZTogJ2h0dHAnLFxuICAgICAgICAgICAgY29ubmVjdGlvblNvdXJjZTogdGhpcy53YWxsZXRDb25uZWN0aW9uU291cmNlLFxuICAgICAgICAgICAgc2Vzc2lvbkNyeXB0b1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIGNhbGxGb3JTdWNjZXNzKF9vcHRpb25zID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlbkdhdGV3YXlzKHNlc3Npb25DcnlwdG8sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbmluZ0RlYWRsaW5lTVM6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vcGVuaW5nRGVhZGxpbmVNUykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5kZWZhdWx0T3BlbmluZ0RlYWRsaW5lTVMsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbDogX29wdGlvbnMgPT09IG51bGwgfHwgX29wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zLnNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VJZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGF0dGVtcHRzOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgICAgICBkZWxheU1zOiB0aGlzLmRlZmF1bHRSZXRyeVRpbWVvdXRNUyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHVuaXZlcnNhbExpbmsgPSAndW5pdmVyc2FsTGluaycgaW4gdGhpcy53YWxsZXRDb25uZWN0aW9uU291cmNlICYmXG4gICAgICAgICAgICB0aGlzLndhbGxldENvbm5lY3Rpb25Tb3VyY2UudW5pdmVyc2FsTGlua1xuICAgICAgICAgICAgPyB0aGlzLndhbGxldENvbm5lY3Rpb25Tb3VyY2UudW5pdmVyc2FsTGlua1xuICAgICAgICAgICAgOiB0aGlzLnN0YW5kYXJkVW5pdmVyc2FsTGluaztcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVVbml2ZXJzYWxMaW5rKHVuaXZlcnNhbExpbmssIG1lc3NhZ2UsIHsgdHJhY2VJZCB9KTtcbiAgICB9XG4gICAgcmVzdG9yZUNvbm5lY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCB0cmFjZUlkID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYWNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFVVSUR2NygpO1xuICAgICAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gY3JlYXRlQWJvcnRDb250cm9sbGVyKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWwpO1xuICAgICAgICAgICAgKF9iID0gdGhpcy5hYm9ydENvbnRyb2xsZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydCgpO1xuICAgICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBhYm9ydENvbnRyb2xsZXI7XG4gICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbG9zZUdhdGV3YXlzKCk7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWRDb25uZWN0aW9uID0geWllbGQgdGhpcy5jb25uZWN0aW9uU3RvcmFnZS5nZXRIdHRwQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKCFzdG9yZWRDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wZW5pbmdEZWFkbGluZU1TID0gKF9jID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9wZW5pbmdEZWFkbGluZU1TKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0aGlzLmRlZmF1bHRPcGVuaW5nRGVhZGxpbmVNUztcbiAgICAgICAgICAgIGlmIChpc1BlbmRpbmdDb25uZWN0aW9uSHR0cChzdG9yZWRDb25uZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbkNyeXB0bzogc3RvcmVkQ29ubmVjdGlvbi5zZXNzaW9uQ3J5cHRvLFxuICAgICAgICAgICAgICAgICAgICBicmlkZ2VVcmw6ICdicmlkZ2VVcmwnIGluIHRoaXMud2FsbGV0Q29ubmVjdGlvblNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLndhbGxldENvbm5lY3Rpb25Tb3VyY2UuYnJpZGdlVXJsXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICcnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5vcGVuR2F0ZXdheXMoc3RvcmVkQ29ubmVjdGlvbi5zZXNzaW9uQ3J5cHRvLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5pbmdEZWFkbGluZU1TOiBvcGVuaW5nRGVhZGxpbmVNUyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIgPT09IG51bGwgfHwgYWJvcnRDb250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZUlkOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy53YWxsZXRDb25uZWN0aW9uU291cmNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ0ludGVybmFsIGVycm9yLiBDb25uZWN0aW9uIHNvdXJjZSBpcyBhcnJheSB3aGlsZSBXYWxsZXRDb25uZWN0aW9uU291cmNlSFRUUCB3YXMgZXhwZWN0ZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24gPSBzdG9yZWRDb25uZWN0aW9uLnNlc3Npb247XG4gICAgICAgICAgICBpZiAodGhpcy5nYXRld2F5KSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ0dhdGV3YXkgaXMgYWxyZWFkeSBvcGVuZWQsIGNsb3NpbmcgcHJldmlvdXMgZ2F0ZXdheScpO1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2F0ZXdheS5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5nYXRld2F5ID0gbmV3IEJyaWRnZUdhdGV3YXkodGhpcy5jb25uZWN0aW9uU3RvcmFnZS5zdG9yYWdlLCB0aGlzLndhbGxldENvbm5lY3Rpb25Tb3VyY2UuYnJpZGdlVXJsLCBzdG9yZWRDb25uZWN0aW9uLnNlc3Npb24uc2Vzc2lvbkNyeXB0by5zZXNzaW9uSWQsIHRoaXMuZ2F0ZXdheUxpc3RlbmVyLmJpbmQodGhpcyksIHRoaXMuZ2F0ZXdheUVycm9yc0xpc3RlbmVyLmJpbmQodGhpcyksIHRoaXMuYW5hbHl0aWNzTWFuYWdlcik7XG4gICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm90aWZ5IGxpc3RlbmVycyBhYm91dCBzdG9yZWQgY29ubmVjdGlvblxuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0b3JlZENvbm5lY3Rpb24uY29ubmVjdEV2ZW50KSwgeyB0cmFjZUlkIH0pKSk7XG4gICAgICAgICAgICAvLyB3YWl0IGZvciB0aGUgY29ubmVjdGlvbiB0byBiZSBvcGVuZWRcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeWllbGQgY2FsbEZvclN1Y2Nlc3Mob3B0aW9ucyA9PiB0aGlzLmdhdGV3YXkucmVnaXN0ZXJTZXNzaW9uKHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbmluZ0RlYWRsaW5lTVM6IG9wZW5pbmdEZWFkbGluZU1TLFxuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZUlkXG4gICAgICAgICAgICAgICAgfSksIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdHM6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgICAgICAgICBkZWxheU1zOiB0aGlzLmRlZmF1bHRSZXRyeVRpbWVvdXRNUyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZGlzY29ubmVjdCh7IHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCwgdHJhY2VJZCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kUmVxdWVzdChyZXF1ZXN0LCBvcHRpb25zT3JPblJlcXVlc3RTZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGRlcHJlY2F0ZWQgbWV0aG9kXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvcHRpb25zLm9uUmVxdWVzdFNlbnQgPSBvcHRpb25zT3JPblJlcXVlc3RTZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucy5vblJlcXVlc3RTZW50ID0gb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gbnVsbCB8fCBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zT3JPblJlcXVlc3RTZW50Lm9uUmVxdWVzdFNlbnQ7XG4gICAgICAgICAgICBvcHRpb25zLnNpZ25hbCA9IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IG51bGwgfHwgb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uc09yT25SZXF1ZXN0U2VudC5zaWduYWw7XG4gICAgICAgICAgICBvcHRpb25zLmF0dGVtcHRzID0gb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gbnVsbCB8fCBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zT3JPblJlcXVlc3RTZW50LmF0dGVtcHRzO1xuICAgICAgICAgICAgb3B0aW9ucy50cmFjZUlkID0gb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gbnVsbCB8fCBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zT3JPblJlcXVlc3RTZW50LnRyYWNlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gb3B0aW9ucy50cmFjZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAob3B0aW9ucy50cmFjZUlkID0gVVVJRHY3KCkpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmICghdGhpcy5nYXRld2F5IHx8ICF0aGlzLnNlc3Npb24gfHwgISgnd2FsbGV0UHVibGljS2V5JyBpbiB0aGlzLnNlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignVHJ5aW5nIHRvIHNlbmQgYnJpZGdlIHJlcXVlc3Qgd2l0aG91dCBzZXNzaW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpZCA9ICh5aWVsZCB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlLmdldE5leHRScGNSZXF1ZXN0SWQoKSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdGlvblN0b3JhZ2UuaW5jcmVhc2VOZXh0UnBjUmVxdWVzdElkKCk7XG4gICAgICAgICAgICBsb2dEZWJ1ZygnU2VuZCBodHRwLWJyaWRnZSByZXF1ZXN0OicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCksIHsgaWQgfSkpO1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZFJlcXVlc3QgPSB0aGlzLnNlc3Npb24uc2Vzc2lvbkNyeXB0by5lbmNyeXB0KEpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCksIHsgaWQgfSkpLCBoZXhUb0J5dGVBcnJheSh0aGlzLnNlc3Npb24ud2FsbGV0UHVibGljS2V5KSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuYW5hbHl0aWNzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW1pdEJyaWRnZUNsaWVudE1lc3NhZ2VTZW50KHtcbiAgICAgICAgICAgICAgICAgICAgYnJpZGdlX3VybDogdGhpcy5nYXRld2F5LmJyaWRnZVVybCxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50X2lkOiB0aGlzLnNlc3Npb24uc2Vzc2lvbkNyeXB0by5zZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgICAgIHdhbGxldF9pZDogdGhpcy5zZXNzaW9uLndhbGxldFB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZV9pZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RfdHlwZTogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlX2lkOiBvcHRpb25zLnRyYWNlSWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmdhdGV3YXkuc2VuZChlbmNvZGVkUmVxdWVzdCwgdGhpcy5zZXNzaW9uLndhbGxldFB1YmxpY0tleSwgcmVxdWVzdC5tZXRob2QsIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdHM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRlbXB0cyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZUlkOiBvcHRpb25zLnRyYWNlSWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25SZXF1ZXN0U2VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMuc2V0KGlkLnRvU3RyaW5nKCksIHJlc29sdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgY2xvc2VDb25uZWN0aW9uKCkge1xuICAgICAgICB0aGlzLmNsb3NlR2F0ZXdheXMoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5nYXRld2F5ID0gbnVsbDtcbiAgICB9XG4gICAgZGlzY29ubmVjdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB0cmFjZUlkID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYWNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFVVSUR2NygpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCB0aW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uUmVxdWVzdFNlbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVCcmlkZ2VBbmRTZXNzaW9uKCkudGhlbihyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZUdhdGV3YXlzKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IGNyZWF0ZUFib3J0Q29udHJvbGxlcihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5kZWZhdWx0T3BlbmluZ0RlYWRsaW5lTVMpO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnNlbmRSZXF1ZXN0KHsgbWV0aG9kOiAnZGlzY29ubmVjdCcsIHBhcmFtczogW10gfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25SZXF1ZXN0U2VudDogb25SZXF1ZXN0U2VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGVtcHRzOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2VJZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoJ0Rpc2Nvbm5lY3QgZXJyb3I6JywgZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUJyaWRnZUFuZFNlc3Npb24oKS50aGVuKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvblJlcXVlc3RTZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGlzdGVuKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4gKHRoaXMubGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMuZmlsdGVyKGxpc3RlbmVyID0+IGxpc3RlbmVyICE9PSBjYWxsYmFjaykpO1xuICAgIH1cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmdhdGV3YXkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXVzZSgpO1xuICAgICAgICB0aGlzLnBlbmRpbmdHYXRld2F5cy5mb3JFYWNoKGJyaWRnZSA9PiBicmlkZ2UucGF1c2UoKSk7XG4gICAgfVxuICAgIHVuUGF1c2UoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMucGVuZGluZ0dhdGV3YXlzLm1hcChicmlkZ2UgPT4gYnJpZGdlLnVuUGF1c2UoKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5nYXRld2F5KSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmdhdGV3YXkudW5QYXVzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBlbmRpbmdHYXRld2F5c0xpc3RlbmVyKGdhdGV3YXksIGJyaWRnZVVybCwgYnJpZGdlSW5jb21pbmdNZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGVuZGluZ0dhdGV3YXlzLmluY2x1ZGVzKGdhdGV3YXkpKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgZ2F0ZXdheS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xvc2VHYXRld2F5cyh7IGV4Y2VwdDogZ2F0ZXdheSB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdhdGV3YXkpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnR2F0ZXdheSBpcyBhbHJlYWR5IG9wZW5lZCwgY2xvc2luZyBwcmV2aW91cyBnYXRld2F5Jyk7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5nYXRld2F5LmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uYnJpZGdlVXJsID0gYnJpZGdlVXJsO1xuICAgICAgICAgICAgdGhpcy5nYXRld2F5ID0gZ2F0ZXdheTtcbiAgICAgICAgICAgIHRoaXMuZ2F0ZXdheS5zZXRFcnJvcnNMaXN0ZW5lcih0aGlzLmdhdGV3YXlFcnJvcnNMaXN0ZW5lci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuZ2F0ZXdheS5zZXRMaXN0ZW5lcih0aGlzLmdhdGV3YXlMaXN0ZW5lci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdhdGV3YXlMaXN0ZW5lcihicmlkZ2VJbmNvbWluZ01lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2F0ZXdheUxpc3RlbmVyKGJyaWRnZUluY29taW5nTWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCB0cmFjZUlkID0gKF9hID0gYnJpZGdlSW5jb21pbmdNZXNzYWdlLnRyYWNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFVVSUR2NygpO1xuICAgICAgICAgICAgbGV0IHdhbGxldE1lc3NhZ2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdhbGxldE1lc3NhZ2UgPSBKU09OLnBhcnNlKHRoaXMuc2Vzc2lvbi5zZXNzaW9uQ3J5cHRvLmRlY3J5cHQoQmFzZTY0LmRlY29kZShicmlkZ2VJbmNvbWluZ01lc3NhZ2UubWVzc2FnZSkudG9VaW50OEFycmF5KCksIGhleFRvQnl0ZUFycmF5KGJyaWRnZUluY29taW5nTWVzc2FnZS5mcm9tKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMuYW5hbHl0aWNzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZW1pdEJyaWRnZUNsaWVudE1lc3NhZ2VEZWNvZGVFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGJyaWRnZV91cmw6IHRoaXMuc2Vzc2lvbi5icmlkZ2VVcmwsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudF9pZDogdGhpcy5zZXNzaW9uLnNlc3Npb25DcnlwdG8uc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICB3YWxsZXRfaWQ6IGJyaWRnZUluY29taW5nTWVzc2FnZS5mcm9tLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcl9tZXNzYWdlOiBTdHJpbmcoZXJyKSxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VfaWQ6IGJyaWRnZUluY29taW5nTWVzc2FnZSA9PT0gbnVsbCB8fCBicmlkZ2VJbmNvbWluZ01lc3NhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyaWRnZUluY29taW5nTWVzc2FnZS50cmFjZUlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nRGVidWcoJ1dhbGxldCBtZXNzYWdlIHJlY2VpdmVkOicsIHdhbGxldE1lc3NhZ2UpO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdFR5cGUgPSAnZXZlbnQnIGluIHdhbGxldE1lc3NhZ2UgPyB3YWxsZXRNZXNzYWdlLmV2ZW50IDogJyc7XG4gICAgICAgICAgICAoX2MgPSB0aGlzLmFuYWx5dGljcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmVtaXRCcmlkZ2VDbGllbnRNZXNzYWdlUmVjZWl2ZWQoe1xuICAgICAgICAgICAgICAgIGJyaWRnZV91cmw6IHRoaXMuc2Vzc2lvbi5icmlkZ2VVcmwsXG4gICAgICAgICAgICAgICAgY2xpZW50X2lkOiB0aGlzLnNlc3Npb24uc2Vzc2lvbkNyeXB0by5zZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgd2FsbGV0X2lkOiBicmlkZ2VJbmNvbWluZ01lc3NhZ2UuZnJvbSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBTdHJpbmcod2FsbGV0TWVzc2FnZS5pZCksXG4gICAgICAgICAgICAgICAgcmVxdWVzdF90eXBlOiByZXF1ZXN0VHlwZSxcbiAgICAgICAgICAgICAgICB0cmFjZV9pZDogYnJpZGdlSW5jb21pbmdNZXNzYWdlID09PSBudWxsIHx8IGJyaWRnZUluY29taW5nTWVzc2FnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJpZGdlSW5jb21pbmdNZXNzYWdlLnRyYWNlSWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCEoJ2V2ZW50JyBpbiB3YWxsZXRNZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gd2FsbGV0TWVzc2FnZS5pZC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmUgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5nZXQoaWQpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhgUmVzcG9uc2UgaWQgJHtpZH0gZG9lc24ndCBtYXRjaCBhbnkgcmVxdWVzdCdzIGlkYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdhbGxldE1lc3NhZ2UpLCB7IHRyYWNlSWQgfSkpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdhbGxldE1lc3NhZ2UuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RJZCA9IHlpZWxkIHRoaXMuY29ubmVjdGlvblN0b3JhZ2UuZ2V0TGFzdFdhbGxldEV2ZW50SWQoKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdElkICE9PSB1bmRlZmluZWQgJiYgd2FsbGV0TWVzc2FnZS5pZCA8PSBsYXN0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRXJyb3IoYFJlY2VpdmVkIGV2ZW50IGlkICg9JHt3YWxsZXRNZXNzYWdlLmlkfSkgbXVzdCBiZSBncmVhdGVyIHRoYW4gc3RvcmVkIGxhc3Qgd2FsbGV0IGV2ZW50IGlkICg9JHtsYXN0SWR9KSBgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAod2FsbGV0TWVzc2FnZS5ldmVudCAhPT0gJ2Nvbm5lY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdGlvblN0b3JhZ2Uuc3RvcmVMYXN0V2FsbGV0RXZlbnRJZCh3YWxsZXRNZXNzYWdlLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBgdGhpcy5saXN0ZW5lcnNgIG1pZ2h0IGJlIG1vZGlmaWVkIGluIHRoZSBldmVudCBoYW5kbGVyXG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycztcbiAgICAgICAgICAgIGlmICh3YWxsZXRNZXNzYWdlLmV2ZW50ID09PSAnY29ubmVjdCcpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnVwZGF0ZVNlc3Npb24od2FsbGV0TWVzc2FnZSwgYnJpZGdlSW5jb21pbmdNZXNzYWdlLmZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdhbGxldE1lc3NhZ2UuZXZlbnQgPT09ICdkaXNjb25uZWN0Jykge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKGBSZW1vdmluZyBicmlkZ2UgYW5kIHNlc3Npb246IHJlY2VpdmVkIGRpc2Nvbm5lY3QgZXZlbnRgKTtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnJlbW92ZUJyaWRnZUFuZFNlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd2FsbGV0TWVzc2FnZSksIHsgdHJhY2VJZCB9KSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2F0ZXdheUVycm9yc0xpc3RlbmVyKGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoYEJyaWRnZSBlcnJvciAke0pTT04uc3RyaW5naWZ5KGUpfWApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlU2Vzc2lvbihjb25uZWN0RXZlbnQsIHdhbGxldFB1YmxpY0tleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnNlc3Npb24pLCB7IHdhbGxldFB1YmxpY0tleSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRvbkFkZHJJdGVtID0gY29ubmVjdEV2ZW50LnBheWxvYWQuaXRlbXMuZmluZChpdGVtID0+IGl0ZW0ubmFtZSA9PT0gJ3Rvbl9hZGRyJyk7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0RXZlbnRUb1NhdmUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbm5lY3RFdmVudCksIHsgcGF5bG9hZDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25uZWN0RXZlbnQucGF5bG9hZCksIHsgaXRlbXM6IFt0b25BZGRySXRlbV0gfSkgfSk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlLnN0b3JlQ29ubmVjdGlvbih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2h0dHAnLFxuICAgICAgICAgICAgICAgIHNlc3Npb246IHRoaXMuc2Vzc2lvbixcbiAgICAgICAgICAgICAgICBsYXN0V2FsbGV0RXZlbnRJZDogY29ubmVjdEV2ZW50LmlkLFxuICAgICAgICAgICAgICAgIGNvbm5lY3RFdmVudDogY29ubmVjdEV2ZW50VG9TYXZlLFxuICAgICAgICAgICAgICAgIG5leHRScGNSZXF1ZXN0SWQ6IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlQnJpZGdlQW5kU2Vzc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlLnJlbW92ZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdlbmVyYXRlVW5pdmVyc2FsTGluayh1bml2ZXJzYWxMaW5rLCBtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChpc1RlbGVncmFtVXJsKHVuaXZlcnNhbExpbmspKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVRHVW5pdmVyc2FsTGluayh1bml2ZXJzYWxMaW5rLCBtZXNzYWdlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVJlZ3VsYXJVbml2ZXJzYWxMaW5rKHVuaXZlcnNhbExpbmssIG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBnZW5lcmF0ZVJlZ3VsYXJVbml2ZXJzYWxMaW5rKHVuaXZlcnNhbExpbmssIG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCh1bml2ZXJzYWxMaW5rKTtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ3YnLCBQUk9UT0NPTF9WRVJTSU9OLnRvU3RyaW5nKCkpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgnaWQnLCB0aGlzLnNlc3Npb24uc2Vzc2lvbkNyeXB0by5zZXNzaW9uSWQpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgndHJhY2VfaWQnLCBvcHRpb25zLnRyYWNlSWQpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgncicsIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKTtcbiAgICAgICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICAgIH1cbiAgICBnZW5lcmF0ZVRHVW5pdmVyc2FsTGluayh1bml2ZXJzYWxMaW5rLCBtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHVybFRvV3JhcCA9IHRoaXMuZ2VuZXJhdGVSZWd1bGFyVW5pdmVyc2FsTGluaygnYWJvdXQ6YmxhbmsnLCBtZXNzYWdlLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbGlua1BhcmFtcyA9IHVybFRvV3JhcC5zcGxpdCgnPycpWzFdO1xuICAgICAgICBjb25zdCBzdGFydGFwcCA9ICd0b25jb25uZWN0LScgKyBlbmNvZGVUZWxlZ3JhbVVybFBhcmFtZXRlcnMobGlua1BhcmFtcyk7XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIGxpbmUgYWZ0ZXIgYWxsIGRBcHBzIGFuZCB0aGUgd2FsbGV0cy1saXN0Lmpzb24gaGF2ZSBiZWVuIHVwZGF0ZWRcbiAgICAgICAgY29uc3QgdXBkYXRlZFVuaXZlcnNhbExpbmsgPSB0aGlzLmNvbnZlcnRUb0RpcmVjdExpbmsodW5pdmVyc2FsTGluayk7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodXBkYXRlZFVuaXZlcnNhbExpbmspO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgnc3RhcnRhcHAnLCBzdGFydGFwcCk7XG4gICAgICAgIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgbWV0aG9kIGFmdGVyIGFsbCBkQXBwcyBhbmQgdGhlIHdhbGxldHMtbGlzdC5qc29uIGhhdmUgYmVlbiB1cGRhdGVkXG4gICAgY29udmVydFRvRGlyZWN0TGluayh1bml2ZXJzYWxMaW5rKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodW5pdmVyc2FsTGluayk7XG4gICAgICAgIGlmICh1cmwuc2VhcmNoUGFyYW1zLmhhcygnYXR0YWNoJykpIHtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKCdhdHRhY2gnKTtcbiAgICAgICAgICAgIHVybC5wYXRobmFtZSArPSAnL3N0YXJ0JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIG9wZW5HYXRld2F5cyhzZXNzaW9uQ3J5cHRvLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB0cmFjZUlkID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYWNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFVVSUR2NygpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy53YWxsZXRDb25uZWN0aW9uU291cmNlKSkge1xuICAgICAgICAgICAgICAgIC8vIGNsb3NlIGFsbCBnYXRld2F5cyBiZWZvcmUgb3BlbmluZyBuZXcgb25lc1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0dhdGV3YXlzLm1hcChicmlkZ2UgPT4gYnJpZGdlLmNsb3NlKCkuY2F0Y2goKSk7XG4gICAgICAgICAgICAgICAgLy8gb3BlbiBuZXcgZ2F0ZXdheXNcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdHYXRld2F5cyA9IHRoaXMud2FsbGV0Q29ubmVjdGlvblNvdXJjZS5tYXAoc291cmNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2F0ZXdheSA9IG5ldyBCcmlkZ2VHYXRld2F5KHRoaXMuY29ubmVjdGlvblN0b3JhZ2Uuc3RvcmFnZSwgc291cmNlLmJyaWRnZVVybCwgc2Vzc2lvbkNyeXB0by5zZXNzaW9uSWQsICgpID0+IHsgfSwgKCkgPT4geyB9LCB0aGlzLmFuYWx5dGljc01hbmFnZXIpO1xuICAgICAgICAgICAgICAgICAgICBnYXRld2F5LnNldExpc3RlbmVyKG1lc3NhZ2UgPT4gdGhpcy5wZW5kaW5nR2F0ZXdheXNMaXN0ZW5lcihnYXRld2F5LCBzb3VyY2UuYnJpZGdlVXJsLCBtZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnYXRld2F5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFdhaXQgdW50aWwgdGhlIHNwZWNpZmllZCBvcHRpb25hbCBnYXRld2F5cyBhcmUgb3BlbmVkLCBub3QgbmVjZXNzYXJpbHkgYWxsIGdhdGV3YXlzXG4gICAgICAgICAgICAgICAgY29uc3QgZ2F0ZXdheXNUb1dhaXRGb3IgPSBNYXRoLm1heCh0aGlzLnBlbmRpbmdHYXRld2F5cy5sZW5ndGggLSB0aGlzLm9wdGlvbmFsT3BlbkdhdGV3YXlzLCAxKTtcbiAgICAgICAgICAgICAgICB5aWVsZCB3YWl0Rm9yU29tZSh0aGlzLnBlbmRpbmdHYXRld2F5cy5tYXAoYnJpZGdlID0+IGNhbGxGb3JTdWNjZXNzKChfb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wZW5kaW5nR2F0ZXdheXMuc29tZShpdGVtID0+IGl0ZW0gPT09IGJyaWRnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBicmlkZ2UuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnJpZGdlLnJlZ2lzdGVyU2Vzc2lvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuaW5nRGVhZGxpbmVNUzogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9wZW5pbmdEZWFkbGluZU1TKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmRlZmF1bHRPcGVuaW5nRGVhZGxpbmVNUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogX29wdGlvbnMuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2VJZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRzOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgICAgICAgICAgZGVsYXlNczogdGhpcy5kZWZhdWx0UmV0cnlUaW1lb3V0TVMsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbFxuICAgICAgICAgICAgICAgIH0pKSwgZ2F0ZXdheXNUb1dhaXRGb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdhdGV3YXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoYEdhdGV3YXkgaXMgYWxyZWFkeSBvcGVuZWQsIGNsb3NpbmcgcHJldmlvdXMgZ2F0ZXdheWApO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmdhdGV3YXkuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5nYXRld2F5ID0gbmV3IEJyaWRnZUdhdGV3YXkodGhpcy5jb25uZWN0aW9uU3RvcmFnZS5zdG9yYWdlLCB0aGlzLndhbGxldENvbm5lY3Rpb25Tb3VyY2UuYnJpZGdlVXJsLCBzZXNzaW9uQ3J5cHRvLnNlc3Npb25JZCwgdGhpcy5nYXRld2F5TGlzdGVuZXIuYmluZCh0aGlzKSwgdGhpcy5nYXRld2F5RXJyb3JzTGlzdGVuZXIuYmluZCh0aGlzKSwgdGhpcy5hbmFseXRpY3NNYW5hZ2VyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5nYXRld2F5LnJlZ2lzdGVyU2Vzc2lvbih7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5pbmdEZWFkbGluZU1TOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub3BlbmluZ0RlYWRsaW5lTVMsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VJZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvc2VHYXRld2F5cyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5nYXRld2F5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nR2F0ZXdheXNcbiAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtICE9PSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmV4Y2VwdCkpXG4gICAgICAgICAgICAuZm9yRWFjaChicmlkZ2UgPT4gYnJpZGdlLmNsb3NlKCkpO1xuICAgICAgICB0aGlzLnBlbmRpbmdHYXRld2F5cyA9IFtdO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFzUHJvcGVydHkodmFsdWUsIHByb3BlcnR5S2V5KSB7XG4gICAgcmV0dXJuIGhhc1Byb3BlcnRpZXModmFsdWUsIFtwcm9wZXJ0eUtleV0pO1xufVxuZnVuY3Rpb24gaGFzUHJvcGVydGllcyh2YWx1ZSwgcHJvcGVydHlLZXlzKSB7XG4gICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BlcnR5S2V5cy5ldmVyeShwcm9wZXJ0eUtleSA9PiBwcm9wZXJ0eUtleSBpbiB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGlzSlNCcmlkZ2VXaXRoTWV0YWRhdGEodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIWhhc1Byb3BlcnR5KHZhbHVlLCAndG9uY29ubmVjdCcpIHx8ICFoYXNQcm9wZXJ0eSh2YWx1ZS50b25jb25uZWN0LCAnd2FsbGV0SW5mbycpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhc1Byb3BlcnRpZXModmFsdWUudG9uY29ubmVjdC53YWxsZXRJbmZvLCBbXG4gICAgICAgICAgICAnbmFtZScsXG4gICAgICAgICAgICAnYXBwX25hbWUnLFxuICAgICAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgICAgICdhYm91dF91cmwnLFxuICAgICAgICAgICAgJ3BsYXRmb3JtcydcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKipcbiAqIEluIG1lbW9yeSBzdG9yYWdlIGxpa2UgbG9jYWxTdG9yYWdlLCBidXQgd2l0aG91dCBwZXJzaXN0ZW5jZS5cbiAqIFVzZXMgYXMgYSBmYWxsYmFjayBmb3IgbG9jYWxTdG9yYWdlIGluIFNhZmFyaSdzIHByaXZhdGUgbW9kZS5cbiAqL1xuY2xhc3MgSW5NZW1vcnlTdG9yYWdlIHtcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XG4gICAgICAgIGlmICghSW5NZW1vcnlTdG9yYWdlLmluc3RhbmNlKSB7XG4gICAgICAgICAgICBJbk1lbW9yeVN0b3JhZ2UuaW5zdGFuY2UgPSBuZXcgSW5NZW1vcnlTdG9yYWdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEluTWVtb3J5U3RvcmFnZS5pbnN0YW5jZTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHt9O1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zdG9yYWdlKS5sZW5ndGg7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSB7fTtcbiAgICB9XG4gICAgZ2V0SXRlbShrZXkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5zdG9yYWdlW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgfVxuICAgIGtleShpbmRleCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLnN0b3JhZ2UpO1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKF9hID0ga2V5c1tpbmRleF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgfVxuICAgIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnN0b3JhZ2Vba2V5XTtcbiAgICB9XG4gICAgc2V0SXRlbShrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZVtrZXldID0gdmFsdWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3coKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3c7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBnZXRXZWJQYWdlTWFuaWZlc3QoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG9yaWdpbiA9IChfYSA9IGdldFdpbmRvdygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYXRpb24ub3JpZ2luO1xuICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbiArICcvdG9uY29ubmVjdC1tYW5pZmVzdC5qc29uJztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuZnVuY3Rpb24gZ2V0T3JpZ2luV2l0aFBhdGgoKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IG9yaWdpbiA9IChfYiA9IChfYSA9IGdldFdpbmRvdygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vcmlnaW47XG4gICAgY29uc3QgcGF0aCA9IChfZCA9IChfYyA9IGdldFdpbmRvdygpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubG9jYXRpb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5wYXRobmFtZTtcbiAgICBpZiAob3JpZ2luICYmIHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbiArIHBhdGg7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cbi8qKlxuICogUmV0dXJucyBgbG9jYWxTdG9yYWdlYCBpZiBpdCBpcyBhdmFpbGFibGUuIEluIFNhZmFyaSdzIHByaXZhdGUgbW9kZSwgaXQgcmV0dXJucyBgSW5NZW1vcnlTdG9yYWdlYC4gSW4gTm9kZS5qcywgaXQgdGhyb3dzIGFuIGVycm9yLlxuICovXG5mdW5jdGlvbiB0cnlHZXRMb2NhbFN0b3JhZ2UoKSB7XG4gICAgaWYgKGlzTG9jYWxTdG9yYWdlQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZTtcbiAgICB9XG4gICAgaWYgKGlzTm9kZUpzKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignYGxvY2FsU3RvcmFnZWAgaXMgdW5hdmFpbGFibGUsIGJ1dCBpdCBpcyByZXF1aXJlZCBmb3IgVG9uQ29ubmVjdC4gRm9yIG1vcmUgZGV0YWlscywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90b24tY29ubmVjdC9zZGsvdHJlZS9tYWluL3BhY2thZ2VzL3NkayNpbml0LWNvbm5lY3RvcicpO1xuICAgIH1cbiAgICByZXR1cm4gSW5NZW1vcnlTdG9yYWdlLmdldEluc3RhbmNlKCk7XG59XG4vKipcbiAqIENoZWNrcyBpZiBgbG9jYWxTdG9yYWdlYCBpcyBhdmFpbGFibGUuXG4gKi9cbmZ1bmN0aW9uIGlzTG9jYWxTdG9yYWdlQXZhaWxhYmxlKCkge1xuICAgIC8vIFdlIHVzZSBhIHRyeS9jYXRjaCBibG9jayBiZWNhdXNlIFNhZmFyaSdzIHByaXZhdGUgbW9kZSB0aHJvd3MgYW4gZXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGFjY2VzcyBsb2NhbFN0b3JhZ2UuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBlbnZpcm9ubWVudCBpcyBOb2RlLmpzLlxuICovXG5mdW5jdGlvbiBpc05vZGVKcygpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb25zICE9IG51bGwgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9IG51bGwpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRvbWFpbiAoaG9zdG5hbWUpIGlmIGF2YWlsYWJsZS5cbiAqIEluIGJyb3dzZXIgZW52aXJvbm1lbnQsIHJldHVybnMgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLlxuICogSW4gTm9kZS5qcyBlbnZpcm9ubWVudCBvciB3aGVuIHdpbmRvdyBpcyBub3QgYXZhaWxhYmxlLCByZXR1cm5zIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdldERvbWFpbigpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBJbiBicm93c2VyIGVudmlyb25tZW50XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJbiBOb2RlLmpzIGVudmlyb25tZW50LCBza2lwIGRvbWFpbiB2YWxpZGF0aW9uXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIFtrZXksIHZhbHVlXSBwYWlycyBmcm9tIHdpbmRvdyBvYmplY3QgaWYgYXZhaWxhYmxlLlxuICogSW4gYnJvd3NlciBlbnZpcm9ubWVudCwgcmV0dXJucyBPYmplY3QuZW50cmllcyh3aW5kb3cpLlxuICogSW4gTm9kZS5qcyBlbnZpcm9ubWVudCBvciB3aGVuIHdpbmRvdyBpcyBub3QgYXZhaWxhYmxlLCByZXR1cm5zIGVtcHR5IGFycmF5LlxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3dFbnRyaWVzKCkge1xuICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgIGlmICghd2luZG93KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHdpbmRvdyk7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuXG5jbGFzcyBJbmplY3RlZFByb3ZpZGVyIHtcbiAgICBzdGF0aWMgZnJvbVN0b3JhZ2Uoc3RvcmFnZSwgYW5hbHl0aWNzTWFuYWdlcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHlpZWxkIHN0b3JhZ2UuZ2V0SW5qZWN0ZWRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEluamVjdGVkUHJvdmlkZXIoc3RvcmFnZSwgY29ubmVjdGlvbi5qc0JyaWRnZUtleSwgYW5hbHl0aWNzTWFuYWdlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgaXNXYWxsZXRJbmplY3RlZChpbmplY3RlZFdhbGxldEtleSkge1xuICAgICAgICByZXR1cm4gSW5qZWN0ZWRQcm92aWRlci5pc1dpbmRvd0NvbnRhaW5zV2FsbGV0KHRoaXMud2luZG93LCBpbmplY3RlZFdhbGxldEtleSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0luc2lkZVdhbGxldEJyb3dzZXIoaW5qZWN0ZWRXYWxsZXRLZXkpIHtcbiAgICAgICAgaWYgKEluamVjdGVkUHJvdmlkZXIuaXNXaW5kb3dDb250YWluc1dhbGxldCh0aGlzLndpbmRvdywgaW5qZWN0ZWRXYWxsZXRLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aW5kb3dbaW5qZWN0ZWRXYWxsZXRLZXldLnRvbmNvbm5lY3QuaXNXYWxsZXRCcm93c2VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3RhdGljIGdldEN1cnJlbnRseUluamVjdGVkV2FsbGV0cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLndpbmRvdykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdpbmRvd0VudHJpZXMgPSBnZXRXaW5kb3dFbnRyaWVzKCk7XG4gICAgICAgIGNvbnN0IHdhbGxldHMgPSB3aW5kb3dFbnRyaWVzLmZpbHRlcigoW19rZXksIHZhbHVlXSkgPT4gaXNKU0JyaWRnZVdpdGhNZXRhZGF0YSh2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gd2FsbGV0cy5tYXAoKFtqc0JyaWRnZUtleSwgd2FsbGV0XSkgPT4gKHtcbiAgICAgICAgICAgIG5hbWU6IHdhbGxldC50b25jb25uZWN0LndhbGxldEluZm8ubmFtZSxcbiAgICAgICAgICAgIGFwcE5hbWU6IHdhbGxldC50b25jb25uZWN0LndhbGxldEluZm8uYXBwX25hbWUsXG4gICAgICAgICAgICBhYm91dFVybDogd2FsbGV0LnRvbmNvbm5lY3Qud2FsbGV0SW5mby5hYm91dF91cmwsXG4gICAgICAgICAgICBpbWFnZVVybDogd2FsbGV0LnRvbmNvbm5lY3Qud2FsbGV0SW5mby5pbWFnZSxcbiAgICAgICAgICAgIHRvbmRuczogd2FsbGV0LnRvbmNvbm5lY3Qud2FsbGV0SW5mby50b25kbnMsXG4gICAgICAgICAgICBqc0JyaWRnZUtleSxcbiAgICAgICAgICAgIGluamVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgZW1iZWRkZWQ6IHdhbGxldC50b25jb25uZWN0LmlzV2FsbGV0QnJvd3NlcixcbiAgICAgICAgICAgIHBsYXRmb3Jtczogd2FsbGV0LnRvbmNvbm5lY3Qud2FsbGV0SW5mby5wbGF0Zm9ybXMsXG4gICAgICAgICAgICBmZWF0dXJlczogd2FsbGV0LnRvbmNvbm5lY3Qud2FsbGV0SW5mby5mZWF0dXJlc1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc1dpbmRvd0NvbnRhaW5zV2FsbGV0KHdpbmRvdywgaW5qZWN0ZWRXYWxsZXRLZXkpIHtcbiAgICAgICAgcmV0dXJuICghIXdpbmRvdyAmJlxuICAgICAgICAgICAgaW5qZWN0ZWRXYWxsZXRLZXkgaW4gd2luZG93ICYmXG4gICAgICAgICAgICB0eXBlb2Ygd2luZG93W2luamVjdGVkV2FsbGV0S2V5XSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICd0b25jb25uZWN0JyBpbiB3aW5kb3dbaW5qZWN0ZWRXYWxsZXRLZXldKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoY29ubmVjdGlvblN0b3JhZ2UsIGluamVjdGVkV2FsbGV0S2V5LCBhbmFseXRpY3NNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblN0b3JhZ2UgPSBjb25uZWN0aW9uU3RvcmFnZTtcbiAgICAgICAgdGhpcy5pbmplY3RlZFdhbGxldEtleSA9IGluamVjdGVkV2FsbGV0S2V5O1xuICAgICAgICB0aGlzLnR5cGUgPSAnaW5qZWN0ZWQnO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmxpc3RlblN1YnNjcmlwdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgY29uc3Qgd2luZG93ID0gSW5qZWN0ZWRQcm92aWRlci53aW5kb3c7XG4gICAgICAgIGlmICghSW5qZWN0ZWRQcm92aWRlci5pc1dpbmRvd0NvbnRhaW5zV2FsbGV0KHdpbmRvdywgaW5qZWN0ZWRXYWxsZXRLZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90SW5qZWN0ZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5qZWN0ZWRXYWxsZXQgPSB3aW5kb3dbaW5qZWN0ZWRXYWxsZXRLZXldLnRvbmNvbm5lY3Q7XG4gICAgICAgIGlmIChhbmFseXRpY3NNYW5hZ2VyKSB7XG4gICAgICAgICAgICB0aGlzLmFuYWx5dGljcyA9IGFuYWx5dGljc01hbmFnZXIuc2NvcGVkKHtcbiAgICAgICAgICAgICAgICBicmlkZ2Vfa2V5OiBpbmplY3RlZFdhbGxldEtleSxcbiAgICAgICAgICAgICAgICB3YWxsZXRfYXBwX25hbWU6IHRoaXMuaW5qZWN0ZWRXYWxsZXQuZGV2aWNlSW5mby5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIHdhbGxldF9hcHBfdmVyc2lvbjogdGhpcy5pbmplY3RlZFdhbGxldC5kZXZpY2VJbmZvLmFwcFZlcnNpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbm5lY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9jb25uZWN0KFBST1RPQ09MX1ZFUlNJT04sIG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXN0b3JlQ29ubmVjdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICBjb25zdCB0cmFjZUlkID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYWNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFVVSUR2NygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhgSW5qZWN0ZWQgUHJvdmlkZXIgcmVzdG9yaW5nIGNvbm5lY3Rpb24uLi5gKTtcbiAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLmFuYWx5dGljcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVtaXRKc0JyaWRnZUNhbGwoe1xuICAgICAgICAgICAgICAgICAgICBqc19icmlkZ2VfbWV0aG9kOiAncmVzdG9yZUNvbm5lY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZV9pZDogdHJhY2VJZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RFdmVudCA9IHlpZWxkIHRoaXMuaW5qZWN0ZWRXYWxsZXQucmVzdG9yZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAoX2MgPSB0aGlzLmFuYWx5dGljcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmVtaXRKc0JyaWRnZVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICAgICAganNfYnJpZGdlX21ldGhvZDogJ3Jlc3RvcmVDb25uZWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VfaWQ6IHRyYWNlSWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnSW5qZWN0ZWQgUHJvdmlkZXIgcmVzdG9yaW5nIGNvbm5lY3Rpb24gcmVzcG9uc2UnLCBjb25uZWN0RXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0RXZlbnQuZXZlbnQgPT09ICdjb25uZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ha2VTdWJzY3JpcHRpb25zKHsgdHJhY2VJZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbm5lY3RFdmVudCksIHsgdHJhY2VJZCB9KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0aW9uU3RvcmFnZS5yZW1vdmVDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAoX2QgPSB0aGlzLmFuYWx5dGljcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmVtaXRKc0JyaWRnZUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAganNfYnJpZGdlX21ldGhvZDogJ3Jlc3RvcmVDb25uZWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JfbWVzc2FnZTogU3RyaW5nKGUpLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZV9pZDogdHJhY2VJZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdGlvblN0b3JhZ2UucmVtb3ZlQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbG9zZUNvbm5lY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmxpc3RlblN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0ZWRXYWxsZXQuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2VBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB0cmFjZUlkID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYWNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFVVSUR2NygpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uUmVxdWVzdFNlbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uU3RvcmFnZS5yZW1vdmVDb25uZWN0aW9uKCkudGhlbihyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5qZWN0ZWRXYWxsZXQuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBvblJlcXVlc3RTZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ2Rpc2Nvbm5lY3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbXVxuICAgICAgICAgICAgICAgICAgICB9LCB7IG9uUmVxdWVzdFNlbnQsIHRyYWNlSWQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbG9zZUFsbExpc3RlbmVycygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmxpc3RlblN1YnNjcmlwdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgKF9hID0gdGhpcy51bnN1YnNjcmliZUNhbGxiYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgbGlzdGVuKGV2ZW50c0NhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2goZXZlbnRzQ2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4gKHRoaXMubGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMuZmlsdGVyKGxpc3RlbmVyID0+IGxpc3RlbmVyICE9PSBldmVudHNDYWxsYmFjaykpO1xuICAgIH1cbiAgICBzZW5kUmVxdWVzdChyZXF1ZXN0LCBvcHRpb25zT3JPblJlcXVlc3RTZW50KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSBkZXByZWNhdGVkIG1ldGhvZFxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlcXVlc3RTZW50ID0gb3B0aW9uc09yT25SZXF1ZXN0U2VudDtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnRyYWNlSWQgPSBVVUlEdjcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub25SZXF1ZXN0U2VudCA9IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IG51bGwgfHwgb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uc09yT25SZXF1ZXN0U2VudC5vblJlcXVlc3RTZW50O1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsID0gb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gbnVsbCB8fCBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zT3JPblJlcXVlc3RTZW50LnNpZ25hbDtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmF0dGVtcHRzID0gb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gbnVsbCB8fCBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zT3JPblJlcXVlc3RTZW50LmF0dGVtcHRzO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudHJhY2VJZCA9IChfYSA9IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IG51bGwgfHwgb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uc09yT25SZXF1ZXN0U2VudC50cmFjZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBVVUlEdjcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlkID0gKHlpZWxkIHRoaXMuY29ubmVjdGlvblN0b3JhZ2UuZ2V0TmV4dFJwY1JlcXVlc3RJZCgpKS50b1N0cmluZygpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0aW9uU3RvcmFnZS5pbmNyZWFzZU5leHRScGNSZXF1ZXN0SWQoKTtcbiAgICAgICAgICAgIGxvZ0RlYnVnKCdTZW5kIGluamVjdGVkLWJyaWRnZSByZXF1ZXN0OicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCksIHsgaWQgfSkpO1xuICAgICAgICAgICAgKF9iID0gdGhpcy5hbmFseXRpY3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5lbWl0SnNCcmlkZ2VDYWxsKHtcbiAgICAgICAgICAgICAgICBqc19icmlkZ2VfbWV0aG9kOiAnc2VuZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5pbmplY3RlZFdhbGxldC5zZW5kKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCksIHsgaWQgfSkpO1xuICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmFuYWx5dGljcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVtaXRKc0JyaWRnZVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICAgICAganNfYnJpZGdlX21ldGhvZDogJ3NlbmQnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ1dhbGxldCBtZXNzYWdlIHJlY2VpdmVkOicsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5hbmFseXRpY3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbWl0SnNCcmlkZ2VFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGpzX2JyaWRnZV9tZXRob2Q6ICdzZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JfbWVzc2FnZTogU3RyaW5nKGVycm9yKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25SZXF1ZXN0U2VudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwob3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2Nvbm5lY3QocHJvdG9jb2xWZXJzaW9uLCBtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICBjb25zdCB0cmFjZUlkID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYWNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFVVSUR2NygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhgSW5qZWN0ZWQgUHJvdmlkZXIgY29ubmVjdCByZXF1ZXN0OiBwcm90b2NvbFZlcnNpb246ICR7cHJvdG9jb2xWZXJzaW9ufSwgbWVzc2FnZTpgLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLmFuYWx5dGljcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVtaXRKc0JyaWRnZUNhbGwoe1xuICAgICAgICAgICAgICAgICAgICBqc19icmlkZ2VfbWV0aG9kOiAnY29ubmVjdCcsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlX2lkOiB0cmFjZUlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdEV2ZW50ID0geWllbGQgdGhpcy5pbmplY3RlZFdhbGxldC5jb25uZWN0KHByb3RvY29sVmVyc2lvbiwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgKF9jID0gdGhpcy5hbmFseXRpY3MpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5lbWl0SnNCcmlkZ2VSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgICAgIGpzX2JyaWRnZV9tZXRob2Q6ICdjb25uZWN0J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdJbmplY3RlZCBQcm92aWRlciBjb25uZWN0IHJlc3BvbnNlOicsIGNvbm5lY3RFdmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3RFdmVudC5ldmVudCA9PT0gJ2Nvbm5lY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMudXBkYXRlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ha2VTdWJzY3JpcHRpb25zKHsgdHJhY2VJZCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbm5lY3RFdmVudCksIHsgdHJhY2VJZCB9KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAoX2QgPSB0aGlzLmFuYWx5dGljcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmVtaXRKc0JyaWRnZUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAganNfYnJpZGdlX21ldGhvZDogJ2Nvbm5lY3QnLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcl9tZXNzYWdlOiBTdHJpbmcoZSksXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlX2lkOiB0cmFjZUlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ0luamVjdGVkIFByb3ZpZGVyIGNvbm5lY3QgZXJyb3I6JywgZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdEV2ZW50RXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiAnY29ubmVjdF9lcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29ubmVjdEV2ZW50RXJyb3IpLCB7IHRyYWNlSWQgfSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1ha2VTdWJzY3JpcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRoaXMubGlzdGVuU3Vic2NyaXB0aW9ucyA9IHRydWU7XG4gICAgICAgIChfYSA9IHRoaXMuYW5hbHl0aWNzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW1pdEpzQnJpZGdlQ2FsbCh7XG4gICAgICAgICAgICBqc19icmlkZ2VfbWV0aG9kOiAnbGlzdGVuJyxcbiAgICAgICAgICAgIHRyYWNlX2lkOiBvcHRpb25zLnRyYWNlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlQ2FsbGJhY2sgPSB0aGlzLmluamVjdGVkV2FsbGV0Lmxpc3RlbihlID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2VJZCA9IChfYSA9IGUudHJhY2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVVVJRHY3KCk7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ1dhbGxldCBtZXNzYWdlIHJlY2VpdmVkOicsIGUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpc3RlblN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGUpLCB7IHRyYWNlSWQgfSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGUuZXZlbnQgPT09ICdkaXNjb25uZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoeyB0cmFjZUlkIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKF9iID0gdGhpcy5hbmFseXRpY3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5lbWl0SnNCcmlkZ2VSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAganNfYnJpZGdlX21ldGhvZDogJ2xpc3RlbicsXG4gICAgICAgICAgICAgICAgdHJhY2VfaWQ6IG9wdGlvbnMudHJhY2VJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgKF9jID0gdGhpcy5hbmFseXRpY3MpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5lbWl0SnNCcmlkZ2VFcnJvcih7XG4gICAgICAgICAgICAgICAganNfYnJpZGdlX21ldGhvZDogJ2xpc3RlbicsXG4gICAgICAgICAgICAgICAgZXJyb3JfbWVzc2FnZTogU3RyaW5nKGVyciksXG4gICAgICAgICAgICAgICAgdHJhY2VfaWQ6IG9wdGlvbnMudHJhY2VJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlU2Vzc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblN0b3JhZ2Uuc3RvcmVDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6ICdpbmplY3RlZCcsXG4gICAgICAgICAgICBqc0JyaWRnZUtleTogdGhpcy5pbmplY3RlZFdhbGxldEtleSxcbiAgICAgICAgICAgIG5leHRScGNSZXF1ZXN0SWQ6IDBcbiAgICAgICAgfSk7XG4gICAgfVxufVxuSW5qZWN0ZWRQcm92aWRlci53aW5kb3cgPSBnZXRXaW5kb3coKTtcblxuY2xhc3MgQnJpZGdlQ29ubmVjdGlvblN0b3JhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHN0b3JhZ2UsIHdhbGxldHNMaXN0TWFuYWdlcikge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgICAgICB0aGlzLndhbGxldHNMaXN0TWFuYWdlciA9IHdhbGxldHNMaXN0TWFuYWdlcjtcbiAgICAgICAgdGhpcy5zdG9yZUtleSA9ICd0b24tY29ubmVjdC1zdG9yYWdlX2JyaWRnZS1jb25uZWN0aW9uJztcbiAgICB9XG4gICAgc3RvcmVDb25uZWN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLnR5cGUgPT09ICdpbmplY3RlZCcgfHwgY29ubmVjdGlvbi50eXBlID09PSAnd2FsbGV0LWNvbm5lY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmVLZXksIEpTT04uc3RyaW5naWZ5KGNvbm5lY3Rpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQZW5kaW5nQ29ubmVjdGlvbkh0dHAoY29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYXdTZXNzaW9uID0ge1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uS2V5UGFpcjogY29ubmVjdGlvbi5zZXNzaW9uLnNlc3Npb25DcnlwdG8uc3RyaW5naWZ5S2V5cGFpcigpLFxuICAgICAgICAgICAgICAgICAgICB3YWxsZXRQdWJsaWNLZXk6IGNvbm5lY3Rpb24uc2Vzc2lvbi53YWxsZXRQdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgICAgIGJyaWRnZVVybDogY29ubmVjdGlvbi5zZXNzaW9uLmJyaWRnZVVybFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3Q29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2h0dHAnLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0RXZlbnQ6IGNvbm5lY3Rpb24uY29ubmVjdEV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uOiByYXdTZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBsYXN0V2FsbGV0RXZlbnRJZDogY29ubmVjdGlvbi5sYXN0V2FsbGV0RXZlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJwY1JlcXVlc3RJZDogY29ubmVjdGlvbi5uZXh0UnBjUmVxdWVzdElkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yZUtleSwgSlNPTi5zdHJpbmdpZnkocmF3Q29ubmVjdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmF3Q29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaHR0cCcsXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvblNvdXJjZTogY29ubmVjdGlvbi5jb25uZWN0aW9uU291cmNlLFxuICAgICAgICAgICAgICAgIHNlc3Npb25DcnlwdG86IGNvbm5lY3Rpb24uc2Vzc2lvbkNyeXB0by5zdHJpbmdpZnlLZXlwYWlyKCksXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmVLZXksIEpTT04uc3RyaW5naWZ5KHJhd0Nvbm5lY3Rpb24pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZUNvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5zdG9yZUtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb25uZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZWQgPSB5aWVsZCB0aGlzLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JlS2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0b3JlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbi50eXBlID09PSAnaW5qZWN0ZWQnIHx8IGNvbm5lY3Rpb24udHlwZSA9PT0gJ3dhbGxldC1jb25uZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpc1BlbmRpbmdDb25uZWN0aW9uSHR0cFJhdyhjb25uZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uQ3J5cHRvID0gbmV3IFNlc3Npb25DcnlwdG8oY29ubmVjdGlvbi5zZXNzaW9uLnNlc3Npb25LZXlQYWlyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuYWN0dWFsaXplQnJpZGdlQ29ubmVjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaHR0cCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0RXZlbnQ6IGNvbm5lY3Rpb24uY29ubmVjdEV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFdhbGxldEV2ZW50SWQ6IGNvbm5lY3Rpb24ubGFzdFdhbGxldEV2ZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UnBjUmVxdWVzdElkOiBjb25uZWN0aW9uLm5leHRScGNSZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbkNyeXB0byxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmlkZ2VVcmw6IGNvbm5lY3Rpb24uc2Vzc2lvbi5icmlkZ2VVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FsbGV0UHVibGljS2V5OiBjb25uZWN0aW9uLnNlc3Npb24ud2FsbGV0UHVibGljS2V5XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNFeHBpcmVkUGVuZGluZ0Nvbm5lY3Rpb25IdHRwUmF3KGNvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucmVtb3ZlQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2h0dHAnLFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uQ3J5cHRvOiBuZXcgU2Vzc2lvbkNyeXB0byhjb25uZWN0aW9uLnNlc3Npb25DcnlwdG8pLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uU291cmNlOiBjb25uZWN0aW9uLmNvbm5lY3Rpb25Tb3VyY2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdFcnJvciByZXRyaWV2aW5nIGNvbm5lY3Rpb24nLCBlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0SHR0cENvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geWllbGQgdGhpcy5nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoIWNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdUcnlpbmcgdG8gcmVhZCBIVFRQIGNvbm5lY3Rpb24gc291cmNlIHdoaWxlIG5vdGhpbmcgaXMgc3RvcmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbi50eXBlICE9PSAnaHR0cCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKGBUcnlpbmcgdG8gcmVhZCBIVFRQIGNvbm5lY3Rpb24gc291cmNlIHdoaWxlICR7Y29ubmVjdGlvbi50eXBlfSBjb25uZWN0aW9uIGlzIHN0b3JlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRIdHRwUGVuZGluZ0Nvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geWllbGQgdGhpcy5nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoIWNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdUcnlpbmcgdG8gcmVhZCBIVFRQIGNvbm5lY3Rpb24gc291cmNlIHdoaWxlIG5vdGhpbmcgaXMgc3RvcmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbi50eXBlICE9PSAnaHR0cCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKGBUcnlpbmcgdG8gcmVhZCBIVFRQIGNvbm5lY3Rpb24gc291cmNlIHdoaWxlICR7Y29ubmVjdGlvbi50eXBlfSBjb25uZWN0aW9uIGlzIHN0b3JlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1BlbmRpbmdDb25uZWN0aW9uSHR0cChjb25uZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ1RyeWluZyB0byByZWFkIEhUVFAtcGVuZGluZyBjb25uZWN0aW9uIHdoaWxlIGh0dHAgY29ubmVjdGlvbiBpcyBzdG9yZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0SW5qZWN0ZWRDb25uZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHlpZWxkIHRoaXMuZ2V0Q29ubmVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKCFjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignVHJ5aW5nIHRvIHJlYWQgSW5qZWN0ZWQgYnJpZGdlIGNvbm5lY3Rpb24gc291cmNlIHdoaWxlIG5vdGhpbmcgaXMgc3RvcmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGNvbm5lY3Rpb24gPT09IG51bGwgfHwgY29ubmVjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29ubmVjdGlvbi50eXBlKSAhPT0gJ2luamVjdGVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoYFRyeWluZyB0byByZWFkIEluamVjdGVkIGJyaWRnZSBjb25uZWN0aW9uIHNvdXJjZSB3aGlsZSAke2Nvbm5lY3Rpb24udHlwZX0gY29ubmVjdGlvbiBpcyBzdG9yZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0V2FsbGV0Q29ubmVjdENvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geWllbGQgdGhpcy5nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoIWNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdUcnlpbmcgdG8gcmVhZCB3YWxsZXQgY29ubmVjdCBicmlkZ2UgY29ubmVjdGlvbiBzb3VyY2Ugd2hpbGUgbm90aGluZyBpcyBzdG9yZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoY29ubmVjdGlvbiA9PT0gbnVsbCB8fCBjb25uZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25uZWN0aW9uLnR5cGUpICE9PSAnd2FsbGV0LWNvbm5lY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcihgVHJ5aW5nIHRvIHJlYWQgd2FsbGV0IGNvbm5lY3QgYnJpZGdlIGNvbm5lY3Rpb24gc291cmNlIHdoaWxlICR7Y29ubmVjdGlvbi50eXBlfSBjb25uZWN0aW9uIGlzIHN0b3JlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdG9yZWRDb25uZWN0aW9uVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZCA9IHlpZWxkIHRoaXMuc3RvcmFnZS5nZXRJdGVtKHRoaXMuc3RvcmVLZXkpO1xuICAgICAgICAgICAgaWYgKCFzdG9yZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBKU09OLnBhcnNlKHN0b3JlZCk7XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbi50eXBlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RvcmVMYXN0V2FsbGV0RXZlbnRJZChpZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHlpZWxkIHRoaXMuZ2V0Q29ubmVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24gJiYgY29ubmVjdGlvbi50eXBlID09PSAnaHR0cCcgJiYgIWlzUGVuZGluZ0Nvbm5lY3Rpb25IdHRwKGNvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5sYXN0V2FsbGV0RXZlbnRJZCA9IGlkO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3JlQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldExhc3RXYWxsZXRFdmVudElkKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHlpZWxkIHRoaXMuZ2V0Q29ubmVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24gJiYgJ2xhc3RXYWxsZXRFdmVudElkJyBpbiBjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24ubGFzdFdhbGxldEV2ZW50SWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5jcmVhc2VOZXh0UnBjUmVxdWVzdElkKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHlpZWxkIHRoaXMuZ2V0Q29ubmVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24gJiYgJ25leHRScGNSZXF1ZXN0SWQnIGluIGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0SWQgPSBjb25uZWN0aW9uLm5leHRScGNSZXF1ZXN0SWQgfHwgMDtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLm5leHRScGNSZXF1ZXN0SWQgPSBsYXN0SWQgKyAxO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3JlQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldE5leHRScGNSZXF1ZXN0SWQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geWllbGQgdGhpcy5nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbiAmJiAnbmV4dFJwY1JlcXVlc3RJZCcgaW4gY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLm5leHRScGNSZXF1ZXN0SWQgfHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWN0dWFsaXplQnJpZGdlQ29ubmVjdGlvbihjb25uZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFwcE5hbWUgPSBjb25uZWN0aW9uLmNvbm5lY3RFdmVudC5wYXlsb2FkLmRldmljZS5hcHBOYW1lO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhbGxldCA9IHlpZWxkIHRoaXMud2FsbGV0c0xpc3RNYW5hZ2VyLmdldFJlbW90ZVdhbGxldChhcHBOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAod2FsbGV0LmJyaWRnZVVybCA9PT0gY29ubmVjdGlvbi5zZXNzaW9uLmJyaWRnZVVybCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYWN0dWFsaXplZENvbm5lY3Rpb24gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbm5lY3Rpb24pLCB7IHNlc3Npb246IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29ubmVjdGlvbi5zZXNzaW9uKSwgeyBicmlkZ2VVcmw6IHdhbGxldC5icmlkZ2VVcmwgfSkgfSk7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5zdG9yZUNvbm5lY3Rpb24oYWN0dWFsaXplZENvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY3R1YWxpemVkQ29ubmVjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdGYWlsZWQgdG8gYWN0dWFsaXplIGJyaWRnZSBjb25uZWN0aW9uJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogRGVmYXVsdCBzdG9yYWdlIHRvIHNhdmUgcHJvdG9jb2wgZGF0YSwgdXNlcyBgbG9jYWxTdG9yYWdlYCBpZiBpdCBpcyBhdmFpbGFibGUuIEluIFNhZmFyaSdzIHByaXZhdGUgbW9kZSwgaXQgdXNlcyBgSW5NZW1vcnlTdG9yYWdlYC4gSW4gTm9kZS5qcywgaXQgdGhyb3dzIGFuIGVycm9yLlxuICovXG5jbGFzcyBEZWZhdWx0U3RvcmFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubG9jYWxTdG9yYWdlID0gdHJ5R2V0TG9jYWxTdG9yYWdlKCk7XG4gICAgfVxuICAgIGdldEl0ZW0oa2V5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlSXRlbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgV2FsbGV0SW5mb2AgaXMgYFdhbGxldEluZm9JbmplY3RhYmxlYCBhbmQgYFdhbGxldEluZm9gIGlzIGluamVjdGVkIHRvIHRoZSBjdXJyZW50IHdlYnBhZ2UgKGB3YWxsZXRJbmZvLmluamVjdGVkID09PSB0cnVlYCkuXG4gKiBAcGFyYW0gdmFsdWUgV2FsbGV0SW5mbyB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gaXNXYWxsZXRJbmZvQ3VycmVudGx5SW5qZWN0ZWQodmFsdWUpIHtcbiAgICByZXR1cm4gaXNXYWxsZXRJbmZvSW5qZWN0YWJsZSh2YWx1ZSkgJiYgdmFsdWUuaW5qZWN0ZWQ7XG59XG4vKipcbiAqIENoZWNrcyBpZiBgV2FsbGV0SW5mb2AgaXMgYFdhbGxldEluZm9JbmplY3RhYmxlYCBhbmQgZEFwcCBpcyBvcGVuZWQgaW5zaWRlIHRoaXMgd2FsbGV0J3MgYnJvd3Nlci5cbiAqIEBwYXJhbSB2YWx1ZSBXYWxsZXRJbmZvIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBpc1dhbGxldEluZm9DdXJyZW50bHlFbWJlZGRlZCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1dhbGxldEluZm9DdXJyZW50bHlJbmplY3RlZCh2YWx1ZSkgJiYgdmFsdWUuZW1iZWRkZWQ7XG59XG4vKipcbiAqIENoZWNrcyBpZiBgV2FsbGV0SW5mb2AgaXMgYFdhbGxldEluZm9JbmplY3RlZGAsIGJ1dCBkb2Vzbid0IGNoZWNrIGlmIGl0IGlzIGluamVjdGVkIHRvIHRoZSBwYWdlIG9yIG5vdC5cbiAqIEBwYXJhbSB2YWx1ZSBXYWxsZXRJbmZvIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBpc1dhbGxldEluZm9JbmplY3RhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICdqc0JyaWRnZUtleScgaW4gdmFsdWU7XG59XG4vKipcbiAqIENoZWNrcyBpZiBgV2FsbGV0SW5mb2AgaXMgYFdhbGxldEluZm9SZW1vdGVgLlxuICogQHBhcmFtIHZhbHVlIFdhbGxldEluZm8gdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIGlzV2FsbGV0SW5mb1JlbW90ZSh2YWx1ZSkge1xuICAgIHJldHVybiAnYnJpZGdlVXJsJyBpbiB2YWx1ZTtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIGBpc1dhbGxldEluZm9JbmplY3RhYmxlYCBvciBgaXNXYWxsZXRJbmZvQ3VycmVudGx5SW5qZWN0ZWRgIGluc3RlYWQuXG4gKiBAcGFyYW0gdmFsdWUgV2FsbGV0SW5mbyB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gaXNXYWxsZXRJbmZvSW5qZWN0ZWQodmFsdWUpIHtcbiAgICByZXR1cm4gJ2pzQnJpZGdlS2V5JyBpbiB2YWx1ZTtcbn1cblxuY29uc3QgRkFMTEJBQ0tfV0FMTEVUU19MSVNUID0gW1xuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICd0ZWxlZ3JhbS13YWxsZXQnLFxuICAgICAgICBuYW1lOiAnV2FsbGV0JyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3dhbGxldC50Zy9pbWFnZXMvbG9nby0yODgucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly93YWxsZXQudGcvJyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vdC5tZS93YWxsZXQ/YXR0YWNoPXdhbGxldCcsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vd2FsbGV0Ym90Lm1lL3RvbmNvbm5lY3QtYnJpZGdlL2JyaWRnZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2lvcycsICdhbmRyb2lkJywgJ21hY29zJywgJ3dpbmRvd3MnLCAnbGludXgnXSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogMjU1LFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NpZ25EYXRhJyxcbiAgICAgICAgICAgICAgICB0eXBlczogWyd0ZXh0JywgJ2JpbmFyeScsICdjZWxsJ11cbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ3RvbmtlZXBlcicsXG4gICAgICAgIG5hbWU6ICdUb25rZWVwZXInLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vdG9ua2VlcGVyLmNvbS9hc3NldHMvdG9uY29ubmVjdC1pY29uLnBuZycsXG4gICAgICAgIHRvbmRuczogJ3RvbmtlZXBlci50b24nLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL3RvbmtlZXBlci5jb20nLFxuICAgICAgICB1bml2ZXJzYWxfdXJsOiAnaHR0cHM6Ly9hcHAudG9ua2VlcGVyLmNvbS90b24tY29ubmVjdCcsXG4gICAgICAgIGRlZXBMaW5rOiAndG9ua2VlcGVyLXRjOi8vJyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9icmlkZ2UudG9uYXBpLmlvL2JyaWRnZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzJyxcbiAgICAgICAgICAgICAgICBrZXk6ICd0b25rZWVwZXInXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydpb3MnLCAnYW5kcm9pZCcsICdjaHJvbWUnLCAnZmlyZWZveCcsICdtYWNvcyddLFxuICAgICAgICBmZWF0dXJlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VzOiAyNTUsXG4gICAgICAgICAgICAgICAgZXh0cmFDdXJyZW5jeVN1cHBvcnRlZDogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2lnbkRhdGEnLFxuICAgICAgICAgICAgICAgIHR5cGVzOiBbJ3RleHQnLCAnYmluYXJ5JywgJ2NlbGwnXVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAnbXl0b253YWxsZXQnLFxuICAgICAgICBuYW1lOiAnTXlUb25XYWxsZXQnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vc3RhdGljLm15dG9ud2FsbGV0LmlvL2ljb24tMjU2LnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vbXl0b253YWxsZXQuaW8nLFxuICAgICAgICB1bml2ZXJzYWxfdXJsOiAnaHR0cHM6Ly9jb25uZWN0Lm15dG9ud2FsbGV0Lm9yZycsXG4gICAgICAgIGRlZXBMaW5rOiAnbXl0b253YWxsZXQtdGM6Ly8nLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnanMnLFxuICAgICAgICAgICAgICAgIGtleTogJ215dG9ud2FsbGV0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3NlJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL3RvbmNvbm5lY3RicmlkZ2UubXl0b253YWxsZXQub3JnL2JyaWRnZS8nXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydjaHJvbWUnLCAnd2luZG93cycsICdtYWNvcycsICdsaW51eCcsICdpb3MnLCAnYW5kcm9pZCcsICdmaXJlZm94J10sXG4gICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgbWF4TWVzc2FnZXM6IDI1NSxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2lnbkRhdGEnLFxuICAgICAgICAgICAgICAgIHR5cGVzOiBbJ3RleHQnLCAnYmluYXJ5JywgJ2NlbGwnXVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAndG9uaHViJyxcbiAgICAgICAgbmFtZTogJ1Rvbmh1YicsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly90b25odWIuY29tL3RvbmNvbm5lY3RfbG9nby5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL3Rvbmh1Yi5jb20nLFxuICAgICAgICB1bml2ZXJzYWxfdXJsOiAnaHR0cHM6Ly90b25odWIuY29tL3Rvbi1jb25uZWN0JyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzJyxcbiAgICAgICAgICAgICAgICBrZXk6ICd0b25odWInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vY29ubmVjdC50b25odWJhcGkuY29tL3RvbmNvbm5lY3QnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydpb3MnLCAnYW5kcm9pZCddLFxuICAgICAgICBmZWF0dXJlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VzOiAyNTUsXG4gICAgICAgICAgICAgICAgZXh0cmFDdXJyZW5jeVN1cHBvcnRlZDogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2lnbkRhdGEnLFxuICAgICAgICAgICAgICAgIHR5cGVzOiBbJ3RleHQnLCAnYmluYXJ5JywgJ2NlbGwnXVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAnYml0Z2V0VG9uV2FsbGV0JyxcbiAgICAgICAgbmFtZTogJ0JpdGdldCBXYWxsZXQnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9iaXRnZXR3YWxsZXQvZG93bmxvYWQvcmVmcy9oZWFkcy9tYWluL2xvZ28vcG5nL2JpdGdldF93YWxsZXRfbG9nb18yODhfbWluaS5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL3dlYjMuYml0Z2V0LmNvbScsXG4gICAgICAgIGRlZXBMaW5rOiAnYml0a2VlcDovLycsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdqcycsXG4gICAgICAgICAgICAgICAga2V5OiAnYml0Z2V0VG9uV2FsbGV0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3NlJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL3Rvbi1jb25uZWN0LWJyaWRnZS5iZ3dhcGkuaW8vYnJpZGdlJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnaW9zJywgJ2FuZHJvaWQnLCAnY2hyb21lJ10sXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL2JrY29kZS52aXAvdG9uLWNvbm5lY3QnLFxuICAgICAgICBmZWF0dXJlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VzOiA0LFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdva3hNaW5pV2FsbGV0JyxcbiAgICAgICAgbmFtZTogJ09LWCBNaW5pIFdhbGxldCcsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9zdGF0aWMub2t4LmNvbS9jZG4vYXNzZXRzL2ltZ3MvMjQxMS84QkUxQTRBNDM0RDhGNThBLnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vd3d3Lm9reC5jb20vd2ViMycsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL3QubWUvT0tYX1dBTExFVF9CT1Q/YXR0YWNoPXdhbGxldCcsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vd3d3Lm9reC5jb20vdG9uYnJpZGdlL2Rpc2NvdmVyL3JwYy9icmlkZ2UnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydpb3MnLCAnYW5kcm9pZCcsICdtYWNvcycsICd3aW5kb3dzJywgJ2xpbnV4J10sXG4gICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgbWF4TWVzc2FnZXM6IDQsXG4gICAgICAgICAgICAgICAgZXh0cmFDdXJyZW5jeVN1cHBvcnRlZDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ2JpbmFuY2VXZWIzVG9uV2FsbGV0JyxcbiAgICAgICAgbmFtZTogJ0JpbmFuY2UgV2FsbGV0JyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3B1YmxpYy5ibmJzdGF0aWMuY29tL3N0YXRpYy9iaW5hbmNlLXczdy90b24tcHJvdmlkZXIvYmluYW5jZXczdy5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL3d3dy5iaW5hbmNlLmNvbS9lbi93ZWIzd2FsbGV0JyxcbiAgICAgICAgZGVlcExpbms6ICdibmM6Ly9hcHAuYmluYW5jZS5jb20vY2VkZWZpL3Rvbi1jb25uZWN0JyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdiaW5hbmNldzN3J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3NlJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL3dhbGxldC5iaW5hbmNlLmNvbS90b25icmlkZ2UvYnJpZGdlJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnaW9zJywgJ2FuZHJvaWQnLCAnbWFjb3MnLCAnd2luZG93cycsICdsaW51eCddLFxuICAgICAgICB1bml2ZXJzYWxfdXJsOiAnaHR0cHM6Ly9hcHAuYmluYW5jZS5jb20vY2VkZWZpL3Rvbi1jb25uZWN0JyxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogNCxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAnZmludG9waW8tdGcnLFxuICAgICAgICBuYW1lOiAnRmludG9waW8nLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9maW50b3Bpby90b24tcHViL3JlZnMvaGVhZHMvbWFpbi9sb2dvcy90b25jb25uZWN0LWljb24ucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly9maW50b3Bpby5jb20nLFxuICAgICAgICB1bml2ZXJzYWxfdXJsOiAnaHR0cHM6Ly90Lm1lL2ZpbnRvcGlvP2F0dGFjaD13YWxsZXQnLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3NlJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL3dhbGxldC1icmlkZ2UuZmludG9waW8uY29tL2JyaWRnZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2lvcycsICdhbmRyb2lkJywgJ21hY29zJywgJ3dpbmRvd3MnLCAnbGludXgnXSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogNCxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAnb2t4VG9uV2FsbGV0JyxcbiAgICAgICAgbmFtZTogJ09LWCBXYWxsZXQnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vc3RhdGljLm9reC5jb20vY2RuL2Fzc2V0cy9pbWdzLzI0Ny81OEU2M0ZFQTQ3QTJCN0Q3LnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vd3d3Lm9reC5jb20vd2ViMycsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL3d3dy5va3guY29tL2Rvd25sb2FkP2FwcGVuZFF1ZXJ5PXRydWUmZGVlcGxpbms9b2t4Oi8vd2ViMy93YWxsZXQvdG9uY29ubmVjdCcsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdqcycsXG4gICAgICAgICAgICAgICAga2V5OiAnb2t4VG9uV2FsbGV0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3NlJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL3d3dy5va3guY29tL3RvbmJyaWRnZS9kaXNjb3Zlci9ycGMvYnJpZGdlJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnY2hyb21lJywgJ3NhZmFyaScsICdmaXJlZm94JywgJ2lvcycsICdhbmRyb2lkJ10sXG4gICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgbWF4TWVzc2FnZXM6IDQsXG4gICAgICAgICAgICAgICAgZXh0cmFDdXJyZW5jeVN1cHBvcnRlZDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ2hvdCcsXG4gICAgICAgIG5hbWU6ICdIT1QnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9ob3QtZGFvL21lZGlhL21haW4vbG9nby5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL2hvdC1sYWJzLm9yZy8nLFxuICAgICAgICB1bml2ZXJzYWxfdXJsOiAnaHR0cHM6Ly90Lm1lL2hlcmV3YWxsZXRib3Q/YXR0YWNoPXdhbGxldCcsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vc3NlLWJyaWRnZS5ob3QtbGFicy5vcmcnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdqcycsXG4gICAgICAgICAgICAgICAga2V5OiAnaG90V2FsbGV0J1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnaW9zJywgJ2FuZHJvaWQnLCAnbWFjb3MnLCAnd2luZG93cycsICdsaW51eCddLFxuICAgICAgICBmZWF0dXJlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VzOiA0LFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdieWJpdFRvbldhbGxldCcsXG4gICAgICAgIG5hbWU6ICdCeWJpdCBXYWxsZXQnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9ieWJpdC13ZWIzL2J5Yml0LXdlYjMuZ2l0aHViLmlvL21haW4vZG9jcy9pbWFnZXMvYnliaXQtbG9nby5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL3d3dy5ieWJpdC5jb20vd2ViMycsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL2FwcC5ieWJpdC5jb20vdG9uLWNvbm5lY3QnLFxuICAgICAgICBkZWVwTGluazogJ2J5Yml0YXBwOi8vJyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdieWJpdFRvbldhbGxldCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9hcGktbm9kZS5ieWJpdC5jb20vc3BvdC9hcGkvd2ViMy9icmlkZ2UvdG9uL2JyaWRnZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2lvcycsICdhbmRyb2lkJywgJ2Nocm9tZSddLFxuICAgICAgICBmZWF0dXJlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VzOiA0LFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdkZXdhbGxldCcsXG4gICAgICAgIG5hbWU6ICdEZVdhbGxldCcsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2RlbGFiLXRlYW0vbWFuaWZlc3RzLWltYWdlcy9tYWluL1dhbGxldEF2YXRhci5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL2RlbGFid2FsbGV0LmNvbScsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL3QubWUvZGV3YWxsZXQ/YXR0YWNoPXdhbGxldCcsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vYnJpZGdlLmRld2FsbGV0LnByby9icmlkZ2UnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydpb3MnLCAnYW5kcm9pZCcsICdtYWNvcycsICd3aW5kb3dzJywgJ2xpbnV4J10sXG4gICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgbWF4TWVzc2FnZXM6IDQsXG4gICAgICAgICAgICAgICAgZXh0cmFDdXJyZW5jeVN1cHBvcnRlZDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ3NhZmVwYWx3YWxsZXQnLFxuICAgICAgICBuYW1lOiAnU2FmZVBhbCcsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9zLnB2Y2xpcGluZy5jb20vd2ViL3B1YmxpY19pbWFnZS9TYWZlUGFsX3gyODgucG5nJyxcbiAgICAgICAgdG9uZG5zOiAnJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly93d3cuc2FmZXBhbC5jb20nLFxuICAgICAgICB1bml2ZXJzYWxfdXJsOiAnaHR0cHM6Ly9saW5rLnNhZmVwYWwuaW8vdG9uLWNvbm5lY3QnLFxuICAgICAgICBkZWVwTGluazogJ3NhZmVwYWwtdGM6Ly8nLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3NlJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL3Rvbi1icmlkZ2Uuc2FmZXBhbC5jb20vdG9uYnJpZGdlL3YxL2JyaWRnZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdzYWZlcGFsd2FsbGV0J1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnaW9zJywgJ2FuZHJvaWQnLCAnY2hyb21lJywgJ2ZpcmVmb3gnXSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogMSxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAnR2F0ZVdhbGxldCcsXG4gICAgICAgIG5hbWU6ICdHYXRlV2FsbGV0JyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL2ltZy5nYXRlZGF0YWltZy5jb20vcHJkLW9yZGluYWwtaW1ncy8wMzZmMDdiYjg3MzA3MTZlL2dhdGVpby0wOTI1LnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vd3d3LmdhdGUuaW8vJyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdnYXRldG9ud2FsbGV0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3NlJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL2RhcHAuZ2F0ZWlvLnNlcnZpY2VzL3RvbmJyaWRnZV9hcGkvYnJpZGdlL3YxJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnaW9zJywgJ2FuZHJvaWQnXSxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vZ2F0ZS5vbmVsaW5rLm1lL0hsczAvd2ViMz9nYXRlX3dlYjNfd2FsbGV0X3VuaXZlcnNhbF90eXBlPXRvbl9jb25uZWN0JyxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogNCxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAnb3Blbm1hc2snLFxuICAgICAgICBuYW1lOiAnT3Blbk1hc2snLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9PcGVuUHJvZHVjdC9vcGVubWFzay1leHRlbnNpb24vbWFpbi9wdWJsaWMvb3Blbm1hc2stbG9nby0yODgucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly93d3cub3Blbm1hc2suYXBwLycsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdqcycsXG4gICAgICAgICAgICAgICAga2V5OiAnb3Blbm1hc2snXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydjaHJvbWUnXSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogNCxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAnQml0Z2V0V2ViMycsXG4gICAgICAgIG5hbWU6ICdCaXRnZXRXZWIzJyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL2ltZy5iaXRnZXRpbWcuY29tL2ltYWdlL3RoaXJkLzE3MzE2MzgwNTk3OTUucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAn4oCLaHR0cHM6Ly93d3cuYml0Z2V0LmNvbScsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL3QubWUvQml0Z2V0T2ZmaWNpYWxCb3Q/YXR0YWNoPXdhbGxldCcsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vdG9uLWNvbm5lY3QtYnJpZGdlLmJnd2FwaS5pby9icmlkZ2UnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydpb3MnLCAnYW5kcm9pZCcsICd3aW5kb3dzJywgJ21hY29zJywgJ2xpbnV4J10sXG4gICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgbWF4TWVzc2FnZXM6IDQsXG4gICAgICAgICAgICAgICAgZXh0cmFDdXJyZW5jeVN1cHBvcnRlZDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ3h0b253YWxsZXQnLFxuICAgICAgICBuYW1lOiAnWFRPTldhbGxldCcsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly94dG9ud2FsbGV0LmNvbS9hc3NldHMvaW1nL2ljb24tMjU2LWJhY2sucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly94dG9ud2FsbGV0LmNvbScsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdqcycsXG4gICAgICAgICAgICAgICAga2V5OiAneHRvbndhbGxldCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2Nocm9tZScsICdmaXJlZm94J10sXG4gICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgbWF4TWVzc2FnZXM6IDEsXG4gICAgICAgICAgICAgICAgZXh0cmFDdXJyZW5jeVN1cHBvcnRlZDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ3RvbndhbGxldCcsXG4gICAgICAgIG5hbWU6ICdUT04gV2FsbGV0JyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3dhbGxldC50b24ub3JnL2Fzc2V0cy91aS9xci1sb2dvLnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vY2hyb21lLmdvb2dsZS5jb20vd2Vic3RvcmUvZGV0YWlsL3Rvbi13YWxsZXQvbnBocGxwZ29ha2hoamNoa2tobWlnZ2FraWpua2hmbmQnLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnanMnLFxuICAgICAgICAgICAgICAgIGtleTogJ3RvbndhbGxldCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2Nocm9tZSddLFxuICAgICAgICBmZWF0dXJlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VzOiA0LFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdiaXRnZXRXYWxsZXRMaXRlJyxcbiAgICAgICAgbmFtZTogJ0JpdGdldCBXYWxsZXQgTGl0ZScsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2JpdGdldHdhbGxldC9kb3dubG9hZC9yZWZzL2hlYWRzL21haW4vbG9nby9wbmcvYml0Z2V0X3dhbGxldF9saXRlX2xvZ29fMjg4LnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vd2ViMy5iaXRnZXQuY29tJyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vdC5tZS9CaXRnZXRXYWxsZXRfVEdCb3Q/YXR0YWNoPXdhbGxldCcsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vdG9uLWNvbm5lY3QtYnJpZGdlLmJnd2FwaS5pby9icmlkZ2UnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydpb3MnLCAnYW5kcm9pZCcsICdtYWNvcycsICd3aW5kb3dzJywgJ2xpbnV4J10sXG4gICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgbWF4TWVzc2FnZXM6IDI1NSxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAndG9tb1dhbGxldCcsXG4gICAgICAgIG5hbWU6ICdUb21vIFdhbGxldCcsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9wdWIudG9tby5pbmMvbG9nby5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL3d3dy50b21vLmluYy8nLFxuICAgICAgICB1bml2ZXJzYWxfdXJsOiAnaHR0cHM6Ly90Lm1lL3RvbW93YWxsZXRib3Q/YXR0YWNoPXdhbGxldCcsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vZ28tYnJpZGdlLnRvbW8uaW5jL2JyaWRnZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2lvcycsICdhbmRyb2lkJywgJ21hY29zJywgJ3dpbmRvd3MnLCAnbGludXgnXSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogNCxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAnbWlyYWlhcHAtdGcnLFxuICAgICAgICBuYW1lOiAnTWlyYWkgTWluaSBBcHAnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vY2RuLm1pcmFpbGFicy5jby9taXJhaWh1Yi9taXJhaWFwcC10Zy1pY29uLTI4OC5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL21pcmFpLmFwcCcsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL3QubWUvTWlyYWlBcHBCb3Q/YXR0YWNoPXdhbGxldCcsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vYnJpZGdlLm1pcmFpLmFwcCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2lvcycsICdhbmRyb2lkJywgJ21hY29zJywgJ3dpbmRvd3MnLCAnbGludXgnXSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogMjU1LFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTaWduRGF0YScsXG4gICAgICAgICAgICAgICAgdHlwZXM6IFsndGV4dCcsICdiaW5hcnknLCAnY2VsbCddXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdBcmNoaXRlYy50b24nLFxuICAgICAgICBuYW1lOiAnQXJjaGl0ZWMudG9uJyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vQXJjaGl0ZWMtVG9uL3dhbGxldC10bWEvcmVmcy9oZWFkcy9kZXYvcHVibGljL2ltYWdlcy9hcmN3YWxsZXRfbG9nby5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL2FyY2hpdGVjdG9uLnRlY2gnLFxuICAgICAgICB1bml2ZXJzYWxfdXJsOiAnaHR0cHM6Ly90Lm1lL2FyY2hpdGVjX3Rvbl9ib3Q/YXR0YWNoPXdhbGxldCcsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vdGMuYXJjaGl0ZWN0b24uc3UvYnJpZGdlJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnaW9zJywgJ2FuZHJvaWQnLCAnbWFjb3MnLCAnd2luZG93cycsICdsaW51eCddLFxuICAgICAgICBmZWF0dXJlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VzOiAyNTUsXG4gICAgICAgICAgICAgICAgZXh0cmFDdXJyZW5jeVN1cHBvcnRlZDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ3Rva2VucG9ja2V0JyxcbiAgICAgICAgbmFtZTogJ1Rva2VuUG9ja2V0JyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL2hrLnRwc3RhdGljLm5ldC9sb2dvL3Rva2VucG9ja2V0LnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vd3d3LnRva2VucG9ja2V0LnBybycsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL3RwLWxhYi50cHRvb2wucHJvL3Rvbi1jb25uZWN0LycsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdqcycsXG4gICAgICAgICAgICAgICAga2V5OiAndG9rZW5wb2NrZXQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vdG9uLWNvbm5lY3QubXl0b2tlbnBvY2tldC52aXAvYnJpZGdlJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnaW9zJywgJ2FuZHJvaWQnXSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogNCxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAndXh1eVdhbGxldCcsXG4gICAgICAgIG5hbWU6ICdVWFVZIFdhbGxldCcsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9jaGFpbi1jZG4udXh1eS5jb20vbG9nby9zcXVhcmVfMjg4LnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vZG9jcy51eHV5LmNvbScsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL3QubWUvVVhVWWJvdD9hdHRhY2g9d2FsbGV0JyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9icmlkZ2UudXh1eS5tZS9icmlkZ2UnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydpb3MnLCAnYW5kcm9pZCcsICdtYWNvcycsICd3aW5kb3dzJywgJ2xpbnV4J10sXG4gICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgbWF4TWVzc2FnZXM6IDQsXG4gICAgICAgICAgICAgICAgZXh0cmFDdXJyZW5jeVN1cHBvcnRlZDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ3RvbmtlZXBlci1wcm8nLFxuICAgICAgICBuYW1lOiAnVG9ua2VlcGVyIFBybycsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly90b25rZWVwZXIuY29tL2Fzc2V0cy90b25jb25uZWN0LWljb24tcHJvLnBuZycsXG4gICAgICAgIHRvbmRuczogJ3RvbmtlZXBlci50b24nLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL3RvbmtlZXBlci5jb20vcHJvJyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vYXBwLnRvbmtlZXBlci5jb20vcHJvL3Rvbi1jb25uZWN0JyxcbiAgICAgICAgZGVlcExpbms6ICd0b25rZWVwZXItcHJvLXRjOi8vJyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9icmlkZ2UudG9uYXBpLmlvL2JyaWRnZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2lvcycsICdtYWNvcycsICd3aW5kb3dzJywgJ2xpbnV4J10sXG4gICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgbWF4TWVzc2FnZXM6IDI1NSxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTaWduRGF0YScsXG4gICAgICAgICAgICAgICAgdHlwZXM6IFsndGV4dCcsICdiaW5hcnknLCAnY2VsbCddXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICduaWNlZ3JhbVdhbGxldCcsXG4gICAgICAgIG5hbWU6ICdOaWNlZ3JhbSBXYWxsZXQnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vc3RhdGljLm5pY2VncmFtLmFwcC9pY29uLnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vbmljZWdyYW0uYXBwJyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vbmljZWdyYW0uYXBwL3RjJyxcbiAgICAgICAgZGVlcExpbms6ICduaWNlZ3JhbS10YzovLycsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vdGMubmljZWdyYW0uYXBwL2JyaWRnZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzJyxcbiAgICAgICAgICAgICAgICBrZXk6ICduaWNlZ3JhbVdhbGxldCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2lvcycsICdhbmRyb2lkJ10sXG4gICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgbWF4TWVzc2FnZXM6IDI1NSxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAnZWNob29vVG9uV2FsbGV0JyxcbiAgICAgICAgbmFtZTogJ0VjaG9vb1dhbGxldCcsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9jZG4uZWNob29vLnh5ei9mcm9udC1lbmQvc291cmNlL2ltYWdlcy9sb2dvL2VjaG9vby10b24ucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly93d3cuZWNob29vLnh5eicsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL3d3dy5lY2hvb28ueHl6L3Rvbi1jb25uZWN0JyxcbiAgICAgICAgZGVlcExpbms6ICdlY2hvb286Ly8nLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnanMnLFxuICAgICAgICAgICAgICAgIGtleTogJ2VjaG9vb1RvbldhbGxldCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly90b24tY29ubmVjdC1icmlkZ2UuZWNob29vLmxpbmsvYnJpZGdlJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnaW9zJywgJ2FuZHJvaWQnXSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogMjU1LFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdibGl0endhbGxldCcsXG4gICAgICAgIG5hbWU6ICdCTElUWiB3YWxsZXQnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vYmxpdHp3YWxsZXQuY2ZkL3dhbGxldC9wdWJsaWMvbG9nby5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL2JsaXR6d2FsbGV0LmNmZCcsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL3QubWUvYmxpdHpfd2FsbGV0X2JvdD9hdHRhY2g9d2FsbGV0JyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9ibGl0endhbGxldC5jZmQvYnJpZGdlLydcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2lvcycsICdhbmRyb2lkJywgJ21hY29zJywgJ3dpbmRvd3MnLCAnbGludXgnXSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogNCxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAna29sb1dlYjNXYWxsZXQnLFxuICAgICAgICBuYW1lOiAnS29sbycsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL29uaWRldjEvdGMtYXNzZXRzL3JlZnMvaGVhZHMvbWFpbi9rb2xvX2xvZ29fMjg4LnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8va29sby54eXonLFxuICAgICAgICB1bml2ZXJzYWxfdXJsOiAnaHR0cHM6Ly90Lm1lL2tvbG8/YXR0YWNoPXdhbGxldCcsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vd2ViMy1icmlkZ2Uua29sby5pbi9icmlkZ2UnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydpb3MnLCAnYW5kcm9pZCcsICdtYWNvcycsICd3aW5kb3dzJywgJ2xpbnV4J10sXG4gICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgbWF4TWVzc2FnZXM6IDI1NSxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAnaW1Ub2tlbicsXG4gICAgICAgIG5hbWU6ICdpbVRva2VuJyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL2F3cy12Mi1jZG4udG9rZW4uaW0vb3JiaXQvdG9rZW4tdjIvaWNvbnMvbG9nby10b24tY29ubmVjdC5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL3Rva2VuLmltJyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vY29ubmVjdC50b2tlbi5pbS9saW5rL3Rvbi1jb25uZWN0JyxcbiAgICAgICAgZGVlcExpbms6ICdpbXRva2VudjI6Ly9saW5rL3Rvbi1jb25uZWN0JyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9jb25uZWN0LnRva2VuLmltL3RvbmJyaWRnZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdpbVRva2VuJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnaW9zJywgJ2FuZHJvaWQnXSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogMjU1LFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdjYWN0dXNsaW5rJyxcbiAgICAgICAgbmFtZTogJ0NhY3R1cyBMaW5rJyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL2Rvd25sb2Fkcy5teWNhY3R1cy5jb20vMjg4X2NhY3R1c19saW5rLnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vd3d3Lm15Y2FjdHVzLmNvbS9kZWZpLWNvbm5lY3RvcicsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdqcycsXG4gICAgICAgICAgICAgICAga2V5OiAnY2FjdHVzbGlua190b24nXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydjaHJvbWUnXSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogNCxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2lnbkRhdGEnLFxuICAgICAgICAgICAgICAgIHR5cGVzOiBbJ3RleHQnLCAnYmluYXJ5J11cbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ29uZWtleScsXG4gICAgICAgIG5hbWU6ICdPbmVLZXknLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vdW5pLm9uZWtleS1hc3NldC5jb20vc3RhdGljL2xvZ28vb25la2V5LXgyODgucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly9vbmVrZXkuc28nLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnanMnLFxuICAgICAgICAgICAgICAgIGtleTogJ29uZWtleVRvbldhbGxldCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2Nocm9tZSddLFxuICAgICAgICBmZWF0dXJlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VzOiA0LFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9XG5dO1xuXG5sZXQgcWFNb2RlRW5hYmxlZCA9IGZhbHNlO1xubGV0IGJhbm5lck9ic2VydmVyID0gbnVsbDtcbmZ1bmN0aW9uIGVuYWJsZVFhTW9kZSgpIHtcbiAgICBxYU1vZGVFbmFibGVkID0gdHJ1ZTtcbiAgICBjb25zb2xlLndhcm4oJ/CfmqggUUEgTW9kZSBlbmFibGVkIC0gdmFsaWRhdGlvbiBpcyBkaXNhYmxlZC4gVGhpcyBpcyB1bnNhZmUgZm9yIHByb2R1Y3Rpb24hJyk7XG4gICAgc2hvd1FhTW9kZUJhbm5lcigpO1xuICAgIHN0YXJ0QmFubmVyT2JzZXJ2ZXIoKTtcbiAgICBhZGRRYU1vZGVTdHlsZXMoKTtcbn1cbmZ1bmN0aW9uIGlzUWFNb2RlRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gcWFNb2RlRW5hYmxlZDtcbn1cbmZ1bmN0aW9uIHNob3dRYU1vZGVCYW5uZXIoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgZXhpc3RpbmdCYW5uZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndG9uLWNvbm5lY3QtcWEtYmFubmVyJyk7XG4gICAgaWYgKGV4aXN0aW5nQmFubmVyKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgYmFubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYmFubmVyLmlkID0gJ3Rvbi1jb25uZWN0LXFhLWJhbm5lcic7XG4gICAgYmFubmVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDkwZGVnLCAjZmY2YjZiLCAjZmY4ZThlKTtcbiAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICBwYWRkaW5nOiAxMnB4IDIwcHg7XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgJ1NlZ29lIFVJJywgUm9ib3RvLCBzYW5zLXNlcmlmO1xuICAgICAgICBmb250LXdlaWdodDogNjAwO1xuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIHotaW5kZXg6IDk5OTk5OTtcbiAgICAgICAgYm94LXNoYWRvdzogMCAycHggOHB4IHJnYmEoMCwwLDAsMC4yKTtcbiAgICAgICAgYW5pbWF0aW9uOiBzbGlkZURvd24gMC4zcyBlYXNlLW91dDtcbiAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIGA7XG4gICAgYmFubmVyLmlubmVySFRNTCA9IGBcbiAgICAgICAg8J+aqCBRQSBNb2RlIEFjdGl2ZSAtIFZhbGlkYXRpb24gRGlzYWJsZWQgKFVuc2FmZSBmb3IgUHJvZHVjdGlvbilcbiAgICBgO1xuICAgIC8vIEFkZCBDU1MgYW5pbWF0aW9uXG4gICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlLnRleHRDb250ZW50ID0gYFxuICAgICAgICBAa2V5ZnJhbWVzIHNsaWRlRG93biB7XG4gICAgICAgICAgICBmcm9tIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMDAlKTsgfVxuICAgICAgICAgICAgdG8geyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7IH1cbiAgICAgICAgfVxuICAgIGA7XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChiYW5uZXIpO1xuICAgIGFkZFFhTW9kZVN0eWxlcygpO1xufVxuZnVuY3Rpb24gYWRkUWFNb2RlU3R5bGVzKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGV4aXN0aW5nU3R5bGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndG9uLWNvbm5lY3QtcWEtbW9kZS1zdHlsZXMnKTtcbiAgICBpZiAoZXhpc3RpbmdTdHlsZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZS5pZCA9ICd0b24tY29ubmVjdC1xYS1tb2RlLXN0eWxlcyc7XG4gICAgc3R5bGUudGV4dENvbnRlbnQgPSBgXG4gICAgICAgIGJvZHkucWEtbW9kZS1hY3RpdmUge1xuICAgICAgICAgICAgcGFkZGluZy10b3A6IDQ4cHggIWltcG9ydGFudDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgYm9keS5xYS1tb2RlLWFjdGl2ZSBoZWFkZXIge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogNDhweCAhaW1wb3J0YW50O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBib2R5LnFhLW1vZGUtYWN0aXZlIC5xYS1tb2RlLWNvbnRyb2wge1xuICAgICAgICAgICAgdG9wOiAxMjhweCAhaW1wb3J0YW50O1xuICAgICAgICB9XG4gICAgYDtcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ3FhLW1vZGUtYWN0aXZlJyk7XG59XG5mdW5jdGlvbiBzdGFydEJhbm5lck9ic2VydmVyKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCBiYW5uZXJPYnNlcnZlcilcbiAgICAgICAgcmV0dXJuO1xuICAgIGJhbm5lck9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgbXV0YXRpb25zLmZvckVhY2gobXV0YXRpb24gPT4ge1xuICAgICAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAgICAgbXV0YXRpb24ucmVtb3ZlZE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5pZCA9PT0gJ3Rvbi1jb25uZWN0LXFhLWJhbm5lcicgJiYgcWFNb2RlRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUUEgTW9kZSBiYW5uZXIgd2FzIHJlbW92ZWQsIHJlc3RvcmluZy4uLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2hvd1FhTW9kZUJhbm5lcigpLCAxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZWxlbWVudC5pZCA9PT0gJ3Rvbi1jb25uZWN0LXFhLW1vZGUtc3R5bGVzJyAmJiBxYU1vZGVFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdRQSBNb2RlIHN0eWxlcyB3ZXJlIHJlbW92ZWQsIHJlc3RvcmluZy4uLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gYWRkUWFNb2RlU3R5bGVzKCksIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgYmFubmVyT2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5ib2R5LCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogZmFsc2VcbiAgICB9KTtcbiAgICBiYW5uZXJPYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmhlYWQsIHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiBmYWxzZVxuICAgIH0pO1xufVxuXG5jbGFzcyBXYWxsZXRzTGlzdE1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLndhbGxldHNMaXN0RFRPQ2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLndhbGxldHNMaXN0RFRPQ2FjaGVDcmVhdGlvblRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgIGlmIChpc1FhTW9kZUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy53YWxsZXRzTGlzdFNvdXJjZSA9XG4gICAgICAgICAgICAgICAgJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS90b24tY29ubmVjdC93YWxsZXRzLWxpc3Qtc3RhZ2luZy9yZWZzL2hlYWRzL21haW4vd2FsbGV0cy12Mi5qc29uJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud2FsbGV0c0xpc3RTb3VyY2UgPVxuICAgICAgICAgICAgICAgIChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53YWxsZXRzTGlzdFNvdXJjZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2h0dHBzOi8vY29uZmlnLnRvbi5vcmcvd2FsbGV0cy12Mi5qc29uJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlVFRMTXMgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FjaGVUVExNcztcbiAgICAgICAgdGhpcy5vbkRvd25sb2FkRHVyYXRpb25NZWFzdXJlZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vbkRvd25sb2FkRHVyYXRpb25NZWFzdXJlZDtcbiAgICB9XG4gICAgZ2V0V2FsbGV0cygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IFt3YWxsZXRzTGlzdERUTywgY3VycmVudGx5SW5qZWN0ZWRXYWxsZXRzXSA9IHlpZWxkIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICB0aGlzLmZldGNoV2FsbGV0c0xpc3REVE8oKSxcbiAgICAgICAgICAgICAgICB0aGlzLmdldEN1cnJlbnRseUluamVjdGVkV2FsbGV0cygpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lcmdlV2FsbGV0c0xpc3RzKHRoaXMud2FsbGV0Q29uZmlnRFRPTGlzdFRvV2FsbGV0Q29uZmlnTGlzdCh3YWxsZXRzTGlzdERUTyksIGN1cnJlbnRseUluamVjdGVkV2FsbGV0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRFbWJlZGRlZFdhbGxldCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHdhbGxldHNMaXN0ID0geWllbGQgdGhpcy5nZXRXYWxsZXRzKCk7XG4gICAgICAgICAgICBjb25zdCBlbWJlZGRlZFdhbGxldHMgPSB3YWxsZXRzTGlzdC5maWx0ZXIoaXNXYWxsZXRJbmZvQ3VycmVudGx5RW1iZWRkZWQpO1xuICAgICAgICAgICAgcmV0dXJuIGVtYmVkZGVkV2FsbGV0cy5sZW5ndGggPT09IDEgPyBlbWJlZGRlZFdhbGxldHNbMF0gOiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmV0Y2hXYWxsZXRzTGlzdERUTygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhY2hlVFRMTXMgJiZcbiAgICAgICAgICAgICAgICB0aGlzLndhbGxldHNMaXN0RFRPQ2FjaGVDcmVhdGlvblRpbWVzdGFtcCAmJlxuICAgICAgICAgICAgICAgIERhdGUubm93KCkgPiB0aGlzLndhbGxldHNMaXN0RFRPQ2FjaGVDcmVhdGlvblRpbWVzdGFtcCArIHRoaXMuY2FjaGVUVExNcykge1xuICAgICAgICAgICAgICAgIHRoaXMud2FsbGV0c0xpc3REVE9DYWNoZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMud2FsbGV0c0xpc3REVE9DYWNoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMud2FsbGV0c0xpc3REVE9DYWNoZSA9IHRoaXMuZmV0Y2hXYWxsZXRzTGlzdEZyb21Tb3VyY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLndhbGxldHNMaXN0RFRPQ2FjaGVcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndhbGxldHNMaXN0RFRPQ2FjaGVDcmVhdGlvblRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53YWxsZXRzTGlzdERUT0NhY2hlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53YWxsZXRzTGlzdERUT0NhY2hlQ3JlYXRpb25UaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FsbGV0c0xpc3REVE9DYWNoZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFJlbW90ZVdhbGxldChhcHBOYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXRzTGlzdCA9IHlpZWxkIHRoaXMuZ2V0V2FsbGV0cygpO1xuICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gd2FsbGV0c0xpc3QuZmluZCh3YWxsZXQgPT4gd2FsbGV0LmFwcE5hbWUgPT09IGFwcE5hbWUpO1xuICAgICAgICAgICAgaWYgKCF3YWxsZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKGBXYWxsZXQgaW5mbyBub3QgZm91bmQgZm9yIGFwcE5hbWU6IFwiJHthcHBOYW1lfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzV2FsbGV0SW5mb1JlbW90ZSh3YWxsZXQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcihgV2FsbGV0IFwiJHthcHBOYW1lfVwiIGlzIG5vdCByZW1vdGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3YWxsZXQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmZXRjaFdhbGxldHNMaXN0RnJvbVNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBsZXQgd2FsbGV0c0xpc3QgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YWxsZXRzUmVzcG9uc2UgPSB5aWVsZCBmZXRjaCh0aGlzLndhbGxldHNMaXN0U291cmNlKTtcbiAgICAgICAgICAgICAgICB3YWxsZXRzTGlzdCA9IHlpZWxkIHdhbGxldHNSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHdhbGxldHNMaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmV0Y2hXYWxsZXRzRXJyb3IoJ1dyb25nIHdhbGxldHMgbGlzdCBmb3JtYXQsIHdhbGxldHMgbGlzdCBtdXN0IGJlIGFuIGFycmF5LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB3cm9uZ0Zvcm1hdFdhbGxldHMgPSB3YWxsZXRzTGlzdC5maWx0ZXIod2FsbGV0ID0+ICF0aGlzLmlzQ29ycmVjdFdhbGxldENvbmZpZ0RUTyh3YWxsZXQpKTtcbiAgICAgICAgICAgICAgICBpZiAod3JvbmdGb3JtYXRXYWxsZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFcnJvcihgV2FsbGV0KHMpICR7d3JvbmdGb3JtYXRXYWxsZXRzXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKHdhbGxldCA9PiAod2FsbGV0ID09PSBudWxsIHx8IHdhbGxldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2FsbGV0Lm5hbWUpIHx8ICd1bmtub3duJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfSBjb25maWcgZm9ybWF0IGlzIHdyb25nLiBUaGV5IHdlcmUgcmVtb3ZlZCBmcm9tIHRoZSB3YWxsZXRzIGxpc3QuYCk7XG4gICAgICAgICAgICAgICAgICAgIHdhbGxldHNMaXN0ID0gd2FsbGV0c0xpc3QuZmlsdGVyKHdhbGxldCA9PiB0aGlzLmlzQ29ycmVjdFdhbGxldENvbmZpZ0RUTyh3YWxsZXQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gTWF0aC5yb3VuZChlbmRUaW1lIC0gc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLm9uRG93bmxvYWREdXJhdGlvbk1lYXN1cmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBkdXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZ0Vycm9yKGUpO1xuICAgICAgICAgICAgICAgIHdhbGxldHNMaXN0ID0gRkFMTEJBQ0tfV0FMTEVUU19MSVNUO1xuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMub25Eb3dubG9hZER1cmF0aW9uTWVhc3VyZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKHRoaXMsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2FsbGV0c0xpc3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDdXJyZW50bHlJbmplY3RlZFdhbGxldHMoKSB7XG4gICAgICAgIGlmICghaXNRYU1vZGVFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEluamVjdGVkUHJvdmlkZXIuZ2V0Q3VycmVudGx5SW5qZWN0ZWRXYWxsZXRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdhbGxldENvbmZpZ0RUT0xpc3RUb1dhbGxldENvbmZpZ0xpc3Qod2FsbGV0Q29uZmlnRFRPKSB7XG4gICAgICAgIHJldHVybiB3YWxsZXRDb25maWdEVE8ubWFwKHdhbGxldENvbmZpZ0RUTyA9PiB7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogd2FsbGV0Q29uZmlnRFRPLm5hbWUsXG4gICAgICAgICAgICAgICAgYXBwTmFtZTogd2FsbGV0Q29uZmlnRFRPLmFwcF9uYW1lLFxuICAgICAgICAgICAgICAgIGltYWdlVXJsOiB3YWxsZXRDb25maWdEVE8uaW1hZ2UsXG4gICAgICAgICAgICAgICAgYWJvdXRVcmw6IHdhbGxldENvbmZpZ0RUTy5hYm91dF91cmwsXG4gICAgICAgICAgICAgICAgdG9uZG5zOiB3YWxsZXRDb25maWdEVE8udG9uZG5zLFxuICAgICAgICAgICAgICAgIHBsYXRmb3Jtczogd2FsbGV0Q29uZmlnRFRPLnBsYXRmb3JtcyxcbiAgICAgICAgICAgICAgICBmZWF0dXJlczogd2FsbGV0Q29uZmlnRFRPLmZlYXR1cmVzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2FsbGV0Q29uZmlnRFRPLmJyaWRnZS5mb3JFYWNoKGJyaWRnZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGJyaWRnZS50eXBlID09PSAnc3NlJykge1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXRDb25maWcuYnJpZGdlVXJsID0gYnJpZGdlLnVybDtcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0Q29uZmlnLnVuaXZlcnNhbExpbmsgPVxuICAgICAgICAgICAgICAgICAgICAgICAgd2FsbGV0Q29uZmlnRFRPLnVuaXZlcnNhbF91cmw7XG4gICAgICAgICAgICAgICAgICAgIHdhbGxldENvbmZpZy5kZWVwTGluayA9IHdhbGxldENvbmZpZ0RUTy5kZWVwTGluaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJyaWRnZS50eXBlID09PSAnanMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGpzQnJpZGdlS2V5ID0gYnJpZGdlLmtleTtcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0Q29uZmlnLmpzQnJpZGdlS2V5ID0ganNCcmlkZ2VLZXk7XG4gICAgICAgICAgICAgICAgICAgIHdhbGxldENvbmZpZy5pbmplY3RlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBJbmplY3RlZFByb3ZpZGVyLmlzV2FsbGV0SW5qZWN0ZWQoanNCcmlkZ2VLZXkpO1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXRDb25maWcuZW1iZWRkZWQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgSW5qZWN0ZWRQcm92aWRlci5pc0luc2lkZVdhbGxldEJyb3dzZXIoanNCcmlkZ2VLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHdhbGxldENvbmZpZztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1lcmdlV2FsbGV0c0xpc3RzKGxpc3QxLCBsaXN0Mikge1xuICAgICAgICBjb25zdCBuYW1lcyA9IG5ldyBTZXQobGlzdDEuY29uY2F0KGxpc3QyKS5tYXAoaXRlbSA9PiBpdGVtLm5hbWUpKTtcbiAgICAgICAgcmV0dXJuIFsuLi5uYW1lcy52YWx1ZXMoKV0ubWFwKG5hbWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGlzdDFJdGVtID0gbGlzdDEuZmluZChpdGVtID0+IGl0ZW0ubmFtZSA9PT0gbmFtZSk7XG4gICAgICAgICAgICBjb25zdCBsaXN0Mkl0ZW0gPSBsaXN0Mi5maW5kKGl0ZW0gPT4gaXRlbS5uYW1lID09PSBuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChsaXN0MUl0ZW0gJiYgT2JqZWN0LmFzc2lnbih7fSwgbGlzdDFJdGVtKSkpLCAobGlzdDJJdGVtICYmIE9iamVjdC5hc3NpZ24oe30sIGxpc3QySXRlbSkpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgaXNDb3JyZWN0V2FsbGV0Q29uZmlnRFRPKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUgfHwgISh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5zTmFtZSA9ICduYW1lJyBpbiB2YWx1ZTtcbiAgICAgICAgY29uc3QgY29udGFpbnNBcHBOYW1lID0gJ2FwcF9uYW1lJyBpbiB2YWx1ZTtcbiAgICAgICAgY29uc3QgY29udGFpbnNJbWFnZSA9ICdpbWFnZScgaW4gdmFsdWU7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5zQWJvdXQgPSAnYWJvdXRfdXJsJyBpbiB2YWx1ZTtcbiAgICAgICAgY29uc3QgY29udGFpbnNQbGF0Zm9ybXMgPSAncGxhdGZvcm1zJyBpbiB2YWx1ZTtcbiAgICAgICAgaWYgKCFjb250YWluc05hbWUgfHxcbiAgICAgICAgICAgICFjb250YWluc0ltYWdlIHx8XG4gICAgICAgICAgICAhY29udGFpbnNBYm91dCB8fFxuICAgICAgICAgICAgIWNvbnRhaW5zUGxhdGZvcm1zIHx8XG4gICAgICAgICAgICAhY29udGFpbnNBcHBOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZS5wbGF0Zm9ybXMgfHxcbiAgICAgICAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlLnBsYXRmb3JtcykgfHxcbiAgICAgICAgICAgICF2YWx1ZS5wbGF0Zm9ybXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoJ2JyaWRnZScgaW4gdmFsdWUpIHx8XG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZS5icmlkZ2UpIHx8XG4gICAgICAgICAgICAhdmFsdWUuYnJpZGdlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJyaWRnZSA9IHZhbHVlLmJyaWRnZTtcbiAgICAgICAgaWYgKGJyaWRnZS5zb21lKGl0ZW0gPT4gIWl0ZW0gfHwgdHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnIHx8ICEoJ3R5cGUnIGluIGl0ZW0pKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNzZUJyaWRnZSA9IGJyaWRnZS5maW5kKGl0ZW0gPT4gaXRlbS50eXBlID09PSAnc3NlJyk7XG4gICAgICAgIGlmIChzc2VCcmlkZ2UpIHtcbiAgICAgICAgICAgIGlmICghKHR5cGVvZiBzc2VCcmlkZ2UgPT09ICdvYmplY3QnICYmICd1cmwnIGluIHNzZUJyaWRnZSkgfHxcbiAgICAgICAgICAgICAgICAhc3NlQnJpZGdlLnVybCB8fFxuICAgICAgICAgICAgICAgICF2YWx1ZS51bml2ZXJzYWxfdXJsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGpzQnJpZGdlID0gYnJpZGdlLmZpbmQoaXRlbSA9PiBpdGVtLnR5cGUgPT09ICdqcycpO1xuICAgICAgICBpZiAoanNCcmlkZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNCcmlkZ2UgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgISgna2V5JyBpbiBqc0JyaWRnZSkgfHxcbiAgICAgICAgICAgICAgICAhanNCcmlkZ2Uua2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tTZW5kVHJhbnNhY3Rpb25TdXBwb3J0KGZlYXR1cmVzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3VwcG9ydHNEZXByZWNhdGVkU2VuZFRyYW5zYWN0aW9uRmVhdHVyZSA9IGZlYXR1cmVzLmluY2x1ZGVzKCdTZW5kVHJhbnNhY3Rpb24nKTtcbiAgICBjb25zdCBzZW5kVHJhbnNhY3Rpb25GZWF0dXJlID0gZmluZEZlYXR1cmUoZmVhdHVyZXMsICdTZW5kVHJhbnNhY3Rpb24nKTtcbiAgICBjb25zdCByZXF1aXJlZEZlYXR1cmUgPSB7XG4gICAgICAgIG1pbk1lc3NhZ2VzOiBvcHRpb25zLnJlcXVpcmVkTWVzc2FnZXNOdW1iZXIsXG4gICAgICAgIGV4dHJhQ3VycmVuY3lSZXF1aXJlZDogb3B0aW9ucy5yZXF1aXJlRXh0cmFDdXJyZW5jaWVzXG4gICAgfTtcbiAgICBpZiAoIXN1cHBvcnRzRGVwcmVjYXRlZFNlbmRUcmFuc2FjdGlvbkZlYXR1cmUgJiYgIXNlbmRUcmFuc2FjdGlvbkZlYXR1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdFN1cHBvcnRGZWF0dXJlRXJyb3IoXCJXYWxsZXQgZG9lc24ndCBzdXBwb3J0IFNlbmRUcmFuc2FjdGlvbiBmZWF0dXJlLlwiLCB7XG4gICAgICAgICAgICBjYXVzZTogeyByZXF1aXJlZEZlYXR1cmU6IHsgZmVhdHVyZU5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLCB2YWx1ZTogcmVxdWlyZWRGZWF0dXJlIH0gfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmVxdWlyZUV4dHJhQ3VycmVuY2llcykge1xuICAgICAgICBpZiAoIXNlbmRUcmFuc2FjdGlvbkZlYXR1cmUgfHwgIXNlbmRUcmFuc2FjdGlvbkZlYXR1cmUuZXh0cmFDdXJyZW5jeVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdFN1cHBvcnRGZWF0dXJlRXJyb3IoYFdhbGxldCBpcyBub3QgYWJsZSB0byBoYW5kbGUgc3VjaCBTZW5kVHJhbnNhY3Rpb24gcmVxdWVzdC4gRXh0cmEgY3VycmVuY2llcyBzdXBwb3J0IGlzIHJlcXVpcmVkLmAsIHtcbiAgICAgICAgICAgICAgICBjYXVzZToge1xuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZEZlYXR1cmU6IHsgZmVhdHVyZU5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLCB2YWx1ZTogcmVxdWlyZWRGZWF0dXJlIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VuZFRyYW5zYWN0aW9uRmVhdHVyZSAmJiBzZW5kVHJhbnNhY3Rpb25GZWF0dXJlLm1heE1lc3NhZ2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHNlbmRUcmFuc2FjdGlvbkZlYXR1cmUubWF4TWVzc2FnZXMgPCBvcHRpb25zLnJlcXVpcmVkTWVzc2FnZXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RTdXBwb3J0RmVhdHVyZUVycm9yKGBXYWxsZXQgaXMgbm90IGFibGUgdG8gaGFuZGxlIHN1Y2ggU2VuZFRyYW5zYWN0aW9uIHJlcXVlc3QuIE1heCBzdXBwb3J0IG1lc3NhZ2VzIG51bWJlciBpcyAke3NlbmRUcmFuc2FjdGlvbkZlYXR1cmUubWF4TWVzc2FnZXN9LCBidXQgJHtvcHRpb25zLnJlcXVpcmVkTWVzc2FnZXNOdW1iZXJ9IGlzIHJlcXVpcmVkLmAsIHtcbiAgICAgICAgICAgICAgICBjYXVzZToge1xuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZEZlYXR1cmU6IHsgZmVhdHVyZU5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLCB2YWx1ZTogcmVxdWlyZWRGZWF0dXJlIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ1dhcm5pbmcoXCJDb25uZWN0ZWQgd2FsbGV0IGRpZG4ndCBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IG1heCBhbGxvd2VkIG1lc3NhZ2VzIGluIHRoZSBTZW5kVHJhbnNhY3Rpb24gcmVxdWVzdC4gUmVxdWVzdCBtYXkgYmUgcmVqZWN0ZWQgYnkgdGhlIHdhbGxldC5cIik7XG59XG5mdW5jdGlvbiBjaGVja1NpZ25EYXRhU3VwcG9ydChmZWF0dXJlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHNpZ25EYXRhRmVhdHVyZSA9IGZlYXR1cmVzLmZpbmQoZmVhdHVyZSA9PiBmZWF0dXJlICYmIHR5cGVvZiBmZWF0dXJlID09PSAnb2JqZWN0JyAmJiBmZWF0dXJlLm5hbWUgPT09ICdTaWduRGF0YScpO1xuICAgIGlmICghc2lnbkRhdGFGZWF0dXJlKSB7XG4gICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RTdXBwb3J0RmVhdHVyZUVycm9yKFwiV2FsbGV0IGRvZXNuJ3Qgc3VwcG9ydCBTaWduRGF0YSBmZWF0dXJlLlwiLCB7XG4gICAgICAgICAgICBjYXVzZToge1xuICAgICAgICAgICAgICAgIHJlcXVpcmVkRmVhdHVyZToge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlTmFtZTogJ1NpZ25EYXRhJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHsgdHlwZXM6IG9wdGlvbnMucmVxdWlyZWRUeXBlcyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgdW5zdXBwb3J0ZWRUeXBlcyA9IG9wdGlvbnMucmVxdWlyZWRUeXBlcy5maWx0ZXIocmVxdWlyZWRUeXBlID0+ICFzaWduRGF0YUZlYXR1cmUudHlwZXMuaW5jbHVkZXMocmVxdWlyZWRUeXBlKSk7XG4gICAgaWYgKHVuc3VwcG9ydGVkVHlwZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RTdXBwb3J0RmVhdHVyZUVycm9yKGBXYWxsZXQgZG9lc24ndCBzdXBwb3J0IHJlcXVpcmVkIFNpZ25EYXRhIHR5cGVzOiAke3Vuc3VwcG9ydGVkVHlwZXMuam9pbignLCAnKX0uYCwge1xuICAgICAgICAgICAgY2F1c2U6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZEZlYXR1cmU6IHsgZmVhdHVyZU5hbWU6ICdTaWduRGF0YScsIHZhbHVlOiB7IHR5cGVzOiB1bnN1cHBvcnRlZFR5cGVzIH0gfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1JlcXVpcmVkV2FsbGV0RmVhdHVyZXMoZmVhdHVyZXMsIHdhbGxldHNSZXF1aXJlZEZlYXR1cmVzKSB7XG4gICAgaWYgKHR5cGVvZiB3YWxsZXRzUmVxdWlyZWRGZWF0dXJlcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHsgc2VuZFRyYW5zYWN0aW9uLCBzaWduRGF0YSB9ID0gd2FsbGV0c1JlcXVpcmVkRmVhdHVyZXM7XG4gICAgaWYgKHNlbmRUcmFuc2FjdGlvbikge1xuICAgICAgICBjb25zdCBmZWF0dXJlID0gZmluZEZlYXR1cmUoZmVhdHVyZXMsICdTZW5kVHJhbnNhY3Rpb24nKTtcbiAgICAgICAgaWYgKCFmZWF0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGVja1NlbmRUcmFuc2FjdGlvbihmZWF0dXJlLCBzZW5kVHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNpZ25EYXRhKSB7XG4gICAgICAgIGNvbnN0IGZlYXR1cmUgPSBmaW5kRmVhdHVyZShmZWF0dXJlcywgJ1NpZ25EYXRhJyk7XG4gICAgICAgIGlmICghZmVhdHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hlY2tTaWduRGF0YShmZWF0dXJlLCBzaWduRGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGZpbmRGZWF0dXJlKGZlYXR1cmVzLCByZXF1aXJlZEZlYXR1cmVOYW1lKSB7XG4gICAgcmV0dXJuIGZlYXR1cmVzLmZpbmQoZiA9PiBmICYmIHR5cGVvZiBmID09PSAnb2JqZWN0JyAmJiBmLm5hbWUgPT09IHJlcXVpcmVkRmVhdHVyZU5hbWUpO1xufVxuZnVuY3Rpb24gY2hlY2tTZW5kVHJhbnNhY3Rpb24oZmVhdHVyZSwgcmVxdWlyZWRGZWF0dXJlKSB7XG4gICAgY29uc3QgY29ycmVjdE1lc3NhZ2VzTnVtYmVyID0gcmVxdWlyZWRGZWF0dXJlLm1pbk1lc3NhZ2VzID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgcmVxdWlyZWRGZWF0dXJlLm1pbk1lc3NhZ2VzIDw9IGZlYXR1cmUubWF4TWVzc2FnZXM7XG4gICAgY29uc3QgY29ycmVjdEV4dHJhQ3VycmVuY3kgPSAhcmVxdWlyZWRGZWF0dXJlLmV4dHJhQ3VycmVuY3lSZXF1aXJlZCB8fCBmZWF0dXJlLmV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ7XG4gICAgcmV0dXJuICEhKGNvcnJlY3RNZXNzYWdlc051bWJlciAmJiBjb3JyZWN0RXh0cmFDdXJyZW5jeSk7XG59XG5mdW5jdGlvbiBjaGVja1NpZ25EYXRhKGZlYXR1cmUsIHJlcXVpcmVkRmVhdHVyZSkge1xuICAgIHJldHVybiByZXF1aXJlZEZlYXR1cmUudHlwZXMuZXZlcnkocmVxdWlyZWRUeXBlID0+IGZlYXR1cmUudHlwZXMuaW5jbHVkZXMocmVxdWlyZWRUeXBlKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVxdWVzdCB2ZXJzaW9uIGV2ZW50LlxuICovXG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0VmVyc2lvbkV2ZW50KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdyZXF1ZXN0LXZlcnNpb24nXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgcmVzcG9uc2UgdmVyc2lvbiBldmVudC5cbiAqIEBwYXJhbSB2ZXJzaW9uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlVmVyc2lvbkV2ZW50KHZlcnNpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAncmVzcG9uc2UtdmVyc2lvbicsXG4gICAgICAgIHZlcnNpb246IHZlcnNpb25cbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSB2ZXJzaW9uIGluZm8uXG4gKiBAcGFyYW0gdmVyc2lvblxuICovXG5mdW5jdGlvbiBjcmVhdGVWZXJzaW9uSW5mbyh2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9uX2Nvbm5lY3Rfc2RrX2xpYjogdmVyc2lvbi50b25fY29ubmVjdF9zZGtfbGliLFxuICAgICAgICB0b25fY29ubmVjdF91aV9saWI6IHZlcnNpb24udG9uX2Nvbm5lY3RfdWlfbGliXG4gICAgfTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uSW5mbyh2ZXJzaW9uLCB3YWxsZXQsIHNlc3Npb25JbmZvKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbDtcbiAgICBjb25zdCBpc1RvblByb29mID0gKChfYSA9IHdhbGxldCA9PT0gbnVsbCB8fCB3YWxsZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdhbGxldC5jb25uZWN0SXRlbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b25Qcm9vZikgJiYgJ3Byb29mJyBpbiB3YWxsZXQuY29ubmVjdEl0ZW1zLnRvblByb29mO1xuICAgIGNvbnN0IGF1dGhUeXBlID0gaXNUb25Qcm9vZiA/ICd0b25fcHJvb2YnIDogJ3Rvbl9hZGRyJztcbiAgICByZXR1cm4ge1xuICAgICAgICB3YWxsZXRfYWRkcmVzczogKF9jID0gKF9iID0gd2FsbGV0ID09PSBudWxsIHx8IHdhbGxldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2FsbGV0LmFjY291bnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hZGRyZXNzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBudWxsLFxuICAgICAgICB3YWxsZXRfc3RhdGVfaW5pdDogKF9kID0gd2FsbGV0ID09PSBudWxsIHx8IHdhbGxldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2FsbGV0LmFjY291bnQud2FsbGV0U3RhdGVJbml0KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBudWxsLFxuICAgICAgICB3YWxsZXRfdHlwZTogKF9lID0gd2FsbGV0ID09PSBudWxsIHx8IHdhbGxldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2FsbGV0LmRldmljZS5hcHBOYW1lKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBudWxsLFxuICAgICAgICB3YWxsZXRfdmVyc2lvbjogKF9mID0gd2FsbGV0ID09PSBudWxsIHx8IHdhbGxldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2FsbGV0LmRldmljZS5hcHBWZXJzaW9uKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBudWxsLFxuICAgICAgICBhdXRoX3R5cGU6IGF1dGhUeXBlLFxuICAgICAgICBjdXN0b21fZGF0YTogT2JqZWN0LmFzc2lnbih7IGNsaWVudF9pZDogKF9nID0gc2Vzc2lvbkluZm8gPT09IG51bGwgfHwgc2Vzc2lvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb25JbmZvLmNsaWVudElkKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBudWxsLCB3YWxsZXRfaWQ6IChfaCA9IHNlc3Npb25JbmZvID09PSBudWxsIHx8IHNlc3Npb25JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uSW5mby53YWxsZXRJZCkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogbnVsbCwgY2hhaW5faWQ6IChfayA9IChfaiA9IHdhbGxldCA9PT0gbnVsbCB8fCB3YWxsZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdhbGxldC5hY2NvdW50KSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ouY2hhaW4pICE9PSBudWxsICYmIF9rICE9PSB2b2lkIDAgPyBfayA6IG51bGwsIHByb3ZpZGVyOiAoX2wgPSB3YWxsZXQgPT09IG51bGwgfHwgd2FsbGV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3YWxsZXQucHJvdmlkZXIpICE9PSBudWxsICYmIF9sICE9PSB2b2lkIDAgPyBfbCA6IG51bGwgfSwgY3JlYXRlVmVyc2lvbkluZm8odmVyc2lvbikpXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgY29ubmVjdGlvbiBpbml0IGV2ZW50LlxuICovXG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uU3RhcnRlZEV2ZW50KHZlcnNpb24sIHRyYWNlSWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnY29ubmVjdGlvbi1zdGFydGVkJyxcbiAgICAgICAgY3VzdG9tX2RhdGE6IGNyZWF0ZVZlcnNpb25JbmZvKHZlcnNpb24pLFxuICAgICAgICB0cmFjZV9pZDogdHJhY2VJZCAhPT0gbnVsbCAmJiB0cmFjZUlkICE9PSB2b2lkIDAgPyB0cmFjZUlkIDogbnVsbFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSBhIGNvbm5lY3Rpb24gY29tcGxldGVkIGV2ZW50LlxuICogQHBhcmFtIHZlcnNpb25cbiAqIEBwYXJhbSB3YWxsZXRcbiAqIEBwYXJhbSBzZXNzaW9uSW5mb1xuICogQHBhcmFtIHRyYWNlSWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvbkNvbXBsZXRlZEV2ZW50KHZlcnNpb24sIHdhbGxldCwgc2Vzc2lvbkluZm8sIHRyYWNlSWQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdjb25uZWN0aW9uLWNvbXBsZXRlZCcsIGlzX3N1Y2Nlc3M6IHRydWUsIHRyYWNlX2lkOiB0cmFjZUlkICE9PSBudWxsICYmIHRyYWNlSWQgIT09IHZvaWQgMCA/IHRyYWNlSWQgOiBudWxsIH0sIGNyZWF0ZUNvbm5lY3Rpb25JbmZvKHZlcnNpb24sIHdhbGxldCwgc2Vzc2lvbkluZm8pKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgY29ubmVjdGlvbiBlcnJvciBldmVudC5cbiAqIEBwYXJhbSB2ZXJzaW9uXG4gKiBAcGFyYW0gZXJyb3JfbWVzc2FnZVxuICogQHBhcmFtIGVycm9yQ29kZVxuICogQHBhcmFtIHNlc3Npb25JbmZvXG4gKiBAcGFyYW0gdHJhY2VJZFxuICovXG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uRXJyb3JFdmVudCh2ZXJzaW9uLCBlcnJvcl9tZXNzYWdlLCBlcnJvckNvZGUsIHNlc3Npb25JbmZvLCB0cmFjZUlkKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnY29ubmVjdGlvbi1lcnJvcicsXG4gICAgICAgIGlzX3N1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcl9tZXNzYWdlOiBlcnJvcl9tZXNzYWdlLFxuICAgICAgICBlcnJvcl9jb2RlOiBlcnJvckNvZGUgIT09IG51bGwgJiYgZXJyb3JDb2RlICE9PSB2b2lkIDAgPyBlcnJvckNvZGUgOiBudWxsLFxuICAgICAgICB0cmFjZV9pZDogdHJhY2VJZCAhPT0gbnVsbCAmJiB0cmFjZUlkICE9PSB2b2lkIDAgPyB0cmFjZUlkIDogbnVsbCxcbiAgICAgICAgY3VzdG9tX2RhdGE6IE9iamVjdC5hc3NpZ24oeyBjbGllbnRfaWQ6IChfYSA9IHNlc3Npb25JbmZvID09PSBudWxsIHx8IHNlc3Npb25JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uSW5mby5jbGllbnRJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCwgd2FsbGV0X2lkOiAoX2IgPSBzZXNzaW9uSW5mbyA9PT0gbnVsbCB8fCBzZXNzaW9uSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbkluZm8ud2FsbGV0SWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGwgfSwgY3JlYXRlVmVyc2lvbkluZm8odmVyc2lvbikpXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgY29ubmVjdGlvbiByZXN0b3Jpbmcgc3RhcnRlZCBldmVudC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvblJlc3RvcmluZ1N0YXJ0ZWRFdmVudCh2ZXJzaW9uLCB0cmFjZUlkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2Nvbm5lY3Rpb24tcmVzdG9yaW5nLXN0YXJ0ZWQnLFxuICAgICAgICBjdXN0b21fZGF0YTogY3JlYXRlVmVyc2lvbkluZm8odmVyc2lvbiksXG4gICAgICAgIHRyYWNlX2lkOiB0cmFjZUlkICE9PSBudWxsICYmIHRyYWNlSWQgIT09IHZvaWQgMCA/IHRyYWNlSWQgOiBudWxsXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgY29ubmVjdGlvbiByZXN0b3JpbmcgY29tcGxldGVkIGV2ZW50LlxuICogQHBhcmFtIHZlcnNpb25cbiAqIEBwYXJhbSB3YWxsZXRcbiAqIEBwYXJhbSBzZXNzaW9uSW5mb1xuICogQHBhcmFtIHRyYWNlSWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvblJlc3RvcmluZ0NvbXBsZXRlZEV2ZW50KHZlcnNpb24sIHdhbGxldCwgc2Vzc2lvbkluZm8sIHRyYWNlSWQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdjb25uZWN0aW9uLXJlc3RvcmluZy1jb21wbGV0ZWQnLCBpc19zdWNjZXNzOiB0cnVlLCB0cmFjZV9pZDogdHJhY2VJZCAhPT0gbnVsbCAmJiB0cmFjZUlkICE9PSB2b2lkIDAgPyB0cmFjZUlkIDogbnVsbCB9LCBjcmVhdGVDb25uZWN0aW9uSW5mbyh2ZXJzaW9uLCB3YWxsZXQsIHNlc3Npb25JbmZvKSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIGNvbm5lY3Rpb24gcmVzdG9yaW5nIGVycm9yIGV2ZW50LlxuICogQHBhcmFtIHZlcnNpb25cbiAqIEBwYXJhbSBlcnJvck1lc3NhZ2VcbiAqIEBwYXJhbSB0cmFjZUlkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3Rpb25SZXN0b3JpbmdFcnJvckV2ZW50KHZlcnNpb24sIGVycm9yTWVzc2FnZSwgdHJhY2VJZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdjb25uZWN0aW9uLXJlc3RvcmluZy1lcnJvcicsXG4gICAgICAgIGlzX3N1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcl9tZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgIHRyYWNlX2lkOiB0cmFjZUlkICE9PSBudWxsICYmIHRyYWNlSWQgIT09IHZvaWQgMCA/IHRyYWNlSWQgOiBudWxsLFxuICAgICAgICBjdXN0b21fZGF0YTogY3JlYXRlVmVyc2lvbkluZm8odmVyc2lvbilcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVHJhbnNhY3Rpb25JbmZvKHdhbGxldCwgdHJhbnNhY3Rpb24pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWRfdW50aWw6IChfYSA9IFN0cmluZyh0cmFuc2FjdGlvbi52YWxpZFVudGlsKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCxcbiAgICAgICAgZnJvbTogKF9kID0gKF9iID0gdHJhbnNhY3Rpb24uZnJvbSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKF9jID0gd2FsbGV0ID09PSBudWxsIHx8IHdhbGxldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2FsbGV0LmFjY291bnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hZGRyZXNzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBudWxsLFxuICAgICAgICBtZXNzYWdlczogdHJhbnNhY3Rpb24ubWVzc2FnZXMubWFwKG1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IChfYSA9IG1lc3NhZ2UuYWRkcmVzcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCxcbiAgICAgICAgICAgICAgICBhbW91bnQ6IChfYiA9IG1lc3NhZ2UuYW1vdW50KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVHJhbnNhY3Rpb25GdWxsSW5mbyh3YWxsZXQsIHRyYW5zYWN0aW9uKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIHJldHVybiB7XG4gICAgICAgIHZhbGlkX3VudGlsOiAoX2EgPSBTdHJpbmcodHJhbnNhY3Rpb24udmFsaWRVbnRpbCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwsXG4gICAgICAgIGZyb206IChfZCA9IChfYiA9IHRyYW5zYWN0aW9uLmZyb20pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChfYyA9IHdhbGxldCA9PT0gbnVsbCB8fCB3YWxsZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdhbGxldC5hY2NvdW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWRkcmVzcykgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogbnVsbCxcbiAgICAgICAgbWVzc2FnZXM6IHRyYW5zYWN0aW9uLm1lc3NhZ2VzLm1hcChtZXNzYWdlID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IChfYSA9IG1lc3NhZ2UuYWRkcmVzcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCxcbiAgICAgICAgICAgICAgICBhbW91bnQ6IChfYiA9IG1lc3NhZ2UuYW1vdW50KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsLFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IChfYyA9IG1lc3NhZ2UucGF5bG9hZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbnVsbCxcbiAgICAgICAgICAgICAgICBzdGF0ZV9pbml0OiAoX2QgPSBtZXNzYWdlLnN0YXRlSW5pdCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgdHJhbnNhY3Rpb24gaW5pdCBldmVudC5cbiAqIEBwYXJhbSB2ZXJzaW9uXG4gKiBAcGFyYW0gd2FsbGV0XG4gKiBAcGFyYW0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSBzZXNzaW9uSW5mb1xuICogQHBhcmFtIHRyYWNlSWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNhY3Rpb25TZW50Rm9yU2lnbmF0dXJlRXZlbnQodmVyc2lvbiwgd2FsbGV0LCB0cmFuc2FjdGlvbiwgc2Vzc2lvbkluZm8sIHRyYWNlSWQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdHlwZTogJ3RyYW5zYWN0aW9uLXNlbnQtZm9yLXNpZ25hdHVyZScsIHRyYWNlX2lkOiB0cmFjZUlkICE9PSBudWxsICYmIHRyYWNlSWQgIT09IHZvaWQgMCA/IHRyYWNlSWQgOiBudWxsIH0sIGNyZWF0ZUNvbm5lY3Rpb25JbmZvKHZlcnNpb24sIHdhbGxldCwgc2Vzc2lvbkluZm8pKSwgY3JlYXRlVHJhbnNhY3Rpb25JbmZvKHdhbGxldCwgdHJhbnNhY3Rpb24pKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgdHJhbnNhY3Rpb24gc2lnbmVkIGV2ZW50LlxuICogQHBhcmFtIHZlcnNpb25cbiAqIEBwYXJhbSB3YWxsZXRcbiAqIEBwYXJhbSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHNpZ25lZFRyYW5zYWN0aW9uXG4gKiBAcGFyYW0gc2Vzc2lvbkluZm9cbiAqIEBwYXJhbSB0cmFjZUlkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zYWN0aW9uU2lnbmVkRXZlbnQodmVyc2lvbiwgd2FsbGV0LCB0cmFuc2FjdGlvbiwgc2lnbmVkVHJhbnNhY3Rpb24sIHNlc3Npb25JbmZvLCB0cmFjZUlkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHR5cGU6ICd0cmFuc2FjdGlvbi1zaWduZWQnLCBpc19zdWNjZXNzOiB0cnVlLCBzaWduZWRfdHJhbnNhY3Rpb246IHNpZ25lZFRyYW5zYWN0aW9uLmJvYywgdHJhY2VfaWQ6IHRyYWNlSWQgIT09IG51bGwgJiYgdHJhY2VJZCAhPT0gdm9pZCAwID8gdHJhY2VJZCA6IG51bGwgfSwgY3JlYXRlQ29ubmVjdGlvbkluZm8odmVyc2lvbiwgd2FsbGV0LCBzZXNzaW9uSW5mbykpLCBjcmVhdGVUcmFuc2FjdGlvbkluZm8od2FsbGV0LCB0cmFuc2FjdGlvbikpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSB0cmFuc2FjdGlvbiBlcnJvciBldmVudC5cbiAqIEBwYXJhbSB2ZXJzaW9uXG4gKiBAcGFyYW0gd2FsbGV0XG4gKiBAcGFyYW0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSBlcnJvck1lc3NhZ2VcbiAqIEBwYXJhbSBlcnJvckNvZGVcbiAqIEBwYXJhbSBzZXNzaW9uSW5mb1xuICogQHBhcmFtIHRyYWNlSWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNhY3Rpb25TaWduaW5nRmFpbGVkRXZlbnQodmVyc2lvbiwgd2FsbGV0LCB0cmFuc2FjdGlvbiwgZXJyb3JNZXNzYWdlLCBlcnJvckNvZGUsIHNlc3Npb25JbmZvLCB0cmFjZUlkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHR5cGU6ICd0cmFuc2FjdGlvbi1zaWduaW5nLWZhaWxlZCcsIGlzX3N1Y2Nlc3M6IGZhbHNlLCBlcnJvcl9tZXNzYWdlOiBlcnJvck1lc3NhZ2UsIGVycm9yX2NvZGU6IGVycm9yQ29kZSAhPT0gbnVsbCAmJiBlcnJvckNvZGUgIT09IHZvaWQgMCA/IGVycm9yQ29kZSA6IG51bGwsIHRyYWNlX2lkOiB0cmFjZUlkICE9PSBudWxsICYmIHRyYWNlSWQgIT09IHZvaWQgMCA/IHRyYWNlSWQgOiBudWxsIH0sIGNyZWF0ZUNvbm5lY3Rpb25JbmZvKHZlcnNpb24sIHdhbGxldCwgc2Vzc2lvbkluZm8pKSwgY3JlYXRlVHJhbnNhY3Rpb25GdWxsSW5mbyh3YWxsZXQsIHRyYW5zYWN0aW9uKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVEYXRhU2VudEZvclNpZ25hdHVyZUV2ZW50KHZlcnNpb24sIHdhbGxldCwgZGF0YSwgc2Vzc2lvbkluZm8sIHRyYWNlSWQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdzaWduLWRhdGEtcmVxdWVzdC1pbml0aWF0ZWQnLCBkYXRhLCB0cmFjZV9pZDogdHJhY2VJZCAhPT0gbnVsbCAmJiB0cmFjZUlkICE9PSB2b2lkIDAgPyB0cmFjZUlkIDogbnVsbCB9LCBjcmVhdGVDb25uZWN0aW9uSW5mbyh2ZXJzaW9uLCB3YWxsZXQsIHNlc3Npb25JbmZvKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVEYXRhU2lnbmVkRXZlbnQodmVyc2lvbiwgd2FsbGV0LCBkYXRhLCBzaWduZWREYXRhLCBzZXNzaW9uSW5mbywgdHJhY2VJZCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgdHlwZTogJ3NpZ24tZGF0YS1yZXF1ZXN0LWNvbXBsZXRlZCcsIGlzX3N1Y2Nlc3M6IHRydWUsIGRhdGEsIHNpZ25lZF9kYXRhOiBzaWduZWREYXRhLCB0cmFjZV9pZDogdHJhY2VJZCAhPT0gbnVsbCAmJiB0cmFjZUlkICE9PSB2b2lkIDAgPyB0cmFjZUlkIDogbnVsbCB9LCBjcmVhdGVDb25uZWN0aW9uSW5mbyh2ZXJzaW9uLCB3YWxsZXQsIHNlc3Npb25JbmZvKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVEYXRhU2lnbmluZ0ZhaWxlZEV2ZW50KHZlcnNpb24sIHdhbGxldCwgZGF0YSwgZXJyb3JNZXNzYWdlLCBlcnJvckNvZGUsIHNlc3Npb25JbmZvLCB0cmFjZUlkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyB0eXBlOiAnc2lnbi1kYXRhLXJlcXVlc3QtZmFpbGVkJywgaXNfc3VjY2VzczogZmFsc2UsIGRhdGEsIGVycm9yX21lc3NhZ2U6IGVycm9yTWVzc2FnZSwgZXJyb3JfY29kZTogZXJyb3JDb2RlICE9PSBudWxsICYmIGVycm9yQ29kZSAhPT0gdm9pZCAwID8gZXJyb3JDb2RlIDogbnVsbCwgdHJhY2VfaWQ6IHRyYWNlSWQgIT09IG51bGwgJiYgdHJhY2VJZCAhPT0gdm9pZCAwID8gdHJhY2VJZCA6IG51bGwgfSwgY3JlYXRlQ29ubmVjdGlvbkluZm8odmVyc2lvbiwgd2FsbGV0LCBzZXNzaW9uSW5mbykpO1xufVxuZnVuY3Rpb24gY3JlYXRlRGlzY29ubmVjdGlvbkV2ZW50KHZlcnNpb24sIHdhbGxldCwgc2NvcGUsIHNlc3Npb25JbmZvLCB0cmFjZUlkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyB0eXBlOiAnZGlzY29ubmVjdGlvbicsIHNjb3BlOiBzY29wZSwgdHJhY2VfaWQ6IHRyYWNlSWQgIT09IG51bGwgJiYgdHJhY2VJZCAhPT0gdm9pZCAwID8gdHJhY2VJZCA6IG51bGwgfSwgY3JlYXRlQ29ubmVjdGlvbkluZm8odmVyc2lvbiwgd2FsbGV0LCBzZXNzaW9uSW5mbykpO1xufVxuZnVuY3Rpb24gY3JlYXRlV2FsbGV0TW9kYWxPcGVuZWRFdmVudCh2ZXJzaW9uLCB2aXNpYmxlV2FsbGV0cywgY2xpZW50SWQsIHRyYWNlSWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnd2FsbGV0LW1vZGFsLW9wZW5lZCcsXG4gICAgICAgIHZpc2libGVfd2FsbGV0czogdmlzaWJsZVdhbGxldHMsXG4gICAgICAgIGNsaWVudF9pZDogY2xpZW50SWQgIT09IG51bGwgJiYgY2xpZW50SWQgIT09IHZvaWQgMCA/IGNsaWVudElkIDogbnVsbCxcbiAgICAgICAgY3VzdG9tX2RhdGE6IHZlcnNpb24sXG4gICAgICAgIHRyYWNlX2lkOiB0cmFjZUlkICE9PSBudWxsICYmIHRyYWNlSWQgIT09IHZvaWQgMCA/IHRyYWNlSWQgOiBudWxsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdGVkV2FsbGV0RXZlbnQodmVyc2lvbiwgdmlzaWJsZVdhbGxldHMsIGxhc3RTZWxlY3RlZFdhbGxldCwgd2FsbGV0c01lbnUsIHJlZGlyZWN0TGluaywgcmVkaXJlY3RMaW5rVHlwZSwgY2xpZW50SWQsIHRyYWNlSWQpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHdhbGxldFJlZGlyZWN0TWV0aG9kID0gcmVkaXJlY3RMaW5rVHlwZTtcbiAgICBpZiAoIXdhbGxldFJlZGlyZWN0TWV0aG9kICYmIHJlZGlyZWN0TGluaykge1xuICAgICAgICB3YWxsZXRSZWRpcmVjdE1ldGhvZCA9IGlzVGVsZWdyYW1VcmwocmVkaXJlY3RMaW5rKSA/ICd0Z19saW5rJyA6ICdleHRlcm5hbF9saW5rJztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3NlbGVjdGVkLXdhbGxldCcsXG4gICAgICAgIHdhbGxldHNfbWVudTogd2FsbGV0c01lbnUsXG4gICAgICAgIHZpc2libGVfd2FsbGV0czogdmlzaWJsZVdhbGxldHMsXG4gICAgICAgIGNsaWVudF9pZDogY2xpZW50SWQgIT09IG51bGwgJiYgY2xpZW50SWQgIT09IHZvaWQgMCA/IGNsaWVudElkIDogbnVsbCxcbiAgICAgICAgY3VzdG9tX2RhdGE6IHZlcnNpb24sXG4gICAgICAgIHRyYWNlX2lkOiB0cmFjZUlkICE9PSBudWxsICYmIHRyYWNlSWQgIT09IHZvaWQgMCA/IHRyYWNlSWQgOiBudWxsLFxuICAgICAgICB3YWxsZXRfcmVkaXJlY3RfbWV0aG9kOiB3YWxsZXRSZWRpcmVjdE1ldGhvZCxcbiAgICAgICAgd2FsbGV0X3JlZGlyZWN0X2xpbms6IHJlZGlyZWN0TGluayB8fCB1bmRlZmluZWQsXG4gICAgICAgIHdhbGxldF90eXBlOiAoX2EgPSBsYXN0U2VsZWN0ZWRXYWxsZXQgPT09IG51bGwgfHwgbGFzdFNlbGVjdGVkV2FsbGV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0U2VsZWN0ZWRXYWxsZXQuYXBwTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbFxuICAgIH07XG59XG5cbi8qKlxuICogVHJhY2tlciBmb3IgVG9uQ29ubmVjdCB1c2VyIGFjdGlvbnMsIHN1Y2ggYXMgdHJhbnNhY3Rpb24gc2lnbmluZywgY29ubmVjdGlvbiwgZXRjLlxuICpcbiAqIExpc3Qgb2YgZXZlbnRzOlxuICogICogYGNvbm5lY3Rpb24tc3RhcnRlZGA6IHdoZW4gYSB1c2VyIHN0YXJ0cyBjb25uZWN0aW5nIGEgd2FsbGV0LlxuICogICogYGNvbm5lY3Rpb24tY29tcGxldGVkYDogd2hlbiBhIHVzZXIgc3VjY2Vzc2Z1bGx5IGNvbm5lY3RlZCBhIHdhbGxldC5cbiAqICAqIGBjb25uZWN0aW9uLWVycm9yYDogd2hlbiBhIHVzZXIgY2FuY2VscyBhIGNvbm5lY3Rpb24gb3IgdGhlcmUgaXMgYW4gZXJyb3IgZHVyaW5nIHRoZSBjb25uZWN0aW9uIHByb2Nlc3MuXG4gKiAgKiBgY29ubmVjdGlvbi1yZXN0b3Jpbmctc3RhcnRlZGA6IHdoZW4gdGhlIGRBcHAgc3RhcnRzIHJlc3RvcmluZyBhIGNvbm5lY3Rpb24uXG4gKiAgKiBgY29ubmVjdGlvbi1yZXN0b3JpbmctY29tcGxldGVkYDogd2hlbiB0aGUgZEFwcCBzdWNjZXNzZnVsbHkgcmVzdG9yZXMgYSBjb25uZWN0aW9uLlxuICogICogYGNvbm5lY3Rpb24tcmVzdG9yaW5nLWVycm9yYDogd2hlbiB0aGUgZEFwcCBmYWlscyB0byByZXN0b3JlIGEgY29ubmVjdGlvbi5cbiAqICAqIGBkaXNjb25uZWN0aW9uYDogd2hlbiBhIHVzZXIgc3RhcnRzIGRpc2Nvbm5lY3RpbmcgYSB3YWxsZXQuXG4gKiAgKiBgdHJhbnNhY3Rpb24tc2VudC1mb3Itc2lnbmF0dXJlYDogd2hlbiBhIHVzZXIgc2VuZHMgYSB0cmFuc2FjdGlvbiBmb3Igc2lnbmF0dXJlLlxuICogICogYHRyYW5zYWN0aW9uLXNpZ25lZGA6IHdoZW4gYSB1c2VyIHN1Y2Nlc3NmdWxseSBzaWducyBhIHRyYW5zYWN0aW9uLlxuICogICogYHRyYW5zYWN0aW9uLXNpZ25pbmctZmFpbGVkYDogd2hlbiBhIHVzZXIgY2FuY2VscyB0cmFuc2FjdGlvbiBzaWduaW5nIG9yIHRoZXJlIGlzIGFuIGVycm9yIGR1cmluZyB0aGUgc2lnbmluZyBwcm9jZXNzLlxuICogICogYHNpZ24tZGF0YS1yZXF1ZXN0LWluaXRpYXRlZGA6IHdoZW4gYSB1c2VyIHNlbmRzIGRhdGEgZm9yIHNpZ25hdHVyZS5cbiAqICAqIGBzaWduLWRhdGEtcmVxdWVzdC1jb21wbGV0ZWRgOiB3aGVuIGEgdXNlciBzdWNjZXNzZnVsbHkgc2lnbnMgZGF0YS5cbiAqICAqIGBzaWduLWRhdGEtcmVxdWVzdC1mYWlsZWRgOiB3aGVuIGEgdXNlciBjYW5jZWxzIGRhdGEgc2lnbmluZyBvciB0aGVyZSBpcyBhbiBlcnJvciBkdXJpbmcgdGhlIHNpZ25pbmcgcHJvY2Vzcy5cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byB0cmFjayB1c2VyIGFjdGlvbnMsIHlvdSBjYW4gc3Vic2NyaWJlIHRvIHRoZSB3aW5kb3cgZXZlbnRzIHdpdGggcHJlZml4IGB0b24tY29ubmVjdC1gOlxuICpcbiAqIEBleGFtcGxlXG4gKiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG9uLWNvbm5lY3QtdHJhbnNhY3Rpb24tc2VudC1mb3Itc2lnbmF0dXJlJywgKGV2ZW50KSA9PiB7XG4gKiAgICBjb25zb2xlLmxvZygnVHJhbnNhY3Rpb24gaW5pdCcsIGV2ZW50LmRldGFpbCk7XG4gKiB9KTtcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgVG9uQ29ubmVjdFRyYWNrZXIge1xuICAgIC8qKlxuICAgICAqIFZlcnNpb24gb2YgdGhlIGxpYnJhcnkuXG4gICAgICovXG4gICAgZ2V0IHZlcnNpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVWZXJzaW9uSW5mbyh7XG4gICAgICAgICAgICB0b25fY29ubmVjdF9zZGtfbGliOiB0aGlzLnRvbkNvbm5lY3RTZGtWZXJzaW9uLFxuICAgICAgICAgICAgdG9uX2Nvbm5lY3RfdWlfbGliOiB0aGlzLnRvbkNvbm5lY3RVaVZlcnNpb25cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IHByZWZpeCBmb3IgdXNlciBhY3Rpb25zLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ldmVudFByZWZpeCA9ICd0b24tY29ubmVjdC0nO1xuICAgICAgICAvKipcbiAgICAgICAgICogVG9uQ29ubmVjdCBVSSB2ZXJzaW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b25Db25uZWN0VWlWZXJzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZXZlbnREaXNwYXRjaGVyO1xuICAgICAgICB0aGlzLnRvbkNvbm5lY3RTZGtWZXJzaW9uID0gb3B0aW9ucy50b25Db25uZWN0U2RrVmVyc2lvbjtcbiAgICAgICAgdGhpcy5pbml0KCkuY2F0Y2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIG9uY2Ugd2hlbiB0aGUgdHJhY2tlciBpcyBjcmVhdGVkIGFuZCByZXF1ZXN0IHZlcnNpb24gb3RoZXIgbGlicmFyaWVzLlxuICAgICAqL1xuICAgIGluaXQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuc2V0UmVxdWVzdFZlcnNpb25IYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy50b25Db25uZWN0VWlWZXJzaW9uID0geWllbGQgdGhpcy5yZXF1ZXN0VG9uQ29ubmVjdFVpVmVyc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHJlcXVlc3QgdmVyc2lvbiBoYW5kbGVyLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc2V0UmVxdWVzdFZlcnNpb25IYW5kbGVyKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5ldmVudERpc3BhdGNoZXIuYWRkRXZlbnRMaXN0ZW5lcigndG9uLWNvbm5lY3QtcmVxdWVzdC12ZXJzaW9uJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZXZlbnREaXNwYXRjaGVyLmRpc3BhdGNoRXZlbnQoJ3Rvbi1jb25uZWN0LXJlc3BvbnNlLXZlcnNpb24nLCBjcmVhdGVSZXNwb25zZVZlcnNpb25FdmVudCh0aGlzLnRvbkNvbm5lY3RTZGtWZXJzaW9uKSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IFRvbkNvbm5lY3QgVUkgdmVyc2lvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJlcXVlc3RUb25Db25uZWN0VWlWZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmV2ZW50RGlzcGF0Y2hlci5hZGRFdmVudExpc3RlbmVyKCd0b24tY29ubmVjdC11aS1yZXNwb25zZS12ZXJzaW9uJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGV2ZW50LmRldGFpbC52ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmV2ZW50RGlzcGF0Y2hlci5kaXNwYXRjaEV2ZW50KCd0b24tY29ubmVjdC11aS1yZXF1ZXN0LXZlcnNpb24nLCBjcmVhdGVSZXF1ZXN0VmVyc2lvbkV2ZW50KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdCB1c2VyIGFjdGlvbiBldmVudCB0byB0aGUgd2luZG93LlxuICAgICAqIEBwYXJhbSBldmVudERldGFpbHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50RGV0YWlscykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXJcbiAgICAgICAgICAgICAgICAuZGlzcGF0Y2hFdmVudChgJHt0aGlzLmV2ZW50UHJlZml4fSR7ZXZlbnREZXRhaWxzLnR5cGV9YCwgZXZlbnREZXRhaWxzKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhY2sgY29ubmVjdGlvbiBpbml0IGV2ZW50LlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgdHJhY2tDb25uZWN0aW9uU3RhcnRlZCguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGNyZWF0ZUNvbm5lY3Rpb25TdGFydGVkRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhY2sgY29ubmVjdGlvbiBzdWNjZXNzIGV2ZW50LlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgdHJhY2tDb25uZWN0aW9uQ29tcGxldGVkKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlQ29ubmVjdGlvbkNvbXBsZXRlZEV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYWNrIGNvbm5lY3Rpb24gZXJyb3IgZXZlbnQuXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICB0cmFja0Nvbm5lY3Rpb25FcnJvciguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGNyZWF0ZUNvbm5lY3Rpb25FcnJvckV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYWNrIGNvbm5lY3Rpb24gcmVzdG9yaW5nIGluaXQgZXZlbnQuXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICB0cmFja0Nvbm5lY3Rpb25SZXN0b3JpbmdTdGFydGVkKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlQ29ubmVjdGlvblJlc3RvcmluZ1N0YXJ0ZWRFdmVudCh0aGlzLnZlcnNpb24sIC4uLmFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFVzZXJBY3Rpb25FdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFjayBjb25uZWN0aW9uIHJlc3RvcmluZyBzdWNjZXNzIGV2ZW50LlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgdHJhY2tDb25uZWN0aW9uUmVzdG9yaW5nQ29tcGxldGVkKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlQ29ubmVjdGlvblJlc3RvcmluZ0NvbXBsZXRlZEV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYWNrIGNvbm5lY3Rpb24gcmVzdG9yaW5nIGVycm9yIGV2ZW50LlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgdHJhY2tDb25uZWN0aW9uUmVzdG9yaW5nRXJyb3IoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVDb25uZWN0aW9uUmVzdG9yaW5nRXJyb3JFdmVudCh0aGlzLnZlcnNpb24sIC4uLmFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFVzZXJBY3Rpb25FdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFjayBkaXNjb25uZWN0IGV2ZW50LlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgdHJhY2tEaXNjb25uZWN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlRGlzY29ubmVjdGlvbkV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYWNrIHRyYW5zYWN0aW9uIGluaXQgZXZlbnQuXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICB0cmFja1RyYW5zYWN0aW9uU2VudEZvclNpZ25hdHVyZSguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGNyZWF0ZVRyYW5zYWN0aW9uU2VudEZvclNpZ25hdHVyZUV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYWNrIHRyYW5zYWN0aW9uIHNpZ25lZCBldmVudC5cbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIHRyYWNrVHJhbnNhY3Rpb25TaWduZWQoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVUcmFuc2FjdGlvblNpZ25lZEV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYWNrIHRyYW5zYWN0aW9uIGVycm9yIGV2ZW50LlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgdHJhY2tUcmFuc2FjdGlvblNpZ25pbmdGYWlsZWQoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVUcmFuc2FjdGlvblNpZ25pbmdGYWlsZWRFdmVudCh0aGlzLnZlcnNpb24sIC4uLmFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFVzZXJBY3Rpb25FdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFjayBzaWduIGRhdGEgaW5pdCBldmVudC5cbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIHRyYWNrRGF0YVNlbnRGb3JTaWduYXR1cmUoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVEYXRhU2VudEZvclNpZ25hdHVyZUV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYWNrIHNpZ24gZGF0YSBzdWNjZXNzIGV2ZW50LlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgdHJhY2tEYXRhU2lnbmVkKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlRGF0YVNpZ25lZEV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYWNrIHNpZ24gZGF0YSBlcnJvciBldmVudC5cbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIHRyYWNrRGF0YVNpZ25pbmdGYWlsZWQoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVEYXRhU2lnbmluZ0ZhaWxlZEV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfVxufVxuXG5jb25zdCB0b25Db25uZWN0U2RrVmVyc2lvbiA9IFwiMy40LjFcIjtcblxuY29uc3QgYm91bmNlYWJsZVRhZyA9IDB4MTE7XG5jb25zdCBub0JvdW5jZWFibGVUYWcgPSAweDUxO1xuY29uc3QgdGVzdE9ubHlUYWcgPSAweDgwO1xuLyoqXG4gKiBDb252ZXJ0cyByYXcgVE9OIGFkZHJlc3MgdG8gbm8tYm91bmNlYWJsZSB1c2VyLWZyaWVuZGx5IGZvcm1hdC4gW1NlZSBkZXRhaWxzXXtAbGluayBodHRwczovL3Rvbi5vcmcvZG9jcy9sZWFybi9vdmVydmlld3MvYWRkcmVzc2VzI3VzZXItZnJpZW5kbHktYWRkcmVzc31cbiAqIEBwYXJhbSBoZXhBZGRyZXNzIHJhdyBUT04gYWRkcmVzcyBmb3JtYXR0ZWQgYXMgXCIwOjxoZXggc3RyaW5nIHdpdGhvdXQgMHg+XCIuXG4gKiBAcGFyYW0gW3Rlc3RPbmx5PWZhbHNlXSBjb252ZXJ0IGFkZHJlc3MgdG8gdGVzdC1vbmx5IGZvcm0uIFtTZWUgZGV0YWlsc117QGxpbmsgaHR0cHM6Ly90b24ub3JnL2RvY3MvbGVhcm4vb3ZlcnZpZXdzL2FkZHJlc3NlcyN1c2VyLWZyaWVuZGx5LWFkZHJlc3N9XG4gKi9cbmZ1bmN0aW9uIHRvVXNlckZyaWVuZGx5QWRkcmVzcyhoZXhBZGRyZXNzLCB0ZXN0T25seSA9IGZhbHNlKSB7XG4gICAgY29uc3QgeyB3YywgaGV4IH0gPSBwYXJzZUhleEFkZHJlc3MoaGV4QWRkcmVzcyk7XG4gICAgbGV0IHRhZyA9IG5vQm91bmNlYWJsZVRhZztcbiAgICBpZiAodGVzdE9ubHkpIHtcbiAgICAgICAgdGFnIHw9IHRlc3RPbmx5VGFnO1xuICAgIH1cbiAgICBjb25zdCBhZGRyID0gbmV3IEludDhBcnJheSgzNCk7XG4gICAgYWRkclswXSA9IHRhZztcbiAgICBhZGRyWzFdID0gd2M7XG4gICAgYWRkci5zZXQoaGV4LCAyKTtcbiAgICBjb25zdCBhZGRyZXNzV2l0aENoZWNrc3VtID0gbmV3IFVpbnQ4QXJyYXkoMzYpO1xuICAgIGFkZHJlc3NXaXRoQ2hlY2tzdW0uc2V0KGFkZHIpO1xuICAgIGFkZHJlc3NXaXRoQ2hlY2tzdW0uc2V0KGNyYzE2KGFkZHIpLCAzNCk7XG4gICAgbGV0IGFkZHJlc3NCYXNlNjQgPSBCYXNlNjQuZW5jb2RlKGFkZHJlc3NXaXRoQ2hlY2tzdW0pO1xuICAgIHJldHVybiBhZGRyZXNzQmFzZTY0LnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgaWYgdGhlIGFkZHJlc3MgaXMgaW4gdXNlci1mcmllbmRseSBmb3JtYXQgYnkgYXR0ZW1wdGluZyB0byBwYXJzZSBpdC5cbiAqIEBwYXJhbSBhZGRyZXNzIGFkZHJlc3MgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGFkZHJlc3MgaXMgdmFsaWQgdXNlci1mcmllbmRseSBmb3JtYXQsIGZhbHNlIG90aGVyd2lzZVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkVXNlckZyaWVuZGx5QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcGFyc2VVc2VyRnJpZW5kbHlBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFZhbGlkYXRlcyBpZiB0aGUgYWRkcmVzcyBpcyBpbiByYXcgaGV4IGZvcm1hdCAoZS5nLiwgXCIwOjEyMzQuLi5cIiBvciBcIi0xOjEyMzQuLi5cIikuXG4gKiBAcGFyYW0gYWRkcmVzcyBhZGRyZXNzIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBhZGRyZXNzIGlzIHZhbGlkIHJhdyBmb3JtYXQsIGZhbHNlIG90aGVyd2lzZVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkUmF3QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcGFyc2VIZXhBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b1Jhd0FkZHJlc3MoeyB3YywgaGV4IH0pIHtcbiAgICByZXR1cm4gYCR7d2N9OiR7aGV4fWA7XG59XG4vKipcbiAqIFBhcnNlcyB1c2VyLWZyaWVuZGx5IGFkZHJlc3MgYW5kIHJldHVybnMgaXRzIGNvbXBvbmVudHMuXG4gKiBAcGFyYW0gYWRkcmVzcyB1c2VyLWZyaWVuZGx5IGFkZHJlc3NcbiAqIEByZXR1cm5zIHBhcnNlZCBhZGRyZXNzIGNvbXBvbmVudHNcbiAqL1xuZnVuY3Rpb24gcGFyc2VVc2VyRnJpZW5kbHlBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBjb25zdCBiYXNlNjQgPSBhZGRyZXNzLnJlcGxhY2UoLy0vZywgJysnKS5yZXBsYWNlKC9fL2csICcvJyk7XG4gICAgbGV0IGRlY29kZWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgZGVjb2RlZCA9IEJhc2U2NC5kZWNvZGUoYmFzZTY0KS50b1VpbnQ4QXJyYXkoKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHRocm93IG5ldyBXcm9uZ0FkZHJlc3NFcnJvcihgSW52YWxpZCBiYXNlNjQgZW5jb2RpbmcgaW4gYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cbiAgICBpZiAoZGVjb2RlZC5sZW5ndGggIT09IDM2KSB7XG4gICAgICAgIHRocm93IG5ldyBXcm9uZ0FkZHJlc3NFcnJvcihgSW52YWxpZCBhZGRyZXNzIGxlbmd0aDogJHthZGRyZXNzfWApO1xuICAgIH1cbiAgICBjb25zdCBhZGRyID0gZGVjb2RlZC5zbGljZSgwLCAzNCk7XG4gICAgY29uc3QgY2hlY2tzdW0gPSBkZWNvZGVkLnNsaWNlKDM0LCAzNik7XG4gICAgY29uc3QgY2FsY3VsYXRlZENoZWNrc3VtID0gY3JjMTYoYWRkcik7XG4gICAgaWYgKCFjaGVja3N1bS5ldmVyeSgoYnl0ZSwgaSkgPT4gYnl0ZSA9PT0gY2FsY3VsYXRlZENoZWNrc3VtW2ldKSkge1xuICAgICAgICB0aHJvdyBuZXcgV3JvbmdBZGRyZXNzRXJyb3IoYEludmFsaWQgY2hlY2tzdW0gaW4gYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cbiAgICBsZXQgdGFnID0gYWRkclswXTtcbiAgICBsZXQgaXNUZXN0T25seSA9IGZhbHNlO1xuICAgIGxldCBpc0JvdW5jZWFibGUgPSBmYWxzZTtcbiAgICBpZiAodGFnICYgdGVzdE9ubHlUYWcpIHtcbiAgICAgICAgaXNUZXN0T25seSA9IHRydWU7XG4gICAgICAgIHRhZyA9IHRhZyBeIHRlc3RPbmx5VGFnO1xuICAgIH1cbiAgICBpZiAodGFnICE9PSBib3VuY2VhYmxlVGFnICYmIHRhZyAhPT0gbm9Cb3VuY2VhYmxlVGFnKSB7XG4gICAgICAgIHRocm93IG5ldyBXcm9uZ0FkZHJlc3NFcnJvcihgVW5rbm93biBhZGRyZXNzIHRhZzogJHt0YWd9YCk7XG4gICAgfVxuICAgIGlzQm91bmNlYWJsZSA9IHRhZyA9PT0gYm91bmNlYWJsZVRhZztcbiAgICBsZXQgd2MgPSBudWxsO1xuICAgIGlmIChhZGRyWzFdID09PSAweGZmKSB7XG4gICAgICAgIC8vIFRPRE8gd2Ugc2hvdWxkIHJlYWQgc2lnbmVkIGludGVnZXIgaGVyZVxuICAgICAgICB3YyA9IC0xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2MgPSBhZGRyWzFdO1xuICAgIH1cbiAgICBjb25zdCBoZXggPSBhZGRyLnNsaWNlKDIpO1xuICAgIGlmICh3YyAhPT0gMCAmJiB3YyAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdyb25nQWRkcmVzc0Vycm9yKGBJbnZhbGlkIHdvcmtjaGFpbjogJHt3Y31gKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2MsXG4gICAgICAgIGhleDogQXJyYXkuZnJvbShoZXgpXG4gICAgICAgICAgICAubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSlcbiAgICAgICAgICAgIC5qb2luKCcnKSxcbiAgICAgICAgdGVzdE9ubHk6IGlzVGVzdE9ubHksXG4gICAgICAgIGlzQm91bmNlYWJsZVxuICAgIH07XG59XG5mdW5jdGlvbiBwYXJzZUhleEFkZHJlc3MoaGV4QWRkcmVzcykge1xuICAgIGlmICghaGV4QWRkcmVzcy5pbmNsdWRlcygnOicpKSB7XG4gICAgICAgIHRocm93IG5ldyBXcm9uZ0FkZHJlc3NFcnJvcihgV3JvbmcgYWRkcmVzcyAke2hleEFkZHJlc3N9LiBBZGRyZXNzIG11c3QgaW5jbHVkZSBcIjpcIi5gKTtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSBoZXhBZGRyZXNzLnNwbGl0KCc6Jyk7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgV3JvbmdBZGRyZXNzRXJyb3IoYFdyb25nIGFkZHJlc3MgJHtoZXhBZGRyZXNzfS4gQWRkcmVzcyBtdXN0IGluY2x1ZGUgXCI6XCIgb25seSBvbmNlLmApO1xuICAgIH1cbiAgICBjb25zdCB3YyA9IHBhcnNlSW50KHBhcnRzWzBdKTtcbiAgICBpZiAod2MgIT09IDAgJiYgd2MgIT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBXcm9uZ0FkZHJlc3NFcnJvcihgV3JvbmcgYWRkcmVzcyAke2hleEFkZHJlc3N9LiBXQyBtdXN0IGJlIGVxIDAgb3IgLTEsIGJ1dCAke3djfSByZWNlaXZlZC5gKTtcbiAgICB9XG4gICAgY29uc3QgaGV4ID0gcGFydHNbMV07XG4gICAgaWYgKChoZXggPT09IG51bGwgfHwgaGV4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBoZXgubGVuZ3RoKSAhPT0gNjQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdyb25nQWRkcmVzc0Vycm9yKGBXcm9uZyBhZGRyZXNzICR7aGV4QWRkcmVzc30uIEhleCBwYXJ0IG11c3QgYmUgNjRieXRlcyBsZW5ndGgsIGJ1dCAke2hleCA9PT0gbnVsbCB8fCBoZXggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhleC5sZW5ndGh9IHJlY2VpdmVkLmApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB3YyxcbiAgICAgICAgaGV4OiBoZXhUb0J5dGVzKGhleClcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JjMTYoZGF0YSkge1xuICAgIGNvbnN0IHBvbHkgPSAweDEwMjE7XG4gICAgbGV0IHJlZyA9IDA7XG4gICAgY29uc3QgbWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgMik7XG4gICAgbWVzc2FnZS5zZXQoZGF0YSk7XG4gICAgZm9yIChsZXQgYnl0ZSBvZiBtZXNzYWdlKSB7XG4gICAgICAgIGxldCBtYXNrID0gMHg4MDtcbiAgICAgICAgd2hpbGUgKG1hc2sgPiAwKSB7XG4gICAgICAgICAgICByZWcgPDw9IDE7XG4gICAgICAgICAgICBpZiAoYnl0ZSAmIG1hc2spIHtcbiAgICAgICAgICAgICAgICByZWcgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hc2sgPj49IDE7XG4gICAgICAgICAgICBpZiAocmVnID4gMHhmZmZmKSB7XG4gICAgICAgICAgICAgICAgcmVnICY9IDB4ZmZmZjtcbiAgICAgICAgICAgICAgICByZWcgXj0gcG9seTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW01hdGguZmxvb3IocmVnIC8gMjU2KSwgcmVnICUgMjU2XSk7XG59XG5jb25zdCB0b0J5dGVNYXAgPSB7fTtcbmZvciAobGV0IG9yZCA9IDA7IG9yZCA8PSAweGZmOyBvcmQrKykge1xuICAgIGxldCBzID0gb3JkLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAocy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHMgPSAnMCcgKyBzO1xuICAgIH1cbiAgICB0b0J5dGVNYXBbc10gPSBvcmQ7XG59XG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGhleCA9IGhleC50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGxlbmd0aDIgPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW5ndGgyICUgMiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VIZXhFcnJvcignSGV4IHN0cmluZyBtdXN0IGhhdmUgbGVuZ3RoIGEgbXVsdGlwbGUgb2YgMjogJyArIGhleCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IGxlbmd0aDIgLyAyO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkb3VibGVkID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleFN1YnN0cmluZyA9IGhleC5zdWJzdHJpbmcoZG91YmxlZCwgZG91YmxlZCArIDIpO1xuICAgICAgICBpZiAoIXRvQnl0ZU1hcC5oYXNPd25Qcm9wZXJ0eShoZXhTdWJzdHJpbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VIZXhFcnJvcignSW52YWxpZCBoZXggY2hhcmFjdGVyOiAnICsgaGV4U3Vic3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbaV0gPSB0b0J5dGVNYXBbaGV4U3Vic3RyaW5nXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgQkFTRTY0X1JFR0VYID0gL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvO1xuY29uc3QgQkFTRTY0VVJMX1JFR0VYID0gL15bQS1aYS16MC05XFwtX10rJC87XG5jb25zdCBCT0NfUFJFRklYID0gJ3RlNmNjJztcbmNvbnN0IElOVEVHRVJfUkVHRVggPSAvXi0/XFxkKyQvO1xuY29uc3QgUE9TSVRJVkVfSU5URUdFUl9SRUdFWCA9IC9eXFxkKyQvO1xuY29uc3QgTUFYX0RPTUFJTl9CWVRFUyA9IDEyODtcbmNvbnN0IE1BWF9QQVlMT0FEX0JZVEVTID0gMTI4O1xuY29uc3QgTUFYX1RPVEFMX0JZVEVTID0gMjIyO1xuZnVuY3Rpb24gaXNWYWxpZE51bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubGVuZ3RoID4gMDtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRBZGRyZXNzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzVmFsaWRTdHJpbmcodmFsdWUpICYmIChpc1ZhbGlkUmF3QWRkcmVzcyh2YWx1ZSkgfHwgaXNWYWxpZFVzZXJGcmllbmRseUFkZHJlc3ModmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWROZXR3b3JrKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzVmFsaWRTdHJpbmcodmFsdWUpICYmIC9eLT9cXGQrJC8udGVzdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkQm9jKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIChCQVNFNjRfUkVHRVgudGVzdCh2YWx1ZSkgfHwgQkFTRTY0VVJMX1JFR0VYLnRlc3QodmFsdWUpKSAmJlxuICAgICAgICB2YWx1ZS5zdGFydHNXaXRoKEJPQ19QUkVGSVgpKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBoYXNFeHRyYVByb3BlcnRpZXMob2JqLCBhbGxvd2VkS2V5cykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnNvbWUoa2V5ID0+ICFhbGxvd2VkS2V5cy5pbmNsdWRlcyhrZXkpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlU2VuZFRyYW5zYWN0aW9uUmVxdWVzdChkYXRhKSB7XG4gICAgaWYgKCFpc1ZhbGlkT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgIHJldHVybiAnUmVxdWVzdCBtdXN0IGJlIGFuIG9iamVjdCc7XG4gICAgfVxuICAgIGNvbnN0IGFsbG93ZWRLZXlzID0gWyd2YWxpZFVudGlsJywgJ25ldHdvcmsnLCAnZnJvbScsICdtZXNzYWdlcyddO1xuICAgIGlmIChoYXNFeHRyYVByb3BlcnRpZXMoZGF0YSwgYWxsb3dlZEtleXMpKSB7XG4gICAgICAgIHJldHVybiAnUmVxdWVzdCBjb250YWlucyBleHRyYSBwcm9wZXJ0aWVzJztcbiAgICB9XG4gICAgaWYgKGRhdGEudmFsaWRVbnRpbCkge1xuICAgICAgICBpZiAoIWlzVmFsaWROdW1iZXIoZGF0YS52YWxpZFVudGlsKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiSW5jb3JyZWN0ICd2YWxpZFVudGlsJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vdyA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICBjb25zdCBmaXZlTWludXRlc0Zyb21Ob3cgPSBub3cgKyAzMDA7XG4gICAgICAgIGlmIChkYXRhLnZhbGlkVW50aWwgPiBmaXZlTWludXRlc0Zyb21Ob3cpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdmFsaWRVbnRpbCAoJHtkYXRhLnZhbGlkVW50aWx9KSBpcyBtb3JlIHRoYW4gNSBtaW51dGVzIGZyb20gbm93ICgke25vd30pYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRhdGEubmV0d29yayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghaXNWYWxpZE5ldHdvcmsoZGF0YS5uZXR3b3JrKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiSW52YWxpZCAnbmV0d29yaycgZm9ybWF0XCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRhdGEuZnJvbSAhPT0gdW5kZWZpbmVkICYmICFpc1ZhbGlkQWRkcmVzcyhkYXRhLmZyb20pKSB7XG4gICAgICAgIHJldHVybiBcIkludmFsaWQgJ2Zyb20nIGFkZHJlc3MgZm9ybWF0XCI7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZEFycmF5KGRhdGEubWVzc2FnZXMpIHx8IGRhdGEubWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBcIidtZXNzYWdlcycgaXMgcmVxdWlyZWRcIjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLm1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkYXRhLm1lc3NhZ2VzW2ldO1xuICAgICAgICBjb25zdCBtZXNzYWdlRXJyb3IgPSB2YWxpZGF0ZVRyYW5zYWN0aW9uTWVzc2FnZShtZXNzYWdlLCBpKTtcbiAgICAgICAgaWYgKG1lc3NhZ2VFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VFcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVHJhbnNhY3Rpb25NZXNzYWdlKG1lc3NhZ2UsIGluZGV4KSB7XG4gICAgaWYgKCFpc1ZhbGlkT2JqZWN0KG1lc3NhZ2UpKSB7XG4gICAgICAgIHJldHVybiBgTWVzc2FnZSBhdCBpbmRleCAke2luZGV4fSBtdXN0IGJlIGFuIG9iamVjdGA7XG4gICAgfVxuICAgIGNvbnN0IGFsbG93ZWRLZXlzID0gWydhZGRyZXNzJywgJ2Ftb3VudCcsICdzdGF0ZUluaXQnLCAncGF5bG9hZCcsICdleHRyYUN1cnJlbmN5J107XG4gICAgaWYgKGhhc0V4dHJhUHJvcGVydGllcyhtZXNzYWdlLCBhbGxvd2VkS2V5cykpIHtcbiAgICAgICAgcmV0dXJuIGBNZXNzYWdlIGF0IGluZGV4ICR7aW5kZXh9IGNvbnRhaW5zIGV4dHJhIHByb3BlcnRpZXNgO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWRTdHJpbmcobWVzc2FnZS5hZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4gYCdhZGRyZXNzJyBpcyByZXF1aXJlZCBpbiBtZXNzYWdlIGF0IGluZGV4ICR7aW5kZXh9YDtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkVXNlckZyaWVuZGx5QWRkcmVzcyhtZXNzYWdlLmFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBgV3JvbmcgJ2FkZHJlc3MnIGZvcm1hdCBpbiBtZXNzYWdlIGF0IGluZGV4ICR7aW5kZXh9YDtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkU3RyaW5nKG1lc3NhZ2UuYW1vdW50KSkge1xuICAgICAgICByZXR1cm4gYCdhbW91bnQnIGlzIHJlcXVpcmVkIGluIG1lc3NhZ2UgYXQgaW5kZXggJHtpbmRleH1gO1xuICAgIH1cbiAgICBpZiAoIS9eWzAtOV0rJC8udGVzdChtZXNzYWdlLmFtb3VudCkpIHtcbiAgICAgICAgcmV0dXJuIGBJbmNvcnJlY3QgJ2Ftb3VudCcgaW4gbWVzc2FnZSBhdCBpbmRleCAke2luZGV4fWA7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLnN0YXRlSW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghaXNWYWxpZFN0cmluZyhtZXNzYWdlLnN0YXRlSW5pdCkgfHwgIWlzVmFsaWRCb2MobWVzc2FnZS5zdGF0ZUluaXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gYEludmFsaWQgJ3N0YXRlSW5pdCcgaW4gbWVzc2FnZSBhdCBpbmRleCAke2luZGV4fWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UucGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghaXNWYWxpZFN0cmluZyhtZXNzYWdlLnBheWxvYWQpIHx8ICFpc1ZhbGlkQm9jKG1lc3NhZ2UucGF5bG9hZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCAncGF5bG9hZCcgaW4gbWVzc2FnZSBhdCBpbmRleCAke2luZGV4fWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UuZXh0cmFDdXJyZW5jeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghaXNWYWxpZE9iamVjdChtZXNzYWdlLmV4dHJhQ3VycmVuY3kpKSB7XG4gICAgICAgICAgICByZXR1cm4gYEludmFsaWQgJ2V4dHJhQ3VycmVuY3knIGluIG1lc3NhZ2UgYXQgaW5kZXggJHtpbmRleH1gO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG1lc3NhZ2UuZXh0cmFDdXJyZW5jeSkpIHtcbiAgICAgICAgICAgIGlmICghSU5URUdFUl9SRUdFWC50ZXN0KGtleSkgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAgICAgIVBPU0lUSVZFX0lOVEVHRVJfUkVHRVgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYEludmFsaWQgJ2V4dHJhQ3VycmVuY3knIGZvcm1hdCBpbiBtZXNzYWdlIGF0IGluZGV4ICR7aW5kZXh9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQ29ubmVjdEFkZGl0aW9uYWxSZXF1ZXN0KGRhdGEpIHtcbiAgICBpZiAoIWlzVmFsaWRPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuICdSZXF1ZXN0IG11c3QgYmUgYW4gb2JqZWN0JztcbiAgICB9XG4gICAgY29uc3QgYWxsb3dlZEtleXMgPSBbJ3RvblByb29mJ107XG4gICAgaWYgKGhhc0V4dHJhUHJvcGVydGllcyhkYXRhLCBhbGxvd2VkS2V5cykpIHtcbiAgICAgICAgcmV0dXJuICdSZXF1ZXN0IGNvbnRhaW5zIGV4dHJhIHByb3BlcnRpZXMnO1xuICAgIH1cbiAgICBpZiAoZGF0YS50b25Qcm9vZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YS50b25Qcm9vZiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkludmFsaWQgJ3RvblByb29mJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYXRhLnRvblByb29mO1xuICAgICAgICBpZiAocGF5bG9hZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBcIkVtcHR5ICd0b25Qcm9vZicgcGF5bG9hZFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBjdXJyZW50IGRvbWFpbiBmb3IgdmFsaWRhdGlvbiBmaXJzdFxuICAgICAgICBjb25zdCBkb21haW4gPSBnZXREb21haW4oKTtcbiAgICAgICAgaWYgKCFkb21haW4pIHtcbiAgICAgICAgICAgIC8vIEluIE5vZGUuanMgZW52aXJvbm1lbnQsIHNraXAgZG9tYWluIHZhbGlkYXRpb25cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFZhbGlkYXRlIGRvbWFpbiBzaXplIChtYXggMTI4IGJ5dGVzKVxuICAgICAgICBjb25zdCBkb21haW5CeXRlcyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkb21haW4pLmxlbmd0aDtcbiAgICAgICAgaWYgKGRvbWFpbkJ5dGVzID4gTUFYX0RPTUFJTl9CWVRFUykge1xuICAgICAgICAgICAgcmV0dXJuICdDdXJyZW50IGRvbWFpbiBleGNlZWRzIDEyOCBieXRlcyBsaW1pdCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmFsaWRhdGUgcGF5bG9hZCBzaXplIChtYXggMTI4IGJ5dGVzKVxuICAgICAgICBjb25zdCBwYXlsb2FkQnl0ZXMgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocGF5bG9hZCkubGVuZ3RoO1xuICAgICAgICBpZiAocGF5bG9hZEJ5dGVzID4gTUFYX1BBWUxPQURfQllURVMpIHtcbiAgICAgICAgICAgIHJldHVybiBcIid0b25Qcm9vZicgcGF5bG9hZCBleGNlZWRzIDEyOCBieXRlcyBsaW1pdFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFZhbGlkYXRlIHRvdGFsIHNpemUgKGRvbWFpbiArIHBheWxvYWQgPD0gMjIyIGJ5dGVzKVxuICAgICAgICBpZiAoZG9tYWluQnl0ZXMgKyBwYXlsb2FkQnl0ZXMgPiBNQVhfVE9UQUxfQllURVMpIHtcbiAgICAgICAgICAgIHJldHVybiBcIid0b25Qcm9vZicgZG9tYWluICsgcGF5bG9hZCBleGNlZWRzIDIyMiBieXRlcyBsaW1pdFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVTaWduRGF0YVBheWxvYWQoZGF0YSkge1xuICAgIGlmICghaXNWYWxpZE9iamVjdChkYXRhKSkge1xuICAgICAgICByZXR1cm4gJ1BheWxvYWQgbXVzdCBiZSBhbiBvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWRTdHJpbmcoZGF0YS50eXBlKSkge1xuICAgICAgICByZXR1cm4gXCIndHlwZScgaXMgcmVxdWlyZWRcIjtcbiAgICB9XG4gICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVTaWduRGF0YVBheWxvYWRUZXh0KGRhdGEpO1xuICAgICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlU2lnbkRhdGFQYXlsb2FkQmluYXJ5KGRhdGEpO1xuICAgICAgICBjYXNlICdjZWxsJzpcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZVNpZ25EYXRhUGF5bG9hZENlbGwoZGF0YSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJJbnZhbGlkICd0eXBlJyB2YWx1ZVwiO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlU2lnbkRhdGFQYXlsb2FkVGV4dChkYXRhKSB7XG4gICAgY29uc3QgYWxsb3dlZEtleXMgPSBbJ3R5cGUnLCAndGV4dCcsICduZXR3b3JrJywgJ2Zyb20nXTtcbiAgICBpZiAoaGFzRXh0cmFQcm9wZXJ0aWVzKGRhdGEsIGFsbG93ZWRLZXlzKSkge1xuICAgICAgICByZXR1cm4gJ1RleHQgcGF5bG9hZCBjb250YWlucyBleHRyYSBwcm9wZXJ0aWVzJztcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkU3RyaW5nKGRhdGEudGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIFwiJ3RleHQnIGlzIHJlcXVpcmVkXCI7XG4gICAgfVxuICAgIGlmIChkYXRhLm5ldHdvcmsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIWlzVmFsaWROZXR3b3JrKGRhdGEubmV0d29yaykpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkludmFsaWQgJ25ldHdvcmsnIGZvcm1hdFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhLmZyb20gIT09IHVuZGVmaW5lZCAmJiAhaXNWYWxpZEFkZHJlc3MoZGF0YS5mcm9tKSkge1xuICAgICAgICByZXR1cm4gXCJJbnZhbGlkICdmcm9tJ1wiO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlU2lnbkRhdGFQYXlsb2FkQmluYXJ5KGRhdGEpIHtcbiAgICBjb25zdCBhbGxvd2VkS2V5cyA9IFsndHlwZScsICdieXRlcycsICduZXR3b3JrJywgJ2Zyb20nXTtcbiAgICBpZiAoaGFzRXh0cmFQcm9wZXJ0aWVzKGRhdGEsIGFsbG93ZWRLZXlzKSkge1xuICAgICAgICByZXR1cm4gJ0JpbmFyeSBwYXlsb2FkIGNvbnRhaW5zIGV4dHJhIHByb3BlcnRpZXMnO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWRTdHJpbmcoZGF0YS5ieXRlcykpIHtcbiAgICAgICAgcmV0dXJuIFwiJ2J5dGVzJyBpcyByZXF1aXJlZFwiO1xuICAgIH1cbiAgICBpZiAoZGF0YS5uZXR3b3JrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkTmV0d29yayhkYXRhLm5ldHdvcmspKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJJbnZhbGlkICduZXR3b3JrJyBmb3JtYXRcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YS5mcm9tICE9PSB1bmRlZmluZWQgJiYgIWlzVmFsaWRBZGRyZXNzKGRhdGEuZnJvbSkpIHtcbiAgICAgICAgcmV0dXJuIFwiSW52YWxpZCAnZnJvbSdcIjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVNpZ25EYXRhUGF5bG9hZENlbGwoZGF0YSkge1xuICAgIGNvbnN0IGFsbG93ZWRLZXlzID0gWyd0eXBlJywgJ3NjaGVtYScsICdjZWxsJywgJ25ldHdvcmsnLCAnZnJvbSddO1xuICAgIGlmIChoYXNFeHRyYVByb3BlcnRpZXMoZGF0YSwgYWxsb3dlZEtleXMpKSB7XG4gICAgICAgIHJldHVybiAnQ2VsbCBwYXlsb2FkIGNvbnRhaW5zIGV4dHJhIHByb3BlcnRpZXMnO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWRTdHJpbmcoZGF0YS5zY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBcIidzY2hlbWEnIGlzIHJlcXVpcmVkXCI7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZFN0cmluZyhkYXRhLmNlbGwpKSB7XG4gICAgICAgIHJldHVybiBcIidjZWxsJyBpcyByZXF1aXJlZFwiO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWRCb2MoZGF0YS5jZWxsKSkge1xuICAgICAgICByZXR1cm4gXCJJbnZhbGlkICdjZWxsJyBmb3JtYXQgKG11c3QgYmUgdmFsaWQgYmFzZTY0KVwiO1xuICAgIH1cbiAgICBpZiAoZGF0YS5uZXR3b3JrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkTmV0d29yayhkYXRhLm5ldHdvcmspKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJJbnZhbGlkICduZXR3b3JrJyBmb3JtYXRcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YS5mcm9tICE9PSB1bmRlZmluZWQgJiYgIWlzVmFsaWRBZGRyZXNzKGRhdGEuZnJvbSkpIHtcbiAgICAgICAgcmV0dXJuIFwiSW52YWxpZCAnZnJvbSdcIjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIFZhbGlkYXRlcyB0b25fcHJvb2YgaXRlbSByZWNlaXZlZCBmcm9tIHdhbGxldCBpbiBjb25uZWN0IGV2ZW50LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdmFsaWRhdGVUb25Qcm9vZkl0ZW1SZXBseShkYXRhKSB7XG4gICAgaWYgKCFpc1ZhbGlkT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgIHJldHVybiAndG9uX3Byb29mIGl0ZW0gbXVzdCBiZSBhbiBvYmplY3QnO1xuICAgIH1cbiAgICBjb25zdCBhbGxvd2VkS2V5cyA9IFsnZXJyb3InLCAncHJvb2YnLCAnbmFtZSddO1xuICAgIGlmIChoYXNFeHRyYVByb3BlcnRpZXMoZGF0YSwgYWxsb3dlZEtleXMpKSB7XG4gICAgICAgIHJldHVybiAndG9uX3Byb29mIGl0ZW0gY29udGFpbnMgZXh0cmEgcHJvcGVydGllcyc7XG4gICAgfVxuICAgIGNvbnN0IGhhc1Byb29mID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsICdwcm9vZicpO1xuICAgIGNvbnN0IGhhc0Vycm9yID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsICdlcnJvcicpO1xuICAgIGlmICghaGFzUHJvb2YgJiYgIWhhc0Vycm9yKSB7XG4gICAgICAgIHJldHVybiBcIid0b25fcHJvb2YnIGl0ZW0gbXVzdCBjb250YWluIGVpdGhlciAncHJvb2YnIG9yICdlcnJvcidcIjtcbiAgICB9XG4gICAgaWYgKGhhc1Byb29mICYmIGhhc0Vycm9yKSB7XG4gICAgICAgIHJldHVybiBcIid0b25fcHJvb2YnIGl0ZW0gbXVzdCBjb250YWluIGVpdGhlciAncHJvb2YnIG9yICdlcnJvcicsIG5vdCBib3RoXCI7XG4gICAgfVxuICAgIGlmIChoYXNQcm9vZikge1xuICAgICAgICBjb25zdCBwcm9vZiA9IGRhdGEucHJvb2Y7XG4gICAgICAgIGlmICghaXNWYWxpZE9iamVjdChwcm9vZikpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkludmFsaWQgJ3Byb29mJyBvYmplY3RcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVmFsaWROdW1iZXIocHJvb2YudGltZXN0YW1wKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiSW52YWxpZCAncHJvb2YudGltZXN0YW1wJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IHByb29mLmRvbWFpbjtcbiAgICAgICAgaWYgKCFpc1ZhbGlkT2JqZWN0KGRvbWFpbikpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkludmFsaWQgJ3Byb29mLmRvbWFpbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVmFsaWROdW1iZXIoZG9tYWluLmxlbmd0aEJ5dGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiSW52YWxpZCAncHJvb2YuZG9tYWluLmxlbmd0aEJ5dGVzJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNWYWxpZFN0cmluZyhkb21haW4udmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJJbnZhbGlkICdwcm9vZi5kb21haW4udmFsdWUnXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ5IHRvIHZlcmlmeSB0aGF0IHByb3ZpZGVkIGJ5dGUgbGVuZ3RoIG1hdGNoZXMgYWN0dWFsIGJ5dGUgbGVuZ3RoIG9mIHZhbHVlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVyQXZhaWxhYmxlID0gdHlwZW9mIFRleHRFbmNvZGVyICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIGNvbnN0IGFjdHVhbExlbmd0aCA9IGVuY29kZXJBdmFpbGFibGVcbiAgICAgICAgICAgICAgICA/IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkb21haW4udmFsdWUpLmxlbmd0aFxuICAgICAgICAgICAgICAgIDogZG9tYWluLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChhY3R1YWxMZW5ndGggIT09IGRvbWFpbi5sZW5ndGhCeXRlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIidwcm9vZi5kb21haW4ubGVuZ3RoQnl0ZXMnIGRvZXMgbm90IG1hdGNoICdwcm9vZi5kb21haW4udmFsdWUnXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgZW52aXJvbm1lbnQgaXNzdWVzOyBiZXN0LWVmZm9ydCB2YWxpZGF0aW9uXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RyaW5nKHByb29mLnBheWxvYWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJJbnZhbGlkICdwcm9vZi5wYXlsb2FkJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNWYWxpZFN0cmluZyhwcm9vZi5zaWduYXR1cmUpIHx8ICFCQVNFNjRfUkVHRVgudGVzdChwcm9vZi5zaWduYXR1cmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJJbnZhbGlkICdwcm9vZi5zaWduYXR1cmUnIGZvcm1hdFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNFcnJvcikge1xuICAgICAgICBjb25zdCBlcnJvciA9IGRhdGEuZXJyb3I7XG4gICAgICAgIGlmICghaXNWYWxpZE9iamVjdChlcnJvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkludmFsaWQgJ2Vycm9yJyBvYmplY3RcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbGxvd2VkRXJyb3JLZXlzID0gWydjb2RlJywgJ21lc3NhZ2UnXTtcbiAgICAgICAgaWYgKGhhc0V4dHJhUHJvcGVydGllcyhlcnJvciwgYWxsb3dlZEVycm9yS2V5cykpIHtcbiAgICAgICAgICAgIHJldHVybiAndG9uX3Byb29mIGVycm9yIGNvbnRhaW5zIGV4dHJhIHByb3BlcnRpZXMnO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNWYWxpZE51bWJlcihlcnJvci5jb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiSW52YWxpZCAnZXJyb3IuY29kZSdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVmFsaWRTdHJpbmcoZXJyb3IubWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkludmFsaWQgJ2Vycm9yLm1lc3NhZ2UnXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUJhc2U2NChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBwYWRkZWRMZW5ndGggPSBkYXRhLmxlbmd0aCArICgoNCAtIChkYXRhLmxlbmd0aCAlIDQpKSAlIDQpO1xuICAgIHJldHVybiBkYXRhLnJlcGxhY2UoLy0vZywgJysnKS5yZXBsYWNlKC9fL2csICcvJykucGFkRW5kKHBhZGRlZExlbmd0aCwgJz0nKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIFBhc2NhbENhc2UgKG9yIGNhbWVsQ2FzZSkgc3RyaW5nIHRvIGtlYmFiLWNhc2UuXG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKiAtIFwiUGFzY2FsQ2FzZVwiIOKGkiBcInBhc2NhbC1jYXNlXCJcbiAqIC0gXCJjYW1lbENhc2VFeGFtcGxlXCIg4oaSIFwiY2FtZWwtY2FzZS1leGFtcGxlXCJcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgaW5wdXQgc3RyaW5nIGluIFBhc2NhbENhc2Ugb3IgY2FtZWxDYXNlIGZvcm1hdC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQga2ViYWItY2FzZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHBhc2NhbFRvS2ViYWIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvKFthLXowLTldKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbn1cbi8qKlxuICogQ29sbGVjdHMgc3RhdGljIGNvbm5lY3Rpb24gbWV0cmljcyBmcm9tIHRoZSBicm93c2VyJ3MgUGVyZm9ybWFuY2UgQVBJLlxuICogVFRGQiBpcyBtZWFzdXJlZCBvbmNlIGF0IHBhZ2UgbG9hZCBhbmQgZG9lc24ndCBjaGFuZ2UuXG4gKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyBzdGF0aWMgY29ubmVjdGlvbiBtZXRyaWNzIChUVEZCKSBvciBlbXB0eSBvYmplY3QgaWYgbm90IGF2YWlsYWJsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGljQ29ubmVjdGlvbk1ldHJpY3MoKSB7XG4gICAgY29uc3QgbWV0cmljcyA9IHt9O1xuICAgIC8vIEdldCBUVEZCIGZyb20gTmF2aWdhdGlvbiBUaW1pbmcgQVBJIChzdGF0aWMsIG1lYXN1cmVkIG9uY2UgYXQgcGFnZSBsb2FkKVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5hdkVudHJpZXMgPSBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlUeXBlKCduYXZpZ2F0aW9uJyk7XG4gICAgICAgIGlmIChuYXZFbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG5hdiA9IG5hdkVudHJpZXNbMF07XG4gICAgICAgICAgICBpZiAobmF2LnJlc3BvbnNlU3RhcnQgJiYgbmF2LnJlcXVlc3RTdGFydCkge1xuICAgICAgICAgICAgICAgIG1ldHJpY3MuY29ubl90dGZiID0gTWF0aC5yb3VuZChuYXYucmVzcG9uc2VTdGFydCAtIG5hdi5yZXF1ZXN0U3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFBlcmZvcm1hbmNlIEFQSSBub3QgYXZhaWxhYmxlIG9yIGVycm9yIG9jY3VycmVkXG4gICAgfVxuICAgIHJldHVybiBtZXRyaWNzO1xufVxuLyoqXG4gKiBDb2xsZWN0cyBkeW5hbWljIGNvbm5lY3Rpb24gbWV0cmljcyBmcm9tIHRoZSBicm93c2VyJ3MgTmV0d29yayBJbmZvcm1hdGlvbiBBUEkuXG4gKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyBkeW5hbWljIGNvbm5lY3Rpb24gbWV0cmljcyAoUlRULCBuZXR3b3JrIHR5cGUpIG9yIGVtcHR5IG9iamVjdCBpZiBub3QgYXZhaWxhYmxlLlxuICovXG5mdW5jdGlvbiBnZXREeW5hbWljQ29ubmVjdGlvbk1ldHJpY3MoKSB7XG4gICAgY29uc3QgbWV0cmljcyA9IHt9O1xuICAgIC8vIEdldCBSVFQgYW5kIG5ldHdvcmsgdHlwZSBmcm9tIE5ldHdvcmsgSW5mb3JtYXRpb24gQVBJIChkeW5hbWljLCBjYW4gY2hhbmdlKVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5hdmlnYXRvcldpdGhDb25uZWN0aW9uID0gbmF2aWdhdG9yO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gbmF2aWdhdG9yV2l0aENvbm5lY3Rpb24uY29ubmVjdGlvbiB8fFxuICAgICAgICAgICAgbmF2aWdhdG9yV2l0aENvbm5lY3Rpb24ubW96Q29ubmVjdGlvbiB8fFxuICAgICAgICAgICAgbmF2aWdhdG9yV2l0aENvbm5lY3Rpb24ud2Via2l0Q29ubmVjdGlvbjtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLnJ0dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWV0cmljcy5jb25uX3J0dCA9IGNvbm5lY3Rpb24ucnR0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24uZWZmZWN0aXZlVHlwZSkge1xuICAgICAgICAgICAgICAgIG1ldHJpY3MuY29ubl9uZXR3b3JrX3R5cGUgPSBjb25uZWN0aW9uLmVmZmVjdGl2ZVR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25uZWN0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBtZXRyaWNzLmNvbm5fbmV0d29ya190eXBlID0gY29ubmVjdGlvbi50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIE5ldHdvcmsgSW5mb3JtYXRpb24gQVBJIG5vdCBhdmFpbGFibGUgb3IgZXJyb3Igb2NjdXJyZWRcbiAgICB9XG4gICAgcmV0dXJuIG1ldHJpY3M7XG59XG5cbmNsYXNzIEFuYWx5dGljc01hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJhY2tvZmYgPSAxO1xuICAgICAgICB0aGlzLnNob3VsZFNlbmQgPSB0cnVlO1xuICAgICAgICB0aGlzLmJhdGNoVGltZW91dE1zID0gKF9hID0gb3B0aW9ucy5iYXRjaFRpbWVvdXRNcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMjAwMDtcbiAgICAgICAgdGhpcy5jdXJyZW50QmF0Y2hUaW1lb3V0TXMgPSB0aGlzLmJhdGNoVGltZW91dE1zO1xuICAgICAgICB0aGlzLm1heEJhdGNoU2l6ZSA9IChfYiA9IG9wdGlvbnMubWF4QmF0Y2hTaXplKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxMDA7XG4gICAgICAgIHRoaXMuYW5hbHl0aWNzVXJsID0gKF9jID0gb3B0aW9ucy5hbmFseXRpY3NVcmwpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICdodHRwczovL2FuYWx5dGljcy50b24ub3JnL2V2ZW50cyc7XG4gICAgICAgIHRoaXMubW9kZSA9IChfZCA9IG9wdGlvbnMubW9kZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJ3RlbGVtZXRyeSc7XG4gICAgICAgIHRoaXMuYmFzZUV2ZW50ID0gT2JqZWN0LmFzc2lnbih7IHN1YnN5c3RlbTogJ2RhcHAtc2RrJywgdmVyc2lvbjogdG9uQ29ubmVjdFNka1ZlcnNpb24sIGNsaWVudF9lbnZpcm9ubWVudDogKF9mID0gKF9lID0gb3B0aW9ucy5lbnZpcm9ubWVudCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmdldENsaWVudEVudmlyb25tZW50KSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY2FsbChfZSkgfSwgZ2V0U3RhdGljQ29ubmVjdGlvbk1ldHJpY3MoKSk7XG4gICAgICAgIHRoaXMuYWRkV2luZG93Rm9jdXNBbmRCbHVyU3Vic2NyaXB0aW9ucygpO1xuICAgIH1cbiAgICBzY29wZWQoc2hhcmVkRGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHRoaXMsIHtcbiAgICAgICAgICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IHByb3AudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcE5hbWUuc3RhcnRzV2l0aCgnZW1pdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50TmFtZVBhc2NhbCA9IHByb3BOYW1lLnJlcGxhY2UoJ2VtaXQnLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50TmFtZUtlYmFiID0gcGFzY2FsVG9LZWJhYihldmVudE5hbWVQYXNjYWwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleGVjdXRlZERhdGEgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoc2hhcmVkRGF0YSAhPT0gbnVsbCAmJiBzaGFyZWREYXRhICE9PSB2b2lkIDAgPyBzaGFyZWREYXRhIDoge30pLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlKCkgOiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5lbWl0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGV2ZW50X25hbWU6IGV2ZW50TmFtZUtlYmFiIH0sIGV4ZWN1dGVkRGF0YSksIGV2ZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVtaXQoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnb2ZmJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYWNlSWQgPSAoX2EgPSBldmVudC50cmFjZV9pZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVVVJRHY3KCk7XG4gICAgICAgIGNvbnN0IGR5bmFtaWNNZXRyaWNzID0gZ2V0RHluYW1pY0Nvbm5lY3Rpb25NZXRyaWNzKCk7XG4gICAgICAgIGNvbnN0IGVuaGFuY2VkRXZlbnQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VFdmVudCksIGR5bmFtaWNNZXRyaWNzKSwgZXZlbnQpLCB7IGV2ZW50X2lkOiBVVUlEdjcoKSwgY2xpZW50X3RpbWVzdGFtcDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksIHRyYWNlX2lkOiB0cmFjZUlkIH0pO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZEV2ZW50ID0gdGhpcy5tb2RlID09PSAndGVsZW1ldHJ5JyA/IHRoaXMuZmlsdGVyRnVsbE1vZGVGaWVsZHMoZW5oYW5jZWRFdmVudCkgOiBlbmhhbmNlZEV2ZW50O1xuICAgICAgICBpZiAoaXNRYU1vZGVFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKGZpbHRlcmVkRXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRzLnB1c2goZmlsdGVyZWRFdmVudCk7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50cy5sZW5ndGggPj0gdGhpcy5tYXhCYXRjaFNpemUpIHtcbiAgICAgICAgICAgIHZvaWQgdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lb3V0KCk7XG4gICAgfVxuICAgIHN0YXJ0VGltZW91dCgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dElkIHx8IHRoaXMuaXNQcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHZvaWQgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9LCB0aGlzLmN1cnJlbnRCYXRjaFRpbWVvdXRNcyk7XG4gICAgfVxuICAgIGZsdXNoKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNQcm9jZXNzaW5nIHx8IHRoaXMuZXZlbnRzLmxlbmd0aCA9PT0gMCB8fCAhdGhpcy5zaG91bGRTZW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgICAgIHRoaXMuaXNQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50c1RvU2VuZCA9IHRoaXMuZXh0cmFjdEV2ZW50c1RvU2VuZCgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnByb2Nlc3NFdmVudHNCYXRjaChldmVudHNUb1NlbmQpO1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdBbmFseXRpY3MgZXZlbnRzIHNlbnQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmVFdmVudHMoZXZlbnRzVG9TZW5kKTtcbiAgICAgICAgICAgICAgICBsb2dFcnJvcignRmFpbGVkIHRvIHNlbmQgYW5hbHl0aWNzIGV2ZW50czonLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVOZXh0Rmx1c2hJZk5lZWRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXh0cmFjdEV2ZW50c1RvU2VuZCgpIHtcbiAgICAgICAgY29uc3QgZXZlbnRzVG9TZW5kID0gdGhpcy5ldmVudHMuc2xpY2UoMCwgdGhpcy5tYXhCYXRjaFNpemUpO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IHRoaXMuZXZlbnRzLnNsaWNlKHRoaXMubWF4QmF0Y2hTaXplKTtcbiAgICAgICAgcmV0dXJuIGV2ZW50c1RvU2VuZDtcbiAgICB9XG4gICAgcHJvY2Vzc0V2ZW50c0JhdGNoKGV2ZW50c1RvU2VuZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbG9nRGVidWcoJ1NlbmRpbmcgYW5hbHl0aWNzIGV2ZW50cy4uLicsIGV2ZW50c1RvU2VuZC5sZW5ndGgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc2VuZEV2ZW50cyhldmVudHNUb1NlbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVW5rbm93bkVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVSZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgc3RhdHVzVGV4dCB9ID0gcmVzcG9uc2U7XG4gICAgICAgIGlmICh0aGlzLmlzVG9vTWFueVJlcXVlc3RzKHN0YXR1cykpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVG9vTWFueVJlcXVlc3RzKHN0YXR1cywgc3RhdHVzVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc0NsaWVudEVycm9yKHN0YXR1cykpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xpZW50RXJyb3Ioc3RhdHVzLCBzdGF0dXNUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzU2VydmVyRXJyb3Ioc3RhdHVzKSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVVbmtub3duRXJyb3IoeyBzdGF0dXMsIHN0YXR1c1RleHQgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdG9yZUV2ZW50cyhldmVudHNUb1NlbmQpIHtcbiAgICAgICAgdGhpcy5ldmVudHMudW5zaGlmdCguLi5ldmVudHNUb1NlbmQpO1xuICAgIH1cbiAgICBzY2hlZHVsZU5leHRGbHVzaElmTmVlZGVkKCkge1xuICAgICAgICBpZiAodGhpcy5ldmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kRXZlbnRzKGV2ZW50cykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGZldGNoKHRoaXMuYW5hbHl0aWNzVXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAnWC1DbGllbnQtVGltZXN0YW1wJzogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZXZlbnRzKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpc0NsaWVudEVycm9yKHN0YXR1cykge1xuICAgICAgICByZXR1cm4gKHN0YXR1cyA+PSBBbmFseXRpY3NNYW5hZ2VyLkhUVFBfU1RBVFVTLkNMSUVOVF9FUlJPUl9TVEFSVCAmJlxuICAgICAgICAgICAgc3RhdHVzIDwgQW5hbHl0aWNzTWFuYWdlci5IVFRQX1NUQVRVUy5TRVJWRVJfRVJST1JfU1RBUlQpO1xuICAgIH1cbiAgICBpc1NlcnZlckVycm9yKHN0YXR1cykge1xuICAgICAgICByZXR1cm4gc3RhdHVzID49IEFuYWx5dGljc01hbmFnZXIuSFRUUF9TVEFUVVMuU0VSVkVSX0VSUk9SX1NUQVJUO1xuICAgIH1cbiAgICBpc1Rvb01hbnlSZXF1ZXN0cyhzdGF0dXMpIHtcbiAgICAgICAgcmV0dXJuIHN0YXR1cyA9PT0gQW5hbHl0aWNzTWFuYWdlci5IVFRQX1NUQVRVUy5UT09fTUFOWV9SRVFVRVNUUztcbiAgICB9XG4gICAgaGFuZGxlQ2xpZW50RXJyb3Ioc3RhdHVzLCBzdGF0dXNUZXh0KSB7XG4gICAgICAgIC8vIERvbid0IHJldHJ5XG4gICAgICAgIGxvZ0Vycm9yKCdGYWlsZWQgdG8gc2VuZCBhbmFseXRpY3MgZXZlbnRzOicsIG5ldyBUb25Db25uZWN0RXJyb3IoYEFuYWx5dGljcyBBUEkgZXJyb3I6ICR7c3RhdHVzfSAke3N0YXR1c1RleHR9YCkpO1xuICAgIH1cbiAgICBoYW5kbGVVbmtub3duRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFja29mZiA8IEFuYWx5dGljc01hbmFnZXIuTUFYX0JBQ0tPRkZfQVRURU1QVFMpIHtcbiAgICAgICAgICAgIHRoaXMuYmFja29mZisrO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50QmF0Y2hUaW1lb3V0TXMgKj0gQW5hbHl0aWNzTWFuYWdlci5CQUNLT0ZGX01VTFRJUExJRVI7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKGBVbmtub3duIGFuYWx5dGljcyBBUEkgZXJyb3I6ICR7ZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRCYXRjaFRpbWVvdXRNcyA9IHRoaXMuYmF0Y2hUaW1lb3V0TXM7XG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYgPSAxO1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBEb24ndCByZXRyeVxuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVRvb01hbnlSZXF1ZXN0cyhzdGF0dXMsIHN0YXR1c1RleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcihgQW5hbHl0aWNzIEFQSSBlcnJvcjogJHtzdGF0dXN9ICR7c3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgYWRkV2luZG93Rm9jdXNBbmRCbHVyU3Vic2NyaXB0aW9ucygpIHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgICBpZiAoIWRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3VsZFNlbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvdWxkU2VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVOZXh0Rmx1c2hJZk5lZWRlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dFcnJvcignQ2Fubm90IHN1YnNjcmliZSB0byB0aGUgZG9jdW1lbnQudmlzaWJpbGl0eWNoYW5nZTogJywgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZTtcbiAgICB9XG4gICAgZ2V0UGVuZGluZ0V2ZW50c0NvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudHMubGVuZ3RoO1xuICAgIH1cbiAgICBmaWx0ZXJGdWxsTW9kZUZpZWxkcyhldmVudCkge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50KTtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBBbmFseXRpY3NNYW5hZ2VyLkZVTExfTU9ERV9GSUVMRFMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBmaWx0ZXJlZFtmaWVsZF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2FsbGV0X2FkZHJlc3MgaXMga2VwdCBmb3IgZXJyb3IgZXZlbnRzLCByZW1vdmVkIGZvciBub24tZXJyb3IgZXZlbnRzXG4gICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9ICdldmVudF9uYW1lJyBpbiBldmVudCA/IFN0cmluZyhldmVudC5ldmVudF9uYW1lKSA6ICcnO1xuICAgICAgICBjb25zdCBpc0Vycm9yRXZlbnQgPSAnZXJyb3JfY29kZScgaW4gZXZlbnQgfHxcbiAgICAgICAgICAgICdlcnJvcl9tZXNzYWdlJyBpbiBldmVudCB8fFxuICAgICAgICAgICAgZXZlbnROYW1lLmluY2x1ZGVzKCdlcnJvcicpIHx8XG4gICAgICAgICAgICBldmVudE5hbWUgPT09ICdjb25uZWN0aW9uLWVycm9yJyB8fFxuICAgICAgICAgICAgZXZlbnROYW1lID09PSAndHJhbnNhY3Rpb24tc2lnbmluZy1mYWlsZWQnIHx8XG4gICAgICAgICAgICBldmVudE5hbWUgPT09ICdzaWduLWRhdGEtcmVxdWVzdC1mYWlsZWQnO1xuICAgICAgICBpZiAoIWlzRXJyb3JFdmVudCAmJiAnd2FsbGV0X2FkZHJlc3MnIGluIGZpbHRlcmVkKSB7XG4gICAgICAgICAgICBkZWxldGUgZmlsdGVyZWQud2FsbGV0X2FkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkO1xuICAgIH1cbiAgICBzZXRXYWxsZXRMaXN0RG93bmxvYWREdXJhdGlvbihkdXJhdGlvbikge1xuICAgICAgICB0aGlzLmJhc2VFdmVudCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlRXZlbnQpLCB7IHdhbGxldF9saXN0X2Rvd25sb2FkX2R1cmF0aW9uOiBkdXJhdGlvbiB9KTtcbiAgICB9XG59XG5BbmFseXRpY3NNYW5hZ2VyLkhUVFBfU1RBVFVTID0ge1xuICAgIFRPT19NQU5ZX1JFUVVFU1RTOiA0MjksXG4gICAgQ0xJRU5UX0VSUk9SX1NUQVJUOiA0MDAsXG4gICAgU0VSVkVSX0VSUk9SX1NUQVJUOiA1MDBcbn07XG5BbmFseXRpY3NNYW5hZ2VyLk1BWF9CQUNLT0ZGX0FUVEVNUFRTID0gNTtcbkFuYWx5dGljc01hbmFnZXIuQkFDS09GRl9NVUxUSVBMSUVSID0gMjtcbkFuYWx5dGljc01hbmFnZXIuRlVMTF9NT0RFX0ZJRUxEUyA9IFtcbiAgICAndXNlcl9pZCcsXG4gICAgJ3RnX2lkJyxcbiAgICAnbG9jYWxlJyxcbiAgICAndG1hX2lzX3ByZW1pdW0nXG5dO1xuXG4vKipcbiAqIEEgY29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgRXZlbnREaXNwYXRjaGVyIHRoYXQgZGlzcGF0Y2hlcyBldmVudHMgdG8gdGhlIGJyb3dzZXIgd2luZG93LlxuICovXG5jbGFzcyBCcm93c2VyRXZlbnREaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB3aW5kb3cgb2JqZWN0LCBwb3NzaWJseSB1bmRlZmluZWQgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaGVzIGFuIGV2ZW50IHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIGRldGFpbHMgdG8gdGhlIGJyb3dzZXIgd2luZG93LlxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZGlzcGF0Y2guXG4gICAgICogQHBhcmFtIGV2ZW50RGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSBldmVudCB0byBkaXNwYXRjaC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBldmVudCBoYXMgYmVlbiBkaXNwYXRjaGVkLlxuICAgICAqL1xuICAgIGRpc3BhdGNoRXZlbnQoZXZlbnROYW1lLCBldmVudERldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgeyBkZXRhaWw6IGV2ZW50RGV0YWlscyB9KTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMud2luZG93KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBicm93c2VyIHdpbmRvdy5cbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiBmb3IuXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gVGhlIGxpc3RlbmVyIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgbGlzdGVuZXIuXG4gICAgICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IHJlbW92ZXMgdGhlIGxpc3RlbmVyLlxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gdGhpcy53aW5kb3cpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMud2luZG93KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRWZXJzaW9uSW5mbyh2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgJ0B0b25jb25uZWN0L3Nkayc6IHZlcnNpb24udG9uX2Nvbm5lY3Rfc2RrX2xpYiB8fCAnJyxcbiAgICAgICAgJ0B0b25jb25uZWN0L3VpJzogdmVyc2lvbi50b25fY29ubmVjdF91aV9saWIgfHwgJydcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRUb25Db25uZWN0RXZlbnQoZGV0YWlsKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICByZXR1cm4ge1xuICAgICAgICB2ZXJzaW9uczogYnVpbGRWZXJzaW9uSW5mbyhkZXRhaWwuY3VzdG9tX2RhdGEpLFxuICAgICAgICBuZXR3b3JrX2lkOiAoX2EgPSBkZXRhaWwuY3VzdG9tX2RhdGEuY2hhaW5faWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnLFxuICAgICAgICBjbGllbnRfaWQ6IChfYiA9IGRldGFpbC5jdXN0b21fZGF0YS5jbGllbnRfaWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLFxuICAgICAgICB3YWxsZXRfaWQ6IChfYyA9IGRldGFpbC5jdXN0b21fZGF0YS53YWxsZXRfaWQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICcnLFxuICAgICAgICB3YWxsZXRfYWRkcmVzczogKF9kID0gZGV0YWlsLndhbGxldF9hZGRyZXNzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAnJyxcbiAgICAgICAgd2FsbGV0X2FwcF9uYW1lOiAoX2UgPSBkZXRhaWwud2FsbGV0X3R5cGUpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6ICcnLFxuICAgICAgICB3YWxsZXRfYXBwX3ZlcnNpb246IChfZiA9IGRldGFpbC53YWxsZXRfdmVyc2lvbikgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogJycsXG4gICAgICAgIHdhbGxldF9zdGF0ZV9pbml0OiAoX2cgPSBkZXRhaWwud2FsbGV0X3N0YXRlX2luaXQpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6ICcnLFxuICAgICAgICB0cmFjZV9pZDogKF9oID0gZGV0YWlsLnRyYWNlX2lkKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiB1bmRlZmluZWRcbiAgICB9O1xufVxuZnVuY3Rpb24gYmluZEV2ZW50c1RvKGV2ZW50RGlzcGF0Y2hlciwgYW5hbHl0aWNzKSB7XG4gICAgZXZlbnREaXNwYXRjaGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3Rvbi1jb25uZWN0LXVpLXdhbGxldC1tb2RhbC1vcGVuZWQnLCBldmVudCA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBkZXRhaWwgfSA9IGV2ZW50O1xuICAgICAgICBhbmFseXRpY3MuZW1pdENvbm5lY3Rpb25TdGFydGVkKHtcbiAgICAgICAgICAgIGNsaWVudF9pZDogZGV0YWlsLmNsaWVudF9pZCB8fCAnJyxcbiAgICAgICAgICAgIHZlcnNpb25zOiBidWlsZFZlcnNpb25JbmZvKGRldGFpbC5jdXN0b21fZGF0YSksXG4gICAgICAgICAgICBtYWluX3NjcmVlbjogZGV0YWlsLnZpc2libGVfd2FsbGV0cyxcbiAgICAgICAgICAgIHRyYWNlX2lkOiAoX2EgPSBkZXRhaWwudHJhY2VfaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBldmVudERpc3BhdGNoZXIuYWRkRXZlbnRMaXN0ZW5lcigndG9uLWNvbm5lY3QtdWktc2VsZWN0ZWQtd2FsbGV0JywgZXZlbnQgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB7IGRldGFpbCB9ID0gZXZlbnQ7XG4gICAgICAgIGFuYWx5dGljcy5lbWl0Q29ubmVjdGlvblNlbGVjdGVkV2FsbGV0KHtcbiAgICAgICAgICAgIGNsaWVudF9pZDogZGV0YWlsLmNsaWVudF9pZCB8fCAnJyxcbiAgICAgICAgICAgIHZlcnNpb25zOiBidWlsZFZlcnNpb25JbmZvKGRldGFpbC5jdXN0b21fZGF0YSksXG4gICAgICAgICAgICBtYWluX3NjcmVlbjogZGV0YWlsLnZpc2libGVfd2FsbGV0cyxcbiAgICAgICAgICAgIHdhbGxldHNfbWVudTogZGV0YWlsLndhbGxldHNfbWVudSxcbiAgICAgICAgICAgIHRyYWNlX2lkOiAoX2EgPSBkZXRhaWwudHJhY2VfaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHdhbGxldF9hcHBfbmFtZTogKF9iID0gZGV0YWlsLndhbGxldF90eXBlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyxcbiAgICAgICAgICAgIHdhbGxldF9yZWRpcmVjdF9tZXRob2Q6IGRldGFpbC53YWxsZXRfcmVkaXJlY3RfbWV0aG9kLFxuICAgICAgICAgICAgd2FsbGV0X3JlZGlyZWN0X2xpbms6IGRldGFpbC53YWxsZXRfcmVkaXJlY3RfbGlua1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBldmVudERpc3BhdGNoZXIuYWRkRXZlbnRMaXN0ZW5lcigndG9uLWNvbm5lY3QtY29ubmVjdGlvbi1jb21wbGV0ZWQnLCBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGV0YWlsIH0gPSBldmVudDtcbiAgICAgICAgYW5hbHl0aWNzLmVtaXRDb25uZWN0aW9uQ29tcGxldGVkKGJ1aWxkVG9uQ29ubmVjdEV2ZW50KGRldGFpbCkpO1xuICAgIH0pO1xuICAgIGV2ZW50RGlzcGF0Y2hlci5hZGRFdmVudExpc3RlbmVyKCd0b24tY29ubmVjdC1jb25uZWN0aW9uLWVycm9yJywgZXZlbnQgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB7IGRldGFpbCB9ID0gZXZlbnQ7XG4gICAgICAgIGFuYWx5dGljcy5lbWl0Q29ubmVjdGlvbkVycm9yKHtcbiAgICAgICAgICAgIGNsaWVudF9pZDogZGV0YWlsLmN1c3RvbV9kYXRhLmNsaWVudF9pZCB8fCAnJyxcbiAgICAgICAgICAgIHdhbGxldF9pZDogZGV0YWlsLmN1c3RvbV9kYXRhLndhbGxldF9pZCB8fCAnJyxcbiAgICAgICAgICAgIGVycm9yX2NvZGU6IChfYSA9IGRldGFpbC5lcnJvcl9jb2RlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLFxuICAgICAgICAgICAgZXJyb3JfbWVzc2FnZTogZGV0YWlsLmVycm9yX21lc3NhZ2UsXG4gICAgICAgICAgICB0cmFjZV9pZDogKF9iID0gZGV0YWlsLnRyYWNlX2lkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgZXZlbnREaXNwYXRjaGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3Rvbi1jb25uZWN0LWRpc2Nvbm5lY3Rpb24nLCBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGV0YWlsIH0gPSBldmVudDtcbiAgICAgICAgYW5hbHl0aWNzLmVtaXREaXNjb25uZWN0aW9uKGJ1aWxkVG9uQ29ubmVjdEV2ZW50KGRldGFpbCkpO1xuICAgIH0pO1xuICAgIGV2ZW50RGlzcGF0Y2hlci5hZGRFdmVudExpc3RlbmVyKCd0b24tY29ubmVjdC10cmFuc2FjdGlvbi1zZW50LWZvci1zaWduYXR1cmUnLCBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGV0YWlsIH0gPSBldmVudDtcbiAgICAgICAgYW5hbHl0aWNzLmVtaXRUcmFuc2FjdGlvblNlbnQoYnVpbGRUb25Db25uZWN0RXZlbnQoZGV0YWlsKSk7XG4gICAgfSk7XG4gICAgZXZlbnREaXNwYXRjaGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3Rvbi1jb25uZWN0LXRyYW5zYWN0aW9uLXNpZ25lZCcsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgeyBkZXRhaWwgfSA9IGV2ZW50O1xuICAgICAgICBhbmFseXRpY3MuZW1pdFRyYW5zYWN0aW9uU2lnbmVkKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGRUb25Db25uZWN0RXZlbnQoZGV0YWlsKSksIHsgc2lnbmVkX2JvYzogZXZlbnQuZGV0YWlsLnNpZ25lZF90cmFuc2FjdGlvbiB9KSk7XG4gICAgfSk7XG4gICAgZXZlbnREaXNwYXRjaGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3Rvbi1jb25uZWN0LXRyYW5zYWN0aW9uLXNpZ25pbmctZmFpbGVkJywgZXZlbnQgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgZGV0YWlsIH0gPSBldmVudDtcbiAgICAgICAgYW5hbHl0aWNzLmVtaXRUcmFuc2FjdGlvblNpZ25pbmdGYWlsZWQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZFRvbkNvbm5lY3RFdmVudChkZXRhaWwpKSwgeyB2YWxpZF91bnRpbDogTnVtYmVyKGRldGFpbC52YWxpZF91bnRpbCksIG1lc3NhZ2VzOiBkZXRhaWwubWVzc2FnZXMubWFwKG1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogKF9hID0gbWVzc2FnZS5hZGRyZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50OiAoX2IgPSBtZXNzYWdlLmFtb3VudCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycsXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IChfYyA9IG1lc3NhZ2UucGF5bG9hZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJycsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlX2luaXQ6IChfZCA9IG1lc3NhZ2Uuc3RhdGVfaW5pdCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLCBlcnJvcl9tZXNzYWdlOiBkZXRhaWwuZXJyb3JfbWVzc2FnZSwgZXJyb3JfY29kZTogKF9hID0gZGV0YWlsLmVycm9yX2NvZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDAgfSkpO1xuICAgIH0pO1xuICAgIGV2ZW50RGlzcGF0Y2hlci5hZGRFdmVudExpc3RlbmVyKCd0b24tY29ubmVjdC1zaWduLWRhdGEtcmVxdWVzdC1pbml0aWF0ZWQnLCBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGV0YWlsIH0gPSBldmVudDtcbiAgICAgICAgYW5hbHl0aWNzID09PSBudWxsIHx8IGFuYWx5dGljcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5hbHl0aWNzLmVtaXRTaWduRGF0YVJlcXVlc3RJbml0aWF0ZWQoYnVpbGRUb25Db25uZWN0RXZlbnQoZGV0YWlsKSk7XG4gICAgfSk7XG4gICAgZXZlbnREaXNwYXRjaGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3Rvbi1jb25uZWN0LXNpZ24tZGF0YS1yZXF1ZXN0LWNvbXBsZXRlZCcsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgeyBkZXRhaWwgfSA9IGV2ZW50O1xuICAgICAgICBhbmFseXRpY3MgPT09IG51bGwgfHwgYW5hbHl0aWNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbmFseXRpY3MuZW1pdFNpZ25EYXRhUmVxdWVzdENvbXBsZXRlZChidWlsZFRvbkNvbm5lY3RFdmVudChkZXRhaWwpKTtcbiAgICB9KTtcbiAgICBldmVudERpc3BhdGNoZXIuYWRkRXZlbnRMaXN0ZW5lcigndG9uLWNvbm5lY3Qtc2lnbi1kYXRhLXJlcXVlc3QtZmFpbGVkJywgZXZlbnQgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgZGV0YWlsIH0gPSBldmVudDtcbiAgICAgICAgbGV0IHNpZ25EYXRhVmFsdWUgPSAnJztcbiAgICAgICAgbGV0IHNpZ25EYXRhU2NoZW1hID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZGV0YWlsLmRhdGEudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBzaWduRGF0YVZhbHVlID0gZGV0YWlsLmRhdGEudGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGV0YWlsLmRhdGEudHlwZSA9PT0gJ2NlbGwnKSB7XG4gICAgICAgICAgICBzaWduRGF0YVZhbHVlID0gZGV0YWlsLmRhdGEuY2VsbDtcbiAgICAgICAgICAgIHNpZ25EYXRhU2NoZW1hID0gZGV0YWlsLmRhdGEuc2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXRhaWwuZGF0YS50eXBlID09PSAnYmluYXJ5Jykge1xuICAgICAgICAgICAgc2lnbkRhdGFWYWx1ZSA9IGRldGFpbC5kYXRhLmJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGFuYWx5dGljcyA9PT0gbnVsbCB8fCBhbmFseXRpY3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFuYWx5dGljcy5lbWl0U2lnbkRhdGFSZXF1ZXN0RmFpbGVkKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGRUb25Db25uZWN0RXZlbnQoZGV0YWlsKSksIHsgc2lnbl9kYXRhX3R5cGU6IGRldGFpbC5kYXRhLnR5cGUsIHNpZ25fZGF0YV92YWx1ZTogc2lnbkRhdGFWYWx1ZSwgc2lnbl9kYXRhX3NjaGVtYTogc2lnbkRhdGFTY2hlbWEsIGVycm9yX2NvZGU6IChfYSA9IGRldGFpbC5lcnJvcl9jb2RlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLCBlcnJvcl9tZXNzYWdlOiBkZXRhaWwuZXJyb3JfbWVzc2FnZSB9KSk7XG4gICAgfSk7XG59XG5cbmNsYXNzIERlZmF1bHRFbnZpcm9ubWVudCB7XG4gICAgZ2V0Q2xpZW50RW52aXJvbm1lbnQoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgZ2V0QnJvd3NlcigpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBnZXRMb2NhbGUoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgZ2V0UGxhdGZvcm0oKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgZ2V0VGVsZWdyYW1Vc2VyKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuY29uc3Qgc3RhdGUgPSB7fTtcbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIFdhbGxldENvbm5lY3QgaW50ZWdyYXRpb24uXG4gKlxuICogVGhpcyBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCBvbmNlIGJlZm9yZSB1c2luZyBXYWxsZXRDb25uZWN0IGZlYXR1cmVzLlxuICogQSBzZWNvbmQgY2FsbCB3aWxsIHRocm93IGFuIGVycm9yIHRvIHByZXZlbnQgYWNjaWRlbnRhbCByZS1pbml0aWFsaXphdGlvbi5cbiAqXG4gKiBAcGFyYW0gVW5pdmVyc2FsQ29ubmVjdG9yQ2xzIC0gQSBVbml2ZXJzYWxDb25uZWN0b3IgY2xhc3MgaW1wb3J0ZWQgZnJvbSAnQHJlb3duL2FwcGtpdC11bml2ZXJzYWwtY29ubmVjdG9yJ1xuICogQHBhcmFtIHtXYWxsZXRDb25uZWN0T3B0aW9uc30gd2FsbGV0Q29ubmVjdE9wdGlvbnMgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgdXNlZCBmb3IgaW5pdGlhbGl6aW5nIFdhbGxldENvbm5lY3QuXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgVW5pdmVyc2FsQ29ubmVjdG9yIH0gZnJvbSAnQHJlb3duL2FwcGtpdC11bml2ZXJzYWwtY29ubmVjdG9yJztcbiAqXG4gKiBpbml0aWFsaXplV2FsbGV0Q29ubmVjdChVbml2ZXJzYWxDb25uZWN0b3IsIHtcbiAqICAgICBwcm9qZWN0SWQ6ICdhYmNkMTIzNGFiY2QxMjM0YWJjZDEyMzRhYmNkMTIzNCcsXG4gKiAgICAgbWV0YWRhdGE6IHtcbiAqICAgICAgICAgbmFtZTogJ0RlbW8gREFwcCcsXG4gKiAgICAgICAgIGljb25zOiBbXG4gKiAgICAgICAgICAgICAnaHR0cHM6Ly9leGFtcGxlLmNvbS9teS1pY29uLnBuZydcbiAqICAgICAgICAgXSxcbiAqICAgICAgICAgdXJsOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luLFxuICogICAgICAgICBkZXNjcmlwdGlvbjogJ0RlbW8gREFwcCdcbiAqICAgICB9XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZVdhbGxldENvbm5lY3QoVW5pdmVyc2FsQ29ubmVjdG9yQ2xzLCB3YWxsZXRDb25uZWN0T3B0aW9ucykge1xuICAgIGlmICgoc3RhdGUgPT09IG51bGwgfHwgc3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0YXRlLndhbGxldENvbm5lY3RPcHRpb25zKSAhPT0gdW5kZWZpbmVkIHx8IChzdGF0ZSA9PT0gbnVsbCB8fCBzdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhdGUuVW5pdmVyc2FsQ29ubmVjdG9yQ2xzKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ1dhbGxldCBDb25uZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQuJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgVW5pdmVyc2FsQ29ubmVjdG9yQ2xzICE9PSAnZnVuY3Rpb24nIHx8ICEoJ2luaXQnIGluIFVuaXZlcnNhbENvbm5lY3RvckNscykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignSW5pdGlhbGl6ZSBVbml2ZXJzYWxDb25uZWN0b3JDbHMgbXVzdCBiZSBzZXQnKTtcbiAgICB9XG4gICAgc3RhdGUuVW5pdmVyc2FsQ29ubmVjdG9yQ2xzID0gVW5pdmVyc2FsQ29ubmVjdG9yQ2xzO1xuICAgIHN0YXRlLndhbGxldENvbm5lY3RPcHRpb25zID0gd2FsbGV0Q29ubmVjdE9wdGlvbnM7XG59XG5mdW5jdGlvbiBpc1dhbGxldENvbm5lY3RJbml0aWFsaXplZCgpIHtcbiAgICByZXR1cm4gc3RhdGUuVW5pdmVyc2FsQ29ubmVjdG9yQ2xzICE9PSB1bmRlZmluZWQgJiYgc3RhdGUud2FsbGV0Q29ubmVjdE9wdGlvbnMgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldFVuaXZlcnNhbENvbm5lY3RvcigpIHtcbiAgICBpZiAoc3RhdGUuVW5pdmVyc2FsQ29ubmVjdG9yQ2xzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignV2FsbGV0IENvbm5lY3QgaXMgbm90IGluaXRpYWxpemVkLicpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUuVW5pdmVyc2FsQ29ubmVjdG9yQ2xzO1xufVxuZnVuY3Rpb24gZ2V0V2FsbGV0Q29ubmVjdE9wdGlvbnMoKSB7XG4gICAgaWYgKHN0YXRlLndhbGxldENvbm5lY3RPcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignV2FsbGV0IENvbm5lY3QgaXMgbm90IGluaXRpYWxpemVkLicpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUud2FsbGV0Q29ubmVjdE9wdGlvbnM7XG59XG5cbmNvbnN0IERFRkFVTFRfUkVRVUVTVF9JRCA9ICcwJztcbmNvbnN0IERFRkFVTFRfRVZFTlRfSUQgPSAwO1xuY2xhc3MgV2FsbGV0Q29ubmVjdFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uU3RvcmFnZSkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlID0gY29ubmVjdGlvblN0b3JhZ2U7XG4gICAgICAgIHRoaXMudHlwZSA9ICdpbmplY3RlZCc7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuY29ubmVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCB7IHByb2plY3RJZCwgbWV0YWRhdGEgfSA9IGdldFdhbGxldENvbm5lY3RPcHRpb25zKCk7XG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAgICAgbmV0d29ya3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogJ3RvbicsXG4gICAgICAgICAgICAgICAgICAgIGNoYWluczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAtMjM5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluTmFtZXNwYWNlOiAndG9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWlwTmV0d29ya0lkOiAndG9uOi0yMzknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdUT04nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZUN1cnJlbmN5OiB7IG5hbWU6ICdUT04nLCBzeW1ib2w6ICdUT04nLCBkZWNpbWFsczogOSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJwY1VybHM6IHsgZGVmYXVsdDogeyBodHRwOiBbXSB9IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IC0zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluTmFtZXNwYWNlOiAndG9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWlwTmV0d29ya0lkOiAndG9uOi0zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnVE9OJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVDdXJyZW5jeTogeyBuYW1lOiAnVE9OJywgc3ltYm9sOiAnVE9OJywgZGVjaW1hbHM6IDkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBycGNVcmxzOiB7IGRlZmF1bHQ6IHsgaHR0cDogW10gfSB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZHM6IFsndG9uX3NlbmRNZXNzYWdlJywgJ3Rvbl9zaWduRGF0YSddLFxuICAgICAgICAgICAgICAgICAgICBldmVudHM6IFtdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHByb2plY3RJZCxcbiAgICAgICAgICAgIG1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RvcmFnZShzdG9yYWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdhbGxldENvbm5lY3RQcm92aWRlcihzdG9yYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29ubmVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IgPSB5aWVsZCBnZXRVbml2ZXJzYWxDb25uZWN0b3IoKS5pbml0KHRoaXMuY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RvcjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbm5lY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB0cmFjZUlkID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYWNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFVVSUR2NygpO1xuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBjcmVhdGVBYm9ydENvbnRyb2xsZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCk7XG4gICAgICAgIChfYiA9IHRoaXMuYWJvcnRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnQoKTtcbiAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBhYm9ydENvbnRyb2xsZXI7XG4gICAgICAgIHZvaWQgdGhpcy5fY29ubmVjdChtZXNzYWdlLCB7XG4gICAgICAgICAgICB0cmFjZUlkLFxuICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyXG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IGxvZ0RlYnVnKCdXYWxsZXRDb25uZWN0IGNvbm5lY3QgdW5leHBlY3RlZCBlcnJvcicsIGVycm9yKSk7XG4gICAgfVxuICAgIF9jb25uZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0b3IgPSB5aWVsZCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgICAgIGlmICgoX2EgPSBvcHRpb25zLnNpZ25hbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnV2FsbGV0Q29ubmVjdCBjb25uZWN0IGFib3J0ZWQgYmVmb3JlIHN0YXJ0Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckFib3J0Q29udHJvbGxlcihvcHRpb25zLmFib3J0Q29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9uUHJvb2YgPSBtZXNzYWdlLml0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLm5hbWUgPT09ICd0b25fcHJvb2YnKTtcbiAgICAgICAgICAgIGNvbnN0IGF1dGhlbnRpY2F0aW9uID0gdG9uUHJvb2ZcbiAgICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBuZXcgVVJMKHRoaXMuY29uZmlnLm1ldGFkYXRhLnVybCkuaG9zdG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbnM6IFsndG9uOi0yMzknXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vbmNlOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVyaTogJ3Rvbl9wcm9vZicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQ6IHRvblByb29mLnBheWxvYWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxvZ0RlYnVnKCdDb25uZWN0aW5nIHRocm91Z2ggdGhpcy5jb25uZWN0b3IuY29ubmVjdCcpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB5aWVsZCBjb25uZWN0b3IuY29ubmVjdCh7IGF1dGhlbnRpY2F0aW9uIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKChfYiA9IG9wdGlvbnMuc2lnbmFsKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnV2FsbGV0Q29ubmVjdCBjb25uZWN0IGFib3J0ZWQgdmlhIHNpZ25hbCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyQWJvcnRDb250cm9sbGVyKG9wdGlvbnMuYWJvcnRDb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnV2FsbGV0Q29ubmVjdCBjb25uZWN0IGVycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogREVGQVVMVF9FVkVOVF9JRCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6ICdjb25uZWN0X2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VJZDogb3B0aW9ucy50cmFjZUlkLFxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTLlVTRVJfUkVKRUNUU19FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdVc2VyIGRlY2xpbmVkIHRoZSBjb25uZWN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnV2FsbGV0Q29ubmVjdCBjb25uZWN0IHJlc3BvbnNlOicsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJBYm9ydENvbnRyb2xsZXIob3B0aW9ucy5hYm9ydENvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ0RlYnVnKCdDb25uZWN0ZWQgdGhyb3VnaCB0aGlzLmNvbm5lY3Rvci5jb25uZWN0Jyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMub25Db25uZWN0KGNvbm5lY3RvciwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBpbmNsdWRlVG9uUHJvb2Y6IHRydWUgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ1dhbGxldENvbm5lY3Qgb25Db25uZWN0IGVycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZGlzY29ubmVjdCh7IHRyYWNlSWQ6IG9wdGlvbnMudHJhY2VJZCwgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJBYm9ydENvbnRyb2xsZXIob3B0aW9ucy5hYm9ydENvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzdG9yZUNvbm5lY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNlSWQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVVVJRHY3KCk7XG4gICAgICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBjcmVhdGVBYm9ydENvbnRyb2xsZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCk7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLmFib3J0Q29udHJvbGxlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0KCk7XG4gICAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IGFib3J0Q29udHJvbGxlcjtcbiAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdSZXN0b3JpbmcgV2FsbGV0Q29ubmVjdCBjb25uZWN0aW9uLi4uJyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmVkQ29ubmVjdGlvbiA9IHlpZWxkIHRoaXMuY29ubmVjdGlvblN0b3JhZ2UuZ2V0V2FsbGV0Q29ubmVjdENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0b3JlZENvbm5lY3Rpb24gfHwgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdG9yID0geWllbGQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMub25Db25uZWN0KGNvbm5lY3Rvciwge1xuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlVG9uUHJvb2Y6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZUlkLFxuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnV2FsbGV0Q29ubmVjdCBzdWNjZXNzZnVsbHkgcmVzdG9yZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnV2FsbGV0Q29ubmVjdCByZXN0b3JlIGVycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZGlzY29ubmVjdCh7IHRyYWNlSWQsIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJBYm9ydENvbnRyb2xsZXIoYWJvcnRDb250cm9sbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsb3NlQ29ubmVjdGlvbigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmFib3J0Q29udHJvbGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFib3J0KCk7XG4gICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB2b2lkIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBjcmVhdGVBYm9ydENvbnRyb2xsZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmFib3J0Q29udHJvbGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFib3J0KCk7XG4gICAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IGFib3J0Q29udHJvbGxlcjtcbiAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdGlvblN0b3JhZ2UucmVtb3ZlQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5aWVsZCAoKF9iID0gdGhpcy5jb25uZWN0b3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNjb25uZWN0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ1dhbGxldENvbm5lY3QgZGlzY29ubmVjdCBlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJBYm9ydENvbnRyb2xsZXIoYWJvcnRDb250cm9sbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRSZXF1ZXN0KHJlcXVlc3QsIG9wdGlvbnNPck9uUmVxdWVzdFNlbnQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25uZWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdXYWxsZXQgQ29ubmVjdCBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub25SZXF1ZXN0U2VudCA9IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uUmVxdWVzdFNlbnQgPSBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSBudWxsIHx8IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQub25SZXF1ZXN0U2VudDtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbCA9IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IG51bGwgfHwgb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uc09yT25SZXF1ZXN0U2VudC5zaWduYWw7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5hdHRlbXB0cyA9IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IG51bGwgfHwgb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uc09yT25SZXF1ZXN0U2VudC5hdHRlbXB0cztcbiAgICAgICAgICAgICAgICBvcHRpb25zLnRyYWNlSWQgPSBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSBudWxsIHx8IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQudHJhY2VJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYSA9IG9wdGlvbnMudHJhY2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKG9wdGlvbnMudHJhY2VJZCA9IFVVSUR2NygpKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKChfYiA9IG9wdGlvbnMuc2lnbmFsKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdXYWxsZXRDb25uZWN0IHJlcXVlc3QgYWJvcnRlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnU2VuZCB3YWxsZXQtY29ubmVjdCByZXF1ZXN0OicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCksIHsgaWQ6IERFRkFVTFRfUkVRVUVTVF9JRCB9KSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSAnc2VuZFRyYW5zYWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBfZSA9IEpTT04ucGFyc2UocmVxdWVzdC5wYXJhbXNbMF0pLCB7IG5ldHdvcmsgfSA9IF9lLCBzZW5kVHJhbnNhY3Rpb25QYXlsb2FkID0gX19yZXN0KF9lLCBbXCJuZXR3b3JrXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuY29ubmVjdG9yLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAndG9uX3NlbmRNZXNzYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogc2VuZFRyYW5zYWN0aW9uUGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICB9LCBgdG9uOiR7bmV0d29ya31gKTtcbiAgICAgICAgICAgICAgICAgICAgKF9jID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uUmVxdWVzdFNlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoeWllbGQgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdXYWxsZXQgbWVzc2FnZSByZWNlaXZlZDonLCB7IHJlc3VsdCwgaWQ6IERFRkFVTFRfUkVRVUVTVF9JRCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBERUZBVUxUX1JFUVVFU1RfSUQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZUlkOiBvcHRpb25zLnRyYWNlSWRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVxdWVzdC5tZXRob2QgPT09ICdzaWduRGF0YScpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgX2YgPSBKU09OLnBhcnNlKHJlcXVlc3QucGFyYW1zWzBdKSwgeyBuZXR3b3JrIH0gPSBfZiwgc2lnbkRhdGFQYXlsb2FkID0gX19yZXN0KF9mLCBbXCJuZXR3b3JrXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuY29ubmVjdG9yLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAndG9uX3NpZ25EYXRhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogc2lnbkRhdGFQYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgIH0sIGB0b246JHtuZXR3b3JrfWApO1xuICAgICAgICAgICAgICAgICAgICAoX2QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25SZXF1ZXN0U2VudCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9ICh5aWVsZCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoJ1dhbGxldCBtZXNzYWdlIHJlY2VpdmVkOicsIHsgcmVzdWx0LCBpZDogREVGQVVMVF9SRVFVRVNUX0lEIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHQsIHRyYWNlSWQ6IG9wdGlvbnMudHJhY2VJZCwgaWQ6IERFRkFVTFRfUkVRVUVTVF9JRCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ2Rpc2Nvbm5lY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogREVGQVVMVF9SRVFVRVNUX0lELFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2VJZDogb3B0aW9ucy50cmFjZUlkXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ1dhbGxldENvbm5lY3QgcmVxdWVzdCBlcnJvcicsIGVycm9yLCBlcnJvci5zdGFjayk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gKHlpZWxkIHRoaXMuaGFuZGxlV2FsbGV0Q29ubmVjdEVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlSWQ6IG9wdGlvbnMudHJhY2VJZFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnV2FsbGV0IG1lc3NhZ2UgcmVjZWl2ZWQ6JywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZDogREVGQVVMVF9SRVFVRVNUX0lELFxuICAgICAgICAgICAgICAgIGVycm9yOiB7IGNvZGU6IERJU0NPTk5FQ1RfRVJST1JfQ09ERVMuVU5LTk9XTl9FUlJPUiwgbWVzc2FnZTogJ05vdCBpbXBsZW1lbnRlZC4nIH0sXG4gICAgICAgICAgICAgICAgdHJhY2VJZDogb3B0aW9ucy50cmFjZUlkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlV2FsbGV0Q29ubmVjdEVycm9yKGVycm9yLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBTdHJpbmcoJ21lc3NhZ2UnIGluIGVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdtc2cnIGluIGVycm9yID8gZXJyb3IubXNnIDogZXJyb3IpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3JlamVjdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogREVGQVVMVF9SRVFVRVNUX0lELFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2VJZDogb3B0aW9ucy50cmFjZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTLlVTRVJfUkVKRUNUU19FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3RvbnZhbGlkYXRpb25lcnJvcicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogREVGQVVMVF9SRVFVRVNUX0lELFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2VJZDogb3B0aW9ucy50cmFjZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTLkJBRF9SRVFVRVNUX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IERFRkFVTFRfUkVRVUVTVF9JRCxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VJZDogb3B0aW9ucy50cmFjZUlkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogU0VORF9UUkFOU0FDVElPTl9FUlJPUl9DT0RFUy5VTktOT1dOX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IERFRkFVTFRfUkVRVUVTVF9JRCxcbiAgICAgICAgICAgICAgICB0cmFjZUlkOiBvcHRpb25zLnRyYWNlSWQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogU0VORF9UUkFOU0FDVElPTl9FUlJPUl9DT0RFUy5VTktOT1dOX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBTdHJpbmcoZXJyb3IpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxpc3RlbihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuICgpID0+ICh0aGlzLmxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzLmZpbHRlcihsaXN0ZW5lciA9PiBsaXN0ZW5lciAhPT0gY2FsbGJhY2spKTtcbiAgICB9XG4gICAgYnVpbGRUb25Qcm9vZihjb25uZWN0b3IpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IGF1dGggPSAoX2EgPSBjb25uZWN0b3IucHJvdmlkZXIuc2Vzc2lvbi5hdXRoZW50aWNhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdO1xuICAgICAgICBjb25zdCBpYXQgPSAoX2IgPSBhdXRoID09PSBudWxsIHx8IGF1dGggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF1dGgucCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlhdDtcbiAgICAgICAgY29uc3Qgc3RhdGVtZW50ID0gKF9jID0gYXV0aCA9PT0gbnVsbCB8fCBhdXRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdXRoLnApID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zdGF0ZW1lbnQ7XG4gICAgICAgIGlmICghaWF0IHx8ICFzdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb21haW4gPSBhdXRoLnAuZG9tYWluO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogJ3Rvbl9wcm9vZicsXG4gICAgICAgICAgICBwcm9vZjoge1xuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogTWF0aC5mbG9vcihuZXcgRGF0ZShpYXQpLmdldFRpbWUoKSAvIDEwMDApLFxuICAgICAgICAgICAgICAgIGRvbWFpbjoge1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGhCeXRlczogZG9tYWluLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRvbWFpblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogc3RhdGVtZW50LFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogYXV0aC5zLnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgb25Db25uZWN0KGNvbm5lY3Rvciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgaWYgKChfYSA9IG9wdGlvbnMuc2lnbmFsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdXYWxsZXRDb25uZWN0IG9uQ29ubmVjdCBhYm9ydGVkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGNvbm5lY3Rvci5wcm92aWRlci5zZXNzaW9uO1xuICAgICAgICAgICAgY29uc3QgdG9uTmFtZXNwYWNlID0gc2Vzc2lvbi5uYW1lc3BhY2VzWyd0b24nXTtcbiAgICAgICAgICAgIGlmICghKChfYiA9IHRvbk5hbWVzcGFjZSA9PT0gbnVsbCB8fCB0b25OYW1lc3BhY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRvbk5hbWVzcGFjZS5hY2NvdW50cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWzBdKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZGlzY29ubmVjdFdpdGhFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlSWQ6IG9wdGlvbnMudHJhY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFUy5CQURfUkVRVUVTVF9FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0Nvbm5lY3Rpb24gZXJyb3IuIE5vIFRPTiBhY2NvdW50cyBjb25uZWN0ZWQuJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFjY291bnQgPSB0b25OYW1lc3BhY2UuYWNjb3VudHNbMF07XG4gICAgICAgICAgICBjb25zdCBbLCBuZXR3b3JrLCBhZGRyZXNzXSA9IGFjY291bnQuc3BsaXQoJzonLCAzKTtcbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IChfYyA9IHNlc3Npb24uc2Vzc2lvblByb3BlcnRpZXMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b25fZ2V0UHVibGljS2V5O1xuICAgICAgICAgICAgaWYgKCFwdWJsaWNLZXkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmRpc2Nvbm5lY3RXaXRoRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICB0cmFjZUlkOiBvcHRpb25zLnRyYWNlSWQsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IENPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVMuQkFEX1JFUVVFU1RfRVJST1IsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdDb25uZWN0aW9uIGVycm9yLiBObyBzZXNzaW9uUHJvcGVydGllcy50b25fZ2V0UHVibGljS2V5IHByb3ZpZGVkLidcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGF0ZUluaXQgPSAoX2QgPSBzZXNzaW9uLnNlc3Npb25Qcm9wZXJ0aWVzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudG9uX2dldFN0YXRlSW5pdDtcbiAgICAgICAgICAgIGlmICghc3RhdGVJbml0KSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5kaXNjb25uZWN0V2l0aEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VJZDogb3B0aW9ucy50cmFjZUlkLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTLkJBRF9SRVFVRVNUX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQ29ubmVjdGlvbiBlcnJvci4gTm8gc2Vzc2lvblByb3BlcnRpZXMudG9uX2dldFN0YXRlSW5pdCBwcm92aWRlZC4nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29ubmVjdG9yLnByb3ZpZGVyLm9uY2UoJ3Nlc3Npb25fZGVsZXRlJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdGlvblN0b3JhZ2UucmVtb3ZlQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiAnZGlzY29ubmVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZUlkOiBVVUlEdjcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHt9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdXYWxsZXQgbWVzc2FnZSByZWNlaXZlZDonLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoJ0Vycm9yIHdoaWxlIGRlbGV0aW5nIHNlc3Npb24nLCBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGNvbnN0IHRvblByb29mID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pbmNsdWRlVG9uUHJvb2YpID8gdGhpcy5idWlsZFRvblByb29mKGNvbm5lY3RvcikgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRBZGRyZXNzID0gaXNWYWxpZFVzZXJGcmllbmRseUFkZHJlc3MoYWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IHRvUmF3QWRkcmVzcyhwYXJzZVVzZXJGcmllbmRseUFkZHJlc3MoYWRkcmVzcykpXG4gICAgICAgICAgICAgICAgOiBhZGRyZXNzO1xuICAgICAgICAgICAgY29uc3QgZmVhdHVyZXMgPSB0aGlzLmJ1aWxkRmVhdHVyZUxpc3QodG9uTmFtZXNwYWNlLm1ldGhvZHMpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndG9uX2FkZHInLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogcGFyc2VkQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcms6IG5ldHdvcmssXG4gICAgICAgICAgICAgICAgICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXRTdGF0ZUluaXQ6IHN0YXRlSW5pdFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAuLi4odG9uUHJvb2YgPyBbdG9uUHJvb2ZdIDogW10pXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkZXZpY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZTogJ3dhbGxldF9jb25uZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgYXBwVmVyc2lvbjogJycsXG4gICAgICAgICAgICAgICAgICAgIG1heFByb3RvY29sVmVyc2lvbjogMixcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXMsXG4gICAgICAgICAgICAgICAgICAgIHBsYXRmb3JtOiAnYnJvd3NlcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbG9nRGVidWcoJ1dhbGxldENvbm5lY3QgY29ubmVjdCByZXNwb25zZTonLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6ICdjb25uZWN0JyxcbiAgICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICAgIGlkOiBERUZBVUxUX0VWRU5UX0lEXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCh7IGV2ZW50OiAnY29ubmVjdCcsIHBheWxvYWQsIHRyYWNlSWQ6IG9wdGlvbnMudHJhY2VJZCB9KTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuc3RvcmVDb25uZWN0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBidWlsZEZlYXR1cmVMaXN0KG1ldGhvZHMpIHtcbiAgICAgICAgY29uc3QgZmVhdHVyZXMgPSBbXTtcbiAgICAgICAgaWYgKG1ldGhvZHMuaW5jbHVkZXMoJ3Rvbl9zZW5kTWVzc2FnZScpKSB7XG4gICAgICAgICAgICBmZWF0dXJlcy5wdXNoKCdTZW5kVHJhbnNhY3Rpb24nLCB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgbWF4TWVzc2FnZXM6IDQsXG4gICAgICAgICAgICAgICAgZXh0cmFDdXJyZW5jeVN1cHBvcnRlZDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2RzLmluY2x1ZGVzKCd0b25fc2lnbkRhdGEnKSkge1xuICAgICAgICAgICAgZmVhdHVyZXMucHVzaCh7IG5hbWU6ICdTaWduRGF0YScsIHR5cGVzOiBbJ3RleHQnLCAnYmluYXJ5JywgJ2NlbGwnXSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmVhdHVyZXM7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RXaXRoRXJyb3Iob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IG9wdGlvbnMuY29kZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLm1lc3NhZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsb2dEZWJ1ZygnV2FsbGV0Q29ubmVjdCBjb25uZWN0IHJlc3BvbnNlOicsIHtcbiAgICAgICAgICAgICAgICBldmVudDogJ2Nvbm5lY3RfZXJyb3InLFxuICAgICAgICAgICAgICAgIGlkOiBERUZBVUxUX0VWRU5UX0lELFxuICAgICAgICAgICAgICAgIHBheWxvYWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KHtcbiAgICAgICAgICAgICAgICBldmVudDogJ2Nvbm5lY3RfZXJyb3InLFxuICAgICAgICAgICAgICAgIHRyYWNlSWQ6IG9wdGlvbnMudHJhY2VJZCxcbiAgICAgICAgICAgICAgICBwYXlsb2FkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsZWFyQWJvcnRDb250cm9sbGVyKGFib3J0Q29udHJvbGxlcikge1xuICAgICAgICBpZiAodGhpcy5hYm9ydENvbnRyb2xsZXIgPT09IGFib3J0Q29udHJvbGxlcikge1xuICAgICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdChldmVudCwgbGlzdGVuZXJzKSB7XG4gICAgICAgIChsaXN0ZW5lcnMgIT09IG51bGwgJiYgbGlzdGVuZXJzICE9PSB2b2lkIDAgPyBsaXN0ZW5lcnMgOiB0aGlzLmxpc3RlbmVycykuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcihldmVudCkpO1xuICAgIH1cbiAgICBzdG9yZUNvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlLnN0b3JlQ29ubmVjdGlvbih7XG4gICAgICAgICAgICB0eXBlOiAnd2FsbGV0LWNvbm5lY3QnXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgVG9uQ29ubmVjdCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhdmFpbGFibGUgd2FsbGV0cyBsaXN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRXYWxsZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53YWxsZXRzTGlzdC5nZXRXYWxsZXRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIGlmIHRoZSB3YWxsZXQgaXMgY29ubmVjdGVkIHJpZ2h0IG5vdy5cbiAgICAgKi9cbiAgICBnZXQgY29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2FsbGV0ICE9PSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGNvbm5lY3RlZCBhY2NvdW50IG9yIG51bGwgaWYgbm8gYWNjb3VudCBpcyBjb25uZWN0ZWQuXG4gICAgICovXG4gICAgZ2V0IGFjY291bnQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLl93YWxsZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2NvdW50KSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGNvbm5lY3RlZCB3YWxsZXQgb3IgbnVsbCBpZiBubyBhY2NvdW50IGlzIGNvbm5lY3RlZC5cbiAgICAgKi9cbiAgICBnZXQgd2FsbGV0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2FsbGV0O1xuICAgIH1cbiAgICBzZXQgd2FsbGV0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3dhbGxldCA9IHZhbHVlO1xuICAgICAgICB0aGlzLnN0YXR1c0NoYW5nZVN1YnNjcmlwdGlvbnMuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayh0aGlzLl93YWxsZXQpKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdGhpcy5fd2FsbGV0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdHVzQ2hhbmdlU3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXR1c0NoYW5nZUVycm9yU3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICBjb25zdCBtYW5pZmVzdFVybCA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWFuaWZlc3RVcmwpIHx8IGdldFdlYlBhZ2VNYW5pZmVzdCgpO1xuICAgICAgICB0aGlzLmRhcHBTZXR0aW5ncyA9IHtcbiAgICAgICAgICAgIG1hbmlmZXN0VXJsLFxuICAgICAgICAgICAgc3RvcmFnZTogKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zdG9yYWdlKSB8fCBuZXcgRGVmYXVsdFN0b3JhZ2UoKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndhbGxldHNSZXF1aXJlZEZlYXR1cmVzID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndhbGxldHNSZXF1aXJlZEZlYXR1cmVzO1xuICAgICAgICB0aGlzLmVudmlyb25tZW50ID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVudmlyb25tZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgRGVmYXVsdEVudmlyb25tZW50KCk7XG4gICAgICAgIHRoaXMud2FsbGV0c0xpc3QgPSBuZXcgV2FsbGV0c0xpc3RNYW5hZ2VyKHtcbiAgICAgICAgICAgIHdhbGxldHNMaXN0U291cmNlOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud2FsbGV0c0xpc3RTb3VyY2UsXG4gICAgICAgICAgICBjYWNoZVRUTE1zOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud2FsbGV0c0xpc3RDYWNoZVRUTE1zLFxuICAgICAgICAgICAgb25Eb3dubG9hZER1cmF0aW9uTWVhc3VyZWQ6IChkdXJhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmFuYWx5dGljcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldFdhbGxldExpc3REb3dubG9hZER1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGV2ZW50RGlzcGF0Y2hlciA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ldmVudERpc3BhdGNoZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBCcm93c2VyRXZlbnREaXNwYXRjaGVyKCk7XG4gICAgICAgIHRoaXMudHJhY2tlciA9IG5ldyBUb25Db25uZWN0VHJhY2tlcih7XG4gICAgICAgICAgICBldmVudERpc3BhdGNoZXIsXG4gICAgICAgICAgICB0b25Db25uZWN0U2RrVmVyc2lvbjogdG9uQ29ubmVjdFNka1ZlcnNpb25cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW52aXJvbm1lbnQgPSAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW52aXJvbm1lbnQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG5ldyBEZWZhdWx0RW52aXJvbm1lbnQoKTtcbiAgICAgICAgdGhpcy5pbml0QW5hbHl0aWNzKG1hbmlmZXN0VXJsLCBldmVudERpc3BhdGNoZXIsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXRoaXMuZGFwcFNldHRpbmdzLm1hbmlmZXN0VXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRGFwcE1ldGFkYXRhRXJyb3IoJ0RhcHAgdG9uY29ubmVjdC1tYW5pZmVzdC5qc29uIG11c3QgYmUgc3BlY2lmaWVkIGlmIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gaXMgdW5kZWZpbmVkLiBTZWUgbW9yZSBodHRwczovL2dpdGh1Yi5jb20vdG9uLWNvbm5lY3QvZG9jcy9ibG9iL21haW4vcmVxdWVzdHMtcmVzcG9uc2VzLm1kI2FwcC1tYW5pZmVzdCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnJpZGdlQ29ubmVjdGlvblN0b3JhZ2UgPSBuZXcgQnJpZGdlQ29ubmVjdGlvblN0b3JhZ2UodGhpcy5kYXBwU2V0dGluZ3Muc3RvcmFnZSwgdGhpcy53YWxsZXRzTGlzdCk7XG4gICAgICAgIGlmICghKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kaXNhYmxlQXV0b1BhdXNlQ29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkV2luZG93Rm9jdXNBbmRCbHVyU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYXZhaWxhYmxlIHdhbGxldHMgbGlzdC5cbiAgICAgKi9cbiAgICBnZXRXYWxsZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53YWxsZXRzTGlzdC5nZXRXYWxsZXRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0byBzdWJzY3JpYmUgdG8gY29ubmVjdGlvbiBzdGF0dXMgY2hhbmdlcyBhbmQgaGFuZGxlIGNvbm5lY3Rpb24gZXJyb3JzLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciBjb25uZWN0aW9ucyBzdGF0dXMgY2hhbmdlcyB3aXRoIGFjdHVhbCB3YWxsZXQgb3IgbnVsbC5cbiAgICAgKiBAcGFyYW0gZXJyb3JzSGFuZGxlciAob3B0aW9uYWwpIHdpbGwgYmUgY2FsbGVkIHdpdGggc29tZSBpbnN0YW5jZSBvZiBUb25Db25uZWN0RXJyb3Igd2hlbiBjb25uZWN0IGVycm9yIGlzIHJlY2VpdmVkLlxuICAgICAqIEByZXR1cm5zIHVuc3Vic2NyaWJlIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIG9uU3RhdHVzQ2hhbmdlKGNhbGxiYWNrLCBlcnJvcnNIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzQ2hhbmdlU3Vic2NyaXB0aW9ucy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGVycm9yc0hhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQ2hhbmdlRXJyb3JTdWJzY3JpcHRpb25zLnB1c2goZXJyb3JzSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQ2hhbmdlU3Vic2NyaXB0aW9ucyA9IHRoaXMuc3RhdHVzQ2hhbmdlU3Vic2NyaXB0aW9ucy5maWx0ZXIoaXRlbSA9PiBpdGVtICE9PSBjYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoZXJyb3JzSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzQ2hhbmdlRXJyb3JTdWJzY3JpcHRpb25zID0gdGhpcy5zdGF0dXNDaGFuZ2VFcnJvclN1YnNjcmlwdGlvbnMuZmlsdGVyKGl0ZW0gPT4gaXRlbSAhPT0gZXJyb3JzSGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgY29ubmVjdCh3YWxsZXQsIHJlcXVlc3RPck9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAvLyBUT0RPOiByZW1vdmUgZGVwcmVjYXRlZCBtZXRob2RcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGFkZGl0aW9uYWxPcHRpb25zKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0T3JPcHRpb25zID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgcmVxdWVzdE9yT3B0aW9ucyAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgJ3RvblByb29mJyBpbiByZXF1ZXN0T3JPcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zLnJlcXVlc3QgPSByZXF1ZXN0T3JPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdE9yT3B0aW9ucyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHJlcXVlc3RPck9wdGlvbnMgIT09IG51bGwgJiZcbiAgICAgICAgICAgICgnb3BlbmluZ0RlYWRsaW5lTVMnIGluIHJlcXVlc3RPck9wdGlvbnMgfHxcbiAgICAgICAgICAgICAgICAnc2lnbmFsJyBpbiByZXF1ZXN0T3JPcHRpb25zIHx8XG4gICAgICAgICAgICAgICAgJ3JlcXVlc3QnIGluIHJlcXVlc3RPck9wdGlvbnMgfHxcbiAgICAgICAgICAgICAgICAndHJhY2VJZCcgaW4gcmVxdWVzdE9yT3B0aW9ucykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucmVxdWVzdCA9IHJlcXVlc3RPck9wdGlvbnMgPT09IG51bGwgfHwgcmVxdWVzdE9yT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVxdWVzdE9yT3B0aW9ucy5yZXF1ZXN0O1xuICAgICAgICAgICAgb3B0aW9ucy5vcGVuaW5nRGVhZGxpbmVNUyA9IHJlcXVlc3RPck9wdGlvbnMgPT09IG51bGwgfHwgcmVxdWVzdE9yT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVxdWVzdE9yT3B0aW9ucy5vcGVuaW5nRGVhZGxpbmVNUztcbiAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsID0gcmVxdWVzdE9yT3B0aW9ucyA9PT0gbnVsbCB8fCByZXF1ZXN0T3JPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXF1ZXN0T3JPcHRpb25zLnNpZ25hbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5yZXF1ZXN0KSB7XG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSB2YWxpZGF0ZUNvbm5lY3RBZGRpdGlvbmFsUmVxdWVzdChvcHRpb25zLnJlcXVlc3QpO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1FhTW9kZUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDb25uZWN0QWRkaXRpb25hbFJlcXVlc3QgdmFsaWRhdGlvbiBmYWlsZWQ6ICcgKyB2YWxpZGF0aW9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignQ29ubmVjdEFkZGl0aW9uYWxSZXF1ZXN0IHZhbGlkYXRpb24gZmFpbGVkOiAnICsgdmFsaWRhdGlvbkVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0QWxyZWFkeUNvbm5lY3RlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gY3JlYXRlQWJvcnRDb250cm9sbGVyKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWwpO1xuICAgICAgICAoX2EgPSB0aGlzLmFib3J0Q29udHJvbGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFib3J0KCk7XG4gICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gYWJvcnRDb250cm9sbGVyO1xuICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdDb25uZWN0aW9uIHdhcyBhYm9ydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgKF9iID0gdGhpcy5wcm92aWRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNsb3NlQ29ubmVjdGlvbigpO1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gdGhpcy5jcmVhdGVQcm92aWRlcih3YWxsZXQpO1xuICAgICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5wcm92aWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlciA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0cmFjZUlkID0gKF9jID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYWNlSWQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFVVSUR2NygpO1xuICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uU3RhcnRlZCh0cmFjZUlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuY29ubmVjdCh0aGlzLmNyZWF0ZUNvbm5lY3RSZXF1ZXN0KG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZXF1ZXN0KSwge1xuICAgICAgICAgICAgb3BlbmluZ0RlYWRsaW5lTVM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vcGVuaW5nRGVhZGxpbmVNUyxcbiAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICAgIHRyYWNlSWRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyeSB0byByZXN0b3JlIGV4aXN0aW5nIHNlc3Npb24gYW5kIHJlY29ubmVjdCB0byB0aGUgY29ycmVzcG9uZGluZyB3YWxsZXQuIENhbGwgaXQgaW1tZWRpYXRlbHkgd2hlbiB5b3VyIGFwcCBpcyBsb2FkZWQuXG4gICAgICovXG4gICAgcmVzdG9yZUNvbm5lY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCB0cmFjZUlkID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYWNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFVVSUR2NygpO1xuICAgICAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrQ29ubmVjdGlvblJlc3RvcmluZ1N0YXJ0ZWQodHJhY2VJZCk7XG4gICAgICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBjcmVhdGVBYm9ydENvbnRyb2xsZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCk7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLmFib3J0Q29udHJvbGxlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0KCk7XG4gICAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IGFib3J0Q29udHJvbGxlcjtcbiAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uUmVzdG9yaW5nRXJyb3IoJ0Nvbm5lY3Rpb24gcmVzdG9yaW5nIHdhcyBhYm9ydGVkJywgdHJhY2VJZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogcG90ZW50aWFsbHkgcmFjZSBjb25kaXRpb24gaGVyZVxuICAgICAgICAgICAgY29uc3QgW2JyaWRnZUNvbm5lY3Rpb25UeXBlLCBlbWJlZGRlZFdhbGxldF0gPSB5aWVsZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5icmlkZ2VDb25uZWN0aW9uU3RvcmFnZS5zdG9yZWRDb25uZWN0aW9uVHlwZSgpLFxuICAgICAgICAgICAgICAgIHRoaXMud2FsbGV0c0xpc3QuZ2V0RW1iZWRkZWRXYWxsZXQoKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrQ29ubmVjdGlvblJlc3RvcmluZ0Vycm9yKCdDb25uZWN0aW9uIHJlc3RvcmluZyB3YXMgYWJvcnRlZCcsIHRyYWNlSWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwcm92aWRlciA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYnJpZGdlQ29ubmVjdGlvblR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaHR0cCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlciA9IHlpZWxkIEJyaWRnZVByb3ZpZGVyLmZyb21TdG9yYWdlKHRoaXMuYnJpZGdlQ29ubmVjdGlvblN0b3JhZ2UsIHRoaXMuYW5hbHl0aWNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbmplY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlciA9IHlpZWxkIEluamVjdGVkUHJvdmlkZXIuZnJvbVN0b3JhZ2UodGhpcy5icmlkZ2VDb25uZWN0aW9uU3RvcmFnZSwgdGhpcy5hbmFseXRpY3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dhbGxldC1jb25uZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0geWllbGQgV2FsbGV0Q29ubmVjdFByb3ZpZGVyLmZyb21TdG9yYWdlKHRoaXMuYnJpZGdlQ29ubmVjdGlvblN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW1iZWRkZWRXYWxsZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlciA9IHRoaXMuY3JlYXRlUHJvdmlkZXIoZW1iZWRkZWRXYWxsZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnUHJvdmlkZXIgaXMgbm90IHJlc3RvcmVkJywgZXJyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uUmVzdG9yaW5nRXJyb3IoJ1Byb3ZpZGVyIGlzIG5vdCByZXN0b3JlZCcsIHRyYWNlSWQpO1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuYnJpZGdlQ29ubmVjdGlvblN0b3JhZ2UucmVtb3ZlQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyID09PSBudWxsIHx8IHByb3ZpZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm92aWRlci5jbG9zZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBwcm92aWRlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyID09PSBudWxsIHx8IHByb3ZpZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm92aWRlci5jbG9zZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uUmVzdG9yaW5nRXJyb3IoJ0Nvbm5lY3Rpb24gcmVzdG9yaW5nIHdhcyBhYm9ydGVkJywgdHJhY2VJZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICAgICAgICAgIGxvZ0Vycm9yKCdQcm92aWRlciBpcyBub3QgcmVzdG9yZWQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uUmVzdG9yaW5nRXJyb3IoJ1Byb3ZpZGVyIGlzIG5vdCByZXN0b3JlZCcsIHRyYWNlSWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYyA9IHRoaXMucHJvdmlkZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jbG9zZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgICAgIHByb3ZpZGVyLmxpc3Rlbih0aGlzLndhbGxldEV2ZW50c0xpc3RlbmVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgY29uc3Qgb25BYm9ydFJlc3RvcmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrQ29ubmVjdGlvblJlc3RvcmluZ0Vycm9yKCdDb25uZWN0aW9uIHJlc3RvcmluZyB3YXMgYWJvcnRlZCcsIHRyYWNlSWQpO1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyID09PSBudWxsIHx8IHByb3ZpZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm92aWRlci5jbG9zZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBwcm92aWRlciA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQWJvcnRSZXN0b3JlKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3RvcmVDb25uZWN0aW9uVGFzayA9IGNhbGxGb3JTdWNjZXNzKChfb3B0aW9ucykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIChwcm92aWRlciA9PT0gbnVsbCB8fCBwcm92aWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvdmlkZXIucmVzdG9yZUNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICBvcGVuaW5nRGVhZGxpbmVNUzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9wZW5pbmdEZWFkbGluZU1TLFxuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IF9vcHRpb25zLnNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VJZFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25BYm9ydFJlc3RvcmUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uSW5mbyA9IHRoaXMuZ2V0U2Vzc2lvbkluZm8oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrQ29ubmVjdGlvblJlc3RvcmluZ0NvbXBsZXRlZCh0aGlzLndhbGxldCwgc2Vzc2lvbkluZm8sIHRyYWNlSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrQ29ubmVjdGlvblJlc3RvcmluZ0Vycm9yKCdDb25uZWN0aW9uIHJlc3RvcmluZyBmYWlsZWQnLCB0cmFjZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgICAgIGF0dGVtcHRzOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgICAgICBkZWxheU1zOiAyMDAwLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN0b3JlQ29ubmVjdGlvblRpbWVvdXQgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZSgpLCAxMjAwMCkgLy8gY29ubmVjdGlvbiBkZWFkbGluZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW3Jlc3RvcmVDb25uZWN0aW9uVGFzaywgcmVzdG9yZUNvbm5lY3Rpb25UaW1lb3V0XSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIG9wdGlvbnNPck9uUmVxdWVzdFNlbnQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSBkZXByZWNhdGVkIG1ldGhvZFxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlcXVlc3RTZW50ID0gb3B0aW9uc09yT25SZXF1ZXN0U2VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub25SZXF1ZXN0U2VudCA9IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IG51bGwgfHwgb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uc09yT25SZXF1ZXN0U2VudC5vblJlcXVlc3RTZW50O1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsID0gb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gbnVsbCB8fCBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zT3JPblJlcXVlc3RTZW50LnNpZ25hbDtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnRyYWNlSWQgPSBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSBudWxsIHx8IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQudHJhY2VJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSB2YWxpZGF0ZVNlbmRUcmFuc2FjdGlvblJlcXVlc3QodHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1FhTW9kZUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdTZW5kVHJhbnNhY3Rpb25SZXF1ZXN0IHZhbGlkYXRpb24gZmFpbGVkOiAnICsgdmFsaWRhdGlvbkVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ1NlbmRUcmFuc2FjdGlvblJlcXVlc3QgdmFsaWRhdGlvbiBmYWlsZWQ6ICcgKyB2YWxpZGF0aW9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IGNyZWF0ZUFib3J0Q29udHJvbGxlcihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsKTtcbiAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdUcmFuc2FjdGlvbiBzZW5kaW5nIHdhcyBhYm9ydGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgY29uc3QgcmVxdWlyZWRNZXNzYWdlc051bWJlciA9IHRyYW5zYWN0aW9uLm1lc3NhZ2VzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVFeHRyYUN1cnJlbmNpZXMgPSB0cmFuc2FjdGlvbi5tZXNzYWdlcy5zb21lKG0gPT4gbS5leHRyYUN1cnJlbmN5ICYmIE9iamVjdC5rZXlzKG0uZXh0cmFDdXJyZW5jeSkubGVuZ3RoID4gMCk7XG4gICAgICAgICAgICBjaGVja1NlbmRUcmFuc2FjdGlvblN1cHBvcnQodGhpcy53YWxsZXQuZGV2aWNlLmZlYXR1cmVzLCB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWRNZXNzYWdlc051bWJlcixcbiAgICAgICAgICAgICAgICByZXF1aXJlRXh0cmFDdXJyZW5jaWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JbmZvID0gdGhpcy5nZXRTZXNzaW9uSW5mbygpO1xuICAgICAgICAgICAgY29uc3QgdHJhY2VJZCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFjZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBVVUlEdjcoKTtcbiAgICAgICAgICAgIHRoaXMudHJhY2tlci50cmFja1RyYW5zYWN0aW9uU2VudEZvclNpZ25hdHVyZSh0aGlzLndhbGxldCwgdHJhbnNhY3Rpb24sIHNlc3Npb25JbmZvLCB0cmFjZUlkKTtcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsaWRVbnRpbCwgbWVzc2FnZXMgfSA9IHRyYW5zYWN0aW9uLCB0eCA9IF9fcmVzdCh0cmFuc2FjdGlvbiwgW1widmFsaWRVbnRpbFwiLCBcIm1lc3NhZ2VzXCJdKTtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSB0cmFuc2FjdGlvbi5mcm9tIHx8IHRoaXMuYWNjb3VudC5hZGRyZXNzO1xuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IHRyYW5zYWN0aW9uLm5ldHdvcmsgfHwgdGhpcy5hY2NvdW50LmNoYWluO1xuICAgICAgICAgICAgaWYgKCgoX2IgPSB0aGlzLndhbGxldCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFjY291bnQuY2hhaW4pICYmIG5ldHdvcmsgIT09IHRoaXMud2FsbGV0LmFjY291bnQuY2hhaW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUWFNb2RlRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRXcm9uZ05ldHdvcmtFcnJvcignV2FsbGV0IGNvbm5lY3RlZCB0byBhIHdyb25nIG5ldHdvcmsnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXVzZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkQ2hhaW5JZDogKF9jID0gdGhpcy53YWxsZXQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hY2NvdW50LmNoYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbENoYWluSWQ6IG5ldHdvcmtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1dhbGxldCBjb25uZWN0ZWQgdG8gYSB3cm9uZyBuZXR3b3JrJywge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZENoYWluSWQ6IChfZCA9IHRoaXMud2FsbGV0KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWNjb3VudC5jaGFpbixcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsQ2hhaW5JZDogbmV0d29ya1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLnNlbmRSZXF1ZXN0KHNlbmRUcmFuc2FjdGlvblBhcnNlci5jb252ZXJ0VG9ScGNSZXF1ZXN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdHgpLCB7IGZyb20sXG4gICAgICAgICAgICAgICAgbmV0d29yaywgdmFsaWRfdW50aWw6IHZhbGlkVW50aWwsIG1lc3NhZ2VzOiBtZXNzYWdlcy5tYXAoKF9hKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB7IGV4dHJhQ3VycmVuY3ksIHBheWxvYWQsIHN0YXRlSW5pdCB9ID0gX2EsIG1zZyA9IF9fcmVzdChfYSwgW1wiZXh0cmFDdXJyZW5jeVwiLCBcInBheWxvYWRcIiwgXCJzdGF0ZUluaXRcIl0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbXNnKSwgeyBwYXlsb2FkOiBub3JtYWxpemVCYXNlNjQocGF5bG9hZCksIHN0YXRlSW5pdDogbm9ybWFsaXplQmFzZTY0KHN0YXRlSW5pdCksIGV4dHJhX2N1cnJlbmN5OiBleHRyYUN1cnJlbmN5IH0pKTtcbiAgICAgICAgICAgICAgICB9KSB9KSksIHtcbiAgICAgICAgICAgICAgICBvblJlcXVlc3RTZW50OiBvcHRpb25zLm9uUmVxdWVzdFNlbnQsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgICAgIHRyYWNlSWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNlbmRUcmFuc2FjdGlvblBhcnNlci5pc0Vycm9yKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tlci50cmFja1RyYW5zYWN0aW9uU2lnbmluZ0ZhaWxlZCh0aGlzLndhbGxldCwgdHJhbnNhY3Rpb24sIHJlc3BvbnNlLmVycm9yLm1lc3NhZ2UsIHJlc3BvbnNlLmVycm9yLmNvZGUsIHNlc3Npb25JbmZvLCB0cmFjZUlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VuZFRyYW5zYWN0aW9uUGFyc2VyLnBhcnNlQW5kVGhyb3dFcnJvcihyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzZW5kVHJhbnNhY3Rpb25QYXJzZXIuY29udmVydEZyb21ScGNSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tUcmFuc2FjdGlvblNpZ25lZCh0aGlzLndhbGxldCwgdHJhbnNhY3Rpb24sIHJlc3VsdCwgc2Vzc2lvbkluZm8sIHRyYWNlSWQpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdWx0KSwgeyB0cmFjZUlkOiByZXNwb25zZS50cmFjZUlkIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbkRhdGEoZGF0YSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gY3JlYXRlQWJvcnRDb250cm9sbGVyKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWwpO1xuICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ2RhdGEgc2VuZGluZyB3YXMgYWJvcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVmFsaWRhdGUgc2lnbiBkYXRhXG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSB2YWxpZGF0ZVNpZ25EYXRhUGF5bG9hZChkYXRhKTtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNRYU1vZGVFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignU2lnbkRhdGFQYXlsb2FkIHZhbGlkYXRpb24gZmFpbGVkOiAnICsgdmFsaWRhdGlvbkVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ1NpZ25EYXRhUGF5bG9hZCB2YWxpZGF0aW9uIGZhaWxlZDogJyArIHZhbGlkYXRpb25FcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGVja0Nvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIGNoZWNrU2lnbkRhdGFTdXBwb3J0KHRoaXMud2FsbGV0LmRldmljZS5mZWF0dXJlcywgeyByZXF1aXJlZFR5cGVzOiBbZGF0YS50eXBlXSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JbmZvID0gdGhpcy5nZXRTZXNzaW9uSW5mbygpO1xuICAgICAgICAgICAgY29uc3QgdHJhY2VJZCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFjZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBVVUlEdjcoKTtcbiAgICAgICAgICAgIHRoaXMudHJhY2tlci50cmFja0RhdGFTZW50Rm9yU2lnbmF0dXJlKHRoaXMud2FsbGV0LCBkYXRhLCBzZXNzaW9uSW5mbywgdHJhY2VJZCk7XG4gICAgICAgICAgICBjb25zdCBmcm9tID0gZGF0YS5mcm9tIHx8IHRoaXMuYWNjb3VudC5hZGRyZXNzO1xuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IGRhdGEubmV0d29yayB8fCB0aGlzLmFjY291bnQuY2hhaW47XG4gICAgICAgICAgICBpZiAoKChfYiA9IHRoaXMud2FsbGV0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWNjb3VudC5jaGFpbikgJiYgbmV0d29yayAhPT0gdGhpcy53YWxsZXQuYWNjb3VudC5jaGFpbikge1xuICAgICAgICAgICAgICAgIGlmICghaXNRYU1vZGVFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFdyb25nTmV0d29ya0Vycm9yKCdXYWxsZXQgY29ubmVjdGVkIHRvIGEgd3JvbmcgbmV0d29yaycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRDaGFpbklkOiAoX2MgPSB0aGlzLndhbGxldCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFjY291bnQuY2hhaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsQ2hhaW5JZDogbmV0d29ya1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignV2FsbGV0IGNvbm5lY3RlZCB0byBhIHdyb25nIG5ldHdvcmsnLCB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkQ2hhaW5JZDogKF9kID0gdGhpcy53YWxsZXQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hY2NvdW50LmNoYWluLFxuICAgICAgICAgICAgICAgICAgICBhY3R1YWxDaGFpbklkOiBuZXR3b3JrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucHJvdmlkZXIuc2VuZFJlcXVlc3Qoc2lnbkRhdGFQYXJzZXIuY29udmVydFRvUnBjUmVxdWVzdChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0YSksIChkYXRhLnR5cGUgPT09ICdjZWxsJyA/IHsgY2VsbDogbm9ybWFsaXplQmFzZTY0KGRhdGEuY2VsbCkgfSA6IHt9KSksIHsgZnJvbSxcbiAgICAgICAgICAgICAgICBuZXR3b3JrIH0pKSwgeyBvblJlcXVlc3RTZW50OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25SZXF1ZXN0U2VudCwgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLCB0cmFjZUlkIH0pO1xuICAgICAgICAgICAgaWYgKHNpZ25EYXRhUGFyc2VyLmlzRXJyb3IocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrRGF0YVNpZ25pbmdGYWlsZWQodGhpcy53YWxsZXQsIGRhdGEsIHJlc3BvbnNlLmVycm9yLm1lc3NhZ2UsIHJlc3BvbnNlLmVycm9yLmNvZGUsIHNlc3Npb25JbmZvLCB0cmFjZUlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbkRhdGFQYXJzZXIucGFyc2VBbmRUaHJvd0Vycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHNpZ25EYXRhUGFyc2VyLmNvbnZlcnRGcm9tUnBjUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrRGF0YVNpZ25lZCh0aGlzLndhbGxldCwgZGF0YSwgcmVzdWx0LCBzZXNzaW9uSW5mbywgdHJhY2VJZCk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN1bHQpLCB7IHRyYWNlSWQgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgZGVzaXJlZCBuZXR3b3JrIGZvciB0aGUgY29ubmVjdGlvbi4gQ2FuIG9ubHkgYmUgc2V0IGJlZm9yZSBjb25uZWN0aW5nLlxuICAgICAqIElmIHdhbGxldCBjb25uZWN0cyB3aXRoIGEgZGlmZmVyZW50IGNoYWluLCB0aGUgU0RLIHdpbGwgdGhyb3cgYW4gZXJyb3IgYW5kIGFib3J0IGNvbm5lY3Rpb24uXG4gICAgICogQHBhcmFtIG5ldHdvcmsgZGVzaXJlZCBuZXR3b3JrIGlkIChlLmcuLCAnLTIzOScsICctMycsIG9yIGN1c3RvbSkuIFBhc3MgdW5kZWZpbmVkIHRvIGFsbG93IGFueSBuZXR3b3JrLlxuICAgICAqL1xuICAgIHNldENvbm5lY3Rpb25OZXR3b3JrKG5ldHdvcmspIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdDYW5ub3QgY2hhbmdlIG5ldHdvcmsgd2hpbGUgd2FsbGV0IGlzIGNvbm5lY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzaXJlZENoYWluSWQgPSBuZXR3b3JrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0IGZvcm0gdGh3IGNvbm5lY3RlZCB3YWxsZXQgYW5kIGRyb3AgY3VycmVudCBzZXNzaW9uLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IGNyZWF0ZUFib3J0Q29udHJvbGxlcihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsKTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZBYm9ydENvbnRyb2xsZXIgPSB0aGlzLmFib3J0Q29udHJvbGxlcjtcbiAgICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gYWJvcnRDb250cm9sbGVyO1xuICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ0Rpc2Nvbm5lY3Qgd2FzIGFib3J0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRyYWNlSWQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVVVJRHY3KCk7XG4gICAgICAgICAgICB0aGlzLm9uV2FsbGV0RGlzY29ubmVjdGVkKCdkYXBwJywgeyB0cmFjZUlkIH0pO1xuICAgICAgICAgICAgeWllbGQgKChfYiA9IHRoaXMucHJvdmlkZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNjb25uZWN0KHtcbiAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICAgICAgdHJhY2VJZFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcHJldkFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBwcmV2QWJvcnRDb250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2QWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHNlc3Npb24gSUQgaWYgYXZhaWxhYmxlLlxuICAgICAqIEByZXR1cm5zIHNlc3Npb24gSUQgc3RyaW5nIG9yIG51bGwgaWYgbm90IGF2YWlsYWJsZS5cbiAgICAgKi9cbiAgICBnZXRTZXNzaW9uSWQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHlpZWxkIHRoaXMuYnJpZGdlQ29ubmVjdGlvblN0b3JhZ2UuZ2V0Q29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmICghY29ubmVjdGlvbiB8fCBjb25uZWN0aW9uLnR5cGUgIT09ICdodHRwJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCdzZXNzaW9uQ3J5cHRvJyBpbiBjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBlbmRpbmcgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5zZXNzaW9uQ3J5cHRvLnNlc3Npb25JZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVzdGFibGlzaGVkIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uc2Vzc2lvbi5zZXNzaW9uQ3J5cHRvLnNlc3Npb25JZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFNlc3Npb25JbmZvKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5wcm92aWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpICE9PSAnaHR0cCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKCdzZXNzaW9uJyBpbiB0aGlzLnByb3ZpZGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSB0aGlzLnByb3ZpZGVyLnNlc3Npb247XG4gICAgICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNsaWVudElkID0gc2Vzc2lvbi5zZXNzaW9uQ3J5cHRvLnNlc3Npb25JZDtcbiAgICAgICAgICAgIGxldCB3YWxsZXRJZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoJ3dhbGxldFB1YmxpY0tleScgaW4gc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHdhbGxldElkID0gc2Vzc2lvbi53YWxsZXRQdWJsaWNLZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBjbGllbnRJZCwgd2FsbGV0SWQgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2IpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhdXNlIGJyaWRnZSBIVFRQIGNvbm5lY3Rpb24uIE1pZ2h0IGJlIGhlbHBmdWwsIGlmIHlvdSB3YW50IHRvIHBhdXNlIGNvbm5lY3Rpb25zIHdoaWxlIGJyb3dzZXIgdGFiIGlzIHVuZm9jdXNlZCxcbiAgICAgKiBvciBpZiB5b3UgdXNlIFNESyB3aXRoIE5vZGVKUyBhbmQgd2FudCB0byBzYXZlIHNlcnZlciByZXNvdXJjZXMuXG4gICAgICovXG4gICAgcGF1c2VDb25uZWN0aW9uKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5wcm92aWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpICE9PSAnaHR0cCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3ZpZGVyLnBhdXNlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucGF1c2UgYnJpZGdlIEhUVFAgY29ubmVjdGlvbiBpZiBpdCBpcyBwYXVzZWQuXG4gICAgICovXG4gICAgdW5QYXVzZUNvbm5lY3Rpb24oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLnByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgIT09ICdodHRwJykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnVuUGF1c2UoKTtcbiAgICB9XG4gICAgYWRkV2luZG93Rm9jdXNBbmRCbHVyU3Vic2NyaXB0aW9ucygpIHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgICBpZiAoIWRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdXNlQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51blBhdXNlQ29ubmVjdGlvbigpLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yKCdDYW5ub3Qgc3Vic2NyaWJlIHRvIHRoZSBkb2N1bWVudC52aXNpYmlsaXR5Y2hhbmdlOiAnLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0QW5hbHl0aWNzKG1hbmlmZXN0VXJsLCBldmVudERpc3BhdGNoZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBhbmFseXRpY3NTZXR0aW5ncyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hbmFseXRpY3M7XG4gICAgICAgIGNvbnN0IG1vZGUgPSAoX2EgPSBhbmFseXRpY3NTZXR0aW5ncyA9PT0gbnVsbCB8fCBhbmFseXRpY3NTZXR0aW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5hbHl0aWNzU2V0dGluZ3MubW9kZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ3RlbGVtZXRyeSc7XG4gICAgICAgIGlmIChtb2RlID09PSAnb2ZmJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFuYWx5dGljcyA9IG5ldyBBbmFseXRpY3NNYW5hZ2VyKHtcbiAgICAgICAgICAgIGVudmlyb25tZW50OiB0aGlzLmVudmlyb25tZW50LFxuICAgICAgICAgICAgbW9kZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hbmFseXRpY3MgPSBhbmFseXRpY3M7XG4gICAgICAgIGNvbnN0IHRlbGVncmFtVXNlciA9IHRoaXMuZW52aXJvbm1lbnQuZ2V0VGVsZWdyYW1Vc2VyKCk7XG4gICAgICAgIGNvbnN0IHNoYXJlZEFuYWx5dGljc0RhdGEgPSB7XG4gICAgICAgICAgICBicm93c2VyOiB0aGlzLmVudmlyb25tZW50LmdldEJyb3dzZXIoKSxcbiAgICAgICAgICAgIHBsYXRmb3JtOiB0aGlzLmVudmlyb25tZW50LmdldFBsYXRmb3JtKCksXG4gICAgICAgICAgICBtYW5pZmVzdF9qc29uX3VybDogbWFuaWZlc3RVcmwsXG4gICAgICAgICAgICBvcmlnaW5fdXJsOiBnZXRPcmlnaW5XaXRoUGF0aCxcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5lbnZpcm9ubWVudC5nZXRMb2NhbGUoKVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGVsZWdyYW1Vc2VyKSB7XG4gICAgICAgICAgICBzaGFyZWRBbmFseXRpY3NEYXRhLnRnX2lkID0gdGVsZWdyYW1Vc2VyLmlkO1xuICAgICAgICAgICAgc2hhcmVkQW5hbHl0aWNzRGF0YS50bWFfaXNfcHJlbWl1bSA9IHRlbGVncmFtVXNlci5pc1ByZW1pdW07XG4gICAgICAgIH1cbiAgICAgICAgYmluZEV2ZW50c1RvKGV2ZW50RGlzcGF0Y2hlciwgYW5hbHl0aWNzLnNjb3BlZChzaGFyZWRBbmFseXRpY3NEYXRhKSk7XG4gICAgfVxuICAgIGNyZWF0ZVByb3ZpZGVyKHdhbGxldCkge1xuICAgICAgICBsZXQgcHJvdmlkZXI7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh3YWxsZXQpICYmIGlzV2FsbGV0Q29ubmVjdGlvblNvdXJjZUpTKHdhbGxldCkpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyID0gbmV3IEluamVjdGVkUHJvdmlkZXIodGhpcy5icmlkZ2VDb25uZWN0aW9uU3RvcmFnZSwgd2FsbGV0LmpzQnJpZGdlS2V5LCB0aGlzLmFuYWx5dGljcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkod2FsbGV0KSAmJiBpc1dhbGxldENvbm5lY3Rpb25Tb3VyY2VXYWxsZXRDb25uZWN0KHdhbGxldCkpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyID0gbmV3IFdhbGxldENvbm5lY3RQcm92aWRlcih0aGlzLmJyaWRnZUNvbm5lY3Rpb25TdG9yYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb3ZpZGVyID0gbmV3IEJyaWRnZVByb3ZpZGVyKHRoaXMuYnJpZGdlQ29ubmVjdGlvblN0b3JhZ2UsIHdhbGxldCwgdGhpcy5hbmFseXRpY3MpO1xuICAgICAgICB9XG4gICAgICAgIHByb3ZpZGVyLmxpc3Rlbih0aGlzLndhbGxldEV2ZW50c0xpc3RlbmVyLmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm4gcHJvdmlkZXI7XG4gICAgfVxuICAgIHdhbGxldEV2ZW50c0xpc3RlbmVyKGUpIHtcbiAgICAgICAgc3dpdGNoIChlLmV2ZW50KSB7XG4gICAgICAgICAgICBjYXNlICdjb25uZWN0JzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uV2FsbGV0Q29ubmVjdGVkKGUucGF5bG9hZCwgeyB0cmFjZUlkOiBlLnRyYWNlSWQgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb25uZWN0X2Vycm9yJzpcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uRXJyb3IoZS5wYXlsb2FkLm1lc3NhZ2UsIGUucGF5bG9hZC5jb2RlLCB0aGlzLmdldFNlc3Npb25JbmZvKCksIGUudHJhY2VJZCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2FsbGV0RXJyb3IgPSBjb25uZWN0RXJyb3JzUGFyc2VyLnBhcnNlRXJyb3IoZS5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uV2FsbGV0Q29ubmVjdEVycm9yKHdhbGxldEVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3QnOlxuICAgICAgICAgICAgICAgIHRoaXMub25XYWxsZXREaXNjb25uZWN0ZWQoJ3dhbGxldCcsIHsgdHJhY2VJZDogZS50cmFjZUlkIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uV2FsbGV0Q29ubmVjdGVkKGNvbm5lY3RFdmVudCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB0b25BY2NvdW50SXRlbSA9IGNvbm5lY3RFdmVudC5pdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5uYW1lID09PSAndG9uX2FkZHInKTtcbiAgICAgICAgY29uc3QgdG9uUHJvb2ZJdGVtID0gY29ubmVjdEV2ZW50Lml0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLm5hbWUgPT09ICd0b25fcHJvb2YnKTtcbiAgICAgICAgaWYgKCF0b25BY2NvdW50SXRlbSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcigndG9uX2FkZHIgY29ubmVjdGlvbiBpdGVtIHdhcyBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNSZXF1aXJlZEZlYXR1cmVzID0gY2hlY2tSZXF1aXJlZFdhbGxldEZlYXR1cmVzKGNvbm5lY3RFdmVudC5kZXZpY2UuZmVhdHVyZXMsIHRoaXMud2FsbGV0c1JlcXVpcmVkRmVhdHVyZXMpO1xuICAgICAgICBpZiAoIWhhc1JlcXVpcmVkRmVhdHVyZXMpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMucHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLm9uV2FsbGV0Q29ubmVjdEVycm9yKG5ldyBXYWxsZXRNaXNzaW5nUmVxdWlyZWRGZWF0dXJlc0Vycm9yKCdXYWxsZXQgZG9lcyBub3Qgc3VwcG9ydCByZXF1aXJlZCBmZWF0dXJlcycsIHsgY2F1c2U6IHsgY29ubmVjdEV2ZW50IH0gfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhbGxldCA9IHtcbiAgICAgICAgICAgIGRldmljZTogY29ubmVjdEV2ZW50LmRldmljZSxcbiAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLnR5cGUsXG4gICAgICAgICAgICBhY2NvdW50OiB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdG9uQWNjb3VudEl0ZW0uYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBjaGFpbjogdG9uQWNjb3VudEl0ZW0ubmV0d29yayxcbiAgICAgICAgICAgICAgICB3YWxsZXRTdGF0ZUluaXQ6IHRvbkFjY291bnRJdGVtLndhbGxldFN0YXRlSW5pdCxcbiAgICAgICAgICAgICAgICBwdWJsaWNLZXk6IHRvbkFjY291bnRJdGVtLnB1YmxpY0tleVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5kZXNpcmVkQ2hhaW5JZCAmJiB3YWxsZXQuYWNjb3VudC5jaGFpbiAhPT0gdGhpcy5kZXNpcmVkQ2hhaW5JZCkge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRDaGFpbklkID0gdGhpcy5kZXNpcmVkQ2hhaW5JZDtcbiAgICAgICAgICAgIGNvbnN0IGFjdHVhbENoYWluSWQgPSB3YWxsZXQuYWNjb3VudC5jaGFpbjtcbiAgICAgICAgICAgIChfYiA9IHRoaXMucHJvdmlkZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLm9uV2FsbGV0Q29ubmVjdEVycm9yKG5ldyBXYWxsZXRXcm9uZ05ldHdvcmtFcnJvcignV2FsbGV0IGNvbm5lY3RlZCB0byBhIHdyb25nIG5ldHdvcmsnLCB7XG4gICAgICAgICAgICAgICAgY2F1c2U6IHsgZXhwZWN0ZWRDaGFpbklkLCBhY3R1YWxDaGFpbklkIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9uUHJvb2ZJdGVtKSB7XG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSB2YWxpZGF0ZVRvblByb29mSXRlbVJlcGx5KHRvblByb29mSXRlbSk7XG4gICAgICAgICAgICBsZXQgdG9uUHJvb2YgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUWFNb2RlRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RvblByb29mSXRlbSB2YWxpZGF0aW9uIGZhaWxlZDogJyArIHZhbGlkYXRpb25FcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvblByb29mID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAndG9uX3Byb29mJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IENPTk5FQ1RfSVRFTV9FUlJPUl9DT0RFUy5VTktOT1dOX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdmFsaWRhdGlvbkVycm9yXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCdwcm9vZicgaW4gdG9uUHJvb2ZJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b25Qcm9vZiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndG9uX3Byb29mJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9vZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRvblByb29mSXRlbS5wcm9vZi50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoQnl0ZXM6IHRvblByb29mSXRlbS5wcm9vZi5kb21haW4ubGVuZ3RoQnl0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdG9uUHJvb2ZJdGVtLnByb29mLmRvbWFpbi52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiB0b25Qcm9vZkl0ZW0ucHJvb2YucGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiB0b25Qcm9vZkl0ZW0ucHJvb2Yuc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgnZXJyb3InIGluIHRvblByb29mSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9uUHJvb2YgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Rvbl9wcm9vZicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogdG9uUHJvb2ZJdGVtLmVycm9yLmNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHRvblByb29mSXRlbS5lcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ0ludmFsaWQgZGF0YSBmb3JtYXQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0b25Qcm9vZiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0b25fcHJvb2YnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBDT05ORUNUX0lURU1fRVJST1JfQ09ERVMuVU5LTk9XTl9FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCBkYXRhIGZvcm1hdCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3YWxsZXQuY29ubmVjdEl0ZW1zID0geyB0b25Qcm9vZiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FsbGV0ID0gd2FsbGV0O1xuICAgICAgICBjb25zdCBzZXNzaW9uSW5mbyA9IHRoaXMuZ2V0U2Vzc2lvbkluZm8oKTtcbiAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrQ29ubmVjdGlvbkNvbXBsZXRlZCh3YWxsZXQsIHNlc3Npb25JbmZvLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZCk7XG4gICAgfVxuICAgIG9uV2FsbGV0Q29ubmVjdEVycm9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzQ2hhbmdlRXJyb3JTdWJzY3JpcHRpb25zLmZvckVhY2goZXJyb3JzSGFuZGxlciA9PiBlcnJvcnNIYW5kbGVyKGVycm9yKSk7XG4gICAgICAgIGxvZ0RlYnVnKGVycm9yKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgTWFuaWZlc3ROb3RGb3VuZEVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgTWFuaWZlc3RDb250ZW50RXJyb3JFcnJvcikge1xuICAgICAgICAgICAgbG9nRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25XYWxsZXREaXNjb25uZWN0ZWQoc2NvcGUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbkluZm8gPSB0aGlzLmdldFNlc3Npb25JbmZvKCk7XG4gICAgICAgIHRoaXMudHJhY2tlci50cmFja0Rpc2Nvbm5lY3Rpb24odGhpcy53YWxsZXQsIHNjb3BlLCBzZXNzaW9uSW5mbywgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYWNlSWQpO1xuICAgICAgICB0aGlzLndhbGxldCA9IG51bGw7XG4gICAgfVxuICAgIGNoZWNrQ29ubmVjdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdENvbm5lY3RlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlQ29ubmVjdFJlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IFtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oeyBuYW1lOiAndG9uX2FkZHInIH0sICh0aGlzLmRlc2lyZWRDaGFpbklkID8geyBuZXR3b3JrOiB0aGlzLmRlc2lyZWRDaGFpbklkIH0gOiB7fSkpXG4gICAgICAgIF07XG4gICAgICAgIGlmIChyZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlcXVlc3QudG9uUHJvb2YpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd0b25fcHJvb2YnLFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHJlcXVlc3QudG9uUHJvb2ZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYW5pZmVzdFVybDogdGhpcy5kYXBwU2V0dGluZ3MubWFuaWZlc3RVcmwsXG4gICAgICAgICAgICBpdGVtc1xuICAgICAgICB9O1xuICAgIH1cbn1cblRvbkNvbm5lY3Qud2FsbGV0c0xpc3QgPSBuZXcgV2FsbGV0c0xpc3RNYW5hZ2VyKCk7XG4vKipcbiAqIENoZWNrIGlmIHNwZWNpZmllZCB3YWxsZXQgaXMgaW5qZWN0ZWQgYW5kIGF2YWlsYWJsZSB0byB1c2Ugd2l0aCB0aGUgYXBwLlxuICogQHBhcmFtIHdhbGxldEpTS2V5IHRhcmdldCB3YWxsZXQncyBqcyBicmlkZ2Uga2V5LlxuICovXG5Ub25Db25uZWN0LmlzV2FsbGV0SW5qZWN0ZWQgPSAod2FsbGV0SlNLZXkpID0+IEluamVjdGVkUHJvdmlkZXIuaXNXYWxsZXRJbmplY3RlZCh3YWxsZXRKU0tleSk7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBhcHAgaXMgb3BlbmVkIGluc2lkZSBzcGVjaWZpZWQgd2FsbGV0J3MgYnJvd3Nlci5cbiAqIEBwYXJhbSB3YWxsZXRKU0tleSB0YXJnZXQgd2FsbGV0J3MganMgYnJpZGdlIGtleS5cbiAqL1xuVG9uQ29ubmVjdC5pc0luc2lkZVdhbGxldEJyb3dzZXIgPSAod2FsbGV0SlNLZXkpID0+IEluamVjdGVkUHJvdmlkZXIuaXNJbnNpZGVXYWxsZXRCcm93c2VyKHdhbGxldEpTS2V5KTtcblxuZXhwb3J0IHsgQmFkUmVxdWVzdEVycm9yLCBCcm93c2VyRXZlbnREaXNwYXRjaGVyLCBGZXRjaFdhbGxldHNFcnJvciwgTG9jYWxzdG9yYWdlTm90Rm91bmRFcnJvciwgUGFyc2VIZXhFcnJvciwgVG9uQ29ubmVjdCwgVG9uQ29ubmVjdEVycm9yLCBVVUlEdjcsIFVua25vd25BcHBFcnJvciwgVW5rbm93bkVycm9yLCBVc2VyUmVqZWN0c0Vycm9yLCBXYWxsZXRBbHJlYWR5Q29ubmVjdGVkRXJyb3IsIFdhbGxldE1pc3NpbmdSZXF1aXJlZEZlYXR1cmVzRXJyb3IsIFdhbGxldE5vdENvbm5lY3RlZEVycm9yLCBXYWxsZXROb3RJbmplY3RlZEVycm9yLCBXYWxsZXROb3RTdXBwb3J0RmVhdHVyZUVycm9yLCBXYWxsZXRXcm9uZ05ldHdvcmtFcnJvciwgV2FsbGV0c0xpc3RNYW5hZ2VyLCBXcm9uZ0FkZHJlc3NFcnJvciwgY2hlY2tSZXF1aXJlZFdhbGxldEZlYXR1cmVzLCBjcmVhdGVDb25uZWN0aW9uQ29tcGxldGVkRXZlbnQsIGNyZWF0ZUNvbm5lY3Rpb25FcnJvckV2ZW50LCBjcmVhdGVDb25uZWN0aW9uUmVzdG9yaW5nQ29tcGxldGVkRXZlbnQsIGNyZWF0ZUNvbm5lY3Rpb25SZXN0b3JpbmdFcnJvckV2ZW50LCBjcmVhdGVDb25uZWN0aW9uUmVzdG9yaW5nU3RhcnRlZEV2ZW50LCBjcmVhdGVDb25uZWN0aW9uU3RhcnRlZEV2ZW50LCBjcmVhdGVEYXRhU2VudEZvclNpZ25hdHVyZUV2ZW50LCBjcmVhdGVEYXRhU2lnbmVkRXZlbnQsIGNyZWF0ZURhdGFTaWduaW5nRmFpbGVkRXZlbnQsIGNyZWF0ZURpc2Nvbm5lY3Rpb25FdmVudCwgY3JlYXRlUmVxdWVzdFZlcnNpb25FdmVudCwgY3JlYXRlUmVzcG9uc2VWZXJzaW9uRXZlbnQsIGNyZWF0ZVNlbGVjdGVkV2FsbGV0RXZlbnQsIGNyZWF0ZVRyYW5zYWN0aW9uU2VudEZvclNpZ25hdHVyZUV2ZW50LCBjcmVhdGVUcmFuc2FjdGlvblNpZ25lZEV2ZW50LCBjcmVhdGVUcmFuc2FjdGlvblNpZ25pbmdGYWlsZWRFdmVudCwgY3JlYXRlVmVyc2lvbkluZm8sIGNyZWF0ZVdhbGxldE1vZGFsT3BlbmVkRXZlbnQsIGRlY29kZVRlbGVncmFtVXJsUGFyYW1ldGVycywgVG9uQ29ubmVjdCBhcyBkZWZhdWx0LCBlbmFibGVRYU1vZGUsIGVuY29kZVRlbGVncmFtVXJsUGFyYW1ldGVycywgaW5pdGlhbGl6ZVdhbGxldENvbm5lY3QsIGlzQ29ubmVjdFVybCwgaXNRYU1vZGVFbmFibGVkLCBpc1RlbGVncmFtVXJsLCBpc1dhbGxldENvbm5lY3RJbml0aWFsaXplZCwgaXNXYWxsZXRJbmZvQ3VycmVudGx5RW1iZWRkZWQsIGlzV2FsbGV0SW5mb0N1cnJlbnRseUluamVjdGVkLCBpc1dhbGxldEluZm9JbmplY3RhYmxlLCBpc1dhbGxldEluZm9JbmplY3RlZCwgaXNXYWxsZXRJbmZvUmVtb3RlLCB0b1VzZXJGcmllbmRseUFkZHJlc3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tonconnect/sdk/lib/esm/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tonconnect/ui-react/lib/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@tonconnect/ui-react/lib/index.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BadRequestError: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.BadRequestError),\n/* harmony export */   BrowserEventDispatcher: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.BrowserEventDispatcher),\n/* harmony export */   CHAIN: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.CHAIN),\n/* harmony export */   CONNECT_EVENT_ERROR_CODES: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.CONNECT_EVENT_ERROR_CODES),\n/* harmony export */   CONNECT_ITEM_ERROR_CODES: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.CONNECT_ITEM_ERROR_CODES),\n/* harmony export */   FetchWalletsError: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.FetchWalletsError),\n/* harmony export */   LocalstorageNotFoundError: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.LocalstorageNotFoundError),\n/* harmony export */   ParseHexError: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.ParseHexError),\n/* harmony export */   SEND_TRANSACTION_ERROR_CODES: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.SEND_TRANSACTION_ERROR_CODES),\n/* harmony export */   SIGN_DATA_ERROR_CODES: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.SIGN_DATA_ERROR_CODES),\n/* harmony export */   SessionCrypto: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.SessionCrypto),\n/* harmony export */   THEME: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.THEME),\n/* harmony export */   TonConnect: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.TonConnect),\n/* harmony export */   TonConnectButton: () => (/* binding */ TonConnectButton$1),\n/* harmony export */   TonConnectError: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.TonConnectError),\n/* harmony export */   TonConnectProviderNotSetError: () => (/* binding */ TonConnectProviderNotSetError),\n/* harmony export */   TonConnectUI: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.TonConnectUI),\n/* harmony export */   TonConnectUIContext: () => (/* binding */ TonConnectUIContext),\n/* harmony export */   TonConnectUIError: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.TonConnectUIError),\n/* harmony export */   TonConnectUIProvider: () => (/* binding */ TonConnectUIProvider$1),\n/* harmony export */   TonConnectUIReactError: () => (/* binding */ TonConnectUIReactError),\n/* harmony export */   UUIDv7: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.UUIDv7),\n/* harmony export */   UnknownAppError: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.UnknownAppError),\n/* harmony export */   UnknownError: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.UnknownError),\n/* harmony export */   UserRejectsError: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.UserRejectsError),\n/* harmony export */   WalletAlreadyConnectedError: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.WalletAlreadyConnectedError),\n/* harmony export */   WalletMissingRequiredFeaturesError: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.WalletMissingRequiredFeaturesError),\n/* harmony export */   WalletNotConnectedError: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.WalletNotConnectedError),\n/* harmony export */   WalletNotInjectedError: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.WalletNotInjectedError),\n/* harmony export */   WalletNotSupportFeatureError: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.WalletNotSupportFeatureError),\n/* harmony export */   WalletWrongNetworkError: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.WalletWrongNetworkError),\n/* harmony export */   WalletsListManager: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.WalletsListManager),\n/* harmony export */   WrongAddressError: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.WrongAddressError),\n/* harmony export */   checkRequiredWalletFeatures: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.checkRequiredWalletFeatures),\n/* harmony export */   createConnectionCompletedEvent: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createConnectionCompletedEvent),\n/* harmony export */   createConnectionErrorEvent: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createConnectionErrorEvent),\n/* harmony export */   createConnectionRestoringCompletedEvent: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createConnectionRestoringCompletedEvent),\n/* harmony export */   createConnectionRestoringErrorEvent: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createConnectionRestoringErrorEvent),\n/* harmony export */   createConnectionRestoringStartedEvent: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createConnectionRestoringStartedEvent),\n/* harmony export */   createConnectionStartedEvent: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createConnectionStartedEvent),\n/* harmony export */   createDataSentForSignatureEvent: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createDataSentForSignatureEvent),\n/* harmony export */   createDataSignedEvent: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createDataSignedEvent),\n/* harmony export */   createDataSigningFailedEvent: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createDataSigningFailedEvent),\n/* harmony export */   createDisconnectionEvent: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createDisconnectionEvent),\n/* harmony export */   createRequestVersionEvent: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createRequestVersionEvent),\n/* harmony export */   createResponseVersionEvent: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createResponseVersionEvent),\n/* harmony export */   createSelectedWalletEvent: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createSelectedWalletEvent),\n/* harmony export */   createTransactionSentForSignatureEvent: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createTransactionSentForSignatureEvent),\n/* harmony export */   createTransactionSignedEvent: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createTransactionSignedEvent),\n/* harmony export */   createTransactionSigningFailedEvent: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createTransactionSigningFailedEvent),\n/* harmony export */   createVersionInfo: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createVersionInfo),\n/* harmony export */   createWalletModalOpenedEvent: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createWalletModalOpenedEvent),\n/* harmony export */   decodeTelegramUrlParameters: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.decodeTelegramUrlParameters),\n/* harmony export */   enableQaMode: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.enableQaMode),\n/* harmony export */   encodeTelegramUrlParameters: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.encodeTelegramUrlParameters),\n/* harmony export */   initializeWalletConnect: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.initializeWalletConnect),\n/* harmony export */   isConnectUrl: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.isConnectUrl),\n/* harmony export */   isQaModeEnabled: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.isQaModeEnabled),\n/* harmony export */   isTelegramUrl: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.isTelegramUrl),\n/* harmony export */   isWalletConnectInitialized: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.isWalletConnectInitialized),\n/* harmony export */   isWalletInfoCurrentlyEmbedded: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.isWalletInfoCurrentlyEmbedded),\n/* harmony export */   isWalletInfoCurrentlyInjected: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.isWalletInfoCurrentlyInjected),\n/* harmony export */   isWalletInfoInjectable: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.isWalletInfoInjectable),\n/* harmony export */   isWalletInfoInjected: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.isWalletInfoInjected),\n/* harmony export */   isWalletInfoRemote: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.isWalletInfoRemote),\n/* harmony export */   toUserFriendlyAddress: () => (/* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.toUserFriendlyAddress),\n/* harmony export */   useIsConnectionRestored: () => (/* binding */ useIsConnectionRestored),\n/* harmony export */   useTonAddress: () => (/* binding */ useTonAddress),\n/* harmony export */   useTonConnectModal: () => (/* binding */ useTonConnectModal),\n/* harmony export */   useTonConnectUI: () => (/* binding */ useTonConnectUI),\n/* harmony export */   useTonWallet: () => (/* binding */ useTonWallet)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tonconnect/ui */ \"(ssr)/./node_modules/@tonconnect/ui/lib/index.mjs\");\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\n\n\n\n\nfunction isClientSide() {\n  return typeof window !== \"undefined\";\n}\nfunction isServerSide() {\n  return !isClientSide();\n}\nconst TonConnectUIContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nlet tonConnectUI = null;\nconst TonConnectUIProvider = (_a) => {\n  var _b = _a, {\n    children\n  } = _b, options = __objRest(_b, [\n    \"children\"\n  ]);\n  const [uiInstance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(() => {\n    if (!isClientSide()) {\n      return null;\n    }\n    if (tonConnectUI !== null) {\n      return tonConnectUI;\n    }\n    if (\"instance\" in options) {\n      tonConnectUI = options.instance;\n    } else {\n      tonConnectUI = new _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.TonConnectUI(options);\n    }\n    return tonConnectUI;\n  });\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(TonConnectUIContext.Provider, { value: uiInstance, children });\n};\nconst TonConnectUIProvider$1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(TonConnectUIProvider);\nclass TonConnectUIReactError extends _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.TonConnectUIError {\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, TonConnectUIReactError.prototype);\n  }\n}\nclass TonConnectProviderNotSetError extends TonConnectUIReactError {\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, TonConnectProviderNotSetError.prototype);\n  }\n}\nfunction checkProvider(provider) {\n  if (!provider) {\n    throw new TonConnectProviderNotSetError(\n      \"You should add <TonConnectUIProvider> on the top of the app to use TonConnect\"\n    );\n  }\n  return true;\n}\nfunction useTonConnectUI() {\n  const tonConnectUI2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(TonConnectUIContext);\n  const setOptions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (options) => {\n      if (tonConnectUI2) {\n        tonConnectUI2.uiOptions = options;\n      }\n    },\n    [tonConnectUI2]\n  );\n  if (isServerSide()) {\n    return [null, () => {\n    }];\n  }\n  checkProvider(tonConnectUI2);\n  return [tonConnectUI2, setOptions];\n}\nconst buttonRootId = \"ton-connect-button\";\nconst TonConnectButton = ({ className, style }) => {\n  const [_, setOptions] = useTonConnectUI();\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    setOptions({ buttonRootId });\n    return () => setOptions({ buttonRootId: null });\n  }, [setOptions]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    \"div\",\n    {\n      id: buttonRootId,\n      className,\n      style: __spreadValues({ width: \"fit-content\" }, style)\n    }\n  );\n};\nconst TonConnectButton$1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(TonConnectButton);\nfunction useTonWallet() {\n  const [tonConnectUI2] = useTonConnectUI();\n  const [wallet, setWallet] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\n    (tonConnectUI2 == null ? void 0 : tonConnectUI2.wallet) || null\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (tonConnectUI2) {\n      setWallet(tonConnectUI2.wallet);\n      return tonConnectUI2.onStatusChange((value) => {\n        setWallet(value);\n      });\n    }\n  }, [tonConnectUI2]);\n  return wallet;\n}\nfunction useTonAddress(userFriendly = true) {\n  const wallet = useTonWallet();\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    if (wallet) {\n      return userFriendly ? (0,_tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.toUserFriendlyAddress)(\n        wallet.account.address,\n        wallet.account.chain === _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.CHAIN.TESTNET\n      ) : wallet.account.address;\n    } else {\n      return \"\";\n    }\n  }, [wallet, userFriendly, wallet == null ? void 0 : wallet.account.address, wallet == null ? void 0 : wallet.account.chain]);\n}\nfunction useTonConnectModal() {\n  const [tonConnectUI2] = useTonConnectUI();\n  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)((tonConnectUI2 == null ? void 0 : tonConnectUI2.modal.state) || null);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (tonConnectUI2) {\n      setState(tonConnectUI2.modal.state);\n      return tonConnectUI2.onModalStateChange((value) => {\n        setState(value);\n      });\n    }\n  }, [tonConnectUI2]);\n  return {\n    state,\n    open: () => tonConnectUI2 == null ? void 0 : tonConnectUI2.modal.open(),\n    close: () => tonConnectUI2 == null ? void 0 : tonConnectUI2.modal.close()\n  };\n}\nfunction useIsConnectionRestored() {\n  const [restored, setRestored] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n  const [tonConnectUI2] = useTonConnectUI();\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (tonConnectUI2) {\n      tonConnectUI2.connectionRestored.then(() => setRestored(true));\n    }\n  }, [tonConnectUI2]);\n  return restored;\n}\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvbmNvbm5lY3QvdWktcmVhY3QvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDd0M7QUFDMkQ7QUFDSjtBQUNoRTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0RBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHlCQUF5Qix3REFBWTtBQUNyQztBQUNBO0FBQ0EsR0FBRztBQUNILHlCQUF5QixzREFBRyxpQ0FBaUMsNkJBQTZCO0FBQzFGO0FBQ0EsK0JBQStCLDJDQUFJO0FBQ25DLHFDQUFxQyw2REFBaUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpREFBVTtBQUNsQyxxQkFBcUIsa0RBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQSxFQUFFLGdEQUFTO0FBQ1gsaUJBQWlCLGNBQWM7QUFDL0IsOEJBQThCLG9CQUFvQjtBQUNsRCxHQUFHO0FBQ0gseUJBQXlCLHNEQUFHO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNCQUFzQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkNBQUk7QUFDL0I7QUFDQTtBQUNBLDhCQUE4QiwrQ0FBUTtBQUN0QztBQUNBO0FBQ0EsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4Q0FBTztBQUNoQjtBQUNBLDRCQUE0QixxRUFBcUI7QUFDakQ7QUFDQSxpQ0FBaUMsaURBQUs7QUFDdEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0NBQVE7QUFDcEMsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtDQUFRO0FBQzFDO0FBQ0EsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBWUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3RtYS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdG9uY29ubmVjdC91aS1yZWFjdC9saWIvaW5kZXgubWpzP2NlZDAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fb2JqUmVzdCA9IChzb3VyY2UsIGV4Y2x1ZGUpID0+IHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoc291cmNlLCBwcm9wKSAmJiBleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwKVxuICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICBpZiAoc291cmNlICE9IG51bGwgJiYgX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoc291cmNlKSkge1xuICAgICAgaWYgKGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDAgJiYgX19wcm9wSXNFbnVtLmNhbGwoc291cmNlLCBwcm9wKSlcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIG1lbW8sIHVzZVN0YXRlLCB1c2VDb250ZXh0LCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBUb25Db25uZWN0VUksIFRvbkNvbm5lY3RVSUVycm9yLCB0b1VzZXJGcmllbmRseUFkZHJlc3MsIENIQUlOIH0gZnJvbSBcIkB0b25jb25uZWN0L3VpXCI7XG5leHBvcnQgKiBmcm9tIFwiQHRvbmNvbm5lY3QvdWlcIjtcbmZ1bmN0aW9uIGlzQ2xpZW50U2lkZSgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59XG5mdW5jdGlvbiBpc1NlcnZlclNpZGUoKSB7XG4gIHJldHVybiAhaXNDbGllbnRTaWRlKCk7XG59XG5jb25zdCBUb25Db25uZWN0VUlDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmxldCB0b25Db25uZWN0VUkgPSBudWxsO1xuY29uc3QgVG9uQ29ubmVjdFVJUHJvdmlkZXIgPSAoX2EpID0+IHtcbiAgdmFyIF9iID0gX2EsIHtcbiAgICBjaGlsZHJlblxuICB9ID0gX2IsIG9wdGlvbnMgPSBfX29ialJlc3QoX2IsIFtcbiAgICBcImNoaWxkcmVuXCJcbiAgXSk7XG4gIGNvbnN0IFt1aUluc3RhbmNlXSA9IHVzZVN0YXRlKCgpID0+IHtcbiAgICBpZiAoIWlzQ2xpZW50U2lkZSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvbkNvbm5lY3RVSSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRvbkNvbm5lY3RVSTtcbiAgICB9XG4gICAgaWYgKFwiaW5zdGFuY2VcIiBpbiBvcHRpb25zKSB7XG4gICAgICB0b25Db25uZWN0VUkgPSBvcHRpb25zLmluc3RhbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b25Db25uZWN0VUkgPSBuZXcgVG9uQ29ubmVjdFVJKG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9uQ29ubmVjdFVJO1xuICB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goVG9uQ29ubmVjdFVJQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdWlJbnN0YW5jZSwgY2hpbGRyZW4gfSk7XG59O1xuY29uc3QgVG9uQ29ubmVjdFVJUHJvdmlkZXIkMSA9IG1lbW8oVG9uQ29ubmVjdFVJUHJvdmlkZXIpO1xuY2xhc3MgVG9uQ29ubmVjdFVJUmVhY3RFcnJvciBleHRlbmRzIFRvbkNvbm5lY3RVSUVycm9yIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBUb25Db25uZWN0VUlSZWFjdEVycm9yLnByb3RvdHlwZSk7XG4gIH1cbn1cbmNsYXNzIFRvbkNvbm5lY3RQcm92aWRlck5vdFNldEVycm9yIGV4dGVuZHMgVG9uQ29ubmVjdFVJUmVhY3RFcnJvciB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgVG9uQ29ubmVjdFByb3ZpZGVyTm90U2V0RXJyb3IucHJvdG90eXBlKTtcbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tQcm92aWRlcihwcm92aWRlcikge1xuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RQcm92aWRlck5vdFNldEVycm9yKFxuICAgICAgXCJZb3Ugc2hvdWxkIGFkZCA8VG9uQ29ubmVjdFVJUHJvdmlkZXI+IG9uIHRoZSB0b3Agb2YgdGhlIGFwcCB0byB1c2UgVG9uQ29ubmVjdFwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHVzZVRvbkNvbm5lY3RVSSgpIHtcbiAgY29uc3QgdG9uQ29ubmVjdFVJMiA9IHVzZUNvbnRleHQoVG9uQ29ubmVjdFVJQ29udGV4dCk7XG4gIGNvbnN0IHNldE9wdGlvbnMgPSB1c2VDYWxsYmFjayhcbiAgICAob3B0aW9ucykgPT4ge1xuICAgICAgaWYgKHRvbkNvbm5lY3RVSTIpIHtcbiAgICAgICAgdG9uQ29ubmVjdFVJMi51aU9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3RvbkNvbm5lY3RVSTJdXG4gICk7XG4gIGlmIChpc1NlcnZlclNpZGUoKSkge1xuICAgIHJldHVybiBbbnVsbCwgKCkgPT4ge1xuICAgIH1dO1xuICB9XG4gIGNoZWNrUHJvdmlkZXIodG9uQ29ubmVjdFVJMik7XG4gIHJldHVybiBbdG9uQ29ubmVjdFVJMiwgc2V0T3B0aW9uc107XG59XG5jb25zdCBidXR0b25Sb290SWQgPSBcInRvbi1jb25uZWN0LWJ1dHRvblwiO1xuY29uc3QgVG9uQ29ubmVjdEJ1dHRvbiA9ICh7IGNsYXNzTmFtZSwgc3R5bGUgfSkgPT4ge1xuICBjb25zdCBbXywgc2V0T3B0aW9uc10gPSB1c2VUb25Db25uZWN0VUkoKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRPcHRpb25zKHsgYnV0dG9uUm9vdElkIH0pO1xuICAgIHJldHVybiAoKSA9PiBzZXRPcHRpb25zKHsgYnV0dG9uUm9vdElkOiBudWxsIH0pO1xuICB9LCBbc2V0T3B0aW9uc10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIGlkOiBidXR0b25Sb290SWQsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICBzdHlsZTogX19zcHJlYWRWYWx1ZXMoeyB3aWR0aDogXCJmaXQtY29udGVudFwiIH0sIHN0eWxlKVxuICAgIH1cbiAgKTtcbn07XG5jb25zdCBUb25Db25uZWN0QnV0dG9uJDEgPSBtZW1vKFRvbkNvbm5lY3RCdXR0b24pO1xuZnVuY3Rpb24gdXNlVG9uV2FsbGV0KCkge1xuICBjb25zdCBbdG9uQ29ubmVjdFVJMl0gPSB1c2VUb25Db25uZWN0VUkoKTtcbiAgY29uc3QgW3dhbGxldCwgc2V0V2FsbGV0XSA9IHVzZVN0YXRlKFxuICAgICh0b25Db25uZWN0VUkyID09IG51bGwgPyB2b2lkIDAgOiB0b25Db25uZWN0VUkyLndhbGxldCkgfHwgbnVsbFxuICApO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0b25Db25uZWN0VUkyKSB7XG4gICAgICBzZXRXYWxsZXQodG9uQ29ubmVjdFVJMi53YWxsZXQpO1xuICAgICAgcmV0dXJuIHRvbkNvbm5lY3RVSTIub25TdGF0dXNDaGFuZ2UoKHZhbHVlKSA9PiB7XG4gICAgICAgIHNldFdhbGxldCh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFt0b25Db25uZWN0VUkyXSk7XG4gIHJldHVybiB3YWxsZXQ7XG59XG5mdW5jdGlvbiB1c2VUb25BZGRyZXNzKHVzZXJGcmllbmRseSA9IHRydWUpIHtcbiAgY29uc3Qgd2FsbGV0ID0gdXNlVG9uV2FsbGV0KCk7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAod2FsbGV0KSB7XG4gICAgICByZXR1cm4gdXNlckZyaWVuZGx5ID8gdG9Vc2VyRnJpZW5kbHlBZGRyZXNzKFxuICAgICAgICB3YWxsZXQuYWNjb3VudC5hZGRyZXNzLFxuICAgICAgICB3YWxsZXQuYWNjb3VudC5jaGFpbiA9PT0gQ0hBSU4uVEVTVE5FVFxuICAgICAgKSA6IHdhbGxldC5hY2NvdW50LmFkZHJlc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgfSwgW3dhbGxldCwgdXNlckZyaWVuZGx5LCB3YWxsZXQgPT0gbnVsbCA/IHZvaWQgMCA6IHdhbGxldC5hY2NvdW50LmFkZHJlc3MsIHdhbGxldCA9PSBudWxsID8gdm9pZCAwIDogd2FsbGV0LmFjY291bnQuY2hhaW5dKTtcbn1cbmZ1bmN0aW9uIHVzZVRvbkNvbm5lY3RNb2RhbCgpIHtcbiAgY29uc3QgW3RvbkNvbm5lY3RVSTJdID0gdXNlVG9uQ29ubmVjdFVJKCk7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUoKHRvbkNvbm5lY3RVSTIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvbkNvbm5lY3RVSTIubW9kYWwuc3RhdGUpIHx8IG51bGwpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0b25Db25uZWN0VUkyKSB7XG4gICAgICBzZXRTdGF0ZSh0b25Db25uZWN0VUkyLm1vZGFsLnN0YXRlKTtcbiAgICAgIHJldHVybiB0b25Db25uZWN0VUkyLm9uTW9kYWxTdGF0ZUNoYW5nZSgodmFsdWUpID0+IHtcbiAgICAgICAgc2V0U3RhdGUodmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBbdG9uQ29ubmVjdFVJMl0pO1xuICByZXR1cm4ge1xuICAgIHN0YXRlLFxuICAgIG9wZW46ICgpID0+IHRvbkNvbm5lY3RVSTIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvbkNvbm5lY3RVSTIubW9kYWwub3BlbigpLFxuICAgIGNsb3NlOiAoKSA9PiB0b25Db25uZWN0VUkyID09IG51bGwgPyB2b2lkIDAgOiB0b25Db25uZWN0VUkyLm1vZGFsLmNsb3NlKClcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUlzQ29ubmVjdGlvblJlc3RvcmVkKCkge1xuICBjb25zdCBbcmVzdG9yZWQsIHNldFJlc3RvcmVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3RvbkNvbm5lY3RVSTJdID0gdXNlVG9uQ29ubmVjdFVJKCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHRvbkNvbm5lY3RVSTIpIHtcbiAgICAgIHRvbkNvbm5lY3RVSTIuY29ubmVjdGlvblJlc3RvcmVkLnRoZW4oKCkgPT4gc2V0UmVzdG9yZWQodHJ1ZSkpO1xuICAgIH1cbiAgfSwgW3RvbkNvbm5lY3RVSTJdKTtcbiAgcmV0dXJuIHJlc3RvcmVkO1xufVxuZXhwb3J0IHtcbiAgVG9uQ29ubmVjdEJ1dHRvbiQxIGFzIFRvbkNvbm5lY3RCdXR0b24sXG4gIFRvbkNvbm5lY3RQcm92aWRlck5vdFNldEVycm9yLFxuICBUb25Db25uZWN0VUlDb250ZXh0LFxuICBUb25Db25uZWN0VUlQcm92aWRlciQxIGFzIFRvbkNvbm5lY3RVSVByb3ZpZGVyLFxuICBUb25Db25uZWN0VUlSZWFjdEVycm9yLFxuICB1c2VJc0Nvbm5lY3Rpb25SZXN0b3JlZCxcbiAgdXNlVG9uQWRkcmVzcyxcbiAgdXNlVG9uQ29ubmVjdE1vZGFsLFxuICB1c2VUb25Db25uZWN0VUksXG4gIHVzZVRvbldhbGxldFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tonconnect/ui-react/lib/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tonconnect/ui/lib/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@tonconnect/ui/lib/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BadRequestError: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.BadRequestError),\n/* harmony export */   BrowserEventDispatcher: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.BrowserEventDispatcher),\n/* harmony export */   CHAIN: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.CHAIN),\n/* harmony export */   CONNECT_EVENT_ERROR_CODES: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES),\n/* harmony export */   CONNECT_ITEM_ERROR_CODES: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.CONNECT_ITEM_ERROR_CODES),\n/* harmony export */   FetchWalletsError: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.FetchWalletsError),\n/* harmony export */   LocalstorageNotFoundError: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.LocalstorageNotFoundError),\n/* harmony export */   ParseHexError: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.ParseHexError),\n/* harmony export */   SEND_TRANSACTION_ERROR_CODES: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES),\n/* harmony export */   SIGN_DATA_ERROR_CODES: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.SIGN_DATA_ERROR_CODES),\n/* harmony export */   SessionCrypto: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.SessionCrypto),\n/* harmony export */   THEME: () => (/* binding */ THEME),\n/* harmony export */   TonConnect: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnect),\n/* harmony export */   TonConnectError: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnectError),\n/* harmony export */   TonConnectUI: () => (/* binding */ TonConnectUI),\n/* harmony export */   TonConnectUIError: () => (/* binding */ TonConnectUIError),\n/* harmony export */   UUIDv7: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.UUIDv7),\n/* harmony export */   UnknownAppError: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.UnknownAppError),\n/* harmony export */   UnknownError: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.UnknownError),\n/* harmony export */   UserRejectsError: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.UserRejectsError),\n/* harmony export */   WalletAlreadyConnectedError: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletAlreadyConnectedError),\n/* harmony export */   WalletMissingRequiredFeaturesError: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletMissingRequiredFeaturesError),\n/* harmony export */   WalletNotConnectedError: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletNotConnectedError),\n/* harmony export */   WalletNotInjectedError: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletNotInjectedError),\n/* harmony export */   WalletNotSupportFeatureError: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletNotSupportFeatureError),\n/* harmony export */   WalletWrongNetworkError: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletWrongNetworkError),\n/* harmony export */   WalletsListManager: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletsListManager),\n/* harmony export */   WrongAddressError: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WrongAddressError),\n/* harmony export */   checkRequiredWalletFeatures: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.checkRequiredWalletFeatures),\n/* harmony export */   createConnectionCompletedEvent: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionCompletedEvent),\n/* harmony export */   createConnectionErrorEvent: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionErrorEvent),\n/* harmony export */   createConnectionRestoringCompletedEvent: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionRestoringCompletedEvent),\n/* harmony export */   createConnectionRestoringErrorEvent: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionRestoringErrorEvent),\n/* harmony export */   createConnectionRestoringStartedEvent: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionRestoringStartedEvent),\n/* harmony export */   createConnectionStartedEvent: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionStartedEvent),\n/* harmony export */   createDataSentForSignatureEvent: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createDataSentForSignatureEvent),\n/* harmony export */   createDataSignedEvent: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createDataSignedEvent),\n/* harmony export */   createDataSigningFailedEvent: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createDataSigningFailedEvent),\n/* harmony export */   createDisconnectionEvent: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createDisconnectionEvent),\n/* harmony export */   createRequestVersionEvent: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createRequestVersionEvent),\n/* harmony export */   createResponseVersionEvent: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createResponseVersionEvent),\n/* harmony export */   createSelectedWalletEvent: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createSelectedWalletEvent),\n/* harmony export */   createTransactionSentForSignatureEvent: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createTransactionSentForSignatureEvent),\n/* harmony export */   createTransactionSignedEvent: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createTransactionSignedEvent),\n/* harmony export */   createTransactionSigningFailedEvent: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createTransactionSigningFailedEvent),\n/* harmony export */   createVersionInfo: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createVersionInfo),\n/* harmony export */   createWalletModalOpenedEvent: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createWalletModalOpenedEvent),\n/* harmony export */   decodeTelegramUrlParameters: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.decodeTelegramUrlParameters),\n/* harmony export */   enableQaMode: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.enableQaMode),\n/* harmony export */   encodeTelegramUrlParameters: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.encodeTelegramUrlParameters),\n/* harmony export */   initializeWalletConnect: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.initializeWalletConnect),\n/* harmony export */   isConnectUrl: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isConnectUrl),\n/* harmony export */   isQaModeEnabled: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isQaModeEnabled),\n/* harmony export */   isTelegramUrl: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isTelegramUrl),\n/* harmony export */   isWalletConnectInitialized: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletConnectInitialized),\n/* harmony export */   isWalletInfoCurrentlyEmbedded: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyEmbedded),\n/* harmony export */   isWalletInfoCurrentlyInjected: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyInjected),\n/* harmony export */   isWalletInfoInjectable: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoInjectable),\n/* harmony export */   isWalletInfoInjected: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoInjected),\n/* harmony export */   isWalletInfoRemote: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoRemote),\n/* harmony export */   toUserFriendlyAddress: () => (/* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.toUserFriendlyAddress)\n/* harmony export */ });\n/* harmony import */ var _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tonconnect/sdk */ \"(ssr)/./node_modules/@tonconnect/sdk/lib/esm/index.mjs\");\n/* harmony import */ var ua_parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ua-parser-js */ \"(ssr)/./node_modules/ua-parser-js/src/ua-parser.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! deepmerge */ \"(ssr)/./node_modules/deepmerge/dist/cjs.js\");\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! classnames */ \"(ssr)/./node_modules/classnames/index.js\");\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a2, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a2, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a2, prop, b[prop]);\n    }\n  return a2;\n};\nvar __spreadProps = (a2, b) => __defProps(a2, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e2) {\n        reject(e2);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e2) {\n        reject(e2);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar _a, _b, _c, _d, _e, _f, _g, _h;\n\n\n\n\n\nconst IS_DEV = false;\nconst equalFn = (a2, b) => a2 === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst SUPPORTS_PROXY = typeof Proxy === \"function\";\nconst $TRACK = Symbol(\"solid-track\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet runEffects = runQueue;\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst NO_INIT = {};\nvar Owner = null;\nlet Transition$1 = null;\nlet ExternalSourceConfig = null;\nlet Listener = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nfunction createRoot(fn, detachedOwner) {\n  const listener = Listener, owner = Owner, unowned = fn.length === 0, current = detachedOwner === void 0 ? owner : detachedOwner, root = unowned ? UNOWNED : {\n    owned: null,\n    cleanups: null,\n    context: current ? current.context : null,\n    owner: current\n  }, updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));\n  Owner = root;\n  Listener = null;\n  try {\n    return runUpdates(updateFn, true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s2 = {\n    value,\n    observers: null,\n    observerSlots: null,\n    comparator: options.equals || void 0\n  };\n  const setter = (value2) => {\n    if (typeof value2 === \"function\") {\n      value2 = value2(s2.value);\n    }\n    return writeSignal(s2, value2);\n  };\n  return [readSignal.bind(s2), setter];\n}\nfunction createComputed(fn, value, options) {\n  const c2 = createComputation(fn, value, true, STALE);\n  updateComputation(c2);\n}\nfunction createRenderEffect(fn, value, options) {\n  const c2 = createComputation(fn, value, false, STALE);\n  updateComputation(c2);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c2 = createComputation(fn, value, false, STALE);\n  if (!options || !options.render) c2.user = true;\n  Effects ? Effects.push(c2) : updateComputation(c2);\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c2 = createComputation(fn, value, true, 0);\n  c2.observers = null;\n  c2.observerSlots = null;\n  c2.comparator = options.equals || void 0;\n  updateComputation(c2);\n  return readSignal.bind(c2);\n}\nfunction isPromise(v) {\n  return v && typeof v === \"object\" && \"then\" in v;\n}\nfunction createResource(pSource, pFetcher, pOptions) {\n  let source;\n  let fetcher;\n  let options;\n  {\n    source = true;\n    fetcher = pSource;\n    options = {};\n  }\n  let pr = null, initP = NO_INIT, scheduled = false, resolved = \"initialValue\" in options, dynamic = typeof source === \"function\" && createMemo(source);\n  const contexts = /* @__PURE__ */ new Set(), [value, setValue] = (options.storage || createSignal)(options.initialValue), [error, setError] = createSignal(void 0), [track, trigger] = createSignal(void 0, {\n    equals: false\n  }), [state, setState] = createSignal(resolved ? \"ready\" : \"unresolved\");\n  function loadEnd(p2, v, error2, key) {\n    if (pr === p2) {\n      pr = null;\n      key !== void 0 && (resolved = true);\n      if ((p2 === initP || v === initP) && options.onHydrated) queueMicrotask(() => options.onHydrated(key, {\n        value: v\n      }));\n      initP = NO_INIT;\n      completeLoad(v, error2);\n    }\n    return v;\n  }\n  function completeLoad(v, err) {\n    runUpdates(() => {\n      if (err === void 0) setValue(() => v);\n      setState(err !== void 0 ? \"errored\" : resolved ? \"ready\" : \"unresolved\");\n      setError(err);\n      for (const c2 of contexts.keys()) c2.decrement();\n      contexts.clear();\n    }, false);\n  }\n  function read() {\n    const c2 = SuspenseContext, v = value(), err = error();\n    if (err !== void 0 && !pr) throw err;\n    if (Listener && !Listener.user && c2) ;\n    return v;\n  }\n  function load(refetching = true) {\n    if (refetching !== false && scheduled) return;\n    scheduled = false;\n    const lookup = dynamic ? dynamic() : source;\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(value));\n      return;\n    }\n    let error2;\n    const p2 = initP !== NO_INIT ? initP : untrack(() => {\n      try {\n        return fetcher(lookup, {\n          value: value(),\n          refetching\n        });\n      } catch (fetcherError) {\n        error2 = fetcherError;\n      }\n    });\n    if (error2 !== void 0) {\n      loadEnd(pr, void 0, castError(error2), lookup);\n      return;\n    } else if (!isPromise(p2)) {\n      loadEnd(pr, p2, void 0, lookup);\n      return p2;\n    }\n    pr = p2;\n    if (\"v\" in p2) {\n      if (p2.s === 1) loadEnd(pr, p2.v, void 0, lookup);\n      else loadEnd(pr, void 0, castError(p2.v), lookup);\n      return p2;\n    }\n    scheduled = true;\n    queueMicrotask(() => scheduled = false);\n    runUpdates(() => {\n      setState(resolved ? \"refreshing\" : \"pending\");\n      trigger();\n    }, false);\n    return p2.then((v) => loadEnd(p2, v, void 0, lookup), (e2) => loadEnd(p2, void 0, castError(e2), lookup));\n  }\n  Object.defineProperties(read, {\n    state: {\n      get: () => state()\n    },\n    error: {\n      get: () => error()\n    },\n    loading: {\n      get() {\n        const s2 = state();\n        return s2 === \"pending\" || s2 === \"refreshing\";\n      }\n    },\n    latest: {\n      get() {\n        if (!resolved) return read();\n        const err = error();\n        if (err && !pr) throw err;\n        return value();\n      }\n    }\n  });\n  let owner = Owner;\n  if (dynamic) createComputed(() => (owner = Owner, load(false)));\n  else load(false);\n  return [read, {\n    refetch: (info) => runWithOwner(owner, () => load(info)),\n    mutate: setValue\n  }];\n}\nfunction batch(fn) {\n  return runUpdates(fn, false);\n}\nfunction untrack(fn) {\n  if (Listener === null) return fn();\n  const listener = Listener;\n  Listener = null;\n  try {\n    if (ExternalSourceConfig) ;\n    return fn();\n  } finally {\n    Listener = listener;\n  }\n}\nfunction on(deps, fn, options) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  return (prevValue) => {\n    let input;\n    if (isArray) {\n      input = Array(deps.length);\n      for (let i2 = 0; i2 < deps.length; i2++) input[i2] = deps[i2]();\n    } else input = deps();\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null) ;\n  else if (Owner.cleanups === null) Owner.cleanups = [fn];\n  else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction getListener() {\n  return Listener;\n}\nfunction getOwner() {\n  return Owner;\n}\nfunction runWithOwner(o2, fn) {\n  const prev = Owner;\n  const prevListener = Listener;\n  Owner = o2;\n  Listener = null;\n  try {\n    return runUpdates(fn, true);\n  } catch (err) {\n    handleError(err);\n  } finally {\n    Owner = prev;\n    Listener = prevListener;\n  }\n}\nfunction startTransition(fn) {\n  const l2 = Listener;\n  const o2 = Owner;\n  return Promise.resolve().then(() => {\n    Listener = l2;\n    Owner = o2;\n    runUpdates(fn, false);\n    Listener = Owner = null;\n    return void 0;\n  });\n}\nconst [transPending, setTransPending] = /* @__PURE__ */ createSignal(false);\nfunction useTransition() {\n  return [transPending, startTransition];\n}\nfunction createContext(defaultValue, options) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\nfunction useContext(context) {\n  let value;\n  return Owner && Owner.context && (value = Owner.context[context.id]) !== void 0 ? value : context.defaultValue;\n}\nfunction children(fn) {\n  const children2 = createMemo(fn);\n  const memo2 = createMemo(() => resolveChildren(children2()));\n  memo2.toArray = () => {\n    const c2 = memo2();\n    return Array.isArray(c2) ? c2 : c2 != null ? [c2] : [];\n  };\n  return memo2;\n}\nlet SuspenseContext;\nfunction readSignal() {\n  if (this.sources && this.state) {\n    if (this.state === STALE) updateComputation(this);\n    else {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(this), false);\n      Updates = updates;\n    }\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  let current = node.value;\n  if (!node.comparator || !node.comparator(current, value)) {\n    node.value = value;\n    if (node.observers && node.observers.length) {\n      runUpdates(() => {\n        for (let i2 = 0; i2 < node.observers.length; i2 += 1) {\n          const o2 = node.observers[i2];\n          const TransitionRunning = Transition$1 && Transition$1.running;\n          if (TransitionRunning && Transition$1.disposed.has(o2)) ;\n          if (TransitionRunning ? !o2.tState : !o2.state) {\n            if (o2.pure) Updates.push(o2);\n            else Effects.push(o2);\n            if (o2.observers) markDownstream(o2);\n          }\n          if (!TransitionRunning) o2.state = STALE;\n        }\n        if (Updates.length > 1e6) {\n          Updates = [];\n          if (IS_DEV) ;\n          throw new Error();\n        }\n      }, false);\n    }\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const time = ExecCount;\n  runComputation(node, node.value, time);\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  const owner = Owner, listener = Listener;\n  Listener = Owner = node;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    if (node.pure) {\n      {\n        node.state = STALE;\n        node.owned && node.owned.forEach(cleanNode);\n        node.owned = null;\n      }\n    }\n    node.updatedAt = time + 1;\n    return handleError(err);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.updatedAt != null && \"observers\" in node) {\n      writeSignal(node, nextValue);\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c2 = {\n    fn,\n    state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: Owner ? Owner.context : null,\n    pure\n  };\n  if (Owner === null) ;\n  else if (Owner !== UNOWNED) {\n    {\n      if (!Owner.owned) Owner.owned = [c2];\n      else Owner.owned.push(c2);\n    }\n  }\n  return c2;\n}\nfunction runTop(node) {\n  if (node.state === 0) return;\n  if (node.state === PENDING) return lookUpstream(node);\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (node.state) ancestors.push(node);\n  }\n  for (let i2 = ancestors.length - 1; i2 >= 0; i2--) {\n    node = ancestors[i2];\n    if (node.state === STALE) {\n      updateComputation(node);\n    } else if (node.state === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(node, ancestors[0]), false);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;\n  else Effects = [];\n  ExecCount++;\n  try {\n    const res = fn();\n    completeUpdates(wait);\n    return res;\n  } catch (err) {\n    if (!wait) Effects = null;\n    Updates = null;\n    handleError(err);\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  const e2 = Effects;\n  Effects = null;\n  if (e2.length) runUpdates(() => runEffects(e2), false);\n}\nfunction runQueue(queue) {\n  for (let i2 = 0; i2 < queue.length; i2++) runTop(queue[i2]);\n}\nfunction runUserEffects(queue) {\n  let i2, userLength = 0;\n  for (i2 = 0; i2 < queue.length; i2++) {\n    const e2 = queue[i2];\n    if (!e2.user) runTop(e2);\n    else queue[userLength++] = e2;\n  }\n  for (i2 = 0; i2 < userLength; i2++) runTop(queue[i2]);\n}\nfunction lookUpstream(node, ignore) {\n  node.state = 0;\n  for (let i2 = 0; i2 < node.sources.length; i2 += 1) {\n    const source = node.sources[i2];\n    if (source.sources) {\n      const state = source.state;\n      if (state === STALE) {\n        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);\n      } else if (state === PENDING) lookUpstream(source, ignore);\n    }\n  }\n}\nfunction markDownstream(node) {\n  for (let i2 = 0; i2 < node.observers.length; i2 += 1) {\n    const o2 = node.observers[i2];\n    if (!o2.state) {\n      o2.state = PENDING;\n      if (o2.pure) Updates.push(o2);\n      else Effects.push(o2);\n      o2.observers && markDownstream(o2);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i2;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;\n      if (obs && obs.length) {\n        const n2 = obs.pop(), s2 = source.observerSlots.pop();\n        if (index < obs.length) {\n          n2.sourceSlots[s2] = index;\n          obs[index] = n2;\n          source.observerSlots[index] = s2;\n        }\n      }\n    }\n  }\n  if (node.tOwned) {\n    for (i2 = node.tOwned.length - 1; i2 >= 0; i2--) cleanNode(node.tOwned[i2]);\n    delete node.tOwned;\n  }\n  if (node.owned) {\n    for (i2 = node.owned.length - 1; i2 >= 0; i2--) cleanNode(node.owned[i2]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i2 = node.cleanups.length - 1; i2 >= 0; i2--) node.cleanups[i2]();\n    node.cleanups = null;\n  }\n  node.state = 0;\n}\nfunction castError(err) {\n  if (err instanceof Error) return err;\n  return new Error(typeof err === \"string\" ? err : \"Unknown error\", {\n    cause: err\n  });\n}\nfunction handleError(err, owner = Owner) {\n  const error = castError(err);\n  throw error;\n}\nfunction resolveChildren(children2) {\n  if (typeof children2 === \"function\" && !children2.length) return resolveChildren(children2());\n  if (Array.isArray(children2)) {\n    const results = [];\n    for (let i2 = 0; i2 < children2.length; i2++) {\n      const result = resolveChildren(children2[i2]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children2;\n}\nfunction createProvider(id, options) {\n  return function provider(props) {\n    let res;\n    createRenderEffect(() => res = untrack(() => {\n      Owner.context = __spreadProps(__spreadValues({}, Owner.context), {\n        [id]: props.value\n      });\n      return children(() => props.children);\n    }), void 0);\n    return res;\n  };\n}\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i2 = 0; i2 < d.length; i2++) d[i2]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [], mapped = [], disposers = [], len = 0, indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [], newLen = newItems.length, i2, j;\n    newItems[$TRACK];\n    return untrack(() => {\n      let newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start, end, newEnd, item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot((disposer) => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      } else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++) ;\n        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = /* @__PURE__ */ new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i2 = newIndices.get(item);\n          newIndicesNext[j] = i2 === void 0 ? -1 : i2;\n          newIndices.set(item, j);\n        }\n        for (i2 = start; i2 <= end; i2++) {\n          item = items[i2];\n          j = newIndices.get(item);\n          if (j !== void 0 && j !== -1) {\n            temp[j] = mapped[i2];\n            tempdisposers[j] = disposers[i2];\n            indexes && (tempIndexes[j] = indexes[i2]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i2]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, len = newLen);\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s2, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s2);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction createComponent(Comp, props) {\n  return untrack(() => Comp(props || {}));\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    if (property === $PROXY) return true;\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s2) {\n  return !(s2 = typeof s2 === \"function\" ? s2() : s2) ? {} : s2;\n}\nfunction resolveSources() {\n  for (let i2 = 0, length = this.length; i2 < length; ++i2) {\n    const v = this[i2]();\n    if (v !== void 0) return v;\n  }\n}\nfunction mergeProps(...sources) {\n  let proxy = false;\n  for (let i2 = 0; i2 < sources.length; i2++) {\n    const s2 = sources[i2];\n    proxy = proxy || !!s2 && $PROXY in s2;\n    sources[i2] = typeof s2 === \"function\" ? (proxy = true, createMemo(s2)) : s2;\n  }\n  if (SUPPORTS_PROXY && proxy) {\n    return new Proxy({\n      get(property) {\n        for (let i2 = sources.length - 1; i2 >= 0; i2--) {\n          const v = resolveSource(sources[i2])[property];\n          if (v !== void 0) return v;\n        }\n      },\n      has(property) {\n        for (let i2 = sources.length - 1; i2 >= 0; i2--) {\n          if (property in resolveSource(sources[i2])) return true;\n        }\n        return false;\n      },\n      keys() {\n        const keys = [];\n        for (let i2 = 0; i2 < sources.length; i2++) keys.push(...Object.keys(resolveSource(sources[i2])));\n        return [...new Set(keys)];\n      }\n    }, propTraps);\n  }\n  const sourcesMap = {};\n  const defined = /* @__PURE__ */ Object.create(null);\n  for (let i2 = sources.length - 1; i2 >= 0; i2--) {\n    const source = sources[i2];\n    if (!source) continue;\n    const sourceKeys = Object.getOwnPropertyNames(source);\n    for (let i3 = sourceKeys.length - 1; i3 >= 0; i3--) {\n      const key = sourceKeys[i3];\n      if (key === \"__proto__\" || key === \"constructor\") continue;\n      const desc = Object.getOwnPropertyDescriptor(source, key);\n      if (!defined[key]) {\n        defined[key] = desc.get ? {\n          enumerable: true,\n          configurable: true,\n          get: resolveSources.bind(sourcesMap[key] = [desc.get.bind(source)])\n        } : desc.value !== void 0 ? desc : void 0;\n      } else {\n        const sources2 = sourcesMap[key];\n        if (sources2) {\n          if (desc.get) sources2.push(desc.get.bind(source));\n          else if (desc.value !== void 0) sources2.push(() => desc.value);\n        }\n      }\n    }\n  }\n  const target = {};\n  const definedKeys = Object.keys(defined);\n  for (let i2 = definedKeys.length - 1; i2 >= 0; i2--) {\n    const key = definedKeys[i2], desc = defined[key];\n    if (desc && desc.get) Object.defineProperty(target, key, desc);\n    else target[key] = desc ? desc.value : void 0;\n  }\n  return target;\n}\nfunction splitProps(props, ...keys) {\n  if (SUPPORTS_PROXY && $PROXY in props) {\n    const blocked = new Set(keys.length > 1 ? keys.flat() : keys[0]);\n    const res = keys.map((k) => {\n      return new Proxy({\n        get(property) {\n          return k.includes(property) ? props[property] : void 0;\n        },\n        has(property) {\n          return k.includes(property) && property in props;\n        },\n        keys() {\n          return k.filter((property) => property in props);\n        }\n      }, propTraps);\n    });\n    res.push(new Proxy({\n      get(property) {\n        return blocked.has(property) ? void 0 : props[property];\n      },\n      has(property) {\n        return blocked.has(property) ? false : property in props;\n      },\n      keys() {\n        return Object.keys(props).filter((k) => !blocked.has(k));\n      }\n    }, propTraps));\n    return res;\n  }\n  const otherObject = {};\n  const objects = keys.map(() => ({}));\n  for (const propName of Object.getOwnPropertyNames(props)) {\n    const desc = Object.getOwnPropertyDescriptor(props, propName);\n    const isDefaultDesc = !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;\n    let blocked = false;\n    let objectIndex = 0;\n    for (const k of keys) {\n      if (k.includes(propName)) {\n        blocked = true;\n        isDefaultDesc ? objects[objectIndex][propName] = desc.value : Object.defineProperty(objects[objectIndex], propName, desc);\n      }\n      ++objectIndex;\n    }\n    if (!blocked) {\n      isDefaultDesc ? otherObject[propName] = desc.value : Object.defineProperty(otherObject, propName, desc);\n    }\n  }\n  return [...objects, otherObject];\n}\nconst narrowedError = (name) => `Stale read from <${name}>.`;\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback || void 0));\n}\nfunction Show(props) {\n  const keyed = props.keyed;\n  const conditionValue = createMemo(() => props.when, void 0, void 0);\n  const condition = keyed ? conditionValue : createMemo(conditionValue, void 0, {\n    equals: (a2, b) => !a2 === !b\n  });\n  return createMemo(() => {\n    const c2 = condition();\n    if (c2) {\n      const child = props.children;\n      const fn = typeof child === \"function\" && child.length > 0;\n      return fn ? untrack(() => child(keyed ? c2 : () => {\n        if (!untrack(condition)) throw narrowedError(\"Show\");\n        return conditionValue();\n      })) : child;\n    }\n    return props.fallback;\n  }, void 0, void 0);\n}\nfunction Switch(props) {\n  const chs = children(() => props.children);\n  const switchFunc = createMemo(() => {\n    const ch = chs();\n    const mps = Array.isArray(ch) ? ch : [ch];\n    let func = () => void 0;\n    for (let i2 = 0; i2 < mps.length; i2++) {\n      const index = i2;\n      const mp = mps[i2];\n      const prevFunc = func;\n      const conditionValue = createMemo(() => prevFunc() ? void 0 : mp.when, void 0, void 0);\n      const condition = mp.keyed ? conditionValue : createMemo(conditionValue, void 0, {\n        equals: (a2, b) => !a2 === !b\n      });\n      func = () => prevFunc() || (condition() ? [index, conditionValue, mp] : void 0);\n    }\n    return func;\n  });\n  return createMemo(() => {\n    const sel = switchFunc()();\n    if (!sel) return props.fallback;\n    const [index, conditionValue, mp] = sel;\n    const child = mp.children;\n    const fn = typeof child === \"function\" && child.length > 0;\n    return fn ? untrack(() => child(mp.keyed ? conditionValue() : () => {\n      var _a2;\n      if (((_a2 = untrack(switchFunc)()) == null ? void 0 : _a2[0]) !== index) throw narrowedError(\"Match\");\n      return conditionValue();\n    })) : child;\n  }, void 0, void 0);\n}\nfunction Match(props) {\n  return props;\n}\nconst booleans = [\"allowfullscreen\", \"async\", \"autofocus\", \"autoplay\", \"checked\", \"controls\", \"default\", \"disabled\", \"formnovalidate\", \"hidden\", \"indeterminate\", \"inert\", \"ismap\", \"loop\", \"multiple\", \"muted\", \"nomodule\", \"novalidate\", \"open\", \"playsinline\", \"readonly\", \"required\", \"reversed\", \"seamless\", \"selected\"];\nconst Properties = /* @__PURE__ */ new Set([\"className\", \"value\", \"readOnly\", \"noValidate\", \"formNoValidate\", \"isMap\", \"noModule\", \"playsInline\", ...booleans]);\nconst ChildProperties = /* @__PURE__ */ new Set([\"innerHTML\", \"textContent\", \"innerText\", \"children\"]);\nconst Aliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {\n  className: \"class\",\n  htmlFor: \"for\"\n});\nconst PropAliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {\n  class: \"className\",\n  novalidate: {\n    $: \"noValidate\",\n    FORM: 1\n  },\n  formnovalidate: {\n    $: \"formNoValidate\",\n    BUTTON: 1,\n    INPUT: 1\n  },\n  ismap: {\n    $: \"isMap\",\n    IMG: 1\n  },\n  nomodule: {\n    $: \"noModule\",\n    SCRIPT: 1\n  },\n  playsinline: {\n    $: \"playsInline\",\n    VIDEO: 1\n  },\n  readonly: {\n    $: \"readOnly\",\n    INPUT: 1,\n    TEXTAREA: 1\n  }\n});\nfunction getPropAlias(prop, tagName) {\n  const a2 = PropAliases[prop];\n  return typeof a2 === \"object\" ? a2[tagName] ? a2[\"$\"] : void 0 : a2;\n}\nconst DelegatedEvents = /* @__PURE__ */ new Set([\"beforeinput\", \"click\", \"dblclick\", \"contextmenu\", \"focusin\", \"focusout\", \"input\", \"keydown\", \"keyup\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\", \"mouseup\", \"pointerdown\", \"pointermove\", \"pointerout\", \"pointerover\", \"pointerup\", \"touchend\", \"touchmove\", \"touchstart\"]);\nconst SVGElements = /* @__PURE__ */ new Set([\n  \"altGlyph\",\n  \"altGlyphDef\",\n  \"altGlyphItem\",\n  \"animate\",\n  \"animateColor\",\n  \"animateMotion\",\n  \"animateTransform\",\n  \"circle\",\n  \"clipPath\",\n  \"color-profile\",\n  \"cursor\",\n  \"defs\",\n  \"desc\",\n  \"ellipse\",\n  \"feBlend\",\n  \"feColorMatrix\",\n  \"feComponentTransfer\",\n  \"feComposite\",\n  \"feConvolveMatrix\",\n  \"feDiffuseLighting\",\n  \"feDisplacementMap\",\n  \"feDistantLight\",\n  \"feDropShadow\",\n  \"feFlood\",\n  \"feFuncA\",\n  \"feFuncB\",\n  \"feFuncG\",\n  \"feFuncR\",\n  \"feGaussianBlur\",\n  \"feImage\",\n  \"feMerge\",\n  \"feMergeNode\",\n  \"feMorphology\",\n  \"feOffset\",\n  \"fePointLight\",\n  \"feSpecularLighting\",\n  \"feSpotLight\",\n  \"feTile\",\n  \"feTurbulence\",\n  \"filter\",\n  \"font\",\n  \"font-face\",\n  \"font-face-format\",\n  \"font-face-name\",\n  \"font-face-src\",\n  \"font-face-uri\",\n  \"foreignObject\",\n  \"g\",\n  \"glyph\",\n  \"glyphRef\",\n  \"hkern\",\n  \"image\",\n  \"line\",\n  \"linearGradient\",\n  \"marker\",\n  \"mask\",\n  \"metadata\",\n  \"missing-glyph\",\n  \"mpath\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"radialGradient\",\n  \"rect\",\n  \"set\",\n  \"stop\",\n  \"svg\",\n  \"switch\",\n  \"symbol\",\n  \"text\",\n  \"textPath\",\n  \"tref\",\n  \"tspan\",\n  \"use\",\n  \"view\",\n  \"vkern\"\n]);\nconst SVGNamespace = {\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\"\n};\nconst memo = (fn) => createMemo(() => fn());\nfunction reconcileArrays(parentNode, a2, b) {\n  let bLength = b.length, aEnd = a2.length, bEnd = bLength, aStart = 0, bStart = 0, after = a2[aEnd - 1].nextSibling, map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    if (a2[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n      continue;\n    }\n    while (a2[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    if (aEnd === aStart) {\n      const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;\n      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);\n    } else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        if (!map || !map.has(a2[aStart])) a2[aStart].remove();\n        aStart++;\n      }\n    } else if (a2[aStart] === b[bEnd - 1] && b[bStart] === a2[aEnd - 1]) {\n      const node = a2[--aEnd].nextSibling;\n      parentNode.insertBefore(b[bStart++], a2[aStart++].nextSibling);\n      parentNode.insertBefore(b[--bEnd], node);\n      a2[aEnd] = b[bEnd];\n    } else {\n      if (!map) {\n        map = /* @__PURE__ */ new Map();\n        let i2 = bStart;\n        while (i2 < bEnd) map.set(b[i2], i2++);\n      }\n      const index = map.get(a2[aStart]);\n      if (index != null) {\n        if (bStart < index && index < bEnd) {\n          let i2 = aStart, sequence = 1, t2;\n          while (++i2 < aEnd && i2 < bEnd) {\n            if ((t2 = map.get(a2[i2])) == null || t2 !== index + sequence) break;\n            sequence++;\n          }\n          if (sequence > index - bStart) {\n            const node = a2[aStart];\n            while (bStart < index) parentNode.insertBefore(b[bStart++], node);\n          } else parentNode.replaceChild(b[bStart++], a2[aStart++]);\n        } else aStart++;\n      } else a2[aStart++].remove();\n    }\n  }\n}\nconst $$EVENTS = \"_$DX_DELEGATE\";\nfunction render(code, element, init, options = {}) {\n  let disposer;\n  createRoot((dispose2) => {\n    disposer = dispose2;\n    element === document ? code() : insert(element, code(), element.firstChild ? null : void 0, init);\n  }, options.owner);\n  return () => {\n    disposer();\n    element.textContent = \"\";\n  };\n}\nfunction template$1(html, isImportNode, isSVG, isMathML) {\n  let node;\n  const create = () => {\n    const t2 = isMathML ? document.createElementNS(\"http://www.w3.org/1998/Math/MathML\", \"template\") : document.createElement(\"template\");\n    t2.innerHTML = html;\n    return isSVG ? t2.content.firstChild.firstChild : isMathML ? t2.firstChild : t2.content.firstChild;\n  };\n  const fn = isImportNode ? () => untrack(() => document.importNode(node || (node = create()), true)) : () => (node || (node = create())).cloneNode(true);\n  fn.cloneNode = fn;\n  return fn;\n}\nfunction delegateEvents(eventNames, document2 = window.document) {\n  const e2 = document2[$$EVENTS] || (document2[$$EVENTS] = /* @__PURE__ */ new Set());\n  for (let i2 = 0, l2 = eventNames.length; i2 < l2; i2++) {\n    const name = eventNames[i2];\n    if (!e2.has(name)) {\n      e2.add(name);\n      document2.addEventListener(name, eventHandler);\n    }\n  }\n}\nfunction setAttribute(node, name, value) {\n  if (value == null) node.removeAttribute(name);\n  else node.setAttribute(name, value);\n}\nfunction setAttributeNS(node, namespace, name, value) {\n  if (value == null) node.removeAttributeNS(namespace, name);\n  else node.setAttributeNS(namespace, name, value);\n}\nfunction setBoolAttribute(node, name, value) {\n  value ? node.setAttribute(name, \"\") : node.removeAttribute(name);\n}\nfunction className(node, value) {\n  if (value == null) node.removeAttribute(\"class\");\n  else node.className = value;\n}\nfunction addEventListener(node, name, handler, delegate) {\n  if (delegate) {\n    if (Array.isArray(handler)) {\n      node[`$$${name}`] = handler[0];\n      node[`$$${name}Data`] = handler[1];\n    } else node[`$$${name}`] = handler;\n  } else if (Array.isArray(handler)) {\n    const handlerFn = handler[0];\n    node.addEventListener(name, handler[0] = (e2) => handlerFn.call(node, handler[1], e2));\n  } else node.addEventListener(name, handler, typeof handler !== \"function\" && handler);\n}\nfunction classList(node, value, prev = {}) {\n  const classKeys = Object.keys(value || {}), prevKeys = Object.keys(prev);\n  let i2, len;\n  for (i2 = 0, len = prevKeys.length; i2 < len; i2++) {\n    const key = prevKeys[i2];\n    if (!key || key === \"undefined\" || value[key]) continue;\n    toggleClassKey(node, key, false);\n    delete prev[key];\n  }\n  for (i2 = 0, len = classKeys.length; i2 < len; i2++) {\n    const key = classKeys[i2], classValue = !!value[key];\n    if (!key || key === \"undefined\" || prev[key] === classValue || !classValue) continue;\n    toggleClassKey(node, key, true);\n    prev[key] = classValue;\n  }\n  return prev;\n}\nfunction style(node, value, prev) {\n  if (!value) return prev ? setAttribute(node, \"style\") : value;\n  const nodeStyle = node.style;\n  if (typeof value === \"string\") return nodeStyle.cssText = value;\n  typeof prev === \"string\" && (nodeStyle.cssText = prev = void 0);\n  prev || (prev = {});\n  value || (value = {});\n  let v, s2;\n  for (s2 in prev) {\n    value[s2] == null && nodeStyle.removeProperty(s2);\n    delete prev[s2];\n  }\n  for (s2 in value) {\n    v = value[s2];\n    if (v !== prev[s2]) {\n      nodeStyle.setProperty(s2, v);\n      prev[s2] = v;\n    }\n  }\n  return prev;\n}\nfunction spread(node, props = {}, isSVG, skipChildren) {\n  const prevProps = {};\n  {\n    createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));\n  }\n  createRenderEffect(() => typeof props.ref === \"function\" && use(props.ref, node));\n  createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));\n  return prevProps;\n}\nfunction use(fn, element, arg) {\n  return untrack(() => fn(element, arg));\n}\nfunction insert(parent, accessor, marker, initial) {\n  if (marker !== void 0 && !initial) initial = [];\n  if (typeof accessor !== \"function\") return insertExpression(parent, accessor, initial, marker);\n  createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);\n}\nfunction assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {\n  props || (props = {});\n  for (const prop in prevProps) {\n    if (!(prop in props)) {\n      if (prop === \"children\") continue;\n      prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef, props);\n    }\n  }\n  for (const prop in props) {\n    if (prop === \"children\") {\n      continue;\n    }\n    const value = props[prop];\n    prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef, props);\n  }\n}\nfunction toPropertyName(name) {\n  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());\n}\nfunction toggleClassKey(node, key, value) {\n  const classNames = key.trim().split(/\\s+/);\n  for (let i2 = 0, nameLen = classNames.length; i2 < nameLen; i2++) node.classList.toggle(classNames[i2], value);\n}\nfunction assignProp(node, prop, value, prev, isSVG, skipRef, props) {\n  let isCE, isProp, isChildProp, propAlias, forceProp;\n  if (prop === \"style\") return style(node, value, prev);\n  if (prop === \"classList\") return classList(node, value, prev);\n  if (value === prev) return prev;\n  if (prop === \"ref\") {\n    if (!skipRef) value(node);\n  } else if (prop.slice(0, 3) === \"on:\") {\n    const e2 = prop.slice(3);\n    prev && node.removeEventListener(e2, prev, typeof prev !== \"function\" && prev);\n    value && node.addEventListener(e2, value, typeof value !== \"function\" && value);\n  } else if (prop.slice(0, 10) === \"oncapture:\") {\n    const e2 = prop.slice(10);\n    prev && node.removeEventListener(e2, prev, true);\n    value && node.addEventListener(e2, value, true);\n  } else if (prop.slice(0, 2) === \"on\") {\n    const name = prop.slice(2).toLowerCase();\n    const delegate = DelegatedEvents.has(name);\n    if (!delegate && prev) {\n      const h2 = Array.isArray(prev) ? prev[0] : prev;\n      node.removeEventListener(name, h2);\n    }\n    if (delegate || value) {\n      addEventListener(node, name, value, delegate);\n      delegate && delegateEvents([name]);\n    }\n  } else if (prop.slice(0, 5) === \"attr:\") {\n    setAttribute(node, prop.slice(5), value);\n  } else if (prop.slice(0, 5) === \"bool:\") {\n    setBoolAttribute(node, prop.slice(5), value);\n  } else if ((forceProp = prop.slice(0, 5) === \"prop:\") || (isChildProp = ChildProperties.has(prop)) || !isSVG && ((propAlias = getPropAlias(prop, node.tagName)) || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes(\"-\") || \"is\" in props)) {\n    if (forceProp) {\n      prop = prop.slice(5);\n      isProp = true;\n    }\n    if (prop === \"class\" || prop === \"className\") className(node, value);\n    else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;\n    else node[propAlias || prop] = value;\n  } else {\n    const ns = isSVG && prop.indexOf(\":\") > -1 && SVGNamespace[prop.split(\":\")[0]];\n    if (ns) setAttributeNS(node, ns, prop, value);\n    else setAttribute(node, Aliases[prop] || prop, value);\n  }\n  return value;\n}\nfunction eventHandler(e2) {\n  let node = e2.target;\n  const key = `$$${e2.type}`;\n  const oriTarget = e2.target;\n  const oriCurrentTarget = e2.currentTarget;\n  const retarget = (value) => Object.defineProperty(e2, \"target\", {\n    configurable: true,\n    value\n  });\n  const handleNode = () => {\n    const handler = node[key];\n    if (handler && !node.disabled) {\n      const data = node[`${key}Data`];\n      data !== void 0 ? handler.call(node, data, e2) : handler.call(node, e2);\n      if (e2.cancelBubble) return;\n    }\n    node.host && typeof node.host !== \"string\" && !node.host._$host && node.contains(e2.target) && retarget(node.host);\n    return true;\n  };\n  const walkUpTree = () => {\n    while (handleNode() && (node = node._$host || node.parentNode || node.host)) ;\n  };\n  Object.defineProperty(e2, \"currentTarget\", {\n    configurable: true,\n    get() {\n      return node || document;\n    }\n  });\n  if (e2.composedPath) {\n    const path = e2.composedPath();\n    retarget(path[0]);\n    for (let i2 = 0; i2 < path.length - 2; i2++) {\n      node = path[i2];\n      if (!handleNode()) break;\n      if (node._$host) {\n        node = node._$host;\n        walkUpTree();\n        break;\n      }\n      if (node.parentNode === oriCurrentTarget) {\n        break;\n      }\n    }\n  } else walkUpTree();\n  retarget(oriTarget);\n}\nfunction insertExpression(parent, value, current, marker, unwrapArray) {\n  while (typeof current === \"function\") current = current();\n  if (value === current) return current;\n  const t2 = typeof value, multi = marker !== void 0;\n  parent = multi && current[0] && current[0].parentNode || parent;\n  if (t2 === \"string\" || t2 === \"number\") {\n    if (t2 === \"number\") {\n      value = value.toString();\n      if (value === current) return current;\n    }\n    if (multi) {\n      let node = current[0];\n      if (node && node.nodeType === 3) {\n        node.data !== value && (node.data = value);\n      } else node = document.createTextNode(value);\n      current = cleanChildren(parent, current, marker, node);\n    } else {\n      if (current !== \"\" && typeof current === \"string\") {\n        current = parent.firstChild.data = value;\n      } else current = parent.textContent = value;\n    }\n  } else if (value == null || t2 === \"boolean\") {\n    current = cleanChildren(parent, current, marker);\n  } else if (t2 === \"function\") {\n    createRenderEffect(() => {\n      let v = value();\n      while (typeof v === \"function\") v = v();\n      current = insertExpression(parent, v, current, marker);\n    });\n    return () => current;\n  } else if (Array.isArray(value)) {\n    const array = [];\n    const currentArray = current && Array.isArray(current);\n    if (normalizeIncomingArray(array, value, current, unwrapArray)) {\n      createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));\n      return () => current;\n    }\n    if (array.length === 0) {\n      current = cleanChildren(parent, current, marker);\n      if (multi) return current;\n    } else if (currentArray) {\n      if (current.length === 0) {\n        appendNodes(parent, array, marker);\n      } else reconcileArrays(parent, current, array);\n    } else {\n      current && cleanChildren(parent);\n      appendNodes(parent, array);\n    }\n    current = array;\n  } else if (value.nodeType) {\n    if (Array.isArray(current)) {\n      if (multi) return current = cleanChildren(parent, current, marker, value);\n      cleanChildren(parent, current, null, value);\n    } else if (current == null || current === \"\" || !parent.firstChild) {\n      parent.appendChild(value);\n    } else parent.replaceChild(value, parent.firstChild);\n    current = value;\n  } else ;\n  return current;\n}\nfunction normalizeIncomingArray(normalized, array, current, unwrap2) {\n  let dynamic = false;\n  for (let i2 = 0, len = array.length; i2 < len; i2++) {\n    let item = array[i2], prev = current && current[normalized.length], t2;\n    if (item == null || item === true || item === false) ;\n    else if ((t2 = typeof item) === \"object\" && item.nodeType) {\n      normalized.push(item);\n    } else if (Array.isArray(item)) {\n      dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;\n    } else if (t2 === \"function\") {\n      if (unwrap2) {\n        while (typeof item === \"function\") item = item();\n        dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev) ? prev : [prev]) || dynamic;\n      } else {\n        normalized.push(item);\n        dynamic = true;\n      }\n    } else {\n      const value = String(item);\n      if (prev && prev.nodeType === 3 && prev.data === value) normalized.push(prev);\n      else normalized.push(document.createTextNode(value));\n    }\n  }\n  return dynamic;\n}\nfunction appendNodes(parent, array, marker = null) {\n  for (let i2 = 0, len = array.length; i2 < len; i2++) parent.insertBefore(array[i2], marker);\n}\nfunction cleanChildren(parent, current, marker, replacement) {\n  if (marker === void 0) return parent.textContent = \"\";\n  const node = replacement || document.createTextNode(\"\");\n  if (current.length) {\n    let inserted = false;\n    for (let i2 = current.length - 1; i2 >= 0; i2--) {\n      const el = current[i2];\n      if (node !== el) {\n        const isParent = el.parentNode === parent;\n        if (!inserted && !i2) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);\n        else isParent && el.remove();\n      } else inserted = true;\n    }\n  } else parent.insertBefore(node, marker);\n  return [node];\n}\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nfunction createElement(tagName, isSVG = false) {\n  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);\n}\nfunction Portal(props) {\n  const {\n    useShadow\n  } = props, marker = document.createTextNode(\"\"), mount = () => props.mount || document.body, owner = getOwner();\n  let content;\n  createEffect(() => {\n    content || (content = runWithOwner(owner, () => createMemo(() => props.children)));\n    const el = mount();\n    if (el instanceof HTMLHeadElement) {\n      const [clean, setClean] = createSignal(false);\n      const cleanup = () => setClean(true);\n      createRoot((dispose2) => insert(el, () => !clean() ? content() : dispose2(), null));\n      onCleanup(cleanup);\n    } else {\n      const container = createElement(props.isSVG ? \"g\" : \"div\", props.isSVG), renderRoot = useShadow && container.attachShadow ? container.attachShadow({\n        mode: \"open\"\n      }) : container;\n      Object.defineProperty(container, \"_$host\", {\n        get() {\n          return marker.parentNode;\n        },\n        configurable: true\n      });\n      insert(renderRoot, content);\n      el.appendChild(container);\n      props.ref && props.ref(container);\n      onCleanup(() => el.removeChild(container));\n    }\n  }, void 0, {\n    render: true\n  });\n  return marker;\n}\nfunction createDynamic(component, props) {\n  const cached = createMemo(component);\n  return createMemo(() => {\n    const component2 = cached();\n    switch (typeof component2) {\n      case \"function\":\n        return untrack(() => component2(props));\n      case \"string\":\n        const isSvg = SVGElements.has(component2);\n        const el = createElement(component2, isSvg);\n        spread(el, props, isSvg);\n        return el;\n    }\n  });\n}\nfunction Dynamic(props) {\n  const [, others] = splitProps(props, [\"component\"]);\n  return createDynamic(() => props.component, others);\n}\nvar THEME = /* @__PURE__ */ ((THEME2) => {\n  THEME2[\"DARK\"] = \"DARK\";\n  THEME2[\"LIGHT\"] = \"LIGHT\";\n  return THEME2;\n})(THEME || {});\nlet e = { data: \"\" }, t = (t2) => \"object\" == typeof window ? ((t2 ? t2.querySelector(\"#_goober\") : window._goober) || Object.assign((t2 || document.head).appendChild(document.createElement(\"style\")), { innerHTML: \" \", id: \"_goober\" })).firstChild : t2 || e, l = /(?:([\\u0080-\\uFFFF\\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\\s*)/g, a = /\\/\\*[^]*?\\*\\/|  +/g, n = /\\n+/g, o = (e2, t2) => {\n  let r = \"\", l2 = \"\", a2 = \"\";\n  for (let n2 in e2) {\n    let c2 = e2[n2];\n    \"@\" == n2[0] ? \"i\" == n2[1] ? r = n2 + \" \" + c2 + \";\" : l2 += \"f\" == n2[1] ? o(c2, n2) : n2 + \"{\" + o(c2, \"k\" == n2[1] ? \"\" : t2) + \"}\" : \"object\" == typeof c2 ? l2 += o(c2, t2 ? t2.replace(/([^,])+/g, (e3) => n2.replace(/(^:.*)|([^,])+/g, (t3) => /&/.test(t3) ? t3.replace(/&/g, e3) : e3 ? e3 + \" \" + t3 : t3)) : n2) : null != c2 && (n2 = /^--/.test(n2) ? n2 : n2.replace(/[A-Z]/g, \"-$&\").toLowerCase(), a2 += o.p ? o.p(n2, c2) : n2 + \":\" + c2 + \";\");\n  }\n  return r + (t2 && a2 ? t2 + \"{\" + a2 + \"}\" : a2) + l2;\n}, c = {}, s = (e2) => {\n  if (\"object\" == typeof e2) {\n    let t2 = \"\";\n    for (let r in e2) t2 += r + s(e2[r]);\n    return t2;\n  }\n  return e2;\n}, i = (e2, t2, r, i2, p2) => {\n  let u2 = s(e2), d = c[u2] || (c[u2] = ((e3) => {\n    let t3 = 0, r2 = 11;\n    for (; t3 < e3.length; ) r2 = 101 * r2 + e3.charCodeAt(t3++) >>> 0;\n    return \"go\" + r2;\n  })(u2));\n  if (!c[d]) {\n    let t3 = u2 !== e2 ? e2 : ((e3) => {\n      let t4, r2, o2 = [{}];\n      for (; t4 = l.exec(e3.replace(a, \"\")); ) t4[4] ? o2.shift() : t4[3] ? (r2 = t4[3].replace(n, \" \").trim(), o2.unshift(o2[0][r2] = o2[0][r2] || {})) : o2[0][t4[1]] = t4[2].replace(n, \" \").trim();\n      return o2[0];\n    })(e2);\n    c[d] = o(p2 ? { [\"@keyframes \" + d]: t3 } : t3, r ? \"\" : \".\" + d);\n  }\n  let f = r && c.g ? c.g : null;\n  return r && (c.g = c[d]), ((e3, t3, r2, l2) => {\n    l2 ? t3.data = t3.data.replace(l2, e3) : -1 === t3.data.indexOf(e3) && (t3.data = r2 ? e3 + t3.data : t3.data + e3);\n  })(c[d], t2, i2, f), d;\n}, p = (e2, t2, r) => e2.reduce((e3, l2, a2) => {\n  let n2 = t2[a2];\n  if (n2 && n2.call) {\n    let e4 = n2(r), t3 = e4 && e4.props && e4.props.className || /^go/.test(e4) && e4;\n    n2 = t3 ? \".\" + t3 : e4 && \"object\" == typeof e4 ? e4.props ? \"\" : o(e4, \"\") : false === e4 ? \"\" : e4;\n  }\n  return e3 + l2 + (null == n2 ? \"\" : n2);\n}, \"\");\nfunction u(e2) {\n  let r = this || {}, l2 = e2.call ? e2(r.p) : e2;\n  return i(l2.unshift ? l2.raw ? p(l2, [].slice.call(arguments, 1), r.p) : l2.reduce((e3, t2) => Object.assign(e3, t2 && t2.call ? t2(r.p) : t2), {}) : l2, t(r.target), r.g, r.o, r.k);\n}\nu.bind({ g: 1 });\nlet h = u.bind({ k: 1 });\nconst ThemeContext = createContext();\nfunction ThemeProvider(props) {\n  return createComponent(ThemeContext.Provider, {\n    value: props.theme,\n    get children() {\n      return props.children;\n    }\n  });\n}\nfunction useTheme() {\n  return useContext(ThemeContext);\n}\nfunction makeStyled(tag) {\n  let _ctx = this || {};\n  return (...args) => {\n    const Styled = (props) => {\n      const theme = useContext(ThemeContext);\n      const withTheme = mergeProps(props, { theme });\n      const clone = mergeProps(withTheme, {\n        get class() {\n          const pClass = withTheme.class, append = \"class\" in withTheme && /^go[0-9]+/.test(pClass);\n          let className2 = u.apply(\n            { target: _ctx.target, o: append, p: withTheme, g: _ctx.g },\n            args\n          );\n          return [pClass, className2].filter(Boolean).join(\" \");\n        }\n      });\n      const [local, newProps] = splitProps(clone, [\"as\", \"theme\"]);\n      const htmlProps = newProps;\n      const createTag = local.as || tag;\n      let el;\n      if (typeof createTag === \"function\") {\n        el = createTag(htmlProps);\n      } else {\n        {\n          if (_ctx.g == 1) {\n            el = document.createElement(createTag);\n            spread(el, htmlProps);\n          } else {\n            el = Dynamic(mergeProps({ component: createTag }, htmlProps));\n          }\n        }\n      }\n      return el;\n    };\n    Styled.class = (props) => {\n      return untrack(() => {\n        return u.apply({ target: _ctx.target, p: props, g: _ctx.g }, args);\n      });\n    };\n    return Styled;\n  };\n}\nconst styled = new Proxy(makeStyled, {\n  get(target, tag) {\n    return target(tag);\n  }\n});\nfunction createGlobalStyles() {\n  const fn = makeStyled.call({ g: 1 }, \"div\").apply(null, arguments);\n  return function GlobalStyles2(props) {\n    fn(props);\n    return null;\n  };\n}\nconst globalStylesTag = \"tc-root\";\nconst disableScrollClass = \"tc-disable-scroll\";\nconst usingMouseClass = \"tc-using-mouse\";\nconst GlobalStyles = () => {\n  document.body.addEventListener(\"mousedown\", () => document.body.classList.add(usingMouseClass));\n  document.body.addEventListener(\"keydown\", (event) => {\n    if (event.key === \"Tab\") {\n      document.body.classList.remove(usingMouseClass);\n    }\n  });\n  const Styles = createGlobalStyles`\n    ${globalStylesTag} * {\n        margin: 0;\n        padding: 0;\n        box-sizing: border-box;\n        \n        font-family: -apple-system, BlinkMacSystemFont, 'Roboto', 'Helvetica Neue', Arial, Tahoma, Verdana, sans-serif;\n        -webkit-font-smoothing: antialiased;\n        -moz-osx-font-smoothing: grayscale;        \n        -webkit-tap-highlight-color: transparent;\n    }\n    \n    ${globalStylesTag} img {\n      -webkit-user-select: none;\n      -webkit-touch-callout: none;\n    }   \n \n    ${globalStylesTag} *:focus {\n        outline: #08f auto 2px;\n    }\n    \n    ${globalStylesTag} li {\n        list-style: none;\n    }\n    \n    ${globalStylesTag} button {\n        outline: none;\n    }\n    \n    body.${disableScrollClass} {\n        position: fixed; \n        overflow-y: scroll;\n        right: 0;\n        left: 0;\n    }\n    \n    body.${usingMouseClass} ${globalStylesTag} *:focus {\n        outline: none;\n    }\n`;\n  return createComponent(Styles, {});\n};\nfunction hexToRgb(hex) {\n  if (hex[0] === \"#\") {\n    hex = hex.slice(1);\n  }\n  const bigint = parseInt(hex, 16);\n  const r = bigint >> 16 & 255;\n  const g = bigint >> 8 & 255;\n  const b = bigint & 255;\n  return [r, g, b].join(\",\");\n}\nfunction rgba(color, opacity) {\n  if (color[0] === \"#\") {\n    color = hexToRgb(color);\n  }\n  return `rgba(${color}, ${opacity})`;\n}\nfunction toPx(value) {\n  return value.toString() + \"px\";\n}\nclass InMemoryStorage {\n  constructor() {\n    this.storage = {};\n  }\n  static getInstance() {\n    if (!InMemoryStorage.instance) {\n      InMemoryStorage.instance = new InMemoryStorage();\n    }\n    return InMemoryStorage.instance;\n  }\n  get length() {\n    return Object.keys(this.storage).length;\n  }\n  clear() {\n    this.storage = {};\n  }\n  getItem(key) {\n    var _a2;\n    return (_a2 = this.storage[key]) != null ? _a2 : null;\n  }\n  key(index) {\n    var _a2;\n    const keys = Object.keys(this.storage);\n    if (index < 0 || index >= keys.length) {\n      return null;\n    }\n    return (_a2 = keys[index]) != null ? _a2 : null;\n  }\n  removeItem(key) {\n    delete this.storage[key];\n  }\n  setItem(key, value) {\n    this.storage[key] = value;\n  }\n}\nclass TonConnectUIError extends _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnectError {\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, TonConnectUIError.prototype);\n  }\n}\nfunction logDebug(...args) {\n  {\n    try {\n      console.debug(\"[TON_CONNECT_UI]\", ...args);\n    } catch (e2) {\n    }\n  }\n}\nfunction logError(...args) {\n  {\n    try {\n      console.error(\"[TON_CONNECT_UI]\", ...args);\n    } catch (e2) {\n    }\n  }\n}\nfunction logWarning(...args) {\n  {\n    try {\n      console.warn(\"[TON_CONNECT_UI]\", ...args);\n    } catch (e2) {\n    }\n  }\n}\nfunction openLink(href, target = \"_self\") {\n  setLastOpenedLink({ link: href });\n  logDebug(\"openLink\", href, target);\n  window.open(href, target, \"noopener noreferrer\");\n}\nfunction openLinkBlank(href) {\n  openLink(href, \"_blank\");\n}\nfunction openDeeplinkWithFallback(href, fallback) {\n  const doFallback = () => {\n    if (isBrowser(\"safari\") || isOS(\"android\") && isBrowser(\"firefox\") || isOS(\"windows\")) {\n      return;\n    }\n    fallback();\n  };\n  const fallbackTimeout = setTimeout(() => doFallback(), 200);\n  window.addEventListener(\"blur\", () => clearTimeout(fallbackTimeout), { once: true });\n  openLink(href, \"_self\");\n}\nfunction getSystemTheme() {\n  if (window.matchMedia && window.matchMedia(\"(prefers-color-scheme: light)\").matches) {\n    return THEME.LIGHT;\n  }\n  return THEME.DARK;\n}\nfunction subscribeToThemeChange(callback) {\n  const handler = (event) => callback(event.matches ? THEME.DARK : THEME.LIGHT);\n  window.matchMedia(\"(prefers-color-scheme: dark)\").addEventListener(\"change\", handler);\n  return () => window.matchMedia(\"(prefers-color-scheme: dark)\").removeEventListener(\"change\", handler);\n}\nfunction disableScroll() {\n  if (document.documentElement.scrollHeight === document.documentElement.clientHeight) {\n    return;\n  }\n  document.body.style.top = toPx(-document.documentElement.scrollTop);\n  document.body.classList.add(disableScrollClass);\n}\nfunction enableScroll() {\n  if (!document.body.classList.contains(disableScrollClass)) {\n    return;\n  }\n  document.body.classList.remove(disableScrollClass);\n  document.documentElement.scrollTo({ top: -parseFloat(getComputedStyle(document.body).top) });\n  document.body.style.top = \"auto\";\n}\nfunction fixMobileSafariActiveTransition() {\n  if (!document.body.hasAttribute(\"ontouchstart\")) {\n    document.body.setAttribute(\"ontouchstart\", \"\");\n  }\n}\nfunction defineStylesRoot() {\n  if (!customElements.get(\"tc-root\")) {\n    customElements.define(globalStylesTag, class TcRootElement extends HTMLElement {\n    });\n  }\n}\nfunction createMacrotask(callback) {\n  return __async(this, null, function* () {\n    yield new Promise((resolve) => requestAnimationFrame(resolve));\n    callback();\n  });\n}\nfunction createMacrotaskAsync(callback) {\n  return __async(this, null, function* () {\n    yield new Promise((resolve) => requestAnimationFrame(resolve));\n    return callback();\n  });\n}\nfunction preloadImages(images) {\n  if (document.readyState !== \"complete\") {\n    window.addEventListener(\"load\", () => createMacrotask(() => preloadImages(images)), {\n      once: true\n    });\n  } else {\n    images.forEach((img) => {\n      const node = new window.Image();\n      node.src = img;\n    });\n  }\n}\nfunction getWindow$1() {\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  return void 0;\n}\nfunction tryGetLocalStorage() {\n  if (isLocalStorageAvailable()) {\n    return localStorage;\n  }\n  if (isNodeJs()) {\n    throw new TonConnectUIError(\n      \"`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector\"\n    );\n  }\n  return InMemoryStorage.getInstance();\n}\nfunction isLocalStorageAvailable() {\n  try {\n    return typeof localStorage !== \"undefined\";\n  } catch (e2) {\n    return false;\n  }\n}\nfunction isNodeJs() {\n  return typeof process !== \"undefined\" && process.versions != null && process.versions.node != null;\n}\nfunction getUserAgent() {\n  var _a2, _b2, _c2;\n  const results = new ua_parser_js__WEBPACK_IMPORTED_MODULE_1__().getResult();\n  const osName = (_a2 = results.os.name) == null ? void 0 : _a2.toLowerCase();\n  const deviceModel = (_b2 = results.device.model) == null ? void 0 : _b2.toLowerCase();\n  let os;\n  switch (true) {\n    case deviceModel === \"ipad\":\n      os = \"ipad\";\n      break;\n    case osName === \"ios\":\n      os = \"ios\";\n      break;\n    case osName === \"android\":\n      os = \"android\";\n      break;\n    case osName === \"mac os\":\n      os = \"macos\";\n      break;\n    case osName === \"linux\":\n      os = \"linux\";\n      break;\n    case (osName == null ? void 0 : osName.includes(\"windows\")):\n      os = \"windows\";\n      break;\n  }\n  const browserName = (_c2 = results.browser.name) == null ? void 0 : _c2.toLowerCase();\n  let browser;\n  switch (true) {\n    case browserName === \"chrome\":\n      browser = \"chrome\";\n      break;\n    case browserName === \"firefox\":\n      browser = \"firefox\";\n      break;\n    case (browserName == null ? void 0 : browserName.includes(\"safari\")):\n      browser = \"safari\";\n      break;\n    case (browserName == null ? void 0 : browserName.includes(\"opera\")):\n      browser = \"opera\";\n      break;\n  }\n  return {\n    os,\n    browser\n  };\n}\nfunction isOS(...os) {\n  return os.includes(getUserAgent().os);\n}\nfunction isBrowser(...browser) {\n  return browser.includes(getUserAgent().browser);\n}\nfunction toDeeplink(universalLink, deeplink) {\n  const url = new URL(universalLink);\n  return deeplink + url.search;\n}\nclass WalletInfoStorage {\n  constructor() {\n    this.storageKey = \"ton-connect-ui_wallet-info\";\n    this.localStorage = tryGetLocalStorage();\n  }\n  setWalletInfo(walletInfo) {\n    this.localStorage.setItem(this.storageKey, JSON.stringify(walletInfo));\n  }\n  getWalletInfo() {\n    const walletInfoString = this.localStorage.getItem(this.storageKey);\n    if (!walletInfoString) {\n      return null;\n    }\n    return JSON.parse(walletInfoString);\n  }\n  removeWalletInfo() {\n    this.localStorage.removeItem(this.storageKey);\n  }\n}\nclass PreferredWalletStorage {\n  constructor() {\n    this.storageKey = \"ton-connect-ui_preferred-wallet\";\n    this.localStorage = tryGetLocalStorage();\n  }\n  setPreferredWalletAppName(name) {\n    this.localStorage.setItem(this.storageKey, name);\n  }\n  getPreferredWalletAppName() {\n    return this.localStorage.getItem(this.storageKey) || void 0;\n  }\n}\nclass LastSelectedWalletInfoStorage {\n  constructor() {\n    this.storageKey = \"ton-connect-ui_last-selected-wallet-info\";\n    this.localStorage = tryGetLocalStorage();\n  }\n  setLastSelectedWalletInfo(walletInfo) {\n    this.localStorage.setItem(this.storageKey, JSON.stringify(walletInfo));\n  }\n  getLastSelectedWalletInfo() {\n    const walletInfoString = this.localStorage.getItem(this.storageKey);\n    if (!walletInfoString) {\n      return null;\n    }\n    return JSON.parse(walletInfoString);\n  }\n  removeLastSelectedWalletInfo() {\n    this.localStorage.removeItem(this.storageKey);\n  }\n}\nconst [walletsModalState, setWalletsModalState] = createSignal({\n  status: \"closed\",\n  closeReason: null\n});\nconst getWalletsModalIsOpened = createMemo(() => walletsModalState().status === \"opened\");\nconst [singleWalletModalState, setSingleWalletModalState] = createSignal({\n  status: \"closed\",\n  closeReason: null\n});\nconst getSingleWalletModalIsOpened = createMemo(\n  () => singleWalletModalState().status === \"opened\"\n);\nconst getSingleWalletModalWalletInfo = createMemo(() => {\n  const state = singleWalletModalState();\n  if (state.status === \"opened\") {\n    return state.walletInfo;\n  }\n  return null;\n});\nlet lastSelectedWalletInfoStorage = typeof window !== \"undefined\" ? new LastSelectedWalletInfoStorage() : void 0;\nconst [lastSelectedWalletInfo, _setLastSelectedWalletInfo] = createSignal((lastSelectedWalletInfoStorage == null ? void 0 : lastSelectedWalletInfoStorage.getLastSelectedWalletInfo()) || null);\nconst setLastSelectedWalletInfo = (walletInfo) => {\n  if (!lastSelectedWalletInfoStorage) {\n    lastSelectedWalletInfoStorage = new LastSelectedWalletInfoStorage();\n  }\n  if (walletInfo) {\n    lastSelectedWalletInfoStorage.setLastSelectedWalletInfo(walletInfo);\n  } else {\n    lastSelectedWalletInfoStorage.removeLastSelectedWalletInfo();\n  }\n  _setLastSelectedWalletInfo(walletInfo);\n};\nconst [action, setAction] = createSignal(null);\nconst [lastVisibleWalletsInfo, setLastVisibleWalletsInfo] = createSignal({\n  walletsMenu: \"explicit_wallet\",\n  wallets: []\n});\nconst [lastOpenedLink, setLastOpenedLink] = createSignal({\n  link: \"\"\n});\nconst common$1 = { \"close\": \"Close\", \"openWallet\": \"Open wallet\", \"copyLink\": \"Copy Link\", \"linkCopied\": \"Link Copied\", \"copied\": \"Copied\", \"yourWallet\": \"Your Wallet\", \"retry\": \"Retry\", \"get\": \"GET\", \"mobile\": \"Mobile\", \"browserExtension\": \"Browser Extension\", \"desktop\": \"Desktop\" };\nconst button$1 = { \"connectWallet\": \"Connect Wallet\", \"dropdown\": { \"copy\": \"Copy address\", \"copied\": \"Address copied!\", \"disconnect\": \"Disconnect\" } };\nconst notifications$1 = { \"confirm\": { \"header\": \"Open {{ name }} toconfirm thetransaction.\" }, \"transactionSent\": { \"header\": \"Transaction sent\", \"text\": \"Your transactionwill beprocessed inafew seconds.\" }, \"transactionCanceled\": { \"header\": \"Transaction canceled\", \"text\": \"There will be no changes toyour account.\" }, \"dataSigned\": { \"header\": \"Data signed\" }, \"signDataCanceled\": { \"header\": \"Sign data canceled\" } };\nconst walletItem$1 = { \"walletOn\": \"Wallet in\", \"recent\": \"Recent\", \"installed\": \"Installed\", \"popular\": \"Popular\" };\nconst walletModal$1 = { \"loading\": \"Loading wallets\", \"wallets\": \"Wallets\", \"mobileUniversalModal\": { \"connectYourWallet\": \"Connect your TONwallet\", \"openWalletOnTelegramOrSelect\": \"Use Wallet in Telegram or choose other application\", \"openWalletOnTelegram\": \"Connect Wallet in Telegram\", \"chooseOtherApplication\": \"Choose other application\", \"openLink\": \"Open Link\", \"scan\": \"Scan with your mobilewallet\" }, \"desktopUniversalModal\": { \"connectYourWallet\": \"Connect your TON wallet\", \"scan\": \"Scan with your mobile wallet\", \"availableWallets\": \"Available wallets\" }, \"mobileConnectionModal\": { \"showQR\": \"Show QR Code\", \"scanQR\": \"Scan theQR code below with your phonesor{{ name }}s camera\", \"missingFeatures\": \"Please update {{ name }}, your version does not support required features for this dApp\", \"wrongNetwork\": \"Connected wallet is on a different network. Please switch network in {{ name }} and try again\", \"notSupportedWallet\": \"{{ name }} doesnt support the requested action. Please connect another wallet that supports it\", \"continueIn\": \"Continue in {{ name }}\", \"updateWallet\": \"Update {{ name }}\", \"chooseAnotherWallet\": \"Choose Another Wallet\", \"connectionDeclined\": \"Connection declined\" }, \"desktopConnectionModal\": { \"scanQR\": \"Scan theQR code below with your phonesor{{ name }}s camera\", \"continueInExtension\": \"Continue in{{ name }} browser extension\", \"dontHaveExtension\": \"Seems you don't have installed {{ name }}browserextension\", \"missingFeatures\": \"Please update {{ name }}, your version does not support required features for this dApp\", \"wrongNetwork\": \"Connected wallet is on a different network. Please switch network in {{ name }} and try again\", \"notSupportedWallet\": \"{{ name }} doesnt support the requested action. Please connect another wallet that supports it\", \"getWallet\": \"Get {{ name }}\", \"updateWallet\": \"Update {{ name }}\", \"chooseAnotherWallet\": \"Choose Another Wallet\", \"continueOnDesktop\": \"Continue in{{ name }} on desktop\", \"openWalletOnTelegram\": \"Connect Wallet in Telegram on desktop\", \"connectionDeclined\": \"Connection declined\" }, \"infoModal\": { \"whatIsAWallet\": \"What is a wallet\", \"secureDigitalAssets\": \"Secure digital assets storage\", \"walletProtects\": \"A wallet protects and manages your digital assetsincluding TON, tokens and collectables.\", \"controlIdentity\": \"Control your Web3 identity\", \"manageIdentity\": \"Manage your digital identity and access decentralized applications with ease. Maintain control over your data and engage securely intheblockchain ecosystem.\", \"effortlessCryptoTransactions\": \"Effortless crypto transactions\", \"easilySend\": \"Easily send, receive, monitor your cryptocurrencies.Streamline your operations withdecentralized applications.\", \"getAWallet\": \"Get a Wallet\" }, \"restoreModal\": { \"title\": \"Restore\", \"step1\": { \"title\": \"Find your current recovery phrase\", \"text\": \"Open your wallet settings and locate therecoveryphrase\" }, \"step2\": { \"title\": \"Copy your recovery phrase\", \"text\": \"Write it down or copy it to a safe place\" }, \"step3\": { \"title\": \"Restore in a supported wallet\", \"text\": \"Enter the recovery phrase to access your wallet\" } }, \"allWallets\": { \"walletsBelowNotSupported\": \"The wallets below dont support all features ofthe connected service. You can use your recovery phrase in one of the supported wallets above.\", \"walletNotSupportService\": \"{{ name }} doesnt support connected service\" }, \"featureNotSupported\": { \"wallet\": { \"title\": \"{{ name }} doesnt support the requestedaction\", \"description\": \"Install a supported wallet from the list below, restore it with your recovery phrase, then connect it and try again.\", \"info\": \"Learn how to restore your wallet\" }, \"version\": { \"description\": \"Your current version of {{ name }} or wallet contract type doesn't support the required features. Please update it to continue.\", \"updateButton\": \"Update {{ name }}\", \"aboutW5\": \"About W5\" }, \"disconnect\": { \"title\": \"Confirm Disconnect\", \"description\": \"You will be disconnected from your current wallet and redirected to connect {{ name }}.\", \"button\": \"Disconnect\" } } };\nconst actionModal$1 = { \"confirmTransaction\": { \"header\": \"Confirm thetransaction in{{ name }}\", \"text\": \"It will only take amoment.\" }, \"signData\": { \"header\": \"Sign thedata in{{ name }}\", \"text\": \"It will only take amoment.\" }, \"transactionSent\": \"$notifications.transactionSent\", \"transactionCanceled\": \"$notifications.transactionCanceled\", \"dataSigned\": \"$notifications.dataSigned\", \"signDataCanceled\": \"$notifications.signDataCanceled\" };\nconst en = {\n  common: common$1,\n  button: button$1,\n  notifications: notifications$1,\n  walletItem: walletItem$1,\n  walletModal: walletModal$1,\n  actionModal: actionModal$1\n};\nconst common = { \"close\": \"\", \"openWallet\": \" \", \"copyLink\": \"\", \"linkCopied\": \" \", \"copied\": \"\", \"yourWallet\": \" \", \"retry\": \"\", \"get\": \"\", \"mobile\": \"\", \"browserExtension\": \"\", \"desktop\": \"\" };\nconst button = { \"connectWallet\": \" \", \"dropdown\": { \"copy\": \" \", \"copied\": \" !\", \"disconnect\": \" \" } };\nconst notifications = { \"confirm\": { \"header\": \" {{ name }},  .\" }, \"transactionSent\": { \"header\": \" \", \"text\": \"    .\" }, \"transactionCanceled\": { \"header\": \" \", \"text\": \"   .\" }, \"dataSigned\": { \"header\": \" \" }, \"signDataCanceled\": { \"header\": \"  \" } };\nconst walletItem = { \"walletOn\": \"Wallet \", \"recent\": \"\", \"installed\": \"\", \"popular\": \"\" };\nconst walletModal = { \"loading\": \" \", \"wallets\": \"\", \"mobileUniversalModal\": { \"connectYourWallet\": \" TON\", \"openWalletOnTelegramOrSelect\": \" Wallet Telegram   \", \"openWalletOnTelegram\": \" Wallet  Telegram\", \"chooseOtherApplication\": \"  \", \"openLink\": \"\", \"scan\": \"  \" }, \"desktopUniversalModal\": { \"connectYourWallet\": \" TON \", \"scan\": \" QR-  \", \"availableWallets\": \" \" }, \"mobileConnectionModal\": { \"showQR\": \" QR-\", \"scanQR\": \" QR-    {{ name }},  \", \"missingFeatures\": \" {{ name }},         dApp\", \"wrongNetwork\": \"     . ,    {{ name }}   \", \"notSupportedWallet\": \"{{ name }}    . ,   ,   \", \"continueIn\": \"  {{ name }}\", \"updateWallet\": \" {{ name }}\", \"chooseAnotherWallet\": \"  \", \"connectionDeclined\": \" \" }, \"desktopConnectionModal\": { \"scanQR\": \" QR-    {{ name }},  \", \"continueInExtension\": \"   {{ name }}\", \"dontHaveExtension\": \",    {{ name }}\", \"missingFeatures\": \" {{ name }},         dApp\", \"wrongNetwork\": \"     . ,    {{ name }}   \", \"notSupportedWallet\": \"{{ name }}    . ,   ,   \", \"getWallet\": \" {{ name }}\", \"updateWallet\": \" {{ name }}\", \"chooseAnotherWallet\": \"  \", \"continueOnDesktop\": \" {{ name }} \", \"openWalletOnTelegram\": \" Wallet Telegram\", \"connectionDeclined\": \" \" }, \"infoModal\": { \"whatIsAWallet\": \"  ?\", \"secureDigitalAssets\": \"   \", \"walletProtects\": \"    ,  TON,   ,  .\", \"controlIdentity\": \"   Web3\", \"manageIdentity\": \"        .       .\", \"effortlessCryptoTransactions\": \" \", \"easilySend\": \" ,    .      .\", \"getAWallet\": \" \" }, \"restoreModal\": { \"title\": \"\", \"step1\": { \"title\": \"    \", \"text\": \"     \" }, \"step2\": { \"title\": \"   \", \"text\": \"      \" }, \"step3\": { \"title\": \"   \", \"text\": \"    \" } }, \"allWallets\": { \"walletsBelowNotSupported\": \"       .            .\", \"walletNotSupportService\": \"{{ name }}    \" }, \"featureNotSupported\": { \"wallet\": { \"title\": \"{{ name }}   \", \"description\": \"     ,      ,     .\", \"info\": \",   \" }, \"version\": { \"description\": \"  {{ name }}        .  ,  .\", \"updateButton\": \" {{ name }}\", \"aboutW5\": \" W5\" }, \"disconnect\": { \"title\": \" \", \"description\": \"          {{ name }}.\", \"button\": \"\" } } };\nconst actionModal = { \"confirmTransaction\": { \"header\": \"  {{ name }}\", \"text\": \"   .\" }, \"signData\": { \"header\": \"  {{ name }}\", \"text\": \"   .\" }, \"transactionSent\": \"$notifications.transactionSent\", \"transactionCanceled\": \"$notifications.transactionCanceled\", \"dataSigned\": \"$notifications.dataSigned\", \"signDataCanceled\": \"$notifications.signDataCanceled\" };\nconst ru = {\n  common,\n  button,\n  notifications,\n  walletItem,\n  walletModal,\n  actionModal\n};\nconst i18nDictionary = {\n  en: parseDictionary(en),\n  ru: parseDictionary(ru)\n};\nfunction parseDictionary(dictionary) {\n  const refSymbol = \"$\";\n  const iterate = (subDictionary) => {\n    Object.entries(subDictionary).forEach(([key, value]) => {\n      if (typeof value === \"object\" && value) {\n        return iterate(value);\n      }\n      if (typeof value === \"string\") {\n        if (value[0] === refSymbol) {\n          const path = value.slice(1).split(\".\");\n          let obj = dictionary;\n          path.forEach((item) => {\n            if (item in obj) {\n              obj = obj[item];\n            } else {\n              throw new Error(\n                `Cannot parse translations: there is no property ${item} in translation`\n              );\n            }\n          });\n          subDictionary[key] = obj;\n        }\n        if (value.slice(0, 2) === `\\\\${refSymbol}`) {\n          subDictionary[key] = value.slice(1);\n        }\n      }\n    });\n  };\n  iterate(dictionary);\n  return dictionary;\n}\nconst ConnectorContext = createContext();\nconst $RAW = Symbol(\"store-raw\"), $NODE = Symbol(\"store-node\"), $HAS = Symbol(\"store-has\"), $SELF = Symbol(\"store-self\");\nfunction wrap$1(value) {\n  let p2 = value[$PROXY];\n  if (!p2) {\n    Object.defineProperty(value, $PROXY, {\n      value: p2 = new Proxy(value, proxyTraps$1)\n    });\n    if (!Array.isArray(value)) {\n      const keys = Object.keys(value), desc = Object.getOwnPropertyDescriptors(value);\n      for (let i2 = 0, l2 = keys.length; i2 < l2; i2++) {\n        const prop = keys[i2];\n        if (desc[prop].get) {\n          Object.defineProperty(value, prop, {\n            enumerable: desc[prop].enumerable,\n            get: desc[prop].get.bind(p2)\n          });\n        }\n      }\n    }\n  }\n  return p2;\n}\nfunction isWrappable(obj) {\n  let proto;\n  return obj != null && typeof obj === \"object\" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));\n}\nfunction unwrap(item, set = /* @__PURE__ */ new Set()) {\n  let result, unwrapped, v, prop;\n  if (result = item != null && item[$RAW]) return result;\n  if (!isWrappable(item) || set.has(item)) return item;\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item)) item = item.slice(0);\n    else set.add(item);\n    for (let i2 = 0, l2 = item.length; i2 < l2; i2++) {\n      v = item[i2];\n      if ((unwrapped = unwrap(v, set)) !== v) item[i2] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item)) item = Object.assign({}, item);\n    else set.add(item);\n    const keys = Object.keys(item), desc = Object.getOwnPropertyDescriptors(item);\n    for (let i2 = 0, l2 = keys.length; i2 < l2; i2++) {\n      prop = keys[i2];\n      if (desc[prop].get) continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;\n    }\n  }\n  return item;\n}\nfunction getNodes(target, symbol) {\n  let nodes = target[symbol];\n  if (!nodes) Object.defineProperty(target, symbol, {\n    value: nodes = /* @__PURE__ */ Object.create(null)\n  });\n  return nodes;\n}\nfunction getNode(nodes, property, value) {\n  if (nodes[property]) return nodes[property];\n  const [s2, set] = createSignal(value, {\n    equals: false,\n    internal: true\n  });\n  s2.$ = set;\n  return nodes[property] = s2;\n}\nfunction proxyDescriptor$1(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE) return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  return desc;\n}\nfunction trackSelf(target) {\n  getListener() && getNode(getNodes(target, $NODE), $SELF)();\n}\nfunction ownKeys(target) {\n  trackSelf(target);\n  return Reflect.ownKeys(target);\n}\nconst proxyTraps$1 = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getNodes(target, $NODE);\n    const tracked = nodes[property];\n    let value = tracked ? tracked() : target[property];\n    if (property === $NODE || property === $HAS || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      if (getListener() && (typeof value !== \"function\" || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getNode(nodes, property, value)();\n    }\n    return isWrappable(value) ? wrap$1(value) : value;\n  },\n  has(target, property) {\n    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === $HAS || property === \"__proto__\") return true;\n    getListener() && getNode(getNodes(target, $HAS), property)();\n    return property in target;\n  },\n  set() {\n    return true;\n  },\n  deleteProperty() {\n    return true;\n  },\n  ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor$1\n};\nfunction setProperty(state, property, value, deleting = false) {\n  if (!deleting && state[property] === value) return;\n  const prev = state[property], len = state.length;\n  if (value === void 0) {\n    delete state[property];\n    if (state[$HAS] && state[$HAS][property] && prev !== void 0) state[$HAS][property].$();\n  } else {\n    state[property] = value;\n    if (state[$HAS] && state[$HAS][property] && prev === void 0) state[$HAS][property].$();\n  }\n  let nodes = getNodes(state, $NODE), node;\n  if (node = getNode(nodes, property, prev)) node.$(() => value);\n  if (Array.isArray(state) && state.length !== len) {\n    for (let i2 = state.length; i2 < len; i2++) (node = nodes[i2]) && node.$();\n    (node = getNode(nodes, \"length\", len)) && node.$(state.length);\n  }\n  (node = nodes[$SELF]) && node.$();\n}\nfunction mergeStoreNode(state, value) {\n  const keys = Object.keys(value);\n  for (let i2 = 0; i2 < keys.length; i2 += 1) {\n    const key = keys[i2];\n    setProperty(state, key, value[key]);\n  }\n}\nfunction updateArray(current, next) {\n  if (typeof next === \"function\") next = next(current);\n  next = unwrap(next);\n  if (Array.isArray(next)) {\n    if (current === next) return;\n    let i2 = 0, len = next.length;\n    for (; i2 < len; i2++) {\n      const value = next[i2];\n      if (current[i2] !== value) setProperty(current, i2, value);\n    }\n    setProperty(current, \"length\", len);\n  } else mergeStoreNode(current, next);\n}\nfunction updatePath(current, path, traversed = []) {\n  let part, prev = current;\n  if (path.length > 1) {\n    part = path.shift();\n    const partType = typeof part, isArray = Array.isArray(current);\n    if (Array.isArray(part)) {\n      for (let i2 = 0; i2 < part.length; i2++) {\n        updatePath(current, [part[i2]].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"function\") {\n      for (let i2 = 0; i2 < current.length; i2++) {\n        if (part(current[i2], i2)) updatePath(current, [i2].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"object\") {\n      const {\n        from = 0,\n        to = current.length - 1,\n        by = 1\n      } = part;\n      for (let i2 = from; i2 <= to; i2 += by) {\n        updatePath(current, [i2].concat(path), traversed);\n      }\n      return;\n    } else if (path.length > 1) {\n      updatePath(current[part], path, [part].concat(traversed));\n      return;\n    }\n    prev = current[part];\n    traversed = [part].concat(traversed);\n  }\n  let value = path[0];\n  if (typeof value === \"function\") {\n    value = value(prev, traversed);\n    if (value === prev) return;\n  }\n  if (part === void 0 && value == void 0) return;\n  value = unwrap(value);\n  if (part === void 0 || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) {\n    mergeStoreNode(prev, value);\n  } else setProperty(current, part, value);\n}\nfunction createStore(...[store, options]) {\n  const unwrappedStore = unwrap(store || {});\n  const isArray = Array.isArray(unwrappedStore);\n  const wrappedStore = wrap$1(unwrappedStore);\n  function setStore(...args) {\n    batch(() => {\n      isArray && args.length === 1 ? updateArray(unwrappedStore, args[0]) : updatePath(unwrappedStore, args);\n    });\n  }\n  return [wrappedStore, setStore];\n}\nconst defaultLightColorsSet = {\n  constant: {\n    black: \"#000000\",\n    white: \"#FFFFFF\"\n  },\n  connectButton: {\n    background: \"#0098EA\",\n    foreground: \"#FFFFFF\"\n  },\n  accent: \"#0098EA\",\n  telegramButton: \"#0098EA\",\n  icon: {\n    primary: \"#0F0F0F\",\n    secondary: \"#7A8999\",\n    tertiary: \"#C1CAD2\",\n    success: \"#29CC6A\",\n    error: \"#F5A73B\"\n  },\n  background: {\n    primary: \"#FFFFFF\",\n    secondary: \"#F1F3F5\",\n    segment: \"#FFFFFF\",\n    tint: \"#F1F3F5\",\n    qr: \"#F1F3F5\"\n  },\n  text: {\n    primary: \"#0F0F0F\",\n    secondary: \"#6A7785\"\n  }\n};\nconst defaultDarkColorsSet = {\n  constant: {\n    black: \"#000000\",\n    white: \"#FFFFFF\"\n  },\n  connectButton: {\n    background: \"#0098EA\",\n    foreground: \"#FFFFFF\"\n  },\n  accent: \"#E5E5EA\",\n  telegramButton: \"#31A6F5\",\n  icon: {\n    primary: \"#E5E5EA\",\n    secondary: \"#909099\",\n    tertiary: \"#434347\",\n    success: \"#29CC6A\",\n    error: \"#F5A73B\"\n  },\n  background: {\n    primary: \"#121214\",\n    secondary: \"#18181A\",\n    segment: \"#262629\",\n    tint: \"#222224\",\n    qr: \"#FFFFFF\"\n  },\n  text: {\n    primary: \"#E5E5EA\",\n    secondary: \"#7D7D85\"\n  }\n};\n/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\nfunction isObject(o2) {\n  return Object.prototype.toString.call(o2) === \"[object Object]\";\n}\nfunction isPlainObject(o2) {\n  var ctor, prot;\n  if (isObject(o2) === false) return false;\n  ctor = o2.constructor;\n  if (ctor === void 0) return true;\n  prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n  if (prot.hasOwnProperty(\"isPrototypeOf\") === false) {\n    return false;\n  }\n  return true;\n}\nfunction mergeOptions(options, defaultOptions) {\n  if (!options) {\n    return defaultOptions;\n  }\n  const overwriteMerge = (_, sourceArray, __) => sourceArray;\n  return deepmerge__WEBPACK_IMPORTED_MODULE_2__(defaultOptions, options, {\n    arrayMerge: overwriteMerge,\n    isMergeableObject: isPlainObject\n  });\n}\nconst [themeState, setThemeState] = createStore({\n  theme: THEME.LIGHT,\n  colors: defaultLightColorsSet,\n  borderRadius: \"m\"\n});\nconst themeColorsMappingDefault = {\n  [THEME.LIGHT]: defaultLightColorsSet,\n  [THEME.DARK]: defaultDarkColorsSet\n};\nconst themeCustomColors = {\n  [THEME.LIGHT]: void 0,\n  [THEME.DARK]: void 0\n};\nfunction setTheme(theme, colorsSet) {\n  if (colorsSet) {\n    themeCustomColors[THEME.DARK] = mergeOptions(\n      colorsSet[THEME.DARK],\n      themeCustomColors[THEME.DARK]\n    );\n    themeCustomColors[THEME.LIGHT] = mergeOptions(\n      colorsSet[THEME.LIGHT],\n      themeCustomColors[THEME.LIGHT]\n    );\n  }\n  setThemeState({\n    theme,\n    colors: mergeOptions(themeCustomColors[theme], themeColorsMappingDefault[theme])\n  });\n}\nfunction setBorderRadius(borderRadius) {\n  setThemeState({ borderRadius });\n}\nfunction setColors(colorsSet) {\n  themeCustomColors[THEME.DARK] = mergeOptions(\n    colorsSet[THEME.DARK],\n    themeCustomColors[THEME.DARK]\n  );\n  themeCustomColors[THEME.LIGHT] = mergeOptions(\n    colorsSet[THEME.LIGHT],\n    themeCustomColors[THEME.LIGHT]\n  );\n  setThemeState((state) => ({\n    colors: mergeOptions(\n      themeCustomColors[state.theme],\n      themeColorsMappingDefault[state.theme]\n    )\n  }));\n}\nconst ImagePlaceholder = styled.div`\n    background-color: ${(props) => props.theme.colors.background.secondary};\n`;\nconst Image = (props) => {\n  let imgRef;\n  const [image, setImage] = createSignal(null);\n  createEffect(() => {\n    const img = new window.Image();\n    img.src = props.src;\n    img.alt = props.alt || \"\";\n    img.setAttribute(\"draggable\", \"false\");\n    if (props.class) {\n      img.classList.add(props.class);\n    }\n    if (img.complete) {\n      return setImage(img);\n    }\n    img.addEventListener(\"load\", () => setImage(img));\n    return () => img.removeEventListener(\"load\", () => setImage(img));\n  });\n  return [createComponent(Show, {\n    get when() {\n      return image();\n    },\n    get children() {\n      return image();\n    }\n  }), createComponent(Show, {\n    get when() {\n      return !image();\n    },\n    get children() {\n      return createComponent(ImagePlaceholder, {\n        get [\"class\"]() {\n          return props.class;\n        },\n        ref(r$) {\n          var _ref$ = imgRef;\n          typeof _ref$ === \"function\" ? _ref$(r$) : imgRef = r$;\n        }\n      });\n    }\n  })];\n};\nlet initParams = {};\ntry {\n  let locationHash = location.hash.toString();\n  initParams = urlParseHashParams(locationHash);\n} catch (e2) {\n}\ntry {\n  const launchParamsStorageKey = \"ton-connect-session_storage_launchParams\";\n  if (Object.entries(initParams).length > 0) {\n    sessionStorage.setItem(launchParamsStorageKey, JSON.stringify(initParams));\n  } else {\n    const savedInitParams = sessionStorage.getItem(launchParamsStorageKey);\n    if (savedInitParams) {\n      initParams = JSON.parse(savedInitParams);\n    }\n  }\n} catch (e2) {\n}\nlet tmaPlatform = \"unknown\";\nif (initParams == null ? void 0 : initParams.tgWebAppPlatform) {\n  tmaPlatform = (_a = initParams.tgWebAppPlatform) != null ? _a : \"unknown\";\n}\nif (tmaPlatform === \"unknown\") {\n  const window2 = getWindow$1();\n  tmaPlatform = (_d = (_c = (_b = window2 == null ? void 0 : window2.Telegram) == null ? void 0 : _b.WebApp) == null ? void 0 : _c.platform) != null ? _d : \"unknown\";\n}\nlet webAppVersion = \"6.0\";\nif (initParams == null ? void 0 : initParams.tgWebAppVersion) {\n  webAppVersion = initParams.tgWebAppVersion;\n}\nif (!webAppVersion) {\n  const window2 = getWindow$1();\n  webAppVersion = (_g = (_f = (_e = window2 == null ? void 0 : window2.Telegram) == null ? void 0 : _e.WebApp) == null ? void 0 : _f.version) != null ? _g : \"6.0\";\n}\nconst initDataRaw = initParams == null ? void 0 : initParams.tgWebAppData;\nlet telegramUser = void 0;\ntry {\n  if (initDataRaw) {\n    let initData = urlParseQueryString(initDataRaw);\n    let userRaw = initData.user;\n    if (userRaw) {\n      let user = JSON.parse(userRaw);\n      if (typeof user.id === \"number\" && typeof user.is_premium === \"boolean\") {\n        telegramUser = {\n          id: user.id,\n          isPremium: user.is_premium\n        };\n      }\n    }\n  }\n} catch (e2) {\n}\nfunction getTgUser() {\n  return telegramUser;\n}\nfunction isTmaPlatform(...platforms) {\n  return platforms.includes(tmaPlatform);\n}\nfunction isInTMA() {\n  var _a2;\n  return tmaPlatform !== \"unknown\" || !!((_a2 = getWindow$1()) == null ? void 0 : _a2.TelegramWebviewProxy);\n}\nfunction isInTelegramBrowser() {\n  var _a2;\n  const isTelegramWebview = !!((_a2 = getWindow$1()) == null ? void 0 : _a2.TelegramWebview);\n  return (isInTMA() || isTelegramWebview) && tmaPlatform === \"unknown\";\n}\nfunction sendExpand() {\n  postEvent(\"web_app_expand\", {});\n}\nfunction sendOpenTelegramLink(link, fallback) {\n  const url = new URL(link);\n  if (url.protocol !== \"http:\" && url.protocol !== \"https:\") {\n    if (fallback) {\n      return fallback();\n    }\n    throw new TonConnectUIError(`Url protocol is not supported: ${url}`);\n  }\n  if (url.hostname !== \"t.me\") {\n    if (fallback) {\n      return fallback();\n    }\n    throw new TonConnectUIError(`Url host is not supported: ${url}`);\n  }\n  const pathFull = url.pathname + url.search;\n  if (isIframe() || versionAtLeast(\"6.1\")) {\n    setLastOpenedLink({ link: pathFull, type: \"tg_link\" });\n    postEvent(\"web_app_open_tg_link\", { path_full: pathFull });\n  } else {\n    openLinkBlank(\"https://t.me\" + pathFull);\n  }\n}\nfunction isIframe() {\n  try {\n    const window2 = getWindow$1();\n    if (!window2) {\n      return false;\n    }\n    return window2.parent != null && window2 !== window2.parent;\n  } catch (e2) {\n    return false;\n  }\n}\nfunction postEvent(eventType, eventData) {\n  try {\n    const window2 = getWindow$1();\n    if (!window2) {\n      throw new TonConnectUIError(`Can't post event to parent window: window is not defined`);\n    }\n    if (window2.TelegramWebviewProxy !== void 0) {\n      logDebug(\"postEvent\", eventType, eventData);\n      window2.TelegramWebviewProxy.postEvent(eventType, JSON.stringify(eventData));\n    } else if (window2.external && \"notify\" in window2.external) {\n      logDebug(\"postEvent\", eventType, eventData);\n      window2.external.notify(JSON.stringify({ eventType, eventData }));\n    } else if (isIframe()) {\n      const trustedTarget = \"*\";\n      const message = JSON.stringify({ eventType, eventData });\n      logDebug(\"postEvent\", eventType, eventData);\n      window2.parent.postMessage(message, trustedTarget);\n    } else {\n      throw new TonConnectUIError(`Can't post event to TMA`);\n    }\n  } catch (e2) {\n    logError(`Can't post event to parent window: ${e2}`);\n  }\n}\nfunction urlParseHashParams(locationHash) {\n  locationHash = locationHash.replace(/^#/, \"\");\n  let params = {};\n  if (!locationHash.length) {\n    return params;\n  }\n  if (locationHash.indexOf(\"=\") < 0 && locationHash.indexOf(\"?\") < 0) {\n    params._path = urlSafeDecode(locationHash);\n    return params;\n  }\n  let qIndex = locationHash.indexOf(\"?\");\n  if (qIndex >= 0) {\n    let pathParam = locationHash.substr(0, qIndex);\n    params._path = urlSafeDecode(pathParam);\n    locationHash = locationHash.substr(qIndex + 1);\n  }\n  let query_params = urlParseQueryString(locationHash);\n  for (let k in query_params) {\n    params[k] = query_params[k];\n  }\n  return params;\n}\nfunction urlSafeDecode(urlencoded) {\n  try {\n    urlencoded = urlencoded.replace(/\\+/g, \"%20\");\n    return decodeURIComponent(urlencoded);\n  } catch (e2) {\n    return urlencoded;\n  }\n}\nfunction urlParseQueryString(queryString) {\n  let params = {};\n  if (!queryString.length) {\n    return params;\n  }\n  let queryStringParams = queryString.split(\"&\");\n  let i2, param, paramName, paramValue;\n  for (i2 = 0; i2 < queryStringParams.length; i2++) {\n    param = queryStringParams[i2].split(\"=\");\n    paramName = urlSafeDecode(param[0]);\n    paramValue = param[1] == null ? null : urlSafeDecode(param[1]);\n    params[paramName] = paramValue;\n  }\n  return params;\n}\nfunction versionCompare(v1, v2) {\n  if (typeof v1 !== \"string\") v1 = \"\";\n  let v1List = v1.replace(/^\\s+|\\s+$/g, \"\").split(\".\");\n  let v2List = v2.replace(/^\\s+|\\s+$/g, \"\").split(\".\");\n  let a2, i2, p1, p2;\n  a2 = Math.max(v1List.length, v2List.length);\n  for (i2 = 0; i2 < a2; i2++) {\n    p1 = parseInt(v1List[i2]) || 0;\n    p2 = parseInt(v2List[i2]) || 0;\n    if (p1 === p2) continue;\n    if (p1 > p2) return 1;\n    return -1;\n  }\n  return 0;\n}\nfunction versionAtLeast(ver) {\n  return versionCompare(webAppVersion, ver) >= 0;\n}\nconst maxWidth = {\n  mobile: 440,\n  tablet: 1020\n};\nfunction isDevice(device) {\n  const window2 = getWindow$1();\n  if (!window2) {\n    return device === \"desktop\";\n  }\n  if (isTmaPlatform(\"weba\")) {\n    return true;\n  }\n  const width = window2.innerWidth;\n  switch (device) {\n    case \"desktop\":\n      return width > maxWidth.tablet;\n    case \"tablet\":\n      return width > maxWidth.mobile;\n    default:\n    case \"mobile\":\n      return width <= maxWidth.mobile || isOS(\"ios\", \"android\", \"ipad\");\n  }\n}\nfunction media(device) {\n  switch (device) {\n    case \"mobile\":\n      return `@media (max-width: ${maxWidth.mobile}px)`;\n    case \"tablet\":\n      return `@media (max-width: ${maxWidth.tablet}px) (min-width: ${maxWidth.mobile}px)`;\n    default:\n    case \"desktop\":\n      return `@media (min-width: ${maxWidth.tablet}px)`;\n  }\n}\nconst mediaTouch = \"@media (hover: none)\";\nconst mediaNotTouch = \"@media not all and (hover: none)\";\nconst borders$6 = {\n  m: \"100vh\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst scaleValues = {\n  s: 0.02,\n  m: 0.04\n};\nconst ButtonStyled$1 = styled.button`\n    display: ${(props) => props.leftIcon || props.rightIcon ? \"flex\" : \"inline-block\"};\n    gap: ${(props) => props.leftIcon || props.rightIcon ? \"6px\" : \"unset\"};\n    align-items: ${(props) => props.leftIcon || props.rightIcon ? \"center\" : \"unset\"};\n    justify-content: ${(props) => props.leftIcon || props.rightIcon ? \"space-between\" : \"unset\"};\n    background-color: ${(props) => props.appearance === \"flat\" ? \"transparent\" : props.appearance === \"secondary\" ? props.theme.colors.background.tint : rgba(props.theme.colors.accent, 0.12)};\n    color: ${(props) => props.appearance === \"secondary\" ? props.theme.colors.text.primary : props.theme.colors.accent};\n\n    padding: ${(props) => props.appearance === \"flat\" ? \"0\" : \"9px 16px\"};\n    padding-left: ${(props) => props.leftIcon && props.appearance !== \"flat\" ? \"12px\" : \"16px\"};\n    padding-right: ${(props) => props.rightIcon && props.appearance !== \"flat\" ? \"12px\" : \"16px\"};\n    border: none;\n    border-radius: ${(props) => borders$6[props.theme.borderRadius]};\n    cursor: ${(props) => props.disabled ? \"not-allowed\" : \"pointer\"};\n\n    font-size: 14px;\n    font-weight: 510;\n    line-height: 18px;\n\n    transition: transform 0.125s ease-in-out;\n\n    ${mediaNotTouch} {\n        &:hover {\n            transform: ${(props) => props.disabled ? \"unset\" : `scale(${1 + scaleValues[props.scale]})`};\n        }\n    }\n\n    &:active {\n        transform: ${(props) => props.disabled ? \"unset\" : `scale(${1 - scaleValues[props.scale]})`};\n    }\n\n    ${mediaTouch} {\n        &:active {\n            transform: ${(props) => props.disabled ? \"unset\" : `scale(${1 - scaleValues[props.scale] * 2})`};\n        }\n    }\n`;\nfunction useDataAttributes(props) {\n  const keys = untrack(() => Object.keys(props).filter((key) => key.startsWith(\"data-\")));\n  const [dataAttrs] = splitProps(props, keys);\n  return dataAttrs;\n}\nconst Button = (props) => {\n  const dataAttrs = useDataAttributes(props);\n  return createComponent(ButtonStyled$1, mergeProps({\n    type: \"button\",\n    get appearance() {\n      return props.appearance || \"primary\";\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    onClick: (e2) => {\n      var _a2;\n      return (_a2 = props.onClick) == null ? void 0 : _a2.call(props, e2);\n    },\n    onMouseEnter: (e2) => {\n      var _a2;\n      return (_a2 = props.onMouseEnter) == null ? void 0 : _a2.call(props, e2);\n    },\n    onMouseLeave: (e2) => {\n      var _a2;\n      return (_a2 = props.onMouseLeave) == null ? void 0 : _a2.call(props, e2);\n    },\n    ref(r$) {\n      var _ref$ = props.ref;\n      typeof _ref$ === \"function\" ? _ref$(r$) : props.ref = r$;\n    },\n    get disabled() {\n      return props.disabled;\n    },\n    get scale() {\n      return props.scale || \"m\";\n    },\n    get leftIcon() {\n      return !!props.leftIcon;\n    },\n    get rightIcon() {\n      return !!props.rightIcon;\n    },\n    \"data-tc-button\": \"true\"\n  }, dataAttrs, {\n    get children() {\n      return [memo(() => props.leftIcon), memo(() => props.children), memo(() => props.rightIcon)];\n    }\n  }));\n};\nconst noop = () => {\n};\nconst noopTransition = (el, done) => done();\nfunction createSwitchTransition(source, options) {\n  const initSource = untrack(source);\n  const initReturned = initSource ? [initSource] : [];\n  const { onEnter = noopTransition, onExit = noopTransition } = options;\n  const [returned, setReturned] = createSignal(options.appear ? [] : initReturned);\n  const [isTransitionPending] = useTransition();\n  let next;\n  let isExiting = false;\n  function exitTransition2(el, after) {\n    if (!el)\n      return after && after();\n    isExiting = true;\n    onExit(el, () => {\n      batch(() => {\n        isExiting = false;\n        setReturned((p2) => p2.filter((e2) => e2 !== el));\n        after && after();\n      });\n    });\n  }\n  function enterTransition2(after) {\n    const el = next;\n    if (!el)\n      return after && after();\n    next = void 0;\n    setReturned((p2) => [el, ...p2]);\n    onEnter(el, after != null ? after : noop);\n  }\n  const triggerTransitions = options.mode === \"out-in\" ? (\n    // exit -> enter\n    // exit -> enter\n    (prev) => isExiting || exitTransition2(prev, enterTransition2)\n  ) : options.mode === \"in-out\" ? (\n    // enter -> exit\n    // enter -> exit\n    (prev) => enterTransition2(() => exitTransition2(prev))\n  ) : (\n    // exit & enter\n    // exit & enter\n    (prev) => {\n      exitTransition2(prev);\n      enterTransition2();\n    }\n  );\n  createComputed((prev) => {\n    const el = source();\n    if (untrack(isTransitionPending)) {\n      isTransitionPending();\n      return prev;\n    }\n    if (el !== prev) {\n      next = el;\n      batch(() => untrack(() => triggerTransitions(prev)));\n    }\n    return el;\n  }, options.appear ? void 0 : initSource);\n  return returned;\n}\nfunction createListTransition(source, options) {\n  const initSource = untrack(source);\n  const { onChange } = options;\n  let prevSet = new Set(options.appear ? void 0 : initSource);\n  const exiting = /* @__PURE__ */ new WeakSet();\n  const [toRemove, setToRemove] = createSignal([], { equals: false });\n  const [isTransitionPending] = useTransition();\n  const finishRemoved = (els) => {\n    setToRemove((p2) => (p2.push.apply(p2, els), p2));\n    for (const el of els)\n      exiting.delete(el);\n  };\n  const handleRemoved = (els, el, i2) => els.splice(i2, 0, el);\n  return createMemo((prev) => {\n    const elsToRemove = toRemove();\n    const sourceList = source();\n    sourceList[$TRACK];\n    if (untrack(isTransitionPending)) {\n      isTransitionPending();\n      return prev;\n    }\n    if (elsToRemove.length) {\n      const next = prev.filter((e2) => !elsToRemove.includes(e2));\n      elsToRemove.length = 0;\n      onChange({ list: next, added: [], removed: [], unchanged: next, finishRemoved });\n      return next;\n    }\n    return untrack(() => {\n      const nextSet = new Set(sourceList);\n      const next = sourceList.slice();\n      const added = [];\n      const removed = [];\n      const unchanged = [];\n      for (const el of sourceList) {\n        (prevSet.has(el) ? unchanged : added).push(el);\n      }\n      let nothingChanged = !added.length;\n      for (let i2 = 0; i2 < prev.length; i2++) {\n        const el = prev[i2];\n        if (!nextSet.has(el)) {\n          if (!exiting.has(el)) {\n            removed.push(el);\n            exiting.add(el);\n          }\n          handleRemoved(next, el, i2);\n        }\n        if (nothingChanged && el !== next[i2])\n          nothingChanged = false;\n      }\n      if (!removed.length && nothingChanged)\n        return prev;\n      onChange({ list: next, added, removed, unchanged, finishRemoved });\n      prevSet = nextSet;\n      return next;\n    });\n  }, options.appear ? [] : initSource.slice());\n}\nconst defaultElementPredicate = (item) => item instanceof Element;\nfunction getResolvedElements(value, predicate) {\n  if (predicate(value))\n    return value;\n  if (typeof value === \"function\" && !value.length)\n    return getResolvedElements(value(), predicate);\n  if (Array.isArray(value)) {\n    const results = [];\n    for (const item of value) {\n      const result = getResolvedElements(item, predicate);\n      if (result)\n        Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results.length ? results : null;\n  }\n  return null;\n}\nfunction resolveElements(fn, predicate = defaultElementPredicate, serverPredicate = defaultElementPredicate) {\n  const children2 = createMemo(fn);\n  const memo2 = createMemo(() => getResolvedElements(children2(), predicate));\n  memo2.toArray = () => {\n    const value = memo2();\n    return Array.isArray(value) ? value : value ? [value] : [];\n  };\n  return memo2;\n}\nfunction getFirstChild(value, predicate) {\n  if (predicate(value))\n    return value;\n  if (typeof value === \"function\" && !value.length)\n    return getFirstChild(value(), predicate);\n  if (Array.isArray(value)) {\n    for (const item of value) {\n      const result = getFirstChild(item, predicate);\n      if (result)\n        return result;\n    }\n  }\n  return null;\n}\nfunction resolveFirst(fn, predicate = defaultElementPredicate, serverPredicate = defaultElementPredicate) {\n  const children2 = createMemo(fn);\n  return createMemo(() => getFirstChild(children2(), predicate));\n}\nfunction createClassnames(props) {\n  return createMemo(() => {\n    const name = props.name || \"s\";\n    return {\n      enterActive: (props.enterActiveClass || name + \"-enter-active\").split(\" \"),\n      enter: (props.enterClass || name + \"-enter\").split(\" \"),\n      enterTo: (props.enterToClass || name + \"-enter-to\").split(\" \"),\n      exitActive: (props.exitActiveClass || name + \"-exit-active\").split(\" \"),\n      exit: (props.exitClass || name + \"-exit\").split(\" \"),\n      exitTo: (props.exitToClass || name + \"-exit-to\").split(\" \"),\n      move: (props.moveClass || name + \"-move\").split(\" \")\n    };\n  });\n}\nfunction nextFrame(fn) {\n  requestAnimationFrame(() => requestAnimationFrame(fn));\n}\nfunction enterTransition(classes, events, el, done) {\n  const { onBeforeEnter, onEnter, onAfterEnter } = events;\n  onBeforeEnter == null ? void 0 : onBeforeEnter(el);\n  el.classList.add(...classes.enter);\n  el.classList.add(...classes.enterActive);\n  queueMicrotask(() => {\n    if (!el.parentNode)\n      return done == null ? void 0 : done();\n    onEnter == null ? void 0 : onEnter(el, () => endTransition());\n  });\n  nextFrame(() => {\n    el.classList.remove(...classes.enter);\n    el.classList.add(...classes.enterTo);\n    if (!onEnter || onEnter.length < 2) {\n      el.addEventListener(\"transitionend\", endTransition);\n      el.addEventListener(\"animationend\", endTransition);\n    }\n  });\n  function endTransition(e2) {\n    if (!e2 || e2.target === el) {\n      done == null ? void 0 : done();\n      el.removeEventListener(\"transitionend\", endTransition);\n      el.removeEventListener(\"animationend\", endTransition);\n      el.classList.remove(...classes.enterActive);\n      el.classList.remove(...classes.enterTo);\n      onAfterEnter == null ? void 0 : onAfterEnter(el);\n    }\n  }\n}\nfunction exitTransition(classes, events, el, done) {\n  const { onBeforeExit, onExit, onAfterExit } = events;\n  if (!el.parentNode)\n    return done == null ? void 0 : done();\n  onBeforeExit == null ? void 0 : onBeforeExit(el);\n  el.classList.add(...classes.exit);\n  el.classList.add(...classes.exitActive);\n  onExit == null ? void 0 : onExit(el, () => endTransition());\n  nextFrame(() => {\n    el.classList.remove(...classes.exit);\n    el.classList.add(...classes.exitTo);\n    if (!onExit || onExit.length < 2) {\n      el.addEventListener(\"transitionend\", endTransition);\n      el.addEventListener(\"animationend\", endTransition);\n    }\n  });\n  function endTransition(e2) {\n    if (!e2 || e2.target === el) {\n      done == null ? void 0 : done();\n      el.removeEventListener(\"transitionend\", endTransition);\n      el.removeEventListener(\"animationend\", endTransition);\n      el.classList.remove(...classes.exitActive);\n      el.classList.remove(...classes.exitTo);\n      onAfterExit == null ? void 0 : onAfterExit(el);\n    }\n  }\n}\nconst TRANSITION_MODE_MAP = {\n  inout: \"in-out\",\n  outin: \"out-in\"\n};\nconst Transition = (props) => {\n  const classnames = createClassnames(props);\n  return createSwitchTransition(resolveFirst(() => props.children), {\n    mode: TRANSITION_MODE_MAP[props.mode],\n    appear: props.appear,\n    onEnter(el, done) {\n      enterTransition(classnames(), props, el, done);\n    },\n    onExit(el, done) {\n      exitTransition(classnames(), props, el, done);\n    }\n  });\n};\nconst TransitionGroup = (props) => {\n  const classnames = createClassnames(props);\n  return createListTransition(resolveElements(() => props.children).toArray, {\n    appear: props.appear,\n    onChange({ added, removed, finishRemoved, list }) {\n      const classes = classnames();\n      for (const el of added) {\n        enterTransition(classes, props, el);\n      }\n      const toMove = [];\n      for (const el of list) {\n        if (el.isConnected && (el instanceof HTMLElement || el instanceof SVGElement)) {\n          toMove.push({ el, rect: el.getBoundingClientRect() });\n        }\n      }\n      queueMicrotask(() => {\n        const moved = [];\n        for (const { el, rect } of toMove) {\n          if (el.isConnected) {\n            const newRect = el.getBoundingClientRect(), dX = rect.left - newRect.left, dY = rect.top - newRect.top;\n            if (dX || dY) {\n              el.style.transform = `translate(${dX}px, ${dY}px)`;\n              el.style.transitionDuration = \"0s\";\n              moved.push(el);\n            }\n          }\n        }\n        document.body.offsetHeight;\n        for (const el of moved) {\n          let endTransition = function(e2) {\n            if (e2.target === el || /transform$/.test(e2.propertyName)) {\n              el.removeEventListener(\"transitionend\", endTransition);\n              el.classList.remove(...classes.move);\n            }\n          };\n          el.classList.add(...classes.move);\n          el.style.transform = el.style.transitionDuration = \"\";\n          el.addEventListener(\"transitionend\", endTransition);\n        }\n      });\n      for (const el of removed) {\n        exitTransition(classes, props, el, () => finishRemoved([el]));\n      }\n    }\n  });\n};\nfunction clickOutside$1(el, accessor) {\n  const onClick = (e2) => {\n    var _a2;\n    return !el.contains(e2.target) && ((_a2 = accessor()) == null ? void 0 : _a2());\n  };\n  document.body.addEventListener(\"click\", onClick);\n  onCleanup(() => document.body.removeEventListener(\"click\", onClick));\n}\nfunction escPressed(_, accessor) {\n  const onKeyPress = (e2) => {\n    var _a2, _b2;\n    if (e2.key === \"Escape\") {\n      (_a2 = document.activeElement) == null ? void 0 : _a2.blur();\n      (_b2 = accessor()) == null ? void 0 : _b2();\n    }\n  };\n  document.body.addEventListener(\"keydown\", onKeyPress);\n  onCleanup(() => document.body.removeEventListener(\"keydown\", onKeyPress));\n}\nfunction androidBackHandler$1(_, config) {\n  const {\n    isEnabled,\n    onClose\n  } = config();\n  if (!isEnabled) {\n    return;\n  }\n  const userOSIsAndroid = getUserAgent().os === \"android\";\n  if (!userOSIsAndroid) {\n    return;\n  }\n  window.history.pushState(ROUTE_STATE, \"\");\n  const popstateHandler = (event) => {\n    event.preventDefault();\n    onClose();\n  };\n  window.addEventListener(\"popstate\", popstateHandler, {\n    once: true\n  });\n  onCleanup(() => {\n    window.removeEventListener(\"popstate\", popstateHandler);\n    createMacrotask(() => {\n      var _a2;\n      if (((_a2 = window.history.state) == null ? void 0 : _a2[ROUTE_STATE_KEY]) === true) {\n        window.history.back();\n      }\n    });\n  });\n}\nconst ROUTE_STATE_KEY = \"androidBackHandler\";\nconst ROUTE_STATE = {\n  [ROUTE_STATE_KEY]: true\n};\nvar _tmpl$$v = /* @__PURE__ */ template$1(`<svg><path fill-rule=evenodd clip-rule=evenodd d=\"M10.2122 14.3407C10.5384 14.0854 10.5959 13.614 10.3406 13.2878L6.20237 8.00003L10.3406 2.71227C10.5959 2.38607 10.5384 1.91469 10.2122 1.6594C9.88604 1.40412 9.41465 1.46161 9.15937 1.7878L4.65937 7.5378C4.44688 7.80932 4.44688 8.19074 4.65937 8.46226L9.15937 14.2123C9.41465 14.5385 9.88604 14.5959 10.2122 14.3407Z\"></svg>`, false, true, false);\nconst rotationDegrees = {\n  left: 0,\n  top: 90,\n  right: 180,\n  bottom: 270\n};\nconst ArrowIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  const direction = () => props.direction || \"left\";\n  const Svg = styled(\"svg\")`\n        transform: rotate(${(props2) => rotationDegrees[props2.svgDirection]}deg);\n        transition: transform 0.1s ease-in-out;\n    `;\n  return createComponent(Svg, {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: \"16\",\n    height: \"16\",\n    viewBox: \"0 0 16 16\",\n    fill: \"none\",\n    get svgDirection() {\n      return direction();\n    },\n    get children() {\n      var _el$ = _tmpl$$v();\n      createRenderEffect(() => setAttribute(_el$, \"fill\", fill()));\n      return _el$;\n    }\n  });\n};\nvar _tmpl$$u = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M2.71966 2.71968C3.01255 2.42678 3.48743 2.42677 3.78032 2.71966L8.00002 6.93925L12.2197 2.71967C12.5126 2.42677 12.9874 2.42678 13.2803 2.71967C13.5732 3.01257 13.5732 3.48744 13.2803 3.78033L9.06068 7.99991L13.2803 12.2197C13.5732 12.5126 13.5732 12.9874 13.2803 13.2803C12.9874 13.5732 12.5126 13.5732 12.2197 13.2803L8.00002 9.06057L3.78033 13.2803C3.48744 13.5732 3.01257 13.5732 2.71967 13.2803C2.42678 12.9874 2.42677 12.5126 2.71967 12.2197L6.93936 7.99991L2.71968 3.78034C2.42678 3.48745 2.42677 3.01257 2.71966 2.71968Z\">`);\nconst CloseIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    var _el$ = _tmpl$$u(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nconst IconButtonStyled = styled.button`\n    padding: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 32px;\n    height: 32px;\n    border-radius: 50%;\n    background-color: ${(props) => props.theme.colors.background.tint};\n    border: none;\n    cursor: pointer;\n\n    transition: transform 0.125s ease-in-out;\n\n    ${mediaNotTouch} {\n        &:hover {\n            transform: scale(1.04);\n        }\n    }\n\n    &:active {\n        transform: scale(0.96);\n    }\n\n    ${mediaTouch} {\n        &:active {\n            transform: scale(0.92);\n        }\n    }\n`;\nconst IconButton = (props) => {\n  const dataAttrs = useDataAttributes(props);\n  const icon = () => props.icon || \"close\";\n  return createComponent(IconButtonStyled, mergeProps({\n    get [\"class\"]() {\n      return props.class;\n    },\n    onClick: () => props.onClick(),\n    \"data-tc-icon-button\": \"true\"\n  }, dataAttrs, {\n    get children() {\n      return [createComponent(Show, {\n        get when() {\n          return !!props.children;\n        },\n        get children() {\n          return props.children;\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !props.children;\n        },\n        get children() {\n          return createComponent(Switch, {\n            get children() {\n              return [createComponent(Match, {\n                get when() {\n                  return icon() === \"close\";\n                },\n                get children() {\n                  return createComponent(CloseIcon, {\n                    get fill() {\n                      return props.fill;\n                    }\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return icon() === \"arrow\";\n                },\n                get children() {\n                  return createComponent(ArrowIcon, {\n                    get fill() {\n                      return props.fill;\n                    }\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return icon() === \"question\";\n                },\n                get children() {\n                  return createComponent(QuestionIcon, {\n                    get fill() {\n                      return props.fill;\n                    }\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return typeof icon() !== \"string\";\n                },\n                get children() {\n                  return icon();\n                }\n              })];\n            }\n          });\n        }\n      })];\n    }\n  }));\n};\nconst borders$5 = {\n  m: \"24px\",\n  s: \"16px\",\n  none: \"0\"\n};\nconst ModalBackgroundStyled = styled.div`\n    display: flex;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.4);\n    padding: 20px 0;\n    overflow-y: auto;\n\n    ${media(\"mobile\")} {\n        padding-bottom: 0;\n    }\n`;\nconst ModalWrapperClass = u`\n    box-shadow:\n        0 4px 16px rgba(0, 0, 0, 0.08),\n        0 16px 64px rgba(0, 0, 0, 0.16);\n    width: fit-content;\n    margin: auto;\n\n    ${media(\"mobile\")} {\n        width: 100%;\n        height: fit-content;\n        margin: auto 0 0 0;\n    }\n`;\nconst ModalBodyStyled = styled.div`\n    position: relative;\n    min-height: 100px;\n    width: 416px;\n    padding: 44px 56px 24px;\n\n    box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.04);\n\n    background-color: ${(props) => props.theme.colors.background.primary};\n    border-radius: ${(props) => borders$5[props.theme.borderRadius]};\n\n    ${media(\"mobile\")} {\n        width: 100%;\n    }\n`;\nconst CloseButtonStyled = styled(IconButton)`\n    position: absolute;\n    right: 16px;\n    top: 16px;\n`;\nconst ModalFooterStyled = styled.div`\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 16px 16px 16px 18px;\n    border-radius: 0 0 ${(props) => borders$5[props.theme.borderRadius]}\n        ${(props) => borders$5[props.theme.borderRadius]};\n`;\nconst QuestionButtonStyled = styled(IconButton)`\n    background-color: ${(props) => rgba(props.theme.colors.icon.secondary, 0.12)};\n`;\nclass AnimationTimelineNoop {\n  constructor() {\n    this.currentTime = 0;\n  }\n}\nconst _AnimationNoop = class _AnimationNoop {\n  constructor() {\n    this.currentTime = 0;\n    this.playbackRate = 1;\n    this.startTime = null;\n    this.timeline = new AnimationTimelineNoop();\n    this.finished = Promise.resolve(this);\n    this.effect = null;\n    this.id = \"\";\n    this.pending = false;\n    this.playState = \"finished\";\n    this.replaceState = \"active\";\n    this.ready = Promise.resolve(this);\n    this.oncancel = null;\n    this.onfinish = null;\n    this.onremove = null;\n  }\n  static create() {\n    if (!_AnimationNoop._instance) {\n      logWarning(\n        \"Animation is not supported in this environment: please consider using the `web-animations-js` polyfill to provide a fallback implementation of the Web Animations API.\"\n      );\n      _AnimationNoop._instance = new _AnimationNoop();\n    }\n    return _AnimationNoop._instance;\n  }\n  cancel() {\n  }\n  finish() {\n  }\n  pause() {\n  }\n  play() {\n  }\n  reverse() {\n  }\n  addEventListener(_type, _listener, _options) {\n  }\n  dispatchEvent(_event) {\n    return false;\n  }\n  removeEventListener(_type, _callback, _options) {\n  }\n  updatePlaybackRate(_playbackRate) {\n  }\n  commitStyles() {\n  }\n  persist() {\n  }\n};\n_AnimationNoop._instance = null;\nlet AnimationNoop = _AnimationNoop;\nfunction animate(element, keyframes, options) {\n  if (\"animate\" in element) {\n    return element.animate(keyframes, options);\n  }\n  return AnimationNoop.create();\n}\nvar _tmpl$$t = /* @__PURE__ */ template$1(`<div>`);\nconst clickOutside = clickOutside$1;\nconst keyPressed = escPressed;\nconst androidBackHandler = androidBackHandler$1;\nconst Modal = (props) => {\n  const theme = useTheme();\n  const dataAttrs = useDataAttributes(props);\n  createEffect(() => {\n    if (props.opened) {\n      disableScroll();\n    } else {\n      enableScroll();\n    }\n  });\n  return createComponent(Transition, {\n    onBeforeEnter: (el) => {\n      const duration = isDevice(\"mobile\") ? 200 : 100;\n      animate(el, [{\n        opacity: 0\n      }, {\n        opacity: 1\n      }], {\n        duration\n      });\n      if (isDevice(\"mobile\")) {\n        animate(el.firstElementChild, [{\n          transform: \"translateY(390px)\"\n        }, {\n          transform: \"translateY(0)\"\n        }], {\n          duration\n        });\n      }\n    },\n    onExit: (el, done) => {\n      const duration = isDevice(\"mobile\") ? 200 : 100;\n      const backgroundAnimation = animate(el, [{\n        opacity: 1\n      }, {\n        opacity: 0\n      }], {\n        duration\n      });\n      if (isDevice(\"mobile\")) {\n        const contentAnimation = animate(el.firstElementChild, [{\n          transform: \"translateY(0)\"\n        }, {\n          transform: \"translateY(390px)\"\n        }], {\n          duration\n        });\n        Promise.all([backgroundAnimation.finished, contentAnimation.finished]).then(done);\n      } else {\n        backgroundAnimation.finished.then(done);\n      }\n    },\n    get children() {\n      return createComponent(Show, {\n        get when() {\n          return props.opened;\n        },\n        get children() {\n          return createComponent(ModalBackgroundStyled, mergeProps({\n            \"data-tc-modal\": \"true\"\n          }, dataAttrs, {\n            get children() {\n              var _el$ = _tmpl$$t();\n              use(androidBackHandler, _el$, () => ({\n                isEnabled: props.enableAndroidBackHandler,\n                onClose: () => props.onClose()\n              }));\n              use(keyPressed, _el$, () => () => props.onClose());\n              use(clickOutside, _el$, () => () => props.onClose());\n              insert(_el$, createComponent(ModalBodyStyled, {\n                get [\"class\"]() {\n                  return props.class;\n                },\n                get children() {\n                  return [createComponent(CloseButtonStyled, {\n                    icon: \"close\",\n                    onClick: () => props.onClose()\n                  }), memo(() => props.children)];\n                }\n              }), null);\n              insert(_el$, createComponent(Show, {\n                get when() {\n                  return props.onClickQuestion && props.showFooter;\n                },\n                get children() {\n                  return createComponent(ModalFooterStyled, {\n                    get children() {\n                      return [createComponent(TonConnectBrand, {}), createComponent(QuestionButtonStyled, {\n                        get onClick() {\n                          return props.onClickQuestion;\n                        },\n                        icon: \"question\"\n                      })];\n                    }\n                  });\n                }\n              }), null);\n              createRenderEffect(() => className(_el$, classnames__WEBPACK_IMPORTED_MODULE_3__(ModalWrapperClass, u`\n                                border-radius: ${borders$5[theme.borderRadius]};\n                                background-color: ${theme.colors.background.tint};\n\n                                ${media(\"mobile\")} {\n                                    border-radius: ${borders$5[theme.borderRadius]}\n                                        ${borders$5[theme.borderRadius]} 0 0;\n                                }\n                            `)));\n              return _el$;\n            }\n          }));\n        }\n      });\n    }\n  });\n};\nconst wrapperBorderRadius = {\n  m: \"22px\",\n  s: \"12px\",\n  none: \"0\"\n};\nconst sliderBorderRadius = {\n  m: \"18px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst TabBarStyled = styled.div`\n    display: grid;\n    grid-template: 1fr / 1fr 1fr;\n    width: fit-content;\n    justify-items: center;\n    gap: 4px;\n\n    position: relative;\n    padding: 4px;\n    border-radius: ${(props) => wrapperBorderRadius[props.theme.borderRadius]};\n\n    background-color: ${(props) => props.theme.colors.background.secondary};\n`;\nconst SliderStyled = styled.div`\n    position: absolute;\n    top: 4px;\n    left: 4px;\n\n    height: calc(100% - 8px);\n    width: calc(50% - 4px);\n\n    border-radius: ${(props) => sliderBorderRadius[props.theme.borderRadius]};\n    background-color: ${(props) => props.theme.colors.background.segment};\n\n    transform: ${(props) => props.right ? \"translateX(100%)\" : \"translateX(0)\"};\n\n    transition: transform 0.13s ease-in-out;\n`;\nconst InputStyled = styled.input`\n    display: none;\n`;\nconst LabelStyled = styled.label`\n    padding: 9px 12px;\n    z-index: 1;\n\n    cursor: ${(props) => props.isActive ? \"default\" : \"pointer\"};\n\n    transition: transform 0.13s ease-in-out;\n\n    &:hover {\n        transform: ${(props) => props.isActive ? \"none\" : \"scale(1.025)\"};\n    }\n\n    > * {\n        ${(props) => !props.isActive ? `color: ${props.theme.colors.text.secondary};` : \"\"}\n    }\n`;\nconst TabBar = (props) => {\n  const groupName = \"tabBar\" + Math.floor(Math.random() * 1e4);\n  return createComponent(TabBarStyled, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-tab-bar\": \"true\",\n    get children() {\n      return [createComponent(SliderStyled, {\n        get right() {\n          return props.selectedTabIndex === 1;\n        }\n      }), createComponent(LabelStyled, {\n        get isActive() {\n          return props.selectedTabIndex === 0;\n        },\n        get children() {\n          return [createComponent(InputStyled, {\n            type: \"radio\",\n            name: groupName,\n            get checked() {\n              return props.selectedTabIndex === 0;\n            },\n            onInput: () => {\n              var _a2;\n              return (_a2 = props.onSelectedTabIndexChange) == null ? void 0 : _a2.call(props, 0);\n            }\n          }), memo(() => props.tab1)];\n        }\n      }), createComponent(LabelStyled, {\n        get isActive() {\n          return props.selectedTabIndex === 1;\n        },\n        get children() {\n          return [createComponent(InputStyled, {\n            type: \"radio\",\n            get checked() {\n              return props.selectedTabIndex === 1;\n            },\n            name: groupName,\n            onInput: () => {\n              var _a2;\n              return (_a2 = props.onSelectedTabIndexChange) == null ? void 0 : _a2.call(props, 1);\n            }\n          }), memo(() => props.tab2)];\n        }\n      })];\n    }\n  });\n};\nconst backgroundBorders = {\n  m: \"16px\",\n  s: \"12px\",\n  none: \"0\"\n};\nconst imageBorders = {\n  m: \"12px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst qrNormalSize = 256;\nconst imgSizeDefault = 60;\nconst picSizeDefault = 48;\nconst qrPaddingTop = 24;\nconst CopyIconButton = styled.div`\n    width: 52px;\n    height: 52px;\n    background: transparent;\n    position: absolute;\n    right: 0;\n    bottom: 0;\n\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    transition: transform 0.125s ease-in-out;\n`;\nconst QrCodeBackground = styled.button`\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    position: relative;\n    background-color: ${(props) => props.theme.colors.background.qr};\n    border-radius: ${(props) => backgroundBorders[props.theme.borderRadius]};\n    padding: ${toPx(qrPaddingTop)} 0;\n    height: ${toPx(qrNormalSize + qrPaddingTop * 2)};\n    width: 100%;\n\n    overflow: hidden;\n    cursor: pointer;\n    border: none;\n\n    ${mediaNotTouch} {\n        &:hover {\n            ${CopyIconButton.class} {\n                transform: scale(1.04);\n            }\n        }\n    }\n\n    &:active {\n        ${CopyIconButton.class} {\n            transform: scale(0.96);\n        }\n    }\n\n    ${mediaTouch} {\n        &:active {\n            ${CopyIconButton.class} {\n                transform: scale(0.92);\n            }\n        }\n    }\n`;\nconst QrCodeWrapper$2 = styled.div`\n    position: relative;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    margin: 0 auto;\n\n    > div:first-child {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n\n    rect {\n        fill: transparent;\n    }\n\n    path {\n        fill: ${(props) => props.theme.colors.constant.black};\n    }\n`;\nconst ImageBackground = styled.div`\n    position: absolute;\n    width: ${toPx(imgSizeDefault)};\n    height: ${toPx(imgSizeDefault)};\n    background: ${(props) => props.theme.colors.background.qr};\n\n    display: flex;\n    align-items: center;\n    justify-content: center;\n`;\nconst ImageStyled$3 = styled(Image)`\n    width: ${(props) => toPx(props.size)};\n    height: ${(props) => toPx(props.size)};\n    border-radius: ${(props) => imageBorders[props.theme.borderRadius]};\n    background-color: ${(props) => props.theme.colors.background.qr};\n`;\nconst CopiedBoxStyled = styled.div`\n    position: absolute;\n    bottom: 14px;\n    left: 50%;\n    transform: translate(-50%, 0);\n\n    display: flex;\n    gap: 6px;\n    align-items: center;\n    border-radius: 18px;\n    min-width: 126px;\n    padding: 9px 16px 9px 10px;\n\n    filter: drop-shadow(0px 2px 8px rgba(0, 0, 0, 0.08));\n    background-color: ${(props) => props.theme.colors.background.segment};\n`;\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar qrcode$1 = { exports: {} };\nvar hasRequiredQrcode;\nfunction requireQrcode() {\n  if (hasRequiredQrcode) return qrcode$1.exports;\n  hasRequiredQrcode = 1;\n  (function(module, exports) {\n    var qrcode2 = function() {\n      var qrcode3 = function(typeNumber, errorCorrectionLevel) {\n        var PAD0 = 236;\n        var PAD1 = 17;\n        var _typeNumber = typeNumber;\n        var _errorCorrectionLevel = QRErrorCorrectionLevel[errorCorrectionLevel];\n        var _modules = null;\n        var _moduleCount = 0;\n        var _dataCache = null;\n        var _dataList = [];\n        var _this = {};\n        var makeImpl = function(test, maskPattern) {\n          _moduleCount = _typeNumber * 4 + 17;\n          _modules = function(moduleCount) {\n            var modules = new Array(moduleCount);\n            for (var row = 0; row < moduleCount; row += 1) {\n              modules[row] = new Array(moduleCount);\n              for (var col = 0; col < moduleCount; col += 1) {\n                modules[row][col] = null;\n              }\n            }\n            return modules;\n          }(_moduleCount);\n          setupPositionProbePattern(0, 0);\n          setupPositionProbePattern(_moduleCount - 7, 0);\n          setupPositionProbePattern(0, _moduleCount - 7);\n          setupPositionAdjustPattern();\n          setupTimingPattern();\n          setupTypeInfo(test, maskPattern);\n          if (_typeNumber >= 7) {\n            setupTypeNumber(test);\n          }\n          if (_dataCache == null) {\n            _dataCache = createData(_typeNumber, _errorCorrectionLevel, _dataList);\n          }\n          mapData(_dataCache, maskPattern);\n        };\n        var setupPositionProbePattern = function(row, col) {\n          for (var r = -1; r <= 7; r += 1) {\n            if (row + r <= -1 || _moduleCount <= row + r) continue;\n            for (var c2 = -1; c2 <= 7; c2 += 1) {\n              if (col + c2 <= -1 || _moduleCount <= col + c2) continue;\n              if (0 <= r && r <= 6 && (c2 == 0 || c2 == 6) || 0 <= c2 && c2 <= 6 && (r == 0 || r == 6) || 2 <= r && r <= 4 && 2 <= c2 && c2 <= 4) {\n                _modules[row + r][col + c2] = true;\n              } else {\n                _modules[row + r][col + c2] = false;\n              }\n            }\n          }\n        };\n        var getBestMaskPattern = function() {\n          var minLostPoint = 0;\n          var pattern = 0;\n          for (var i2 = 0; i2 < 8; i2 += 1) {\n            makeImpl(true, i2);\n            var lostPoint = QRUtil.getLostPoint(_this);\n            if (i2 == 0 || minLostPoint > lostPoint) {\n              minLostPoint = lostPoint;\n              pattern = i2;\n            }\n          }\n          return pattern;\n        };\n        var setupTimingPattern = function() {\n          for (var r = 8; r < _moduleCount - 8; r += 1) {\n            if (_modules[r][6] != null) {\n              continue;\n            }\n            _modules[r][6] = r % 2 == 0;\n          }\n          for (var c2 = 8; c2 < _moduleCount - 8; c2 += 1) {\n            if (_modules[6][c2] != null) {\n              continue;\n            }\n            _modules[6][c2] = c2 % 2 == 0;\n          }\n        };\n        var setupPositionAdjustPattern = function() {\n          var pos = QRUtil.getPatternPosition(_typeNumber);\n          for (var i2 = 0; i2 < pos.length; i2 += 1) {\n            for (var j = 0; j < pos.length; j += 1) {\n              var row = pos[i2];\n              var col = pos[j];\n              if (_modules[row][col] != null) {\n                continue;\n              }\n              for (var r = -2; r <= 2; r += 1) {\n                for (var c2 = -2; c2 <= 2; c2 += 1) {\n                  if (r == -2 || r == 2 || c2 == -2 || c2 == 2 || r == 0 && c2 == 0) {\n                    _modules[row + r][col + c2] = true;\n                  } else {\n                    _modules[row + r][col + c2] = false;\n                  }\n                }\n              }\n            }\n          }\n        };\n        var setupTypeNumber = function(test) {\n          var bits = QRUtil.getBCHTypeNumber(_typeNumber);\n          for (var i2 = 0; i2 < 18; i2 += 1) {\n            var mod = !test && (bits >> i2 & 1) == 1;\n            _modules[Math.floor(i2 / 3)][i2 % 3 + _moduleCount - 8 - 3] = mod;\n          }\n          for (var i2 = 0; i2 < 18; i2 += 1) {\n            var mod = !test && (bits >> i2 & 1) == 1;\n            _modules[i2 % 3 + _moduleCount - 8 - 3][Math.floor(i2 / 3)] = mod;\n          }\n        };\n        var setupTypeInfo = function(test, maskPattern) {\n          var data = _errorCorrectionLevel << 3 | maskPattern;\n          var bits = QRUtil.getBCHTypeInfo(data);\n          for (var i2 = 0; i2 < 15; i2 += 1) {\n            var mod = !test && (bits >> i2 & 1) == 1;\n            if (i2 < 6) {\n              _modules[i2][8] = mod;\n            } else if (i2 < 8) {\n              _modules[i2 + 1][8] = mod;\n            } else {\n              _modules[_moduleCount - 15 + i2][8] = mod;\n            }\n          }\n          for (var i2 = 0; i2 < 15; i2 += 1) {\n            var mod = !test && (bits >> i2 & 1) == 1;\n            if (i2 < 8) {\n              _modules[8][_moduleCount - i2 - 1] = mod;\n            } else if (i2 < 9) {\n              _modules[8][15 - i2 - 1 + 1] = mod;\n            } else {\n              _modules[8][15 - i2 - 1] = mod;\n            }\n          }\n          _modules[_moduleCount - 8][8] = !test;\n        };\n        var mapData = function(data, maskPattern) {\n          var inc = -1;\n          var row = _moduleCount - 1;\n          var bitIndex = 7;\n          var byteIndex = 0;\n          var maskFunc = QRUtil.getMaskFunction(maskPattern);\n          for (var col = _moduleCount - 1; col > 0; col -= 2) {\n            if (col == 6) col -= 1;\n            while (true) {\n              for (var c2 = 0; c2 < 2; c2 += 1) {\n                if (_modules[row][col - c2] == null) {\n                  var dark = false;\n                  if (byteIndex < data.length) {\n                    dark = (data[byteIndex] >>> bitIndex & 1) == 1;\n                  }\n                  var mask = maskFunc(row, col - c2);\n                  if (mask) {\n                    dark = !dark;\n                  }\n                  _modules[row][col - c2] = dark;\n                  bitIndex -= 1;\n                  if (bitIndex == -1) {\n                    byteIndex += 1;\n                    bitIndex = 7;\n                  }\n                }\n              }\n              row += inc;\n              if (row < 0 || _moduleCount <= row) {\n                row -= inc;\n                inc = -inc;\n                break;\n              }\n            }\n          }\n        };\n        var createBytes = function(buffer, rsBlocks) {\n          var offset = 0;\n          var maxDcCount = 0;\n          var maxEcCount = 0;\n          var dcdata = new Array(rsBlocks.length);\n          var ecdata = new Array(rsBlocks.length);\n          for (var r = 0; r < rsBlocks.length; r += 1) {\n            var dcCount = rsBlocks[r].dataCount;\n            var ecCount = rsBlocks[r].totalCount - dcCount;\n            maxDcCount = Math.max(maxDcCount, dcCount);\n            maxEcCount = Math.max(maxEcCount, ecCount);\n            dcdata[r] = new Array(dcCount);\n            for (var i2 = 0; i2 < dcdata[r].length; i2 += 1) {\n              dcdata[r][i2] = 255 & buffer.getBuffer()[i2 + offset];\n            }\n            offset += dcCount;\n            var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);\n            var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);\n            var modPoly = rawPoly.mod(rsPoly);\n            ecdata[r] = new Array(rsPoly.getLength() - 1);\n            for (var i2 = 0; i2 < ecdata[r].length; i2 += 1) {\n              var modIndex = i2 + modPoly.getLength() - ecdata[r].length;\n              ecdata[r][i2] = modIndex >= 0 ? modPoly.getAt(modIndex) : 0;\n            }\n          }\n          var totalCodeCount = 0;\n          for (var i2 = 0; i2 < rsBlocks.length; i2 += 1) {\n            totalCodeCount += rsBlocks[i2].totalCount;\n          }\n          var data = new Array(totalCodeCount);\n          var index = 0;\n          for (var i2 = 0; i2 < maxDcCount; i2 += 1) {\n            for (var r = 0; r < rsBlocks.length; r += 1) {\n              if (i2 < dcdata[r].length) {\n                data[index] = dcdata[r][i2];\n                index += 1;\n              }\n            }\n          }\n          for (var i2 = 0; i2 < maxEcCount; i2 += 1) {\n            for (var r = 0; r < rsBlocks.length; r += 1) {\n              if (i2 < ecdata[r].length) {\n                data[index] = ecdata[r][i2];\n                index += 1;\n              }\n            }\n          }\n          return data;\n        };\n        var createData = function(typeNumber2, errorCorrectionLevel2, dataList) {\n          var rsBlocks = QRRSBlock.getRSBlocks(typeNumber2, errorCorrectionLevel2);\n          var buffer = qrBitBuffer();\n          for (var i2 = 0; i2 < dataList.length; i2 += 1) {\n            var data = dataList[i2];\n            buffer.put(data.getMode(), 4);\n            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber2));\n            data.write(buffer);\n          }\n          var totalDataCount = 0;\n          for (var i2 = 0; i2 < rsBlocks.length; i2 += 1) {\n            totalDataCount += rsBlocks[i2].dataCount;\n          }\n          if (buffer.getLengthInBits() > totalDataCount * 8) {\n            throw \"code length overflow. (\" + buffer.getLengthInBits() + \">\" + totalDataCount * 8 + \")\";\n          }\n          if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {\n            buffer.put(0, 4);\n          }\n          while (buffer.getLengthInBits() % 8 != 0) {\n            buffer.putBit(false);\n          }\n          while (true) {\n            if (buffer.getLengthInBits() >= totalDataCount * 8) {\n              break;\n            }\n            buffer.put(PAD0, 8);\n            if (buffer.getLengthInBits() >= totalDataCount * 8) {\n              break;\n            }\n            buffer.put(PAD1, 8);\n          }\n          return createBytes(buffer, rsBlocks);\n        };\n        _this.addData = function(data, mode) {\n          mode = mode || \"Byte\";\n          var newData = null;\n          switch (mode) {\n            case \"Numeric\":\n              newData = qrNumber(data);\n              break;\n            case \"Alphanumeric\":\n              newData = qrAlphaNum(data);\n              break;\n            case \"Byte\":\n              newData = qr8BitByte(data);\n              break;\n            case \"Kanji\":\n              newData = qrKanji(data);\n              break;\n            default:\n              throw \"mode:\" + mode;\n          }\n          _dataList.push(newData);\n          _dataCache = null;\n        };\n        _this.isDark = function(row, col) {\n          if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {\n            throw row + \",\" + col;\n          }\n          return _modules[row][col];\n        };\n        _this.getModuleCount = function() {\n          return _moduleCount;\n        };\n        _this.make = function() {\n          if (_typeNumber < 1) {\n            var typeNumber2 = 1;\n            for (; typeNumber2 < 40; typeNumber2++) {\n              var rsBlocks = QRRSBlock.getRSBlocks(typeNumber2, _errorCorrectionLevel);\n              var buffer = qrBitBuffer();\n              for (var i2 = 0; i2 < _dataList.length; i2++) {\n                var data = _dataList[i2];\n                buffer.put(data.getMode(), 4);\n                buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber2));\n                data.write(buffer);\n              }\n              var totalDataCount = 0;\n              for (var i2 = 0; i2 < rsBlocks.length; i2++) {\n                totalDataCount += rsBlocks[i2].dataCount;\n              }\n              if (buffer.getLengthInBits() <= totalDataCount * 8) {\n                break;\n              }\n            }\n            _typeNumber = typeNumber2;\n          }\n          makeImpl(false, getBestMaskPattern());\n        };\n        _this.createTableTag = function(cellSize, margin) {\n          cellSize = cellSize || 2;\n          margin = typeof margin == \"undefined\" ? cellSize * 4 : margin;\n          var qrHtml = \"\";\n          qrHtml += '<table style=\"';\n          qrHtml += \" border-width: 0px; border-style: none;\";\n          qrHtml += \" border-collapse: collapse;\";\n          qrHtml += \" padding: 0px; margin: \" + margin + \"px;\";\n          qrHtml += '\">';\n          qrHtml += \"<tbody>\";\n          for (var r = 0; r < _this.getModuleCount(); r += 1) {\n            qrHtml += \"<tr>\";\n            for (var c2 = 0; c2 < _this.getModuleCount(); c2 += 1) {\n              qrHtml += '<td style=\"';\n              qrHtml += \" border-width: 0px; border-style: none;\";\n              qrHtml += \" border-collapse: collapse;\";\n              qrHtml += \" padding: 0px; margin: 0px;\";\n              qrHtml += \" width: \" + cellSize + \"px;\";\n              qrHtml += \" height: \" + cellSize + \"px;\";\n              qrHtml += \" background-color: \";\n              qrHtml += _this.isDark(r, c2) ? \"#000000\" : \"#ffffff\";\n              qrHtml += \";\";\n              qrHtml += '\"/>';\n            }\n            qrHtml += \"</tr>\";\n          }\n          qrHtml += \"</tbody>\";\n          qrHtml += \"</table>\";\n          return qrHtml;\n        };\n        _this.createSvgTag = function(cellSize, margin, alt, title) {\n          var opts = {};\n          if (typeof arguments[0] == \"object\") {\n            opts = arguments[0];\n            cellSize = opts.cellSize;\n            margin = opts.margin;\n            alt = opts.alt;\n            title = opts.title;\n          }\n          cellSize = cellSize || 2;\n          margin = typeof margin == \"undefined\" ? cellSize * 4 : margin;\n          alt = typeof alt === \"string\" ? { text: alt } : alt || {};\n          alt.text = alt.text || null;\n          alt.id = alt.text ? alt.id || \"qrcode-description\" : null;\n          title = typeof title === \"string\" ? { text: title } : title || {};\n          title.text = title.text || null;\n          title.id = title.text ? title.id || \"qrcode-title\" : null;\n          var size = _this.getModuleCount() * cellSize + margin * 2;\n          var c2, mc, r, mr, qrSvg = \"\", rect;\n          rect = \"l\" + cellSize + \",0 0,\" + cellSize + \" -\" + cellSize + \",0 0,-\" + cellSize + \"z \";\n          qrSvg += '<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"';\n          qrSvg += !opts.scalable ? ' width=\"' + size + 'px\" height=\"' + size + 'px\"' : \"\";\n          qrSvg += ' viewBox=\"0 0 ' + size + \" \" + size + '\" ';\n          qrSvg += ' preserveAspectRatio=\"xMinYMin meet\"';\n          qrSvg += title.text || alt.text ? ' role=\"img\" aria-labelledby=\"' + escapeXml([title.id, alt.id].join(\" \").trim()) + '\"' : \"\";\n          qrSvg += \">\";\n          qrSvg += title.text ? '<title id=\"' + escapeXml(title.id) + '\">' + escapeXml(title.text) + \"</title>\" : \"\";\n          qrSvg += alt.text ? '<description id=\"' + escapeXml(alt.id) + '\">' + escapeXml(alt.text) + \"</description>\" : \"\";\n          qrSvg += '<rect width=\"100%\" height=\"100%\" fill=\"white\" cx=\"0\" cy=\"0\"/>';\n          qrSvg += '<path d=\"';\n          for (r = 0; r < _this.getModuleCount(); r += 1) {\n            mr = r * cellSize + margin;\n            for (c2 = 0; c2 < _this.getModuleCount(); c2 += 1) {\n              if (_this.isDark(r, c2)) {\n                mc = c2 * cellSize + margin;\n                qrSvg += \"M\" + mc + \",\" + mr + rect;\n              }\n            }\n          }\n          qrSvg += '\" stroke=\"transparent\" fill=\"black\"/>';\n          qrSvg += \"</svg>\";\n          return qrSvg;\n        };\n        _this.createDataURL = function(cellSize, margin) {\n          cellSize = cellSize || 2;\n          margin = typeof margin == \"undefined\" ? cellSize * 4 : margin;\n          var size = _this.getModuleCount() * cellSize + margin * 2;\n          var min2 = margin;\n          var max2 = size - margin;\n          return createDataURL(size, size, function(x, y) {\n            if (min2 <= x && x < max2 && min2 <= y && y < max2) {\n              var c2 = Math.floor((x - min2) / cellSize);\n              var r = Math.floor((y - min2) / cellSize);\n              return _this.isDark(r, c2) ? 0 : 1;\n            } else {\n              return 1;\n            }\n          });\n        };\n        _this.createImgTag = function(cellSize, margin, alt) {\n          cellSize = cellSize || 2;\n          margin = typeof margin == \"undefined\" ? cellSize * 4 : margin;\n          var size = _this.getModuleCount() * cellSize + margin * 2;\n          var img = \"\";\n          img += \"<img\";\n          img += ' src=\"';\n          img += _this.createDataURL(cellSize, margin);\n          img += '\"';\n          img += ' width=\"';\n          img += size;\n          img += '\"';\n          img += ' height=\"';\n          img += size;\n          img += '\"';\n          if (alt) {\n            img += ' alt=\"';\n            img += escapeXml(alt);\n            img += '\"';\n          }\n          img += \"/>\";\n          return img;\n        };\n        var escapeXml = function(s2) {\n          var escaped = \"\";\n          for (var i2 = 0; i2 < s2.length; i2 += 1) {\n            var c2 = s2.charAt(i2);\n            switch (c2) {\n              case \"<\":\n                escaped += \"&lt;\";\n                break;\n              case \">\":\n                escaped += \"&gt;\";\n                break;\n              case \"&\":\n                escaped += \"&amp;\";\n                break;\n              case '\"':\n                escaped += \"&quot;\";\n                break;\n              default:\n                escaped += c2;\n                break;\n            }\n          }\n          return escaped;\n        };\n        var _createHalfASCII = function(margin) {\n          var cellSize = 1;\n          margin = typeof margin == \"undefined\" ? cellSize * 2 : margin;\n          var size = _this.getModuleCount() * cellSize + margin * 2;\n          var min2 = margin;\n          var max2 = size - margin;\n          var y, x, r1, r2, p2;\n          var blocks = {\n            \"\": \"\",\n            \" \": \"\",\n            \" \": \"\",\n            \"  \": \" \"\n          };\n          var blocksLastLineNoMargin = {\n            \"\": \"\",\n            \" \": \"\",\n            \" \": \" \",\n            \"  \": \" \"\n          };\n          var ascii = \"\";\n          for (y = 0; y < size; y += 2) {\n            r1 = Math.floor((y - min2) / cellSize);\n            r2 = Math.floor((y + 1 - min2) / cellSize);\n            for (x = 0; x < size; x += 1) {\n              p2 = \"\";\n              if (min2 <= x && x < max2 && min2 <= y && y < max2 && _this.isDark(r1, Math.floor((x - min2) / cellSize))) {\n                p2 = \" \";\n              }\n              if (min2 <= x && x < max2 && min2 <= y + 1 && y + 1 < max2 && _this.isDark(r2, Math.floor((x - min2) / cellSize))) {\n                p2 += \" \";\n              } else {\n                p2 += \"\";\n              }\n              ascii += margin < 1 && y + 1 >= max2 ? blocksLastLineNoMargin[p2] : blocks[p2];\n            }\n            ascii += \"\\n\";\n          }\n          if (size % 2 && margin > 0) {\n            return ascii.substring(0, ascii.length - size - 1) + Array(size + 1).join(\"\");\n          }\n          return ascii.substring(0, ascii.length - 1);\n        };\n        _this.createASCII = function(cellSize, margin) {\n          cellSize = cellSize || 1;\n          if (cellSize < 2) {\n            return _createHalfASCII(margin);\n          }\n          cellSize -= 1;\n          margin = typeof margin == \"undefined\" ? cellSize * 2 : margin;\n          var size = _this.getModuleCount() * cellSize + margin * 2;\n          var min2 = margin;\n          var max2 = size - margin;\n          var y, x, r, p2;\n          var white = Array(cellSize + 1).join(\"\");\n          var black = Array(cellSize + 1).join(\"  \");\n          var ascii = \"\";\n          var line = \"\";\n          for (y = 0; y < size; y += 1) {\n            r = Math.floor((y - min2) / cellSize);\n            line = \"\";\n            for (x = 0; x < size; x += 1) {\n              p2 = 1;\n              if (min2 <= x && x < max2 && min2 <= y && y < max2 && _this.isDark(r, Math.floor((x - min2) / cellSize))) {\n                p2 = 0;\n              }\n              line += p2 ? white : black;\n            }\n            for (r = 0; r < cellSize; r += 1) {\n              ascii += line + \"\\n\";\n            }\n          }\n          return ascii.substring(0, ascii.length - 1);\n        };\n        _this.renderTo2dContext = function(context, cellSize) {\n          cellSize = cellSize || 2;\n          var length = _this.getModuleCount();\n          for (var row = 0; row < length; row++) {\n            for (var col = 0; col < length; col++) {\n              context.fillStyle = _this.isDark(row, col) ? \"black\" : \"white\";\n              context.fillRect(row * cellSize, col * cellSize, cellSize, cellSize);\n            }\n          }\n        };\n        return _this;\n      };\n      qrcode3.stringToBytesFuncs = {\n        \"default\": function(s2) {\n          var bytes = [];\n          for (var i2 = 0; i2 < s2.length; i2 += 1) {\n            var c2 = s2.charCodeAt(i2);\n            bytes.push(c2 & 255);\n          }\n          return bytes;\n        }\n      };\n      qrcode3.stringToBytes = qrcode3.stringToBytesFuncs[\"default\"];\n      qrcode3.createStringToBytes = function(unicodeData, numChars) {\n        var unicodeMap = function() {\n          var bin = base64DecodeInputStream(unicodeData);\n          var read = function() {\n            var b = bin.read();\n            if (b == -1) throw \"eof\";\n            return b;\n          };\n          var count = 0;\n          var unicodeMap2 = {};\n          while (true) {\n            var b0 = bin.read();\n            if (b0 == -1) break;\n            var b1 = read();\n            var b2 = read();\n            var b3 = read();\n            var k = String.fromCharCode(b0 << 8 | b1);\n            var v = b2 << 8 | b3;\n            unicodeMap2[k] = v;\n            count += 1;\n          }\n          if (count != numChars) {\n            throw count + \" != \" + numChars;\n          }\n          return unicodeMap2;\n        }();\n        var unknownChar = \"?\".charCodeAt(0);\n        return function(s2) {\n          var bytes = [];\n          for (var i2 = 0; i2 < s2.length; i2 += 1) {\n            var c2 = s2.charCodeAt(i2);\n            if (c2 < 128) {\n              bytes.push(c2);\n            } else {\n              var b = unicodeMap[s2.charAt(i2)];\n              if (typeof b == \"number\") {\n                if ((b & 255) == b) {\n                  bytes.push(b);\n                } else {\n                  bytes.push(b >>> 8);\n                  bytes.push(b & 255);\n                }\n              } else {\n                bytes.push(unknownChar);\n              }\n            }\n          }\n          return bytes;\n        };\n      };\n      var QRMode = {\n        MODE_NUMBER: 1 << 0,\n        MODE_ALPHA_NUM: 1 << 1,\n        MODE_8BIT_BYTE: 1 << 2,\n        MODE_KANJI: 1 << 3\n      };\n      var QRErrorCorrectionLevel = {\n        L: 1,\n        M: 0,\n        Q: 3,\n        H: 2\n      };\n      var QRMaskPattern = {\n        PATTERN000: 0,\n        PATTERN001: 1,\n        PATTERN010: 2,\n        PATTERN011: 3,\n        PATTERN100: 4,\n        PATTERN101: 5,\n        PATTERN110: 6,\n        PATTERN111: 7\n      };\n      var QRUtil = function() {\n        var PATTERN_POSITION_TABLE = [\n          [],\n          [6, 18],\n          [6, 22],\n          [6, 26],\n          [6, 30],\n          [6, 34],\n          [6, 22, 38],\n          [6, 24, 42],\n          [6, 26, 46],\n          [6, 28, 50],\n          [6, 30, 54],\n          [6, 32, 58],\n          [6, 34, 62],\n          [6, 26, 46, 66],\n          [6, 26, 48, 70],\n          [6, 26, 50, 74],\n          [6, 30, 54, 78],\n          [6, 30, 56, 82],\n          [6, 30, 58, 86],\n          [6, 34, 62, 90],\n          [6, 28, 50, 72, 94],\n          [6, 26, 50, 74, 98],\n          [6, 30, 54, 78, 102],\n          [6, 28, 54, 80, 106],\n          [6, 32, 58, 84, 110],\n          [6, 30, 58, 86, 114],\n          [6, 34, 62, 90, 118],\n          [6, 26, 50, 74, 98, 122],\n          [6, 30, 54, 78, 102, 126],\n          [6, 26, 52, 78, 104, 130],\n          [6, 30, 56, 82, 108, 134],\n          [6, 34, 60, 86, 112, 138],\n          [6, 30, 58, 86, 114, 142],\n          [6, 34, 62, 90, 118, 146],\n          [6, 30, 54, 78, 102, 126, 150],\n          [6, 24, 50, 76, 102, 128, 154],\n          [6, 28, 54, 80, 106, 132, 158],\n          [6, 32, 58, 84, 110, 136, 162],\n          [6, 26, 54, 82, 110, 138, 166],\n          [6, 30, 58, 86, 114, 142, 170]\n        ];\n        var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;\n        var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;\n        var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;\n        var _this = {};\n        var getBCHDigit = function(data) {\n          var digit = 0;\n          while (data != 0) {\n            digit += 1;\n            data >>>= 1;\n          }\n          return digit;\n        };\n        _this.getBCHTypeInfo = function(data) {\n          var d = data << 10;\n          while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {\n            d ^= G15 << getBCHDigit(d) - getBCHDigit(G15);\n          }\n          return (data << 10 | d) ^ G15_MASK;\n        };\n        _this.getBCHTypeNumber = function(data) {\n          var d = data << 12;\n          while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {\n            d ^= G18 << getBCHDigit(d) - getBCHDigit(G18);\n          }\n          return data << 12 | d;\n        };\n        _this.getPatternPosition = function(typeNumber) {\n          return PATTERN_POSITION_TABLE[typeNumber - 1];\n        };\n        _this.getMaskFunction = function(maskPattern) {\n          switch (maskPattern) {\n            case QRMaskPattern.PATTERN000:\n              return function(i2, j) {\n                return (i2 + j) % 2 == 0;\n              };\n            case QRMaskPattern.PATTERN001:\n              return function(i2, j) {\n                return i2 % 2 == 0;\n              };\n            case QRMaskPattern.PATTERN010:\n              return function(i2, j) {\n                return j % 3 == 0;\n              };\n            case QRMaskPattern.PATTERN011:\n              return function(i2, j) {\n                return (i2 + j) % 3 == 0;\n              };\n            case QRMaskPattern.PATTERN100:\n              return function(i2, j) {\n                return (Math.floor(i2 / 2) + Math.floor(j / 3)) % 2 == 0;\n              };\n            case QRMaskPattern.PATTERN101:\n              return function(i2, j) {\n                return i2 * j % 2 + i2 * j % 3 == 0;\n              };\n            case QRMaskPattern.PATTERN110:\n              return function(i2, j) {\n                return (i2 * j % 2 + i2 * j % 3) % 2 == 0;\n              };\n            case QRMaskPattern.PATTERN111:\n              return function(i2, j) {\n                return (i2 * j % 3 + (i2 + j) % 2) % 2 == 0;\n              };\n            default:\n              throw \"bad maskPattern:\" + maskPattern;\n          }\n        };\n        _this.getErrorCorrectPolynomial = function(errorCorrectLength) {\n          var a2 = qrPolynomial([1], 0);\n          for (var i2 = 0; i2 < errorCorrectLength; i2 += 1) {\n            a2 = a2.multiply(qrPolynomial([1, QRMath.gexp(i2)], 0));\n          }\n          return a2;\n        };\n        _this.getLengthInBits = function(mode, type) {\n          if (1 <= type && type < 10) {\n            switch (mode) {\n              case QRMode.MODE_NUMBER:\n                return 10;\n              case QRMode.MODE_ALPHA_NUM:\n                return 9;\n              case QRMode.MODE_8BIT_BYTE:\n                return 8;\n              case QRMode.MODE_KANJI:\n                return 8;\n              default:\n                throw \"mode:\" + mode;\n            }\n          } else if (type < 27) {\n            switch (mode) {\n              case QRMode.MODE_NUMBER:\n                return 12;\n              case QRMode.MODE_ALPHA_NUM:\n                return 11;\n              case QRMode.MODE_8BIT_BYTE:\n                return 16;\n              case QRMode.MODE_KANJI:\n                return 10;\n              default:\n                throw \"mode:\" + mode;\n            }\n          } else if (type < 41) {\n            switch (mode) {\n              case QRMode.MODE_NUMBER:\n                return 14;\n              case QRMode.MODE_ALPHA_NUM:\n                return 13;\n              case QRMode.MODE_8BIT_BYTE:\n                return 16;\n              case QRMode.MODE_KANJI:\n                return 12;\n              default:\n                throw \"mode:\" + mode;\n            }\n          } else {\n            throw \"type:\" + type;\n          }\n        };\n        _this.getLostPoint = function(qrcode4) {\n          var moduleCount = qrcode4.getModuleCount();\n          var lostPoint = 0;\n          for (var row = 0; row < moduleCount; row += 1) {\n            for (var col = 0; col < moduleCount; col += 1) {\n              var sameCount = 0;\n              var dark = qrcode4.isDark(row, col);\n              for (var r = -1; r <= 1; r += 1) {\n                if (row + r < 0 || moduleCount <= row + r) {\n                  continue;\n                }\n                for (var c2 = -1; c2 <= 1; c2 += 1) {\n                  if (col + c2 < 0 || moduleCount <= col + c2) {\n                    continue;\n                  }\n                  if (r == 0 && c2 == 0) {\n                    continue;\n                  }\n                  if (dark == qrcode4.isDark(row + r, col + c2)) {\n                    sameCount += 1;\n                  }\n                }\n              }\n              if (sameCount > 5) {\n                lostPoint += 3 + sameCount - 5;\n              }\n            }\n          }\n          for (var row = 0; row < moduleCount - 1; row += 1) {\n            for (var col = 0; col < moduleCount - 1; col += 1) {\n              var count = 0;\n              if (qrcode4.isDark(row, col)) count += 1;\n              if (qrcode4.isDark(row + 1, col)) count += 1;\n              if (qrcode4.isDark(row, col + 1)) count += 1;\n              if (qrcode4.isDark(row + 1, col + 1)) count += 1;\n              if (count == 0 || count == 4) {\n                lostPoint += 3;\n              }\n            }\n          }\n          for (var row = 0; row < moduleCount; row += 1) {\n            for (var col = 0; col < moduleCount - 6; col += 1) {\n              if (qrcode4.isDark(row, col) && !qrcode4.isDark(row, col + 1) && qrcode4.isDark(row, col + 2) && qrcode4.isDark(row, col + 3) && qrcode4.isDark(row, col + 4) && !qrcode4.isDark(row, col + 5) && qrcode4.isDark(row, col + 6)) {\n                lostPoint += 40;\n              }\n            }\n          }\n          for (var col = 0; col < moduleCount; col += 1) {\n            for (var row = 0; row < moduleCount - 6; row += 1) {\n              if (qrcode4.isDark(row, col) && !qrcode4.isDark(row + 1, col) && qrcode4.isDark(row + 2, col) && qrcode4.isDark(row + 3, col) && qrcode4.isDark(row + 4, col) && !qrcode4.isDark(row + 5, col) && qrcode4.isDark(row + 6, col)) {\n                lostPoint += 40;\n              }\n            }\n          }\n          var darkCount = 0;\n          for (var col = 0; col < moduleCount; col += 1) {\n            for (var row = 0; row < moduleCount; row += 1) {\n              if (qrcode4.isDark(row, col)) {\n                darkCount += 1;\n              }\n            }\n          }\n          var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;\n          lostPoint += ratio * 10;\n          return lostPoint;\n        };\n        return _this;\n      }();\n      var QRMath = function() {\n        var EXP_TABLE = new Array(256);\n        var LOG_TABLE = new Array(256);\n        for (var i2 = 0; i2 < 8; i2 += 1) {\n          EXP_TABLE[i2] = 1 << i2;\n        }\n        for (var i2 = 8; i2 < 256; i2 += 1) {\n          EXP_TABLE[i2] = EXP_TABLE[i2 - 4] ^ EXP_TABLE[i2 - 5] ^ EXP_TABLE[i2 - 6] ^ EXP_TABLE[i2 - 8];\n        }\n        for (var i2 = 0; i2 < 255; i2 += 1) {\n          LOG_TABLE[EXP_TABLE[i2]] = i2;\n        }\n        var _this = {};\n        _this.glog = function(n2) {\n          if (n2 < 1) {\n            throw \"glog(\" + n2 + \")\";\n          }\n          return LOG_TABLE[n2];\n        };\n        _this.gexp = function(n2) {\n          while (n2 < 0) {\n            n2 += 255;\n          }\n          while (n2 >= 256) {\n            n2 -= 255;\n          }\n          return EXP_TABLE[n2];\n        };\n        return _this;\n      }();\n      function qrPolynomial(num, shift2) {\n        if (typeof num.length == \"undefined\") {\n          throw num.length + \"/\" + shift2;\n        }\n        var _num = function() {\n          var offset = 0;\n          while (offset < num.length && num[offset] == 0) {\n            offset += 1;\n          }\n          var _num2 = new Array(num.length - offset + shift2);\n          for (var i2 = 0; i2 < num.length - offset; i2 += 1) {\n            _num2[i2] = num[i2 + offset];\n          }\n          return _num2;\n        }();\n        var _this = {};\n        _this.getAt = function(index) {\n          return _num[index];\n        };\n        _this.getLength = function() {\n          return _num.length;\n        };\n        _this.multiply = function(e2) {\n          var num2 = new Array(_this.getLength() + e2.getLength() - 1);\n          for (var i2 = 0; i2 < _this.getLength(); i2 += 1) {\n            for (var j = 0; j < e2.getLength(); j += 1) {\n              num2[i2 + j] ^= QRMath.gexp(QRMath.glog(_this.getAt(i2)) + QRMath.glog(e2.getAt(j)));\n            }\n          }\n          return qrPolynomial(num2, 0);\n        };\n        _this.mod = function(e2) {\n          if (_this.getLength() - e2.getLength() < 0) {\n            return _this;\n          }\n          var ratio = QRMath.glog(_this.getAt(0)) - QRMath.glog(e2.getAt(0));\n          var num2 = new Array(_this.getLength());\n          for (var i2 = 0; i2 < _this.getLength(); i2 += 1) {\n            num2[i2] = _this.getAt(i2);\n          }\n          for (var i2 = 0; i2 < e2.getLength(); i2 += 1) {\n            num2[i2] ^= QRMath.gexp(QRMath.glog(e2.getAt(i2)) + ratio);\n          }\n          return qrPolynomial(num2, 0).mod(e2);\n        };\n        return _this;\n      }\n      var QRRSBlock = function() {\n        var RS_BLOCK_TABLE = [\n          // L\n          // M\n          // Q\n          // H\n          // 1\n          [1, 26, 19],\n          [1, 26, 16],\n          [1, 26, 13],\n          [1, 26, 9],\n          // 2\n          [1, 44, 34],\n          [1, 44, 28],\n          [1, 44, 22],\n          [1, 44, 16],\n          // 3\n          [1, 70, 55],\n          [1, 70, 44],\n          [2, 35, 17],\n          [2, 35, 13],\n          // 4\n          [1, 100, 80],\n          [2, 50, 32],\n          [2, 50, 24],\n          [4, 25, 9],\n          // 5\n          [1, 134, 108],\n          [2, 67, 43],\n          [2, 33, 15, 2, 34, 16],\n          [2, 33, 11, 2, 34, 12],\n          // 6\n          [2, 86, 68],\n          [4, 43, 27],\n          [4, 43, 19],\n          [4, 43, 15],\n          // 7\n          [2, 98, 78],\n          [4, 49, 31],\n          [2, 32, 14, 4, 33, 15],\n          [4, 39, 13, 1, 40, 14],\n          // 8\n          [2, 121, 97],\n          [2, 60, 38, 2, 61, 39],\n          [4, 40, 18, 2, 41, 19],\n          [4, 40, 14, 2, 41, 15],\n          // 9\n          [2, 146, 116],\n          [3, 58, 36, 2, 59, 37],\n          [4, 36, 16, 4, 37, 17],\n          [4, 36, 12, 4, 37, 13],\n          // 10\n          [2, 86, 68, 2, 87, 69],\n          [4, 69, 43, 1, 70, 44],\n          [6, 43, 19, 2, 44, 20],\n          [6, 43, 15, 2, 44, 16],\n          // 11\n          [4, 101, 81],\n          [1, 80, 50, 4, 81, 51],\n          [4, 50, 22, 4, 51, 23],\n          [3, 36, 12, 8, 37, 13],\n          // 12\n          [2, 116, 92, 2, 117, 93],\n          [6, 58, 36, 2, 59, 37],\n          [4, 46, 20, 6, 47, 21],\n          [7, 42, 14, 4, 43, 15],\n          // 13\n          [4, 133, 107],\n          [8, 59, 37, 1, 60, 38],\n          [8, 44, 20, 4, 45, 21],\n          [12, 33, 11, 4, 34, 12],\n          // 14\n          [3, 145, 115, 1, 146, 116],\n          [4, 64, 40, 5, 65, 41],\n          [11, 36, 16, 5, 37, 17],\n          [11, 36, 12, 5, 37, 13],\n          // 15\n          [5, 109, 87, 1, 110, 88],\n          [5, 65, 41, 5, 66, 42],\n          [5, 54, 24, 7, 55, 25],\n          [11, 36, 12, 7, 37, 13],\n          // 16\n          [5, 122, 98, 1, 123, 99],\n          [7, 73, 45, 3, 74, 46],\n          [15, 43, 19, 2, 44, 20],\n          [3, 45, 15, 13, 46, 16],\n          // 17\n          [1, 135, 107, 5, 136, 108],\n          [10, 74, 46, 1, 75, 47],\n          [1, 50, 22, 15, 51, 23],\n          [2, 42, 14, 17, 43, 15],\n          // 18\n          [5, 150, 120, 1, 151, 121],\n          [9, 69, 43, 4, 70, 44],\n          [17, 50, 22, 1, 51, 23],\n          [2, 42, 14, 19, 43, 15],\n          // 19\n          [3, 141, 113, 4, 142, 114],\n          [3, 70, 44, 11, 71, 45],\n          [17, 47, 21, 4, 48, 22],\n          [9, 39, 13, 16, 40, 14],\n          // 20\n          [3, 135, 107, 5, 136, 108],\n          [3, 67, 41, 13, 68, 42],\n          [15, 54, 24, 5, 55, 25],\n          [15, 43, 15, 10, 44, 16],\n          // 21\n          [4, 144, 116, 4, 145, 117],\n          [17, 68, 42],\n          [17, 50, 22, 6, 51, 23],\n          [19, 46, 16, 6, 47, 17],\n          // 22\n          [2, 139, 111, 7, 140, 112],\n          [17, 74, 46],\n          [7, 54, 24, 16, 55, 25],\n          [34, 37, 13],\n          // 23\n          [4, 151, 121, 5, 152, 122],\n          [4, 75, 47, 14, 76, 48],\n          [11, 54, 24, 14, 55, 25],\n          [16, 45, 15, 14, 46, 16],\n          // 24\n          [6, 147, 117, 4, 148, 118],\n          [6, 73, 45, 14, 74, 46],\n          [11, 54, 24, 16, 55, 25],\n          [30, 46, 16, 2, 47, 17],\n          // 25\n          [8, 132, 106, 4, 133, 107],\n          [8, 75, 47, 13, 76, 48],\n          [7, 54, 24, 22, 55, 25],\n          [22, 45, 15, 13, 46, 16],\n          // 26\n          [10, 142, 114, 2, 143, 115],\n          [19, 74, 46, 4, 75, 47],\n          [28, 50, 22, 6, 51, 23],\n          [33, 46, 16, 4, 47, 17],\n          // 27\n          [8, 152, 122, 4, 153, 123],\n          [22, 73, 45, 3, 74, 46],\n          [8, 53, 23, 26, 54, 24],\n          [12, 45, 15, 28, 46, 16],\n          // 28\n          [3, 147, 117, 10, 148, 118],\n          [3, 73, 45, 23, 74, 46],\n          [4, 54, 24, 31, 55, 25],\n          [11, 45, 15, 31, 46, 16],\n          // 29\n          [7, 146, 116, 7, 147, 117],\n          [21, 73, 45, 7, 74, 46],\n          [1, 53, 23, 37, 54, 24],\n          [19, 45, 15, 26, 46, 16],\n          // 30\n          [5, 145, 115, 10, 146, 116],\n          [19, 75, 47, 10, 76, 48],\n          [15, 54, 24, 25, 55, 25],\n          [23, 45, 15, 25, 46, 16],\n          // 31\n          [13, 145, 115, 3, 146, 116],\n          [2, 74, 46, 29, 75, 47],\n          [42, 54, 24, 1, 55, 25],\n          [23, 45, 15, 28, 46, 16],\n          // 32\n          [17, 145, 115],\n          [10, 74, 46, 23, 75, 47],\n          [10, 54, 24, 35, 55, 25],\n          [19, 45, 15, 35, 46, 16],\n          // 33\n          [17, 145, 115, 1, 146, 116],\n          [14, 74, 46, 21, 75, 47],\n          [29, 54, 24, 19, 55, 25],\n          [11, 45, 15, 46, 46, 16],\n          // 34\n          [13, 145, 115, 6, 146, 116],\n          [14, 74, 46, 23, 75, 47],\n          [44, 54, 24, 7, 55, 25],\n          [59, 46, 16, 1, 47, 17],\n          // 35\n          [12, 151, 121, 7, 152, 122],\n          [12, 75, 47, 26, 76, 48],\n          [39, 54, 24, 14, 55, 25],\n          [22, 45, 15, 41, 46, 16],\n          // 36\n          [6, 151, 121, 14, 152, 122],\n          [6, 75, 47, 34, 76, 48],\n          [46, 54, 24, 10, 55, 25],\n          [2, 45, 15, 64, 46, 16],\n          // 37\n          [17, 152, 122, 4, 153, 123],\n          [29, 74, 46, 14, 75, 47],\n          [49, 54, 24, 10, 55, 25],\n          [24, 45, 15, 46, 46, 16],\n          // 38\n          [4, 152, 122, 18, 153, 123],\n          [13, 74, 46, 32, 75, 47],\n          [48, 54, 24, 14, 55, 25],\n          [42, 45, 15, 32, 46, 16],\n          // 39\n          [20, 147, 117, 4, 148, 118],\n          [40, 75, 47, 7, 76, 48],\n          [43, 54, 24, 22, 55, 25],\n          [10, 45, 15, 67, 46, 16],\n          // 40\n          [19, 148, 118, 6, 149, 119],\n          [18, 75, 47, 31, 76, 48],\n          [34, 54, 24, 34, 55, 25],\n          [20, 45, 15, 61, 46, 16]\n        ];\n        var qrRSBlock = function(totalCount, dataCount) {\n          var _this2 = {};\n          _this2.totalCount = totalCount;\n          _this2.dataCount = dataCount;\n          return _this2;\n        };\n        var _this = {};\n        var getRsBlockTable = function(typeNumber, errorCorrectionLevel) {\n          switch (errorCorrectionLevel) {\n            case QRErrorCorrectionLevel.L:\n              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];\n            case QRErrorCorrectionLevel.M:\n              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];\n            case QRErrorCorrectionLevel.Q:\n              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];\n            case QRErrorCorrectionLevel.H:\n              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];\n            default:\n              return void 0;\n          }\n        };\n        _this.getRSBlocks = function(typeNumber, errorCorrectionLevel) {\n          var rsBlock = getRsBlockTable(typeNumber, errorCorrectionLevel);\n          if (typeof rsBlock == \"undefined\") {\n            throw \"bad rs block @ typeNumber:\" + typeNumber + \"/errorCorrectionLevel:\" + errorCorrectionLevel;\n          }\n          var length = rsBlock.length / 3;\n          var list = [];\n          for (var i2 = 0; i2 < length; i2 += 1) {\n            var count = rsBlock[i2 * 3 + 0];\n            var totalCount = rsBlock[i2 * 3 + 1];\n            var dataCount = rsBlock[i2 * 3 + 2];\n            for (var j = 0; j < count; j += 1) {\n              list.push(qrRSBlock(totalCount, dataCount));\n            }\n          }\n          return list;\n        };\n        return _this;\n      }();\n      var qrBitBuffer = function() {\n        var _buffer = [];\n        var _length = 0;\n        var _this = {};\n        _this.getBuffer = function() {\n          return _buffer;\n        };\n        _this.getAt = function(index) {\n          var bufIndex = Math.floor(index / 8);\n          return (_buffer[bufIndex] >>> 7 - index % 8 & 1) == 1;\n        };\n        _this.put = function(num, length) {\n          for (var i2 = 0; i2 < length; i2 += 1) {\n            _this.putBit((num >>> length - i2 - 1 & 1) == 1);\n          }\n        };\n        _this.getLengthInBits = function() {\n          return _length;\n        };\n        _this.putBit = function(bit) {\n          var bufIndex = Math.floor(_length / 8);\n          if (_buffer.length <= bufIndex) {\n            _buffer.push(0);\n          }\n          if (bit) {\n            _buffer[bufIndex] |= 128 >>> _length % 8;\n          }\n          _length += 1;\n        };\n        return _this;\n      };\n      var qrNumber = function(data) {\n        var _mode = QRMode.MODE_NUMBER;\n        var _data = data;\n        var _this = {};\n        _this.getMode = function() {\n          return _mode;\n        };\n        _this.getLength = function(buffer) {\n          return _data.length;\n        };\n        _this.write = function(buffer) {\n          var data2 = _data;\n          var i2 = 0;\n          while (i2 + 2 < data2.length) {\n            buffer.put(strToNum(data2.substring(i2, i2 + 3)), 10);\n            i2 += 3;\n          }\n          if (i2 < data2.length) {\n            if (data2.length - i2 == 1) {\n              buffer.put(strToNum(data2.substring(i2, i2 + 1)), 4);\n            } else if (data2.length - i2 == 2) {\n              buffer.put(strToNum(data2.substring(i2, i2 + 2)), 7);\n            }\n          }\n        };\n        var strToNum = function(s2) {\n          var num = 0;\n          for (var i2 = 0; i2 < s2.length; i2 += 1) {\n            num = num * 10 + chatToNum(s2.charAt(i2));\n          }\n          return num;\n        };\n        var chatToNum = function(c2) {\n          if (\"0\" <= c2 && c2 <= \"9\") {\n            return c2.charCodeAt(0) - \"0\".charCodeAt(0);\n          }\n          throw \"illegal char :\" + c2;\n        };\n        return _this;\n      };\n      var qrAlphaNum = function(data) {\n        var _mode = QRMode.MODE_ALPHA_NUM;\n        var _data = data;\n        var _this = {};\n        _this.getMode = function() {\n          return _mode;\n        };\n        _this.getLength = function(buffer) {\n          return _data.length;\n        };\n        _this.write = function(buffer) {\n          var s2 = _data;\n          var i2 = 0;\n          while (i2 + 1 < s2.length) {\n            buffer.put(\n              getCode(s2.charAt(i2)) * 45 + getCode(s2.charAt(i2 + 1)),\n              11\n            );\n            i2 += 2;\n          }\n          if (i2 < s2.length) {\n            buffer.put(getCode(s2.charAt(i2)), 6);\n          }\n        };\n        var getCode = function(c2) {\n          if (\"0\" <= c2 && c2 <= \"9\") {\n            return c2.charCodeAt(0) - \"0\".charCodeAt(0);\n          } else if (\"A\" <= c2 && c2 <= \"Z\") {\n            return c2.charCodeAt(0) - \"A\".charCodeAt(0) + 10;\n          } else {\n            switch (c2) {\n              case \" \":\n                return 36;\n              case \"$\":\n                return 37;\n              case \"%\":\n                return 38;\n              case \"*\":\n                return 39;\n              case \"+\":\n                return 40;\n              case \"-\":\n                return 41;\n              case \".\":\n                return 42;\n              case \"/\":\n                return 43;\n              case \":\":\n                return 44;\n              default:\n                throw \"illegal char :\" + c2;\n            }\n          }\n        };\n        return _this;\n      };\n      var qr8BitByte = function(data) {\n        var _mode = QRMode.MODE_8BIT_BYTE;\n        var _bytes = qrcode3.stringToBytes(data);\n        var _this = {};\n        _this.getMode = function() {\n          return _mode;\n        };\n        _this.getLength = function(buffer) {\n          return _bytes.length;\n        };\n        _this.write = function(buffer) {\n          for (var i2 = 0; i2 < _bytes.length; i2 += 1) {\n            buffer.put(_bytes[i2], 8);\n          }\n        };\n        return _this;\n      };\n      var qrKanji = function(data) {\n        var _mode = QRMode.MODE_KANJI;\n        var stringToBytes = qrcode3.stringToBytesFuncs[\"SJIS\"];\n        if (!stringToBytes) {\n          throw \"sjis not supported.\";\n        }\n        !function(c2, code) {\n          var test = stringToBytes(c2);\n          if (test.length != 2 || (test[0] << 8 | test[1]) != code) {\n            throw \"sjis not supported.\";\n          }\n        }(\"\", 38726);\n        var _bytes = stringToBytes(data);\n        var _this = {};\n        _this.getMode = function() {\n          return _mode;\n        };\n        _this.getLength = function(buffer) {\n          return ~~(_bytes.length / 2);\n        };\n        _this.write = function(buffer) {\n          var data2 = _bytes;\n          var i2 = 0;\n          while (i2 + 1 < data2.length) {\n            var c2 = (255 & data2[i2]) << 8 | 255 & data2[i2 + 1];\n            if (33088 <= c2 && c2 <= 40956) {\n              c2 -= 33088;\n            } else if (57408 <= c2 && c2 <= 60351) {\n              c2 -= 49472;\n            } else {\n              throw \"illegal char at \" + (i2 + 1) + \"/\" + c2;\n            }\n            c2 = (c2 >>> 8 & 255) * 192 + (c2 & 255);\n            buffer.put(c2, 13);\n            i2 += 2;\n          }\n          if (i2 < data2.length) {\n            throw \"illegal char at \" + (i2 + 1);\n          }\n        };\n        return _this;\n      };\n      var byteArrayOutputStream = function() {\n        var _bytes = [];\n        var _this = {};\n        _this.writeByte = function(b) {\n          _bytes.push(b & 255);\n        };\n        _this.writeShort = function(i2) {\n          _this.writeByte(i2);\n          _this.writeByte(i2 >>> 8);\n        };\n        _this.writeBytes = function(b, off, len) {\n          off = off || 0;\n          len = len || b.length;\n          for (var i2 = 0; i2 < len; i2 += 1) {\n            _this.writeByte(b[i2 + off]);\n          }\n        };\n        _this.writeString = function(s2) {\n          for (var i2 = 0; i2 < s2.length; i2 += 1) {\n            _this.writeByte(s2.charCodeAt(i2));\n          }\n        };\n        _this.toByteArray = function() {\n          return _bytes;\n        };\n        _this.toString = function() {\n          var s2 = \"\";\n          s2 += \"[\";\n          for (var i2 = 0; i2 < _bytes.length; i2 += 1) {\n            if (i2 > 0) {\n              s2 += \",\";\n            }\n            s2 += _bytes[i2];\n          }\n          s2 += \"]\";\n          return s2;\n        };\n        return _this;\n      };\n      var base64EncodeOutputStream = function() {\n        var _buffer = 0;\n        var _buflen = 0;\n        var _length = 0;\n        var _base64 = \"\";\n        var _this = {};\n        var writeEncoded = function(b) {\n          _base64 += String.fromCharCode(encode(b & 63));\n        };\n        var encode = function(n2) {\n          if (n2 < 0) ;\n          else if (n2 < 26) {\n            return 65 + n2;\n          } else if (n2 < 52) {\n            return 97 + (n2 - 26);\n          } else if (n2 < 62) {\n            return 48 + (n2 - 52);\n          } else if (n2 == 62) {\n            return 43;\n          } else if (n2 == 63) {\n            return 47;\n          }\n          throw \"n:\" + n2;\n        };\n        _this.writeByte = function(n2) {\n          _buffer = _buffer << 8 | n2 & 255;\n          _buflen += 8;\n          _length += 1;\n          while (_buflen >= 6) {\n            writeEncoded(_buffer >>> _buflen - 6);\n            _buflen -= 6;\n          }\n        };\n        _this.flush = function() {\n          if (_buflen > 0) {\n            writeEncoded(_buffer << 6 - _buflen);\n            _buffer = 0;\n            _buflen = 0;\n          }\n          if (_length % 3 != 0) {\n            var padlen = 3 - _length % 3;\n            for (var i2 = 0; i2 < padlen; i2 += 1) {\n              _base64 += \"=\";\n            }\n          }\n        };\n        _this.toString = function() {\n          return _base64;\n        };\n        return _this;\n      };\n      var base64DecodeInputStream = function(str) {\n        var _str = str;\n        var _pos = 0;\n        var _buffer = 0;\n        var _buflen = 0;\n        var _this = {};\n        _this.read = function() {\n          while (_buflen < 8) {\n            if (_pos >= _str.length) {\n              if (_buflen == 0) {\n                return -1;\n              }\n              throw \"unexpected end of file./\" + _buflen;\n            }\n            var c2 = _str.charAt(_pos);\n            _pos += 1;\n            if (c2 == \"=\") {\n              _buflen = 0;\n              return -1;\n            } else if (c2.match(/^\\s$/)) {\n              continue;\n            }\n            _buffer = _buffer << 6 | decode(c2.charCodeAt(0));\n            _buflen += 6;\n          }\n          var n2 = _buffer >>> _buflen - 8 & 255;\n          _buflen -= 8;\n          return n2;\n        };\n        var decode = function(c2) {\n          if (65 <= c2 && c2 <= 90) {\n            return c2 - 65;\n          } else if (97 <= c2 && c2 <= 122) {\n            return c2 - 97 + 26;\n          } else if (48 <= c2 && c2 <= 57) {\n            return c2 - 48 + 52;\n          } else if (c2 == 43) {\n            return 62;\n          } else if (c2 == 47) {\n            return 63;\n          } else {\n            throw \"c:\" + c2;\n          }\n        };\n        return _this;\n      };\n      var gifImage = function(width, height) {\n        var _width = width;\n        var _height = height;\n        var _data = new Array(width * height);\n        var _this = {};\n        _this.setPixel = function(x, y, pixel) {\n          _data[y * _width + x] = pixel;\n        };\n        _this.write = function(out) {\n          out.writeString(\"GIF87a\");\n          out.writeShort(_width);\n          out.writeShort(_height);\n          out.writeByte(128);\n          out.writeByte(0);\n          out.writeByte(0);\n          out.writeByte(0);\n          out.writeByte(0);\n          out.writeByte(0);\n          out.writeByte(255);\n          out.writeByte(255);\n          out.writeByte(255);\n          out.writeString(\",\");\n          out.writeShort(0);\n          out.writeShort(0);\n          out.writeShort(_width);\n          out.writeShort(_height);\n          out.writeByte(0);\n          var lzwMinCodeSize = 2;\n          var raster = getLZWRaster(lzwMinCodeSize);\n          out.writeByte(lzwMinCodeSize);\n          var offset = 0;\n          while (raster.length - offset > 255) {\n            out.writeByte(255);\n            out.writeBytes(raster, offset, 255);\n            offset += 255;\n          }\n          out.writeByte(raster.length - offset);\n          out.writeBytes(raster, offset, raster.length - offset);\n          out.writeByte(0);\n          out.writeString(\";\");\n        };\n        var bitOutputStream = function(out) {\n          var _out = out;\n          var _bitLength = 0;\n          var _bitBuffer = 0;\n          var _this2 = {};\n          _this2.write = function(data, length) {\n            if (data >>> length != 0) {\n              throw \"length over\";\n            }\n            while (_bitLength + length >= 8) {\n              _out.writeByte(255 & (data << _bitLength | _bitBuffer));\n              length -= 8 - _bitLength;\n              data >>>= 8 - _bitLength;\n              _bitBuffer = 0;\n              _bitLength = 0;\n            }\n            _bitBuffer = data << _bitLength | _bitBuffer;\n            _bitLength = _bitLength + length;\n          };\n          _this2.flush = function() {\n            if (_bitLength > 0) {\n              _out.writeByte(_bitBuffer);\n            }\n          };\n          return _this2;\n        };\n        var getLZWRaster = function(lzwMinCodeSize) {\n          var clearCode = 1 << lzwMinCodeSize;\n          var endCode = (1 << lzwMinCodeSize) + 1;\n          var bitLength = lzwMinCodeSize + 1;\n          var table = lzwTable();\n          for (var i2 = 0; i2 < clearCode; i2 += 1) {\n            table.add(String.fromCharCode(i2));\n          }\n          table.add(String.fromCharCode(clearCode));\n          table.add(String.fromCharCode(endCode));\n          var byteOut = byteArrayOutputStream();\n          var bitOut = bitOutputStream(byteOut);\n          bitOut.write(clearCode, bitLength);\n          var dataIndex = 0;\n          var s2 = String.fromCharCode(_data[dataIndex]);\n          dataIndex += 1;\n          while (dataIndex < _data.length) {\n            var c2 = String.fromCharCode(_data[dataIndex]);\n            dataIndex += 1;\n            if (table.contains(s2 + c2)) {\n              s2 = s2 + c2;\n            } else {\n              bitOut.write(table.indexOf(s2), bitLength);\n              if (table.size() < 4095) {\n                if (table.size() == 1 << bitLength) {\n                  bitLength += 1;\n                }\n                table.add(s2 + c2);\n              }\n              s2 = c2;\n            }\n          }\n          bitOut.write(table.indexOf(s2), bitLength);\n          bitOut.write(endCode, bitLength);\n          bitOut.flush();\n          return byteOut.toByteArray();\n        };\n        var lzwTable = function() {\n          var _map = {};\n          var _size = 0;\n          var _this2 = {};\n          _this2.add = function(key) {\n            if (_this2.contains(key)) {\n              throw \"dup key:\" + key;\n            }\n            _map[key] = _size;\n            _size += 1;\n          };\n          _this2.size = function() {\n            return _size;\n          };\n          _this2.indexOf = function(key) {\n            return _map[key];\n          };\n          _this2.contains = function(key) {\n            return typeof _map[key] != \"undefined\";\n          };\n          return _this2;\n        };\n        return _this;\n      };\n      var createDataURL = function(width, height, getPixel) {\n        var gif = gifImage(width, height);\n        for (var y = 0; y < height; y += 1) {\n          for (var x = 0; x < width; x += 1) {\n            gif.setPixel(x, y, getPixel(x, y));\n          }\n        }\n        var b = byteArrayOutputStream();\n        gif.write(b);\n        var base64 = base64EncodeOutputStream();\n        var bytes = b.toByteArray();\n        for (var i2 = 0; i2 < bytes.length; i2 += 1) {\n          base64.writeByte(bytes[i2]);\n        }\n        base64.flush();\n        return \"data:image/gif;base64,\" + base64;\n      };\n      return qrcode3;\n    }();\n    !function() {\n      qrcode2.stringToBytesFuncs[\"UTF-8\"] = function(s2) {\n        function toUTF8Array(str) {\n          var utf8 = [];\n          for (var i2 = 0; i2 < str.length; i2++) {\n            var charcode = str.charCodeAt(i2);\n            if (charcode < 128) utf8.push(charcode);\n            else if (charcode < 2048) {\n              utf8.push(\n                192 | charcode >> 6,\n                128 | charcode & 63\n              );\n            } else if (charcode < 55296 || charcode >= 57344) {\n              utf8.push(\n                224 | charcode >> 12,\n                128 | charcode >> 6 & 63,\n                128 | charcode & 63\n              );\n            } else {\n              i2++;\n              charcode = 65536 + ((charcode & 1023) << 10 | str.charCodeAt(i2) & 1023);\n              utf8.push(\n                240 | charcode >> 18,\n                128 | charcode >> 12 & 63,\n                128 | charcode >> 6 & 63,\n                128 | charcode & 63\n              );\n            }\n          }\n          return utf8;\n        }\n        return toUTF8Array(s2);\n      };\n    }();\n    (function(factory) {\n      {\n        module.exports = factory();\n      }\n    })(function() {\n      return qrcode2;\n    });\n  })(qrcode$1);\n  return qrcode$1.exports;\n}\nvar qrcodeExports = requireQrcode();\nconst qrcode = /* @__PURE__ */ getDefaultExportFromCjs(qrcodeExports);\nfunction copyToClipboard(text) {\n  return __async(this, null, function* () {\n    try {\n      if (!(navigator == null ? void 0 : navigator.clipboard)) {\n        throw new TonConnectUIError(\"Clipboard API not available\");\n      }\n      return yield navigator.clipboard.writeText(text);\n    } catch (e2) {\n    }\n    fallbackCopyTextToClipboard(text);\n  });\n}\nfunction fallbackCopyTextToClipboard(text) {\n  const textArea = document.createElement(\"textarea\");\n  textArea.value = text;\n  textArea.style.top = \"0\";\n  textArea.style.left = \"0\";\n  textArea.style.position = \"fixed\";\n  document.body.appendChild(textArea);\n  textArea.focus();\n  textArea.select();\n  try {\n    document.execCommand(\"copy\");\n  } finally {\n    document.body.removeChild(textArea);\n  }\n}\nvar _tmpl$$s = /* @__PURE__ */ template$1(`<div>`);\nconst QRCode = (props) => {\n  let qrCodeCanvasRef;\n  let qrCodeWrapperRef;\n  let imageRef;\n  const [copyButtonOpened, setCopyButtonOpened] = createSignal(false);\n  const [picSize, setPicSize] = createSignal(picSizeDefault);\n  createEffect(() => {\n    const errorCorrectionLevel = \"L\";\n    const cellSize = 4;\n    const qr = qrcode(0, errorCorrectionLevel);\n    qr.addData(props.sourceUrl);\n    qr.make();\n    qrCodeCanvasRef.innerHTML = qr.createSvgTag(cellSize, 0);\n    const qrSize = qrCodeCanvasRef.firstElementChild.clientWidth;\n    const scale = Math.round(qrNormalSize / qrSize * 1e5) / 1e5;\n    if (imageRef) {\n      const imgSize = Math.ceil(imgSizeDefault / (scale * cellSize)) * cellSize;\n      const imgOffset = toPx(Math.ceil((qrSize - imgSize) / (2 * cellSize)) * cellSize);\n      imageRef.style.top = imgOffset;\n      imageRef.style.left = imgOffset;\n      imageRef.style.height = toPx(imgSize);\n      imageRef.style.width = toPx(imgSize);\n      setPicSize(Math.round(picSizeDefault / scale));\n    }\n    qrCodeWrapperRef.style.transform = `scale(${scale})`;\n  });\n  let timeoutId = null;\n  const onCopyClick = () => {\n    setCopyButtonOpened(true);\n    copyToClipboard(props.sourceUrl);\n    if (timeoutId != null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => setCopyButtonOpened(false), 1500);\n  };\n  return createComponent(QrCodeBackground, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    onClick: onCopyClick,\n    get children() {\n      return [createComponent(QrCodeWrapper$2, {\n        ref(r$) {\n          var _ref$ = qrCodeWrapperRef;\n          typeof _ref$ === \"function\" ? _ref$(r$) : qrCodeWrapperRef = r$;\n        },\n        get children() {\n          return [(() => {\n            var _el$ = _tmpl$$s();\n            var _ref$2 = qrCodeCanvasRef;\n            typeof _ref$2 === \"function\" ? use(_ref$2, _el$) : qrCodeCanvasRef = _el$;\n            return _el$;\n          })(), createComponent(Show, {\n            get when() {\n              return props.imageUrl;\n            },\n            get children() {\n              return createComponent(ImageBackground, {\n                ref(r$) {\n                  var _ref$3 = imageRef;\n                  typeof _ref$3 === \"function\" ? _ref$3(r$) : imageRef = r$;\n                },\n                get children() {\n                  return createComponent(ImageStyled$3, {\n                    get src() {\n                      return props.imageUrl;\n                    },\n                    alt: \"\",\n                    get size() {\n                      return picSize();\n                    }\n                  });\n                }\n              });\n            }\n          })];\n        }\n      }), createComponent(Transition, {\n        onBeforeEnter: (el) => {\n          animate(el, [{\n            opacity: 0,\n            transform: \"translate(-50%, 44px)\"\n          }, {\n            opacity: 1,\n            transform: \"translate(-50%, 0)\"\n          }], {\n            duration: 150,\n            easing: \"ease-out\"\n          });\n        },\n        onExit: (el, done) => {\n          animate(el, [{\n            opacity: 1,\n            transform: \"translate(-50%, 0)\"\n          }, {\n            opacity: 0,\n            transform: \"translate(-50%, 44px)\"\n          }], {\n            duration: 150,\n            easing: \"ease-out\"\n          }).finished.then(() => {\n            done();\n          });\n        },\n        get children() {\n          return createComponent(Show, {\n            get when() {\n              return copyButtonOpened() && !props.disableCopy;\n            },\n            get children() {\n              return createComponent(CopiedBoxStyled, {\n                get children() {\n                  return [createComponent(SuccessIcon, {\n                    size: \"xs\"\n                  }), createComponent(Text, {\n                    translationKey: \"common.linkCopied\",\n                    children: \"Link Copied\"\n                  })];\n                }\n              });\n            }\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !props.disableCopy;\n        },\n        get children() {\n          return createComponent(CopyIconButton, {\n            get children() {\n              return createComponent(CopyLightIcon, {});\n            }\n          });\n        }\n      })];\n    }\n  });\n};\nvar deepReadObject = (obj, path, defaultValue) => {\n  const value = path.trim().split(\".\").reduce((a2, b) => a2 ? a2[b] : void 0, obj);\n  return value !== void 0 ? value : defaultValue;\n};\nvar template = (str, params, reg = /{{(.*?)}}/g) => str.replace(reg, (_, key) => deepReadObject(params, key, \"\"));\nvar createI18nContext = (init = {}, lang = navigator.language in init ? navigator.language : Object.keys(init)[0]) => {\n  const [locale, setLocale] = createSignal(lang);\n  const [dict, setDict] = createStore(init);\n  const translate = (key, params, defaultValue) => {\n    const val = deepReadObject(dict[locale()], key, defaultValue || \"\");\n    if (typeof val === \"function\")\n      return val(params);\n    if (typeof val === \"string\")\n      return template(val, params || {});\n    return val;\n  };\n  const actions = {\n    add(lang2, table) {\n      setDict(lang2, (t2) => Object.assign(t2 || {}, table));\n    },\n    locale: (lang2) => lang2 ? setLocale(lang2) : locale(),\n    dict: (lang2) => deepReadObject(dict, lang2)\n  };\n  return [translate, actions];\n};\nvar I18nContext = createContext({});\nvar useI18n = () => useContext(I18nContext);\nconst TextStyled$4 = styled.div`\n    font-style: normal;\n    font-weight: ${(props) => props.fontWeight};\n    font-size: ${(props) => props.fontSize};\n    line-height: ${(props) => props.lineHeight};\n\n    color: ${(props) => props.color};\n`;\nconst Text = (inputs) => {\n  const theme = useTheme();\n  const [t2] = useI18n();\n  let textRef;\n  const color = () => inputs.color || theme.colors.text.primary;\n  const props = mergeProps({\n    fontSize: \"14px\",\n    fontWeight: \"510\",\n    lineHeight: \"130%\"\n  }, inputs);\n  createEffect(() => {\n    if (!textRef) {\n      return;\n    }\n    if (props.cursor === \"unset\") {\n      return;\n    }\n    if (getComputedStyle(textRef).cursor !== \"pointer\") {\n      textRef.style.cursor = \"default\";\n    }\n  });\n  return createComponent(TextStyled$4, {\n    get fontSize() {\n      return props.fontSize;\n    },\n    get fontWeight() {\n      return props.fontWeight;\n    },\n    get lineHeight() {\n      return props.lineHeight;\n    },\n    get color() {\n      return color();\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    ref(r$) {\n      var _ref$ = textRef;\n      typeof _ref$ === \"function\" ? _ref$(r$) : textRef = r$;\n    },\n    \"data-tc-text\": \"true\",\n    get children() {\n      var _a2;\n      return memo(() => !!props.translationKey)() ? t2(props.translationKey, props.translationValues, (_a2 = props.children) == null ? void 0 : _a2.toString()) : props.children;\n    }\n  });\n};\nconst ImageContainer = styled.div`\n    position: relative;\n\n    &::after {\n        content: '';\n        display: block;\n        position: absolute;\n        top: 0;\n        bottom: 0;\n        left: 0;\n        right: 0;\n        border: 0.5px solid rgba(0, 0, 0, 0.08);\n        border-radius: inherit;\n    }\n`;\nconst ImageStyled$2 = styled(Image)`\n    width: 100%;\n    height: 100%;\n    border-radius: inherit;\n`;\nconst WalletImage = (props) => {\n  return createComponent(ImageContainer, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    get children() {\n      return [createComponent(ImageStyled$2, {\n        get src() {\n          return props.src;\n        }\n      }), memo(() => props.badge)];\n    }\n  });\n};\nconst borders$4 = {\n  m: \"16px\",\n  s: \"12px\",\n  none: \"0\"\n};\nconst badgeBorders = {\n  m: \"6px\",\n  s: \"6px\",\n  none: \"0\"\n};\nconst WalletUlContainer = styled.ul`\n    display: flex;\n    gap: 0;\n    width: 100%;\n    overflow-x: auto;\n    padding: 8px 12px 16px 12px;\n    margin: 0;\n    list-style: none;\n    flex-wrap: nowrap;\n\n    &&::-webkit-scrollbar {\n        display: none;\n    }\n    -ms-overflow-style: none;\n    scrollbar-width: none;\n\n    > li {\n        display: flex;\n        flex: 1;\n        min-width: 78px;\n        height: fit-content;\n    }\n\n    > li > button {\n        width: 100%;\n    }\n`;\nconst WalletItemStyled = styled.button`\n    position: relative;\n    cursor: pointer;\n    border: none;\n    background-color: unset;\n    padding: 8px 4px;\n    min-width: 78px;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n\n    transition: transform 0.125s ease-in-out;\n\n    ${mediaNotTouch} {\n        &:hover {\n            transform: scale(1.04);\n        }\n    }\n\n    &:active {\n        transform: scale(0.96);\n    }\n\n    ${mediaTouch} {\n        &:active {\n            transform: scale(0.92);\n        }\n    }\n`;\nconst ImageStyled$1 = styled(WalletImage)`\n    width: 60px;\n    height: 60px;\n    border-radius: ${(props) => borders$4[props.theme.borderRadius]};\n    margin-bottom: 8px;\n    position: relative;\n`;\nconst BadgeStyled = styled(Image)`\n    position: absolute;\n    right: -6px;\n    bottom: -6px;\n    width: 24px;\n    height: 24px;\n    border-radius: ${(props) => badgeBorders[props.theme.borderRadius]};\n    box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.08);\n`;\nconst StyledText = styled(Text)`\n    max-width: 90px;\n    font-weight: 510;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    overflow: hidden;\n\n    ${media(\"mobile\")} {\n        max-width: 80px;\n    }\n`;\nconst StyledSecondLine = styled(Text)`\n    font-weight: ${(props) => props.colorPrimary ? \"510\" : \"400\"};\n    max-width: 90px;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    color: ${(props) => props.colorPrimary ? props.theme.colors.text.primary : props.theme.colors.text.secondary};\n\n    ${media(\"mobile\")} {\n        max-width: 80px;\n    }\n`;\nvar _tmpl$$r = /* @__PURE__ */ template$1(`<div>`);\nconst WalletItem = (props) => {\n  let ctxRef = null;\n  const adjustLetterSpacing = () => {\n    const name = ctxRef == null ? void 0 : ctxRef.querySelector(\"div\");\n    if (name && name.scrollWidth > name.clientWidth) {\n      let spacing = 0;\n      const minSpacing = -0.4;\n      const step = 0.05;\n      while (name.scrollWidth > name.clientWidth && spacing >= minSpacing) {\n        spacing -= step;\n        name.style.letterSpacing = `${spacing}px`;\n      }\n      if (spacing !== 0) {\n        spacing -= step;\n        name.style.letterSpacing = `${spacing}px`;\n      }\n    }\n  };\n  onMount(() => adjustLetterSpacing());\n  createEffect(() => {\n    adjustLetterSpacing();\n  });\n  return createComponent(WalletItemStyled, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    onClick: () => props.onClick(),\n    \"data-tc-wallet-item\": \"true\",\n    get children() {\n      return [memo(() => memo(() => typeof props.icon === \"string\")() ? createComponent(ImageStyled$1, {\n        get src() {\n          return props.icon;\n        },\n        get badge() {\n          return memo(() => !!props.badgeUrl)() && createComponent(BadgeStyled, {\n            get src() {\n              return props.badgeUrl;\n            }\n          });\n        }\n      }) : props.icon), (() => {\n        var _el$ = _tmpl$$r();\n        use((el) => ctxRef = el, _el$);\n        insert(_el$, createComponent(StyledText, {\n          get children() {\n            return props.name;\n          }\n        }));\n        return _el$;\n      })(), memo(() => memo(() => !!props.secondLine)() && createComponent(StyledSecondLine, {\n        get colorPrimary() {\n          var _a2;\n          return (_a2 = props.secondLineColorPrimary) != null ? _a2 : true;\n        },\n        get children() {\n          return props.secondLine;\n        }\n      }))];\n    }\n  });\n};\nconst H1Styled$b = styled.h1`\n    font-style: normal;\n    font-weight: 590;\n    font-size: 20px;\n    line-height: 28px;\n\n    text-align: center;\n\n    color: ${(props) => props.theme.colors.text.primary};\n\n    margin-top: 0;\n    margin-bottom: 0;\n\n    cursor: default;\n`;\nconst H1 = (props) => {\n  const [t2] = useI18n();\n  return createComponent(H1Styled$b, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-h1\": \"true\",\n    get children() {\n      var _a2;\n      return memo(() => !!props.translationKey)() ? t2(props.translationKey, props.translationValues, (_a2 = props.children) == null ? void 0 : _a2.toString()) : props.children;\n    }\n  });\n};\nconst H2Styled$5 = styled.h2`\n    font-style: normal;\n    font-weight: 400;\n    font-size: 16px;\n    line-height: 22px;\n\n    text-align: center;\n\n    color: ${(props) => props.theme.colors.text.secondary};\n\n    margin-top: 0;\n    margin-bottom: 32px;\n\n    cursor: default;\n`;\nconst H2 = (props) => {\n  const [t2] = useI18n();\n  return createComponent(H2Styled$5, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-h2\": \"true\",\n    get children() {\n      var _a2;\n      return memo(() => !!props.translationKey)() ? t2(props.translationKey, props.translationValues, (_a2 = props.children) == null ? void 0 : _a2.toString()) : props.children;\n    }\n  });\n};\nconst H3Styled$2 = styled.h3`\n    font-style: normal;\n    font-weight: 510;\n    font-size: 16px;\n    line-height: 20px;\n\n    color: ${(props) => props.theme.colors.text.primary};\n\n    margin-top: 0;\n    margin-bottom: 0;\n\n    cursor: default;\n`;\nconst H3 = (props) => {\n  const [t2] = useI18n();\n  return createComponent(H3Styled$2, {\n    \"data-tc-h3\": \"true\",\n    get [\"class\"]() {\n      return props.class;\n    },\n    get children() {\n      var _a2;\n      return memo(() => !!props.translationKey)() ? t2(props.translationKey, props.translationValues, (_a2 = props.children) == null ? void 0 : _a2.toString()) : props.children;\n    }\n  });\n};\nvar _tmpl$$q = /* @__PURE__ */ template$1(`<svg width=24 height=24 viewBox=\"0 0 24 24\"fill=none xmlns=http://www.w3.org/2000/svg><path fill-rule=evenodd clip-rule=evenodd d=\"M14.1839 17.7069C13.6405 18.6507 13.3688 19.1226 13.0591 19.348C12.4278 19.8074 11.5723 19.8074 10.941 19.348C10.6312 19.1226 10.3595 18.6507 9.81613 17.7069L5.52066 10.2464C4.76864 8.94024 4.39263 8.28717 4.33762 7.75894C4.2255 6.68236 4.81894 5.65591 5.80788 5.21589C6.29309 5 7.04667 5 8.55383 5H15.4462C16.9534 5 17.7069 5 18.1922 5.21589C19.1811 5.65591 19.7745 6.68236 19.6624 7.75894C19.6074 8.28717 19.2314 8.94024 18.4794 10.2464L14.1839 17.7069ZM11.1 16.3412L6.56139 8.48002C6.31995 8.06185 6.19924 7.85276 6.18146 7.68365C6.14523 7.33896 6.33507 7.01015 6.65169 6.86919C6.80703 6.80002 7.04847 6.80002 7.53133 6.80002H7.53134L11.1 6.80002V16.3412ZM12.9 16.3412L17.4387 8.48002C17.6801 8.06185 17.8008 7.85276 17.8186 7.68365C17.8548 7.33896 17.665 7.01015 17.3484 6.86919C17.193 6.80002 16.9516 6.80002 16.4687 6.80002L12.9 6.80002V16.3412Z\">`);\nconst TonIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.primary;\n  return (() => {\n    var _el$ = _tmpl$$q(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$p = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none><g clip-path=url(#clip0_3783_2045)><circle cx=8 cy=8.00098 r=8></circle><path d=\"M4.75 8.50098L7 10.751L11.75 6.00098\"stroke-width=1.5 stroke-linecap=round stroke-linejoin=round></path></g><defs><clipPath id=clip0_3783_2045><rect width=16 height=16 fill=white transform=\"translate(0 0.000976562)\">`), _tmpl$2$4 = /* @__PURE__ */ template$1(`<svg width=24 height=24 viewBox=\"0 0 24 24\"fill=none xmlns=http://www.w3.org/2000/svg><circle cx=12 cy=12 r=11></circle><path d=\"M17.1364 9.6364C17.4879 9.28493 17.4879 8.71508 17.1364 8.36361C16.7849 8.01214 16.2151 8.01214 15.8636 8.36361L10 14.2272L8.1364 12.3636C7.78493 12.0121 7.21508 12.0121 6.86361 12.3636C6.51214 12.7151 6.51214 13.2849 6.86361 13.6364L9.36361 16.1364C9.71508 16.4879 10.2849 16.4879 10.6364 16.1364L17.1364 9.6364Z\">`), _tmpl$3$2 = /* @__PURE__ */ template$1(`<svg width=72 height=72 viewBox=\"0 0 72 72\"fill=none xmlns=http://www.w3.org/2000/svg><circle cx=36 cy=36 r=33></circle><path d=\"M50.9142 28.4142C51.6953 27.6332 51.6953 26.3668 50.9142 25.5858C50.1332 24.8047 48.8668 24.8047 48.0858 25.5858L30 43.6716L23.9142 37.5858C23.1332 36.8047 21.8668 36.8047 21.0858 37.5858C20.3047 38.3668 20.3047 39.6332 21.0858 40.4142L28.5858 47.9142C29.3668 48.6953 30.6332 48.6953 31.4142 47.9142L50.9142 28.4142Z\">`);\nconst SuccessIcon = (props) => {\n  const theme = useTheme();\n  const size = () => props.size || \"s\";\n  const fill = () => props.fill || theme.colors.icon.success;\n  return memo(() => memo(() => size() === \"xs\")() ? (() => {\n    var _el$ = _tmpl$$p(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$ = props.class, _v$2 = fill(), _v$3 = theme.colors.constant.white;\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$3, \"fill\", _p$.t = _v$2);\n      _v$3 !== _p$.a && setAttribute(_el$4, \"stroke\", _p$.a = _v$3);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0\n    });\n    return _el$;\n  })() : memo(() => size() === \"s\")() ? (() => {\n    var _el$5 = _tmpl$2$4(), _el$6 = _el$5.firstChild, _el$7 = _el$6.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$4 = props.class, _v$5 = fill(), _v$6 = theme.colors.constant.white;\n      _v$4 !== _p$.e && setAttribute(_el$5, \"class\", _p$.e = _v$4);\n      _v$5 !== _p$.t && setAttribute(_el$6, \"fill\", _p$.t = _v$5);\n      _v$6 !== _p$.a && setAttribute(_el$7, \"fill\", _p$.a = _v$6);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0\n    });\n    return _el$5;\n  })() : (() => {\n    var _el$8 = _tmpl$3$2(), _el$9 = _el$8.firstChild, _el$0 = _el$9.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$7 = props.class, _v$8 = fill(), _v$9 = theme.colors.constant.white;\n      _v$7 !== _p$.e && setAttribute(_el$8, \"class\", _p$.e = _v$7);\n      _v$8 !== _p$.t && setAttribute(_el$9, \"fill\", _p$.t = _v$8);\n      _v$9 !== _p$.a && setAttribute(_el$0, \"fill\", _p$.a = _v$9);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0\n    });\n    return _el$8;\n  })());\n};\nvar _tmpl$$o = /* @__PURE__ */ template$1(`<svg width=72 height=72 viewBox=\"0 0 72 72\"fill=none xmlns=http://www.w3.org/2000/svg><circle cx=36 cy=36 r=33></circle><path d=\"M24.0858 26.9142C23.3047 26.1332 23.3047 24.8668 24.0858 24.0858C24.8668 23.3047 26.1332 23.3047 26.9142 24.0858L36 33.1716L45.0858 24.0858C45.8668 23.3047 47.1332 23.3047 47.9142 24.0858C48.6953 24.8668 48.6953 26.1332 47.9142 26.9142L38.8284 36L47.9142 45.0858C48.6953 45.8668 48.6953 47.1332 47.9142 47.9142C47.1332 48.6953 45.8668 48.6953 45.0858 47.9142L36 38.8284L26.9142 47.9142C26.1332 48.6953 24.8668 48.6953 24.0858 47.9142C23.3047 47.1332 23.3047 45.8668 24.0858 45.0858L33.1716 36L24.0858 26.9142Z\">`), _tmpl$2$3 = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=48 height=48 viewBox=\"0 0 48 48\"fill=none><circle cx=24 cy=24.001 r=22></circle><path d=\"M24 24.001L31.5 16.501M24 24.001L16.5 16.501M24 24.001L16.5 31.501M24 24.001L31.5 31.501\"stroke-width=3 stroke-linecap=round stroke-linejoin=round>`), _tmpl$3$1 = /* @__PURE__ */ template$1(`<svg width=24 height=24 viewBox=\"0 0 24 24\"fill=none xmlns=http://www.w3.org/2000/svg><circle cx=12 cy=12 r=11></circle><path d=\"M7.86361 9.1364C7.51214 8.78493 7.51214 8.21508 7.86361 7.86361C8.21508 7.51214 8.78493 7.51214 9.1364 7.86361L12 10.7272L14.8636 7.86361C15.2151 7.51214 15.7849 7.51214 16.1364 7.86361C16.4879 8.21508 16.4879 8.78493 16.1364 9.1364L13.2728 12L16.1364 14.8636C16.4879 15.2151 16.4879 15.7849 16.1364 16.1364C15.7849 16.4879 15.2151 16.4879 14.8636 16.1364L12 13.2728L9.1364 16.1364C8.78493 16.4879 8.21508 16.4879 7.86361 16.1364C7.51214 15.7849 7.51214 15.2151 7.86361 14.8636L10.7272 12L7.86361 9.1364Z\">`);\nconst ErrorIcon = (props) => {\n  const theme = useTheme();\n  const size = () => props.size || \"m\";\n  const fill = () => props.fill || theme.colors.icon.error;\n  return memo(() => memo(() => size() === \"m\")() ? (() => {\n    var _el$ = _tmpl$$o(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$ = props.class, _v$2 = fill(), _v$3 = theme.colors.constant.white;\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      _v$3 !== _p$.a && setAttribute(_el$3, \"fill\", _p$.a = _v$3);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0\n    });\n    return _el$;\n  })() : memo(() => size() === \"s\")() ? (() => {\n    var _el$4 = _tmpl$2$3(), _el$5 = _el$4.firstChild, _el$6 = _el$5.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$4 = props.class, _v$5 = fill(), _v$6 = theme.colors.constant.white;\n      _v$4 !== _p$.e && setAttribute(_el$4, \"class\", _p$.e = _v$4);\n      _v$5 !== _p$.t && setAttribute(_el$5, \"fill\", _p$.t = _v$5);\n      _v$6 !== _p$.a && setAttribute(_el$6, \"stroke\", _p$.a = _v$6);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0\n    });\n    return _el$4;\n  })() : (() => {\n    var _el$7 = _tmpl$3$1(), _el$8 = _el$7.firstChild, _el$9 = _el$8.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$7 = props.class, _v$8 = fill(), _v$9 = theme.colors.constant.white;\n      _v$7 !== _p$.e && setAttribute(_el$7, \"class\", _p$.e = _v$7);\n      _v$8 !== _p$.t && setAttribute(_el$8, \"fill\", _p$.t = _v$8);\n      _v$9 !== _p$.a && setAttribute(_el$9, \"fill\", _p$.a = _v$9);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0\n    });\n    return _el$7;\n  })());\n};\nvar _tmpl$$n = /* @__PURE__ */ template$1(`<svg width=24 height=24 viewBox=\"0 0 24 24\"fill=none xmlns=http://www.w3.org/2000/svg><path d=\"M15.55 5.85123C18.9459 7.81184 20.1094 12.1541 18.1488 15.55C16.1882 18.9459 11.8459 20.1094 8.44998 18.1488C8.01952 17.9003 7.46909 18.0478 7.22056 18.4782C6.97203 18.9087 7.11952 19.4591 7.54998 19.7076C11.8068 22.1653 17.2499 20.7068 19.7076 16.45C22.1653 12.1932 20.7068 6.75005 16.45 4.29239C12.1932 1.83472 6.75003 3.29321 4.29236 7.55001C4.04383 7.98047 4.19132 8.53091 4.62178 8.77943C5.05224 9.02796 5.60268 8.88048 5.8512 8.45001C7.81181 5.05413 12.1541 3.89062 15.55 5.85123Z\">`), _tmpl$2$2 = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=44 height=44 viewBox=\"0 0 44 44\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M22 2.99951C11.5066 2.99951 3 11.5061 3 21.9995C3 32.4929 11.5066 40.9995 22 40.9995C22.8284 40.9995 23.5 41.6711 23.5 42.4995C23.5 43.3279 22.8284 43.9995 22 43.9995C9.84974 43.9995 0 34.1498 0 21.9995C0 9.84925 9.84974 -0.000488281 22 -0.000488281C34.1503 -0.000488281 44 9.84925 44 21.9995C44 22.8279 43.3284 23.4995 42.5 23.4995C41.6716 23.4995 41 22.8279 41 21.9995C41 11.5061 32.4934 2.99951 22 2.99951Z\">`), _tmpl$3 = /* @__PURE__ */ template$1(`<svg width=72 height=72 viewBox=\"0 0 72 72\"fill=none xmlns=http://www.w3.org/2000/svg><path d=\"M24 56.7846C35.479 63.412 50.1572 59.479 56.7846 47.9999C63.412 36.5209 59.479 21.8427 48 15.2153C36.521 8.58791 21.8428 12.5209 15.2154 23.9999\"stroke-width=4 stroke-linecap=round stroke-linejoin=round>`);\nconst LoaderIcon = (props) => {\n  const theme = useTheme();\n  const size = () => props.size || \"xs\";\n  const fill = () => props.fill || theme.colors.icon.tertiary;\n  const rotateAnimation = h`\n        0% {\n          transform: rotate(0deg);\n        }\n        100% {\n          transform: rotate(360deg);\n        }\n    `;\n  const svgClass = u`\n        animation: ${rotateAnimation} 1s linear infinite;\n    `;\n  return memo(() => memo(() => size() === \"xs\")() ? (() => {\n    var _el$ = _tmpl$$n(), _el$2 = _el$.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = classnames__WEBPACK_IMPORTED_MODULE_3__(svgClass, props.class), _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })() : memo(() => size() === \"s\")() ? (() => {\n    var _el$3 = _tmpl$2$2(), _el$4 = _el$3.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$3 = classnames__WEBPACK_IMPORTED_MODULE_3__(svgClass, props.class), _v$4 = fill();\n      _v$3 !== _p$.e && setAttribute(_el$3, \"class\", _p$.e = _v$3);\n      _v$4 !== _p$.t && setAttribute(_el$4, \"fill\", _p$.t = _v$4);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$3;\n  })() : (() => {\n    var _el$5 = _tmpl$3(), _el$6 = _el$5.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$5 = classnames__WEBPACK_IMPORTED_MODULE_3__(svgClass, props.class), _v$6 = fill();\n      _v$5 !== _p$.e && setAttribute(_el$5, \"class\", _p$.e = _v$5);\n      _v$6 !== _p$.t && setAttribute(_el$6, \"stroke\", _p$.t = _v$6);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$5;\n  })());\n};\nvar _tmpl$$m = /* @__PURE__ */ template$1(`<svg width=158 height=28 viewBox=\"0 0 158 28\"fill=none xmlns=http://www.w3.org/2000/svg><path fill-rule=evenodd clip-rule=evenodd d=\"M28 14.001C28 21.733 21.732 28.001 14 28.001C6.26801 28.001 0 21.733 0 14.001C0 6.26899 6.26801 0.000976562 14 0.000976562C21.732 0.000976562 28 6.26899 28 14.001ZM9.21931 8.00098H18.7801H18.7813C20.538 8.00098 21.6522 9.89966 20.7691 11.4302L14.8672 21.6576C14.4822 22.3254 13.5172 22.3254 13.1322 21.6576L7.23158 11.4302C6.34721 9.89726 7.4614 8.00098 9.21931 8.00098ZM13.1262 18.5882V9.74806H9.21811C8.78976 9.74806 8.53708 10.2029 8.74163 10.5578L11.8423 16.1035L13.1262 18.5882ZM16.1559 16.1047L19.2554 10.5566C19.4599 10.2017 19.2073 9.74685 18.7789 9.74685H14.8709V18.5906L16.1559 16.1047Z\"fill=#0098EA></path><path d=\"M18.7802 8.00098H9.21936C7.46145 8.00098 6.34727 9.89726 7.23164 11.4302L13.1322 21.6576C13.5173 22.3254 14.4823 22.3254 14.8673 21.6576L20.7691 11.4302C21.6523 9.89966 20.5381 8.00098 18.7814 8.00098H18.7802ZM13.1274 18.5906L11.8424 16.1035L8.74168 10.5578C8.53714 10.2029 8.78981 9.74806 9.21816 9.74806H13.1262V18.5918L13.1274 18.5906ZM19.2555 10.5566L16.156 16.1047L14.8709 18.5906V9.74685H18.779C19.2073 9.74685 19.46 10.2017 19.2555 10.5566Z\"fill=white></path><path fill-rule=evenodd clip-rule=evenodd d=\"M51.7483 22.1967C55.7182 22.1967 58.9609 18.954 58.9609 14.9841C58.9609 11.0142 55.7182 7.77148 51.7483 7.77148C47.7588 7.77148 44.5357 11.0142 44.5357 14.9841C44.5357 18.954 47.7588 22.1967 51.7483 22.1967ZM51.7483 19.1702C49.4686 19.1702 47.6802 17.2442 47.6802 14.9841C47.6802 12.724 49.4686 10.798 51.7483 10.798C54.0084 10.798 55.7968 12.724 55.7968 14.9841C55.7968 17.2442 54.0084 19.1702 51.7483 19.1702ZM37.0698 21.9609H40.2142V10.9946H44.2843V8.00732H33V10.9946H37.0698V21.9609ZM69.9379 8.00732H73.0823V21.9609H70.3899L63.59 13.3333V21.9609H60.4652V8.00732H63.1576L69.9379 16.6153V8.00732ZM79.2259 14.9887C79.2259 10.9202 82.351 7.77539 86.4982 7.77539C89.8592 7.77539 92.5519 9.95709 93.2202 12.6891H90.7437C90.154 11.0971 88.4637 9.9964 86.4982 9.9964C83.5893 9.9964 81.5452 12.1781 81.5452 14.9887C81.5452 17.7994 83.5893 19.9811 86.4982 19.9811C88.4637 19.9811 90.154 18.8804 90.7437 17.2884H93.2202C92.5519 20.0204 89.8592 22.2021 86.4982 22.2021C82.351 22.2021 79.2259 19.0573 79.2259 14.9887ZM104.584 17.0525C104.584 19.9025 102.343 22.1628 99.4342 22.1628C96.5253 22.1628 94.2846 19.9025 94.2846 17.0525C94.2846 14.2025 96.5253 11.9422 99.4342 11.9422C102.343 11.9422 104.584 14.2025 104.584 17.0525ZM96.4663 17.0525C96.4663 18.8018 97.6849 20.158 99.4342 20.158C101.164 20.158 102.382 18.8018 102.382 17.0525C102.382 15.3032 101.164 13.947 99.4342 13.947C97.6849 13.947 96.4663 15.3032 96.4663 17.0525ZM108.626 12.1388H106.463V21.9662H108.626V17.1311C108.626 15.0281 109.726 13.9077 111.161 13.9077C112.419 13.9077 113.205 14.8512 113.205 16.4039V21.9662H115.367V16.0501C115.367 13.5539 113.893 11.9422 111.613 11.9422C110.335 11.9422 109.215 12.4926 108.626 13.4753V12.1388ZM117.839 12.1388H120.001V13.4753C120.59 12.4926 121.711 11.9422 122.988 11.9422C125.268 11.9422 126.742 13.5539 126.742 16.0501V21.9662H124.58V16.4039C124.58 14.8512 123.794 13.9077 122.536 13.9077C121.101 13.9077 120.001 15.0281 120.001 17.1311V21.9662H117.839V12.1388ZM133.558 22.1628C136.054 22.1628 137.823 20.728 138.373 18.8804H136.113C135.661 19.8238 134.717 20.2563 133.636 20.2563C131.887 20.2563 130.747 19.077 130.668 17.5832H138.491C138.688 14.2419 136.585 11.9422 133.577 11.9422C130.551 11.9422 128.526 14.1436 128.526 17.0525C128.526 20.0007 130.629 22.1628 133.558 22.1628ZM130.747 16.0501C131.042 14.5367 132.162 13.7505 133.518 13.7505C134.717 13.7505 135.838 14.4581 136.172 16.0501H130.747ZM149.851 18.3694C149.32 20.5511 147.453 22.1628 144.859 22.1628C141.871 22.1628 139.709 19.8828 139.709 17.0525C139.709 14.2222 141.871 11.9422 144.859 11.9422C147.453 11.9422 149.32 13.5539 149.851 15.7356H147.571C147.178 14.6743 146.215 13.9077 144.859 13.9077C143.109 13.9077 141.91 15.2246 141.91 17.0525C141.91 18.8804 143.109 20.1973 144.859 20.1973C146.215 20.1973 147.178 19.4307 147.571 18.3694H149.851ZM155.75 22.0645C156.418 22.0645 156.929 21.9859 157.362 21.8483V19.9221C157.047 20.0401 156.615 20.1187 156.202 20.1187C155.082 20.1187 154.551 19.6666 154.551 18.448V14.065H157.362V12.1388H154.551V9.40675H152.389V12.1388H150.345V14.065H152.389V18.8018C152.389 21.0228 153.863 22.0645 155.75 22.0645Z\">`);\nconst TonConnectBrand = () => {\n  const theme = useTheme();\n  const fill = () => theme.theme === THEME.DARK ? theme.colors.constant.white : theme.colors.constant.black;\n  return (() => {\n    var _el$ = _tmpl$$m(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling, _el$4 = _el$3.nextSibling;\n    createRenderEffect(() => setAttribute(_el$4, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$l = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M5.56608 4.42584C5.82527 3.32158 6.8176 2.5 8.00001 2.5C9.38072 2.5 10.5 3.61929 10.5 5C10.5 5.63026 10.3391 6.0386 10.1264 6.34455C9.90018 6.66993 9.58561 6.92478 9.18864 7.20877C9.12579 7.25372 9.05873 7.30025 8.9887 7.34883C8.27392 7.84472 7.25001 8.55507 7.25001 10V10.25C7.25001 10.6642 7.5858 11 8.00001 11C8.41422 11 8.75001 10.6642 8.75001 10.25V10C8.75001 9.36502 9.10777 9.1096 9.94554 8.51149L10.0614 8.42873C10.4769 8.13147 10.9748 7.75194 11.358 7.20076C11.7547 6.63015 12 5.91973 12 5C12 2.79086 10.2091 1 8.00001 1C6.10564 1 4.5205 2.31615 4.10577 4.08308C4.01112 4.48634 4.26129 4.88997 4.66454 4.98462C5.0678 5.07927 5.47143 4.8291 5.56608 4.42584ZM8.00001 15C8.60752 15 9.10001 14.5075 9.10001 13.9C9.10001 13.2925 8.60752 12.8 8.00001 12.8C7.39249 12.8 6.90001 13.2925 6.90001 13.9C6.90001 14.5075 7.39249 15 8.00001 15Z\">`);\nconst QuestionIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    var _el$ = _tmpl$$l(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$k = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M9.98156 8.75C9.84854 11.4328 9.01206 13.5 8 13.5C6.98794 13.5 6.15146 11.4328 6.01844 8.75H9.98156ZM11.4832 8.75C11.4217 10.1155 11.1929 11.3869 10.8239 12.4017C10.7734 12.5405 10.7188 12.6789 10.6595 12.8154C12.1454 11.993 13.2103 10.5029 13.4493 8.75H11.4832ZM13.4493 7.25H11.4832C11.4217 5.88453 11.1929 4.61314 10.8239 3.5983C10.7734 3.4595 10.7188 3.32111 10.6595 3.18459C12.1454 4.00697 13.2103 5.49709 13.4493 7.25ZM9.98156 7.25H6.01844C6.15144 4.56764 6.98769 2.50062 7.99955 2.5H8C9.01206 2.5 9.84854 4.56724 9.98156 7.25ZM4.51678 7.25C4.57826 5.88453 4.80706 4.61314 5.1761 3.5983C5.22657 3.4595 5.28124 3.32111 5.3405 3.18459C3.85463 4.00697 2.78972 5.49709 2.55071 7.25H4.51678ZM2.55071 8.75C2.78972 10.5029 3.85463 11.993 5.3405 12.8154C5.28124 12.6789 5.22657 12.5405 5.1761 12.4017C4.80706 11.3869 4.57826 10.1155 4.51678 8.75H2.55071ZM15 8C15 11.866 11.866 15 8 15C4.13401 15 1 11.866 1 8C1 4.13401 4.13401 1 8 1C11.866 1 15 4.13401 15 8Z\">`);\nconst BrowserIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.primary;\n  return (() => {\n    var _el$ = _tmpl$$k(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$j = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M2.5 4.8C2.5 3.11984 2.5 2.27976 2.82698 1.63803C3.1146 1.07354 3.57354 0.614601 4.13803 0.32698C4.77976 0 5.61984 0 7.3 0H8.7C10.3802 0 11.2202 0 11.862 0.32698C12.4265 0.614601 12.8854 1.07354 13.173 1.63803C13.5 2.27976 13.5 3.11984 13.5 4.8V11.2C13.5 12.8802 13.5 13.7202 13.173 14.362C12.8854 14.9265 12.4265 15.3854 11.862 15.673C11.2202 16 10.3802 16 8.7 16H7.3C5.61984 16 4.77976 16 4.13803 15.673C3.57354 15.3854 3.1146 14.9265 2.82698 14.362C2.5 13.7202 2.5 12.8802 2.5 11.2V4.8ZM4 3.9C4 3.05992 4 2.63988 4.16349 2.31901C4.3073 2.03677 4.53677 1.8073 4.81901 1.66349C5.13988 1.5 5.55992 1.5 6.4 1.5H9.6C10.4401 1.5 10.8601 1.5 11.181 1.66349C11.4632 1.8073 11.6927 2.03677 11.8365 2.31901C12 2.63988 12 3.05992 12 3.9V12.1C12 12.9401 12 13.3601 11.8365 13.681C11.6927 13.9632 11.4632 14.1927 11.181 14.3365C10.8601 14.5 10.4401 14.5 9.6 14.5H6.4C5.55992 14.5 5.13988 14.5 4.81901 14.3365C4.53677 14.1927 4.3073 13.9632 4.16349 13.681C4 13.3601 4 12.9401 4 12.1V3.9ZM7 2.5C6.58579 2.5 6.25 2.83579 6.25 3.25C6.25 3.66421 6.58579 4 7 4H9C9.41421 4 9.75 3.66421 9.75 3.25C9.75 2.83579 9.41421 2.5 9 2.5H7Z\">`);\nconst MobileIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.primary;\n  return (() => {\n    var _el$ = _tmpl$$j(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$i = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M1.5 6.8C1.5 5.11984 1.5 4.27976 1.82698 3.63803C2.1146 3.07354 2.57354 2.6146 3.13803 2.32698C3.77976 2 4.61984 2 6.3 2H9.7C11.3802 2 12.2202 2 12.862 2.32698C13.4265 2.6146 13.8854 3.07354 14.173 3.63803C14.5 4.27976 14.5 5.11984 14.5 6.8V11.5H15.25C15.6642 11.5 16 11.8358 16 12.25C16 12.6642 15.6642 13 15.25 13H0.75C0.335786 13 0 12.6642 0 12.25C0 11.8358 0.335786 11.5 0.75 11.5H1.5V6.8ZM3 11.5H13V5.9C13 5.05992 13 4.63988 12.8365 4.31901C12.6927 4.03677 12.4632 3.8073 12.181 3.66349C11.8601 3.5 11.4401 3.5 10.6 3.5H5.4C4.55992 3.5 4.13988 3.5 3.81901 3.66349C3.53677 3.8073 3.3073 4.03677 3.16349 4.31901C3 4.63988 3 5.05992 3 5.9V11.5Z\">`);\nconst DesktopIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.primary;\n  return (() => {\n    var _el$ = _tmpl$$i(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$h = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=17 height=16 viewBox=\"0 0 17 16\"fill=none><g clip-path=url(#clip0_3676_1603)><path fill-rule=evenodd clip-rule=evenodd d=\"M15.5 1.25049C15.5 0.836275 15.1642 0.500488 14.75 0.500488C14.3358 0.500488 14 0.836275 14 1.25049V3.67012C12.7187 2.04487 10.7318 1.00049 8.5 1.00049C4.63401 1.00049 1.5 4.1345 1.5 8.00049C1.5 11.8665 4.63401 15.0005 8.5 15.0005C11.6844 15.0005 14.3703 12.8748 15.2199 9.96661C15.3361 9.56902 15.1079 9.15254 14.7103 9.03638C14.3127 8.92023 13.8962 9.14838 13.7801 9.54597C13.1123 11.8319 11 13.5005 8.5 13.5005C5.46243 13.5005 3 11.0381 3 8.00049C3 4.96292 5.46243 2.50049 8.5 2.50049C10.321 2.50049 11.9363 3.3855 12.9377 4.75049H10.5C10.0858 4.75049 9.75 5.08627 9.75 5.50049C9.75 5.9147 10.0858 6.25049 10.5 6.25049H14.75C15.1642 6.25049 15.5 5.9147 15.5 5.50049V1.25049Z\"></path></g><defs><clipPath id=clip0_3676_1603><rect width=16 height=16 fill=white transform=\"translate(0.5 0.000488281)\">`);\nconst RetryIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.accent;\n  return (() => {\n    var _el$ = _tmpl$$h(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild;\n    createRenderEffect(() => setAttribute(_el$3, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$g = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M13 4.06119V6.75053C13 7.16474 13.3358 7.50053 13.75 7.50053C14.1642 7.50053 14.5 7.16474 14.5 6.75053V2.75053L14.5 2.72807C14.5001 2.63191 14.5003 2.49627 14.4842 2.37627C14.4638 2.22503 14.4063 1.99261 14.2071 1.79342C14.0079 1.59423 13.7755 1.5367 13.6243 1.51637C13.5043 1.50023 13.3686 1.50039 13.2725 1.50051L13.25 1.50053H9.25C8.83579 1.50053 8.5 1.83631 8.5 2.25053C8.5 2.66474 8.83579 3.00053 9.25 3.00053H11.9393L7.21967 7.7202C6.92678 8.01309 6.92678 8.48796 7.21967 8.78086C7.51256 9.07375 7.98744 9.07375 8.28033 8.78086L13 4.06119ZM5.85 1.50053H5.81903H5.81899C5.21528 1.50052 4.71702 1.50051 4.31113 1.53367C3.88956 1.56812 3.50203 1.64204 3.13803 1.82751C2.57354 2.11513 2.1146 2.57407 1.82698 3.13856C1.64151 3.50256 1.56759 3.89009 1.53315 4.31166C1.49998 4.71755 1.49999 5.21581 1.5 5.81953V5.81955V5.85053V10.1505V10.1815V10.1815C1.49999 10.7852 1.49998 11.2835 1.53315 11.6894C1.56759 12.111 1.64151 12.4985 1.82698 12.8625C2.1146 13.427 2.57354 13.8859 3.13803 14.1735C3.50203 14.359 3.88956 14.4329 4.31113 14.4674C4.71702 14.5005 5.21527 14.5005 5.81897 14.5005H5.81901H5.85H10.15H10.181H10.181C10.7847 14.5005 11.283 14.5005 11.6889 14.4674C12.1104 14.4329 12.498 14.359 12.862 14.1735C13.4265 13.8859 13.8854 13.427 14.173 12.8625C14.3585 12.4985 14.4324 12.111 14.4669 11.6894C14.5 11.2835 14.5 10.7853 14.5 10.1816V10.1815V10.1505V9.75053C14.5 9.33631 14.1642 9.00053 13.75 9.00053C13.3358 9.00053 13 9.33631 13 9.75053V10.1505C13 10.793 12.9994 11.2297 12.9718 11.5672C12.945 11.8961 12.8963 12.0642 12.8365 12.1815C12.6927 12.4638 12.4632 12.6932 12.181 12.837C12.0637 12.8968 11.8955 12.9455 11.5667 12.9724C11.2292 12.9999 10.7924 13.0005 10.15 13.0005H5.85C5.20757 13.0005 4.77085 12.9999 4.43328 12.9724C4.10447 12.9455 3.93632 12.8968 3.81902 12.837C3.53677 12.6932 3.3073 12.4638 3.16349 12.1815C3.10372 12.0642 3.05503 11.8961 3.02816 11.5672C3.00058 11.2297 3 10.793 3 10.1505V5.85053C3 5.20809 3.00058 4.77137 3.02816 4.43381C3.05503 4.10499 3.10372 3.93684 3.16349 3.81954C3.3073 3.5373 3.53677 3.30783 3.81902 3.16402C3.93632 3.10425 4.10447 3.05556 4.43328 3.02869C4.77085 3.00111 5.20757 3.00053 5.85 3.00053H6.25C6.66422 3.00053 7 2.66474 7 2.25053C7 1.83631 6.66422 1.50053 6.25 1.50053H5.85Z\">`);\nconst LinkIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.accent;\n  return (() => {\n    var _el$ = _tmpl$$g(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$f = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=17 height=16 viewBox=\"0 0 17 16\"fill=none><g clip-path=url(#clip0_3676_1274)><path fill-rule=evenodd clip-rule=evenodd d=\"M1.82698 2.63901C1.5 3.28074 1.5 4.12082 1.5 5.80098V8.80098V9.00098V10.201C1.5 11.8811 1.5 12.7212 1.82698 13.3629C2.1146 13.9274 2.57354 14.3864 3.13803 14.674C3.77976 15.001 4.61984 15.001 6.3 15.001H11.7C13.3802 15.001 14.2202 15.001 14.862 14.674C15.4265 14.3864 15.8854 13.9274 16.173 13.3629C16.5 12.7212 16.5 11.8811 16.5 10.201V8.80098C16.5 7.12082 16.5 6.28074 16.173 5.63901C15.8854 5.07452 15.4265 4.61558 14.862 4.32796C14.743 4.26733 14.6172 4.21795 14.4805 4.17772C14.4501 3.49449 14.3722 3.02994 14.173 2.63901C13.8854 2.07452 13.4265 1.61558 12.862 1.32796C12.2202 1.00098 11.3802 1.00098 9.7 1.00098H6.3C4.61984 1.00098 3.77976 1.00098 3.13803 1.32796C2.57354 1.61558 2.1146 2.07452 1.82698 2.63901ZM12.9861 4.00942C12.9684 3.7108 12.9281 3.49982 12.8365 3.31999C12.6927 3.03775 12.4632 2.80828 12.181 2.66447C11.8601 2.50098 11.4401 2.50098 10.6 2.50098H5.4C4.55992 2.50098 4.13988 2.50098 3.81901 2.66447C3.53677 2.80828 3.3073 3.03775 3.16349 3.31999C3.03615 3.56991 3.00799 3.88 3.00177 4.40188C3.04646 4.37612 3.09189 4.35146 3.13803 4.32796C3.77976 4.00098 4.61984 4.00098 6.3 4.00098H11.7C12.1966 4.00098 12.6197 4.00098 12.9861 4.00942ZM3 7.90098V8.10098C3 8.47468 3 8.76527 3.01439 9.00098H3V11.101C3 11.9411 3 12.3611 3.16349 12.682C3.3073 12.9642 3.53677 13.1937 3.81901 13.3375C4.13988 13.501 4.55992 13.501 5.4 13.501H12.6C13.4401 13.501 13.8601 13.501 14.181 13.3375C14.4632 13.1937 14.6927 12.9642 14.8365 12.682C15 12.3611 15 11.9411 15 11.101V7.90098C15 7.0609 15 6.64086 14.8365 6.31999C14.6927 6.03775 14.4632 5.80828 14.181 5.66447C13.8601 5.50098 13.4401 5.50098 12.6 5.50098H5.4C4.55992 5.50098 4.13988 5.50098 3.81901 5.66447C3.53677 5.80828 3.3073 6.03775 3.16349 6.31999C3 6.64086 3 7.0609 3 7.90098ZM10.5 9.75098C10.5 9.33676 10.8358 9.00098 11.25 9.00098H12.75C13.1642 9.00098 13.5 9.33676 13.5 9.75098C13.5 10.1652 13.1642 10.501 12.75 10.501H11.25C10.8358 10.501 10.5 10.1652 10.5 9.75098Z\"></path></g><defs><clipPath id=clip0_3676_1274><rect width=16 height=16 fill=white transform=\"translate(0.5 0.000976562)\">`);\nconst WalletIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.accent;\n  return (() => {\n    var _el$ = _tmpl$$f(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild;\n    createRenderEffect(() => setAttribute(_el$3, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$e = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=48 height=48 viewBox=\"0 0 48 48\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M39.6319 16.8719C38.3212 16.2041 36.7002 16.0478 34 16.0112V11C34 5.47715 29.5228 1 24 1C18.4772 1 14 5.47715 14 11V16.0112C11.2998 16.0478 9.6788 16.2041 8.36808 16.8719C6.86278 17.6389 5.63893 18.8628 4.87195 20.3681C4 22.0794 4 24.3196 4 28.8V32.2C4 36.6804 4 38.9206 4.87195 40.6319C5.63893 42.1372 6.86278 43.3611 8.36808 44.1281C10.0794 45 12.3196 45 16.8 45H31.2C35.6804 45 37.9206 45 39.6319 44.1281C41.1372 43.3611 42.3611 42.1372 43.1281 40.6319C44 38.9206 44 36.6804 44 32.2V28.8C44 24.3196 44 22.0794 43.1281 20.3681C42.3611 18.8628 41.1372 17.6389 39.6319 16.8719ZM31 11V16H17V11C17 7.13401 20.134 4 24 4C27.866 4 31 7.13401 31 11ZM7.54497 21.73C7 22.7996 7 24.1997 7 27V34C7 36.8003 7 38.2004 7.54497 39.27C8.02433 40.2108 8.78924 40.9757 9.73005 41.455C10.7996 42 12.1997 42 15 42H33C35.8003 42 37.2004 42 38.27 41.455C39.2108 40.9757 39.9757 40.2108 40.455 39.27C41 38.2004 41 36.8003 41 34V27C41 24.1997 41 22.7996 40.455 21.73C39.9757 20.7892 39.2108 20.0243 38.27 19.545C37.2004 19 35.8003 19 33 19H15C12.1997 19 10.7996 19 9.73005 19.545C8.78924 20.0243 8.02433 20.7892 7.54497 21.73ZM24 24C23.1716 24 22.5 24.6716 22.5 25.5V29.5C22.5 30.3284 23.1716 31 24 31C24.8284 31 25.5 30.3284 25.5 29.5V25.5C25.5 24.6716 24.8284 24 24 24Z\">`);\nconst SecurityIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    var _el$ = _tmpl$$e(), _el$2 = _el$.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = props.class, _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })();\n};\nvar _tmpl$$d = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=48 height=48 viewBox=\"0 0 48 48\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M37.485 37.3849C40.894 33.9506 43 29.2212 43 24C43 13.5066 34.4934 5 24 5C13.5066 5 5 13.5066 5 24C5 29.2213 7.1061 33.9507 10.5151 37.385C13.3583 32.9438 18.3354 30 24.0001 30C29.6647 30 34.6418 32.9437 37.485 37.3849ZM35.1809 39.3635C32.9143 35.5532 28.7554 33 24.0001 33C19.2448 33 15.0858 35.5533 12.8193 39.3636C15.9564 41.6506 19.8206 43 24 43C28.1795 43 32.0437 41.6505 35.1809 39.3635ZM24 46C36.1503 46 46 36.1503 46 24C46 11.8497 36.1503 2 24 2C11.8497 2 2 11.8497 2 24C2 36.1503 11.8497 46 24 46ZM24 24C26.7614 24 29 21.7614 29 19C29 16.2386 26.7614 14 24 14C21.2386 14 19 16.2386 19 19C19 21.7614 21.2386 24 24 24ZM24 27C28.4183 27 32 23.4183 32 19C32 14.5817 28.4183 11 24 11C19.5817 11 16 14.5817 16 19C16 23.4183 19.5817 27 24 27Z\">`);\nconst PersonalityIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    var _el$ = _tmpl$$d(), _el$2 = _el$.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = props.class, _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })();\n};\nvar _tmpl$$c = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=48 height=48 viewBox=\"0 0 48 48\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M34.5607 4.43934C33.9749 3.85355 33.0251 3.85355 32.4393 4.43934C31.8536 5.02513 31.8536 5.97487 32.4393 6.56066L37.8787 12H10.5C9.67157 12 9 12.6716 9 13.5C9 14.3284 9.67157 15 10.5 15H37.8787L32.4393 20.4393C31.8536 21.0251 31.8536 21.9749 32.4393 22.5607C33.0251 23.1464 33.9749 23.1464 34.5607 22.5607L42.5607 14.5607C43.1464 13.9749 43.1464 13.0251 42.5607 12.4393L34.5607 4.43934ZM13.4393 25.4393C14.0251 24.8536 14.9749 24.8536 15.5607 25.4393C16.1464 26.0251 16.1464 26.9749 15.5607 27.5607L10.1213 33H37.5C38.3284 33 39 33.6716 39 34.5C39 35.3284 38.3284 36 37.5 36H10.1213L15.5607 41.4393C16.1464 42.0251 16.1464 42.9749 15.5607 43.5607C14.9749 44.1464 14.0251 44.1464 13.4393 43.5607L5.43934 35.5607C4.85355 34.9749 4.85355 34.0251 5.43934 33.4393L13.4393 25.4393Z\">`);\nconst SwapIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    var _el$ = _tmpl$$c(), _el$2 = _el$.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = props.class, _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })();\n};\nvar _tmpl$$b = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=28 height=28 viewBox=\"0 0 28 28\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M1.75 12.002C1.75 9.20169 1.75 7.80156 2.29497 6.732C2.77433 5.79119 3.53924 5.02629 4.48005 4.54692C5.54961 4.00195 6.94974 4.00195 9.75 4.00195H17.25C20.0503 4.00195 21.4504 4.00195 22.52 4.54692C23.4608 5.02629 24.2257 5.79119 24.705 6.732C24.8256 6.96861 24.9195 7.2214 24.9926 7.50195H21.5C19.6377 7.50195 18.7065 7.50195 17.9609 7.77334C16.711 8.22828 15.7263 9.21291 15.2714 10.4629C15 11.2085 15 12.1396 15 14.002C15 15.8643 15 16.7954 15.2714 17.541C15.7263 18.791 16.711 19.7756 17.9609 20.2306C18.7065 20.502 19.6377 20.502 21.5 20.502H24.9926C24.9195 20.7825 24.8256 21.0353 24.705 21.2719C24.2257 22.2127 23.4608 22.9776 22.52 23.457C21.4504 24.002 20.0503 24.002 17.25 24.002H9.75C6.94974 24.002 5.54961 24.002 4.48005 23.457C3.53924 22.9776 2.77433 22.2127 2.29497 21.2719C1.75 20.2023 1.75 18.8022 1.75 16.002V12.002ZM16.4999 13.802C16.4999 12.1218 16.4999 11.2817 16.8269 10.64C17.1145 10.0755 17.5735 9.61656 18.138 9.32894C18.7797 9.00196 19.6198 9.00196 21.2999 9.00196H23.1999C24.8801 9.00196 25.7202 9.00196 26.3619 9.32894C26.9264 9.61656 27.3853 10.0755 27.673 10.64C27.9999 11.2817 27.9999 12.1218 27.9999 13.802V14.202C27.9999 15.8821 27.9999 16.7222 27.673 17.3639C27.3853 17.9284 26.9264 18.3874 26.3619 18.675C25.7202 19.002 24.8801 19.002 23.1999 19.002H21.2999C19.6198 19.002 18.7797 19.002 18.138 18.675C17.5735 18.3874 17.1145 17.9284 16.8269 17.3639C16.4999 16.7222 16.4999 15.8821 16.4999 14.202V13.802ZM22.4999 14.002C22.4999 14.9685 21.7164 15.752 20.7499 15.752C19.7834 15.752 18.9999 14.9685 18.9999 14.002C18.9999 13.0355 19.7834 12.252 20.7499 12.252C21.7164 12.252 22.4999 13.0355 22.4999 14.002Z\">`);\nconst AtWalletIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.constant.white;\n  return (() => {\n    var _el$ = _tmpl$$b(), _el$2 = _el$.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = props.class, _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })();\n};\nvar _tmpl$$a = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=28 height=28 viewBox=\"0 0 28 28\"><path fill-rule=evenodd clip-rule=evenodd d=\"M10.0001 10.0001C10.0016 8.02333 10.0267 6.98719 10.436 6.18404C10.8195 5.43139 11.4314 4.81947 12.184 4.43597C13.0397 4 14.1598 4 16.4 4H17.6C19.8402 4 20.9603 4 21.816 4.43597C22.5686 4.81947 23.1805 5.43139 23.564 6.18404C24 7.03969 24 8.15979 24 10.4V11.6C24 13.8402 24 14.9603 23.564 15.816C23.1805 16.5686 22.5686 17.1805 21.816 17.564C21.0128 17.9733 19.9767 17.9984 17.9999 17.9999C17.9984 19.9767 17.9733 21.0128 17.564 21.816C17.1805 22.5686 16.5686 23.1805 15.816 23.564C14.9603 24 13.8402 24 11.6 24H10.4C8.15979 24 7.03969 24 6.18404 23.564C5.43139 23.1805 4.81947 22.5686 4.43597 21.816C4 20.9603 4 19.8402 4 17.6V16.4C4 14.1598 4 13.0397 4.43597 12.184C4.81947 11.4314 5.43139 10.8195 6.18404 10.436C6.98719 10.0267 8.02333 10.0016 10.0001 10.0001ZM10 11.5H9.5C8.09987 11.5 7.3998 11.5 6.86502 11.7725C6.39462 12.0122 6.01217 12.3946 5.77248 12.865C5.5 13.3998 5.5 14.0999 5.5 15.5V18.5C5.5 19.9001 5.5 20.6002 5.77248 21.135C6.01217 21.6054 6.39462 21.9878 6.86502 22.2275C7.3998 22.5 8.09987 22.5 9.5 22.5H12.5C13.9001 22.5 14.6002 22.5 15.135 22.2275C15.6054 21.9878 15.9878 21.6054 16.2275 21.135C16.5 20.6002 16.5 19.9001 16.5 18.5V18H16.4C14.1598 18 13.0397 18 12.184 17.564C11.4314 17.1805 10.8195 16.5686 10.436 15.816C10 14.9603 10 13.8402 10 11.6V11.5ZM11.5 9.5C11.5 8.09987 11.5 7.3998 11.7725 6.86502C12.0122 6.39462 12.3946 6.01217 12.865 5.77248C13.3998 5.5 14.0999 5.5 15.5 5.5H18.5C19.9001 5.5 20.6002 5.5 21.135 5.77248C21.6054 6.01217 21.9878 6.39462 22.2275 6.86502C22.5 7.3998 22.5 8.09987 22.5 9.5V12.5C22.5 13.9001 22.5 14.6002 22.2275 15.135C21.9878 15.6054 21.6054 15.9878 21.135 16.2275C20.6002 16.5 19.9001 16.5 18.5 16.5H15.5C14.0999 16.5 13.3998 16.5 12.865 16.2275C12.3946 15.9878 12.0122 15.6054 11.7725 15.135C11.5 14.6002 11.5 13.9001 11.5 12.5V9.5Z\">`);\nconst CopyLightIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    var _el$ = _tmpl$$a(), _el$2 = _el$.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = fill(), _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$, \"fill\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })();\n};\nvar _tmpl$$9 = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=17 viewBox=\"0 0 16 17\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M1 4.12695C1 3.07754 1 2.55284 1.19202 2.14684C1.38986 1.72856 1.7266 1.39181 2.14489 1.19397C2.55088 1.00195 3.07559 1.00195 4.125 1.00195C5.17441 1.00195 5.69912 1.00195 6.10511 1.19397C6.5234 1.39181 6.86014 1.72856 7.05798 2.14684C7.25 2.55284 7.25 3.07754 7.25 4.12695C7.25 5.17636 7.25 5.70107 7.05798 6.10706C6.86014 6.52535 6.5234 6.8621 6.10511 7.05993C5.69912 7.25195 5.17441 7.25195 4.125 7.25195C3.07559 7.25195 2.55088 7.25195 2.14489 7.05993C1.7266 6.8621 1.38986 6.52535 1.19202 6.10706C1 5.70107 1 5.17636 1 4.12695ZM2.5 3.30195C2.5 3.02193 2.5 2.88191 2.5545 2.77496C2.60243 2.68088 2.67892 2.60439 2.773 2.55645C2.87996 2.50195 3.01997 2.50195 3.3 2.50195H4.95C5.23003 2.50195 5.37004 2.50195 5.477 2.55645C5.57108 2.60439 5.64757 2.68088 5.6955 2.77496C5.75 2.88191 5.75 3.02193 5.75 3.30195V4.95195C5.75 5.23198 5.75 5.37199 5.6955 5.47895C5.64757 5.57303 5.57108 5.64952 5.477 5.69746C5.37004 5.75195 5.23003 5.75195 4.95 5.75195H3.3C3.01997 5.75195 2.87996 5.75195 2.773 5.69746C2.67892 5.64952 2.60243 5.57303 2.5545 5.47895C2.5 5.37199 2.5 5.23198 2.5 4.95195V3.30195ZM1 11.877C1 10.8275 1 10.3028 1.19202 9.89684C1.38986 9.47856 1.7266 9.14181 2.14489 8.94397C2.55088 8.75195 3.07559 8.75195 4.125 8.75195C5.17441 8.75195 5.69912 8.75195 6.10511 8.94397C6.5234 9.14181 6.86014 9.47856 7.05798 9.89684C7.25 10.3028 7.25 10.8275 7.25 11.877C7.25 12.9264 7.25 13.4511 7.05798 13.8571C6.86014 14.2753 6.5234 14.6121 6.10511 14.8099C5.69912 15.002 5.17441 15.002 4.125 15.002C3.07559 15.002 2.55088 15.002 2.14489 14.8099C1.7266 14.6121 1.38986 14.2753 1.19202 13.8571C1 13.4511 1 12.9264 1 11.877ZM2.5 11.052C2.5 10.7719 2.5 10.6319 2.5545 10.525C2.60243 10.4309 2.67892 10.3544 2.773 10.3064C2.87996 10.252 3.01997 10.252 3.3 10.252H4.95C5.23003 10.252 5.37004 10.252 5.477 10.3064C5.57108 10.3544 5.64757 10.4309 5.6955 10.525C5.75 10.6319 5.75 10.7719 5.75 11.052V12.702C5.75 12.982 5.75 13.122 5.6955 13.2289C5.64757 13.323 5.57108 13.3995 5.477 13.4475C5.37004 13.502 5.23003 13.502 4.95 13.502H3.3C3.01997 13.502 2.87996 13.502 2.773 13.4475C2.67892 13.3995 2.60243 13.323 2.5545 13.2289C2.5 13.122 2.5 12.982 2.5 12.702V11.052ZM8.94202 2.14684C8.75 2.55284 8.75 3.07754 8.75 4.12695C8.75 5.17636 8.75 5.70107 8.94202 6.10706C9.13986 6.52535 9.4766 6.8621 9.89489 7.05993C10.3009 7.25195 10.8256 7.25195 11.875 7.25195C12.9244 7.25195 13.4491 7.25195 13.8551 7.05993C14.2734 6.8621 14.6101 6.52535 14.808 6.10706C15 5.70107 15 5.17636 15 4.12695C15 3.07754 15 2.55284 14.808 2.14684C14.6101 1.72856 14.2734 1.39181 13.8551 1.19397C13.4491 1.00195 12.9244 1.00195 11.875 1.00195C10.8256 1.00195 10.3009 1.00195 9.89489 1.19397C9.4766 1.39181 9.13986 1.72856 8.94202 2.14684ZM10.3045 2.77496C10.25 2.88191 10.25 3.02193 10.25 3.30195V4.95195C10.25 5.23198 10.25 5.37199 10.3045 5.47895C10.3524 5.57303 10.4289 5.64952 10.523 5.69746C10.63 5.75195 10.77 5.75195 11.05 5.75195H12.7C12.98 5.75195 13.12 5.75195 13.227 5.69746C13.3211 5.64952 13.3976 5.57303 13.4455 5.47895C13.5 5.37199 13.5 5.23198 13.5 4.95195V3.30195C13.5 3.02193 13.5 2.88191 13.4455 2.77496C13.3976 2.68088 13.3211 2.60439 13.227 2.55645C13.12 2.50195 12.98 2.50195 12.7 2.50195H11.05C10.77 2.50195 10.63 2.50195 10.523 2.55645C10.4289 2.60439 10.3524 2.68088 10.3045 2.77496ZM8.80727 9.13518C8.75 9.26242 8.75 9.4256 8.75 9.75195C8.75 10.0783 8.75 10.2415 8.80727 10.3687C8.87245 10.5136 8.9884 10.6295 9.13323 10.6947C9.26047 10.752 9.42365 10.752 9.75 10.752C10.0764 10.752 10.2395 10.752 10.3668 10.6947C10.5116 10.6295 10.6276 10.5136 10.6927 10.3687C10.75 10.2415 10.75 10.0783 10.75 9.75195C10.75 9.4256 10.75 9.26242 10.6927 9.13518C10.6276 8.99035 10.5116 8.8744 10.3668 8.80922C10.2395 8.75195 10.0764 8.75195 9.75 8.75195C9.42365 8.75195 9.26047 8.75195 9.13323 8.80922C8.9884 8.8744 8.87245 8.99035 8.80727 9.13518ZM10.87 11.8771C10.87 11.546 10.87 11.3805 10.9289 11.2517C10.9938 11.1098 11.1077 10.9959 11.2497 10.931C11.3784 10.8721 11.5439 10.8721 11.875 10.8721C12.2061 10.8721 12.3716 10.8721 12.5003 10.931C12.6423 10.9959 12.7562 11.1098 12.8211 11.2517C12.88 11.3805 12.88 11.546 12.88 11.8771C12.88 12.2081 12.88 12.3737 12.8211 12.5024C12.7562 12.6444 12.6423 12.7583 12.5003 12.8232C12.3716 12.8821 12.2061 12.8821 11.875 12.8821C11.5439 12.8821 11.3784 12.8821 11.2497 12.8232C11.1077 12.7583 10.9938 12.6444 10.9289 12.5024C10.87 12.3737 10.87 12.2081 10.87 11.8771ZM8.80727 13.3852C8.75 13.5124 8.75 13.6756 8.75 14.002C8.75 14.3283 8.75 14.4915 8.80727 14.6187C8.87245 14.7636 8.9884 14.8795 9.13323 14.9447C9.26047 15.002 9.42365 15.002 9.75 15.002C10.0764 15.002 10.2395 15.002 10.3668 14.9447C10.5116 14.8795 10.6276 14.7636 10.6927 14.6187C10.75 14.4915 10.75 14.3283 10.75 14.002C10.75 13.6756 10.75 13.5124 10.6927 13.3852C10.6276 13.2404 10.5116 13.1244 10.3668 13.0592C10.2395 13.002 10.0764 13.002 9.75 13.002C9.42365 13.002 9.26047 13.002 9.13323 13.0592C8.9884 13.1244 8.87245 13.2404 8.80727 13.3852ZM13 9.75195C13 9.4256 13 9.26242 13.0573 9.13518C13.1224 8.99035 13.2384 8.8744 13.3832 8.80922C13.5105 8.75195 13.6736 8.75195 14 8.75195C14.3264 8.75195 14.4895 8.75195 14.6168 8.80922C14.7616 8.8744 14.8776 8.99035 14.9427 9.13518C15 9.26242 15 9.4256 15 9.75195C15 10.0783 15 10.2415 14.9427 10.3687C14.8776 10.5136 14.7616 10.6295 14.6168 10.6947C14.4895 10.752 14.3264 10.752 14 10.752C13.6736 10.752 13.5105 10.752 13.3832 10.6947C13.2384 10.6295 13.1224 10.5136 13.0573 10.3687C13 10.2415 13 10.0783 13 9.75195ZM13.0573 13.3852C13 13.5124 13 13.6756 13 14.002C13 14.3283 13 14.4915 13.0573 14.6187C13.1224 14.7636 13.2384 14.8795 13.3832 14.9447C13.5105 15.002 13.6736 15.002 14 15.002C14.3264 15.002 14.4895 15.002 14.6168 14.9447C14.7616 14.8795 14.8776 14.7636 14.9427 14.6187C15 14.4915 15 14.3283 15 14.002C15 13.6756 15 13.5124 14.9427 13.3852C14.8776 13.2404 14.7616 13.1244 14.6168 13.0592C14.4895 13.002 14.3264 13.002 14 13.002C13.6736 13.002 13.5105 13.002 13.3832 13.0592C13.2384 13.1244 13.1224 13.2404 13.0573 13.3852Z\">`);\nconst QRIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    var _el$ = _tmpl$$9(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nconst containerBorders = {\n  m: \"16px\",\n  s: \"12px\",\n  none: \"0\"\n};\nconst walletBorders = {\n  m: \"6px\",\n  s: \"6px\",\n  none: \"0\"\n};\nconst FourWalletsCard = styled.div`\n    width: 60px;\n    height: 60px;\n    padding: 8px;\n    margin-bottom: 8px;\n    border-radius: ${(props) => containerBorders[props.theme.borderRadius]};\n    background-color: ${(props) => props.theme.colors.background.tint};\n    display: grid;\n    grid-template: 1fr 1fr / 1fr 1fr;\n    gap: 4px;\n`;\nconst FourWalletsImage = styled(WalletImage)`\n    width: 20px;\n    height: 20px;\n    border-radius: ${(props) => walletBorders[props.theme.borderRadius]};\n`;\nconst FourWalletsItem = (props) => {\n  return createComponent(WalletItem, {\n    get name() {\n      return props.labelLine1;\n    },\n    get secondLine() {\n      return props.labelLine2;\n    },\n    get icon() {\n      return createComponent(FourWalletsCard, {\n        get children() {\n          return createComponent(For, {\n            each: [0, 1, 2, 3],\n            children: (index) => createComponent(FourWalletsImage, {\n              get src() {\n                return props.images[index];\n              }\n            })\n          });\n        }\n      });\n    },\n    onClick: () => props.onClick()\n  });\n};\nconst AT_WALLET_APP_NAME = \"telegram-wallet\";\nconst IMG = {\n  TON: \"https://raw.githubusercontent.com/ton-connect/sdk/main/assets/ton-icon-48.png\",\n  TG: \"https://raw.githubusercontent.com/ton-connect/sdk/main/assets/tg.png\",\n  WALLET_CONNECT: \"https://raw.githubusercontent.com/ton-connect/sdk/main/assets/walletconnect-icon-288.png\"\n};\nfunction isWalletUi(wallet) {\n  return !(\"type\" in wallet) || wallet.type !== \"wallet-connect\";\n}\nconst WalletLabeledItem = (props) => {\n  const [t2] = useI18n();\n  const walletsSecondLine = () => {\n    if (props.wallet.appName === AT_WALLET_APP_NAME) {\n      return void 0;\n    }\n    if (\"isPreferred\" in props.wallet && props.wallet.isPreferred) {\n      return t2(\"walletItem.recent\", {}, \"Recent\");\n    }\n    if (props.wallet.name === \"Tonkeeper\") {\n      return t2(\"walletItem.popular\", {}, \"Popular\");\n    }\n    if (isWalletUi(props.wallet) && (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyInjected)(props.wallet)) {\n      return t2(\"walletItem.installed\", {}, \"Installed\");\n    }\n    return void 0;\n  };\n  return memo(() => memo(() => props.wallet.appName === AT_WALLET_APP_NAME)() ? createComponent(WalletItem, {\n    get icon() {\n      return props.wallet.imageUrl;\n    },\n    get name() {\n      return t2(\"walletItem.walletOn\", {}, \"Wallet in\");\n    },\n    secondLine: \"Telegram\",\n    get badgeUrl() {\n      return IMG.TG;\n    },\n    onClick: () => props.onClick(),\n    get [\"class\"]() {\n      return props.class;\n    }\n  }) : createComponent(WalletItem, {\n    get icon() {\n      return props.wallet.imageUrl;\n    },\n    get name() {\n      return props.wallet.name;\n    },\n    get secondLine() {\n      return walletsSecondLine();\n    },\n    secondLineColorPrimary: false,\n    onClick: () => props.onClick(),\n    get [\"class\"]() {\n      return props.class;\n    }\n  }));\n};\nconst ScrollContainerStyled = styled.div`\n    width: 100%;\n    overflow-y: auto;\n    max-height: ${(props) => props.maxHeight};\n\n    scrollbar-width: none;\n    &&::-webkit-scrollbar {\n        display: none;\n    }\n\n    &&::-webkit-scrollbar-track {\n        background: transparent;\n    }\n\n    &&::-webkit-scrollbar-thumb {\n        display: none;\n    }\n`;\nconst ScrollDivider = styled.div`\n    height: 1px;\n    margin: 0 -24px;\n    width: calc(100% + 48px);\n    opacity: 0.08;\n    background: ${(props) => props.isShown ? props.theme.colors.icon.secondary : \"transparent\"};\n    transition: background 0.15s ease-in-out;\n\n    ${media(\"mobile\")} {\n        width: 100%;\n        margin: 0;\n    }\n`;\nconst [windowHeight, setWindowHeight] = createSignal(((_h = getWindow$1()) == null ? void 0 : _h.innerHeight) || 0);\nif (getWindow$1()) {\n  window.addEventListener(\"resize\", () => setWindowHeight(window.innerHeight));\n}\nconst [isMobile, setIsMobile] = createSignal(isDevice(\"mobile\"));\nconst updateIsMobile = () => setIsMobile(isDevice(\"mobile\"));\nif (getWindow$1()) {\n  window.addEventListener(\"resize\", () => updateIsMobile());\n  window.addEventListener(\"load\", () => updateIsMobile(), { once: true });\n}\nconst ScrollContainer = (props) => {\n  const [scrolled, setScrolled] = createSignal(false);\n  const onScroll = (e2) => {\n    setScrolled(e2.target.scrollTop > 0);\n  };\n  const offset = () => isMobile() ? 150 : 200;\n  const maxHeight = () => props.maxHeight !== void 0 ? `${props.maxHeight}px` : `${windowHeight() - offset()}px`;\n  return [createComponent(ScrollDivider, {\n    get isShown() {\n      return scrolled();\n    }\n  }), createComponent(ScrollContainerStyled, {\n    get maxHeight() {\n      return maxHeight();\n    },\n    onScroll,\n    get [\"class\"]() {\n      return props.class;\n    },\n    get children() {\n      return props.children;\n    }\n  })];\n};\nconst AStyled = styled.a`\n    display: block;\n    text-decoration: unset;\n`;\nconst Link = (props) => {\n  const attributes = () => props.blank ? {\n    rel: \"noreferrer noopener\"\n  } : {};\n  return createComponent(AStyled, mergeProps({\n    get href() {\n      return props.href;\n    },\n    get target() {\n      return props.blank ? \"_blank\" : \"_self\";\n    },\n    get [\"class\"]() {\n      return props.class;\n    }\n  }, attributes, {\n    get children() {\n      return props.children;\n    }\n  }));\n};\nconst TonConnectUiContext = createContext();\nvar _tmpl$$8 = /* @__PURE__ */ template$1(`<svg width=24 height=24 viewBox=\"0 0 24 24\"fill=none xmlns=http://www.w3.org/2000/svg><path fill-rule=evenodd clip-rule=evenodd d=\"M7.76228 2.09998H10.2378C11.0458 2.09997 11.7067 2.09996 12.2438 2.14384C12.7997 2.18926 13.3017 2.28614 13.7706 2.52505C14.5045 2.89896 15.1011 3.49558 15.475 4.22941C15.7139 4.6983 15.8108 5.20038 15.8562 5.75629C15.9001 6.29337 15.9001 6.95422 15.9001 7.76227V8.1H16.2377C17.0457 8.09999 17.7066 8.09998 18.2437 8.14386C18.7996 8.18928 19.3017 8.28616 19.7705 8.52507C20.5044 8.89898 21.101 9.4956 21.4749 10.2294C21.7138 10.6983 21.8107 11.2004 21.8561 11.7563C21.9 12.2934 21.9 12.9542 21.9 13.7623V16.2377C21.9 17.0458 21.9 17.7066 21.8561 18.2437C21.8107 18.7996 21.7138 19.3017 21.4749 19.7706C21.101 20.5044 20.5044 21.101 19.7705 21.4749C19.3017 21.7138 18.7996 21.8107 18.2437 21.8561C17.7066 21.9 17.0458 21.9 16.2378 21.9H13.7623C12.9543 21.9 12.2934 21.9 11.7563 21.8561C11.2004 21.8107 10.6983 21.7138 10.2294 21.4749C9.49561 21.101 8.89898 20.5044 8.52508 19.7706C8.28616 19.3017 8.18928 18.7996 8.14386 18.2437C8.09998 17.7066 8.09999 17.0458 8.1 16.2377V15.9H7.76227C6.95426 15.9 6.29335 15.9 5.75629 15.8561C5.20038 15.8107 4.6983 15.7138 4.22941 15.4749C3.49558 15.101 2.89896 14.5044 2.52505 13.7705C2.28614 13.3017 2.18926 12.7996 2.14384 12.2437C2.09996 11.7066 2.09997 11.0458 2.09998 10.2377V7.76228C2.09997 6.95424 2.09996 6.29336 2.14384 5.75629C2.18926 5.20038 2.28614 4.6983 2.52505 4.22941C2.89896 3.49558 3.49558 2.89896 4.22941 2.52505C4.6983 2.28614 5.20038 2.18926 5.75629 2.14384C6.29336 2.09996 6.95425 2.09997 7.76228 2.09998ZM8.1 14.1V13.7623C8.09999 12.9542 8.09998 12.2934 8.14386 11.7563C8.18928 11.2004 8.28616 10.6983 8.52508 10.2294C8.89898 9.4956 9.49561 8.89898 10.2294 8.52507C10.6983 8.28616 11.2004 8.18928 11.7563 8.14386C12.2934 8.09998 12.9542 8.09999 13.7623 8.1H14.1001V7.79998C14.1001 6.94505 14.0994 6.35798 14.0622 5.90287C14.0259 5.45827 13.9593 5.21944 13.8712 5.0466C13.6699 4.65146 13.3486 4.3302 12.9535 4.12886C12.7806 4.04079 12.5418 3.97419 12.0972 3.93786C11.6421 3.90068 11.055 3.89998 10.2001 3.89998H7.79998C6.94505 3.89998 6.35798 3.90068 5.90287 3.93786C5.45827 3.97419 5.21944 4.04079 5.0466 4.12886C4.65146 4.3302 4.3302 4.65146 4.12886 5.0466C4.04079 5.21944 3.97419 5.45827 3.93786 5.90287C3.90068 6.35798 3.89998 6.94505 3.89998 7.79998V10.2C3.89998 11.0549 3.90068 11.642 3.93786 12.0971C3.97419 12.5417 4.04079 12.7805 4.12886 12.9534C4.3302 13.3485 4.65146 13.6698 5.0466 13.8711C5.21944 13.9592 5.45827 14.0258 5.90287 14.0621C6.35798 14.0993 6.94505 14.1 7.79998 14.1H8.1ZM11.0466 10.1289C11.2195 10.0408 11.4583 9.97421 11.9029 9.93788C12.358 9.9007 12.9451 9.9 13.8 9.9H16.2C17.0549 9.9 17.642 9.9007 18.0971 9.93788C18.5417 9.97421 18.7805 10.0408 18.9534 10.1289C19.3485 10.3302 19.6698 10.6515 19.8711 11.0466C19.9592 11.2195 20.0258 11.4583 20.0621 11.9029C20.0993 12.358 20.1 12.9451 20.1 13.8V16.2C20.1 17.0549 20.0993 17.642 20.0621 18.0971C20.0258 18.5417 19.9592 18.7805 19.8711 18.9534C19.6698 19.3485 19.3485 19.6698 18.9534 19.8711C18.7805 19.9592 18.5417 20.0258 18.0971 20.0621C17.642 20.0993 17.0549 20.1 16.2 20.1H13.8C12.9451 20.1 12.358 20.0993 11.9029 20.0621C11.4583 20.0258 11.2195 19.9592 11.0466 19.8711C10.6515 19.6698 10.3302 19.3485 10.1289 18.9534C10.0408 18.7805 9.97421 18.5417 9.93788 18.0971C9.9007 17.642 9.9 17.0549 9.9 16.2V13.8C9.9 12.9451 9.9007 12.358 9.93788 11.9029C9.97421 11.4583 10.0408 11.2195 10.1289 11.0466C10.3302 10.6515 10.6515 10.3302 11.0466 10.1289Z\">`);\nconst CopyIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.primary;\n  return (() => {\n    var _el$ = _tmpl$$8(), _el$2 = _el$.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = props.class, _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })();\n};\nvar _tmpl$$7 = /* @__PURE__ */ template$1(`<svg width=24 height=24 viewBox=\"0 0 24 24\"fill=none xmlns=http://www.w3.org/2000/svg><path d=\"M8.7624 3.10001C7.95435 3.1 7.29349 3.09999 6.75642 3.14387C6.2005 3.18929 5.69842 3.28617 5.22954 3.52508C4.4957 3.89899 3.89908 4.49561 3.52517 5.22944C3.28626 5.69833 3.18938 6.20041 3.14396 6.75632C3.10008 7.2934 3.10009 7.95424 3.1001 8.76229V15.2377C3.10009 16.0458 3.10008 16.7066 3.14396 17.2437C3.18938 17.7996 3.28626 18.3017 3.52517 18.7706C3.89908 19.5044 4.4957 20.101 5.22954 20.4749C5.69842 20.7138 6.2005 20.8107 6.75642 20.8561C7.29349 20.9 7.95434 20.9 8.76239 20.9H12.0001C12.4972 20.9 12.9001 20.4971 12.9001 20C12.9001 19.503 12.4972 19.1 12.0001 19.1H8.8001C7.94517 19.1 7.3581 19.0993 6.90299 19.0621C6.45839 19.0258 6.21956 18.9592 6.04672 18.8711C5.65158 18.6698 5.33032 18.3485 5.12898 17.9534C5.04092 17.7805 4.97431 17.5417 4.93798 17.0971C4.9008 16.642 4.9001 16.0549 4.9001 15.2V8.80001C4.9001 7.94508 4.9008 7.35801 4.93798 6.9029C4.97431 6.4583 5.04092 6.21947 5.12898 6.04663C5.33032 5.65149 5.65158 5.33023 6.04672 5.12889C6.21956 5.04082 6.45839 4.97422 6.90299 4.93789C7.3581 4.90071 7.94517 4.90001 8.8001 4.90001H12.0001C12.4972 4.90001 12.9001 4.49706 12.9001 4.00001C12.9001 3.50295 12.4972 3.10001 12.0001 3.10001H8.7624Z\"></path><path d=\"M17.6364 7.3636C17.2849 7.01212 16.7151 7.01212 16.3636 7.3636C16.0121 7.71507 16.0121 8.28492 16.3636 8.63639L18.8272 11.1H9.00001C8.50295 11.1 8.10001 11.5029 8.10001 12C8.10001 12.497 8.50295 12.9 9.00001 12.9H18.8272L16.3636 15.3636C16.0121 15.7151 16.0121 16.2849 16.3636 16.6364C16.7151 16.9879 17.2849 16.9879 17.6364 16.6364L21.6364 12.6364C21.9879 12.2849 21.9879 11.7151 21.6364 11.3636L17.6364 7.3636Z\">`);\nconst DisconnectIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.primary;\n  return (() => {\n    var _el$ = _tmpl$$7(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$ = fill(), _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$2, \"fill\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$3, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })();\n};\nconst hoverBorders$1 = {\n  m: \"8px\",\n  s: \"4px\",\n  none: \"0\"\n};\nconst dropdownBorders = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst AccountButtonDropdownStyled = styled.div`\n    width: 256px;\n    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);\n    border-radius: ${(props) => dropdownBorders[props.theme.borderRadius]};\n\n    background-color: ${(props) => props.theme.colors.background.primary}\n           \n    color: ${(props) => props.theme.colors.text.primary}\n`;\nconst UlStyled = styled.ul`\n    background-color: ${(props) => props.theme.colors.background.primary};\n    padding: 8px;\n`;\nconst MenuButtonStyled = styled.button`\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    height: 40px;\n    padding-left: 8px;\n    width: 100%;\n\n    background-color: ${(props) => props.theme.colors.background.primary};\n    border: none;\n    border-radius: ${(props) => hoverBorders$1[props.theme.borderRadius]};\n    cursor: pointer;\n\n    transition:\n        background-color,\n        transform 0.1s ease-in-out;\n\n    &:hover {\n        background-color: ${(props) => props.theme.colors.background.secondary};\n    }\n\n    &:active {\n        transform: scale(0.96);\n    }\n`;\nvar _tmpl$$6 = /* @__PURE__ */ template$1(`<li>`);\nconst MenuItemText = (props) => createComponent(Text, {\n  get translationKey() {\n    return props.translationKey;\n  },\n  fontSize: \"15px\",\n  fontWeight: \"590\",\n  get children() {\n    return props.children;\n  }\n});\nconst AccountButtonDropdown = (props) => {\n  const tonConnectUi = useContext(TonConnectUiContext);\n  const [isCopiedShown, setIsCopiedShown] = createSignal(false);\n  const onCopy = () => __async(null, null, function* () {\n    const userFriendlyAddress = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.toUserFriendlyAddress)(tonConnectUi.account.address, tonConnectUi.account.chain === _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.CHAIN.TESTNET);\n    yield copyToClipboard(userFriendlyAddress);\n    setIsCopiedShown(true);\n    setTimeout(() => setIsCopiedShown(false), 1e3);\n  });\n  const onDisconnect = () => {\n    tonConnectUi.disconnect();\n    props.onClose();\n  };\n  return createComponent(AccountButtonDropdownStyled, {\n    ref(r$) {\n      var _ref$ = props.ref;\n      typeof _ref$ === \"function\" ? _ref$(r$) : props.ref = r$;\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-dropdown\": \"true\",\n    get children() {\n      return createComponent(UlStyled, {\n        get children() {\n          return [(() => {\n            var _el$ = _tmpl$$6();\n            insert(_el$, createComponent(MenuButtonStyled, {\n              onClick: () => onCopy(),\n              get children() {\n                return [createComponent(CopyIcon, {}), createComponent(Show, {\n                  get when() {\n                    return !isCopiedShown();\n                  },\n                  get children() {\n                    return createComponent(MenuItemText, {\n                      translationKey: \"button.dropdown.copy\",\n                      children: \"Copy address\"\n                    });\n                  }\n                }), createComponent(Show, {\n                  get when() {\n                    return isCopiedShown();\n                  },\n                  get children() {\n                    return createComponent(MenuItemText, {\n                      translationKey: \"button.dropdown.copied\",\n                      children: \"Address copied!\"\n                    });\n                  }\n                })];\n              }\n            }));\n            return _el$;\n          })(), (() => {\n            var _el$2 = _tmpl$$6();\n            insert(_el$2, createComponent(MenuButtonStyled, {\n              onClick: () => onDisconnect(),\n              get children() {\n                return [createComponent(DisconnectIcon, {}), createComponent(MenuItemText, {\n                  translationKey: \"button.dropdown.disconnect\",\n                  children: \"Disconnect\"\n                })];\n              }\n            }));\n            return _el$2;\n          })()];\n        }\n      });\n    }\n  });\n};\nconst borders$3 = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst NotificationStyled = styled.div`\n    width: 256px;\n    padding: 12px 16px;\n    display: flex;\n    gap: 9px;\n\n    background-color: ${(props) => props.theme.colors.background.primary};\n    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);\n    border-radius: ${(props) => borders$3[props.theme.borderRadius]};\n`;\nconst NotificationContentStyled = styled.div`\n    width: 192px;\n\n    > h3 {\n        font-size: 15px;\n    }\n`;\nconst TextStyled$3 = styled(Text)`\n    margin-top: 4px;\n    color: ${(props) => props.theme.colors.text.secondary};\n`;\nconst Notification = (props) => {\n  const dataAttrs = useDataAttributes(props);\n  return createComponent(NotificationStyled, mergeProps({\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-notification\": \"true\"\n  }, dataAttrs, {\n    get children() {\n      return [createComponent(NotificationContentStyled, {\n        get children() {\n          return [createComponent(H3, {\n            get translationKey() {\n              return props.header.translationKey;\n            },\n            get translationValues() {\n              return props.header.translationValues;\n            },\n            get children() {\n              return props.children;\n            }\n          }), createComponent(Show, {\n            get when() {\n              return props.text;\n            },\n            get children() {\n              return createComponent(TextStyled$3, {\n                get translationKey() {\n                  return props.text.translationKey;\n                },\n                get translationValues() {\n                  return props.text.translationValues;\n                }\n              });\n            }\n          })];\n        }\n      }), memo(() => props.icon)];\n    }\n  }));\n};\nconst LoaderIconStyled$2 = styled(LoaderIcon)`\n    align-self: center;\n`;\nconst ConfirmOperationNotification = (props) => {\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [t2] = useI18n();\n  const name = () => tonConnectUI.wallet && \"name\" in tonConnectUI.wallet ? tonConnectUI.wallet.name : t2(\"common.yourWallet\", {}, \"Your wallet\");\n  return createComponent(Notification, {\n    get header() {\n      return {\n        translationKey: \"notifications.confirm.header\",\n        translationValues: {\n          name: name()\n        }\n      };\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    get icon() {\n      return createComponent(LoaderIconStyled$2, {});\n    },\n    \"data-tc-notification-confirm\": \"true\",\n    children: \"Confirm operation in your wallet\"\n  });\n};\nconst ErrorIconStyled$4 = styled(ErrorIcon)`\n    margin-top: 2px;\n`;\nconst ErrorTransactionNotification = (props) => {\n  return createComponent(Notification, {\n    header: {\n      translationKey: \"notifications.transactionCanceled.header\"\n    },\n    text: {\n      translationKey: \"notifications.transactionCanceled.text\"\n    },\n    get icon() {\n      return createComponent(ErrorIconStyled$4, {\n        size: \"xs\"\n      });\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-notification-tx-cancelled\": \"true\",\n    children: \"Transaction cancelled\"\n  });\n};\nconst SuccessIconStyled = styled(SuccessIcon)`\n    margin-top: 2px;\n`;\nconst SuccessTransactionNotification = (props) => {\n  return createComponent(Notification, {\n    header: {\n      translationKey: \"notifications.transactionSent.header\"\n    },\n    text: {\n      translationKey: \"notifications.transactionSent.text\"\n    },\n    get icon() {\n      return createComponent(SuccessIconStyled, {});\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-notification-tx-sent\": \"true\",\n    children: \"Transaction sent\"\n  });\n};\nconst NotificationClass = u`\n    transform: translateY(-8px);\n    margin-bottom: 12px;\n`;\nconst defaultConfig = {\n  timeout: 4500\n};\nconst [latestAction, setLatestAction] = createSignal(null);\nfunction useOpenedNotifications(config) {\n  const { timeout } = __spreadValues(__spreadValues({}, defaultConfig), config);\n  const [openedNotifications, setOpenedNotifications] = createSignal([]);\n  const [timeoutIds, setTimeoutIds] = createSignal([]);\n  createEffect(\n    on(action, (action2) => {\n      var _a2, _b2;\n      if (!action2 || !action2.showNotification) {\n        setOpenedNotifications(\n          (openedNotifications2) => openedNotifications2.filter((n2) => n2.action !== \"confirm-transaction\")\n        );\n        return;\n      }\n      if (latestAction() === action2) {\n        return;\n      }\n      const isConfirmTransactionAction = ((_a2 = latestAction()) == null ? void 0 : _a2.name) === \"confirm-transaction\" && action2.name === \"confirm-transaction\";\n      const isConfirmSignDataAction = ((_b2 = latestAction()) == null ? void 0 : _b2.name) === \"confirm-sign-data\" && action2.name === \"confirm-sign-data\";\n      if (isConfirmTransactionAction || isConfirmSignDataAction) {\n        return;\n      }\n      setLatestAction(action2);\n      setOpenedNotifications(\n        (openedNotifications2) => openedNotifications2.filter(\n          (n2) => n2.action !== \"confirm-transaction\" && n2.action !== \"confirm-sign-data\"\n        )\n      );\n      const notification = { action: action2.name };\n      setOpenedNotifications((openedNotifications2) => [...openedNotifications2, notification]);\n      const timeoutId = setTimeout(() => {\n        setOpenedNotifications(\n          (openedNotifications2) => openedNotifications2.filter((n2) => n2 !== notification)\n        );\n        setTimeoutIds((timeoutIds2) => timeoutIds2.filter((id) => id !== timeoutId));\n      }, timeout);\n      setTimeoutIds((timeoutIds2) => [...timeoutIds2, timeoutId]);\n    })\n  );\n  onCleanup(() => {\n    timeoutIds().forEach((id) => clearTimeout(id));\n  });\n  return openedNotifications;\n}\nconst ErrorIconStyled$3 = styled(ErrorIcon)`\n    margin-top: 2px;\n`;\nconst ErrorSignDataNotification = (props) => {\n  return createComponent(Notification, {\n    header: {\n      translationKey: \"notifications.signDataCanceled.header\"\n    },\n    get icon() {\n      return createComponent(ErrorIconStyled$3, {\n        size: \"xs\"\n      });\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-notification-sign-data-cancelled\": \"true\",\n    children: \"Sign data canceled\"\n  });\n};\nconst SuccessSignDataNotification = (props) => {\n  return createComponent(Notification, {\n    header: {\n      translationKey: \"notifications.dataSigned.header\"\n    },\n    get icon() {\n      return createComponent(SuccessIconStyled, {});\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-notification-data-signed\": \"true\",\n    children: \"Data signed\"\n  });\n};\nvar _tmpl$$5 = /* @__PURE__ */ template$1(`<div data-tc-list-notifications=true>`);\nconst Notifications = (props) => {\n  const openedNotifications = useOpenedNotifications();\n  return (() => {\n    var _el$ = _tmpl$$5();\n    insert(_el$, createComponent(TransitionGroup, {\n      onBeforeEnter: (el) => {\n        animate(el, [{\n          opacity: 0,\n          transform: \"translateY(0)\"\n        }, {\n          opacity: 1,\n          transform: \"translateY(-8px)\"\n        }], {\n          duration: 200\n        });\n      },\n      onExit: (el, done) => {\n        const a2 = animate(el, [{\n          opacity: 1,\n          transform: \"translateY(-8px)\"\n        }, {\n          opacity: 0,\n          transform: \"translateY(-30px)\"\n        }], {\n          duration: 200\n        });\n        a2.finished.then(done);\n      },\n      get children() {\n        return createComponent(For, {\n          get each() {\n            return openedNotifications();\n          },\n          children: (openedNotification) => createComponent(Switch, {\n            get children() {\n              return [createComponent(Match, {\n                get when() {\n                  return openedNotification.action === \"transaction-sent\";\n                },\n                get children() {\n                  return createComponent(SuccessTransactionNotification, {\n                    \"class\": NotificationClass\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return openedNotification.action === \"transaction-canceled\";\n                },\n                get children() {\n                  return createComponent(ErrorTransactionNotification, {\n                    \"class\": NotificationClass\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return openedNotification.action === \"data-signed\";\n                },\n                get children() {\n                  return createComponent(SuccessSignDataNotification, {\n                    \"class\": NotificationClass\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return openedNotification.action === \"sign-data-canceled\";\n                },\n                get children() {\n                  return createComponent(ErrorSignDataNotification, {\n                    \"class\": NotificationClass\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return openedNotification.action === \"confirm-transaction\" || openedNotification.action === \"confirm-sign-data\";\n                },\n                get children() {\n                  return createComponent(ConfirmOperationNotification, {\n                    \"class\": NotificationClass\n                  });\n                }\n              })];\n            }\n          })\n        });\n      }\n    }));\n    createRenderEffect(() => className(_el$, props.class));\n    return _el$;\n  })();\n};\nconst AccountButtonStyled = styled(Button)`\n    background-color: ${(props) => props.theme.colors.connectButton.background};\n    color: ${(props) => props.theme.colors.connectButton.foreground};\n    box-shadow: ${(props) => `0 4px 24px ${rgba(props.theme.colors.constant.black, 0.16)}`};\n    padding: 8px 16px 8px 12px;\n\n    display: flex;\n    align-items: center;\n    gap: 4px;\n    height: 40px;\n`;\nconst DropdownButtonStyled = styled(AccountButtonStyled)`\n    padding: 12px 16px;\n    min-width: 148px;\n    justify-content: center;\n    background-color: ${(props) => props.theme.colors.background.primary};\n`;\nconst LoaderButtonStyled$1 = styled(Button)`\n    min-width: 148px;\n    height: 40px;\n\n    background-color: ${(props) => props.theme.colors.background.primary};\n    color: ${(props) => props.theme.colors.connectButton.foreground};\n    box-shadow: ${(props) => `0 4px 24px ${rgba(props.theme.colors.constant.black, 0.16)}`};\n\n    display: flex;\n    align-items: center;\n    justify-content: center;\n`;\nconst LoaderIconStyled$1 = styled(LoaderIcon)`\n    height: 18px;\n    width: 18px;\n`;\nconst DropdownContainerStyled = styled.div`\n    width: fit-content;\n    display: flex;\n    flex-direction: column;\n    align-items: flex-end;\n`;\nconst DropdownStyled = styled(AccountButtonDropdown)`\n    box-sizing: border-box;\n    overflow: hidden;\n    margin-top: 12px;\n`;\nconst NotificationsStyled = styled(Notifications)`\n    > div:first-child {\n        margin-top: 20px;\n    }\n`;\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = (v) => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nconst oppositeAlignmentMap = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === \"function\" ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split(\"-\")[0];\n}\nfunction getAlignment(placement) {\n  return placement.split(\"-\")[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === \"x\" ? \"y\" : \"x\";\n}\nfunction getAxisLength(axis) {\n  return axis === \"y\" ? \"height\" : \"width\";\n}\nconst yAxisSides = /* @__PURE__ */ new Set([\"top\", \"bottom\"]);\nfunction getSideAxis(placement) {\n  return yAxisSides.has(getSide(placement)) ? \"y\" : \"x\";\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === \"x\" ? alignment === (rtl ? \"end\" : \"start\") ? \"right\" : \"left\" : alignment === \"start\" ? \"bottom\" : \"top\";\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);\n}\nconst lrPlacement = [\"left\", \"right\"];\nconst rlPlacement = [\"right\", \"left\"];\nconst tbPlacement = [\"top\", \"bottom\"];\nconst btPlacement = [\"bottom\", \"top\"];\nfunction getSideList(side, isStart, rtl) {\n  switch (side) {\n    case \"top\":\n    case \"bottom\":\n      if (rtl) return isStart ? rlPlacement : lrPlacement;\n      return isStart ? lrPlacement : rlPlacement;\n    case \"left\":\n    case \"right\":\n      return isStart ? tbPlacement : btPlacement;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === \"start\", rtl);\n  if (alignment) {\n    list = list.map((side) => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return __spreadValues({\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  }, padding);\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== \"number\" ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === \"y\";\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case \"top\":\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case \"bottom\":\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case \"right\":\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case \"left\":\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case \"start\":\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case \"end\":\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\nconst computePosition$1 = (reference, floating, config) => __async(null, null, function* () {\n  const {\n    placement = \"bottom\",\n    strategy = \"absolute\",\n    middleware = [],\n    platform: platform2\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(floating);\n  let rects = yield platform2.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i2 = 0; i2 < validMiddleware.length; i2++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i2];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = yield fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform: platform2,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = __spreadProps(__spreadValues({}, middlewareData), {\n      [name]: __spreadValues(__spreadValues({}, middlewareData[name]), data)\n    });\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === \"object\") {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? yield platform2.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i2 = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n});\nfunction detectOverflow(state, options) {\n  return __async(this, null, function* () {\n    var _await$platform$isEle;\n    if (options === void 0) {\n      options = {};\n    }\n    const {\n      x,\n      y,\n      platform: platform2,\n      rects,\n      elements,\n      strategy\n    } = state;\n    const {\n      boundary = \"clippingAncestors\",\n      rootBoundary = \"viewport\",\n      elementContext = \"floating\",\n      altBoundary = false,\n      padding = 0\n    } = evaluate(options, state);\n    const paddingObject = getPaddingObject(padding);\n    const altContext = elementContext === \"floating\" ? \"reference\" : \"floating\";\n    const element = elements[altBoundary ? altContext : elementContext];\n    const clippingClientRect = rectToClientRect(yield platform2.getClippingRect({\n      element: ((_await$platform$isEle = yield platform2.isElement == null ? void 0 : platform2.isElement(element)) != null ? _await$platform$isEle : true) ? element : element.contextElement || (yield platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),\n      boundary,\n      rootBoundary,\n      strategy\n    }));\n    const rect = elementContext === \"floating\" ? {\n      x,\n      y,\n      width: rects.floating.width,\n      height: rects.floating.height\n    } : rects.reference;\n    const offsetParent = yield platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating);\n    const offsetScale = (yield platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? (yield platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {\n      x: 1,\n      y: 1\n    } : {\n      x: 1,\n      y: 1\n    };\n    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? yield platform2.convertOffsetParentRelativeRectToViewportRelativeRect({\n      elements,\n      rect,\n      offsetParent,\n      strategy\n    }) : rect);\n    return {\n      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n    };\n  });\n}\nconst flip$1 = function(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"flip\",\n    options,\n    fn(state) {\n      return __async(this, null, function* () {\n        var _middlewareData$arrow, _middlewareData$flip;\n        const {\n          placement,\n          middlewareData,\n          rects,\n          initialPlacement,\n          platform: platform2,\n          elements\n        } = state;\n        const _a3 = evaluate(options, state), {\n          mainAxis: checkMainAxis = true,\n          crossAxis: checkCrossAxis = true,\n          fallbackPlacements: specifiedFallbackPlacements,\n          fallbackStrategy = \"bestFit\",\n          fallbackAxisSideDirection = \"none\",\n          flipAlignment = true\n        } = _a3, detectOverflowOptions = __objRest(_a3, [\n          \"mainAxis\",\n          \"crossAxis\",\n          \"fallbackPlacements\",\n          \"fallbackStrategy\",\n          \"fallbackAxisSideDirection\",\n          \"flipAlignment\"\n        ]);\n        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n          return {};\n        }\n        const side = getSide(placement);\n        const initialSideAxis = getSideAxis(initialPlacement);\n        const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n        const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating);\n        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n        const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== \"none\";\n        if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n        }\n        const placements = [initialPlacement, ...fallbackPlacements];\n        const overflow = yield detectOverflow(state, detectOverflowOptions);\n        const overflows = [];\n        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n        if (checkMainAxis) {\n          overflows.push(overflow[side]);\n        }\n        if (checkCrossAxis) {\n          const sides = getAlignmentSides(placement, rects, rtl);\n          overflows.push(overflow[sides[0]], overflow[sides[1]]);\n        }\n        overflowsData = [...overflowsData, {\n          placement,\n          overflows\n        }];\n        if (!overflows.every((side2) => side2 <= 0)) {\n          var _middlewareData$flip2, _overflowsData$filter;\n          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n          const nextPlacement = placements[nextIndex];\n          if (nextPlacement) {\n            const ignoreCrossAxisOverflow = checkCrossAxis === \"alignment\" ? initialSideAxis !== getSideAxis(nextPlacement) : false;\n            if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis\n            // overflows the main axis.\n            overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {\n              return {\n                data: {\n                  index: nextIndex,\n                  overflows: overflowsData\n                },\n                reset: {\n                  placement: nextPlacement\n                }\n              };\n            }\n          }\n          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a2, b) => a2.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n          if (!resetPlacement) {\n            switch (fallbackStrategy) {\n              case \"bestFit\": {\n                var _overflowsData$filter2;\n                const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === \"y\";\n                  }\n                  return true;\n                }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b) => a2[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement2) {\n                  resetPlacement = placement2;\n                }\n                break;\n              }\n              case \"initialPlacement\":\n                resetPlacement = initialPlacement;\n                break;\n            }\n          }\n          if (placement !== resetPlacement) {\n            return {\n              reset: {\n                placement: resetPlacement\n              }\n            };\n          }\n        }\n        return {};\n      });\n    }\n  };\n};\nconst shift$1 = function(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"shift\",\n    options,\n    fn(state) {\n      return __async(this, null, function* () {\n        const {\n          x,\n          y,\n          placement\n        } = state;\n        const _a3 = evaluate(options, state), {\n          mainAxis: checkMainAxis = true,\n          crossAxis: checkCrossAxis = false,\n          limiter = {\n            fn: (_ref) => {\n              let {\n                x: x2,\n                y: y2\n              } = _ref;\n              return {\n                x: x2,\n                y: y2\n              };\n            }\n          }\n        } = _a3, detectOverflowOptions = __objRest(_a3, [\n          \"mainAxis\",\n          \"crossAxis\",\n          \"limiter\"\n        ]);\n        const coords = {\n          x,\n          y\n        };\n        const overflow = yield detectOverflow(state, detectOverflowOptions);\n        const crossAxis = getSideAxis(getSide(placement));\n        const mainAxis = getOppositeAxis(crossAxis);\n        let mainAxisCoord = coords[mainAxis];\n        let crossAxisCoord = coords[crossAxis];\n        if (checkMainAxis) {\n          const minSide = mainAxis === \"y\" ? \"top\" : \"left\";\n          const maxSide = mainAxis === \"y\" ? \"bottom\" : \"right\";\n          const min2 = mainAxisCoord + overflow[minSide];\n          const max2 = mainAxisCoord - overflow[maxSide];\n          mainAxisCoord = clamp(min2, mainAxisCoord, max2);\n        }\n        if (checkCrossAxis) {\n          const minSide = crossAxis === \"y\" ? \"top\" : \"left\";\n          const maxSide = crossAxis === \"y\" ? \"bottom\" : \"right\";\n          const min2 = crossAxisCoord + overflow[minSide];\n          const max2 = crossAxisCoord - overflow[maxSide];\n          crossAxisCoord = clamp(min2, crossAxisCoord, max2);\n        }\n        const limitedCoords = limiter.fn(__spreadProps(__spreadValues({}, state), {\n          [mainAxis]: mainAxisCoord,\n          [crossAxis]: crossAxisCoord\n        }));\n        return __spreadProps(__spreadValues({}, limitedCoords), {\n          data: {\n            x: limitedCoords.x - x,\n            y: limitedCoords.y - y,\n            enabled: {\n              [mainAxis]: checkMainAxis,\n              [crossAxis]: checkCrossAxis\n            }\n          }\n        });\n      });\n    }\n  };\n};\nfunction hasWindow() {\n  return typeof window !== \"undefined\";\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || \"\").toLowerCase();\n  }\n  return \"#document\";\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === \"undefined\") {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nconst invalidOverflowDisplayValues = /* @__PURE__ */ new Set([\"inline\", \"contents\"]);\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);\n}\nconst tableElements = /* @__PURE__ */ new Set([\"table\", \"td\", \"th\"]);\nfunction isTableElement(element) {\n  return tableElements.has(getNodeName(element));\n}\nconst topLayerSelectors = [\":popover-open\", \":modal\"];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some((selector) => {\n    try {\n      return element.matches(selector);\n    } catch (_e2) {\n      return false;\n    }\n  });\n}\nconst transformProperties = [\"transform\", \"translate\", \"scale\", \"rotate\", \"perspective\"];\nconst willChangeValues = [\"transform\", \"translate\", \"scale\", \"rotate\", \"perspective\", \"filter\"];\nconst containValues = [\"paint\", \"layout\", \"strict\", \"content\"];\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;\n  return transformProperties.some((value) => css[value] ? css[value] !== \"none\" : false) || (css.containerType ? css.containerType !== \"normal\" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== \"none\" : false) || !webkit && (css.filter ? css.filter !== \"none\" : false) || willChangeValues.some((value) => (css.willChange || \"\").includes(value)) || containValues.some((value) => (css.contain || \"\").includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === \"undefined\" || !CSS.supports) return false;\n  return CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nconst lastTraversableNodeNames = /* @__PURE__ */ new Set([\"html\", \"body\", \"#document\"]);\nfunction isLastTraversableNode(node) {\n  return lastTraversableNodeNames.has(getNodeName(node));\n}\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === \"html\") {\n    return node;\n  }\n  const result = (\n    // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot || // DOM Element detected.\n    node.parentNode || // ShadowRoot detected.\n    isShadowRoot(node) && node.host || // Fallback.\n    getDocumentElement(node)\n  );\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\nfunction getCssDimensions(element) {\n  const css = getComputedStyle$1(element);\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\nconst noOffsets = /* @__PURE__ */ createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle$1(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n  if (ignoreScrollbarX === void 0) {\n    ignoreScrollbarX = false;\n  }\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (\n    // RTL <body> scrollbar.\n    getWindowScrollBarX(documentElement, htmlRect)\n  ));\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === \"fixed\";\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle$1(body).direction === \"rtl\") {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === \"fixed\") {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nconst absoluteOrFixed = /* @__PURE__ */ new Set([\"absolute\", \"fixed\"]);\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === \"fixed\");\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === \"viewport\") {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === \"document\") {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle$1(parentNode).position === \"fixed\" || hasFixedPositionAncestor(parentNode, stopNode);\n}\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== \"body\");\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === \"fixed\";\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle$1(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === \"fixed\") {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === \"static\" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      result = result.filter((ancestor) => ancestor !== currentNode);\n    } else {\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === \"clippingAncestors\" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === \"fixed\";\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction isStaticPositioned(element) {\n  return getComputedStyle$1(element).position === \"static\";\n}\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === \"fixed\") {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\nconst getElementRects = function(data) {\n  return __async(this, null, function* () {\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    const floatingDimensions = yield getDimensionsFn(data.floating);\n    return {\n      reference: getRectRelativeToOffsetParent(data.reference, yield getOffsetParentFn(data.floating), data.strategy),\n      floating: {\n        x: 0,\n        y: 0,\n        width: floatingDimensions.width,\n        height: floatingDimensions.height\n      }\n    };\n  });\n};\nfunction isRTL(element) {\n  return getComputedStyle$1(element).direction === \"rtl\";\n}\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\nfunction rectsAreEqual(a2, b) {\n  return a2.x === b.x && a2.y === b.y && a2.width === b.width && a2.height === b.height;\n}\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1e3);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n    try {\n      io = new IntersectionObserver(handleObserve, __spreadProps(__spreadValues({}, options), {\n        // Handle <iframe>s\n        root: root.ownerDocument\n      }));\n    } catch (_e2) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === \"function\",\n    layoutShift = typeof IntersectionObserver === \"function\",\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach((ancestor) => {\n    ancestorScroll && ancestor.addEventListener(\"scroll\", update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener(\"resize\", update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver((_ref) => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach((ancestor) => {\n      ancestorScroll && ancestor.removeEventListener(\"scroll\", update);\n      ancestorResize && ancestor.removeEventListener(\"resize\", update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\nconst shift = shift$1;\nconst flip = flip$1;\nconst computePosition = (reference, floating, options) => {\n  const cache = /* @__PURE__ */ new Map();\n  const mergedOptions = __spreadValues({\n    platform\n  }, options);\n  const platformWithCache = __spreadProps(__spreadValues({}, mergedOptions.platform), {\n    _c: cache\n  });\n  return computePosition$1(reference, floating, __spreadProps(__spreadValues({}, mergedOptions), {\n    platform: platformWithCache\n  }));\n};\nfunction C(l2, u2, e2) {\n  let c2 = () => {\n    var t2;\n    return (t2 = e2 == null ? void 0 : e2.placement) != null ? t2 : \"bottom\";\n  }, d = () => {\n    var t2;\n    return (t2 = e2 == null ? void 0 : e2.strategy) != null ? t2 : \"absolute\";\n  }, [n2, o2] = createSignal({ x: null, y: null, placement: c2(), strategy: d(), middlewareData: {} }), [x, F] = createSignal();\n  createEffect(() => {\n    let t2 = x();\n    if (t2) throw t2.value;\n  });\n  let s2 = createMemo(() => (l2(), u2(), {}));\n  function m() {\n    let t2 = l2(), r = u2();\n    if (t2 && r) {\n      let a2 = s2();\n      computePosition(t2, r, { middleware: e2 == null ? void 0 : e2.middleware, placement: c2(), strategy: d() }).then((i2) => {\n        a2 === s2() && o2(i2);\n      }, (i2) => {\n        F(i2);\n      });\n    }\n  }\n  return createEffect(() => {\n    let t2 = l2(), r = u2();\n    if (c2(), d(), t2 && r) if (e2 != null && e2.whileElementsMounted) {\n      let a2 = e2.whileElementsMounted(t2, r, m);\n      a2 && onCleanup(a2);\n    } else m();\n  }), { get x() {\n    return n2().x;\n  }, get y() {\n    return n2().y;\n  }, get placement() {\n    return n2().placement;\n  }, get strategy() {\n    return n2().strategy;\n  }, get middlewareData() {\n    return n2().middlewareData;\n  }, update: m };\n}\nvar _tmpl$$4 = /* @__PURE__ */ template$1(`<tc-root data-tc-dropdown-container=true>`, true, false, false);\nconst AccountButton = () => {\n  const theme = useTheme();\n  const connector = useContext(ConnectorContext);\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [isOpened, setIsOpened] = createSignal(false);\n  const [account, setAccount] = createSignal(connector.account);\n  const [restoringProcess, setRestoringProcess] = createSignal(!connector.account);\n  let dropDownRef;\n  const [floating, setFloating] = createSignal();\n  const [anchor, setAnchor] = createSignal();\n  const position = C(anchor, floating, {\n    whileElementsMounted: autoUpdate,\n    placement: \"bottom-end\",\n    middleware: [flip(), shift()]\n  });\n  const normalizedAddress = () => {\n    const acc = account();\n    if (acc) {\n      const userFriendlyAddress = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.toUserFriendlyAddress)(acc.address, acc.chain === _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.CHAIN.TESTNET);\n      return userFriendlyAddress.slice(0, 4) + \"\" + userFriendlyAddress.slice(-4);\n    }\n    return \"\";\n  };\n  tonConnectUI.connectionRestored.then(() => setRestoringProcess(false));\n  const unsubscribe = connector.onStatusChange((wallet) => {\n    if (!wallet) {\n      setIsOpened(false);\n      setAccount(null);\n      setRestoringProcess(false);\n      return;\n    }\n    setAccount(wallet.account);\n    setRestoringProcess(false);\n  });\n  const onClick = (e2) => {\n    if (!account() || !isOpened()) {\n      return;\n    }\n    const clickToButton = anchor().contains(e2.target);\n    const clickToDropdown = dropDownRef.contains(e2.target);\n    if (!clickToButton && !clickToDropdown) {\n      setIsOpened(false);\n    }\n  };\n  onMount(() => {\n    document.body.addEventListener(\"click\", onClick);\n  });\n  onCleanup(() => {\n    document.body.removeEventListener(\"click\", onClick);\n    unsubscribe();\n  });\n  return createComponent(Dynamic, {\n    component: globalStylesTag,\n    get children() {\n      return [createComponent(Show, {\n        get when() {\n          return restoringProcess();\n        },\n        get children() {\n          return createComponent(LoaderButtonStyled$1, {\n            disabled: true,\n            \"data-tc-connect-button-loading\": \"true\",\n            get children() {\n              return createComponent(LoaderIconStyled$1, {});\n            }\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !restoringProcess();\n        },\n        get children() {\n          return [createComponent(Show, {\n            get when() {\n              return !account();\n            },\n            get children() {\n              return createComponent(AccountButtonStyled, {\n                onClick: () => tonConnectUI.openModal(),\n                \"data-tc-connect-button\": \"true\",\n                scale: \"s\",\n                get children() {\n                  return [createComponent(TonIcon, {\n                    get fill() {\n                      return theme.colors.connectButton.foreground;\n                    }\n                  }), createComponent(Text, {\n                    translationKey: \"button.connectWallet\",\n                    fontSize: \"15px\",\n                    lineHeight: \"18px\",\n                    fontWeight: \"590\",\n                    get color() {\n                      return theme.colors.connectButton.foreground;\n                    },\n                    children: \"Connect wallet\"\n                  })];\n                }\n              });\n            }\n          }), createComponent(Show, {\n            get when() {\n              return account();\n            },\n            get children() {\n              return createComponent(DropdownContainerStyled, {\n                get children() {\n                  return [createComponent(DropdownButtonStyled, {\n                    onClick: () => setIsOpened((v) => !v),\n                    ref: setAnchor,\n                    \"data-tc-dropdown-button\": \"true\",\n                    scale: \"s\",\n                    get children() {\n                      return [createComponent(Text, {\n                        fontSize: \"15px\",\n                        fontWeight: \"590\",\n                        lineHeight: \"18px\",\n                        get children() {\n                          return normalizedAddress();\n                        }\n                      }), createComponent(ArrowIcon, {\n                        direction: \"bottom\"\n                      })];\n                    }\n                  }), createComponent(Portal, {\n                    get children() {\n                      var _el$ = _tmpl$$4();\n                      use(setFloating, _el$);\n                      _el$.style.setProperty(\"z-index\", \"999\");\n                      _el$._$owner = getOwner();\n                      insert(_el$, createComponent(Transition, {\n                        onBeforeEnter: (el) => {\n                          animate(el, [{\n                            opacity: 0,\n                            transform: \"translateY(-8px)\"\n                          }, {\n                            opacity: 1,\n                            transform: \"translateY(0)\"\n                          }], {\n                            duration: 150\n                          });\n                        },\n                        onExit: (el, done) => {\n                          const a2 = animate(el, [{\n                            opacity: 1,\n                            transform: \"translateY(0)\"\n                          }, {\n                            opacity: 0,\n                            transform: \"translateY(-8px)\"\n                          }], {\n                            duration: 150\n                          });\n                          a2.finished.then(done);\n                        },\n                        get children() {\n                          return createComponent(Show, {\n                            get when() {\n                              return isOpened();\n                            },\n                            get children() {\n                              return createComponent(DropdownStyled, {\n                                get hidden() {\n                                  return !isOpened();\n                                },\n                                onClose: () => setIsOpened(false),\n                                ref(r$) {\n                                  var _ref$ = dropDownRef;\n                                  typeof _ref$ === \"function\" ? _ref$(r$) : dropDownRef = r$;\n                                }\n                              });\n                            }\n                          });\n                        }\n                      }), null);\n                      insert(_el$, createComponent(NotificationsStyled, {}), null);\n                      createRenderEffect((_p$) => {\n                        var _a2, _b2;\n                        var _v$ = position.strategy, _v$2 = `${(_a2 = position.y) != null ? _a2 : 0}px`, _v$3 = `${(_b2 = position.x) != null ? _b2 : 0}px`;\n                        _v$ !== _p$.e && ((_p$.e = _v$) != null ? _el$.style.setProperty(\"position\", _v$) : _el$.style.removeProperty(\"position\"));\n                        _v$2 !== _p$.t && ((_p$.t = _v$2) != null ? _el$.style.setProperty(\"top\", _v$2) : _el$.style.removeProperty(\"top\"));\n                        _v$3 !== _p$.a && ((_p$.a = _v$3) != null ? _el$.style.setProperty(\"left\", _v$3) : _el$.style.removeProperty(\"left\"));\n                        return _p$;\n                      }, {\n                        e: void 0,\n                        t: void 0,\n                        a: void 0\n                      });\n                      return _el$;\n                    }\n                  })];\n                }\n              });\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst StyledModal = styled(Modal)`\n    padding-left: 24px;\n    padding-right: 24px;\n    padding-top: 18px;\n    padding-bottom: 0;\n\n    ${media(\"mobile\")} {\n        padding-left: 0;\n        padding-right: 0;\n    }\n`;\nconst H1Styled$a = styled(H1)`\n    margin-top: 12px;\n\n    ${media(\"mobile\")} {\n        padding: 0 10px;\n    }\n`;\nconst LoaderContainerStyled = styled.div`\n    margin: 30px 0;\n    width: 100%;\n    display: flex;\n    justify-content: center;\n\n    ${media(\"mobile\")} {\n        height: 160px;\n        align-items: center;\n    }\n`;\nstyled(Text)`\n    min-width: 84px;\n    text-align: center;\n    font-weight: 590;\n`;\nstyled(TabBar)`\n    margin: 0 auto 22px;\n`;\nconst [appState, setAppState] = createStore({\n  buttonRootId: null,\n  language: \"en\",\n  returnStrategy: \"back\",\n  twaReturnUrl: void 0,\n  walletsListConfiguration: {},\n  enableAndroidBackHandler: true\n});\nfunction uniq(array) {\n  return [...new Set(array)];\n}\nfunction mergeConcat(idKey, array1, array2) {\n  return array1.map((item1) => {\n    const item2 = array2.find((elem) => elem[idKey] === item1[idKey]);\n    array2 = array2.filter((elem) => elem[idKey] !== item1[idKey]);\n    return item2 === void 0 ? item1 : item2;\n  }).concat(array2);\n}\nfunction uiWalletToWalletInfo(uiWallet) {\n  if (\"jsBridgeKey\" in uiWallet) {\n    return __spreadProps(__spreadValues({}, uiWallet), {\n      injected: _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnect.isWalletInjected(uiWallet.jsBridgeKey),\n      embedded: _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnect.isInsideWalletBrowser(uiWallet.jsBridgeKey)\n    });\n  }\n  return uiWallet;\n}\nfunction applyWalletsListConfiguration(walletsList, configuration) {\n  var _a2;\n  if (!configuration) {\n    return walletsList;\n  }\n  if ((_a2 = configuration.includeWallets) == null ? void 0 : _a2.length) {\n    walletsList = mergeConcat(\n      \"name\",\n      walletsList,\n      configuration.includeWallets.map(uiWalletToWalletInfo)\n    );\n  }\n  return walletsList;\n}\nfunction supportsDesktop(walletInfo) {\n  return walletInfo.platforms.some((w) => [\"macos\", \"linux\", \"windows\"].includes(w));\n}\nfunction supportsMobile(walletInfo) {\n  return walletInfo.platforms.some((w) => [\"ios\", \"android\"].includes(w));\n}\nfunction supportsExtension(walletInfo) {\n  return walletInfo.platforms.some((w) => [\"chrome\", \"firefox\", \"safari\"].includes(w));\n}\nfunction eqWalletName(wallet1, name) {\n  if (!name) {\n    return false;\n  }\n  return wallet1.name.toLowerCase() === name.toLowerCase() || wallet1.appName.toLowerCase() === name.toLowerCase();\n}\nconst DesktopSelectWalletModalStyled = styled.div`\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n`;\nconst H1Styled$9 = styled(H1)`\n    margin-bottom: 18px;\n`;\nstyled.div`\n    height: 1px;\n    margin: 0 -24px;\n    width: calc(100% + 48px);\n    opacity: 0.12;\n    background: ${(props) => props.isShown ? props.theme.colors.icon.secondary : \"transparent\"};\n    transition: background 0.15s ease-in-out;\n\n    ${media(\"mobile\")} {\n        width: 100%;\n    }\n`;\nconst WalletsUl = styled.ul`\n    display: grid;\n    grid-template-columns: repeat(auto-fit, 92px);\n    grid-template-rows: auto;\n    align-content: flex-start;\n    row-gap: 8px;\n    width: 100%;\n    padding: 0 0 16px;\n    align-self: flex-start;\n    max-width: 400px;\n    margin: 0 auto;\n    list-style: none;\n\n    > li {\n        display: block;\n        height: fit-content;\n    }\n\n    ${media(\"mobile\")} {\n        display: grid;\n        grid-template-columns: repeat(4, 1fr);\n        gap: 0;\n        padding: 8px 12px 16px;\n        max-width: none;\n\n        > li {\n            min-width: 78px;\n            display: flex;\n        }\n\n        > li > * {\n            width: 100%;\n        }\n    }\n`;\nstyled(Button)`\n    display: block;\n    margin: 0 auto 1px;\n    font-size: 15px;\n`;\nconst StyledIconButton$5 = styled(IconButton)`\n    position: absolute;\n    top: 16px;\n    left: 16px;\n`;\nconst WalletLabeledItemStyled = styled(WalletLabeledItem)`\n    opacity: ${(props) => props.withOpacity ? \"0.4\" : \"1\"};\n`;\nconst WalletsNotSupportedNotifier = styled.div`\n    display: grid;\n    grid-template-columns: auto 28px;\n    gap: 16px;\n    padding: 16px;\n    margin-bottom: 16px;\n    border-radius: 16px;\n    color: ${(props) => props.theme.colors.text.secondary};\n    background: ${(props) => props.theme.colors.background.tint};\n\n    ${media(\"mobile\")} {\n        margin-left: 16px;\n        margin-right: 16px;\n    }\n`;\nconst WalletsNotSupportedNotifierText = styled(H2)`\n    color: ${(props) => props.theme.colors.text.secondary};\n    text-align: left;\n    margin: 0;\n`;\nconst ErrorBoxStyled = styled.div`\n    position: absolute;\n    bottom: 14px;\n    left: 50%;\n    transform: translate(-50%, 0);\n\n    text-wrap: nowrap;\n    display: flex;\n    gap: 6px;\n    align-items: center;\n    border-radius: 18px;\n    min-width: 126px;\n    padding: 9px 16px 9px 10px;\n\n    filter: drop-shadow(0px 2px 8px rgba(0, 0, 0, 0.08));\n    background-color: ${(props) => props.theme.colors.background.segment};\n`;\nvar _tmpl$$3 = /* @__PURE__ */ template$1(`<svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none xmlns=http://www.w3.org/2000/svg><g clip-path=url(#clip0_5122_10355)><circle cx=8 cy=8 r=8></circle><circle cx=8 cy=11 r=1></circle><path d=\"M7.04994 4.99875C7.02277 4.45542 7.45598 4 8 4C8.54402 4 8.97723 4.45541 8.95006 4.99875L8.78745 8.25094C8.76647 8.67055 8.42014 9 8 9C7.57986 9 7.23353 8.67055 7.21255 8.25094L7.04994 4.99875Z\"></path></g><defs><clipPath id=clip0_5122_10355><rect width=16 height=16>`), _tmpl$2$1 = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=28 height=28 viewBox=\"0 0 28 28\"fill=none><circle cx=14 cy=14 r=12></circle><circle cx=14 cy=18.9 r=1.4></circle><path d=\"M12.6658 8.89845C12.63 8.13698 13.2377 7.5 14 7.5C14.7623 7.5 15.37 8.13698 15.3342 8.89845L15.047 15.0013C15.0207 15.5604 14.5597 16.0002 14 16.0002C13.4403 16.0002 12.9793 15.5604 12.953 15.0013L12.6658 8.89845Z\">`);\nconst ExclamationIcon = (props) => {\n  const theme = useTheme();\n  const size = () => props.size;\n  const fill = () => props.fill || theme.colors.icon.error;\n  return memo(() => memo(() => size() === \"16\")() ? (() => {\n    var _el$ = _tmpl$$3(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.nextSibling, _el$5 = _el$4.nextSibling, _el$6 = _el$2.nextSibling, _el$7 = _el$6.firstChild, _el$8 = _el$7.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = fill(), _v$2 = theme.colors.constant.white, _v$3 = theme.colors.constant.white, _v$4 = theme.colors.constant.white;\n      _v$ !== _p$.e && setAttribute(_el$3, \"fill\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$4, \"fill\", _p$.t = _v$2);\n      _v$3 !== _p$.a && setAttribute(_el$5, \"fill\", _p$.a = _v$3);\n      _v$4 !== _p$.o && setAttribute(_el$8, \"fill\", _p$.o = _v$4);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0,\n      o: void 0\n    });\n    return _el$;\n  })() : memo(() => size() === \"28\")() ? (() => {\n    var _el$9 = _tmpl$2$1(), _el$0 = _el$9.firstChild, _el$1 = _el$0.nextSibling, _el$10 = _el$1.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$5 = props.class, _v$6 = fill(), _v$7 = theme.colors.constant.white, _v$8 = theme.colors.constant.white;\n      _v$5 !== _p$.e && setAttribute(_el$9, \"class\", _p$.e = _v$5);\n      _v$6 !== _p$.t && setAttribute(_el$0, \"fill\", _p$.t = _v$6);\n      _v$7 !== _p$.a && setAttribute(_el$1, \"fill\", _p$.a = _v$7);\n      _v$8 !== _p$.o && setAttribute(_el$10, \"fill\", _p$.o = _v$8);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0,\n      o: void 0\n    });\n    return _el$9;\n  })() : null);\n};\nconst WALLET_CONNECT_APP_NAME = \"wallet_connect\";\nconst WALLET_CONNECT_WALLET_NAME = \"WalletConnect\";\nconst WALLET_CONNECT_ABOUT_URL = \"https://reown.com/\";\nvar _tmpl$$2 = /* @__PURE__ */ template$1(`<li>`);\nconst AllWalletsListModal = (props) => {\n  const maxHeight = () => isMobile() ? void 0 : 510;\n  const connector = appState.connector;\n  const additionalRequest = appState.connectRequestParameters;\n  const connectWalletConnect = () => {\n    connector.connect({\n      type: \"wallet-connect\"\n    }, (additionalRequest == null ? void 0 : additionalRequest.state) === \"ready\" ? additionalRequest.value : void 0);\n  };\n  const [errorSupportOpened, setErrorSupportOpened] = createSignal(null);\n  let timeoutId = null;\n  const onErrorClick = (wallet) => {\n    setErrorSupportOpened(wallet);\n    if (timeoutId != null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => setErrorSupportOpened(null), 1500);\n  };\n  const handleSelectWallet = (wallet) => {\n    if (!wallet.isSupportRequiredFeatures && props.featureCheckMode === \"strict\") {\n      onErrorClick(wallet);\n      return;\n    }\n    props.onSelect(wallet);\n  };\n  const walletsList = () => isMobile() ? props.walletsList.filter(supportsMobile) : props.walletsList;\n  const supportedWallets = () => walletsList().filter((wallet) => wallet.isSupportRequiredFeatures);\n  setLastVisibleWalletsInfo({\n    walletsMenu: \"other_wallets\",\n    wallets: supportedWallets()\n  });\n  const unsupportedWallets = () => walletsList().filter((wallet) => !wallet.isSupportRequiredFeatures);\n  return createComponent(DesktopSelectWalletModalStyled, {\n    \"data-tc-wallets-modal-list\": \"true\",\n    get children() {\n      return [createComponent(StyledIconButton$5, {\n        icon: \"arrow\",\n        onClick: () => props.onBack()\n      }), createComponent(H1Styled$9, {\n        translationKey: \"walletModal.wallets\",\n        children: \"Wallets\"\n      }), createComponent(ScrollContainer, {\n        get maxHeight() {\n          return maxHeight();\n        },\n        get children() {\n          return [createComponent(WalletsUl, {\n            get children() {\n              return [createComponent(For, {\n                get each() {\n                  return supportedWallets();\n                },\n                children: (wallet) => (() => {\n                  var _el$ = _tmpl$$2();\n                  insert(_el$, createComponent(WalletLabeledItemStyled, {\n                    wallet,\n                    onClick: () => props.onSelect(wallet)\n                  }));\n                  return _el$;\n                })()\n              }), createComponent(Show, {\n                get when() {\n                  return memo(() => !!!isInTMA())() && (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletConnectInitialized)();\n                },\n                get children() {\n                  return createComponent(WalletLabeledItemStyled, {\n                    get wallet() {\n                      return {\n                        type: \"wallet-connect\",\n                        name: WALLET_CONNECT_WALLET_NAME,\n                        appName: WALLET_CONNECT_APP_NAME,\n                        imageUrl: IMG.WALLET_CONNECT\n                      };\n                    },\n                    onClick: connectWalletConnect\n                  });\n                }\n              })];\n            }\n          }), createComponent(Show, {\n            get when() {\n              return unsupportedWallets().length > 0 && props.featureCheckMode !== \"hide\";\n            },\n            get children() {\n              return [createComponent(WalletsNotSupportedNotifier, {\n                get children() {\n                  return [createComponent(WalletsNotSupportedNotifierText, {\n                    translationKey: \"walletModal.allWallets.walletsBelowNotSupported\",\n                    children: \"The wallets below dont support all features of the connected service. You can use your recovery phrase in one of the supported wallets above.\"\n                  }), createComponent(ExclamationIcon, {\n                    size: \"28\"\n                  })];\n                }\n              }), createComponent(WalletsUl, {\n                get children() {\n                  return createComponent(For, {\n                    get each() {\n                      return unsupportedWallets();\n                    },\n                    children: (wallet) => (() => {\n                      var _el$2 = _tmpl$$2();\n                      insert(_el$2, createComponent(WalletLabeledItemStyled, {\n                        wallet,\n                        onClick: () => handleSelectWallet(wallet),\n                        get withOpacity() {\n                          return props.featureCheckMode === \"strict\";\n                        }\n                      }));\n                      return _el$2;\n                    })()\n                  });\n                }\n              }), createComponent(Transition, {\n                onBeforeEnter: (el) => {\n                  animate(el, [{\n                    opacity: 0,\n                    transform: \"translate(-50%, 44px)\"\n                  }, {\n                    opacity: 1,\n                    transform: \"translate(-50%, 0)\"\n                  }], {\n                    duration: 150,\n                    easing: \"ease-out\"\n                  });\n                },\n                onExit: (el, done) => {\n                  animate(el, [{\n                    opacity: 1,\n                    transform: \"translate(-50%, 0)\"\n                  }, {\n                    opacity: 0,\n                    transform: \"translate(-50%, 44px)\"\n                  }], {\n                    duration: 150,\n                    easing: \"ease-out\"\n                  }).finished.then(() => {\n                    done();\n                  });\n                },\n                get children() {\n                  return createComponent(Show, {\n                    get when() {\n                      return errorSupportOpened();\n                    },\n                    get children() {\n                      return createComponent(ErrorBoxStyled, {\n                        get children() {\n                          return [createComponent(ErrorIcon, {\n                            size: \"xs\"\n                          }), createComponent(Text, {\n                            translationKey: \"walletModal.allWallets.walletNotSupportService\",\n                            get translationValues() {\n                              return {\n                                name: errorSupportOpened().name\n                              };\n                            },\n                            get children() {\n                              return [memo(() => errorSupportOpened().name), \" doesnt support connected service\"];\n                            }\n                          })];\n                        }\n                      });\n                    }\n                  });\n                }\n              })];\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst tgButtonBorders = {\n  m: \"16px\",\n  s: \"12px\",\n  none: \"0\"\n};\nconst tgIconBorders = {\n  m: \"6px\",\n  s: \"6px\",\n  none: \"0\"\n};\nconst DesktopConnectionModalStyled = styled.div`\n    display: flex;\n    flex-direction: column;\n`;\nconst BodyStyled$1 = styled.div`\n    flex: 1;\n    margin-top: ${(props) => props.qr ? \"0\" : \"18px\"};\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    min-height: 232px;\n`;\nconst QRCodeStyled$1 = styled(QRCode)`\n    margin-bottom: 24px;\n`;\nconst H1Styled$8 = styled(H1)`\n    max-width: 288px;\n    margin: 0 auto 2px;\n`;\nconst H2Styled$4 = styled(H2)`\n    max-width: 288px;\n    text-align: center;\n    margin: 0 auto 20px;\n`;\nconst StyledIconButton$4 = styled(IconButton)`\n    position: absolute;\n    top: 16px;\n    left: 16px;\n`;\nconst ButtonsContainerStyled$2 = styled.div`\n    display: flex;\n    justify-content: center;\n    gap: 8px;\n    padding-bottom: 16px;\n`;\nconst BottomButtonsContainerStyled = styled(ButtonsContainerStyled$2)`\n    padding-bottom: 0;\n`;\nconst FooterButton$1 = styled(Button)`\n    margin-bottom: 24px;\n`;\nconst LoaderStyled$1 = styled(LoaderIcon)`\n    margin-bottom: 18px;\n    margin-top: 2px;\n`;\nconst ErrorIconStyled$2 = styled(ErrorIcon)`\n    margin-bottom: 16px;\n`;\nconst BodyTextStyled$2 = styled(H2)`\n    color: ${(props) => props.theme.colors.text.secondary};\n    text-align: center;\n    margin-bottom: 20px;\n`;\nconst TgButtonStyled = styled(Button)`\n    margin-top: -8px;\n    margin-bottom: 24px;\n    width: 100%;\n    padding: 12px 12px 12px 20px;\n    border-radius: ${(props) => tgButtonBorders[props.theme.borderRadius]};\n    font-size: 16px;\n    line-height: 20px;\n`;\nconst TgImageStyled = styled(Image)`\n    width: 32px;\n    height: 32px;\n    border-radius: ${(props) => tgIconBorders[props.theme.borderRadius]};\n`;\nconst Translation = (props) => {\n  const [t2] = useI18n();\n  return memo(() => {\n    var _a2;\n    return t2(props.translationKey, props.translationValues, (_a2 = props.children) == null ? void 0 : _a2.toString());\n  });\n};\nfunction addReturnStrategy(url, strategy) {\n  let returnStrategy;\n  if (typeof strategy === \"string\") {\n    returnStrategy = strategy;\n  } else {\n    returnStrategy = isInTMA() ? strategy.twaReturnUrl || strategy.returnStrategy : \"none\";\n  }\n  const newUrl = addQueryParameter(url, \"ret\", returnStrategy);\n  if (!(0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isTelegramUrl)(url)) {\n    return newUrl;\n  }\n  const lastParam = newUrl.slice(newUrl.lastIndexOf(\"&\") + 1);\n  return newUrl.slice(0, newUrl.lastIndexOf(\"&\")) + \"-\" + (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.encodeTelegramUrlParameters)(lastParam);\n}\nfunction redirectToTelegram(universalLink, options) {\n  options = __spreadValues({}, options);\n  const directLink = convertToTGDirectLink(universalLink);\n  const directLinkUrl = new URL(directLink);\n  if (!directLinkUrl.searchParams.has(\"startapp\")) {\n    directLinkUrl.searchParams.append(\"startapp\", \"tonconnect\");\n  }\n  if (isInTelegramBrowser()) {\n    options.returnStrategy = \"back\";\n    const linkWithStrategy = addReturnStrategy(\n      directLinkUrl.toString(),\n      options.returnStrategy\n    );\n    openLinkBlank(linkWithStrategy);\n  } else if (isInTMA()) {\n    if (isTmaPlatform(\"ios\", \"android\", \"macos\", \"tdesktop\", \"web\")) {\n      options.returnStrategy = \"back\";\n      const linkWithStrategy = addReturnStrategy(\n        directLinkUrl.toString(),\n        options.returnStrategy\n      );\n      sendOpenTelegramLink(linkWithStrategy);\n    } else if (isTmaPlatform(\"weba\")) {\n      sendOpenTelegramLink(addReturnStrategy(directLinkUrl.toString(), options));\n    } else {\n      openLinkBlank(addReturnStrategy(directLinkUrl.toString(), options));\n    }\n  } else {\n    if (isOS(\"ios\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"safari\")) {\n          options.returnStrategy = \"back\";\n        } else if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = location.href;\n        }\n      }\n      const isChrome = isBrowser(\"chrome\");\n      const isFirefox = isBrowser(\"firefox\");\n      const useDeepLink = (isChrome || isFirefox) && !options.forceRedirect;\n      if (useDeepLink) {\n        const linkWithStrategy = addReturnStrategy(\n          directLinkUrl.toString(),\n          options.returnStrategy\n        );\n        const deepLink = convertToTGDeepLink(linkWithStrategy);\n        openDeeplinkWithFallback(deepLink, () => openLinkBlank(linkWithStrategy));\n      } else {\n        const linkWithStrategy = addReturnStrategy(\n          directLinkUrl.toString(),\n          options.returnStrategy\n        );\n        openLinkBlank(linkWithStrategy);\n      }\n    } else if (isOS(\"android\")) {\n      options.returnStrategy = \"back\";\n      const isChrome = isBrowser(\"chrome\");\n      const isFirefox = isBrowser(\"firefox\");\n      const useDeepLink = (isChrome || isFirefox) && !options.forceRedirect;\n      if (useDeepLink) {\n        const linkWithStrategy = addReturnStrategy(\n          directLinkUrl.toString(),\n          options.returnStrategy\n        );\n        const deepLink = convertToTGDeepLink(linkWithStrategy);\n        openDeeplinkWithFallback(deepLink, () => openLinkBlank(linkWithStrategy));\n      } else {\n        const linkWithStrategy = addReturnStrategy(\n          directLinkUrl.toString(),\n          options.returnStrategy\n        );\n        openLinkBlank(linkWithStrategy);\n      }\n    } else if (isOS(\"ipad\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"safari\")) {\n          options.returnStrategy = \"back\";\n        } else if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = location.href;\n        }\n      }\n      const isChrome = isBrowser(\"chrome\");\n      const isFirefox = isBrowser(\"firefox\");\n      const useDeepLink = (isChrome || isFirefox) && !options.forceRedirect;\n      const linkWithStrategy = addReturnStrategy(\n        directLinkUrl.toString(),\n        options.returnStrategy\n      );\n      if (useDeepLink) {\n        const deepLink = convertToTGDeepLink(linkWithStrategy);\n        openDeeplinkWithFallback(deepLink, () => openLinkBlank(linkWithStrategy));\n      } else {\n        openLinkBlank(linkWithStrategy);\n      }\n    } else if (isOS(\"macos\", \"windows\", \"linux\")) {\n      options.returnStrategy = \"back\";\n      options.twaReturnUrl = void 0;\n      const linkWithStrategy = addReturnStrategy(\n        directLinkUrl.toString(),\n        options.returnStrategy\n      );\n      if (options.forceRedirect) {\n        openLinkBlank(linkWithStrategy);\n      } else {\n        const deepLink = convertToTGDeepLink(linkWithStrategy);\n        openDeeplinkWithFallback(deepLink, () => openLinkBlank(linkWithStrategy));\n      }\n    } else {\n      openLinkBlank(addReturnStrategy(directLinkUrl.toString(), options));\n    }\n  }\n}\nfunction redirectToWallet(universalLink, deepLink, options, setOpenMethod) {\n  options = __spreadValues({}, options);\n  if (isInTelegramBrowser()) {\n    if (isOS(\"ios\", \"android\")) {\n      if (options.returnStrategy === \"back\") {\n        options.returnStrategy = \"tg://resolve\";\n      }\n      setOpenMethod(\"universal-link\");\n      openLink(addReturnStrategy(universalLink, options.returnStrategy), \"_self\");\n    } else {\n      setOpenMethod(\"universal-link\");\n      const linkWithStrategy = addReturnStrategy(universalLink, options.returnStrategy);\n      openLinkBlank(linkWithStrategy);\n    }\n  } else if (isInTMA()) {\n    if (isTmaPlatform(\"ios\", \"android\")) {\n      if (options.returnStrategy === \"back\") {\n        options.returnStrategy = \"tg://resolve\";\n      }\n      setOpenMethod(\"universal-link\");\n      const linkWithStrategy = addReturnStrategy(universalLink, options.returnStrategy);\n      sendOpenTelegramLink(linkWithStrategy, () => {\n        setOpenMethod(\"universal-link\");\n        openLinkBlank(linkWithStrategy);\n      });\n    } else if (isTmaPlatform(\"macos\", \"tdesktop\")) {\n      if (options.returnStrategy === \"back\") {\n        options.returnStrategy = \"tg://resolve\";\n      }\n      const linkWithStrategy = addReturnStrategy(universalLink, options.returnStrategy);\n      const useDeepLink = !!deepLink && !options.forceRedirect;\n      if (useDeepLink) {\n        setOpenMethod(\"custom-deeplink\");\n        openDeeplinkWithFallback(toDeeplink(linkWithStrategy, deepLink), () => {\n          setOpenMethod(\"universal-link\");\n          openLinkBlank(linkWithStrategy);\n        });\n      } else {\n        setOpenMethod(\"universal-link\");\n        openLinkBlank(linkWithStrategy);\n      }\n    } else if (isTmaPlatform(\"weba\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"safari\")) {\n          options.returnStrategy = location.href;\n        } else if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = location.href;\n        }\n      }\n      const linkWithStrategy = addReturnStrategy(universalLink, options.returnStrategy);\n      const useDeepLink = !!deepLink && !options.forceRedirect;\n      if (useDeepLink) {\n        setOpenMethod(\"custom-deeplink\");\n        openDeeplinkWithFallback(toDeeplink(linkWithStrategy, deepLink), () => {\n          setOpenMethod(\"universal-link\");\n          openLinkBlank(linkWithStrategy);\n        });\n      } else {\n        setOpenMethod(\"universal-link\");\n        openLinkBlank(linkWithStrategy);\n      }\n    } else if (isTmaPlatform(\"web\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"safari\")) {\n          options.returnStrategy = location.href;\n        } else if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = location.href;\n        }\n      }\n      const linkWithStrategy = addReturnStrategy(universalLink, options.returnStrategy);\n      const useDeepLink = !!deepLink && !options.forceRedirect;\n      if (useDeepLink) {\n        setOpenMethod(\"custom-deeplink\");\n        openDeeplinkWithFallback(toDeeplink(linkWithStrategy, deepLink), () => {\n          setOpenMethod(\"universal-link\");\n          openLinkBlank(linkWithStrategy);\n        });\n      } else {\n        setOpenMethod(\"universal-link\");\n        openLinkBlank(linkWithStrategy);\n      }\n    } else {\n      setOpenMethod(\"universal-link\");\n      const linkWithStrategy = addReturnStrategy(universalLink, options.returnStrategy);\n      openLinkBlank(linkWithStrategy);\n    }\n  } else {\n    if (isOS(\"ios\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"safari\")) {\n          options.returnStrategy = \"none\";\n        } else if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = location.href;\n        }\n      }\n      if (isBrowser(\"chrome\")) {\n        setOpenMethod(\"universal-link\");\n        openLink(addReturnStrategy(universalLink, options.returnStrategy), \"_self\");\n      } else {\n        setOpenMethod(\"universal-link\");\n        openLinkBlank(addReturnStrategy(universalLink, options.returnStrategy));\n      }\n    } else if (isOS(\"android\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = location.href;\n        }\n      }\n      setOpenMethod(\"universal-link\");\n      openLinkBlank(addReturnStrategy(universalLink, options.returnStrategy));\n    } else if (isOS(\"ipad\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"safari\")) {\n          options.returnStrategy = \"none\";\n        } else if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = location.href;\n        }\n      }\n      if (isBrowser(\"chrome\")) {\n        setOpenMethod(\"universal-link\");\n        openLink(addReturnStrategy(universalLink, options.returnStrategy), \"_self\");\n      } else {\n        setOpenMethod(\"universal-link\");\n        openLinkBlank(addReturnStrategy(universalLink, options.returnStrategy));\n      }\n    } else if (isOS(\"macos\", \"windows\", \"linux\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"safari\")) {\n          options.returnStrategy = \"none\";\n        } else if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = \"none\";\n        }\n      }\n      const linkWithStrategy = addReturnStrategy(universalLink, options.returnStrategy);\n      const useDeepLink = !!deepLink && !options.forceRedirect;\n      if (useDeepLink) {\n        setOpenMethod(\"custom-deeplink\");\n        openDeeplinkWithFallback(toDeeplink(linkWithStrategy, deepLink), () => {\n          setOpenMethod(\"universal-link\");\n          openLinkBlank(linkWithStrategy);\n        });\n      } else {\n        setOpenMethod(\"universal-link\");\n        openLinkBlank(linkWithStrategy);\n      }\n    } else {\n      setOpenMethod(\"universal-link\");\n      openLinkBlank(addReturnStrategy(universalLink, options.returnStrategy));\n    }\n  }\n}\nfunction enrichUniversalLink(universalLink, params) {\n  var _a2, _b2;\n  if (!(0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isTelegramUrl)(universalLink)) {\n    return addQueryParametersIfNotPresented(universalLink, {\n      id: params.sessionId,\n      trace_id: params.traceId\n    });\n  }\n  const directLink = convertToTGDirectLink(universalLink);\n  const directLinkUrl = new URL(directLink);\n  const previousStartApp = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.decodeTelegramUrlParameters)(\n    (_a2 = directLinkUrl.searchParams.get(\"startapp\")) != null ? _a2 : \"\"\n  );\n  let searchParams = buildSearchParams(previousStartApp);\n  const sessionId = (_b2 = params.sessionId) != null ? _b2 : searchParams.get(\"id\");\n  const traceId = params.traceId;\n  const orderedKeys = [\"tonconnect\", \"v\", \"id\", \"trace_id\"];\n  const unorderedParams = Array.from(searchParams.entries()).filter(\n    ([key]) => !orderedKeys.includes(key)\n  );\n  const startApp = buildQueryParams(__spreadProps(__spreadValues({\n    tonconnect: \"\",\n    v: \"2\",\n    id: sessionId\n  }, Object.fromEntries(unorderedParams)), {\n    trace_id: traceId\n  })).replace(\"=&\", \"&\");\n  directLinkUrl.searchParams.set(\"startapp\", (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.encodeTelegramUrlParameters)(startApp));\n  return directLinkUrl.toString();\n}\nfunction addQueryParameter(url, key, value) {\n  const parsed = new URL(url);\n  parsed.searchParams.append(key, value);\n  return parsed.toString();\n}\nfunction addQueryParametersIfNotPresented(url, params) {\n  const parsed = new URL(url);\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      parsed.searchParams.set(key, value);\n    }\n  }\n  return parsed.toString();\n}\nfunction convertToTGDirectLink(universalLink) {\n  const url = new URL(universalLink);\n  if (url.searchParams.has(\"attach\")) {\n    url.searchParams.delete(\"attach\");\n    url.pathname += \"/start\";\n  }\n  return url.toString();\n}\nfunction buildSearchParams(search = \"\") {\n  const url = new URL(\"https://example.com\");\n  url.search = search;\n  return url.searchParams;\n}\nfunction buildQueryParams(params) {\n  const searchParams = buildSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      searchParams.append(key, value);\n    }\n  }\n  return searchParams.toString();\n}\nfunction convertToTGDeepLink(directLink) {\n  const parsed = new URL(directLink);\n  const [, domain, appname] = parsed.pathname.split(\"/\");\n  const startapp = parsed.searchParams.get(\"startapp\");\n  return `tg://resolve?domain=${domain}&appname=${appname}&startapp=${startapp}`;\n}\nconst DesktopConnectionModal = (props) => {\n  const [mode, setMode] = createSignal(\"mobile\");\n  const [connectionErrored, setConnectionErrored] = createSignal(null);\n  createEffect(() => {\n    var _a2;\n    setConnectionErrored((_a2 = props.defaultError) != null ? _a2 : null);\n  });\n  const [universalLink, setUniversalLink] = createSignal();\n  const [firstClick, setFirstClick] = createSignal(true);\n  const connector = useContext(ConnectorContext);\n  const unsubscribe = connector.onStatusChange(() => {\n  }, (error) => {\n    if (error instanceof _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletMissingRequiredFeaturesError) {\n      setConnectionErrored(\"missing-features\");\n      return;\n    }\n    if (error instanceof _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletWrongNetworkError) {\n      setConnectionErrored(\"wrong-network\");\n      return;\n    }\n    if (props.wallet.appName !== AT_WALLET_APP_NAME) {\n      setConnectionErrored(\"connection-declined\");\n    }\n  });\n  onCleanup(unsubscribe);\n  const generateUniversalLink = () => {\n    var _a2;\n    try {\n      const universalLink2 = connector.connect({\n        universalLink: props.wallet.universalLink,\n        bridgeUrl: props.wallet.bridgeUrl\n      }, props.additionalRequest, {\n        traceId: (_a2 = props.walletsModalState) == null ? void 0 : _a2.traceId\n      });\n      setUniversalLink(universalLink2);\n    } catch (e2) {\n    }\n  };\n  createEffect(() => {\n    if (untrack(mode) !== \"extension\" && (supportsMobile(props.wallet) || supportsDesktop(props.wallet))) {\n      generateUniversalLink();\n    }\n  });\n  const onClickMobile = () => {\n    setConnectionErrored(null);\n    if (mode() === \"extension\") {\n      generateUniversalLink();\n    }\n    setMode(\"mobile\");\n    setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, props.wallet), {\n      openMethod: \"qrcode\"\n    }));\n  };\n  const onClickDesktop = () => {\n    setConnectionErrored(null);\n    if (mode() === \"extension\") {\n      generateUniversalLink();\n    }\n    setMode(\"desktop\");\n    if ((0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isTelegramUrl)(universalLink())) {\n      onClickTelegram();\n    } else {\n      const forceRedirect = !firstClick();\n      setFirstClick(false);\n      redirectToWallet(universalLink(), props.wallet.deepLink, {\n        returnStrategy: appState.returnStrategy,\n        forceRedirect\n      }, (method) => {\n        setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, props.wallet), {\n          openMethod: method\n        }));\n      });\n    }\n  };\n  const onClickTelegram = () => {\n    const forceRedirect = !firstClick();\n    setFirstClick(false);\n    setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, props.wallet), {\n      openMethod: \"universal-link\"\n    }));\n    redirectToTelegram(universalLink(), {\n      returnStrategy: appState.returnStrategy,\n      twaReturnUrl: appState.twaReturnUrl,\n      forceRedirect\n    });\n  };\n  const onClickExtension = () => {\n    var _a2;\n    setConnectionErrored(null);\n    setMode(\"extension\");\n    if ((0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyInjected)(props.wallet)) {\n      setLastSelectedWalletInfo(props.wallet);\n      connector.connect({\n        jsBridgeKey: props.wallet.jsBridgeKey\n      }, props.additionalRequest, {\n        traceId: (_a2 = props.walletsModalState) == null ? void 0 : _a2.traceId\n      });\n    }\n  };\n  if (supportsMobile(props.wallet)) {\n    onClickMobile();\n  } else if (supportsExtension(props.wallet)) {\n    onClickExtension();\n  } else {\n    onClickDesktop();\n  }\n  return createComponent(DesktopConnectionModalStyled, {\n    \"data-tc-wallets-modal-connection-desktop\": \"true\",\n    get children() {\n      return [createComponent(Show, {\n        get when() {\n          return !props.backDisabled;\n        },\n        get children() {\n          return createComponent(StyledIconButton$4, {\n            icon: \"arrow\",\n            onClick: () => props.onBackClick()\n          });\n        }\n      }), createComponent(H1Styled$8, {\n        get children() {\n          return props.wallet.name;\n        }\n      }), createComponent(Show, {\n        get when() {\n          return memo(() => mode() === \"mobile\")() && !connectionErrored();\n        },\n        get children() {\n          return createComponent(H2Styled$4, {\n            translationKey: \"walletModal.desktopConnectionModal.scanQR\",\n            get translationValues() {\n              return {\n                name: props.wallet.name\n              };\n            },\n            get children() {\n              return [\"Scan the QR code below with your phones or \", memo(() => props.wallet.name), \"s camera\"];\n            }\n          });\n        }\n      }), createComponent(BodyStyled$1, {\n        get qr() {\n          return mode() === \"mobile\";\n        },\n        get children() {\n          return createComponent(Switch, {\n            get children() {\n              return [createComponent(Match, {\n                get when() {\n                  return connectionErrored();\n                },\n                get children() {\n                  return [createComponent(ErrorIconStyled$2, {\n                    size: \"s\"\n                  }), createComponent(Switch, {\n                    get children() {\n                      return [createComponent(Match, {\n                        get when() {\n                          return connectionErrored() === \"missing-features\";\n                        },\n                        get children() {\n                          return createComponent(BodyTextStyled$2, {\n                            translationKey: \"walletModal.desktopConnectionModal.missingFeatures\",\n                            get translationValues() {\n                              return {\n                                name: props.wallet.name\n                              };\n                            },\n                            children: \"Please update Wallet, your version does not support required features for this dApp\"\n                          });\n                        }\n                      }), createComponent(Match, {\n                        get when() {\n                          return connectionErrored() === \"connection-declined\";\n                        },\n                        get children() {\n                          return createComponent(BodyTextStyled$2, {\n                            translationKey: \"walletModal.desktopConnectionModal.connectionDeclined\",\n                            children: \"Connection declined\"\n                          });\n                        }\n                      }), createComponent(Match, {\n                        get when() {\n                          return connectionErrored() === \"not-supported\";\n                        },\n                        get children() {\n                          return createComponent(BodyTextStyled$2, {\n                            translationKey: \"walletModal.desktopConnectionModal.notSupportedWallet\",\n                            get translationValues() {\n                              return {\n                                name: props.wallet.name\n                              };\n                            },\n                            get children() {\n                              return [memo(() => props.wallet.name), \" doesnt support the requested action. Please connect another wallet that supports it.\"];\n                            }\n                          });\n                        }\n                      }), createComponent(Match, {\n                        get when() {\n                          return connectionErrored() === \"wrong-network\";\n                        },\n                        get children() {\n                          return createComponent(BodyTextStyled$2, {\n                            translationKey: \"walletModal.desktopConnectionModal.wrongNetwork\",\n                            get translationValues() {\n                              return {\n                                name: props.wallet.name\n                              };\n                            },\n                            get children() {\n                              return [\"Connected wallet is on a different network. Please switch network in \", memo(() => props.wallet.name), \" and try again.\"];\n                            }\n                          });\n                        }\n                      })];\n                    }\n                  }), createComponent(ButtonsContainerStyled$2, {\n                    get children() {\n                      return [createComponent(Show, {\n                        get when() {\n                          return connectionErrored() !== \"not-supported\";\n                        },\n                        get children() {\n                          return createComponent(Button, {\n                            get leftIcon() {\n                              return createComponent(RetryIcon, {});\n                            },\n                            get onClick() {\n                              return mode() === \"extension\" ? onClickExtension : onClickDesktop;\n                            },\n                            get children() {\n                              return createComponent(Translation, {\n                                translationKey: \"common.retry\",\n                                children: \"Retry\"\n                              });\n                            }\n                          });\n                        }\n                      }), createComponent(Show, {\n                        get when() {\n                          return connectionErrored() === \"missing-features\";\n                        },\n                        get children() {\n                          return createComponent(Link, {\n                            get href() {\n                              return props.wallet.aboutUrl;\n                            },\n                            blank: true,\n                            get children() {\n                              return createComponent(Button, {\n                                get leftIcon() {\n                                  return createComponent(LinkIcon, {});\n                                },\n                                get children() {\n                                  return createComponent(Translation, {\n                                    translationKey: \"walletModal.desktopConnectionModal.updateWallet\",\n                                    get translationValues() {\n                                      return {\n                                        name: props.wallet.name\n                                      };\n                                    },\n                                    get children() {\n                                      return [\"Update \", memo(() => props.wallet.name)];\n                                    }\n                                  });\n                                }\n                              });\n                            }\n                          });\n                        }\n                      }), createComponent(Show, {\n                        get when() {\n                          return connectionErrored() === \"not-supported\";\n                        },\n                        get children() {\n                          return createComponent(Button, {\n                            onClick: () => props.onBackClick(),\n                            get children() {\n                              return createComponent(Translation, {\n                                translationKey: \"walletModal.desktopConnectionModal.chooseAnotherWallet\",\n                                children: \"Choose Another Wallet\"\n                              });\n                            }\n                          });\n                        }\n                      })];\n                    }\n                  })];\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return mode() === \"mobile\";\n                },\n                get children() {\n                  return createComponent(QRCodeStyled$1, {\n                    disableCopy: false,\n                    get sourceUrl() {\n                      return addReturnStrategy(universalLink(), \"none\");\n                    },\n                    get imageUrl() {\n                      return props.wallet.imageUrl;\n                    }\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return mode() === \"extension\";\n                },\n                get children() {\n                  return [createComponent(Show, {\n                    get when() {\n                      return (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyInjected)(props.wallet);\n                    },\n                    get children() {\n                      return [createComponent(LoaderStyled$1, {\n                        size: \"s\"\n                      }), createComponent(BodyTextStyled$2, {\n                        translationKey: \"walletModal.desktopConnectionModal.continueInExtension\",\n                        get translationValues() {\n                          return {\n                            name: props.wallet.name\n                          };\n                        },\n                        get children() {\n                          return [\"Continue in \", memo(() => props.wallet.name), \" browser extension\"];\n                        }\n                      }), createComponent(ButtonsContainerStyled$2, {\n                        get children() {\n                          return createComponent(Button, {\n                            get leftIcon() {\n                              return createComponent(RetryIcon, {});\n                            },\n                            onClick: onClickExtension,\n                            get children() {\n                              return createComponent(Translation, {\n                                translationKey: \"common.retry\",\n                                children: \"Retry\"\n                              });\n                            }\n                          });\n                        }\n                      })];\n                    }\n                  }), createComponent(Show, {\n                    get when() {\n                      return !(0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyInjected)(props.wallet);\n                    },\n                    get children() {\n                      return [createComponent(BodyTextStyled$2, {\n                        translationKey: \"walletModal.desktopConnectionModal.dontHaveExtension\",\n                        get translationValues() {\n                          return {\n                            name: props.wallet.name\n                          };\n                        },\n                        get children() {\n                          return [\"Seems you don't have installed \", memo(() => props.wallet.name), \" browser extension\"];\n                        }\n                      }), createComponent(ButtonsContainerStyled$2, {\n                        get children() {\n                          return createComponent(Link, {\n                            get href() {\n                              return props.wallet.aboutUrl;\n                            },\n                            blank: true,\n                            get children() {\n                              return createComponent(Button, {\n                                get rightIcon() {\n                                  return createComponent(LinkIcon, {});\n                                },\n                                onClick: onClickExtension,\n                                get children() {\n                                  return createComponent(Translation, {\n                                    translationKey: \"walletModal.desktopConnectionModal.getWallet\",\n                                    get translationValues() {\n                                      return {\n                                        name: props.wallet.name\n                                      };\n                                    },\n                                    get children() {\n                                      return [\"Get \", memo(() => props.wallet.name)];\n                                    }\n                                  });\n                                }\n                              });\n                            }\n                          });\n                        }\n                      })];\n                    }\n                  })];\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return mode() === \"desktop\";\n                },\n                get children() {\n                  return [createComponent(LoaderIcon, {\n                    size: \"m\"\n                  }), createComponent(BodyTextStyled$2, {\n                    translationKey: \"walletModal.desktopConnectionModal.continueOnDesktop\",\n                    get translationValues() {\n                      return {\n                        name: props.wallet.name\n                      };\n                    },\n                    get children() {\n                      return [\"Continue in \", memo(() => props.wallet.name), \" on desktop\"];\n                    }\n                  }), createComponent(ButtonsContainerStyled$2, {\n                    get children() {\n                      return [createComponent(Button, {\n                        get leftIcon() {\n                          return createComponent(RetryIcon, {});\n                        },\n                        onClick: onClickDesktop,\n                        get children() {\n                          return createComponent(Translation, {\n                            translationKey: \"common.retry\",\n                            children: \"Retry\"\n                          });\n                        }\n                      }), createComponent(Link, {\n                        get href() {\n                          return props.wallet.aboutUrl;\n                        },\n                        blank: true,\n                        get children() {\n                          return createComponent(Button, {\n                            get rightIcon() {\n                              return createComponent(LinkIcon, {});\n                            },\n                            get children() {\n                              return createComponent(Translation, {\n                                translationKey: \"walletModal.desktopConnectionModal.getWallet\",\n                                get translationValues() {\n                                  return {\n                                    name: props.wallet.name\n                                  };\n                                },\n                                get children() {\n                                  return [\"Get \", memo(() => props.wallet.name)];\n                                }\n                              });\n                            }\n                          });\n                        }\n                      })];\n                    }\n                  })];\n                }\n              })];\n            }\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return props.wallet.appName === AT_WALLET_APP_NAME;\n        },\n        get children() {\n          return createComponent(TgButtonStyled, {\n            get rightIcon() {\n              return createComponent(TgImageStyled, {\n                get src() {\n                  return IMG.TG;\n                }\n              });\n            },\n            scale: \"s\",\n            onClick: onClickTelegram,\n            get children() {\n              return createComponent(Translation, {\n                translationKey: \"walletModal.desktopConnectionModal.openWalletOnTelegram\",\n                children: \"Open Wallet in Telegram on desktop\"\n              });\n            }\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return props.wallet.appName !== AT_WALLET_APP_NAME;\n        },\n        get children() {\n          return createComponent(BottomButtonsContainerStyled, {\n            get children() {\n              return [createComponent(Show, {\n                get when() {\n                  return memo(() => mode() !== \"mobile\")() && supportsMobile(props.wallet);\n                },\n                get children() {\n                  return createComponent(FooterButton$1, {\n                    appearance: \"secondary\",\n                    get leftIcon() {\n                      return createComponent(MobileIcon, {});\n                    },\n                    onClick: onClickMobile,\n                    get children() {\n                      return createComponent(Translation, {\n                        translationKey: \"common.mobile\",\n                        children: \"Mobile\"\n                      });\n                    }\n                  });\n                }\n              }), createComponent(Show, {\n                get when() {\n                  return memo(() => mode() !== \"extension\")() && supportsExtension(props.wallet);\n                },\n                get children() {\n                  return createComponent(FooterButton$1, {\n                    appearance: \"secondary\",\n                    get leftIcon() {\n                      return createComponent(BrowserIcon, {});\n                    },\n                    onClick: onClickExtension,\n                    get children() {\n                      return createComponent(Translation, {\n                        translationKey: \"common.browserExtension\",\n                        children: \"Browser Extension\"\n                      });\n                    }\n                  });\n                }\n              }), createComponent(Show, {\n                get when() {\n                  return memo(() => mode() !== \"desktop\")() && supportsDesktop(props.wallet);\n                },\n                get children() {\n                  return createComponent(FooterButton$1, {\n                    appearance: \"secondary\",\n                    get leftIcon() {\n                      return createComponent(DesktopIcon, {});\n                    },\n                    onClick: onClickDesktop,\n                    get children() {\n                      return createComponent(Translation, {\n                        translationKey: \"common.desktop\",\n                        children: \"Desktop\"\n                      });\n                    }\n                  });\n                }\n              })];\n            }\n          });\n        }\n      })];\n    }\n  });\n};\nconst InfoModalStyled = styled.div``;\nconst StyledIconButton$3 = styled(IconButton)`\n    position: absolute;\n    top: 16px;\n    left: 16px;\n`;\nconst H1Styled$7 = styled(H1)`\n    margin-bottom: 18px;\n`;\nconst InfoBlock = styled.div`\n    padding: 16px 0;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n`;\nconst InfoBlockIconClass = u`\n    margin-bottom: 12px;\n`;\nconst H3Styled$1 = styled(H3)`\n    text-align: center;\n    margin-bottom: 4px;\n`;\nconst TextStyled$2 = styled(Text)`\n    text-align: center;\n    max-width: 352px;\n    color: ${(props) => props.theme.colors.text.secondary};\n`;\nconst ButtonsBlock = styled.div`\n    padding: 16px 24px 24px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    gap: 8px;\n`;\nconst LINKS = {\n  GET_A_WALLET: \"https://ton.org/wallets?filters[wallet_features][slug][$in]=dapp-auth&pagination[limit]=-1\"\n};\nconst InfoModal = (props) => {\n  return createComponent(InfoModalStyled, {\n    \"data-tc-wallets-modal-info\": \"true\",\n    get children() {\n      return [createComponent(StyledIconButton$3, {\n        icon: \"arrow\",\n        onClick: () => props.onBackClick()\n      }), createComponent(H1Styled$7, {\n        translationKey: \"walletModal.infoModal.whatIsAWallet\",\n        children: \"What is a wallet\"\n      }), createComponent(ScrollContainer, {\n        get children() {\n          return [createComponent(InfoBlock, {\n            get children() {\n              return [createComponent(SecurityIcon, {\n                \"class\": InfoBlockIconClass\n              }), createComponent(H3Styled$1, {\n                translationKey: \"walletModal.infoModal.secureDigitalAssets\",\n                children: \"Secure digital assets storage\"\n              }), createComponent(TextStyled$2, {\n                translationKey: \"walletModal.infoModal.walletProtects\",\n                children: \"A wallet protects and manages your digital assets including TON, tokens and collectables.\"\n              })];\n            }\n          }), createComponent(InfoBlock, {\n            get children() {\n              return [createComponent(PersonalityIcon, {\n                \"class\": InfoBlockIconClass\n              }), createComponent(H3Styled$1, {\n                translationKey: \"walletModal.infoModal.controlIdentity\",\n                children: \"Control your Web3 identity\"\n              }), createComponent(TextStyled$2, {\n                translationKey: \"walletModal.infoModal.manageIdentity\",\n                children: \"Manage your digital identity and access decentralized applications with ease. Maintain control over your data and engage securely in the blockchain ecosystem.\"\n              })];\n            }\n          }), createComponent(InfoBlock, {\n            get children() {\n              return [createComponent(SwapIcon, {\n                \"class\": InfoBlockIconClass\n              }), createComponent(H3Styled$1, {\n                translationKey: \"walletModal.infoModal.effortlessCryptoTransactions\",\n                children: \"Effortless crypto transactions\"\n              }), createComponent(TextStyled$2, {\n                translationKey: \"walletModal.infoModal.easilySend\",\n                children: \"Easily send, receive, monitor your cryptocurrencies. Streamline your operations with decentralized applications.\"\n              })];\n            }\n          }), createComponent(ButtonsBlock, {\n            get children() {\n              return createComponent(Link, {\n                get href() {\n                  return LINKS.GET_A_WALLET;\n                },\n                blank: true,\n                get children() {\n                  return createComponent(Button, {\n                    get rightIcon() {\n                      return createComponent(WalletIcon, {});\n                    },\n                    get children() {\n                      return createComponent(Translation, {\n                        translationKey: \"walletModal.infoModal.getAWallet\",\n                        children: \"Get a Wallet\"\n                      });\n                    }\n                  });\n                }\n              });\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst MobileConnectionModalStyled = styled.div``;\nconst BodyStyled = styled.div`\n    flex: 1;\n    margin-top: 18px;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    min-height: 232px;\n`;\nconst H1Styled$6 = styled(H1)`\n    max-width: 262px;\n    margin: 0 auto 8px;\n`;\nconst StyledIconButton$2 = styled(IconButton)`\n    position: absolute;\n    top: 16px;\n    left: 16px;\n`;\nconst FooterStyled = styled.div`\n    padding: 16px;\n    display: flex;\n    align-items: center;\n    gap: 12px;\n    border-top: 0.5px solid ${(props) => rgba(props.theme.colors.icon.secondary, 0.2)};\n`;\nconst ImageStyled = styled(Image)`\n    width: 36px;\n    height: 36px;\n    border-radius: 10px;\n`;\nconst FooterButton = styled(Link)`\n    margin-left: auto;\n`;\nconst LoaderStyled = styled(LoaderIcon)`\n    margin-bottom: 18px;\n    margin-top: 2px;\n`;\nconst ErrorIconStyled$1 = styled(ErrorIcon)`\n    margin-bottom: 16px;\n`;\nconst BodyTextStyled$1 = styled(H2)`\n    color: ${(props) => props.theme.colors.text.secondary};\n    text-align: center;\n    margin-bottom: 20px;\n`;\nconst ButtonsContainerStyled$1 = styled.div`\n    display: flex;\n    justify-content: center;\n    gap: 8px;\n    padding-bottom: 16px;\n`;\nconst actionButtonBorderRadius$1 = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst H1Styled$5 = styled(H1)`\n    margin-bottom: 2px;\n    padding: 0 52px;\n`;\nconst H2Styled$3 = styled(H2)`\n    margin-bottom: 20px;\n    padding: 0 64px;\n`;\nconst QrCodeWrapper$1 = styled.div`\n    padding: 0 24px 16px;\n`;\nconst ButtonsWrapper$1 = styled.div`\n    display: flex;\n    flex-direction: row;\n    gap: 16px;\n    padding: 0 24px 24px;\n    margin-top: 0;\n`;\nconst ActionButton$1 = styled(Button)`\n    width: 100%;\n    height: 56px;\n    border-radius: ${(props) => actionButtonBorderRadius$1[props.theme.borderRadius]};\n    background-color: ${(props) => rgba(props.theme.colors.accent, 0.12)};\n    color: ${(props) => props.theme.colors.accent};\n    font-size: 16px;\n    line-height: 20px;\n    font-weight: 500;\n    padding: 17px 20px 19px 20px;\n`;\nconst MobileConnectionQR = (props) => {\n  return [createComponent(H1Styled$5, {\n    get children() {\n      return props.walletInfo.name;\n    }\n  }), createComponent(H2Styled$3, {\n    translationKey: \"walletModal.mobileConnectionModal.scanQR\",\n    get translationValues() {\n      return {\n        name: props.walletInfo.name\n      };\n    },\n    get children() {\n      return [\"Scan the QR code below with your phones or \", memo(() => props.walletInfo.name), \"s camera\"];\n    }\n  }), createComponent(QrCodeWrapper$1, {\n    get children() {\n      return createComponent(QRCode, {\n        get imageUrl() {\n          return props.walletInfo.imageUrl;\n        },\n        get sourceUrl() {\n          return addReturnStrategy(props.universalLink, \"none\");\n        },\n        disableCopy: true\n      });\n    }\n  }), createComponent(ButtonsWrapper$1, {\n    get children() {\n      return [createComponent(ActionButton$1, {\n        appearance: \"secondary\",\n        onClick: () => {\n          var _a2;\n          return (_a2 = props.onOpenLink) == null ? void 0 : _a2.call(props);\n        },\n        get children() {\n          return createComponent(Translation, {\n            translationKey: \"walletModal.mobileUniversalModal.openLink\",\n            children: \"Open Link\"\n          });\n        }\n      }), createComponent(ActionButton$1, {\n        appearance: \"secondary\",\n        onClick: () => {\n          var _a2;\n          return (_a2 = props.onCopy) == null ? void 0 : _a2.call(props);\n        },\n        get children() {\n          return createComponent(Translation, {\n            get translationKey() {\n              return props.isCopiedShown !== void 0 ? \"common.copied\" : \"common.copyLink\";\n            },\n            get children() {\n              return props.isCopiedShown !== void 0 ? \"Copied\" : \"Copy Link\";\n            }\n          });\n        }\n      })];\n    }\n  })];\n};\nconst MobileConnectionModal = (props) => {\n  const theme = useTheme();\n  const [firstClick, setFirstClick] = createSignal(true);\n  const [showQR, setShowQR] = createSignal(false);\n  const [connectionErrored, setConnectionErrored] = createSignal(null);\n  createEffect(() => {\n    var _a2;\n    setConnectionErrored((_a2 = props.defaultError) != null ? _a2 : null);\n  });\n  const connector = useContext(ConnectorContext);\n  const unsubscribe = connector.onStatusChange(() => {\n  }, (error) => {\n    if (error instanceof _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletMissingRequiredFeaturesError) {\n      setConnectionErrored(\"missing-features\");\n      return;\n    }\n    if (error instanceof _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletWrongNetworkError) {\n      setConnectionErrored(\"wrong-network\");\n      return;\n    }\n    setConnectionErrored(null);\n  });\n  const universalLink = createMemo(() => {\n    var _a2;\n    return connector.connect({\n      universalLink: props.wallet.universalLink,\n      bridgeUrl: props.wallet.bridgeUrl\n    }, props.additionalRequest, {\n      traceId: (_a2 = props.walletModalState) == null ? void 0 : _a2.traceId\n    });\n  });\n  const onClickTelegram = () => {\n    const alwaysForceRedirect = true;\n    setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, props.wallet), {\n      openMethod: \"universal-link\"\n    }));\n    redirectToTelegram(universalLink(), {\n      returnStrategy: appState.returnStrategy,\n      twaReturnUrl: appState.twaReturnUrl,\n      forceRedirect: alwaysForceRedirect\n    });\n  };\n  const onRetry = () => {\n    const currentUniversalLink = universalLink();\n    if ((0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isTelegramUrl)(currentUniversalLink)) {\n      return onClickTelegram();\n    }\n    setConnectionErrored(null);\n    const forceRedirect = !firstClick();\n    setFirstClick(false);\n    redirectToWallet(universalLink(), props.wallet.deepLink, {\n      returnStrategy: appState.returnStrategy,\n      forceRedirect\n    }, (method) => {\n      setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, props.wallet), {\n        openMethod: method\n      }));\n    });\n  };\n  const [isCopiedShown, setIsCopiedShown] = createSignal(void 0);\n  const onCopy = () => __async(null, null, function* () {\n    if (isCopiedShown() !== void 0) {\n      clearTimeout(isCopiedShown());\n    }\n    yield copyToClipboard(universalLink());\n    const timeoutId = setTimeout(() => setIsCopiedShown(void 0), 1500);\n    setIsCopiedShown(timeoutId);\n  });\n  const onOpenQR = () => {\n    setConnectionErrored(null);\n    setShowQR(true);\n    setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, props.wallet), {\n      openMethod: \"qrcode\"\n    }));\n  };\n  const onCloseQR = () => {\n    setShowQR(false);\n    setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, props.wallet), {\n      openMethod: \"universal-link\"\n    }));\n  };\n  const onBack = () => {\n    if (showQR()) {\n      onCloseQR();\n    } else {\n      props.onBackClick();\n    }\n  };\n  onCleanup(unsubscribe);\n  onRetry();\n  return createComponent(MobileConnectionModalStyled, {\n    \"data-tc-wallets-modal-connection-mobile\": \"true\",\n    get children() {\n      return [createComponent(Show, {\n        get when() {\n          return !props.backDisabled || showQR();\n        },\n        get children() {\n          return createComponent(StyledIconButton$2, {\n            icon: \"arrow\",\n            onClick: onBack\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return showQR();\n        },\n        get children() {\n          return createComponent(MobileConnectionQR, {\n            get universalLink() {\n              return universalLink();\n            },\n            get walletInfo() {\n              return props.wallet;\n            },\n            onOpenLink: onRetry,\n            onCopy,\n            get isCopiedShown() {\n              return isCopiedShown();\n            }\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !showQR();\n        },\n        get children() {\n          return [createComponent(H1Styled$6, {\n            get children() {\n              return props.wallet.name;\n            }\n          }), createComponent(BodyStyled, {\n            get children() {\n              return [createComponent(Show, {\n                get when() {\n                  return connectionErrored();\n                },\n                get children() {\n                  return [createComponent(ErrorIconStyled$1, {\n                    size: \"s\"\n                  }), createComponent(Switch, {\n                    get children() {\n                      return [createComponent(Match, {\n                        get when() {\n                          return connectionErrored() === \"missing-features\";\n                        },\n                        get children() {\n                          return createComponent(BodyTextStyled$1, {\n                            translationKey: \"walletModal.mobileConnectionModal.missingFeatures\",\n                            get translationValues() {\n                              return {\n                                name: props.wallet.name\n                              };\n                            },\n                            children: \"Please update Wallet, your version does not support required features for this dApp\"\n                          });\n                        }\n                      }), createComponent(Match, {\n                        get when() {\n                          return connectionErrored() === \"connection-declined\";\n                        },\n                        get children() {\n                          return createComponent(BodyTextStyled$1, {\n                            translationKey: \"walletModal.mobileConnectionModal.connectionDeclined\",\n                            children: \"Connection declined\"\n                          });\n                        }\n                      }), createComponent(Match, {\n                        get when() {\n                          return connectionErrored() === \"wrong-network\";\n                        },\n                        get children() {\n                          return createComponent(BodyTextStyled$1, {\n                            translationKey: \"walletModal.mobileConnectionModal.wrongNetwork\",\n                            get translationValues() {\n                              return {\n                                name: props.wallet.name\n                              };\n                            },\n                            get children() {\n                              return [\"Connected wallet is on a different network. Please switch network in \", memo(() => props.wallet.name), \" and try again.\"];\n                            }\n                          });\n                        }\n                      }), createComponent(Match, {\n                        get when() {\n                          return connectionErrored() === \"not-supported\";\n                        },\n                        get children() {\n                          return createComponent(BodyTextStyled$1, {\n                            translationKey: \"walletModal.mobileConnectionModal.notSupportedWallet\",\n                            get translationValues() {\n                              return {\n                                name: props.wallet.name\n                              };\n                            },\n                            get children() {\n                              return [memo(() => props.wallet.name), \" doesn't support the requested action. Please connect another wallet that supports it.\"];\n                            }\n                          });\n                        }\n                      })];\n                    }\n                  }), createComponent(ButtonsContainerStyled$1, {\n                    get children() {\n                      return createComponent(Switch, {\n                        get children() {\n                          return [createComponent(Match, {\n                            get when() {\n                              return connectionErrored() === \"missing-features\";\n                            },\n                            get children() {\n                              return [createComponent(Button, {\n                                get leftIcon() {\n                                  return createComponent(RetryIcon, {});\n                                },\n                                onClick: onRetry,\n                                get children() {\n                                  return createComponent(Translation, {\n                                    translationKey: \"common.retry\",\n                                    children: \"Retry\"\n                                  });\n                                }\n                              }), createComponent(Link, {\n                                get href() {\n                                  return props.wallet.aboutUrl;\n                                },\n                                blank: true,\n                                get children() {\n                                  return createComponent(Button, {\n                                    get leftIcon() {\n                                      return createComponent(LinkIcon, {});\n                                    },\n                                    get children() {\n                                      return createComponent(Translation, {\n                                        translationKey: \"walletModal.mobileConnectionModal.updateWallet\",\n                                        get translationValues() {\n                                          return {\n                                            name: props.wallet.name\n                                          };\n                                        },\n                                        get children() {\n                                          return [\"Update \", memo(() => props.wallet.name)];\n                                        }\n                                      });\n                                    }\n                                  });\n                                }\n                              })];\n                            }\n                          }), createComponent(Match, {\n                            get when() {\n                              return connectionErrored() === \"not-supported\";\n                            },\n                            get children() {\n                              return createComponent(Button, {\n                                onClick: () => props.onBackClick(),\n                                get children() {\n                                  return createComponent(Translation, {\n                                    translationKey: \"walletModal.mobileConnectionModal.chooseAnotherWallet\",\n                                    children: \"Choose Another Wallet\"\n                                  });\n                                }\n                              });\n                            }\n                          }), createComponent(Match, {\n                            get when() {\n                              return connectionErrored() === \"wrong-network\";\n                            },\n                            get children() {\n                              return createComponent(Button, {\n                                get leftIcon() {\n                                  return createComponent(RetryIcon, {});\n                                },\n                                onClick: onRetry,\n                                get children() {\n                                  return createComponent(Translation, {\n                                    translationKey: \"common.retry\",\n                                    children: \"Retry\"\n                                  });\n                                }\n                              });\n                            }\n                          }), createComponent(Match, {\n                            get when() {\n                              return connectionErrored() === \"connection-declined\";\n                            },\n                            get children() {\n                              return [createComponent(Button, {\n                                get leftIcon() {\n                                  return createComponent(RetryIcon, {});\n                                },\n                                onClick: onRetry,\n                                get children() {\n                                  return createComponent(Translation, {\n                                    translationKey: \"common.retry\",\n                                    children: \"Retry\"\n                                  });\n                                }\n                              }), createComponent(Button, {\n                                get leftIcon() {\n                                  return createComponent(QRIcon, {\n                                    get fill() {\n                                      return theme.colors.accent;\n                                    }\n                                  });\n                                },\n                                onClick: onOpenQR,\n                                get children() {\n                                  return createComponent(Translation, {\n                                    translationKey: \"walletModal.mobileConnectionModal.showQR\",\n                                    children: \"Show QR Code\"\n                                  });\n                                }\n                              })];\n                            }\n                          })];\n                        }\n                      });\n                    }\n                  })];\n                }\n              }), createComponent(Show, {\n                get when() {\n                  return !connectionErrored();\n                },\n                get children() {\n                  return [createComponent(LoaderStyled, {\n                    size: \"s\"\n                  }), createComponent(BodyTextStyled$1, {\n                    translationKey: \"walletModal.mobileConnectionModal.continueIn\",\n                    get translationValues() {\n                      return {\n                        name: props.wallet.name\n                      };\n                    },\n                    get children() {\n                      return [\"Continue in \", memo(() => props.wallet.name), \"\"];\n                    }\n                  }), createComponent(ButtonsContainerStyled$1, {\n                    get children() {\n                      return [createComponent(Button, {\n                        get leftIcon() {\n                          return createComponent(RetryIcon, {});\n                        },\n                        onClick: onRetry,\n                        get children() {\n                          return createComponent(Translation, {\n                            translationKey: \"common.retry\",\n                            children: \"Retry\"\n                          });\n                        }\n                      }), createComponent(Button, {\n                        get leftIcon() {\n                          return createComponent(QRIcon, {\n                            get fill() {\n                              return theme.colors.accent;\n                            }\n                          });\n                        },\n                        onClick: onOpenQR,\n                        get children() {\n                          return createComponent(Translation, {\n                            translationKey: \"walletModal.mobileConnectionModal.showQR\",\n                            children: \"Show QR Code\"\n                          });\n                        }\n                      })];\n                    }\n                  })];\n                }\n              })];\n            }\n          }), createComponent(FooterStyled, {\n            get children() {\n              return [createComponent(ImageStyled, {\n                get src() {\n                  return props.wallet.imageUrl;\n                }\n              }), createComponent(H3, {\n                get children() {\n                  return props.wallet.name;\n                }\n              }), createComponent(FooterButton, {\n                get href() {\n                  return props.wallet.aboutUrl;\n                },\n                blank: true,\n                get children() {\n                  return createComponent(Button, {\n                    get children() {\n                      return createComponent(Translation, {\n                        translationKey: \"common.get\",\n                        children: \"GET\"\n                      });\n                    }\n                  });\n                }\n              })];\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst borders$2 = {\n  m: \"16px\",\n  s: \"12px\",\n  none: \"0\"\n};\nconst tgBorders = {\n  m: \"6px\",\n  s: \"6px\",\n  none: \"0\"\n};\nstyled.li`\n    width: 82px;\n    min-width: 82px;\n    height: 124px;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    padding: 8px 4px;\n\n    text-align: center;\n    cursor: pointer;\n\n    transition: transform 0.1s ease-in-out;\n\n    ${mediaNotTouch} {\n        &:hover {\n            transform: scale(1.04);\n        }\n    }\n\n    &:active {\n        transform: scale(0.96);\n    }\n\n    ${mediaTouch} {\n        &:active {\n            transform: scale(0.92);\n        }\n    }\n`;\nconst H1Styled$4 = styled(H1)`\n    margin-top: 38px;\n    margin-bottom: 4px;\n    padding: 0 24px;\n`;\nconst H2Styled$2 = styled(H2)`\n    margin: ${(props) => {\n  var _a2;\n  return (_a2 = props.margin) != null ? _a2 : \"0 0 28px 0\";\n}};\n    padding: ${(props) => {\n  var _a2;\n  return (_a2 = props.padding) != null ? _a2 : \"0 24px\";\n}};\n    min-height: ${(props) => {\n  var _a2;\n  return (_a2 = props.padding) != null ? _a2 : \"44px\";\n}};\n    max-width: ${(props) => props.maxWidth}px;\n    margin-left: ${(props) => props.maxWidth ? \"auto\" : \"0px\"};\n    margin-right: ${(props) => props.maxWidth ? \"auto\" : \"0px\"};\n`;\nstyled(Button)`\n    display: block;\n    margin: 0 auto;\n`;\nconst TelegramButtonStyled = styled(Button)`\n    margin: 0 28px 24px;\n    width: calc(100% - 56px);\n    border-radius: ${(props) => borders$2[props.theme.borderRadius]};\n    padding: 14px 16px 14px 14px;\n    background-color: ${(props) => props.theme.colors.telegramButton};\n\n    color: ${(props) => props.theme.colors.constant.white};\n    font-weight: 500;\n    font-size: 16px;\n    line-height: 20px;\n\n    @media (max-width: 375px) {\n        margin: 0 16px 24px;\n        width: calc(100% - 32px);\n    }\n`;\nconst TGImageStyled = styled(Image)`\n    background-color: transparent;\n    border-radius: ${(props) => tgBorders[props.theme.borderRadius]};\n    width: 24px;\n    height: 24px;\n`;\nconst StyledLeftActionButton = styled(IconButton)`\n    position: absolute;\n    top: 16px;\n    left: 16px;\n`;\nconst actionButtonBorderRadius = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst H1Styled$3 = styled(H1)`\n    margin-bottom: 2px;\n    padding: 0 52px;\n`;\nconst H2Styled$1 = styled(H2)`\n    margin-bottom: 20px;\n    padding: 0 64px;\n`;\nconst QrCodeWrapper = styled.div`\n    padding: 0 24px 16px;\n`;\nconst ButtonsWrapper = styled.div`\n    display: flex;\n    flex-direction: row;\n    gap: 16px;\n    padding: 0 24px 24px;\n    margin-top: 0;\n`;\nconst ActionButton = styled(Button)`\n    width: 100%;\n    height: 56px;\n    border-radius: ${(props) => actionButtonBorderRadius[props.theme.borderRadius]};\n    background-color: ${(props) => rgba(props.theme.colors.accent, 0.12)};\n    color: ${(props) => props.theme.colors.accent};\n    font-size: 16px;\n    line-height: 20px;\n    font-weight: 500;\n    padding: 17px 20px 19px 20px;\n`;\nconst MobileUniversalQR = (props) => {\n  return [createComponent(H1Styled$3, {\n    translationKey: \"walletModal.mobileUniversalModal.connectYourWallet\",\n    children: \"Connect your TON wallet\"\n  }), createComponent(H2Styled$1, {\n    translationKey: \"walletModal.mobileUniversalModal.scan\",\n    children: \"Scan with your mobile wallet\"\n  }), createComponent(QrCodeWrapper, {\n    get children() {\n      return createComponent(QRCode, {\n        get imageUrl() {\n          return IMG.TON;\n        },\n        get sourceUrl() {\n          return addReturnStrategy(props.universalLink, \"none\");\n        },\n        disableCopy: true\n      });\n    }\n  }), createComponent(ButtonsWrapper, {\n    get children() {\n      return [createComponent(ActionButton, {\n        appearance: \"secondary\",\n        onClick: () => props.onOpenLink(),\n        get children() {\n          return createComponent(Translation, {\n            translationKey: \"walletModal.mobileUniversalModal.openLink\",\n            children: \"Open Link\"\n          });\n        }\n      }), createComponent(ActionButton, {\n        appearance: \"secondary\",\n        onClick: () => props.onCopy(),\n        get children() {\n          return createComponent(Translation, {\n            get translationKey() {\n              return props.isCopiedShown !== void 0 ? \"common.copied\" : \"common.copyLink\";\n            },\n            get children() {\n              return props.isCopiedShown !== void 0 ? \"Copied\" : \"Copy Link\";\n            }\n          });\n        }\n      })];\n    }\n  })];\n};\nfunction getUniqueBridges(walletsList) {\n  const uniqueBridges = new Set(\n    walletsList.filter(_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoRemote).map((item) => item.bridgeUrl)\n  );\n  return Array.from(uniqueBridges).map((bridgeUrl) => ({ bridgeUrl }));\n}\nfunction bridgesIsEqual(left, right) {\n  const leftSet = new Set(left == null ? void 0 : left.map((i2) => i2.bridgeUrl));\n  const rightSet = new Set(right == null ? void 0 : right.map((i2) => i2.bridgeUrl));\n  return leftSet.size === rightSet.size && [...leftSet].every((value) => rightSet.has(value));\n}\nvar _tmpl$$1 = /* @__PURE__ */ template$1(`<li>`), _tmpl$2 = /* @__PURE__ */ template$1(`<div data-tc-wallets-modal-universal-mobile=true>`);\nconst MobileUniversalModal = (props) => {\n  const [showQR, setShowQR] = createSignal(false);\n  const [firstClick, setFirstClick] = createSignal(true);\n  const [universalLink, setUniversalLink] = createSignal(null);\n  const connector = appState.connector;\n  const walletsList = () => props.walletsList.filter((w) => supportsMobile(w) && w.appName !== AT_WALLET_APP_NAME);\n  const shouldShowMoreButton = () => walletsList().length > 7;\n  const walletsBridges = createMemo(() => getUniqueBridges(props.walletsList), null, {\n    equals: bridgesIsEqual\n  });\n  const atWalletSupportFeatures = createMemo(() => {\n    var _a2, _b2;\n    return (_b2 = (_a2 = props.walletsList.find((wallet) => wallet.appName === AT_WALLET_APP_NAME)) == null ? void 0 : _a2.isSupportRequiredFeatures) != null ? _b2 : false;\n  }, null);\n  const getUniversalLink = () => {\n    if (!universalLink()) {\n      setUniversalLink(connector.connect(walletsBridges(), props.additionalRequest, {\n        traceId: props.walletModalState.traceId\n      }));\n    }\n    return universalLink();\n  };\n  setLastSelectedWalletInfo({\n    openMethod: \"universal-link\"\n  });\n  const [isCopiedShown, setIsCopiedShown] = createSignal(void 0);\n  const onCopy = () => __async(null, null, function* () {\n    if (isCopiedShown() !== void 0) {\n      clearTimeout(isCopiedShown());\n    }\n    yield copyToClipboard(getUniversalLink());\n    const timeoutId = setTimeout(() => setIsCopiedShown(void 0), 1500);\n    setIsCopiedShown(timeoutId);\n  });\n  const onSelectUniversal = () => {\n    const forceRedirect = !firstClick();\n    setFirstClick(false);\n    redirectToWallet(getUniversalLink(), void 0, {\n      returnStrategy: appState.returnStrategy,\n      forceRedirect\n    }, (method) => {\n      setLastSelectedWalletInfo({\n        openMethod: method\n      });\n    });\n  };\n  const onSelectTelegram = () => {\n    setUniversalLink(null);\n    const atWallet = props.walletsList.find((wallet) => wallet.appName === AT_WALLET_APP_NAME);\n    if (!atWallet || !(0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoRemote)(atWallet)) {\n      throw new TonConnectUIError(\"@wallet bot not found in the wallets list\");\n    }\n    const walletLink = connector.connect({\n      bridgeUrl: atWallet.bridgeUrl,\n      universalLink: atWallet.universalLink\n    }, props.additionalRequest, {\n      traceId: props.walletModalState.traceId\n    });\n    const forceRedirect = !firstClick();\n    setFirstClick(false);\n    redirectToTelegram(walletLink, {\n      returnStrategy: appState.returnStrategy,\n      twaReturnUrl: appState.twaReturnUrl,\n      forceRedirect\n    });\n  };\n  const onOpenQR = () => {\n    setShowQR(true);\n    setLastSelectedWalletInfo({\n      openMethod: \"qrcode\"\n    });\n  };\n  const onCloseQR = () => {\n    setShowQR(false);\n    setLastSelectedWalletInfo({\n      openMethod: \"universal-link\"\n    });\n  };\n  const supportedWallets = createMemo(() => walletsList().filter((wallet) => wallet.isSupportRequiredFeatures), null);\n  const visibleWallets = createMemo(() => supportedWallets().slice(0, 3), null);\n  setLastVisibleWalletsInfo({\n    walletsMenu: \"main_screen\",\n    wallets: atWalletSupportFeatures() ? [props.walletsList.find((wallet) => wallet.appName === AT_WALLET_APP_NAME), ...visibleWallets()] : visibleWallets()\n  });\n  const fourWalletsItem = createMemo(() => walletsList().filter((wallet) => !visibleWallets().find((w) => w.appName === wallet.appName)).slice(0, 4), null);\n  return (() => {\n    var _el$ = _tmpl$2();\n    insert(_el$, createComponent(Show, {\n      get when() {\n        return showQR();\n      },\n      get children() {\n        return [createComponent(StyledLeftActionButton, {\n          icon: \"arrow\",\n          onClick: onCloseQR\n        }), createComponent(MobileUniversalQR, {\n          get universalLink() {\n            return getUniversalLink();\n          },\n          get isCopiedShown() {\n            return isCopiedShown();\n          },\n          onOpenLink: onSelectUniversal,\n          onCopy\n        })];\n      }\n    }), null);\n    insert(_el$, createComponent(Show, {\n      get when() {\n        return !showQR();\n      },\n      get children() {\n        return [createComponent(StyledLeftActionButton, {\n          get icon() {\n            return createComponent(QRIcon, {});\n          },\n          onClick: onOpenQR\n        }), createComponent(H1Styled$4, {\n          translationKey: \"walletModal.mobileUniversalModal.connectYourWallet\",\n          children: \"Connect your TON wallet\"\n        }), createComponent(Show, {\n          get when() {\n            return atWalletSupportFeatures();\n          },\n          get children() {\n            return [createComponent(H2Styled$2, {\n              translationKey: \"walletModal.mobileUniversalModal.openWalletOnTelegramOrSelect\",\n              maxWidth: 320,\n              children: \"Use Wallet in Telegram or choose other application\"\n            }), createComponent(TelegramButtonStyled, {\n              get leftIcon() {\n                return createComponent(AtWalletIcon, {});\n              },\n              get rightIcon() {\n                return createComponent(TGImageStyled, {\n                  get src() {\n                    return IMG.TG;\n                  }\n                });\n              },\n              onClick: onSelectTelegram,\n              scale: \"s\",\n              get children() {\n                return createComponent(Translation, {\n                  translationKey: \"walletModal.mobileUniversalModal.openWalletOnTelegram\",\n                  children: \"Connect Wallet in Telegram\"\n                });\n              }\n            })];\n          }\n        }), createComponent(H2Styled$2, {\n          translationKey: \"walletModal.mobileUniversalModal.chooseOtherApplication\",\n          maxWidth: 342,\n          padding: \"0 24px 8px 24px\",\n          margin: \"0\",\n          children: \"Choose other application\"\n        }), createComponent(WalletUlContainer, {\n          get children() {\n            return [createComponent(For, {\n              get each() {\n                return memo(() => !!shouldShowMoreButton())() ? visibleWallets() : supportedWallets();\n              },\n              children: (wallet) => (() => {\n                var _el$3 = _tmpl$$1();\n                insert(_el$3, createComponent(WalletItem, {\n                  get icon() {\n                    return wallet.imageUrl;\n                  },\n                  get name() {\n                    return wallet.name;\n                  },\n                  onClick: () => props.onSelect(wallet)\n                }));\n                return _el$3;\n              })()\n            }), createComponent(Show, {\n              get when() {\n                return shouldShowMoreButton();\n              },\n              get children() {\n                var _el$2 = _tmpl$$1();\n                insert(_el$2, createComponent(FourWalletsItem, {\n                  labelLine1: \"View all\",\n                  labelLine2: \"wallets\",\n                  get images() {\n                    return fourWalletsItem().map((i2) => i2.imageUrl);\n                  },\n                  onClick: () => props.onSelectAllWallets()\n                }));\n                return _el$2;\n              }\n            })];\n          }\n        })];\n      }\n    }), null);\n    return _el$;\n  })();\n};\nconst borders$1 = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst hoverBorders = {\n  m: \"8px\",\n  s: \"4px\",\n  none: \"0\"\n};\nconst DesktopUniversalModalStyled = styled.div`\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    padding-bottom: 16px;\n`;\nconst H2Styled = styled(H2)`\n    max-width: 320px;\n    margin-top: 2px;\n    margin-bottom: 20px;\n`;\nconst H2AvailableWalletsStyled = styled(H2)`\n    margin-bottom: 16px;\n`;\nconst QRCodeStyled = styled(QRCode)`\n    margin-bottom: 24px;\n`;\nconst WalletsContainerStyled = styled.ul`\n    display: flex;\n`;\nstyled.div`\n    display: flex;\n    gap: 16px;\n    width: 100%;\n`;\nstyled(Button)`\n    position: relative;\n    font-size: 16px;\n    line-height: 20px;\n    width: 100%;\n    padding: 0 16px;\n    height: 56px;\n    border-radius: ${(props) => borders$1[props.theme.borderRadius]};\n\n    &:hover {\n        ${(props) => props.disableEventsAnimation ? \"transform: unset;\" : \"\"}\n    }\n\n    &:active {\n        ${(props) => props.disableEventsAnimation ? \"transform: unset;\" : \"\"}\n    }\n`;\nstyled.ul`\n    position: absolute;\n    bottom: 100%;\n    left: 0;\n    margin: 0;\n    padding: 8px;\n    width: 188px;\n    transform: translateY(-16px);\n\n    background-color: ${(props) => props.theme.colors.background.primary};\n    border-radius: ${(props) => borders$1[props.theme.borderRadius]};\n    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);\n`;\nstyled.li`\n    padding: 8px;\n\n    display: flex;\n    align-items: center;\n    gap: 8px;\n\n    cursor: pointer;\n    border-radius: ${(props) => hoverBorders[props.theme.borderRadius]};\n\n    transition:\n        background-color,\n        transform 0.1s ease-in-out;\n\n    &:hover {\n        background-color: ${(props) => props.theme.colors.background.secondary};\n    }\n\n    &:active {\n        transform: scale(0.96);\n    }\n`;\nstyled(Image)`\n    width: 24px;\n    height: 24px;\n\n    border-radius: 6px;\n`;\nstyled.div`\n    margin-top: 23px;\n    margin-bottom: 1px;\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n`;\nstyled(Text)`\n    color: ${(props) => props.theme.colors.text.secondary};\n    font-size: 16px;\n`;\nvar _tmpl$ = /* @__PURE__ */ template$1(`<li>`);\nconst DesktopUniversalModal = (props) => {\n  const [popupOpened, setPopupOpened] = createSignal(false);\n  const connector = appState.connector;\n  const walletsBridges = createMemo(() => getUniqueBridges(props.walletsList), null, {\n    equals: bridgesIsEqual\n  });\n  setLastSelectedWalletInfo({\n    openMethod: \"qrcode\"\n  });\n  const request = createMemo(() => connector.connect(walletsBridges(), props.additionalRequest, {\n    traceId: props.walletModalState.traceId\n  }));\n  const supportedWallets = createMemo(() => props.walletsList.filter((wallet) => wallet.isSupportRequiredFeatures), null);\n  const visibleWallets = createMemo(() => supportedWallets().slice(0, 3), null);\n  setLastVisibleWalletsInfo({\n    walletsMenu: \"main_screen\",\n    wallets: visibleWallets()\n  });\n  const fourWalletsItem = createMemo(() => props.walletsList.filter((wallet) => !visibleWallets().find((w) => w.appName === wallet.appName)).slice(0, 4), null);\n  return createComponent(DesktopUniversalModalStyled, {\n    onClick: () => setPopupOpened(false),\n    \"data-tc-wallets-modal-universal-desktop\": \"true\",\n    get children() {\n      return [createComponent(H1, {\n        translationKey: \"walletModal.desktopUniversalModal.connectYourWallet\",\n        children: \"Connect your wallet\"\n      }), createComponent(H2Styled, {\n        translationKey: \"walletModal.desktopUniversalModal.scan\",\n        children: \"Scan with your mobile wallet\"\n      }), createComponent(QRCodeStyled, {\n        get sourceUrl() {\n          return addReturnStrategy(request(), \"none\");\n        },\n        get disableCopy() {\n          return popupOpened();\n        },\n        get imageUrl() {\n          return IMG.TON;\n        }\n      }), createComponent(H2AvailableWalletsStyled, {\n        translationKey: \"walletModal.desktopUniversalModal.availableWallets\",\n        children: \"Available wallets\"\n      }), createComponent(WalletsContainerStyled, {\n        get children() {\n          return [createComponent(For, {\n            get each() {\n              return visibleWallets();\n            },\n            children: (wallet) => (() => {\n              var _el$ = _tmpl$();\n              insert(_el$, createComponent(WalletLabeledItem, {\n                wallet,\n                onClick: () => props.onSelect(wallet)\n              }));\n              return _el$;\n            })()\n          }), createComponent(FourWalletsItem, {\n            labelLine1: \"View all\",\n            labelLine2: \"wallets\",\n            get images() {\n              return fourWalletsItem().map((i2) => i2.imageUrl);\n            },\n            onClick: () => props.onSelectAllWallets()\n          })];\n        }\n      })];\n    }\n  });\n};\nconst borders = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst H1Styled$2 = styled(H1)`\n    max-width: 288px;\n    margin: 0 auto 38px;\n`;\nconst DesktopFeatureNotSupportModalStyled = styled.div`\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n`;\nconst StyledIconButton$1 = styled(IconButton)`\n    position: absolute;\n    top: 16px;\n    left: 16px;\n`;\nconst TitleStyled = styled(H1)`\n    text-align: center;\n    font-size: 20px;\n    line-height: 28px;\n`;\nconst DescriptionStyled = styled(Text)`\n    margin-top: 12px;\n    margin-bottom: 24px;\n    text-align: center;\n    max-width: 360px;\n    font-weight: 400;\n    color: ${(props) => props.theme.colors.text.secondary};\n`;\nstyled.button`\n    background: transparent;\n    border: none;\n    padding: 0;\n    margin: 0;\n    color: ${(props) => props.theme.colors.accent};\n    text-decoration: underline;\n    cursor: pointer;\n    font: inherit;\n`;\nconst Spacer = styled.div`\n    margin-bottom: 46px;\n`;\nconst ErrorIconStyled = styled(ErrorIcon)`\n    margin-bottom: 16px;\n`;\nstyled.ul`\n    display: flex;\n    gap: 8px;\n    margin-bottom: 24px;\n    list-style: none;\n    padding: 0;\n`;\nconst DisconnectButtonStyled = styled(Button)`\n    max-width: 320px;\n    width: 100%;\n    height: 48px;\n    font-size: 16px;\n    line-height: 20px;\n    border-radius: ${(props) => borders[props.theme.borderRadius]};\n    margin-bottom: 28px;\n`;\nconst BodyTextStyled = styled(H2)`\n    color: ${(props) => props.theme.colors.text.secondary};\n    text-align: center;\n    margin-bottom: 20px;\n`;\nconst ButtonsContainerStyled = styled.div`\n    display: flex;\n    justify-content: center;\n    gap: 8px;\n    padding-bottom: 31px;\n`;\nconst RestoreInfoModalStyled = styled.div`\n    margin: 0 8px 16px 8px;\n`;\nconst StyledIconButton = styled(IconButton)`\n    position: absolute;\n    top: 16px;\n    left: 16px;\n`;\nconst H1Styled$1 = styled(H1)`\n    margin-bottom: 18px;\n    text-align: center;\n`;\nconst StepBlock = styled.div`\n    padding: 16px 0;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n`;\nstyled.div`\n    margin-bottom: 12px;\n`;\nconst H3Styled = styled(H3)`\n    text-align: center;\n    margin-bottom: 4px;\n`;\nconst TextStyled$1 = styled(Text)`\n    text-align: center;\n    max-width: 352px;\n    color: ${(props) => props.theme.colors.text.secondary};\n`;\nconst CircleNumber = styled.div`\n    width: 44px;\n    height: 44px;\n    border-radius: 20px;\n    background-color: ${(props) => {\n  var _a2;\n  return (_a2 = props.theme) == null ? void 0 : _a2.colors.icon.secondary;\n}};\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    margin-bottom: 12px;\n    font-weight: 700;\n    font-size: 22px;\n    color: ${(props) => {\n  var _a2;\n  return (_a2 = props.theme) == null ? void 0 : _a2.colors.text.primary;\n}};\n`;\nconst RestoreInfoModal = (props) => {\n  return createComponent(RestoreInfoModalStyled, {\n    \"data-tc-wallets-modal-restore\": \"true\",\n    get children() {\n      return [createComponent(StyledIconButton, {\n        icon: \"arrow\",\n        get onClick() {\n          return props.onBackClick;\n        }\n      }), createComponent(H1Styled$1, {\n        translationKey: \"walletModal.restoreInfoModal.title\",\n        children: \"Restore\"\n      }), createComponent(ScrollContainer, {\n        get children() {\n          return [createComponent(StepBlock, {\n            get children() {\n              return [createComponent(CircleNumber, {\n                children: \"1\"\n              }), createComponent(H3Styled, {\n                translationKey: \"walletModal.restoreModal.step1.title\",\n                children: \"Find your current recovery phrase\"\n              }), createComponent(TextStyled$1, {\n                translationKey: \"walletModal.restoreModal.step1.text\",\n                children: \"Open your wallet settings and locate therecoveryphrase\"\n              })];\n            }\n          }), createComponent(StepBlock, {\n            get children() {\n              return [createComponent(CircleNumber, {\n                children: \"2\"\n              }), createComponent(H3Styled, {\n                translationKey: \"walletModal.restoreModal.step2.title\",\n                children: \"Copy your recovery phrase\"\n              }), createComponent(TextStyled$1, {\n                translationKey: \"walletModal.restoreModal.step2.text\",\n                children: \"Write it down or copy it to a safe place\"\n              })];\n            }\n          }), createComponent(StepBlock, {\n            get children() {\n              return [createComponent(CircleNumber, {\n                children: \"3\"\n              }), createComponent(H3Styled, {\n                translationKey: \"walletModal.restoreModal.step3.title\",\n                children: \"Restore in a supported wallet fromthelistbelow\"\n              }), createComponent(TextStyled$1, {\n                translationKey: \"walletModal.restoreModal.step3.text\",\n                children: \"Enter the recovery phrase to access your wallet\"\n              })];\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst DesktopFeatureNotSupportModal = (props) => {\n  const [selectedWallet, setSelectedWallet] = createSignal(null);\n  const [infoModalOpen, setInfoModalOpen] = createSignal(false);\n  const currentWalletUI = createMemo(() => props.walletsList.find((wallet) => wallet.appName === props.currentWallet.device.appName || wallet.name === props.currentWallet.device.appName));\n  const currentWalletName = createMemo(() => {\n    var _a2, _b2, _c2, _d2;\n    const appName = (_b2 = (_a2 = currentWalletUI()) == null ? void 0 : _a2.appName) != null ? _b2 : props.currentWallet.device.appName;\n    if (appName === AT_WALLET_APP_NAME) {\n      return \"Wallet in Telegram\";\n    }\n    return (_d2 = (_c2 = currentWalletUI()) == null ? void 0 : _c2.name) != null ? _d2 : props.currentWallet.device.appName;\n  });\n  const currentWalletVersionNotSupported = createMemo(() => {\n    const currentWalletUIVar = currentWalletUI();\n    if (!(currentWalletUIVar == null ? void 0 : currentWalletUIVar.features)) {\n      return false;\n    }\n    const requiredFeature = props.walletsModalState.requiredFeature;\n    const requiredFeatures = requiredFeature ? {\n      [requiredFeature.featureName]: requiredFeature.value\n    } : {};\n    const validInList = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.checkRequiredWalletFeatures)(currentWalletUIVar.features, requiredFeatures);\n    const validCurrentWallet = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.checkRequiredWalletFeatures)(props.currentWallet.device.features, requiredFeatures);\n    return validInList && !validCurrentWallet;\n  });\n  const handleDisconnect = () => __async(null, null, function* () {\n    yield props.onDisconnect();\n    props.onSelect(selectedWallet());\n  });\n  return createComponent(DesktopFeatureNotSupportModalStyled, {\n    get children() {\n      return createComponent(Switch, {\n        get children() {\n          return [createComponent(Match, {\n            get when() {\n              return infoModalOpen();\n            },\n            get children() {\n              return createComponent(RestoreInfoModal, {\n                onBackClick: () => setInfoModalOpen(false)\n              });\n            }\n          }), createComponent(Match, {\n            get when() {\n              return selectedWallet();\n            },\n            get children() {\n              return [createComponent(Spacer, {}), createComponent(DesktopFeatureNotSupportModalStyled, {\n                get children() {\n                  return [createComponent(StyledIconButton$1, {\n                    icon: \"arrow\",\n                    onClick: () => setSelectedWallet(null)\n                  }), createComponent(TitleStyled, {\n                    translationKey: \"walletModal.featureNotSupported.disconnect.title\",\n                    children: \"Confirm Disconnect\"\n                  }), createComponent(DescriptionStyled, {\n                    translationKey: \"walletModal.featureNotSupported.disconnect.description\",\n                    get translationValues() {\n                      return {\n                        name: selectedWallet().name\n                      };\n                    },\n                    get children() {\n                      return [\"You will be disconnected from your current wallet and redirected to connect \", memo(() => {\n                        var _a2;\n                        return (_a2 = selectedWallet()) == null ? void 0 : _a2.name;\n                      }), \".\"];\n                    }\n                  }), createComponent(DisconnectButtonStyled, {\n                    onClick: () => handleDisconnect(),\n                    get children() {\n                      return createComponent(Translation, {\n                        translationKey: \"walletModal.featureNotSupported.disconnect.button\",\n                        children: \"Disconnect\"\n                      });\n                    }\n                  })];\n                }\n              })];\n            }\n          }), createComponent(Match, {\n            get when() {\n              return currentWalletVersionNotSupported();\n            },\n            get children() {\n              return [createComponent(H1Styled$2, {\n                get children() {\n                  return currentWalletName();\n                }\n              }), createComponent(ErrorIconStyled, {\n                size: \"s\"\n              }), createComponent(BodyTextStyled, {\n                translationKey: \"walletModal.featureNotSupported.version.description\",\n                get translationValues() {\n                  return {\n                    name: currentWalletName()\n                  };\n                },\n                get children() {\n                  return [\"Your current version of \", memo(() => currentWalletName()), \" or wallet contract type doesn't support the required features. Please update it to continue.\"];\n                }\n              }), createComponent(ButtonsContainerStyled, {\n                get children() {\n                  return [createComponent(Link, {\n                    get href() {\n                      return currentWalletUI().aboutUrl;\n                    },\n                    blank: true,\n                    get children() {\n                      return createComponent(Button, {\n                        get leftIcon() {\n                          return createComponent(LinkIcon, {});\n                        },\n                        get children() {\n                          return createComponent(Translation, {\n                            translationKey: \"walletModal.featureNotSupported.version.updateButton\",\n                            get translationValues() {\n                              return {\n                                name: currentWalletName()\n                              };\n                            },\n                            get children() {\n                              return [\"Update \", memo(() => currentWalletName())];\n                            }\n                          });\n                        }\n                      });\n                    }\n                  }), createComponent(Link, {\n                    href: \"https://tonkeeper.helpscoutdocs.com/article/102-w5\",\n                    blank: true,\n                    get children() {\n                      return createComponent(Button, {\n                        get leftIcon() {\n                          return createComponent(LinkIcon, {});\n                        },\n                        get children() {\n                          return createComponent(Translation, {\n                            translationKey: \"walletModal.featureNotSupported.version.aboutW5\",\n                            children: \"About W5\"\n                          });\n                        }\n                      });\n                    }\n                  })];\n                }\n              })];\n            }\n          }), createComponent(Match, {\n            when: true,\n            get children() {\n              return [createComponent(Spacer, {}), createComponent(ErrorIconStyled, {\n                size: \"s\"\n              }), createComponent(TitleStyled, {\n                translationKey: \"walletModal.featureNotSupported.wallet.title\",\n                get translationValues() {\n                  return {\n                    name: currentWalletName()\n                  };\n                },\n                get children() {\n                  return [memo(() => currentWalletName()), \" doesnt support the requestedaction\"];\n                }\n              }), createComponent(Spacer, {})];\n            }\n          })];\n        }\n      });\n    }\n  });\n};\nconst WalletsModal = () => {\n  const {\n    locale\n  } = useI18n()[1];\n  createEffect(() => locale(appState.language));\n  createEffect(() => {\n    if (getWalletsModalIsOpened()) {\n      updateIsMobile();\n      refetchWallets();\n    } else {\n      setSelectedWalletInfo(null);\n      setSelectedTab(\"universal\");\n      setInfoTab(false);\n    }\n  });\n  const connector = useContext(ConnectorContext);\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [fetchedWalletsList, {\n    refetch: refetchWallets\n  }] = createResource(() => {\n    return tonConnectUI.getWallets();\n  });\n  const [selectedWalletInfo, setSelectedWalletInfo] = createSignal(null);\n  const [selectedWalletError, setSelectedWalletError] = createSignal(null);\n  const [selectedTab, setSelectedTab] = createSignal(\"universal\");\n  const [infoTab, setInfoTab] = createSignal(false);\n  const walletsModalIsWalletNotSupportFeature = createMemo(() => {\n    const state = walletsModalState();\n    return \"type\" in state && state.type === \"wallet-not-support-feature\";\n  });\n  const walletsList = createMemo(() => {\n    var _a2;\n    if (fetchedWalletsList.state !== \"ready\") {\n      return null;\n    }\n    let walletsList2 = applyWalletsListConfiguration(fetchedWalletsList(), appState.walletsListConfiguration);\n    const injectedWallets = walletsList2.filter(_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyInjected);\n    const notInjectedWallets = walletsList2.filter((w) => !(0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyInjected)(w));\n    walletsList2 = (injectedWallets || []).concat(notInjectedWallets);\n    const preferredWalletAppName = appState.preferredWalletAppName;\n    const preferredWallet = walletsList2.find((item) => eqWalletName(item, preferredWalletAppName));\n    const someWalletsWithSameName = walletsList2.filter((item) => eqWalletName(item, preferredWalletAppName)).length >= 2;\n    if (preferredWalletAppName && preferredWallet && !someWalletsWithSameName) {\n      walletsList2 = [__spreadProps(__spreadValues({}, preferredWallet), {\n        isPreferred: true\n      })].concat(walletsList2.filter((item) => !eqWalletName(item, preferredWalletAppName)));\n    }\n    const atWallet = walletsList2.find((item) => eqWalletName(item, AT_WALLET_APP_NAME));\n    if (atWallet) {\n      walletsList2 = [atWallet].concat(walletsList2.filter((item) => !eqWalletName(item, AT_WALLET_APP_NAME)));\n    }\n    const walletsFeaturesRequested = (_a2 = tonConnectUI == null ? void 0 : tonConnectUI.walletsRequiredFeatures) != null ? _a2 : tonConnectUI == null ? void 0 : tonConnectUI.walletsPreferredFeatures;\n    const uiWallets = walletsList2.map((wallet) => {\n      var _a3;\n      return __spreadProps(__spreadValues({}, wallet), {\n        isSupportRequiredFeatures: walletsFeaturesRequested ? (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.checkRequiredWalletFeatures)((_a3 = wallet.features) != null ? _a3 : [], walletsFeaturesRequested) : true\n      });\n    });\n    return uiWallets;\n  });\n  const additionalRequestLoading = () => {\n    var _a2;\n    return ((_a2 = appState.connectRequestParameters) == null ? void 0 : _a2.state) === \"loading\";\n  };\n  const additionalRequest = createMemo(() => {\n    var _a2;\n    if (additionalRequestLoading()) {\n      return void 0;\n    }\n    return (_a2 = appState.connectRequestParameters) == null ? void 0 : _a2.value;\n  });\n  const onClose = (closeReason) => {\n    tonConnectUI.closeModal(closeReason);\n  };\n  const unsubscribe = connector.onStatusChange((wallet) => {\n    if (wallet) {\n      onClose(\"wallet-selected\");\n    }\n  }, (err) => {\n    var _a2;\n    if (err instanceof _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletMissingRequiredFeaturesError) {\n      const errorAppName = err.cause.connectEvent.device.appName.toLowerCase();\n      const wallet = (_a2 = walletsList()) == null ? void 0 : _a2.find((w) => w.appName.toLowerCase() === errorAppName);\n      if (!wallet) {\n        throw new _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnectError(\"Wallet not found\");\n      }\n      const walletErrorType = wallet.isSupportRequiredFeatures ? \"missing-features\" : \"not-supported\";\n      setSelectedWalletError(walletErrorType);\n      setSelectedWalletInfo(wallet);\n    }\n  });\n  const onSelectAllWallets = () => {\n    setSelectedTab(\"all-wallets\");\n  };\n  const onSelectUniversal = () => {\n    setSelectedTab(\"universal\");\n  };\n  const onSelectWallet = (wallet) => {\n    setSelectedWalletInfo(wallet);\n    widgetController.openWalletsModal();\n  };\n  const clearSelectedWalletInfo = () => {\n    setSelectedWalletInfo(null);\n    setSelectedWalletError(null);\n  };\n  onCleanup(() => {\n    setSelectedWalletInfo(null);\n    setSelectedWalletError(null);\n    setInfoTab(false);\n  });\n  onCleanup(unsubscribe);\n  return createComponent(StyledModal, {\n    get opened() {\n      return getWalletsModalIsOpened();\n    },\n    get enableAndroidBackHandler() {\n      return appState.enableAndroidBackHandler;\n    },\n    onClose: () => onClose(\"action-cancelled\"),\n    onClickQuestion: () => setInfoTab((v) => !v),\n    get showFooter() {\n      return !walletsModalIsWalletNotSupportFeature();\n    },\n    \"data-tc-wallets-modal-container\": \"true\",\n    get children() {\n      return [createComponent(Show, {\n        get when() {\n          return infoTab();\n        },\n        get children() {\n          return createComponent(InfoModal, {\n            onBackClick: () => setInfoTab(false)\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !infoTab();\n        },\n        get children() {\n          return [createComponent(Show, {\n            get when() {\n              return additionalRequestLoading() || !walletsList();\n            },\n            get children() {\n              return [createComponent(H1Styled$a, {\n                translationKey: \"walletModal.loading\",\n                children: \"Wallets list is loading\"\n              }), createComponent(LoaderContainerStyled, {\n                get children() {\n                  return createComponent(LoaderIcon, {\n                    size: \"m\"\n                  });\n                }\n              })];\n            }\n          }), createComponent(Show, {\n            get when() {\n              return memo(() => !!!additionalRequestLoading())() && walletsList();\n            },\n            get children() {\n              return createComponent(Switch, {\n                get children() {\n                  return [createComponent(Match, {\n                    get when() {\n                      return walletsModalIsWalletNotSupportFeature();\n                    },\n                    get children() {\n                      return createComponent(DesktopFeatureNotSupportModal, {\n                        get walletsList() {\n                          return walletsList();\n                        },\n                        get currentWallet() {\n                          return tonConnectUI == null ? void 0 : tonConnectUI.wallet;\n                        },\n                        onSelect: onSelectWallet,\n                        onSelectAllWallets,\n                        onDisconnect: () => connector.disconnect(),\n                        get walletsModalState() {\n                          return walletsModalState();\n                        },\n                        onClose: () => onClose(\"action-cancelled\")\n                      });\n                    }\n                  }), createComponent(Match, {\n                    get when() {\n                      return selectedWalletInfo();\n                    },\n                    get children() {\n                      return createComponent(Dynamic, {\n                        get component() {\n                          return isMobile() ? MobileConnectionModal : DesktopConnectionModal;\n                        },\n                        get walletsModalState() {\n                          return walletsModalState();\n                        },\n                        get wallet() {\n                          return selectedWalletInfo();\n                        },\n                        get additionalRequest() {\n                          return additionalRequest();\n                        },\n                        onBackClick: clearSelectedWalletInfo,\n                        get defaultError() {\n                          return selectedWalletError();\n                        }\n                      });\n                    }\n                  }), createComponent(Match, {\n                    get when() {\n                      return selectedTab() === \"universal\";\n                    },\n                    get children() {\n                      return createComponent(Dynamic, {\n                        get component() {\n                          return isMobile() ? MobileUniversalModal : DesktopUniversalModal;\n                        },\n                        onSelect: setSelectedWalletInfo,\n                        get walletModalState() {\n                          return walletsModalState();\n                        },\n                        get walletsList() {\n                          return walletsList();\n                        },\n                        get additionalRequest() {\n                          return additionalRequest();\n                        },\n                        onSelectAllWallets\n                      });\n                    }\n                  }), createComponent(Match, {\n                    get when() {\n                      return selectedTab() === \"all-wallets\";\n                    },\n                    get children() {\n                      return createComponent(AllWalletsListModal, {\n                        get walletsList() {\n                          return walletsList();\n                        },\n                        get featureCheckMode() {\n                          return (tonConnectUI == null ? void 0 : tonConnectUI.walletsRequiredFeatures) ? \"strict\" : \"soft\";\n                        },\n                        onBack: onSelectUniversal,\n                        onSelect: setSelectedWalletInfo\n                      });\n                    }\n                  })];\n                }\n              });\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst ActionModalStyled = styled.div`\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    padding-bottom: 8px;\n`;\nconst H1Styled = styled(H1)`\n    margin-top: 16px;\n`;\nconst TextStyled = styled(Text)`\n    font-weight: 510;\n    font-size: 16px;\n    line-height: 20px;\n    text-align: center;\n    max-width: 250px;\n\n    color: ${(props) => props.theme.colors.text.secondary};\n`;\nconst LoaderButtonStyled = styled(Button)`\n    min-width: 112px;\n    margin-top: 32px;\n`;\nconst LoaderIconStyled = styled(LoaderIcon)`\n    height: 16px;\n    width: 16px;\n`;\nconst ButtonStyled = styled(Button)`\n    margin-top: 32px;\n`;\nconst ActionModal = (props) => {\n  const dataAttrs = useDataAttributes(props);\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [firstClick, setFirstClick] = createSignal(true);\n  const [sent, setSent] = createSignal(false);\n  const [signed, setSigned] = createSignal(false);\n  const [canceled, setCanceled] = createSignal(false);\n  createEffect(() => {\n    const currentAction = action();\n    setSent(!!currentAction && (\"sent\" in currentAction && currentAction.sent || currentAction.name === \"transaction-sent\"));\n    setSigned(!!currentAction && (\"signed\" in currentAction && currentAction.signed || currentAction.name === \"data-signed\"));\n    setCanceled(!!currentAction && (currentAction.name === \"transaction-canceled\" || currentAction.name === \"sign-data-canceled\"));\n  });\n  let universalLink;\n  if ((tonConnectUI == null ? void 0 : tonConnectUI.wallet) && \"universalLink\" in tonConnectUI.wallet && (tonConnectUI.wallet.openMethod === \"universal-link\" || (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isTelegramUrl)(tonConnectUI.wallet.universalLink) && isInTMA())) {\n    universalLink = tonConnectUI.wallet.universalLink;\n  }\n  let deepLink;\n  if ((tonConnectUI == null ? void 0 : tonConnectUI.wallet) && \"deepLink\" in tonConnectUI.wallet && (tonConnectUI.wallet.openMethod === \"custom-deeplink\" || (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isTelegramUrl)(tonConnectUI.wallet.deepLink) && isInTMA())) {\n    deepLink = tonConnectUI.wallet.deepLink;\n  }\n  const onOpenWallet = () => {\n    const currentAction = action();\n    const returnStrategy = \"returnStrategy\" in currentAction ? currentAction.returnStrategy : appState.returnStrategy;\n    const forceRedirect = !firstClick();\n    setFirstClick(false);\n    const linkWithSessionId = enrichUniversalLink(universalLink, {\n      sessionId: currentAction.sessionId,\n      traceId: currentAction.traceId\n    });\n    if ((0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isTelegramUrl)(universalLink)) {\n      redirectToTelegram(linkWithSessionId, {\n        returnStrategy,\n        twaReturnUrl: \"twaReturnUrl\" in currentAction ? currentAction.twaReturnUrl : appState.twaReturnUrl,\n        forceRedirect\n      });\n    } else {\n      redirectToWallet(linkWithSessionId, deepLink, {\n        returnStrategy,\n        forceRedirect\n      }, () => {\n      });\n    }\n  };\n  return createComponent(ActionModalStyled, mergeProps(dataAttrs, {\n    get children() {\n      return [memo(() => props.icon), createComponent(H1Styled, {\n        get translationKey() {\n          return props.headerTranslationKey;\n        },\n        get translationValues() {\n          return props.headerTranslationValues;\n        }\n      }), createComponent(TextStyled, {\n        get translationKey() {\n          return props.textTranslationKey;\n        },\n        get translationValues() {\n          return props.textTranslationValues;\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !sent() && !signed() && !canceled() && (props.showButton === \"open-wallet\" && universalLink || props.showButton !== \"open-wallet\");\n        },\n        get children() {\n          return createComponent(LoaderButtonStyled, {\n            disabled: true,\n            \"data-tc-connect-button-loading\": \"true\",\n            get children() {\n              return createComponent(LoaderIconStyled, {});\n            }\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return sent() || signed();\n        },\n        get children() {\n          return [createComponent(Show, {\n            get when() {\n              return props.showButton !== \"open-wallet\";\n            },\n            get children() {\n              return createComponent(ButtonStyled, {\n                onClick: () => props.onClose(),\n                get children() {\n                  return createComponent(Translation, {\n                    translationKey: \"common.close\",\n                    children: \"Close\"\n                  });\n                }\n              });\n            }\n          }), createComponent(Show, {\n            get when() {\n              return props.showButton === \"open-wallet\" && universalLink;\n            },\n            get children() {\n              return createComponent(ButtonStyled, {\n                onClick: onOpenWallet,\n                get children() {\n                  return createComponent(Translation, {\n                    translationKey: \"common.openWallet\",\n                    children: \"Open wallet\"\n                  });\n                }\n              });\n            }\n          })];\n        }\n      })];\n    }\n  }));\n};\nconst ConfirmTransactionModal = (props) => {\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [t2] = useI18n();\n  const name = () => tonConnectUI.wallet && \"name\" in tonConnectUI.wallet ? tonConnectUI.wallet.name : t2(\"common.yourWallet\", {}, \"Your wallet\");\n  return createComponent(ActionModal, {\n    headerTranslationKey: \"actionModal.confirmTransaction.header\",\n    get headerTranslationValues() {\n      return {\n        name: name()\n      };\n    },\n    textTranslationKey: \"actionModal.confirmTransaction.text\",\n    get icon() {\n      return createComponent(LoaderIcon, {\n        size: \"m\"\n      });\n    },\n    onClose: () => props.onClose(),\n    showButton: \"open-wallet\",\n    \"data-tc-confirm-modal\": \"true\"\n  });\n};\nconst TransactionCanceledModal = (props) => {\n  return createComponent(ActionModal, {\n    headerTranslationKey: \"actionModal.transactionCanceled.header\",\n    textTranslationKey: \"actionModal.transactionCanceled.text\",\n    get icon() {\n      return createComponent(ErrorIcon, {\n        size: \"m\"\n      });\n    },\n    onClose: () => props.onClose(),\n    \"data-tc-transaction-canceled-modal\": \"true\"\n  });\n};\nconst TransactionSentModal = (props) => {\n  return createComponent(ActionModal, {\n    headerTranslationKey: \"actionModal.transactionSent.header\",\n    textTranslationKey: \"actionModal.transactionSent.text\",\n    get icon() {\n      return createComponent(SuccessIcon, {\n        size: \"m\"\n      });\n    },\n    showButton: \"open-wallet\",\n    onClose: () => props.onClose(),\n    \"data-tc-transaction-sent-modal\": \"true\"\n  });\n};\nconst ConfirmSignDataModal = (props) => {\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [t2] = useI18n();\n  const name = () => tonConnectUI.wallet && \"name\" in tonConnectUI.wallet ? tonConnectUI.wallet.name : t2(\"common.yourWallet\", {}, \"Your wallet\");\n  return createComponent(ActionModal, {\n    headerTranslationKey: \"actionModal.signData.header\",\n    get headerTranslationValues() {\n      return {\n        name: name()\n      };\n    },\n    textTranslationKey: \"actionModal.signData.text\",\n    get icon() {\n      return createComponent(LoaderIcon, {\n        size: \"m\"\n      });\n    },\n    onClose: () => props.onClose(),\n    showButton: \"open-wallet\",\n    \"data-tc-sign-data-confirm-modal\": \"true\"\n  });\n};\nconst SignDataCanceledModal = (props) => {\n  return createComponent(ActionModal, {\n    headerTranslationKey: \"actionModal.signDataCanceled.header\",\n    get icon() {\n      return createComponent(ErrorIcon, {\n        size: \"m\"\n      });\n    },\n    onClose: () => props.onClose(),\n    \"data-tc-sign-data-canceled-modal\": \"true\"\n  });\n};\nconst DataSignedModal = (props) => {\n  return createComponent(ActionModal, {\n    headerTranslationKey: \"actionModal.dataSigned.header\",\n    get icon() {\n      return createComponent(SuccessIcon, {\n        size: \"m\"\n      });\n    },\n    onClose: () => props.onClose(),\n    \"data-tc-data-signed-modal\": \"true\"\n  });\n};\nconst ActionsModal = () => {\n  return createComponent(Modal, {\n    get opened() {\n      var _a2;\n      return memo(() => action() !== null)() && ((_a2 = action()) == null ? void 0 : _a2.openModal) === true;\n    },\n    get enableAndroidBackHandler() {\n      return appState.enableAndroidBackHandler;\n    },\n    onClose: () => setAction(null),\n    showFooter: false,\n    \"data-tc-actions-modal-container\": \"true\",\n    get children() {\n      return createComponent(Switch, {\n        get children() {\n          return [createComponent(Match, {\n            get when() {\n              return action().name === \"transaction-sent\";\n            },\n            get children() {\n              return createComponent(TransactionSentModal, {\n                onClose: () => setAction(null)\n              });\n            }\n          }), createComponent(Match, {\n            get when() {\n              return action().name === \"transaction-canceled\";\n            },\n            get children() {\n              return createComponent(TransactionCanceledModal, {\n                onClose: () => setAction(null)\n              });\n            }\n          }), createComponent(Match, {\n            get when() {\n              return action().name === \"confirm-transaction\";\n            },\n            get children() {\n              return createComponent(ConfirmTransactionModal, {\n                onClose: () => setAction(null)\n              });\n            }\n          }), createComponent(Match, {\n            get when() {\n              return action().name === \"data-signed\";\n            },\n            get children() {\n              return createComponent(DataSignedModal, {\n                onClose: () => setAction(null)\n              });\n            }\n          }), createComponent(Match, {\n            get when() {\n              return action().name === \"sign-data-canceled\";\n            },\n            get children() {\n              return createComponent(SignDataCanceledModal, {\n                onClose: () => setAction(null)\n              });\n            }\n          }), createComponent(Match, {\n            get when() {\n              return action().name === \"confirm-sign-data\";\n            },\n            get children() {\n              return createComponent(ConfirmSignDataModal, {\n                onClose: () => setAction(null)\n              });\n            }\n          })];\n        }\n      });\n    }\n  });\n};\nconst SingleWalletModal = () => {\n  const {\n    locale\n  } = useI18n()[1];\n  createEffect(() => locale(appState.language));\n  createEffect(() => {\n    if (getSingleWalletModalIsOpened()) {\n      updateIsMobile();\n    }\n  });\n  const connector = useContext(ConnectorContext);\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [infoTab, setInfoTab] = createSignal(false);\n  const additionalRequestLoading = () => {\n    var _a2;\n    return ((_a2 = appState.connectRequestParameters) == null ? void 0 : _a2.state) === \"loading\";\n  };\n  const additionalRequest = createMemo(() => {\n    var _a2;\n    if (additionalRequestLoading()) {\n      return void 0;\n    }\n    return (_a2 = appState.connectRequestParameters) == null ? void 0 : _a2.value;\n  });\n  const onClose = (closeReason) => {\n    tonConnectUI.closeSingleWalletModal(closeReason);\n  };\n  const unsubscribe = connector.onStatusChange((wallet) => {\n    if (wallet) {\n      onClose(\"wallet-selected\");\n    }\n  });\n  onCleanup(unsubscribe);\n  onCleanup(() => {\n    setInfoTab(false);\n  });\n  return createComponent(StyledModal, {\n    get opened() {\n      return getSingleWalletModalIsOpened();\n    },\n    get enableAndroidBackHandler() {\n      return appState.enableAndroidBackHandler;\n    },\n    onClose: () => onClose(\"action-cancelled\"),\n    onClickQuestion: () => setInfoTab((v) => !v),\n    showFooter: true,\n    \"data-tc-wallets-modal-container\": \"true\",\n    get children() {\n      return [createComponent(Show, {\n        get when() {\n          return infoTab();\n        },\n        get children() {\n          return createComponent(InfoModal, {\n            onBackClick: () => setInfoTab(false)\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !infoTab();\n        },\n        get children() {\n          return [createComponent(Show, {\n            get when() {\n              return additionalRequestLoading();\n            },\n            get children() {\n              return [createComponent(H1Styled$a, {\n                translationKey: \"walletModal.loading\",\n                children: \"Wallets list is loading\"\n              }), createComponent(LoaderContainerStyled, {\n                get children() {\n                  return createComponent(LoaderIcon, {\n                    size: \"m\"\n                  });\n                }\n              })];\n            }\n          }), createComponent(Show, {\n            get when() {\n              return !additionalRequestLoading();\n            },\n            get children() {\n              return createComponent(Dynamic, {\n                get component() {\n                  return isMobile() ? MobileConnectionModal : DesktopConnectionModal;\n                },\n                get wallet() {\n                  return getSingleWalletModalWalletInfo();\n                },\n                get additionalRequest() {\n                  return additionalRequest();\n                },\n                onBackClick: () => {\n                },\n                backDisabled: true\n              });\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst App = (props) => {\n  const translations = createI18nContext(i18nDictionary, appState.language);\n  defineStylesRoot();\n  fixMobileSafariActiveTransition();\n  return createComponent(I18nContext.Provider, {\n    value: translations,\n    get children() {\n      return createComponent(TonConnectUiContext.Provider, {\n        get value() {\n          return props.tonConnectUI;\n        },\n        get children() {\n          return createComponent(ConnectorContext.Provider, {\n            get value() {\n              return appState.connector;\n            },\n            get children() {\n              return [createComponent(GlobalStyles, {}), createComponent(ThemeProvider, {\n                theme: themeState,\n                get children() {\n                  return [createComponent(Show, {\n                    get when() {\n                      return appState.buttonRootId;\n                    },\n                    get children() {\n                      return createComponent(Portal, {\n                        get mount() {\n                          return document.getElementById(appState.buttonRootId);\n                        },\n                        get children() {\n                          return createComponent(AccountButton, {});\n                        }\n                      });\n                    }\n                  }), createComponent(Dynamic, {\n                    component: globalStylesTag,\n                    get children() {\n                      return [createComponent(WalletsModal, {}), createComponent(SingleWalletModal, {}), createComponent(ActionsModal, {})];\n                    }\n                  })];\n                }\n              })];\n            }\n          });\n        }\n      });\n    }\n  });\n};\nconst widgetController = {\n  openWalletsModal: (options) => void setTimeout(() => setWalletsModalState((prev) => {\n    var _a2;\n    return {\n      status: \"opened\",\n      traceId: (_a2 = options == null ? void 0 : options.traceId) != null ? _a2 : prev == null ? void 0 : prev.traceId,\n      closeReason: null\n    };\n  })),\n  closeWalletsModal: (reason) => void setTimeout(() => setWalletsModalState({\n    status: \"closed\",\n    closeReason: reason\n  })),\n  openSingleWalletModal: (walletInfo) => {\n    void setTimeout(() => setSingleWalletModalState({\n      status: \"opened\",\n      closeReason: null,\n      walletInfo\n    }));\n  },\n  closeSingleWalletModal: (reason) => void setTimeout(() => setSingleWalletModalState({\n    status: \"closed\",\n    closeReason: reason\n  })),\n  openWalletNotSupportFeatureModal: (cause, options) => void setTimeout(() => setWalletsModalState({\n    status: \"opened\",\n    traceId: options.traceId,\n    closeReason: null,\n    type: \"wallet-not-support-feature\",\n    requiredFeature: cause.requiredFeature\n  })),\n  setAction: (action2) => void setTimeout(() => setAction(action2)),\n  clearAction: () => void setTimeout(() => setAction(null)),\n  getSelectedWalletInfo: () => lastSelectedWalletInfo(),\n  getLastVisibleWallets: () => lastVisibleWalletsInfo(),\n  removeSelectedWalletInfo: () => setLastSelectedWalletInfo(null),\n  renderApp: (root, tonConnectUI) => render(() => createComponent(App, {\n    tonConnectUI\n  }), document.getElementById(root))\n};\nclass WalletsModalManager {\n  constructor(options) {\n    this.consumers = [];\n    this.state = walletsModalState();\n    this.connector = options.connector;\n    this.tracker = options.tracker;\n    this.setConnectRequestParametersCallback = options.setConnectRequestParametersCallback;\n    createEffect(() => {\n      const state = walletsModalState();\n      this.state = state;\n      this.consumers.forEach((consumer) => consumer(state));\n    });\n    createEffect(\n      on(lastSelectedWalletInfo, (selectedWallet, previousWallet) => __async(this, null, function* () {\n        try {\n          const { wallets, walletsMenu } = widgetController.getLastVisibleWallets();\n          if (selectedWallet && \"appName\" in selectedWallet) {\n            if (previousWallet && \"appName\" in previousWallet && previousWallet.appName === selectedWallet.appName) {\n              return;\n            }\n            const clientId = yield this.connector.getSessionId();\n            this.tracker.trackSelectedWallet(\n              wallets.map((wallet) => wallet.name),\n              selectedWallet,\n              walletsMenu,\n              \"\",\n              void 0,\n              clientId,\n              this.state.traceId\n            );\n          }\n        } catch (error) {\n          logError(error);\n        }\n      }))\n    );\n    createEffect(\n      on(lastOpenedLink, (openedLink) => __async(this, null, function* () {\n        try {\n          const { wallets, walletsMenu } = widgetController.getLastVisibleWallets();\n          if ((0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isConnectUrl)(openedLink.link)) {\n            const selectedWallet = lastSelectedWalletInfo();\n            const clientId = yield this.connector.getSessionId();\n            this.tracker.trackSelectedWallet(\n              wallets.map((wallet) => wallet.name),\n              selectedWallet && \"appName\" in selectedWallet ? selectedWallet : null,\n              walletsMenu,\n              openedLink.link,\n              openedLink.type,\n              clientId,\n              this.state.traceId\n            );\n          }\n        } catch (error) {\n          logError(error);\n        }\n      }))\n    );\n  }\n  /**\n   * Opens the modal window.\n   */\n  open(options) {\n    return __async(this, null, function* () {\n      var _a2;\n      const traceId = (_a2 = options == null ? void 0 : options.traceId) != null ? _a2 : (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.UUIDv7)();\n      this.tracker.trackConnectionStarted();\n      const walletsList = yield this.connector.getWallets();\n      const embeddedWallet = walletsList.find(_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyEmbedded);\n      if (embeddedWallet) {\n        return this.connectEmbeddedWallet(embeddedWallet, { traceId });\n      } else {\n        return this.openWalletsModal({ traceId });\n      }\n    });\n  }\n  /**\n   * Closes the modal window.\n   * @default 'action-cancelled'\n   */\n  close(reason = \"action-cancelled\") {\n    if (reason === \"action-cancelled\") {\n      this.tracker.trackConnectionError(\"Connection was cancelled\");\n    }\n    widgetController.closeWalletsModal(reason);\n  }\n  /**\n   * Subscribe to the modal window state changes, returns unsubscribe function.\n   */\n  onStateChange(onChange) {\n    this.consumers.push(onChange);\n    return () => {\n      this.consumers = this.consumers.filter((consumer) => consumer !== onChange);\n    };\n  }\n  /**\n   * Initiates a connection with an embedded wallet.\n   * @param embeddedWallet - Information about the embedded wallet to connect to.\n   * @internal\n   */\n  connectEmbeddedWallet(embeddedWallet, options) {\n    const connect = (parameters) => {\n      setLastSelectedWalletInfo(embeddedWallet);\n      this.connector.connect({ jsBridgeKey: embeddedWallet.jsBridgeKey }, parameters, {\n        traceId: options.traceId\n      });\n    };\n    const additionalRequest = appState.connectRequestParameters;\n    if ((additionalRequest == null ? void 0 : additionalRequest.state) === \"loading\") {\n      this.setConnectRequestParametersCallback(connect);\n    } else {\n      connect(additionalRequest == null ? void 0 : additionalRequest.value);\n    }\n  }\n  /**\n   * Opens the modal window to connect to an external wallet, and waits when modal window is opened.\n   * @internal\n   */\n  openWalletsModal(options) {\n    return __async(this, null, function* () {\n      if (isInTMA()) {\n        sendExpand();\n      }\n      widgetController.openWalletsModal({ traceId: options.traceId });\n      return new Promise((resolve) => {\n        const unsubscribe = this.onStateChange((state) => {\n          const { status } = state;\n          if (status === \"opened\") {\n            unsubscribe();\n            resolve();\n          }\n        });\n      });\n    });\n  }\n}\nclass TransactionModalManager {\n  constructor(options) {\n    this.consumers = [];\n    this.connector = options.connector;\n    createEffect(() => {\n      const currentAction = action();\n      this.consumers.forEach((consumer) => consumer(currentAction));\n    });\n  }\n  /**\n   * Subscribe to the modal window state changes, returns unsubscribe function.\n   */\n  onStateChange(consumer) {\n    this.consumers.push(consumer);\n    return () => {\n      this.consumers = this.consumers.filter((c2) => c2 !== consumer);\n    };\n  }\n}\nclass SingleWalletModalManager {\n  constructor(options) {\n    this.consumers = [];\n    this.state = singleWalletModalState();\n    this.connector = options.connector;\n    this.tracker = options.tracker;\n    this.setConnectRequestParametersCallback = options.setConnectRequestParametersCallback;\n    createEffect(() => {\n      const state = singleWalletModalState();\n      this.state = state;\n      this.consumers.forEach((consumer) => consumer(state));\n    });\n  }\n  /**\n   * Opens the modal window with the specified wallet.\n   * @param wallet - Wallet app name.\n   * @throws TonConnectUIError if the specified wallet is not found.\n   */\n  open(wallet) {\n    return __async(this, null, function* () {\n      this.tracker.trackConnectionStarted();\n      const fetchedWalletsList = yield this.connector.getWallets();\n      const walletsList = applyWalletsListConfiguration(\n        fetchedWalletsList,\n        appState.walletsListConfiguration\n      );\n      const embeddedWallet = walletsList.find(_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyEmbedded);\n      const isEmbeddedWalletExist = !!embeddedWallet;\n      if (isEmbeddedWalletExist) {\n        return this.connectEmbeddedWallet(embeddedWallet);\n      }\n      const externalWallets = walletsList.filter(_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoRemote);\n      const externalWallet = externalWallets.find((walletInfo) => eqWalletName(walletInfo, wallet));\n      const isExternalWalletExist = !!externalWallet;\n      if (isExternalWalletExist) {\n        return this.openSingleWalletModal(externalWallet);\n      }\n      const error = `Trying to open modal window with unknown wallet \"${wallet}\".`;\n      this.tracker.trackConnectionError(error);\n      throw new TonConnectUIError(error);\n    });\n  }\n  /**\n   * Closes the modal window.\n   * @default 'action-cancelled'\n   */\n  close(reason = \"action-cancelled\") {\n    if (reason === \"action-cancelled\") {\n      this.tracker.trackConnectionError(\"Connection was cancelled\");\n    }\n    widgetController.closeSingleWalletModal(\"action-cancelled\");\n  }\n  /**\n   * Subscribe to the modal window state changes, returns unsubscribe function.\n   */\n  onStateChange(onChange) {\n    this.consumers.push(onChange);\n    return () => {\n      this.consumers = this.consumers.filter((consumer) => consumer !== onChange);\n    };\n  }\n  /**\n   * Initiates a connection with an embedded wallet.\n   * @param embeddedWallet - Information about the embedded wallet to connect to.\n   * @internal\n   */\n  connectEmbeddedWallet(embeddedWallet) {\n    const connect = (parameters) => {\n      setLastSelectedWalletInfo(embeddedWallet);\n      this.connector.connect({ jsBridgeKey: embeddedWallet.jsBridgeKey }, parameters);\n    };\n    const additionalRequest = appState.connectRequestParameters;\n    if ((additionalRequest == null ? void 0 : additionalRequest.state) === \"loading\") {\n      this.setConnectRequestParametersCallback(connect);\n    } else {\n      connect(additionalRequest == null ? void 0 : additionalRequest.value);\n    }\n  }\n  /**\n   * Opens the modal window to connect to a specified wallet, and waits when modal window is opened.\n   */\n  openSingleWalletModal(wallet) {\n    return __async(this, null, function* () {\n      if (isInTMA()) {\n        sendExpand();\n      }\n      widgetController.openSingleWalletModal(wallet);\n      return new Promise((resolve) => {\n        const unsubscribe = this.onStateChange((state) => {\n          const { status } = state;\n          if (status === \"opened\") {\n            unsubscribe();\n            resolve();\n          }\n        });\n      });\n    });\n  }\n}\nclass TonConnectUITracker {\n  constructor(options) {\n    this.eventPrefix = \"ton-connect-ui-\";\n    this.tonConnectSdkVersion = null;\n    this.eventDispatcher = options == null ? void 0 : options.eventDispatcher;\n    this.tonConnectUiVersion = options.tonConnectUiVersion;\n    this.init().catch();\n  }\n  /**\n   * Version of the library.\n   */\n  get version() {\n    return (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createVersionInfo)({\n      ton_connect_sdk_lib: this.tonConnectSdkVersion,\n      ton_connect_ui_lib: this.tonConnectUiVersion\n    });\n  }\n  /**\n   * Called once when the tracker is created and request version other libraries.\n   */\n  init() {\n    return __async(this, null, function* () {\n      try {\n        yield this.setRequestVersionHandler();\n        this.tonConnectSdkVersion = yield this.requestTonConnectSdkVersion();\n      } catch (e2) {\n      }\n    });\n  }\n  /**\n   * Set request version handler.\n   * @private\n   */\n  setRequestVersionHandler() {\n    return __async(this, null, function* () {\n      yield this.eventDispatcher.addEventListener(\"ton-connect-ui-request-version\", () => __async(this, null, function* () {\n        yield this.eventDispatcher.dispatchEvent(\n          \"ton-connect-ui-response-version\",\n          (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createResponseVersionEvent)(this.tonConnectUiVersion)\n        );\n      }));\n    });\n  }\n  /**\n   * Request TonConnect SDK version.\n   * @private\n   */\n  requestTonConnectSdkVersion() {\n    return __async(this, null, function* () {\n      return new Promise((resolve, reject) => __async(this, null, function* () {\n        try {\n          yield this.eventDispatcher.addEventListener(\n            \"ton-connect-response-version\",\n            (event) => {\n              resolve(event.detail.version);\n            },\n            { once: true }\n          );\n          yield this.eventDispatcher.dispatchEvent(\n            \"ton-connect-request-version\",\n            (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createRequestVersionEvent)()\n          );\n        } catch (e2) {\n          reject(e2);\n        }\n      }));\n    });\n  }\n  /**\n   * Emit user action event to the window.\n   * @param eventDetails\n   * @private\n   */\n  dispatchUserActionEvent(eventDetails) {\n    var _a2;\n    try {\n      (_a2 = this.eventDispatcher) == null ? void 0 : _a2.dispatchEvent(`${this.eventPrefix}${eventDetails.type}`, eventDetails).catch();\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track wallet opened event.\n   * @param args\n   */\n  trackWalletModalOpened(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createWalletModalOpenedEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track wallet selected event.\n   * @param args\n   */\n  trackSelectedWallet(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createSelectedWalletEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n      logError(e2);\n    }\n  }\n  /**\n   * Track connection init event.\n   * @param args\n   */\n  trackConnectionStarted(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionStartedEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track connection success event.\n   * @param args\n   */\n  trackConnectionCompleted(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionCompletedEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track connection error event.\n   * @param args\n   */\n  trackConnectionError(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionErrorEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track connection restoring init event.\n   * @param args\n   */\n  trackConnectionRestoringStarted(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionRestoringStartedEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track connection restoring success event.\n   * @param args\n   */\n  trackConnectionRestoringCompleted(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionRestoringCompletedEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track connection restoring error event.\n   * @param args\n   */\n  trackConnectionRestoringError(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionRestoringErrorEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track disconnect event.\n   * @param args\n   */\n  trackDisconnection(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createDisconnectionEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track transaction init event.\n   * @param args\n   */\n  trackTransactionSentForSignature(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createTransactionSentForSignatureEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track transaction signed event.\n   * @param args\n   */\n  trackTransactionSigned(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createTransactionSignedEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track transaction error event.\n   * @param args\n   */\n  trackTransactionSigningFailed(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createTransactionSigningFailedEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track data sent for signature event.\n   * @param args\n   */\n  trackDataSentForSignature(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createDataSentForSignatureEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track data signed event.\n   * @param args\n   */\n  trackDataSigned(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createDataSignedEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track data signing error event.\n   * @param args\n   */\n  trackDataSigningFailed(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createDataSigningFailedEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n}\nconst tonConnectUiVersion = \"2.4.2\";\nclass TonConnectEnvironment {\n  constructor() {\n    this.userAgent = getUserAgent();\n  }\n  getLocale() {\n    var _a2;\n    return ((_a2 = navigator.languages) == null ? void 0 : _a2[0]) || navigator.language || \"\";\n  }\n  getBrowser() {\n    var _a2;\n    return (_a2 = this.userAgent.browser) != null ? _a2 : \"\";\n  }\n  getPlatform() {\n    var _a2;\n    return (_a2 = this.userAgent.os) != null ? _a2 : \"\";\n  }\n  getTelegramUser() {\n    return getTgUser();\n  }\n  getClientEnvironment() {\n    return isInTMA() ? \"miniapp\" : \"web\";\n  }\n}\nclass TonConnectUI {\n  // TODO: `actionsConfiguration.twaReturnUrl` is used only in `connectWallet` method, but it's not used in `sendTransaction` method, NEED TO FIX IT\n  constructor(options) {\n    var _a2;\n    this.walletInfoStorage = new WalletInfoStorage();\n    this.preferredWalletStorage = new PreferredWalletStorage();\n    this.walletInfo = null;\n    this.systemThemeChangeUnsubscribe = null;\n    this.connectionRestored = Promise.resolve(false);\n    let eventDispatcher = (_a2 = options == null ? void 0 : options.eventDispatcher) != null ? _a2 : new _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.BrowserEventDispatcher();\n    if (options && \"connector\" in options && options.connector) {\n      this.connector = options.connector;\n    } else if (options && \"manifestUrl\" in options && options.manifestUrl) {\n      this.connector = new _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnect({\n        manifestUrl: options.manifestUrl,\n        eventDispatcher,\n        walletsRequiredFeatures: options.walletsRequiredFeatures,\n        environment: new TonConnectEnvironment(),\n        analytics: options.analytics\n      });\n    } else {\n      throw new TonConnectUIError(\n        \"You have to specify a `manifestUrl` or a `connector` in the options.\"\n      );\n    }\n    this.tracker = new TonConnectUITracker({\n      eventDispatcher,\n      tonConnectUiVersion\n    });\n    this.modal = new WalletsModalManager({\n      connector: this.connector,\n      tracker: this.tracker,\n      setConnectRequestParametersCallback: (callback) => {\n        this.connectRequestParametersCallback = callback;\n      }\n    });\n    this.singleWalletModal = new SingleWalletModalManager({\n      connector: this.connector,\n      tracker: this.tracker,\n      setConnectRequestParametersCallback: (callback) => {\n        this.connectRequestParametersCallback = callback;\n      }\n    });\n    this.transactionModal = new TransactionModalManager({\n      connector: this.connector\n    });\n    this._walletsRequiredFeatures = options.walletsRequiredFeatures;\n    this._walletsPreferredFeatures = options.walletsPreferredFeatures;\n    this.walletsList = this.getWallets();\n    this.walletsList.then((list) => preloadImages(uniq(list.map((item) => item.imageUrl))));\n    const rootId = this.normalizeWidgetRoot(options == null ? void 0 : options.widgetRootId);\n    this.subscribeToWalletChange();\n    if ((options == null ? void 0 : options.restoreConnection) !== false) {\n      this.connectionRestored = createMacrotaskAsync(() => __async(this, null, function* () {\n        this.tracker.trackConnectionRestoringStarted();\n        yield this.connector.restoreConnection();\n        if (!this.connector.connected) {\n          this.tracker.trackConnectionRestoringError(\"Connection was not restored\");\n          this.walletInfoStorage.removeWalletInfo();\n        } else {\n          this.tracker.trackConnectionRestoringCompleted(this.wallet);\n        }\n        return this.connector.connected;\n      }));\n    }\n    this.uiOptions = mergeOptions(options, { uiPreferences: { theme: \"SYSTEM\" } });\n    const preferredWalletName = this.preferredWalletStorage.getPreferredWalletAppName();\n    setAppState({\n      connector: this.connector,\n      preferredWalletAppName: preferredWalletName\n    });\n    widgetController.renderApp(rootId, this);\n  }\n  static getWallets() {\n    return _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnect.getWallets();\n  }\n  get walletsRequiredFeatures() {\n    return this._walletsRequiredFeatures;\n  }\n  get walletsPreferredFeatures() {\n    return this._walletsPreferredFeatures;\n  }\n  /**\n   * Current connection status.\n   */\n  get connected() {\n    return this.connector.connected;\n  }\n  /**\n   * Current connected account or null.\n   */\n  get account() {\n    return this.connector.account;\n  }\n  /**\n   * Curren connected wallet app and its info or null.\n   */\n  get wallet() {\n    if (!this.connector.wallet) {\n      return null;\n    }\n    return __spreadValues(__spreadValues({}, this.connector.wallet), this.walletInfo);\n  }\n  /**\n   * Set and apply new UI options. Object with partial options should be passed. Passed options will be merged with current options.\n   * @param options\n   */\n  set uiOptions(options) {\n    var _a2, _b2, _c2, _d2, _e2;\n    this.checkButtonRootExist(options.buttonRootId);\n    this.actionsConfiguration = options.actionsConfiguration;\n    if (\"walletsRequiredFeatures\" in options) {\n      this._walletsRequiredFeatures = options.walletsRequiredFeatures;\n    }\n    if (\"walletsPreferredFeatures\" in options) {\n      this._walletsPreferredFeatures = options.walletsPreferredFeatures;\n    }\n    if ((_a2 = options.uiPreferences) == null ? void 0 : _a2.theme) {\n      if (((_b2 = options.uiPreferences) == null ? void 0 : _b2.theme) !== \"SYSTEM\") {\n        (_c2 = this.systemThemeChangeUnsubscribe) == null ? void 0 : _c2.call(this);\n        setTheme(options.uiPreferences.theme, options.uiPreferences.colorsSet);\n      } else {\n        setTheme(getSystemTheme(), options.uiPreferences.colorsSet);\n        if (!this.systemThemeChangeUnsubscribe) {\n          this.systemThemeChangeUnsubscribe = subscribeToThemeChange(setTheme);\n        }\n      }\n    } else {\n      if ((_d2 = options.uiPreferences) == null ? void 0 : _d2.colorsSet) {\n        setColors(options.uiPreferences.colorsSet);\n      }\n    }\n    if ((_e2 = options.uiPreferences) == null ? void 0 : _e2.borderRadius) {\n      setBorderRadius(options.uiPreferences.borderRadius);\n    }\n    setAppState((state) => {\n      var _a3, _b3;\n      const merged = mergeOptions(\n        __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, options.language && { language: options.language }), !!((_a3 = options.actionsConfiguration) == null ? void 0 : _a3.returnStrategy) && {\n          returnStrategy: options.actionsConfiguration.returnStrategy\n        }), !!((_b3 = options.actionsConfiguration) == null ? void 0 : _b3.twaReturnUrl) && {\n          twaReturnUrl: options.actionsConfiguration.twaReturnUrl\n        }), !!options.walletsListConfiguration && {\n          walletsListConfiguration: options.walletsListConfiguration\n        }),\n        unwrap(state)\n      );\n      if (options.buttonRootId !== void 0) {\n        merged.buttonRootId = options.buttonRootId;\n      }\n      if (options.enableAndroidBackHandler !== void 0) {\n        merged.enableAndroidBackHandler = options.enableAndroidBackHandler;\n      }\n      return merged;\n    });\n  }\n  /**\n   * Use it to customize ConnectRequest and add `tonProof` payload.\n   * You can call it multiply times to set updated tonProof payload if previous one is outdated.\n   * If `connectRequestParameters.state === 'loading'` loader will appear instead of the qr code in the wallets modal.\n   * If `connectRequestParameters.state` was changed to 'ready' or it's value has been changed, QR will be re-rendered.\n   */\n  setConnectRequestParameters(connectRequestParameters) {\n    var _a2;\n    setAppState({ connectRequestParameters });\n    if ((connectRequestParameters == null ? void 0 : connectRequestParameters.state) === \"ready\" || !connectRequestParameters) {\n      (_a2 = this.connectRequestParametersCallback) == null ? void 0 : _a2.call(this, connectRequestParameters == null ? void 0 : connectRequestParameters.value);\n    }\n  }\n  /**\n   * Set desired network for the connection. Can only be set before connecting.\n   * If wallet connects with a different chain, the SDK will throw an error and abort connection.\n   * @param network desired network id (e.g., '-239', '-3', or custom). Pass undefined to allow any network.\n   */\n  setConnectionNetwork(network) {\n    this.connector.setConnectionNetwork(network);\n  }\n  /**\n   * Returns available wallets list.\n   */\n  getWallets() {\n    return __async(this, null, function* () {\n      return this.connector.getWallets();\n    });\n  }\n  /**\n   * Subscribe to connection status change.\n   * @return function which has to be called to unsubscribe.\n   */\n  onStatusChange(callback, errorsHandler) {\n    return this.connector.onStatusChange((wallet) => __async(this, null, function* () {\n      if (wallet) {\n        const lastSelectedWalletInfo2 = yield this.getSelectedWalletInfo(wallet);\n        callback(__spreadValues(__spreadValues({}, wallet), lastSelectedWalletInfo2 || this.walletInfoStorage.getWalletInfo()));\n      } else {\n        callback(wallet);\n      }\n    }), errorsHandler);\n  }\n  /**\n   * Opens the modal window, returns a promise that resolves after the modal window is opened.\n   */\n  openModal(options) {\n    return __async(this, null, function* () {\n      var _a2;\n      const traceId = (_a2 = options == null ? void 0 : options.traceId) != null ? _a2 : (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.UUIDv7)();\n      yield this.modal.open({ traceId });\n      const sessionId = yield this.getSessionId();\n      const visibleWallets = widgetController.getLastVisibleWallets();\n      this.tracker.trackWalletModalOpened(\n        visibleWallets.wallets.map((wallet) => wallet.name),\n        sessionId,\n        options == null ? void 0 : options.traceId\n      );\n    });\n  }\n  /**\n   * Closes the modal window.\n   */\n  closeModal(reason) {\n    this.modal.close(reason);\n  }\n  /**\n   * Subscribe to the modal window state changes, returns a function which has to be called to unsubscribe.\n   */\n  onModalStateChange(onChange) {\n    return this.modal.onStateChange(onChange);\n  }\n  /**\n   * Returns current modal window state.\n   */\n  get modalState() {\n    return this.modal.state;\n  }\n  /**\n   * Opens the single wallet modal window, returns a promise that resolves after the modal window is opened.\n   * @experimental\n   */\n  openSingleWalletModal(wallet) {\n    return __async(this, null, function* () {\n      return this.singleWalletModal.open(wallet);\n    });\n  }\n  /**\n   * Close the single wallet modal window.\n   * @experimental\n   */\n  closeSingleWalletModal(closeReason) {\n    this.singleWalletModal.close(closeReason);\n  }\n  /**\n   * Subscribe to the single wallet modal window state changes, returns a function which has to be called to unsubscribe.\n   * @experimental\n   */\n  onSingleWalletModalStateChange(onChange) {\n    return this.singleWalletModal.onStateChange(onChange);\n  }\n  /**\n   * Returns current single wallet modal window state.\n   * @experimental\n   */\n  get singleWalletModalState() {\n    return this.singleWalletModal.state;\n  }\n  /**\n   * @deprecated Use `tonConnectUI.openModal()` instead. Will be removed in the next major version.\n   * Opens the modal window and handles a wallet connection.\n   * @return Connected wallet.\n   * @throws TonConnectUIError if connection was aborted.\n   */\n  connectWallet(options) {\n    return __async(this, null, function* () {\n      var _a2;\n      const traceId = (_a2 = options == null ? void 0 : options.traceId) != null ? _a2 : (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.UUIDv7)();\n      const walletsList = yield this.getWallets();\n      const embeddedWallet = walletsList.find(_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyEmbedded);\n      if (embeddedWallet) {\n        return yield this.connectEmbeddedWallet(embeddedWallet, { traceId });\n      } else {\n        return yield this.connectExternalWallet({ traceId });\n      }\n    });\n  }\n  /**\n   * Disconnect wallet and clean localstorage.\n   */\n  disconnect(options) {\n    var _a2;\n    const traceId = (_a2 = options == null ? void 0 : options.traceId) != null ? _a2 : (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.UUIDv7)();\n    this.tracker.trackDisconnection(this.wallet, \"dapp\");\n    widgetController.clearAction();\n    widgetController.removeSelectedWalletInfo();\n    this.walletInfoStorage.removeWalletInfo();\n    return this.connector.disconnect({ traceId });\n  }\n  /**\n   * Opens the modal window and handles the transaction sending.\n   * @param tx transaction to send.\n   * @param options modal and notifications behaviour settings. Default is show only 'before' modal and all notifications.\n   */\n  sendTransaction(tx, options) {\n    return __async(this, null, function* () {\n      var _a2;\n      const traceId = (_a2 = options == null ? void 0 : options.traceId) != null ? _a2 : (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.UUIDv7)();\n      this.tracker.trackTransactionSentForSignature(this.wallet, tx);\n      if (!this.connected) {\n        this.tracker.trackTransactionSigningFailed(this.wallet, tx, \"Wallet was not connected\");\n        throw new TonConnectUIError(\"Connect wallet to send a transaction.\");\n      }\n      if (isInTMA()) {\n        sendExpand();\n      }\n      const { notifications: notifications2, modals, returnStrategy, twaReturnUrl } = this.getModalsAndNotificationsConfiguration(options);\n      const sessionId = yield this.getSessionId();\n      widgetController.setAction({\n        name: \"confirm-transaction\",\n        showNotification: notifications2.includes(\"before\"),\n        openModal: modals.includes(\"before\"),\n        sent: false,\n        sessionId: sessionId || void 0,\n        traceId\n      });\n      const abortController = new AbortController();\n      const onRequestSent = () => {\n        var _a3;\n        if (abortController.signal.aborted) {\n          return;\n        }\n        widgetController.setAction({\n          name: \"confirm-transaction\",\n          showNotification: notifications2.includes(\"before\"),\n          openModal: modals.includes(\"before\"),\n          sent: true,\n          sessionId: sessionId || void 0,\n          traceId\n        });\n        this.redirectAfterRequestSent({\n          returnStrategy,\n          twaReturnUrl,\n          sessionId: sessionId || void 0,\n          traceId\n        });\n        let firstClick = true;\n        const redirectToWallet2 = () => __async(this, null, function* () {\n          if (abortController.signal.aborted) {\n            return;\n          }\n          const forceRedirect = !firstClick;\n          firstClick = false;\n          yield this.redirectAfterRequestSent({\n            returnStrategy,\n            twaReturnUrl,\n            forceRedirect,\n            sessionId: sessionId || void 0,\n            traceId\n          });\n        });\n        (_a3 = options == null ? void 0 : options.onRequestSent) == null ? void 0 : _a3.call(options, redirectToWallet2);\n      };\n      const unsubscribe = this.onTransactionModalStateChange((action2) => {\n        if (action2 == null ? void 0 : action2.openModal) {\n          return;\n        }\n        unsubscribe();\n        if (!action2) {\n          abortController.abort();\n        }\n      });\n      try {\n        const result = yield this.waitForSendTransaction(\n          {\n            transaction: tx,\n            signal: abortController.signal,\n            traceId\n          },\n          onRequestSent\n        );\n        this.tracker.trackTransactionSigned(this.wallet, tx, result);\n        widgetController.setAction({\n          name: \"transaction-sent\",\n          showNotification: notifications2.includes(\"success\"),\n          openModal: modals.includes(\"success\"),\n          traceId\n        });\n        return result;\n      } catch (e2) {\n        if (e2 instanceof _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletNotSupportFeatureError) {\n          widgetController.clearAction();\n          widgetController.openWalletNotSupportFeatureModal(e2.cause, { traceId });\n          throw e2;\n        }\n        widgetController.setAction({\n          name: \"transaction-canceled\",\n          showNotification: notifications2.includes(\"error\"),\n          openModal: modals.includes(\"error\"),\n          traceId\n        });\n        if (e2 instanceof _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnectError) {\n          throw e2;\n        } else {\n          console.error(e2);\n          throw new TonConnectUIError(\"Unhandled error:\" + e2);\n        }\n      } finally {\n        unsubscribe();\n      }\n    });\n  }\n  /**\n   * Signs the data and returns the signature.\n   * @param data data to sign.\n   */\n  signData(data, options) {\n    return __async(this, null, function* () {\n      var _a2;\n      const traceId = (_a2 = options == null ? void 0 : options.traceId) != null ? _a2 : (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.UUIDv7)();\n      this.tracker.trackDataSentForSignature(this.wallet, data);\n      if (!this.connected) {\n        this.tracker.trackDataSigningFailed(this.wallet, data, \"Wallet was not connected\");\n        throw new TonConnectUIError(\"Connect wallet to send a transaction.\");\n      }\n      if (isInTMA()) {\n        sendExpand();\n      }\n      const { notifications: notifications2, modals, returnStrategy, twaReturnUrl } = this.getModalsAndNotificationsConfiguration();\n      const sessionId = yield this.getSessionId();\n      widgetController.setAction({\n        name: \"confirm-sign-data\",\n        showNotification: notifications2.includes(\"before\"),\n        openModal: modals.includes(\"before\"),\n        signed: false,\n        sessionId: sessionId || void 0,\n        traceId\n      });\n      const abortController = new AbortController();\n      const onRequestSent = () => {\n        var _a3;\n        if (abortController.signal.aborted) {\n          return;\n        }\n        widgetController.setAction({\n          name: \"confirm-sign-data\",\n          showNotification: notifications2.includes(\"before\"),\n          openModal: modals.includes(\"before\"),\n          signed: true,\n          sessionId: sessionId || void 0,\n          traceId\n        });\n        this.redirectAfterRequestSent({\n          returnStrategy,\n          twaReturnUrl,\n          sessionId: sessionId || void 0,\n          traceId\n        });\n        let firstClick = true;\n        const redirectToWallet2 = () => {\n          if (abortController.signal.aborted) {\n            return;\n          }\n          const forceRedirect = !firstClick;\n          firstClick = false;\n          this.redirectAfterRequestSent({\n            returnStrategy,\n            twaReturnUrl,\n            forceRedirect,\n            sessionId: sessionId || void 0,\n            traceId\n          });\n        };\n        (_a3 = options == null ? void 0 : options.onRequestSent) == null ? void 0 : _a3.call(options, redirectToWallet2);\n      };\n      const unsubscribe = this.onTransactionModalStateChange((action2) => {\n        if (action2 == null ? void 0 : action2.openModal) {\n          return;\n        }\n        unsubscribe();\n        if (!action2) {\n          abortController.abort();\n        }\n      });\n      try {\n        const result = yield this.waitForSignData(\n          {\n            data,\n            signal: new AbortController().signal,\n            traceId\n          },\n          onRequestSent\n        );\n        this.tracker.trackDataSigned(this.wallet, data, result);\n        widgetController.setAction({\n          name: \"data-signed\",\n          showNotification: notifications2.includes(\"success\"),\n          openModal: modals.includes(\"success\"),\n          traceId\n        });\n        return result;\n      } catch (e2) {\n        if (e2 instanceof _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletNotSupportFeatureError) {\n          widgetController.clearAction();\n          widgetController.openWalletNotSupportFeatureModal(e2.cause, { traceId });\n          throw e2;\n        }\n        widgetController.setAction({\n          name: \"sign-data-canceled\",\n          showNotification: notifications2.includes(\"error\"),\n          openModal: modals.includes(\"error\"),\n          traceId\n        });\n        if (e2 instanceof _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnectError) {\n          throw e2;\n        } else {\n          console.error(e2);\n          throw new TonConnectUIError(\"Unhandled error:\" + e2);\n        }\n      } finally {\n        unsubscribe();\n      }\n    });\n  }\n  /**\n   * Gets the current session ID if available.\n   * @returns session ID string or null if not available.\n   */\n  getSessionId() {\n    return __async(this, null, function* () {\n      var _a2, _b2;\n      try {\n        const storage = (_a2 = this.connector.dappSettings) == null ? void 0 : _a2.storage;\n        if (storage) {\n          const stored = yield storage.getItem(\"ton-connect-storage_bridge-connection\");\n          if (stored) {\n            const connection = JSON.parse(stored);\n            if (connection.type === \"http\" && connection.sessionCrypto) {\n              const sessionCrypto = new _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.SessionCrypto(connection.sessionCrypto);\n              const sessionId = sessionCrypto.sessionId;\n              return sessionId;\n            } else if (connection.type === \"http\" && ((_b2 = connection.session) == null ? void 0 : _b2.sessionKeyPair)) {\n              const sessionCrypto = new _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.SessionCrypto(connection.session.sessionKeyPair);\n              const sessionId = sessionCrypto.sessionId;\n              return sessionId;\n            }\n          }\n        }\n      } catch (e2) {\n      }\n      return null;\n    });\n  }\n  redirectAfterRequestSent({\n    returnStrategy,\n    twaReturnUrl,\n    forceRedirect,\n    sessionId,\n    traceId\n  }) {\n    if (this.walletInfo && \"universalLink\" in this.walletInfo && (this.walletInfo.openMethod === \"universal-link\" || this.walletInfo.openMethod === \"custom-deeplink\")) {\n      const linkWithSessionId = enrichUniversalLink(this.walletInfo.universalLink, {\n        sessionId,\n        traceId\n      });\n      if ((0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isTelegramUrl)(this.walletInfo.universalLink)) {\n        redirectToTelegram(linkWithSessionId, {\n          returnStrategy,\n          twaReturnUrl: twaReturnUrl || appState.twaReturnUrl,\n          forceRedirect: forceRedirect || false\n        });\n      } else {\n        redirectToWallet(\n          linkWithSessionId,\n          this.walletInfo.deepLink,\n          {\n            returnStrategy,\n            forceRedirect: forceRedirect || false\n          },\n          () => {\n          }\n        );\n      }\n    }\n  }\n  /**\n   * TODO: remove in the next major version.\n   * Initiates a connection with an embedded wallet, awaits its completion, and returns the connected wallet information.\n   * @param embeddedWallet - Information about the embedded wallet to connect to.\n   * @throws Error if the connection process fails.\n   * @internal\n   */\n  connectEmbeddedWallet(embeddedWallet, options) {\n    return __async(this, null, function* () {\n      const connect = (parameters) => {\n        setLastSelectedWalletInfo(embeddedWallet);\n        this.connector.connect({ jsBridgeKey: embeddedWallet.jsBridgeKey }, parameters, {\n          traceId: options.traceId\n        });\n      };\n      const additionalRequest = appState.connectRequestParameters;\n      if ((additionalRequest == null ? void 0 : additionalRequest.state) === \"loading\") {\n        this.connectRequestParametersCallback = connect;\n      } else {\n        connect(additionalRequest == null ? void 0 : additionalRequest.value);\n      }\n      return yield this.waitForWalletConnection({\n        ignoreErrors: false,\n        traceId: options.traceId\n      });\n    });\n  }\n  /**\n   * TODO: remove in the next major version.\n   * Initiates the connection process for an external wallet by opening the wallet modal\n   * and returns the connected wallet information upon successful connection.\n   * @throws Error if the user cancels the connection process or if the connection process fails.\n   * @internal\n   */\n  connectExternalWallet(options) {\n    return __async(this, null, function* () {\n      const abortController = new AbortController();\n      widgetController.openWalletsModal({ traceId: options.traceId });\n      const unsubscribe = this.onModalStateChange((state) => {\n        const { status, closeReason } = state;\n        if (status === \"opened\") {\n          return;\n        }\n        unsubscribe();\n        if (closeReason === \"action-cancelled\") {\n          abortController.abort();\n        }\n      });\n      return yield this.waitForWalletConnection({\n        ignoreErrors: true,\n        signal: abortController.signal,\n        traceId: options.traceId\n      });\n    });\n  }\n  /**\n   * TODO: remove in the next major version.\n   * Waits for a wallet connection based on provided options, returning connected wallet information.\n   * @param options - Configuration for connection statuses and errors handling.\n   * @options.ignoreErrors - If true, ignores errors during waiting, waiting continues until a valid wallet connects. Default is false.\n   * @options.abortSignal - Optional AbortSignal for external cancellation. Throws TonConnectUIError if aborted.\n   * @throws TonConnectUIError if waiting is aborted or no valid wallet connection is received and ignoreErrors is false.\n   * @internal\n   */\n  waitForWalletConnection(options) {\n    return __async(this, null, function* () {\n      return new Promise((resolve, reject) => {\n        this.tracker.trackConnectionStarted();\n        const { ignoreErrors = false, signal = null } = options;\n        if (signal && signal.aborted) {\n          this.tracker.trackConnectionError(\"Connection was cancelled\");\n          return reject(new TonConnectUIError(\"Wallet was not connected\"));\n        }\n        const onStatusChangeHandler = (wallet) => __async(this, null, function* () {\n          if (!wallet) {\n            this.tracker.trackConnectionError(\"Connection was cancelled\");\n            if (ignoreErrors) {\n              return;\n            }\n            unsubscribe();\n            reject(new TonConnectUIError(\"Wallet was not connected\"));\n          } else {\n            this.tracker.trackConnectionCompleted(wallet);\n            unsubscribe();\n            resolve(wallet);\n          }\n        });\n        const onErrorsHandler = (reason) => {\n          this.tracker.trackConnectionError(reason.message);\n          if (ignoreErrors) {\n            return;\n          }\n          unsubscribe();\n          reject(reason);\n        };\n        const unsubscribe = this.onStatusChange(\n          (wallet) => onStatusChangeHandler(wallet),\n          (reason) => onErrorsHandler(reason)\n        );\n        if (signal) {\n          signal.addEventListener(\n            \"abort\",\n            () => {\n              unsubscribe();\n              reject(new TonConnectUIError(\"Wallet was not connected\"));\n            },\n            { once: true }\n          );\n        }\n      });\n    });\n  }\n  /**\n   * Waits for a transaction to be sent based on provided options, returning the transaction response.\n   * @param options - Configuration for transaction statuses and errors handling.\n   * @options.transaction - Transaction to send.\n   * @options.ignoreErrors - If true, ignores errors during waiting, waiting continues until a valid transaction is sent. Default is false.\n   * @options.abortSignal - Optional AbortSignal for external cancellation. Throws TonConnectUIError if aborted.\n   * @param onRequestSent (optional) will be called after the transaction is sent to the wallet.\n   * @throws TonConnectUIError if waiting is aborted or no valid transaction response is received and ignoreErrors is false.\n   * @internal\n   */\n  waitForSendTransaction(options, onRequestSent) {\n    return __async(this, null, function* () {\n      return new Promise((resolve, reject) => {\n        const { transaction, signal } = options;\n        if (signal.aborted) {\n          this.tracker.trackTransactionSigningFailed(\n            this.wallet,\n            transaction,\n            \"Transaction was cancelled\"\n          );\n          return reject(new TonConnectUIError(\"Transaction was not sent\"));\n        }\n        const onTransactionHandler = (transaction2) => __async(this, null, function* () {\n          resolve(transaction2);\n        });\n        const onErrorsHandler = (reason) => {\n          reject(reason);\n        };\n        const onCanceledHandler = () => {\n          this.tracker.trackTransactionSigningFailed(\n            this.wallet,\n            transaction,\n            \"Transaction was cancelled\"\n          );\n          reject(new TonConnectUIError(\"Transaction was not sent\"));\n        };\n        signal.addEventListener(\"abort\", onCanceledHandler, { once: true });\n        this.connector.sendTransaction(transaction, {\n          onRequestSent,\n          signal,\n          traceId: options.traceId\n        }).then((result) => {\n          signal.removeEventListener(\"abort\", onCanceledHandler);\n          return onTransactionHandler(result);\n        }).catch((reason) => {\n          signal.removeEventListener(\"abort\", onCanceledHandler);\n          return onErrorsHandler(reason);\n        });\n      });\n    });\n  }\n  /**\n   * Waits for a transaction to be sent based on provided options, returning the transaction response.\n   * @param options - Configuration for transaction statuses and errors handling.\n   * @options.transaction - Transaction to send.\n   * @options.ignoreErrors - If true, ignores errors during waiting, waiting continues until a valid transaction is sent. Default is false.\n   * @options.abortSignal - Optional AbortSignal for external cancellation. Throws TonConnectUIError if aborted.\n   * @param onRequestSent (optional) will be called after the transaction is sent to the wallet.\n   * @throws TonConnectUIError if waiting is aborted or no valid transaction response is received and ignoreErrors is false.\n   * @internal\n   */\n  waitForSignData(options, onRequestSent) {\n    return __async(this, null, function* () {\n      return new Promise((resolve, reject) => {\n        const { data, signal } = options;\n        if (signal.aborted) {\n          this.tracker.trackDataSigningFailed(this.wallet, data, \"SignData was cancelled\");\n          return reject(new TonConnectUIError(\"SignData was not sent\"));\n        }\n        const onSignHandler = (data2) => __async(this, null, function* () {\n          resolve(data2);\n        });\n        const onErrorsHandler = (reason) => {\n          reject(reason);\n        };\n        const onCanceledHandler = () => {\n          this.tracker.trackDataSigningFailed(this.wallet, data, \"SignData was cancelled\");\n          reject(new TonConnectUIError(\"SignData was not sent\"));\n        };\n        signal.addEventListener(\"abort\", onCanceledHandler, { once: true });\n        this.connector.signData(data, { onRequestSent, signal }).then((result) => {\n          return onSignHandler(result);\n        }).catch((reason) => {\n          return onErrorsHandler(reason);\n        });\n      });\n    });\n  }\n  /**\n   * Subscribe to the transaction modal window state changes, returns a function which has to be called to unsubscribe.\n   * @internal\n   */\n  onTransactionModalStateChange(onChange) {\n    return this.transactionModal.onStateChange(onChange);\n  }\n  subscribeToWalletChange() {\n    this.connector.onStatusChange((wallet) => __async(this, null, function* () {\n      var _a2;\n      if (wallet) {\n        yield this.updateWalletInfo(wallet);\n        this.setPreferredWalletAppName(((_a2 = this.walletInfo) == null ? void 0 : _a2.appName) || wallet.device.appName);\n      } else {\n        this.walletInfoStorage.removeWalletInfo();\n      }\n    }));\n  }\n  setPreferredWalletAppName(value) {\n    this.preferredWalletStorage.setPreferredWalletAppName(value);\n    setAppState({ preferredWalletAppName: value });\n  }\n  getSelectedWalletInfo(wallet) {\n    return __async(this, null, function* () {\n      let lastSelectedWalletInfo2 = widgetController.getSelectedWalletInfo();\n      if (!lastSelectedWalletInfo2) {\n        return null;\n      }\n      if (!(\"name\" in lastSelectedWalletInfo2)) {\n        if (wallet.device.appName === WALLET_CONNECT_APP_NAME) {\n          return {\n            type: \"wallet-connect\",\n            name: WALLET_CONNECT_WALLET_NAME,\n            appName: WALLET_CONNECT_APP_NAME,\n            imageUrl: IMG.WALLET_CONNECT,\n            aboutUrl: WALLET_CONNECT_ABOUT_URL,\n            features: wallet.device.features,\n            platforms: []\n          };\n        }\n        const walletsList = applyWalletsListConfiguration(\n          yield this.walletsList,\n          appState.walletsListConfiguration\n        );\n        const walletInfo = walletsList.find((item) => eqWalletName(item, wallet.device.appName));\n        if (!walletInfo) {\n          throw new TonConnectUIError(\n            `Cannot find WalletInfo for the '${wallet.device.appName}' wallet`\n          );\n        }\n        return __spreadValues(__spreadValues({}, walletInfo), lastSelectedWalletInfo2);\n      }\n      return lastSelectedWalletInfo2;\n    });\n  }\n  updateWalletInfo(wallet) {\n    return __async(this, null, function* () {\n      const selectedWalletInfo = yield this.getSelectedWalletInfo(wallet);\n      if (selectedWalletInfo) {\n        this.walletInfo = selectedWalletInfo;\n        this.walletInfoStorage.setWalletInfo(selectedWalletInfo);\n        return;\n      }\n      const storedWalletInfo = this.walletInfoStorage.getWalletInfo();\n      if (storedWalletInfo) {\n        this.walletInfo = storedWalletInfo;\n        return;\n      }\n      this.walletInfo = (yield this.walletsList).find(\n        (walletInfo) => eqWalletName(walletInfo, wallet.device.appName)\n      ) || null;\n    });\n  }\n  normalizeWidgetRoot(rootId) {\n    if (!rootId || !document.getElementById(rootId)) {\n      rootId = \"tc-widget-root\";\n      const rootElement = document.createElement(\"div\");\n      rootElement.id = rootId;\n      document.body.appendChild(rootElement);\n    }\n    return rootId;\n  }\n  checkButtonRootExist(buttonRootId) {\n    if (buttonRootId == null) {\n      return;\n    }\n    if (!document.getElementById(buttonRootId)) {\n      throw new TonConnectUIError(`${buttonRootId} element not found in the document.`);\n    }\n  }\n  // eslint-disable-next-line complexity\n  getModalsAndNotificationsConfiguration(options) {\n    var _a2, _b2, _c2, _d2, _e2, _f2;\n    const allActions = [\n      \"before\",\n      \"success\",\n      \"error\"\n    ];\n    let notifications2 = allActions;\n    if (((_a2 = this.actionsConfiguration) == null ? void 0 : _a2.notifications) && ((_b2 = this.actionsConfiguration) == null ? void 0 : _b2.notifications) !== \"all\") {\n      notifications2 = this.actionsConfiguration.notifications;\n    }\n    if (options == null ? void 0 : options.notifications) {\n      if (options.notifications === \"all\") {\n        notifications2 = allActions;\n      } else {\n        notifications2 = options.notifications;\n      }\n    }\n    let modals = [\"before\"];\n    if ((_c2 = this.actionsConfiguration) == null ? void 0 : _c2.modals) {\n      if (this.actionsConfiguration.modals === \"all\") {\n        modals = allActions;\n      } else {\n        modals = this.actionsConfiguration.modals;\n      }\n    }\n    if (options == null ? void 0 : options.modals) {\n      if (options.modals === \"all\") {\n        modals = allActions;\n      } else {\n        modals = options.modals;\n      }\n    }\n    const returnStrategy = (options == null ? void 0 : options.returnStrategy) || ((_d2 = this.actionsConfiguration) == null ? void 0 : _d2.returnStrategy) || \"back\";\n    const twaReturnUrl = (options == null ? void 0 : options.twaReturnUrl) || ((_e2 = this.actionsConfiguration) == null ? void 0 : _e2.twaReturnUrl);\n    let skipRedirectToWallet = (options == null ? void 0 : options.skipRedirectToWallet) || ((_f2 = this.actionsConfiguration) == null ? void 0 : _f2.skipRedirectToWallet) || \"ios\";\n    if (isInTMA()) {\n      skipRedirectToWallet = \"never\";\n    }\n    return {\n      notifications: notifications2,\n      modals,\n      returnStrategy,\n      twaReturnUrl,\n      skipRedirectToWallet\n    };\n  }\n}\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvbmNvbm5lY3QvdWkvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDcS9CO0FBQ3I5QjtBQUNJO0FBQ0Y7QUFDTjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0QkFBNEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaURBQWlEO0FBQ3RHLGlEQUFpRCxvRUFBb0U7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsS0FBSztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7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REFBdUQ7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUNBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNDQUFTO0FBQ2xCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0I7QUFDeEIscUJBQXFCOztBQUVyQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsVUFBVTtBQUNWO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUFFO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQkFBaUIsdUNBQUU7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlCQUFpQix1Q0FBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0RBQWtEO0FBQ2xELEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFVBQVUsa0NBQWtDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrREFBa0Q7QUFDbEQsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixhQUFhO0FBQ2Isa0JBQWtCLHlCQUF5Qiw4Q0FBOEM7QUFDekY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QixhQUFhO0FBQ2Isa0JBQWtCLHlCQUF5Qiw4Q0FBOEM7O0FBRXpGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZCQUE2QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCw4Q0FBOEM7QUFDOUMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FB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Q047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0Es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O0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNB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QUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMEVBQTZCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELCtEQUFrQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLE9BQU87QUFDL0U7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5Q0FBeUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0VBQWlCO0FBQzVCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBS0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3RtYS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdG9uY29ubmVjdC91aS9saWIvaW5kZXgubWpzP2ZkZDQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYTIsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhMiwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYTIsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGEyO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEyLCBiKSA9PiBfX2RlZlByb3BzKGEyLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG52YXIgX19vYmpSZXN0ID0gKHNvdXJjZSwgZXhjbHVkZSkgPT4ge1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIGZvciAodmFyIHByb3AgaW4gc291cmNlKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChzb3VyY2UsIHByb3ApICYmIGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDApXG4gICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhzb3VyY2UpKSB7XG4gICAgICBpZiAoZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMCAmJiBfX3Byb3BJc0VudW0uY2FsbChzb3VyY2UsIHByb3ApKVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX2FzeW5jID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBmdWxmaWxsZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIHJlamVjdChlMik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVqZWN0ZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLnRocm93KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICByZWplY3QoZTIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xudmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbmltcG9ydCB7IFRvbkNvbm5lY3RFcnJvciwgaXNXYWxsZXRJbmZvQ3VycmVudGx5SW5qZWN0ZWQsIHRvVXNlckZyaWVuZGx5QWRkcmVzcywgQ0hBSU4sIFRvbkNvbm5lY3QsIGlzV2FsbGV0Q29ubmVjdEluaXRpYWxpemVkLCBpc1RlbGVncmFtVXJsLCBkZWNvZGVUZWxlZ3JhbVVybFBhcmFtZXRlcnMsIGVuY29kZVRlbGVncmFtVXJsUGFyYW1ldGVycywgV2FsbGV0TWlzc2luZ1JlcXVpcmVkRmVhdHVyZXNFcnJvciwgV2FsbGV0V3JvbmdOZXR3b3JrRXJyb3IsIGlzV2FsbGV0SW5mb1JlbW90ZSwgY2hlY2tSZXF1aXJlZFdhbGxldEZlYXR1cmVzLCBpc0Nvbm5lY3RVcmwsIFVVSUR2NywgaXNXYWxsZXRJbmZvQ3VycmVudGx5RW1iZWRkZWQsIGNyZWF0ZVZlcnNpb25JbmZvLCBjcmVhdGVSZXNwb25zZVZlcnNpb25FdmVudCwgY3JlYXRlUmVxdWVzdFZlcnNpb25FdmVudCwgY3JlYXRlV2FsbGV0TW9kYWxPcGVuZWRFdmVudCwgY3JlYXRlU2VsZWN0ZWRXYWxsZXRFdmVudCwgY3JlYXRlQ29ubmVjdGlvblN0YXJ0ZWRFdmVudCwgY3JlYXRlQ29ubmVjdGlvbkNvbXBsZXRlZEV2ZW50LCBjcmVhdGVDb25uZWN0aW9uRXJyb3JFdmVudCwgY3JlYXRlQ29ubmVjdGlvblJlc3RvcmluZ1N0YXJ0ZWRFdmVudCwgY3JlYXRlQ29ubmVjdGlvblJlc3RvcmluZ0NvbXBsZXRlZEV2ZW50LCBjcmVhdGVDb25uZWN0aW9uUmVzdG9yaW5nRXJyb3JFdmVudCwgY3JlYXRlRGlzY29ubmVjdGlvbkV2ZW50LCBjcmVhdGVUcmFuc2FjdGlvblNlbnRGb3JTaWduYXR1cmVFdmVudCwgY3JlYXRlVHJhbnNhY3Rpb25TaWduZWRFdmVudCwgY3JlYXRlVHJhbnNhY3Rpb25TaWduaW5nRmFpbGVkRXZlbnQsIGNyZWF0ZURhdGFTZW50Rm9yU2lnbmF0dXJlRXZlbnQsIGNyZWF0ZURhdGFTaWduZWRFdmVudCwgY3JlYXRlRGF0YVNpZ25pbmdGYWlsZWRFdmVudCwgQnJvd3NlckV2ZW50RGlzcGF0Y2hlciwgV2FsbGV0Tm90U3VwcG9ydEZlYXR1cmVFcnJvciwgU2Vzc2lvbkNyeXB0byB9IGZyb20gXCJAdG9uY29ubmVjdC9zZGtcIjtcbmV4cG9ydCAqIGZyb20gXCJAdG9uY29ubmVjdC9zZGtcIjtcbmltcG9ydCBVQVBhcnNlciBmcm9tIFwidWEtcGFyc2VyLWpzXCI7XG5pbXBvcnQgZGVlcG1lcmdlIGZyb20gXCJkZWVwbWVyZ2VcIjtcbmltcG9ydCBjbiBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuY29uc3QgSVNfREVWID0gZmFsc2U7XG5jb25zdCBlcXVhbEZuID0gKGEyLCBiKSA9PiBhMiA9PT0gYjtcbmNvbnN0ICRQUk9YWSA9IFN5bWJvbChcInNvbGlkLXByb3h5XCIpO1xuY29uc3QgU1VQUE9SVFNfUFJPWFkgPSB0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0ICRUUkFDSyA9IFN5bWJvbChcInNvbGlkLXRyYWNrXCIpO1xuY29uc3Qgc2lnbmFsT3B0aW9ucyA9IHtcbiAgZXF1YWxzOiBlcXVhbEZuXG59O1xubGV0IHJ1bkVmZmVjdHMgPSBydW5RdWV1ZTtcbmNvbnN0IFNUQUxFID0gMTtcbmNvbnN0IFBFTkRJTkcgPSAyO1xuY29uc3QgVU5PV05FRCA9IHtcbiAgb3duZWQ6IG51bGwsXG4gIGNsZWFudXBzOiBudWxsLFxuICBjb250ZXh0OiBudWxsLFxuICBvd25lcjogbnVsbFxufTtcbmNvbnN0IE5PX0lOSVQgPSB7fTtcbnZhciBPd25lciA9IG51bGw7XG5sZXQgVHJhbnNpdGlvbiQxID0gbnVsbDtcbmxldCBFeHRlcm5hbFNvdXJjZUNvbmZpZyA9IG51bGw7XG5sZXQgTGlzdGVuZXIgPSBudWxsO1xubGV0IFVwZGF0ZXMgPSBudWxsO1xubGV0IEVmZmVjdHMgPSBudWxsO1xubGV0IEV4ZWNDb3VudCA9IDA7XG5mdW5jdGlvbiBjcmVhdGVSb290KGZuLCBkZXRhY2hlZE93bmVyKSB7XG4gIGNvbnN0IGxpc3RlbmVyID0gTGlzdGVuZXIsIG93bmVyID0gT3duZXIsIHVub3duZWQgPSBmbi5sZW5ndGggPT09IDAsIGN1cnJlbnQgPSBkZXRhY2hlZE93bmVyID09PSB2b2lkIDAgPyBvd25lciA6IGRldGFjaGVkT3duZXIsIHJvb3QgPSB1bm93bmVkID8gVU5PV05FRCA6IHtcbiAgICBvd25lZDogbnVsbCxcbiAgICBjbGVhbnVwczogbnVsbCxcbiAgICBjb250ZXh0OiBjdXJyZW50ID8gY3VycmVudC5jb250ZXh0IDogbnVsbCxcbiAgICBvd25lcjogY3VycmVudFxuICB9LCB1cGRhdGVGbiA9IHVub3duZWQgPyBmbiA6ICgpID0+IGZuKCgpID0+IHVudHJhY2soKCkgPT4gY2xlYW5Ob2RlKHJvb3QpKSk7XG4gIE93bmVyID0gcm9vdDtcbiAgTGlzdGVuZXIgPSBudWxsO1xuICB0cnkge1xuICAgIHJldHVybiBydW5VcGRhdGVzKHVwZGF0ZUZuLCB0cnVlKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgIE93bmVyID0gb3duZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVNpZ25hbCh2YWx1ZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oe30sIHNpZ25hbE9wdGlvbnMsIG9wdGlvbnMpIDogc2lnbmFsT3B0aW9ucztcbiAgY29uc3QgczIgPSB7XG4gICAgdmFsdWUsXG4gICAgb2JzZXJ2ZXJzOiBudWxsLFxuICAgIG9ic2VydmVyU2xvdHM6IG51bGwsXG4gICAgY29tcGFyYXRvcjogb3B0aW9ucy5lcXVhbHMgfHwgdm9pZCAwXG4gIH07XG4gIGNvbnN0IHNldHRlciA9ICh2YWx1ZTIpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB2YWx1ZTIgPSB2YWx1ZTIoczIudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gd3JpdGVTaWduYWwoczIsIHZhbHVlMik7XG4gIH07XG4gIHJldHVybiBbcmVhZFNpZ25hbC5iaW5kKHMyKSwgc2V0dGVyXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkKGZuLCB2YWx1ZSwgb3B0aW9ucykge1xuICBjb25zdCBjMiA9IGNyZWF0ZUNvbXB1dGF0aW9uKGZuLCB2YWx1ZSwgdHJ1ZSwgU1RBTEUpO1xuICB1cGRhdGVDb21wdXRhdGlvbihjMik7XG59XG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJFZmZlY3QoZm4sIHZhbHVlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGMyID0gY3JlYXRlQ29tcHV0YXRpb24oZm4sIHZhbHVlLCBmYWxzZSwgU1RBTEUpO1xuICB1cGRhdGVDb21wdXRhdGlvbihjMik7XG59XG5mdW5jdGlvbiBjcmVhdGVFZmZlY3QoZm4sIHZhbHVlLCBvcHRpb25zKSB7XG4gIHJ1bkVmZmVjdHMgPSBydW5Vc2VyRWZmZWN0cztcbiAgY29uc3QgYzIgPSBjcmVhdGVDb21wdXRhdGlvbihmbiwgdmFsdWUsIGZhbHNlLCBTVEFMRSk7XG4gIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5yZW5kZXIpIGMyLnVzZXIgPSB0cnVlO1xuICBFZmZlY3RzID8gRWZmZWN0cy5wdXNoKGMyKSA6IHVwZGF0ZUNvbXB1dGF0aW9uKGMyKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1lbW8oZm4sIHZhbHVlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zID8gT2JqZWN0LmFzc2lnbih7fSwgc2lnbmFsT3B0aW9ucywgb3B0aW9ucykgOiBzaWduYWxPcHRpb25zO1xuICBjb25zdCBjMiA9IGNyZWF0ZUNvbXB1dGF0aW9uKGZuLCB2YWx1ZSwgdHJ1ZSwgMCk7XG4gIGMyLm9ic2VydmVycyA9IG51bGw7XG4gIGMyLm9ic2VydmVyU2xvdHMgPSBudWxsO1xuICBjMi5jb21wYXJhdG9yID0gb3B0aW9ucy5lcXVhbHMgfHwgdm9pZCAwO1xuICB1cGRhdGVDb21wdXRhdGlvbihjMik7XG4gIHJldHVybiByZWFkU2lnbmFsLmJpbmQoYzIpO1xufVxuZnVuY3Rpb24gaXNQcm9taXNlKHYpIHtcbiAgcmV0dXJuIHYgJiYgdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgXCJ0aGVuXCIgaW4gdjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlc291cmNlKHBTb3VyY2UsIHBGZXRjaGVyLCBwT3B0aW9ucykge1xuICBsZXQgc291cmNlO1xuICBsZXQgZmV0Y2hlcjtcbiAgbGV0IG9wdGlvbnM7XG4gIHtcbiAgICBzb3VyY2UgPSB0cnVlO1xuICAgIGZldGNoZXIgPSBwU291cmNlO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBsZXQgcHIgPSBudWxsLCBpbml0UCA9IE5PX0lOSVQsIHNjaGVkdWxlZCA9IGZhbHNlLCByZXNvbHZlZCA9IFwiaW5pdGlhbFZhbHVlXCIgaW4gb3B0aW9ucywgZHluYW1pYyA9IHR5cGVvZiBzb3VyY2UgPT09IFwiZnVuY3Rpb25cIiAmJiBjcmVhdGVNZW1vKHNvdXJjZSk7XG4gIGNvbnN0IGNvbnRleHRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgW3ZhbHVlLCBzZXRWYWx1ZV0gPSAob3B0aW9ucy5zdG9yYWdlIHx8IGNyZWF0ZVNpZ25hbCkob3B0aW9ucy5pbml0aWFsVmFsdWUpLCBbZXJyb3IsIHNldEVycm9yXSA9IGNyZWF0ZVNpZ25hbCh2b2lkIDApLCBbdHJhY2ssIHRyaWdnZXJdID0gY3JlYXRlU2lnbmFsKHZvaWQgMCwge1xuICAgIGVxdWFsczogZmFsc2VcbiAgfSksIFtzdGF0ZSwgc2V0U3RhdGVdID0gY3JlYXRlU2lnbmFsKHJlc29sdmVkID8gXCJyZWFkeVwiIDogXCJ1bnJlc29sdmVkXCIpO1xuICBmdW5jdGlvbiBsb2FkRW5kKHAyLCB2LCBlcnJvcjIsIGtleSkge1xuICAgIGlmIChwciA9PT0gcDIpIHtcbiAgICAgIHByID0gbnVsbDtcbiAgICAgIGtleSAhPT0gdm9pZCAwICYmIChyZXNvbHZlZCA9IHRydWUpO1xuICAgICAgaWYgKChwMiA9PT0gaW5pdFAgfHwgdiA9PT0gaW5pdFApICYmIG9wdGlvbnMub25IeWRyYXRlZCkgcXVldWVNaWNyb3Rhc2soKCkgPT4gb3B0aW9ucy5vbkh5ZHJhdGVkKGtleSwge1xuICAgICAgICB2YWx1ZTogdlxuICAgICAgfSkpO1xuICAgICAgaW5pdFAgPSBOT19JTklUO1xuICAgICAgY29tcGxldGVMb2FkKHYsIGVycm9yMik7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG4gIGZ1bmN0aW9uIGNvbXBsZXRlTG9hZCh2LCBlcnIpIHtcbiAgICBydW5VcGRhdGVzKCgpID0+IHtcbiAgICAgIGlmIChlcnIgPT09IHZvaWQgMCkgc2V0VmFsdWUoKCkgPT4gdik7XG4gICAgICBzZXRTdGF0ZShlcnIgIT09IHZvaWQgMCA/IFwiZXJyb3JlZFwiIDogcmVzb2x2ZWQgPyBcInJlYWR5XCIgOiBcInVucmVzb2x2ZWRcIik7XG4gICAgICBzZXRFcnJvcihlcnIpO1xuICAgICAgZm9yIChjb25zdCBjMiBvZiBjb250ZXh0cy5rZXlzKCkpIGMyLmRlY3JlbWVudCgpO1xuICAgICAgY29udGV4dHMuY2xlYXIoKTtcbiAgICB9LCBmYWxzZSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICBjb25zdCBjMiA9IFN1c3BlbnNlQ29udGV4dCwgdiA9IHZhbHVlKCksIGVyciA9IGVycm9yKCk7XG4gICAgaWYgKGVyciAhPT0gdm9pZCAwICYmICFwcikgdGhyb3cgZXJyO1xuICAgIGlmIChMaXN0ZW5lciAmJiAhTGlzdGVuZXIudXNlciAmJiBjMikgO1xuICAgIHJldHVybiB2O1xuICB9XG4gIGZ1bmN0aW9uIGxvYWQocmVmZXRjaGluZyA9IHRydWUpIHtcbiAgICBpZiAocmVmZXRjaGluZyAhPT0gZmFsc2UgJiYgc2NoZWR1bGVkKSByZXR1cm47XG4gICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgY29uc3QgbG9va3VwID0gZHluYW1pYyA/IGR5bmFtaWMoKSA6IHNvdXJjZTtcbiAgICBpZiAobG9va3VwID09IG51bGwgfHwgbG9va3VwID09PSBmYWxzZSkge1xuICAgICAgbG9hZEVuZChwciwgdW50cmFjayh2YWx1ZSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZXJyb3IyO1xuICAgIGNvbnN0IHAyID0gaW5pdFAgIT09IE5PX0lOSVQgPyBpbml0UCA6IHVudHJhY2soKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZldGNoZXIobG9va3VwLCB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlKCksXG4gICAgICAgICAgcmVmZXRjaGluZ1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGZldGNoZXJFcnJvcikge1xuICAgICAgICBlcnJvcjIgPSBmZXRjaGVyRXJyb3I7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGVycm9yMiAhPT0gdm9pZCAwKSB7XG4gICAgICBsb2FkRW5kKHByLCB2b2lkIDAsIGNhc3RFcnJvcihlcnJvcjIpLCBsb29rdXApO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoIWlzUHJvbWlzZShwMikpIHtcbiAgICAgIGxvYWRFbmQocHIsIHAyLCB2b2lkIDAsIGxvb2t1cCk7XG4gICAgICByZXR1cm4gcDI7XG4gICAgfVxuICAgIHByID0gcDI7XG4gICAgaWYgKFwidlwiIGluIHAyKSB7XG4gICAgICBpZiAocDIucyA9PT0gMSkgbG9hZEVuZChwciwgcDIudiwgdm9pZCAwLCBsb29rdXApO1xuICAgICAgZWxzZSBsb2FkRW5kKHByLCB2b2lkIDAsIGNhc3RFcnJvcihwMi52KSwgbG9va3VwKTtcbiAgICAgIHJldHVybiBwMjtcbiAgICB9XG4gICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBzY2hlZHVsZWQgPSBmYWxzZSk7XG4gICAgcnVuVXBkYXRlcygoKSA9PiB7XG4gICAgICBzZXRTdGF0ZShyZXNvbHZlZCA/IFwicmVmcmVzaGluZ1wiIDogXCJwZW5kaW5nXCIpO1xuICAgICAgdHJpZ2dlcigpO1xuICAgIH0sIGZhbHNlKTtcbiAgICByZXR1cm4gcDIudGhlbigodikgPT4gbG9hZEVuZChwMiwgdiwgdm9pZCAwLCBsb29rdXApLCAoZTIpID0+IGxvYWRFbmQocDIsIHZvaWQgMCwgY2FzdEVycm9yKGUyKSwgbG9va3VwKSk7XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocmVhZCwge1xuICAgIHN0YXRlOiB7XG4gICAgICBnZXQ6ICgpID0+IHN0YXRlKClcbiAgICB9LFxuICAgIGVycm9yOiB7XG4gICAgICBnZXQ6ICgpID0+IGVycm9yKClcbiAgICB9LFxuICAgIGxvYWRpbmc6IHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgczIgPSBzdGF0ZSgpO1xuICAgICAgICByZXR1cm4gczIgPT09IFwicGVuZGluZ1wiIHx8IHMyID09PSBcInJlZnJlc2hpbmdcIjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxhdGVzdDoge1xuICAgICAgZ2V0KCkge1xuICAgICAgICBpZiAoIXJlc29sdmVkKSByZXR1cm4gcmVhZCgpO1xuICAgICAgICBjb25zdCBlcnIgPSBlcnJvcigpO1xuICAgICAgICBpZiAoZXJyICYmICFwcikgdGhyb3cgZXJyO1xuICAgICAgICByZXR1cm4gdmFsdWUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBsZXQgb3duZXIgPSBPd25lcjtcbiAgaWYgKGR5bmFtaWMpIGNyZWF0ZUNvbXB1dGVkKCgpID0+IChvd25lciA9IE93bmVyLCBsb2FkKGZhbHNlKSkpO1xuICBlbHNlIGxvYWQoZmFsc2UpO1xuICByZXR1cm4gW3JlYWQsIHtcbiAgICByZWZldGNoOiAoaW5mbykgPT4gcnVuV2l0aE93bmVyKG93bmVyLCAoKSA9PiBsb2FkKGluZm8pKSxcbiAgICBtdXRhdGU6IHNldFZhbHVlXG4gIH1dO1xufVxuZnVuY3Rpb24gYmF0Y2goZm4pIHtcbiAgcmV0dXJuIHJ1blVwZGF0ZXMoZm4sIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHVudHJhY2soZm4pIHtcbiAgaWYgKExpc3RlbmVyID09PSBudWxsKSByZXR1cm4gZm4oKTtcbiAgY29uc3QgbGlzdGVuZXIgPSBMaXN0ZW5lcjtcbiAgTGlzdGVuZXIgPSBudWxsO1xuICB0cnkge1xuICAgIGlmIChFeHRlcm5hbFNvdXJjZUNvbmZpZykgO1xuICAgIHJldHVybiBmbigpO1xuICB9IGZpbmFsbHkge1xuICAgIExpc3RlbmVyID0gbGlzdGVuZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIG9uKGRlcHMsIGZuLCBvcHRpb25zKSB7XG4gIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGRlcHMpO1xuICBsZXQgcHJldklucHV0O1xuICByZXR1cm4gKHByZXZWYWx1ZSkgPT4ge1xuICAgIGxldCBpbnB1dDtcbiAgICBpZiAoaXNBcnJheSkge1xuICAgICAgaW5wdXQgPSBBcnJheShkZXBzLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgZGVwcy5sZW5ndGg7IGkyKyspIGlucHV0W2kyXSA9IGRlcHNbaTJdKCk7XG4gICAgfSBlbHNlIGlucHV0ID0gZGVwcygpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHVudHJhY2soKCkgPT4gZm4oaW5wdXQsIHByZXZJbnB1dCwgcHJldlZhbHVlKSk7XG4gICAgcHJldklucHV0ID0gaW5wdXQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cbmZ1bmN0aW9uIG9uTW91bnQoZm4pIHtcbiAgY3JlYXRlRWZmZWN0KCgpID0+IHVudHJhY2soZm4pKTtcbn1cbmZ1bmN0aW9uIG9uQ2xlYW51cChmbikge1xuICBpZiAoT3duZXIgPT09IG51bGwpIDtcbiAgZWxzZSBpZiAoT3duZXIuY2xlYW51cHMgPT09IG51bGwpIE93bmVyLmNsZWFudXBzID0gW2ZuXTtcbiAgZWxzZSBPd25lci5jbGVhbnVwcy5wdXNoKGZuKTtcbiAgcmV0dXJuIGZuO1xufVxuZnVuY3Rpb24gZ2V0TGlzdGVuZXIoKSB7XG4gIHJldHVybiBMaXN0ZW5lcjtcbn1cbmZ1bmN0aW9uIGdldE93bmVyKCkge1xuICByZXR1cm4gT3duZXI7XG59XG5mdW5jdGlvbiBydW5XaXRoT3duZXIobzIsIGZuKSB7XG4gIGNvbnN0IHByZXYgPSBPd25lcjtcbiAgY29uc3QgcHJldkxpc3RlbmVyID0gTGlzdGVuZXI7XG4gIE93bmVyID0gbzI7XG4gIExpc3RlbmVyID0gbnVsbDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcnVuVXBkYXRlcyhmbiwgdHJ1ZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGhhbmRsZUVycm9yKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgT3duZXIgPSBwcmV2O1xuICAgIExpc3RlbmVyID0gcHJldkxpc3RlbmVyO1xuICB9XG59XG5mdW5jdGlvbiBzdGFydFRyYW5zaXRpb24oZm4pIHtcbiAgY29uc3QgbDIgPSBMaXN0ZW5lcjtcbiAgY29uc3QgbzIgPSBPd25lcjtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgIExpc3RlbmVyID0gbDI7XG4gICAgT3duZXIgPSBvMjtcbiAgICBydW5VcGRhdGVzKGZuLCBmYWxzZSk7XG4gICAgTGlzdGVuZXIgPSBPd25lciA9IG51bGw7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfSk7XG59XG5jb25zdCBbdHJhbnNQZW5kaW5nLCBzZXRUcmFuc1BlbmRpbmddID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVNpZ25hbChmYWxzZSk7XG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uKCkge1xuICByZXR1cm4gW3RyYW5zUGVuZGluZywgc3RhcnRUcmFuc2l0aW9uXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGlkID0gU3ltYm9sKFwiY29udGV4dFwiKTtcbiAgcmV0dXJuIHtcbiAgICBpZCxcbiAgICBQcm92aWRlcjogY3JlYXRlUHJvdmlkZXIoaWQpLFxuICAgIGRlZmF1bHRWYWx1ZVxuICB9O1xufVxuZnVuY3Rpb24gdXNlQ29udGV4dChjb250ZXh0KSB7XG4gIGxldCB2YWx1ZTtcbiAgcmV0dXJuIE93bmVyICYmIE93bmVyLmNvbnRleHQgJiYgKHZhbHVlID0gT3duZXIuY29udGV4dFtjb250ZXh0LmlkXSkgIT09IHZvaWQgMCA/IHZhbHVlIDogY29udGV4dC5kZWZhdWx0VmFsdWU7XG59XG5mdW5jdGlvbiBjaGlsZHJlbihmbikge1xuICBjb25zdCBjaGlsZHJlbjIgPSBjcmVhdGVNZW1vKGZuKTtcbiAgY29uc3QgbWVtbzIgPSBjcmVhdGVNZW1vKCgpID0+IHJlc29sdmVDaGlsZHJlbihjaGlsZHJlbjIoKSkpO1xuICBtZW1vMi50b0FycmF5ID0gKCkgPT4ge1xuICAgIGNvbnN0IGMyID0gbWVtbzIoKTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShjMikgPyBjMiA6IGMyICE9IG51bGwgPyBbYzJdIDogW107XG4gIH07XG4gIHJldHVybiBtZW1vMjtcbn1cbmxldCBTdXNwZW5zZUNvbnRleHQ7XG5mdW5jdGlvbiByZWFkU2lnbmFsKCkge1xuICBpZiAodGhpcy5zb3VyY2VzICYmIHRoaXMuc3RhdGUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU1RBTEUpIHVwZGF0ZUNvbXB1dGF0aW9uKHRoaXMpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgdXBkYXRlcyA9IFVwZGF0ZXM7XG4gICAgICBVcGRhdGVzID0gbnVsbDtcbiAgICAgIHJ1blVwZGF0ZXMoKCkgPT4gbG9va1Vwc3RyZWFtKHRoaXMpLCBmYWxzZSk7XG4gICAgICBVcGRhdGVzID0gdXBkYXRlcztcbiAgICB9XG4gIH1cbiAgaWYgKExpc3RlbmVyKSB7XG4gICAgY29uc3Qgc1Nsb3QgPSB0aGlzLm9ic2VydmVycyA/IHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA6IDA7XG4gICAgaWYgKCFMaXN0ZW5lci5zb3VyY2VzKSB7XG4gICAgICBMaXN0ZW5lci5zb3VyY2VzID0gW3RoaXNdO1xuICAgICAgTGlzdGVuZXIuc291cmNlU2xvdHMgPSBbc1Nsb3RdO1xuICAgIH0gZWxzZSB7XG4gICAgICBMaXN0ZW5lci5zb3VyY2VzLnB1c2godGhpcyk7XG4gICAgICBMaXN0ZW5lci5zb3VyY2VTbG90cy5wdXNoKHNTbG90KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm9ic2VydmVycykge1xuICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbTGlzdGVuZXJdO1xuICAgICAgdGhpcy5vYnNlcnZlclNsb3RzID0gW0xpc3RlbmVyLnNvdXJjZXMubGVuZ3RoIC0gMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2goTGlzdGVuZXIpO1xuICAgICAgdGhpcy5vYnNlcnZlclNsb3RzLnB1c2goTGlzdGVuZXIuc291cmNlcy5sZW5ndGggLSAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMudmFsdWU7XG59XG5mdW5jdGlvbiB3cml0ZVNpZ25hbChub2RlLCB2YWx1ZSwgaXNDb21wKSB7XG4gIGxldCBjdXJyZW50ID0gbm9kZS52YWx1ZTtcbiAgaWYgKCFub2RlLmNvbXBhcmF0b3IgfHwgIW5vZGUuY29tcGFyYXRvcihjdXJyZW50LCB2YWx1ZSkpIHtcbiAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgaWYgKG5vZGUub2JzZXJ2ZXJzICYmIG5vZGUub2JzZXJ2ZXJzLmxlbmd0aCkge1xuICAgICAgcnVuVXBkYXRlcygoKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBub2RlLm9ic2VydmVycy5sZW5ndGg7IGkyICs9IDEpIHtcbiAgICAgICAgICBjb25zdCBvMiA9IG5vZGUub2JzZXJ2ZXJzW2kyXTtcbiAgICAgICAgICBjb25zdCBUcmFuc2l0aW9uUnVubmluZyA9IFRyYW5zaXRpb24kMSAmJiBUcmFuc2l0aW9uJDEucnVubmluZztcbiAgICAgICAgICBpZiAoVHJhbnNpdGlvblJ1bm5pbmcgJiYgVHJhbnNpdGlvbiQxLmRpc3Bvc2VkLmhhcyhvMikpIDtcbiAgICAgICAgICBpZiAoVHJhbnNpdGlvblJ1bm5pbmcgPyAhbzIudFN0YXRlIDogIW8yLnN0YXRlKSB7XG4gICAgICAgICAgICBpZiAobzIucHVyZSkgVXBkYXRlcy5wdXNoKG8yKTtcbiAgICAgICAgICAgIGVsc2UgRWZmZWN0cy5wdXNoKG8yKTtcbiAgICAgICAgICAgIGlmIChvMi5vYnNlcnZlcnMpIG1hcmtEb3duc3RyZWFtKG8yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFUcmFuc2l0aW9uUnVubmluZykgbzIuc3RhdGUgPSBTVEFMRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVXBkYXRlcy5sZW5ndGggPiAxZTYpIHtcbiAgICAgICAgICBVcGRhdGVzID0gW107XG4gICAgICAgICAgaWYgKElTX0RFVikgO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbXB1dGF0aW9uKG5vZGUpIHtcbiAgaWYgKCFub2RlLmZuKSByZXR1cm47XG4gIGNsZWFuTm9kZShub2RlKTtcbiAgY29uc3QgdGltZSA9IEV4ZWNDb3VudDtcbiAgcnVuQ29tcHV0YXRpb24obm9kZSwgbm9kZS52YWx1ZSwgdGltZSk7XG59XG5mdW5jdGlvbiBydW5Db21wdXRhdGlvbihub2RlLCB2YWx1ZSwgdGltZSkge1xuICBsZXQgbmV4dFZhbHVlO1xuICBjb25zdCBvd25lciA9IE93bmVyLCBsaXN0ZW5lciA9IExpc3RlbmVyO1xuICBMaXN0ZW5lciA9IE93bmVyID0gbm9kZTtcbiAgdHJ5IHtcbiAgICBuZXh0VmFsdWUgPSBub2RlLmZuKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKG5vZGUucHVyZSkge1xuICAgICAge1xuICAgICAgICBub2RlLnN0YXRlID0gU1RBTEU7XG4gICAgICAgIG5vZGUub3duZWQgJiYgbm9kZS5vd25lZC5mb3JFYWNoKGNsZWFuTm9kZSk7XG4gICAgICAgIG5vZGUub3duZWQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlLnVwZGF0ZWRBdCA9IHRpbWUgKyAxO1xuICAgIHJldHVybiBoYW5kbGVFcnJvcihlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIExpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgT3duZXIgPSBvd25lcjtcbiAgfVxuICBpZiAoIW5vZGUudXBkYXRlZEF0IHx8IG5vZGUudXBkYXRlZEF0IDw9IHRpbWUpIHtcbiAgICBpZiAobm9kZS51cGRhdGVkQXQgIT0gbnVsbCAmJiBcIm9ic2VydmVyc1wiIGluIG5vZGUpIHtcbiAgICAgIHdyaXRlU2lnbmFsKG5vZGUsIG5leHRWYWx1ZSk7XG4gICAgfSBlbHNlIG5vZGUudmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgbm9kZS51cGRhdGVkQXQgPSB0aW1lO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVDb21wdXRhdGlvbihmbiwgaW5pdCwgcHVyZSwgc3RhdGUgPSBTVEFMRSwgb3B0aW9ucykge1xuICBjb25zdCBjMiA9IHtcbiAgICBmbixcbiAgICBzdGF0ZSxcbiAgICB1cGRhdGVkQXQ6IG51bGwsXG4gICAgb3duZWQ6IG51bGwsXG4gICAgc291cmNlczogbnVsbCxcbiAgICBzb3VyY2VTbG90czogbnVsbCxcbiAgICBjbGVhbnVwczogbnVsbCxcbiAgICB2YWx1ZTogaW5pdCxcbiAgICBvd25lcjogT3duZXIsXG4gICAgY29udGV4dDogT3duZXIgPyBPd25lci5jb250ZXh0IDogbnVsbCxcbiAgICBwdXJlXG4gIH07XG4gIGlmIChPd25lciA9PT0gbnVsbCkgO1xuICBlbHNlIGlmIChPd25lciAhPT0gVU5PV05FRCkge1xuICAgIHtcbiAgICAgIGlmICghT3duZXIub3duZWQpIE93bmVyLm93bmVkID0gW2MyXTtcbiAgICAgIGVsc2UgT3duZXIub3duZWQucHVzaChjMik7XG4gICAgfVxuICB9XG4gIHJldHVybiBjMjtcbn1cbmZ1bmN0aW9uIHJ1blRvcChub2RlKSB7XG4gIGlmIChub2RlLnN0YXRlID09PSAwKSByZXR1cm47XG4gIGlmIChub2RlLnN0YXRlID09PSBQRU5ESU5HKSByZXR1cm4gbG9va1Vwc3RyZWFtKG5vZGUpO1xuICBpZiAobm9kZS5zdXNwZW5zZSAmJiB1bnRyYWNrKG5vZGUuc3VzcGVuc2UuaW5GYWxsYmFjaykpIHJldHVybiBub2RlLnN1c3BlbnNlLmVmZmVjdHMucHVzaChub2RlKTtcbiAgY29uc3QgYW5jZXN0b3JzID0gW25vZGVdO1xuICB3aGlsZSAoKG5vZGUgPSBub2RlLm93bmVyKSAmJiAoIW5vZGUudXBkYXRlZEF0IHx8IG5vZGUudXBkYXRlZEF0IDwgRXhlY0NvdW50KSkge1xuICAgIGlmIChub2RlLnN0YXRlKSBhbmNlc3RvcnMucHVzaChub2RlKTtcbiAgfVxuICBmb3IgKGxldCBpMiA9IGFuY2VzdG9ycy5sZW5ndGggLSAxOyBpMiA+PSAwOyBpMi0tKSB7XG4gICAgbm9kZSA9IGFuY2VzdG9yc1tpMl07XG4gICAgaWYgKG5vZGUuc3RhdGUgPT09IFNUQUxFKSB7XG4gICAgICB1cGRhdGVDb21wdXRhdGlvbihub2RlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZXMgPSBVcGRhdGVzO1xuICAgICAgVXBkYXRlcyA9IG51bGw7XG4gICAgICBydW5VcGRhdGVzKCgpID0+IGxvb2tVcHN0cmVhbShub2RlLCBhbmNlc3RvcnNbMF0pLCBmYWxzZSk7XG4gICAgICBVcGRhdGVzID0gdXBkYXRlcztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJ1blVwZGF0ZXMoZm4sIGluaXQpIHtcbiAgaWYgKFVwZGF0ZXMpIHJldHVybiBmbigpO1xuICBsZXQgd2FpdCA9IGZhbHNlO1xuICBpZiAoIWluaXQpIFVwZGF0ZXMgPSBbXTtcbiAgaWYgKEVmZmVjdHMpIHdhaXQgPSB0cnVlO1xuICBlbHNlIEVmZmVjdHMgPSBbXTtcbiAgRXhlY0NvdW50Kys7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzID0gZm4oKTtcbiAgICBjb21wbGV0ZVVwZGF0ZXMod2FpdCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKCF3YWl0KSBFZmZlY3RzID0gbnVsbDtcbiAgICBVcGRhdGVzID0gbnVsbDtcbiAgICBoYW5kbGVFcnJvcihlcnIpO1xuICB9XG59XG5mdW5jdGlvbiBjb21wbGV0ZVVwZGF0ZXMod2FpdCkge1xuICBpZiAoVXBkYXRlcykge1xuICAgIHJ1blF1ZXVlKFVwZGF0ZXMpO1xuICAgIFVwZGF0ZXMgPSBudWxsO1xuICB9XG4gIGlmICh3YWl0KSByZXR1cm47XG4gIGNvbnN0IGUyID0gRWZmZWN0cztcbiAgRWZmZWN0cyA9IG51bGw7XG4gIGlmIChlMi5sZW5ndGgpIHJ1blVwZGF0ZXMoKCkgPT4gcnVuRWZmZWN0cyhlMiksIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHJ1blF1ZXVlKHF1ZXVlKSB7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBxdWV1ZS5sZW5ndGg7IGkyKyspIHJ1blRvcChxdWV1ZVtpMl0pO1xufVxuZnVuY3Rpb24gcnVuVXNlckVmZmVjdHMocXVldWUpIHtcbiAgbGV0IGkyLCB1c2VyTGVuZ3RoID0gMDtcbiAgZm9yIChpMiA9IDA7IGkyIDwgcXVldWUubGVuZ3RoOyBpMisrKSB7XG4gICAgY29uc3QgZTIgPSBxdWV1ZVtpMl07XG4gICAgaWYgKCFlMi51c2VyKSBydW5Ub3AoZTIpO1xuICAgIGVsc2UgcXVldWVbdXNlckxlbmd0aCsrXSA9IGUyO1xuICB9XG4gIGZvciAoaTIgPSAwOyBpMiA8IHVzZXJMZW5ndGg7IGkyKyspIHJ1blRvcChxdWV1ZVtpMl0pO1xufVxuZnVuY3Rpb24gbG9va1Vwc3RyZWFtKG5vZGUsIGlnbm9yZSkge1xuICBub2RlLnN0YXRlID0gMDtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG5vZGUuc291cmNlcy5sZW5ndGg7IGkyICs9IDEpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBub2RlLnNvdXJjZXNbaTJdO1xuICAgIGlmIChzb3VyY2Uuc291cmNlcykge1xuICAgICAgY29uc3Qgc3RhdGUgPSBzb3VyY2Uuc3RhdGU7XG4gICAgICBpZiAoc3RhdGUgPT09IFNUQUxFKSB7XG4gICAgICAgIGlmIChzb3VyY2UgIT09IGlnbm9yZSAmJiAoIXNvdXJjZS51cGRhdGVkQXQgfHwgc291cmNlLnVwZGF0ZWRBdCA8IEV4ZWNDb3VudCkpIHJ1blRvcChzb3VyY2UpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gUEVORElORykgbG9va1Vwc3RyZWFtKHNvdXJjZSwgaWdub3JlKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtEb3duc3RyZWFtKG5vZGUpIHtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG5vZGUub2JzZXJ2ZXJzLmxlbmd0aDsgaTIgKz0gMSkge1xuICAgIGNvbnN0IG8yID0gbm9kZS5vYnNlcnZlcnNbaTJdO1xuICAgIGlmICghbzIuc3RhdGUpIHtcbiAgICAgIG8yLnN0YXRlID0gUEVORElORztcbiAgICAgIGlmIChvMi5wdXJlKSBVcGRhdGVzLnB1c2gobzIpO1xuICAgICAgZWxzZSBFZmZlY3RzLnB1c2gobzIpO1xuICAgICAgbzIub2JzZXJ2ZXJzICYmIG1hcmtEb3duc3RyZWFtKG8yKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFuTm9kZShub2RlKSB7XG4gIGxldCBpMjtcbiAgaWYgKG5vZGUuc291cmNlcykge1xuICAgIHdoaWxlIChub2RlLnNvdXJjZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBub2RlLnNvdXJjZXMucG9wKCksIGluZGV4ID0gbm9kZS5zb3VyY2VTbG90cy5wb3AoKSwgb2JzID0gc291cmNlLm9ic2VydmVycztcbiAgICAgIGlmIChvYnMgJiYgb2JzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBuMiA9IG9icy5wb3AoKSwgczIgPSBzb3VyY2Uub2JzZXJ2ZXJTbG90cy5wb3AoKTtcbiAgICAgICAgaWYgKGluZGV4IDwgb2JzLmxlbmd0aCkge1xuICAgICAgICAgIG4yLnNvdXJjZVNsb3RzW3MyXSA9IGluZGV4O1xuICAgICAgICAgIG9ic1tpbmRleF0gPSBuMjtcbiAgICAgICAgICBzb3VyY2Uub2JzZXJ2ZXJTbG90c1tpbmRleF0gPSBzMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobm9kZS50T3duZWQpIHtcbiAgICBmb3IgKGkyID0gbm9kZS50T3duZWQubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkgY2xlYW5Ob2RlKG5vZGUudE93bmVkW2kyXSk7XG4gICAgZGVsZXRlIG5vZGUudE93bmVkO1xuICB9XG4gIGlmIChub2RlLm93bmVkKSB7XG4gICAgZm9yIChpMiA9IG5vZGUub3duZWQubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkgY2xlYW5Ob2RlKG5vZGUub3duZWRbaTJdKTtcbiAgICBub2RlLm93bmVkID0gbnVsbDtcbiAgfVxuICBpZiAobm9kZS5jbGVhbnVwcykge1xuICAgIGZvciAoaTIgPSBub2RlLmNsZWFudXBzLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pIG5vZGUuY2xlYW51cHNbaTJdKCk7XG4gICAgbm9kZS5jbGVhbnVwcyA9IG51bGw7XG4gIH1cbiAgbm9kZS5zdGF0ZSA9IDA7XG59XG5mdW5jdGlvbiBjYXN0RXJyb3IoZXJyKSB7XG4gIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIGVycjtcbiAgcmV0dXJuIG5ldyBFcnJvcih0eXBlb2YgZXJyID09PSBcInN0cmluZ1wiID8gZXJyIDogXCJVbmtub3duIGVycm9yXCIsIHtcbiAgICBjYXVzZTogZXJyXG4gIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyLCBvd25lciA9IE93bmVyKSB7XG4gIGNvbnN0IGVycm9yID0gY2FzdEVycm9yKGVycik7XG4gIHRocm93IGVycm9yO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUNoaWxkcmVuKGNoaWxkcmVuMikge1xuICBpZiAodHlwZW9mIGNoaWxkcmVuMiA9PT0gXCJmdW5jdGlvblwiICYmICFjaGlsZHJlbjIubGVuZ3RoKSByZXR1cm4gcmVzb2x2ZUNoaWxkcmVuKGNoaWxkcmVuMigpKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4yKSkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgY2hpbGRyZW4yLmxlbmd0aDsgaTIrKykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcmVzb2x2ZUNoaWxkcmVuKGNoaWxkcmVuMltpMl0pO1xuICAgICAgQXJyYXkuaXNBcnJheShyZXN1bHQpID8gcmVzdWx0cy5wdXNoLmFwcGx5KHJlc3VsdHMsIHJlc3VsdCkgOiByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuMjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb3ZpZGVyKGlkLCBvcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwcm92aWRlcihwcm9wcykge1xuICAgIGxldCByZXM7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KCgpID0+IHJlcyA9IHVudHJhY2soKCkgPT4ge1xuICAgICAgT3duZXIuY29udGV4dCA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIE93bmVyLmNvbnRleHQpLCB7XG4gICAgICAgIFtpZF06IHByb3BzLnZhbHVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjaGlsZHJlbigoKSA9PiBwcm9wcy5jaGlsZHJlbik7XG4gICAgfSksIHZvaWQgMCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn1cbmNvbnN0IEZBTExCQUNLID0gU3ltYm9sKFwiZmFsbGJhY2tcIik7XG5mdW5jdGlvbiBkaXNwb3NlKGQpIHtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGQubGVuZ3RoOyBpMisrKSBkW2kyXSgpO1xufVxuZnVuY3Rpb24gbWFwQXJyYXkobGlzdCwgbWFwRm4sIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgaXRlbXMgPSBbXSwgbWFwcGVkID0gW10sIGRpc3Bvc2VycyA9IFtdLCBsZW4gPSAwLCBpbmRleGVzID0gbWFwRm4ubGVuZ3RoID4gMSA/IFtdIDogbnVsbDtcbiAgb25DbGVhbnVwKCgpID0+IGRpc3Bvc2UoZGlzcG9zZXJzKSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGV0IG5ld0l0ZW1zID0gbGlzdCgpIHx8IFtdLCBuZXdMZW4gPSBuZXdJdGVtcy5sZW5ndGgsIGkyLCBqO1xuICAgIG5ld0l0ZW1zWyRUUkFDS107XG4gICAgcmV0dXJuIHVudHJhY2soKCkgPT4ge1xuICAgICAgbGV0IG5ld0luZGljZXMsIG5ld0luZGljZXNOZXh0LCB0ZW1wLCB0ZW1wZGlzcG9zZXJzLCB0ZW1wSW5kZXhlcywgc3RhcnQsIGVuZCwgbmV3RW5kLCBpdGVtO1xuICAgICAgaWYgKG5ld0xlbiA9PT0gMCkge1xuICAgICAgICBpZiAobGVuICE9PSAwKSB7XG4gICAgICAgICAgZGlzcG9zZShkaXNwb3NlcnMpO1xuICAgICAgICAgIGRpc3Bvc2VycyA9IFtdO1xuICAgICAgICAgIGl0ZW1zID0gW107XG4gICAgICAgICAgbWFwcGVkID0gW107XG4gICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICBpbmRleGVzICYmIChpbmRleGVzID0gW10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmZhbGxiYWNrKSB7XG4gICAgICAgICAgaXRlbXMgPSBbRkFMTEJBQ0tdO1xuICAgICAgICAgIG1hcHBlZFswXSA9IGNyZWF0ZVJvb3QoKGRpc3Bvc2VyKSA9PiB7XG4gICAgICAgICAgICBkaXNwb3NlcnNbMF0gPSBkaXNwb3NlcjtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmZhbGxiYWNrKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGVuID0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgbWFwcGVkID0gbmV3IEFycmF5KG5ld0xlbik7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBuZXdMZW47IGorKykge1xuICAgICAgICAgIGl0ZW1zW2pdID0gbmV3SXRlbXNbal07XG4gICAgICAgICAgbWFwcGVkW2pdID0gY3JlYXRlUm9vdChtYXBwZXIpO1xuICAgICAgICB9XG4gICAgICAgIGxlbiA9IG5ld0xlbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXAgPSBuZXcgQXJyYXkobmV3TGVuKTtcbiAgICAgICAgdGVtcGRpc3Bvc2VycyA9IG5ldyBBcnJheShuZXdMZW4pO1xuICAgICAgICBpbmRleGVzICYmICh0ZW1wSW5kZXhlcyA9IG5ldyBBcnJheShuZXdMZW4pKTtcbiAgICAgICAgZm9yIChzdGFydCA9IDAsIGVuZCA9IE1hdGgubWluKGxlbiwgbmV3TGVuKTsgc3RhcnQgPCBlbmQgJiYgaXRlbXNbc3RhcnRdID09PSBuZXdJdGVtc1tzdGFydF07IHN0YXJ0KyspIDtcbiAgICAgICAgZm9yIChlbmQgPSBsZW4gLSAxLCBuZXdFbmQgPSBuZXdMZW4gLSAxOyBlbmQgPj0gc3RhcnQgJiYgbmV3RW5kID49IHN0YXJ0ICYmIGl0ZW1zW2VuZF0gPT09IG5ld0l0ZW1zW25ld0VuZF07IGVuZC0tLCBuZXdFbmQtLSkge1xuICAgICAgICAgIHRlbXBbbmV3RW5kXSA9IG1hcHBlZFtlbmRdO1xuICAgICAgICAgIHRlbXBkaXNwb3NlcnNbbmV3RW5kXSA9IGRpc3Bvc2Vyc1tlbmRdO1xuICAgICAgICAgIGluZGV4ZXMgJiYgKHRlbXBJbmRleGVzW25ld0VuZF0gPSBpbmRleGVzW2VuZF0pO1xuICAgICAgICB9XG4gICAgICAgIG5ld0luZGljZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBuZXdJbmRpY2VzTmV4dCA9IG5ldyBBcnJheShuZXdFbmQgKyAxKTtcbiAgICAgICAgZm9yIChqID0gbmV3RW5kOyBqID49IHN0YXJ0OyBqLS0pIHtcbiAgICAgICAgICBpdGVtID0gbmV3SXRlbXNbal07XG4gICAgICAgICAgaTIgPSBuZXdJbmRpY2VzLmdldChpdGVtKTtcbiAgICAgICAgICBuZXdJbmRpY2VzTmV4dFtqXSA9IGkyID09PSB2b2lkIDAgPyAtMSA6IGkyO1xuICAgICAgICAgIG5ld0luZGljZXMuc2V0KGl0ZW0sIGopO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaTIgPSBzdGFydDsgaTIgPD0gZW5kOyBpMisrKSB7XG4gICAgICAgICAgaXRlbSA9IGl0ZW1zW2kyXTtcbiAgICAgICAgICBqID0gbmV3SW5kaWNlcy5nZXQoaXRlbSk7XG4gICAgICAgICAgaWYgKGogIT09IHZvaWQgMCAmJiBqICE9PSAtMSkge1xuICAgICAgICAgICAgdGVtcFtqXSA9IG1hcHBlZFtpMl07XG4gICAgICAgICAgICB0ZW1wZGlzcG9zZXJzW2pdID0gZGlzcG9zZXJzW2kyXTtcbiAgICAgICAgICAgIGluZGV4ZXMgJiYgKHRlbXBJbmRleGVzW2pdID0gaW5kZXhlc1tpMl0pO1xuICAgICAgICAgICAgaiA9IG5ld0luZGljZXNOZXh0W2pdO1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5zZXQoaXRlbSwgaik7XG4gICAgICAgICAgfSBlbHNlIGRpc3Bvc2Vyc1tpMl0oKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGogPSBzdGFydDsgaiA8IG5ld0xlbjsgaisrKSB7XG4gICAgICAgICAgaWYgKGogaW4gdGVtcCkge1xuICAgICAgICAgICAgbWFwcGVkW2pdID0gdGVtcFtqXTtcbiAgICAgICAgICAgIGRpc3Bvc2Vyc1tqXSA9IHRlbXBkaXNwb3NlcnNbal07XG4gICAgICAgICAgICBpZiAoaW5kZXhlcykge1xuICAgICAgICAgICAgICBpbmRleGVzW2pdID0gdGVtcEluZGV4ZXNbal07XG4gICAgICAgICAgICAgIGluZGV4ZXNbal0oaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIG1hcHBlZFtqXSA9IGNyZWF0ZVJvb3QobWFwcGVyKTtcbiAgICAgICAgfVxuICAgICAgICBtYXBwZWQgPSBtYXBwZWQuc2xpY2UoMCwgbGVuID0gbmV3TGVuKTtcbiAgICAgICAgaXRlbXMgPSBuZXdJdGVtcy5zbGljZSgwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gbWFwcGVyKGRpc3Bvc2VyKSB7XG4gICAgICBkaXNwb3NlcnNbal0gPSBkaXNwb3NlcjtcbiAgICAgIGlmIChpbmRleGVzKSB7XG4gICAgICAgIGNvbnN0IFtzMiwgc2V0XSA9IGNyZWF0ZVNpZ25hbChqKTtcbiAgICAgICAgaW5kZXhlc1tqXSA9IHNldDtcbiAgICAgICAgcmV0dXJuIG1hcEZuKG5ld0l0ZW1zW2pdLCBzMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwRm4obmV3SXRlbXNbal0pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudChDb21wLCBwcm9wcykge1xuICByZXR1cm4gdW50cmFjaygoKSA9PiBDb21wKHByb3BzIHx8IHt9KSk7XG59XG5mdW5jdGlvbiB0cnVlRm4oKSB7XG4gIHJldHVybiB0cnVlO1xufVxuY29uc3QgcHJvcFRyYXBzID0ge1xuICBnZXQoXywgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgaWYgKHByb3BlcnR5ID09PSAkUFJPWFkpIHJldHVybiByZWNlaXZlcjtcbiAgICByZXR1cm4gXy5nZXQocHJvcGVydHkpO1xuICB9LFxuICBoYXMoXywgcHJvcGVydHkpIHtcbiAgICBpZiAocHJvcGVydHkgPT09ICRQUk9YWSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIF8uaGFzKHByb3BlcnR5KTtcbiAgfSxcbiAgc2V0OiB0cnVlRm4sXG4gIGRlbGV0ZVByb3BlcnR5OiB0cnVlRm4sXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihfLCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gXy5nZXQocHJvcGVydHkpO1xuICAgICAgfSxcbiAgICAgIHNldDogdHJ1ZUZuLFxuICAgICAgZGVsZXRlUHJvcGVydHk6IHRydWVGblxuICAgIH07XG4gIH0sXG4gIG93bktleXMoXykge1xuICAgIHJldHVybiBfLmtleXMoKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJlc29sdmVTb3VyY2UoczIpIHtcbiAgcmV0dXJuICEoczIgPSB0eXBlb2YgczIgPT09IFwiZnVuY3Rpb25cIiA/IHMyKCkgOiBzMikgPyB7fSA6IHMyO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVNvdXJjZXMoKSB7XG4gIGZvciAobGV0IGkyID0gMCwgbGVuZ3RoID0gdGhpcy5sZW5ndGg7IGkyIDwgbGVuZ3RoOyArK2kyKSB7XG4gICAgY29uc3QgdiA9IHRoaXNbaTJdKCk7XG4gICAgaWYgKHYgIT09IHZvaWQgMCkgcmV0dXJuIHY7XG4gIH1cbn1cbmZ1bmN0aW9uIG1lcmdlUHJvcHMoLi4uc291cmNlcykge1xuICBsZXQgcHJveHkgPSBmYWxzZTtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHNvdXJjZXMubGVuZ3RoOyBpMisrKSB7XG4gICAgY29uc3QgczIgPSBzb3VyY2VzW2kyXTtcbiAgICBwcm94eSA9IHByb3h5IHx8ICEhczIgJiYgJFBST1hZIGluIHMyO1xuICAgIHNvdXJjZXNbaTJdID0gdHlwZW9mIHMyID09PSBcImZ1bmN0aW9uXCIgPyAocHJveHkgPSB0cnVlLCBjcmVhdGVNZW1vKHMyKSkgOiBzMjtcbiAgfVxuICBpZiAoU1VQUE9SVFNfUFJPWFkgJiYgcHJveHkpIHtcbiAgICByZXR1cm4gbmV3IFByb3h5KHtcbiAgICAgIGdldChwcm9wZXJ0eSkge1xuICAgICAgICBmb3IgKGxldCBpMiA9IHNvdXJjZXMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkge1xuICAgICAgICAgIGNvbnN0IHYgPSByZXNvbHZlU291cmNlKHNvdXJjZXNbaTJdKVtwcm9wZXJ0eV07XG4gICAgICAgICAgaWYgKHYgIT09IHZvaWQgMCkgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoYXMocHJvcGVydHkpIHtcbiAgICAgICAgZm9yIChsZXQgaTIgPSBzb3VyY2VzLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pIHtcbiAgICAgICAgICBpZiAocHJvcGVydHkgaW4gcmVzb2x2ZVNvdXJjZShzb3VyY2VzW2kyXSkpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBrZXlzKCkge1xuICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBzb3VyY2VzLmxlbmd0aDsgaTIrKykga2V5cy5wdXNoKC4uLk9iamVjdC5rZXlzKHJlc29sdmVTb3VyY2Uoc291cmNlc1tpMl0pKSk7XG4gICAgICAgIHJldHVybiBbLi4ubmV3IFNldChrZXlzKV07XG4gICAgICB9XG4gICAgfSwgcHJvcFRyYXBzKTtcbiAgfVxuICBjb25zdCBzb3VyY2VzTWFwID0ge307XG4gIGNvbnN0IGRlZmluZWQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChsZXQgaTIgPSBzb3VyY2VzLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pIHtcbiAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzW2kyXTtcbiAgICBpZiAoIXNvdXJjZSkgY29udGludWU7XG4gICAgY29uc3Qgc291cmNlS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZSk7XG4gICAgZm9yIChsZXQgaTMgPSBzb3VyY2VLZXlzLmxlbmd0aCAtIDE7IGkzID49IDA7IGkzLS0pIHtcbiAgICAgIGNvbnN0IGtleSA9IHNvdXJjZUtleXNbaTNdO1xuICAgICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIiB8fCBrZXkgPT09IFwiY29uc3RydWN0b3JcIikgY29udGludWU7XG4gICAgICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSk7XG4gICAgICBpZiAoIWRlZmluZWRba2V5XSkge1xuICAgICAgICBkZWZpbmVkW2tleV0gPSBkZXNjLmdldCA/IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IHJlc29sdmVTb3VyY2VzLmJpbmQoc291cmNlc01hcFtrZXldID0gW2Rlc2MuZ2V0LmJpbmQoc291cmNlKV0pXG4gICAgICAgIH0gOiBkZXNjLnZhbHVlICE9PSB2b2lkIDAgPyBkZXNjIDogdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc291cmNlczIgPSBzb3VyY2VzTWFwW2tleV07XG4gICAgICAgIGlmIChzb3VyY2VzMikge1xuICAgICAgICAgIGlmIChkZXNjLmdldCkgc291cmNlczIucHVzaChkZXNjLmdldC5iaW5kKHNvdXJjZSkpO1xuICAgICAgICAgIGVsc2UgaWYgKGRlc2MudmFsdWUgIT09IHZvaWQgMCkgc291cmNlczIucHVzaCgoKSA9PiBkZXNjLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgY29uc3QgZGVmaW5lZEtleXMgPSBPYmplY3Qua2V5cyhkZWZpbmVkKTtcbiAgZm9yIChsZXQgaTIgPSBkZWZpbmVkS2V5cy5sZW5ndGggLSAxOyBpMiA+PSAwOyBpMi0tKSB7XG4gICAgY29uc3Qga2V5ID0gZGVmaW5lZEtleXNbaTJdLCBkZXNjID0gZGVmaW5lZFtrZXldO1xuICAgIGlmIChkZXNjICYmIGRlc2MuZ2V0KSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgdGFyZ2V0W2tleV0gPSBkZXNjID8gZGVzYy52YWx1ZSA6IHZvaWQgMDtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gc3BsaXRQcm9wcyhwcm9wcywgLi4ua2V5cykge1xuICBpZiAoU1VQUE9SVFNfUFJPWFkgJiYgJFBST1hZIGluIHByb3BzKSB7XG4gICAgY29uc3QgYmxvY2tlZCA9IG5ldyBTZXQoa2V5cy5sZW5ndGggPiAxID8ga2V5cy5mbGF0KCkgOiBrZXlzWzBdKTtcbiAgICBjb25zdCByZXMgPSBrZXlzLm1hcCgoaykgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm94eSh7XG4gICAgICAgIGdldChwcm9wZXJ0eSkge1xuICAgICAgICAgIHJldHVybiBrLmluY2x1ZGVzKHByb3BlcnR5KSA/IHByb3BzW3Byb3BlcnR5XSA6IHZvaWQgMDtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzKHByb3BlcnR5KSB7XG4gICAgICAgICAgcmV0dXJuIGsuaW5jbHVkZXMocHJvcGVydHkpICYmIHByb3BlcnR5IGluIHByb3BzO1xuICAgICAgICB9LFxuICAgICAgICBrZXlzKCkge1xuICAgICAgICAgIHJldHVybiBrLmZpbHRlcigocHJvcGVydHkpID0+IHByb3BlcnR5IGluIHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgfSwgcHJvcFRyYXBzKTtcbiAgICB9KTtcbiAgICByZXMucHVzaChuZXcgUHJveHkoe1xuICAgICAgZ2V0KHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBibG9ja2VkLmhhcyhwcm9wZXJ0eSkgPyB2b2lkIDAgOiBwcm9wc1twcm9wZXJ0eV07XG4gICAgICB9LFxuICAgICAgaGFzKHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBibG9ja2VkLmhhcyhwcm9wZXJ0eSkgPyBmYWxzZSA6IHByb3BlcnR5IGluIHByb3BzO1xuICAgICAgfSxcbiAgICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKChrKSA9PiAhYmxvY2tlZC5oYXMoaykpO1xuICAgICAgfVxuICAgIH0sIHByb3BUcmFwcykpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgY29uc3Qgb3RoZXJPYmplY3QgPSB7fTtcbiAgY29uc3Qgb2JqZWN0cyA9IGtleXMubWFwKCgpID0+ICh7fSkpO1xuICBmb3IgKGNvbnN0IHByb3BOYW1lIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BzKSkge1xuICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3BzLCBwcm9wTmFtZSk7XG4gICAgY29uc3QgaXNEZWZhdWx0RGVzYyA9ICFkZXNjLmdldCAmJiAhZGVzYy5zZXQgJiYgZGVzYy5lbnVtZXJhYmxlICYmIGRlc2Mud3JpdGFibGUgJiYgZGVzYy5jb25maWd1cmFibGU7XG4gICAgbGV0IGJsb2NrZWQgPSBmYWxzZTtcbiAgICBsZXQgb2JqZWN0SW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICBpZiAoay5pbmNsdWRlcyhwcm9wTmFtZSkpIHtcbiAgICAgICAgYmxvY2tlZCA9IHRydWU7XG4gICAgICAgIGlzRGVmYXVsdERlc2MgPyBvYmplY3RzW29iamVjdEluZGV4XVtwcm9wTmFtZV0gPSBkZXNjLnZhbHVlIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdHNbb2JqZWN0SW5kZXhdLCBwcm9wTmFtZSwgZGVzYyk7XG4gICAgICB9XG4gICAgICArK29iamVjdEluZGV4O1xuICAgIH1cbiAgICBpZiAoIWJsb2NrZWQpIHtcbiAgICAgIGlzRGVmYXVsdERlc2MgPyBvdGhlck9iamVjdFtwcm9wTmFtZV0gPSBkZXNjLnZhbHVlIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KG90aGVyT2JqZWN0LCBwcm9wTmFtZSwgZGVzYyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBbLi4ub2JqZWN0cywgb3RoZXJPYmplY3RdO1xufVxuY29uc3QgbmFycm93ZWRFcnJvciA9IChuYW1lKSA9PiBgU3RhbGUgcmVhZCBmcm9tIDwke25hbWV9Pi5gO1xuZnVuY3Rpb24gRm9yKHByb3BzKSB7XG4gIGNvbnN0IGZhbGxiYWNrID0gXCJmYWxsYmFja1wiIGluIHByb3BzICYmIHtcbiAgICBmYWxsYmFjazogKCkgPT4gcHJvcHMuZmFsbGJhY2tcbiAgfTtcbiAgcmV0dXJuIGNyZWF0ZU1lbW8obWFwQXJyYXkoKCkgPT4gcHJvcHMuZWFjaCwgcHJvcHMuY2hpbGRyZW4sIGZhbGxiYWNrIHx8IHZvaWQgMCkpO1xufVxuZnVuY3Rpb24gU2hvdyhwcm9wcykge1xuICBjb25zdCBrZXllZCA9IHByb3BzLmtleWVkO1xuICBjb25zdCBjb25kaXRpb25WYWx1ZSA9IGNyZWF0ZU1lbW8oKCkgPT4gcHJvcHMud2hlbiwgdm9pZCAwLCB2b2lkIDApO1xuICBjb25zdCBjb25kaXRpb24gPSBrZXllZCA/IGNvbmRpdGlvblZhbHVlIDogY3JlYXRlTWVtbyhjb25kaXRpb25WYWx1ZSwgdm9pZCAwLCB7XG4gICAgZXF1YWxzOiAoYTIsIGIpID0+ICFhMiA9PT0gIWJcbiAgfSk7XG4gIHJldHVybiBjcmVhdGVNZW1vKCgpID0+IHtcbiAgICBjb25zdCBjMiA9IGNvbmRpdGlvbigpO1xuICAgIGlmIChjMikge1xuICAgICAgY29uc3QgY2hpbGQgPSBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIGNvbnN0IGZuID0gdHlwZW9mIGNoaWxkID09PSBcImZ1bmN0aW9uXCIgJiYgY2hpbGQubGVuZ3RoID4gMDtcbiAgICAgIHJldHVybiBmbiA/IHVudHJhY2soKCkgPT4gY2hpbGQoa2V5ZWQgPyBjMiA6ICgpID0+IHtcbiAgICAgICAgaWYgKCF1bnRyYWNrKGNvbmRpdGlvbikpIHRocm93IG5hcnJvd2VkRXJyb3IoXCJTaG93XCIpO1xuICAgICAgICByZXR1cm4gY29uZGl0aW9uVmFsdWUoKTtcbiAgICAgIH0pKSA6IGNoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcHMuZmFsbGJhY2s7XG4gIH0sIHZvaWQgMCwgdm9pZCAwKTtcbn1cbmZ1bmN0aW9uIFN3aXRjaChwcm9wcykge1xuICBjb25zdCBjaHMgPSBjaGlsZHJlbigoKSA9PiBwcm9wcy5jaGlsZHJlbik7XG4gIGNvbnN0IHN3aXRjaEZ1bmMgPSBjcmVhdGVNZW1vKCgpID0+IHtcbiAgICBjb25zdCBjaCA9IGNocygpO1xuICAgIGNvbnN0IG1wcyA9IEFycmF5LmlzQXJyYXkoY2gpID8gY2ggOiBbY2hdO1xuICAgIGxldCBmdW5jID0gKCkgPT4gdm9pZCAwO1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBtcHMubGVuZ3RoOyBpMisrKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGkyO1xuICAgICAgY29uc3QgbXAgPSBtcHNbaTJdO1xuICAgICAgY29uc3QgcHJldkZ1bmMgPSBmdW5jO1xuICAgICAgY29uc3QgY29uZGl0aW9uVmFsdWUgPSBjcmVhdGVNZW1vKCgpID0+IHByZXZGdW5jKCkgPyB2b2lkIDAgOiBtcC53aGVuLCB2b2lkIDAsIHZvaWQgMCk7XG4gICAgICBjb25zdCBjb25kaXRpb24gPSBtcC5rZXllZCA/IGNvbmRpdGlvblZhbHVlIDogY3JlYXRlTWVtbyhjb25kaXRpb25WYWx1ZSwgdm9pZCAwLCB7XG4gICAgICAgIGVxdWFsczogKGEyLCBiKSA9PiAhYTIgPT09ICFiXG4gICAgICB9KTtcbiAgICAgIGZ1bmMgPSAoKSA9PiBwcmV2RnVuYygpIHx8IChjb25kaXRpb24oKSA/IFtpbmRleCwgY29uZGl0aW9uVmFsdWUsIG1wXSA6IHZvaWQgMCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jO1xuICB9KTtcbiAgcmV0dXJuIGNyZWF0ZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHNlbCA9IHN3aXRjaEZ1bmMoKSgpO1xuICAgIGlmICghc2VsKSByZXR1cm4gcHJvcHMuZmFsbGJhY2s7XG4gICAgY29uc3QgW2luZGV4LCBjb25kaXRpb25WYWx1ZSwgbXBdID0gc2VsO1xuICAgIGNvbnN0IGNoaWxkID0gbXAuY2hpbGRyZW47XG4gICAgY29uc3QgZm4gPSB0eXBlb2YgY2hpbGQgPT09IFwiZnVuY3Rpb25cIiAmJiBjaGlsZC5sZW5ndGggPiAwO1xuICAgIHJldHVybiBmbiA/IHVudHJhY2soKCkgPT4gY2hpbGQobXAua2V5ZWQgPyBjb25kaXRpb25WYWx1ZSgpIDogKCkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGlmICgoKF9hMiA9IHVudHJhY2soc3dpdGNoRnVuYykoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMlswXSkgIT09IGluZGV4KSB0aHJvdyBuYXJyb3dlZEVycm9yKFwiTWF0Y2hcIik7XG4gICAgICByZXR1cm4gY29uZGl0aW9uVmFsdWUoKTtcbiAgICB9KSkgOiBjaGlsZDtcbiAgfSwgdm9pZCAwLCB2b2lkIDApO1xufVxuZnVuY3Rpb24gTWF0Y2gocHJvcHMpIHtcbiAgcmV0dXJuIHByb3BzO1xufVxuY29uc3QgYm9vbGVhbnMgPSBbXCJhbGxvd2Z1bGxzY3JlZW5cIiwgXCJhc3luY1wiLCBcImF1dG9mb2N1c1wiLCBcImF1dG9wbGF5XCIsIFwiY2hlY2tlZFwiLCBcImNvbnRyb2xzXCIsIFwiZGVmYXVsdFwiLCBcImRpc2FibGVkXCIsIFwiZm9ybW5vdmFsaWRhdGVcIiwgXCJoaWRkZW5cIiwgXCJpbmRldGVybWluYXRlXCIsIFwiaW5lcnRcIiwgXCJpc21hcFwiLCBcImxvb3BcIiwgXCJtdWx0aXBsZVwiLCBcIm11dGVkXCIsIFwibm9tb2R1bGVcIiwgXCJub3ZhbGlkYXRlXCIsIFwib3BlblwiLCBcInBsYXlzaW5saW5lXCIsIFwicmVhZG9ubHlcIiwgXCJyZXF1aXJlZFwiLCBcInJldmVyc2VkXCIsIFwic2VhbWxlc3NcIiwgXCJzZWxlY3RlZFwiXTtcbmNvbnN0IFByb3BlcnRpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJjbGFzc05hbWVcIiwgXCJ2YWx1ZVwiLCBcInJlYWRPbmx5XCIsIFwibm9WYWxpZGF0ZVwiLCBcImZvcm1Ob1ZhbGlkYXRlXCIsIFwiaXNNYXBcIiwgXCJub01vZHVsZVwiLCBcInBsYXlzSW5saW5lXCIsIC4uLmJvb2xlYW5zXSk7XG5jb25zdCBDaGlsZFByb3BlcnRpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJpbm5lckhUTUxcIiwgXCJ0ZXh0Q29udGVudFwiLCBcImlubmVyVGV4dFwiLCBcImNoaWxkcmVuXCJdKTtcbmNvbnN0IEFsaWFzZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmFzc2lnbigvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICBjbGFzc05hbWU6IFwiY2xhc3NcIixcbiAgaHRtbEZvcjogXCJmb3JcIlxufSk7XG5jb25zdCBQcm9wQWxpYXNlcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuYXNzaWduKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gIGNsYXNzOiBcImNsYXNzTmFtZVwiLFxuICBub3ZhbGlkYXRlOiB7XG4gICAgJDogXCJub1ZhbGlkYXRlXCIsXG4gICAgRk9STTogMVxuICB9LFxuICBmb3Jtbm92YWxpZGF0ZToge1xuICAgICQ6IFwiZm9ybU5vVmFsaWRhdGVcIixcbiAgICBCVVRUT046IDEsXG4gICAgSU5QVVQ6IDFcbiAgfSxcbiAgaXNtYXA6IHtcbiAgICAkOiBcImlzTWFwXCIsXG4gICAgSU1HOiAxXG4gIH0sXG4gIG5vbW9kdWxlOiB7XG4gICAgJDogXCJub01vZHVsZVwiLFxuICAgIFNDUklQVDogMVxuICB9LFxuICBwbGF5c2lubGluZToge1xuICAgICQ6IFwicGxheXNJbmxpbmVcIixcbiAgICBWSURFTzogMVxuICB9LFxuICByZWFkb25seToge1xuICAgICQ6IFwicmVhZE9ubHlcIixcbiAgICBJTlBVVDogMSxcbiAgICBURVhUQVJFQTogMVxuICB9XG59KTtcbmZ1bmN0aW9uIGdldFByb3BBbGlhcyhwcm9wLCB0YWdOYW1lKSB7XG4gIGNvbnN0IGEyID0gUHJvcEFsaWFzZXNbcHJvcF07XG4gIHJldHVybiB0eXBlb2YgYTIgPT09IFwib2JqZWN0XCIgPyBhMlt0YWdOYW1lXSA/IGEyW1wiJFwiXSA6IHZvaWQgMCA6IGEyO1xufVxuY29uc3QgRGVsZWdhdGVkRXZlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiYmVmb3JlaW5wdXRcIiwgXCJjbGlja1wiLCBcImRibGNsaWNrXCIsIFwiY29udGV4dG1lbnVcIiwgXCJmb2N1c2luXCIsIFwiZm9jdXNvdXRcIiwgXCJpbnB1dFwiLCBcImtleWRvd25cIiwgXCJrZXl1cFwiLCBcIm1vdXNlZG93blwiLCBcIm1vdXNlbW92ZVwiLCBcIm1vdXNlb3V0XCIsIFwibW91c2VvdmVyXCIsIFwibW91c2V1cFwiLCBcInBvaW50ZXJkb3duXCIsIFwicG9pbnRlcm1vdmVcIiwgXCJwb2ludGVyb3V0XCIsIFwicG9pbnRlcm92ZXJcIiwgXCJwb2ludGVydXBcIiwgXCJ0b3VjaGVuZFwiLCBcInRvdWNobW92ZVwiLCBcInRvdWNoc3RhcnRcIl0pO1xuY29uc3QgU1ZHRWxlbWVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiYWx0R2x5cGhcIixcbiAgXCJhbHRHbHlwaERlZlwiLFxuICBcImFsdEdseXBoSXRlbVwiLFxuICBcImFuaW1hdGVcIixcbiAgXCJhbmltYXRlQ29sb3JcIixcbiAgXCJhbmltYXRlTW90aW9uXCIsXG4gIFwiYW5pbWF0ZVRyYW5zZm9ybVwiLFxuICBcImNpcmNsZVwiLFxuICBcImNsaXBQYXRoXCIsXG4gIFwiY29sb3ItcHJvZmlsZVwiLFxuICBcImN1cnNvclwiLFxuICBcImRlZnNcIixcbiAgXCJkZXNjXCIsXG4gIFwiZWxsaXBzZVwiLFxuICBcImZlQmxlbmRcIixcbiAgXCJmZUNvbG9yTWF0cml4XCIsXG4gIFwiZmVDb21wb25lbnRUcmFuc2ZlclwiLFxuICBcImZlQ29tcG9zaXRlXCIsXG4gIFwiZmVDb252b2x2ZU1hdHJpeFwiLFxuICBcImZlRGlmZnVzZUxpZ2h0aW5nXCIsXG4gIFwiZmVEaXNwbGFjZW1lbnRNYXBcIixcbiAgXCJmZURpc3RhbnRMaWdodFwiLFxuICBcImZlRHJvcFNoYWRvd1wiLFxuICBcImZlRmxvb2RcIixcbiAgXCJmZUZ1bmNBXCIsXG4gIFwiZmVGdW5jQlwiLFxuICBcImZlRnVuY0dcIixcbiAgXCJmZUZ1bmNSXCIsXG4gIFwiZmVHYXVzc2lhbkJsdXJcIixcbiAgXCJmZUltYWdlXCIsXG4gIFwiZmVNZXJnZVwiLFxuICBcImZlTWVyZ2VOb2RlXCIsXG4gIFwiZmVNb3JwaG9sb2d5XCIsXG4gIFwiZmVPZmZzZXRcIixcbiAgXCJmZVBvaW50TGlnaHRcIixcbiAgXCJmZVNwZWN1bGFyTGlnaHRpbmdcIixcbiAgXCJmZVNwb3RMaWdodFwiLFxuICBcImZlVGlsZVwiLFxuICBcImZlVHVyYnVsZW5jZVwiLFxuICBcImZpbHRlclwiLFxuICBcImZvbnRcIixcbiAgXCJmb250LWZhY2VcIixcbiAgXCJmb250LWZhY2UtZm9ybWF0XCIsXG4gIFwiZm9udC1mYWNlLW5hbWVcIixcbiAgXCJmb250LWZhY2Utc3JjXCIsXG4gIFwiZm9udC1mYWNlLXVyaVwiLFxuICBcImZvcmVpZ25PYmplY3RcIixcbiAgXCJnXCIsXG4gIFwiZ2x5cGhcIixcbiAgXCJnbHlwaFJlZlwiLFxuICBcImhrZXJuXCIsXG4gIFwiaW1hZ2VcIixcbiAgXCJsaW5lXCIsXG4gIFwibGluZWFyR3JhZGllbnRcIixcbiAgXCJtYXJrZXJcIixcbiAgXCJtYXNrXCIsXG4gIFwibWV0YWRhdGFcIixcbiAgXCJtaXNzaW5nLWdseXBoXCIsXG4gIFwibXBhdGhcIixcbiAgXCJwYXRoXCIsXG4gIFwicGF0dGVyblwiLFxuICBcInBvbHlnb25cIixcbiAgXCJwb2x5bGluZVwiLFxuICBcInJhZGlhbEdyYWRpZW50XCIsXG4gIFwicmVjdFwiLFxuICBcInNldFwiLFxuICBcInN0b3BcIixcbiAgXCJzdmdcIixcbiAgXCJzd2l0Y2hcIixcbiAgXCJzeW1ib2xcIixcbiAgXCJ0ZXh0XCIsXG4gIFwidGV4dFBhdGhcIixcbiAgXCJ0cmVmXCIsXG4gIFwidHNwYW5cIixcbiAgXCJ1c2VcIixcbiAgXCJ2aWV3XCIsXG4gIFwidmtlcm5cIlxuXSk7XG5jb25zdCBTVkdOYW1lc3BhY2UgPSB7XG4gIHhsaW5rOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgeG1sOiBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiXG59O1xuY29uc3QgbWVtbyA9IChmbikgPT4gY3JlYXRlTWVtbygoKSA9PiBmbigpKTtcbmZ1bmN0aW9uIHJlY29uY2lsZUFycmF5cyhwYXJlbnROb2RlLCBhMiwgYikge1xuICBsZXQgYkxlbmd0aCA9IGIubGVuZ3RoLCBhRW5kID0gYTIubGVuZ3RoLCBiRW5kID0gYkxlbmd0aCwgYVN0YXJ0ID0gMCwgYlN0YXJ0ID0gMCwgYWZ0ZXIgPSBhMlthRW5kIC0gMV0ubmV4dFNpYmxpbmcsIG1hcCA9IG51bGw7XG4gIHdoaWxlIChhU3RhcnQgPCBhRW5kIHx8IGJTdGFydCA8IGJFbmQpIHtcbiAgICBpZiAoYTJbYVN0YXJ0XSA9PT0gYltiU3RhcnRdKSB7XG4gICAgICBhU3RhcnQrKztcbiAgICAgIGJTdGFydCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHdoaWxlIChhMlthRW5kIC0gMV0gPT09IGJbYkVuZCAtIDFdKSB7XG4gICAgICBhRW5kLS07XG4gICAgICBiRW5kLS07XG4gICAgfVxuICAgIGlmIChhRW5kID09PSBhU3RhcnQpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBiRW5kIDwgYkxlbmd0aCA/IGJTdGFydCA/IGJbYlN0YXJ0IC0gMV0ubmV4dFNpYmxpbmcgOiBiW2JFbmQgLSBiU3RhcnRdIDogYWZ0ZXI7XG4gICAgICB3aGlsZSAoYlN0YXJ0IDwgYkVuZCkgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYltiU3RhcnQrK10sIG5vZGUpO1xuICAgIH0gZWxzZSBpZiAoYkVuZCA9PT0gYlN0YXJ0KSB7XG4gICAgICB3aGlsZSAoYVN0YXJ0IDwgYUVuZCkge1xuICAgICAgICBpZiAoIW1hcCB8fCAhbWFwLmhhcyhhMlthU3RhcnRdKSkgYTJbYVN0YXJ0XS5yZW1vdmUoKTtcbiAgICAgICAgYVN0YXJ0Kys7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhMlthU3RhcnRdID09PSBiW2JFbmQgLSAxXSAmJiBiW2JTdGFydF0gPT09IGEyW2FFbmQgLSAxXSkge1xuICAgICAgY29uc3Qgbm9kZSA9IGEyWy0tYUVuZF0ubmV4dFNpYmxpbmc7XG4gICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShiW2JTdGFydCsrXSwgYTJbYVN0YXJ0KytdLm5leHRTaWJsaW5nKTtcbiAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGJbLS1iRW5kXSwgbm9kZSk7XG4gICAgICBhMlthRW5kXSA9IGJbYkVuZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghbWFwKSB7XG4gICAgICAgIG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGxldCBpMiA9IGJTdGFydDtcbiAgICAgICAgd2hpbGUgKGkyIDwgYkVuZCkgbWFwLnNldChiW2kyXSwgaTIrKyk7XG4gICAgICB9XG4gICAgICBjb25zdCBpbmRleCA9IG1hcC5nZXQoYTJbYVN0YXJ0XSk7XG4gICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICBpZiAoYlN0YXJ0IDwgaW5kZXggJiYgaW5kZXggPCBiRW5kKSB7XG4gICAgICAgICAgbGV0IGkyID0gYVN0YXJ0LCBzZXF1ZW5jZSA9IDEsIHQyO1xuICAgICAgICAgIHdoaWxlICgrK2kyIDwgYUVuZCAmJiBpMiA8IGJFbmQpIHtcbiAgICAgICAgICAgIGlmICgodDIgPSBtYXAuZ2V0KGEyW2kyXSkpID09IG51bGwgfHwgdDIgIT09IGluZGV4ICsgc2VxdWVuY2UpIGJyZWFrO1xuICAgICAgICAgICAgc2VxdWVuY2UrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlcXVlbmNlID4gaW5kZXggLSBiU3RhcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBhMlthU3RhcnRdO1xuICAgICAgICAgICAgd2hpbGUgKGJTdGFydCA8IGluZGV4KSBwYXJlbnROb2RlLmluc2VydEJlZm9yZShiW2JTdGFydCsrXSwgbm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGJbYlN0YXJ0KytdLCBhMlthU3RhcnQrK10pO1xuICAgICAgICB9IGVsc2UgYVN0YXJ0Kys7XG4gICAgICB9IGVsc2UgYTJbYVN0YXJ0KytdLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxufVxuY29uc3QgJCRFVkVOVFMgPSBcIl8kRFhfREVMRUdBVEVcIjtcbmZ1bmN0aW9uIHJlbmRlcihjb2RlLCBlbGVtZW50LCBpbml0LCBvcHRpb25zID0ge30pIHtcbiAgbGV0IGRpc3Bvc2VyO1xuICBjcmVhdGVSb290KChkaXNwb3NlMikgPT4ge1xuICAgIGRpc3Bvc2VyID0gZGlzcG9zZTI7XG4gICAgZWxlbWVudCA9PT0gZG9jdW1lbnQgPyBjb2RlKCkgOiBpbnNlcnQoZWxlbWVudCwgY29kZSgpLCBlbGVtZW50LmZpcnN0Q2hpbGQgPyBudWxsIDogdm9pZCAwLCBpbml0KTtcbiAgfSwgb3B0aW9ucy5vd25lcik7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZGlzcG9zZXIoKTtcbiAgICBlbGVtZW50LnRleHRDb250ZW50ID0gXCJcIjtcbiAgfTtcbn1cbmZ1bmN0aW9uIHRlbXBsYXRlJDEoaHRtbCwgaXNJbXBvcnROb2RlLCBpc1NWRywgaXNNYXRoTUwpIHtcbiAgbGV0IG5vZGU7XG4gIGNvbnN0IGNyZWF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCB0MiA9IGlzTWF0aE1MID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLCBcInRlbXBsYXRlXCIpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuICAgIHQyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIGlzU1ZHID8gdDIuY29udGVudC5maXJzdENoaWxkLmZpcnN0Q2hpbGQgOiBpc01hdGhNTCA/IHQyLmZpcnN0Q2hpbGQgOiB0Mi5jb250ZW50LmZpcnN0Q2hpbGQ7XG4gIH07XG4gIGNvbnN0IGZuID0gaXNJbXBvcnROb2RlID8gKCkgPT4gdW50cmFjaygoKSA9PiBkb2N1bWVudC5pbXBvcnROb2RlKG5vZGUgfHwgKG5vZGUgPSBjcmVhdGUoKSksIHRydWUpKSA6ICgpID0+IChub2RlIHx8IChub2RlID0gY3JlYXRlKCkpKS5jbG9uZU5vZGUodHJ1ZSk7XG4gIGZuLmNsb25lTm9kZSA9IGZuO1xuICByZXR1cm4gZm47XG59XG5mdW5jdGlvbiBkZWxlZ2F0ZUV2ZW50cyhldmVudE5hbWVzLCBkb2N1bWVudDIgPSB3aW5kb3cuZG9jdW1lbnQpIHtcbiAgY29uc3QgZTIgPSBkb2N1bWVudDJbJCRFVkVOVFNdIHx8IChkb2N1bWVudDJbJCRFVkVOVFNdID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gIGZvciAobGV0IGkyID0gMCwgbDIgPSBldmVudE5hbWVzLmxlbmd0aDsgaTIgPCBsMjsgaTIrKykge1xuICAgIGNvbnN0IG5hbWUgPSBldmVudE5hbWVzW2kyXTtcbiAgICBpZiAoIWUyLmhhcyhuYW1lKSkge1xuICAgICAgZTIuYWRkKG5hbWUpO1xuICAgICAgZG9jdW1lbnQyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZShub2RlLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIGVsc2Ugbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gc2V0QXR0cmlidXRlTlMobm9kZSwgbmFtZXNwYWNlLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkgbm9kZS5yZW1vdmVBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUpO1xuICBlbHNlIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBzZXRCb29sQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIHZhbHVlID8gbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgXCJcIikgOiBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbn1cbmZ1bmN0aW9uIGNsYXNzTmFtZShub2RlLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgZWxzZSBub2RlLmNsYXNzTmFtZSA9IHZhbHVlO1xufVxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBuYW1lLCBoYW5kbGVyLCBkZWxlZ2F0ZSkge1xuICBpZiAoZGVsZWdhdGUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgbm9kZVtgJCQke25hbWV9YF0gPSBoYW5kbGVyWzBdO1xuICAgICAgbm9kZVtgJCQke25hbWV9RGF0YWBdID0gaGFuZGxlclsxXTtcbiAgICB9IGVsc2Ugbm9kZVtgJCQke25hbWV9YF0gPSBoYW5kbGVyO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICBjb25zdCBoYW5kbGVyRm4gPSBoYW5kbGVyWzBdO1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyWzBdID0gKGUyKSA9PiBoYW5kbGVyRm4uY2FsbChub2RlLCBoYW5kbGVyWzFdLCBlMikpO1xuICB9IGVsc2Ugbm9kZS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIHR5cGVvZiBoYW5kbGVyICE9PSBcImZ1bmN0aW9uXCIgJiYgaGFuZGxlcik7XG59XG5mdW5jdGlvbiBjbGFzc0xpc3Qobm9kZSwgdmFsdWUsIHByZXYgPSB7fSkge1xuICBjb25zdCBjbGFzc0tleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSB8fCB7fSksIHByZXZLZXlzID0gT2JqZWN0LmtleXMocHJldik7XG4gIGxldCBpMiwgbGVuO1xuICBmb3IgKGkyID0gMCwgbGVuID0gcHJldktleXMubGVuZ3RoOyBpMiA8IGxlbjsgaTIrKykge1xuICAgIGNvbnN0IGtleSA9IHByZXZLZXlzW2kyXTtcbiAgICBpZiAoIWtleSB8fCBrZXkgPT09IFwidW5kZWZpbmVkXCIgfHwgdmFsdWVba2V5XSkgY29udGludWU7XG4gICAgdG9nZ2xlQ2xhc3NLZXkobm9kZSwga2V5LCBmYWxzZSk7XG4gICAgZGVsZXRlIHByZXZba2V5XTtcbiAgfVxuICBmb3IgKGkyID0gMCwgbGVuID0gY2xhc3NLZXlzLmxlbmd0aDsgaTIgPCBsZW47IGkyKyspIHtcbiAgICBjb25zdCBrZXkgPSBjbGFzc0tleXNbaTJdLCBjbGFzc1ZhbHVlID0gISF2YWx1ZVtrZXldO1xuICAgIGlmICgha2V5IHx8IGtleSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBwcmV2W2tleV0gPT09IGNsYXNzVmFsdWUgfHwgIWNsYXNzVmFsdWUpIGNvbnRpbnVlO1xuICAgIHRvZ2dsZUNsYXNzS2V5KG5vZGUsIGtleSwgdHJ1ZSk7XG4gICAgcHJldltrZXldID0gY2xhc3NWYWx1ZTtcbiAgfVxuICByZXR1cm4gcHJldjtcbn1cbmZ1bmN0aW9uIHN0eWxlKG5vZGUsIHZhbHVlLCBwcmV2KSB7XG4gIGlmICghdmFsdWUpIHJldHVybiBwcmV2ID8gc2V0QXR0cmlidXRlKG5vZGUsIFwic3R5bGVcIikgOiB2YWx1ZTtcbiAgY29uc3Qgbm9kZVN0eWxlID0gbm9kZS5zdHlsZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIG5vZGVTdHlsZS5jc3NUZXh0ID0gdmFsdWU7XG4gIHR5cGVvZiBwcmV2ID09PSBcInN0cmluZ1wiICYmIChub2RlU3R5bGUuY3NzVGV4dCA9IHByZXYgPSB2b2lkIDApO1xuICBwcmV2IHx8IChwcmV2ID0ge30pO1xuICB2YWx1ZSB8fCAodmFsdWUgPSB7fSk7XG4gIGxldCB2LCBzMjtcbiAgZm9yIChzMiBpbiBwcmV2KSB7XG4gICAgdmFsdWVbczJdID09IG51bGwgJiYgbm9kZVN0eWxlLnJlbW92ZVByb3BlcnR5KHMyKTtcbiAgICBkZWxldGUgcHJldltzMl07XG4gIH1cbiAgZm9yIChzMiBpbiB2YWx1ZSkge1xuICAgIHYgPSB2YWx1ZVtzMl07XG4gICAgaWYgKHYgIT09IHByZXZbczJdKSB7XG4gICAgICBub2RlU3R5bGUuc2V0UHJvcGVydHkoczIsIHYpO1xuICAgICAgcHJldltzMl0gPSB2O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJldjtcbn1cbmZ1bmN0aW9uIHNwcmVhZChub2RlLCBwcm9wcyA9IHt9LCBpc1NWRywgc2tpcENoaWxkcmVuKSB7XG4gIGNvbnN0IHByZXZQcm9wcyA9IHt9O1xuICB7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KCgpID0+IHByZXZQcm9wcy5jaGlsZHJlbiA9IGluc2VydEV4cHJlc3Npb24obm9kZSwgcHJvcHMuY2hpbGRyZW4sIHByZXZQcm9wcy5jaGlsZHJlbikpO1xuICB9XG4gIGNyZWF0ZVJlbmRlckVmZmVjdCgoKSA9PiB0eXBlb2YgcHJvcHMucmVmID09PSBcImZ1bmN0aW9uXCIgJiYgdXNlKHByb3BzLnJlZiwgbm9kZSkpO1xuICBjcmVhdGVSZW5kZXJFZmZlY3QoKCkgPT4gYXNzaWduKG5vZGUsIHByb3BzLCBpc1NWRywgdHJ1ZSwgcHJldlByb3BzLCB0cnVlKSk7XG4gIHJldHVybiBwcmV2UHJvcHM7XG59XG5mdW5jdGlvbiB1c2UoZm4sIGVsZW1lbnQsIGFyZykge1xuICByZXR1cm4gdW50cmFjaygoKSA9PiBmbihlbGVtZW50LCBhcmcpKTtcbn1cbmZ1bmN0aW9uIGluc2VydChwYXJlbnQsIGFjY2Vzc29yLCBtYXJrZXIsIGluaXRpYWwpIHtcbiAgaWYgKG1hcmtlciAhPT0gdm9pZCAwICYmICFpbml0aWFsKSBpbml0aWFsID0gW107XG4gIGlmICh0eXBlb2YgYWNjZXNzb3IgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGluc2VydEV4cHJlc3Npb24ocGFyZW50LCBhY2Nlc3NvciwgaW5pdGlhbCwgbWFya2VyKTtcbiAgY3JlYXRlUmVuZGVyRWZmZWN0KChjdXJyZW50KSA9PiBpbnNlcnRFeHByZXNzaW9uKHBhcmVudCwgYWNjZXNzb3IoKSwgY3VycmVudCwgbWFya2VyKSwgaW5pdGlhbCk7XG59XG5mdW5jdGlvbiBhc3NpZ24obm9kZSwgcHJvcHMsIGlzU1ZHLCBza2lwQ2hpbGRyZW4sIHByZXZQcm9wcyA9IHt9LCBza2lwUmVmID0gZmFsc2UpIHtcbiAgcHJvcHMgfHwgKHByb3BzID0ge30pO1xuICBmb3IgKGNvbnN0IHByb3AgaW4gcHJldlByb3BzKSB7XG4gICAgaWYgKCEocHJvcCBpbiBwcm9wcykpIHtcbiAgICAgIGlmIChwcm9wID09PSBcImNoaWxkcmVuXCIpIGNvbnRpbnVlO1xuICAgICAgcHJldlByb3BzW3Byb3BdID0gYXNzaWduUHJvcChub2RlLCBwcm9wLCBudWxsLCBwcmV2UHJvcHNbcHJvcF0sIGlzU1ZHLCBza2lwUmVmLCBwcm9wcyk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wcykge1xuICAgIGlmIChwcm9wID09PSBcImNoaWxkcmVuXCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHByb3BzW3Byb3BdO1xuICAgIHByZXZQcm9wc1twcm9wXSA9IGFzc2lnblByb3Aobm9kZSwgcHJvcCwgdmFsdWUsIHByZXZQcm9wc1twcm9wXSwgaXNTVkcsIHNraXBSZWYsIHByb3BzKTtcbiAgfVxufVxuZnVuY3Rpb24gdG9Qcm9wZXJ0eU5hbWUobmFtZSkge1xuICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oW2Etel0pL2csIChfLCB3KSA9PiB3LnRvVXBwZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gdG9nZ2xlQ2xhc3NLZXkobm9kZSwga2V5LCB2YWx1ZSkge1xuICBjb25zdCBjbGFzc05hbWVzID0ga2V5LnRyaW0oKS5zcGxpdCgvXFxzKy8pO1xuICBmb3IgKGxldCBpMiA9IDAsIG5hbWVMZW4gPSBjbGFzc05hbWVzLmxlbmd0aDsgaTIgPCBuYW1lTGVuOyBpMisrKSBub2RlLmNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lc1tpMl0sIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGFzc2lnblByb3Aobm9kZSwgcHJvcCwgdmFsdWUsIHByZXYsIGlzU1ZHLCBza2lwUmVmLCBwcm9wcykge1xuICBsZXQgaXNDRSwgaXNQcm9wLCBpc0NoaWxkUHJvcCwgcHJvcEFsaWFzLCBmb3JjZVByb3A7XG4gIGlmIChwcm9wID09PSBcInN0eWxlXCIpIHJldHVybiBzdHlsZShub2RlLCB2YWx1ZSwgcHJldik7XG4gIGlmIChwcm9wID09PSBcImNsYXNzTGlzdFwiKSByZXR1cm4gY2xhc3NMaXN0KG5vZGUsIHZhbHVlLCBwcmV2KTtcbiAgaWYgKHZhbHVlID09PSBwcmV2KSByZXR1cm4gcHJldjtcbiAgaWYgKHByb3AgPT09IFwicmVmXCIpIHtcbiAgICBpZiAoIXNraXBSZWYpIHZhbHVlKG5vZGUpO1xuICB9IGVsc2UgaWYgKHByb3Auc2xpY2UoMCwgMykgPT09IFwib246XCIpIHtcbiAgICBjb25zdCBlMiA9IHByb3Auc2xpY2UoMyk7XG4gICAgcHJldiAmJiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZTIsIHByZXYsIHR5cGVvZiBwcmV2ICE9PSBcImZ1bmN0aW9uXCIgJiYgcHJldik7XG4gICAgdmFsdWUgJiYgbm9kZS5hZGRFdmVudExpc3RlbmVyKGUyLCB2YWx1ZSwgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIgJiYgdmFsdWUpO1xuICB9IGVsc2UgaWYgKHByb3Auc2xpY2UoMCwgMTApID09PSBcIm9uY2FwdHVyZTpcIikge1xuICAgIGNvbnN0IGUyID0gcHJvcC5zbGljZSgxMCk7XG4gICAgcHJldiAmJiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZTIsIHByZXYsIHRydWUpO1xuICAgIHZhbHVlICYmIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihlMiwgdmFsdWUsIHRydWUpO1xuICB9IGVsc2UgaWYgKHByb3Auc2xpY2UoMCwgMikgPT09IFwib25cIikge1xuICAgIGNvbnN0IG5hbWUgPSBwcm9wLnNsaWNlKDIpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgZGVsZWdhdGUgPSBEZWxlZ2F0ZWRFdmVudHMuaGFzKG5hbWUpO1xuICAgIGlmICghZGVsZWdhdGUgJiYgcHJldikge1xuICAgICAgY29uc3QgaDIgPSBBcnJheS5pc0FycmF5KHByZXYpID8gcHJldlswXSA6IHByZXY7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaDIpO1xuICAgIH1cbiAgICBpZiAoZGVsZWdhdGUgfHwgdmFsdWUpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgbmFtZSwgdmFsdWUsIGRlbGVnYXRlKTtcbiAgICAgIGRlbGVnYXRlICYmIGRlbGVnYXRlRXZlbnRzKFtuYW1lXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHByb3Auc2xpY2UoMCwgNSkgPT09IFwiYXR0cjpcIikge1xuICAgIHNldEF0dHJpYnV0ZShub2RlLCBwcm9wLnNsaWNlKDUpLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAocHJvcC5zbGljZSgwLCA1KSA9PT0gXCJib29sOlwiKSB7XG4gICAgc2V0Qm9vbEF0dHJpYnV0ZShub2RlLCBwcm9wLnNsaWNlKDUpLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoKGZvcmNlUHJvcCA9IHByb3Auc2xpY2UoMCwgNSkgPT09IFwicHJvcDpcIikgfHwgKGlzQ2hpbGRQcm9wID0gQ2hpbGRQcm9wZXJ0aWVzLmhhcyhwcm9wKSkgfHwgIWlzU1ZHICYmICgocHJvcEFsaWFzID0gZ2V0UHJvcEFsaWFzKHByb3AsIG5vZGUudGFnTmFtZSkpIHx8IChpc1Byb3AgPSBQcm9wZXJ0aWVzLmhhcyhwcm9wKSkpIHx8IChpc0NFID0gbm9kZS5ub2RlTmFtZS5pbmNsdWRlcyhcIi1cIikgfHwgXCJpc1wiIGluIHByb3BzKSkge1xuICAgIGlmIChmb3JjZVByb3ApIHtcbiAgICAgIHByb3AgPSBwcm9wLnNsaWNlKDUpO1xuICAgICAgaXNQcm9wID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByb3AgPT09IFwiY2xhc3NcIiB8fCBwcm9wID09PSBcImNsYXNzTmFtZVwiKSBjbGFzc05hbWUobm9kZSwgdmFsdWUpO1xuICAgIGVsc2UgaWYgKGlzQ0UgJiYgIWlzUHJvcCAmJiAhaXNDaGlsZFByb3ApIG5vZGVbdG9Qcm9wZXJ0eU5hbWUocHJvcCldID0gdmFsdWU7XG4gICAgZWxzZSBub2RlW3Byb3BBbGlhcyB8fCBwcm9wXSA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5zID0gaXNTVkcgJiYgcHJvcC5pbmRleE9mKFwiOlwiKSA+IC0xICYmIFNWR05hbWVzcGFjZVtwcm9wLnNwbGl0KFwiOlwiKVswXV07XG4gICAgaWYgKG5zKSBzZXRBdHRyaWJ1dGVOUyhub2RlLCBucywgcHJvcCwgdmFsdWUpO1xuICAgIGVsc2Ugc2V0QXR0cmlidXRlKG5vZGUsIEFsaWFzZXNbcHJvcF0gfHwgcHJvcCwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGV2ZW50SGFuZGxlcihlMikge1xuICBsZXQgbm9kZSA9IGUyLnRhcmdldDtcbiAgY29uc3Qga2V5ID0gYCQkJHtlMi50eXBlfWA7XG4gIGNvbnN0IG9yaVRhcmdldCA9IGUyLnRhcmdldDtcbiAgY29uc3Qgb3JpQ3VycmVudFRhcmdldCA9IGUyLmN1cnJlbnRUYXJnZXQ7XG4gIGNvbnN0IHJldGFyZ2V0ID0gKHZhbHVlKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZTIsIFwidGFyZ2V0XCIsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWVcbiAgfSk7XG4gIGNvbnN0IGhhbmRsZU5vZGUgPSAoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlciA9IG5vZGVba2V5XTtcbiAgICBpZiAoaGFuZGxlciAmJiAhbm9kZS5kaXNhYmxlZCkge1xuICAgICAgY29uc3QgZGF0YSA9IG5vZGVbYCR7a2V5fURhdGFgXTtcbiAgICAgIGRhdGEgIT09IHZvaWQgMCA/IGhhbmRsZXIuY2FsbChub2RlLCBkYXRhLCBlMikgOiBoYW5kbGVyLmNhbGwobm9kZSwgZTIpO1xuICAgICAgaWYgKGUyLmNhbmNlbEJ1YmJsZSkgcmV0dXJuO1xuICAgIH1cbiAgICBub2RlLmhvc3QgJiYgdHlwZW9mIG5vZGUuaG9zdCAhPT0gXCJzdHJpbmdcIiAmJiAhbm9kZS5ob3N0Ll8kaG9zdCAmJiBub2RlLmNvbnRhaW5zKGUyLnRhcmdldCkgJiYgcmV0YXJnZXQobm9kZS5ob3N0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgY29uc3Qgd2Fsa1VwVHJlZSA9ICgpID0+IHtcbiAgICB3aGlsZSAoaGFuZGxlTm9kZSgpICYmIChub2RlID0gbm9kZS5fJGhvc3QgfHwgbm9kZS5wYXJlbnROb2RlIHx8IG5vZGUuaG9zdCkpIDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUyLCBcImN1cnJlbnRUYXJnZXRcIiwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gbm9kZSB8fCBkb2N1bWVudDtcbiAgICB9XG4gIH0pO1xuICBpZiAoZTIuY29tcG9zZWRQYXRoKSB7XG4gICAgY29uc3QgcGF0aCA9IGUyLmNvbXBvc2VkUGF0aCgpO1xuICAgIHJldGFyZ2V0KHBhdGhbMF0pO1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBwYXRoLmxlbmd0aCAtIDI7IGkyKyspIHtcbiAgICAgIG5vZGUgPSBwYXRoW2kyXTtcbiAgICAgIGlmICghaGFuZGxlTm9kZSgpKSBicmVhaztcbiAgICAgIGlmIChub2RlLl8kaG9zdCkge1xuICAgICAgICBub2RlID0gbm9kZS5fJGhvc3Q7XG4gICAgICAgIHdhbGtVcFRyZWUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5wYXJlbnROb2RlID09PSBvcmlDdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHdhbGtVcFRyZWUoKTtcbiAgcmV0YXJnZXQob3JpVGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGluc2VydEV4cHJlc3Npb24ocGFyZW50LCB2YWx1ZSwgY3VycmVudCwgbWFya2VyLCB1bndyYXBBcnJheSkge1xuICB3aGlsZSAodHlwZW9mIGN1cnJlbnQgPT09IFwiZnVuY3Rpb25cIikgY3VycmVudCA9IGN1cnJlbnQoKTtcbiAgaWYgKHZhbHVlID09PSBjdXJyZW50KSByZXR1cm4gY3VycmVudDtcbiAgY29uc3QgdDIgPSB0eXBlb2YgdmFsdWUsIG11bHRpID0gbWFya2VyICE9PSB2b2lkIDA7XG4gIHBhcmVudCA9IG11bHRpICYmIGN1cnJlbnRbMF0gJiYgY3VycmVudFswXS5wYXJlbnROb2RlIHx8IHBhcmVudDtcbiAgaWYgKHQyID09PSBcInN0cmluZ1wiIHx8IHQyID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKHQyID09PSBcIm51bWJlclwiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICBpZiAodmFsdWUgPT09IGN1cnJlbnQpIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBpZiAobXVsdGkpIHtcbiAgICAgIGxldCBub2RlID0gY3VycmVudFswXTtcbiAgICAgIGlmIChub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgbm9kZS5kYXRhICE9PSB2YWx1ZSAmJiAobm9kZS5kYXRhID0gdmFsdWUpO1xuICAgICAgfSBlbHNlIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSk7XG4gICAgICBjdXJyZW50ID0gY2xlYW5DaGlsZHJlbihwYXJlbnQsIGN1cnJlbnQsIG1hcmtlciwgbm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdXJyZW50ICE9PSBcIlwiICYmIHR5cGVvZiBjdXJyZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGN1cnJlbnQgPSBwYXJlbnQuZmlyc3RDaGlsZC5kYXRhID0gdmFsdWU7XG4gICAgICB9IGVsc2UgY3VycmVudCA9IHBhcmVudC50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2YWx1ZSA9PSBudWxsIHx8IHQyID09PSBcImJvb2xlYW5cIikge1xuICAgIGN1cnJlbnQgPSBjbGVhbkNoaWxkcmVuKHBhcmVudCwgY3VycmVudCwgbWFya2VyKTtcbiAgfSBlbHNlIGlmICh0MiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgIGxldCB2ID0gdmFsdWUoKTtcbiAgICAgIHdoaWxlICh0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiKSB2ID0gdigpO1xuICAgICAgY3VycmVudCA9IGluc2VydEV4cHJlc3Npb24ocGFyZW50LCB2LCBjdXJyZW50LCBtYXJrZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiBjdXJyZW50O1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICBjb25zdCBjdXJyZW50QXJyYXkgPSBjdXJyZW50ICYmIEFycmF5LmlzQXJyYXkoY3VycmVudCk7XG4gICAgaWYgKG5vcm1hbGl6ZUluY29taW5nQXJyYXkoYXJyYXksIHZhbHVlLCBjdXJyZW50LCB1bndyYXBBcnJheSkpIHtcbiAgICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoKSA9PiBjdXJyZW50ID0gaW5zZXJ0RXhwcmVzc2lvbihwYXJlbnQsIGFycmF5LCBjdXJyZW50LCBtYXJrZXIsIHRydWUpKTtcbiAgICAgIHJldHVybiAoKSA9PiBjdXJyZW50O1xuICAgIH1cbiAgICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICBjdXJyZW50ID0gY2xlYW5DaGlsZHJlbihwYXJlbnQsIGN1cnJlbnQsIG1hcmtlcik7XG4gICAgICBpZiAobXVsdGkpIHJldHVybiBjdXJyZW50O1xuICAgIH0gZWxzZSBpZiAoY3VycmVudEFycmF5KSB7XG4gICAgICBpZiAoY3VycmVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYXBwZW5kTm9kZXMocGFyZW50LCBhcnJheSwgbWFya2VyKTtcbiAgICAgIH0gZWxzZSByZWNvbmNpbGVBcnJheXMocGFyZW50LCBjdXJyZW50LCBhcnJheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQgJiYgY2xlYW5DaGlsZHJlbihwYXJlbnQpO1xuICAgICAgYXBwZW5kTm9kZXMocGFyZW50LCBhcnJheSk7XG4gICAgfVxuICAgIGN1cnJlbnQgPSBhcnJheTtcbiAgfSBlbHNlIGlmICh2YWx1ZS5ub2RlVHlwZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICBpZiAobXVsdGkpIHJldHVybiBjdXJyZW50ID0gY2xlYW5DaGlsZHJlbihwYXJlbnQsIGN1cnJlbnQsIG1hcmtlciwgdmFsdWUpO1xuICAgICAgY2xlYW5DaGlsZHJlbihwYXJlbnQsIGN1cnJlbnQsIG51bGwsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQgPT0gbnVsbCB8fCBjdXJyZW50ID09PSBcIlwiIHx8ICFwYXJlbnQuZmlyc3RDaGlsZCkge1xuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHZhbHVlKTtcbiAgICB9IGVsc2UgcGFyZW50LnJlcGxhY2VDaGlsZCh2YWx1ZSwgcGFyZW50LmZpcnN0Q2hpbGQpO1xuICAgIGN1cnJlbnQgPSB2YWx1ZTtcbiAgfSBlbHNlIDtcbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVJbmNvbWluZ0FycmF5KG5vcm1hbGl6ZWQsIGFycmF5LCBjdXJyZW50LCB1bndyYXAyKSB7XG4gIGxldCBkeW5hbWljID0gZmFsc2U7XG4gIGZvciAobGV0IGkyID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpMiA8IGxlbjsgaTIrKykge1xuICAgIGxldCBpdGVtID0gYXJyYXlbaTJdLCBwcmV2ID0gY3VycmVudCAmJiBjdXJyZW50W25vcm1hbGl6ZWQubGVuZ3RoXSwgdDI7XG4gICAgaWYgKGl0ZW0gPT0gbnVsbCB8fCBpdGVtID09PSB0cnVlIHx8IGl0ZW0gPT09IGZhbHNlKSA7XG4gICAgZWxzZSBpZiAoKHQyID0gdHlwZW9mIGl0ZW0pID09PSBcIm9iamVjdFwiICYmIGl0ZW0ubm9kZVR5cGUpIHtcbiAgICAgIG5vcm1hbGl6ZWQucHVzaChpdGVtKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgIGR5bmFtaWMgPSBub3JtYWxpemVJbmNvbWluZ0FycmF5KG5vcm1hbGl6ZWQsIGl0ZW0sIHByZXYpIHx8IGR5bmFtaWM7XG4gICAgfSBlbHNlIGlmICh0MiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAodW53cmFwMikge1xuICAgICAgICB3aGlsZSAodHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIikgaXRlbSA9IGl0ZW0oKTtcbiAgICAgICAgZHluYW1pYyA9IG5vcm1hbGl6ZUluY29taW5nQXJyYXkobm9ybWFsaXplZCwgQXJyYXkuaXNBcnJheShpdGVtKSA/IGl0ZW0gOiBbaXRlbV0sIEFycmF5LmlzQXJyYXkocHJldikgPyBwcmV2IDogW3ByZXZdKSB8fCBkeW5hbWljO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybWFsaXplZC5wdXNoKGl0ZW0pO1xuICAgICAgICBkeW5hbWljID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdmFsdWUgPSBTdHJpbmcoaXRlbSk7XG4gICAgICBpZiAocHJldiAmJiBwcmV2Lm5vZGVUeXBlID09PSAzICYmIHByZXYuZGF0YSA9PT0gdmFsdWUpIG5vcm1hbGl6ZWQucHVzaChwcmV2KTtcbiAgICAgIGVsc2Ugbm9ybWFsaXplZC5wdXNoKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkeW5hbWljO1xufVxuZnVuY3Rpb24gYXBwZW5kTm9kZXMocGFyZW50LCBhcnJheSwgbWFya2VyID0gbnVsbCkge1xuICBmb3IgKGxldCBpMiA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaTIgPCBsZW47IGkyKyspIHBhcmVudC5pbnNlcnRCZWZvcmUoYXJyYXlbaTJdLCBtYXJrZXIpO1xufVxuZnVuY3Rpb24gY2xlYW5DaGlsZHJlbihwYXJlbnQsIGN1cnJlbnQsIG1hcmtlciwgcmVwbGFjZW1lbnQpIHtcbiAgaWYgKG1hcmtlciA9PT0gdm9pZCAwKSByZXR1cm4gcGFyZW50LnRleHRDb250ZW50ID0gXCJcIjtcbiAgY29uc3Qgbm9kZSA9IHJlcGxhY2VtZW50IHx8IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO1xuICBpZiAoY3VycmVudC5sZW5ndGgpIHtcbiAgICBsZXQgaW5zZXJ0ZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpMiA9IGN1cnJlbnQubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkge1xuICAgICAgY29uc3QgZWwgPSBjdXJyZW50W2kyXTtcbiAgICAgIGlmIChub2RlICE9PSBlbCkge1xuICAgICAgICBjb25zdCBpc1BhcmVudCA9IGVsLnBhcmVudE5vZGUgPT09IHBhcmVudDtcbiAgICAgICAgaWYgKCFpbnNlcnRlZCAmJiAhaTIpIGlzUGFyZW50ID8gcGFyZW50LnJlcGxhY2VDaGlsZChub2RlLCBlbCkgOiBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIG1hcmtlcik7XG4gICAgICAgIGVsc2UgaXNQYXJlbnQgJiYgZWwucmVtb3ZlKCk7XG4gICAgICB9IGVsc2UgaW5zZXJ0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgbWFya2VyKTtcbiAgcmV0dXJuIFtub2RlXTtcbn1cbmNvbnN0IFNWR19OQU1FU1BBQ0UgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZ05hbWUsIGlzU1ZHID0gZmFsc2UpIHtcbiAgcmV0dXJuIGlzU1ZHID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OQU1FU1BBQ0UsIHRhZ05hbWUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbn1cbmZ1bmN0aW9uIFBvcnRhbChwcm9wcykge1xuICBjb25zdCB7XG4gICAgdXNlU2hhZG93XG4gIH0gPSBwcm9wcywgbWFya2VyID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIiksIG1vdW50ID0gKCkgPT4gcHJvcHMubW91bnQgfHwgZG9jdW1lbnQuYm9keSwgb3duZXIgPSBnZXRPd25lcigpO1xuICBsZXQgY29udGVudDtcbiAgY3JlYXRlRWZmZWN0KCgpID0+IHtcbiAgICBjb250ZW50IHx8IChjb250ZW50ID0gcnVuV2l0aE93bmVyKG93bmVyLCAoKSA9PiBjcmVhdGVNZW1vKCgpID0+IHByb3BzLmNoaWxkcmVuKSkpO1xuICAgIGNvbnN0IGVsID0gbW91bnQoKTtcbiAgICBpZiAoZWwgaW5zdGFuY2VvZiBIVE1MSGVhZEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IFtjbGVhbiwgc2V0Q2xlYW5dID0gY3JlYXRlU2lnbmFsKGZhbHNlKTtcbiAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiBzZXRDbGVhbih0cnVlKTtcbiAgICAgIGNyZWF0ZVJvb3QoKGRpc3Bvc2UyKSA9PiBpbnNlcnQoZWwsICgpID0+ICFjbGVhbigpID8gY29udGVudCgpIDogZGlzcG9zZTIoKSwgbnVsbCkpO1xuICAgICAgb25DbGVhbnVwKGNsZWFudXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBjcmVhdGVFbGVtZW50KHByb3BzLmlzU1ZHID8gXCJnXCIgOiBcImRpdlwiLCBwcm9wcy5pc1NWRyksIHJlbmRlclJvb3QgPSB1c2VTaGFkb3cgJiYgY29udGFpbmVyLmF0dGFjaFNoYWRvdyA/IGNvbnRhaW5lci5hdHRhY2hTaGFkb3coe1xuICAgICAgICBtb2RlOiBcIm9wZW5cIlxuICAgICAgfSkgOiBjb250YWluZXI7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udGFpbmVyLCBcIl8kaG9zdFwiLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gbWFya2VyLnBhcmVudE5vZGU7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBpbnNlcnQocmVuZGVyUm9vdCwgY29udGVudCk7XG4gICAgICBlbC5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgcHJvcHMucmVmICYmIHByb3BzLnJlZihjb250YWluZXIpO1xuICAgICAgb25DbGVhbnVwKCgpID0+IGVsLnJlbW92ZUNoaWxkKGNvbnRhaW5lcikpO1xuICAgIH1cbiAgfSwgdm9pZCAwLCB7XG4gICAgcmVuZGVyOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gbWFya2VyO1xufVxuZnVuY3Rpb24gY3JlYXRlRHluYW1pYyhjb21wb25lbnQsIHByb3BzKSB7XG4gIGNvbnN0IGNhY2hlZCA9IGNyZWF0ZU1lbW8oY29tcG9uZW50KTtcbiAgcmV0dXJuIGNyZWF0ZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGNvbXBvbmVudDIgPSBjYWNoZWQoKTtcbiAgICBzd2l0Y2ggKHR5cGVvZiBjb21wb25lbnQyKSB7XG4gICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgcmV0dXJuIHVudHJhY2soKCkgPT4gY29tcG9uZW50Mihwcm9wcykpO1xuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBjb25zdCBpc1N2ZyA9IFNWR0VsZW1lbnRzLmhhcyhjb21wb25lbnQyKTtcbiAgICAgICAgY29uc3QgZWwgPSBjcmVhdGVFbGVtZW50KGNvbXBvbmVudDIsIGlzU3ZnKTtcbiAgICAgICAgc3ByZWFkKGVsLCBwcm9wcywgaXNTdmcpO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIER5bmFtaWMocHJvcHMpIHtcbiAgY29uc3QgWywgb3RoZXJzXSA9IHNwbGl0UHJvcHMocHJvcHMsIFtcImNvbXBvbmVudFwiXSk7XG4gIHJldHVybiBjcmVhdGVEeW5hbWljKCgpID0+IHByb3BzLmNvbXBvbmVudCwgb3RoZXJzKTtcbn1cbnZhciBUSEVNRSA9IC8qIEBfX1BVUkVfXyAqLyAoKFRIRU1FMikgPT4ge1xuICBUSEVNRTJbXCJEQVJLXCJdID0gXCJEQVJLXCI7XG4gIFRIRU1FMltcIkxJR0hUXCJdID0gXCJMSUdIVFwiO1xuICByZXR1cm4gVEhFTUUyO1xufSkoVEhFTUUgfHwge30pO1xubGV0IGUgPSB7IGRhdGE6IFwiXCIgfSwgdCA9ICh0MikgPT4gXCJvYmplY3RcIiA9PSB0eXBlb2Ygd2luZG93ID8gKCh0MiA/IHQyLnF1ZXJ5U2VsZWN0b3IoXCIjX2dvb2JlclwiKSA6IHdpbmRvdy5fZ29vYmVyKSB8fCBPYmplY3QuYXNzaWduKCh0MiB8fCBkb2N1bWVudC5oZWFkKS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIikpLCB7IGlubmVySFRNTDogXCIgXCIsIGlkOiBcIl9nb29iZXJcIiB9KSkuZmlyc3RDaGlsZCA6IHQyIHx8IGUsIGwgPSAvKD86KFtcXHUwMDgwLVxcdUZGRkZcXHctJUBdKykgKjo/ICooW157O10rPyk7fChbXjt9e10qPykgKnspfCh9XFxzKikvZywgYSA9IC9cXC9cXCpbXl0qP1xcKlxcL3wgICsvZywgbiA9IC9cXG4rL2csIG8gPSAoZTIsIHQyKSA9PiB7XG4gIGxldCByID0gXCJcIiwgbDIgPSBcIlwiLCBhMiA9IFwiXCI7XG4gIGZvciAobGV0IG4yIGluIGUyKSB7XG4gICAgbGV0IGMyID0gZTJbbjJdO1xuICAgIFwiQFwiID09IG4yWzBdID8gXCJpXCIgPT0gbjJbMV0gPyByID0gbjIgKyBcIiBcIiArIGMyICsgXCI7XCIgOiBsMiArPSBcImZcIiA9PSBuMlsxXSA/IG8oYzIsIG4yKSA6IG4yICsgXCJ7XCIgKyBvKGMyLCBcImtcIiA9PSBuMlsxXSA/IFwiXCIgOiB0MikgKyBcIn1cIiA6IFwib2JqZWN0XCIgPT0gdHlwZW9mIGMyID8gbDIgKz0gbyhjMiwgdDIgPyB0Mi5yZXBsYWNlKC8oW14sXSkrL2csIChlMykgPT4gbjIucmVwbGFjZSgvKF46LiopfChbXixdKSsvZywgKHQzKSA9PiAvJi8udGVzdCh0MykgPyB0My5yZXBsYWNlKC8mL2csIGUzKSA6IGUzID8gZTMgKyBcIiBcIiArIHQzIDogdDMpKSA6IG4yKSA6IG51bGwgIT0gYzIgJiYgKG4yID0gL14tLS8udGVzdChuMikgPyBuMiA6IG4yLnJlcGxhY2UoL1tBLVpdL2csIFwiLSQmXCIpLnRvTG93ZXJDYXNlKCksIGEyICs9IG8ucCA/IG8ucChuMiwgYzIpIDogbjIgKyBcIjpcIiArIGMyICsgXCI7XCIpO1xuICB9XG4gIHJldHVybiByICsgKHQyICYmIGEyID8gdDIgKyBcIntcIiArIGEyICsgXCJ9XCIgOiBhMikgKyBsMjtcbn0sIGMgPSB7fSwgcyA9IChlMikgPT4ge1xuICBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZTIpIHtcbiAgICBsZXQgdDIgPSBcIlwiO1xuICAgIGZvciAobGV0IHIgaW4gZTIpIHQyICs9IHIgKyBzKGUyW3JdKTtcbiAgICByZXR1cm4gdDI7XG4gIH1cbiAgcmV0dXJuIGUyO1xufSwgaSA9IChlMiwgdDIsIHIsIGkyLCBwMikgPT4ge1xuICBsZXQgdTIgPSBzKGUyKSwgZCA9IGNbdTJdIHx8IChjW3UyXSA9ICgoZTMpID0+IHtcbiAgICBsZXQgdDMgPSAwLCByMiA9IDExO1xuICAgIGZvciAoOyB0MyA8IGUzLmxlbmd0aDsgKSByMiA9IDEwMSAqIHIyICsgZTMuY2hhckNvZGVBdCh0MysrKSA+Pj4gMDtcbiAgICByZXR1cm4gXCJnb1wiICsgcjI7XG4gIH0pKHUyKSk7XG4gIGlmICghY1tkXSkge1xuICAgIGxldCB0MyA9IHUyICE9PSBlMiA/IGUyIDogKChlMykgPT4ge1xuICAgICAgbGV0IHQ0LCByMiwgbzIgPSBbe31dO1xuICAgICAgZm9yICg7IHQ0ID0gbC5leGVjKGUzLnJlcGxhY2UoYSwgXCJcIikpOyApIHQ0WzRdID8gbzIuc2hpZnQoKSA6IHQ0WzNdID8gKHIyID0gdDRbM10ucmVwbGFjZShuLCBcIiBcIikudHJpbSgpLCBvMi51bnNoaWZ0KG8yWzBdW3IyXSA9IG8yWzBdW3IyXSB8fCB7fSkpIDogbzJbMF1bdDRbMV1dID0gdDRbMl0ucmVwbGFjZShuLCBcIiBcIikudHJpbSgpO1xuICAgICAgcmV0dXJuIG8yWzBdO1xuICAgIH0pKGUyKTtcbiAgICBjW2RdID0gbyhwMiA/IHsgW1wiQGtleWZyYW1lcyBcIiArIGRdOiB0MyB9IDogdDMsIHIgPyBcIlwiIDogXCIuXCIgKyBkKTtcbiAgfVxuICBsZXQgZiA9IHIgJiYgYy5nID8gYy5nIDogbnVsbDtcbiAgcmV0dXJuIHIgJiYgKGMuZyA9IGNbZF0pLCAoKGUzLCB0MywgcjIsIGwyKSA9PiB7XG4gICAgbDIgPyB0My5kYXRhID0gdDMuZGF0YS5yZXBsYWNlKGwyLCBlMykgOiAtMSA9PT0gdDMuZGF0YS5pbmRleE9mKGUzKSAmJiAodDMuZGF0YSA9IHIyID8gZTMgKyB0My5kYXRhIDogdDMuZGF0YSArIGUzKTtcbiAgfSkoY1tkXSwgdDIsIGkyLCBmKSwgZDtcbn0sIHAgPSAoZTIsIHQyLCByKSA9PiBlMi5yZWR1Y2UoKGUzLCBsMiwgYTIpID0+IHtcbiAgbGV0IG4yID0gdDJbYTJdO1xuICBpZiAobjIgJiYgbjIuY2FsbCkge1xuICAgIGxldCBlNCA9IG4yKHIpLCB0MyA9IGU0ICYmIGU0LnByb3BzICYmIGU0LnByb3BzLmNsYXNzTmFtZSB8fCAvXmdvLy50ZXN0KGU0KSAmJiBlNDtcbiAgICBuMiA9IHQzID8gXCIuXCIgKyB0MyA6IGU0ICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIGU0ID8gZTQucHJvcHMgPyBcIlwiIDogbyhlNCwgXCJcIikgOiBmYWxzZSA9PT0gZTQgPyBcIlwiIDogZTQ7XG4gIH1cbiAgcmV0dXJuIGUzICsgbDIgKyAobnVsbCA9PSBuMiA/IFwiXCIgOiBuMik7XG59LCBcIlwiKTtcbmZ1bmN0aW9uIHUoZTIpIHtcbiAgbGV0IHIgPSB0aGlzIHx8IHt9LCBsMiA9IGUyLmNhbGwgPyBlMihyLnApIDogZTI7XG4gIHJldHVybiBpKGwyLnVuc2hpZnQgPyBsMi5yYXcgPyBwKGwyLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIHIucCkgOiBsMi5yZWR1Y2UoKGUzLCB0MikgPT4gT2JqZWN0LmFzc2lnbihlMywgdDIgJiYgdDIuY2FsbCA/IHQyKHIucCkgOiB0MiksIHt9KSA6IGwyLCB0KHIudGFyZ2V0KSwgci5nLCByLm8sIHIuayk7XG59XG51LmJpbmQoeyBnOiAxIH0pO1xubGV0IGggPSB1LmJpbmQoeyBrOiAxIH0pO1xuY29uc3QgVGhlbWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dCgpO1xuZnVuY3Rpb24gVGhlbWVQcm92aWRlcihwcm9wcykge1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRoZW1lQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBwcm9wcy50aGVtZSxcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHVzZVRoZW1lKCkge1xuICByZXR1cm4gdXNlQ29udGV4dChUaGVtZUNvbnRleHQpO1xufVxuZnVuY3Rpb24gbWFrZVN0eWxlZCh0YWcpIHtcbiAgbGV0IF9jdHggPSB0aGlzIHx8IHt9O1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBTdHlsZWQgPSAocHJvcHMpID0+IHtcbiAgICAgIGNvbnN0IHRoZW1lID0gdXNlQ29udGV4dChUaGVtZUNvbnRleHQpO1xuICAgICAgY29uc3Qgd2l0aFRoZW1lID0gbWVyZ2VQcm9wcyhwcm9wcywgeyB0aGVtZSB9KTtcbiAgICAgIGNvbnN0IGNsb25lID0gbWVyZ2VQcm9wcyh3aXRoVGhlbWUsIHtcbiAgICAgICAgZ2V0IGNsYXNzKCkge1xuICAgICAgICAgIGNvbnN0IHBDbGFzcyA9IHdpdGhUaGVtZS5jbGFzcywgYXBwZW5kID0gXCJjbGFzc1wiIGluIHdpdGhUaGVtZSAmJiAvXmdvWzAtOV0rLy50ZXN0KHBDbGFzcyk7XG4gICAgICAgICAgbGV0IGNsYXNzTmFtZTIgPSB1LmFwcGx5KFxuICAgICAgICAgICAgeyB0YXJnZXQ6IF9jdHgudGFyZ2V0LCBvOiBhcHBlbmQsIHA6IHdpdGhUaGVtZSwgZzogX2N0eC5nIH0sXG4gICAgICAgICAgICBhcmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gW3BDbGFzcywgY2xhc3NOYW1lMl0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IFtsb2NhbCwgbmV3UHJvcHNdID0gc3BsaXRQcm9wcyhjbG9uZSwgW1wiYXNcIiwgXCJ0aGVtZVwiXSk7XG4gICAgICBjb25zdCBodG1sUHJvcHMgPSBuZXdQcm9wcztcbiAgICAgIGNvbnN0IGNyZWF0ZVRhZyA9IGxvY2FsLmFzIHx8IHRhZztcbiAgICAgIGxldCBlbDtcbiAgICAgIGlmICh0eXBlb2YgY3JlYXRlVGFnID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZWwgPSBjcmVhdGVUYWcoaHRtbFByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoX2N0eC5nID09IDEpIHtcbiAgICAgICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChjcmVhdGVUYWcpO1xuICAgICAgICAgICAgc3ByZWFkKGVsLCBodG1sUHJvcHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbCA9IER5bmFtaWMobWVyZ2VQcm9wcyh7IGNvbXBvbmVudDogY3JlYXRlVGFnIH0sIGh0bWxQcm9wcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4gICAgU3R5bGVkLmNsYXNzID0gKHByb3BzKSA9PiB7XG4gICAgICByZXR1cm4gdW50cmFjaygoKSA9PiB7XG4gICAgICAgIHJldHVybiB1LmFwcGx5KHsgdGFyZ2V0OiBfY3R4LnRhcmdldCwgcDogcHJvcHMsIGc6IF9jdHguZyB9LCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFN0eWxlZDtcbiAgfTtcbn1cbmNvbnN0IHN0eWxlZCA9IG5ldyBQcm94eShtYWtlU3R5bGVkLCB7XG4gIGdldCh0YXJnZXQsIHRhZykge1xuICAgIHJldHVybiB0YXJnZXQodGFnKTtcbiAgfVxufSk7XG5mdW5jdGlvbiBjcmVhdGVHbG9iYWxTdHlsZXMoKSB7XG4gIGNvbnN0IGZuID0gbWFrZVN0eWxlZC5jYWxsKHsgZzogMSB9LCBcImRpdlwiKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICByZXR1cm4gZnVuY3Rpb24gR2xvYmFsU3R5bGVzMihwcm9wcykge1xuICAgIGZuKHByb3BzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cbmNvbnN0IGdsb2JhbFN0eWxlc1RhZyA9IFwidGMtcm9vdFwiO1xuY29uc3QgZGlzYWJsZVNjcm9sbENsYXNzID0gXCJ0Yy1kaXNhYmxlLXNjcm9sbFwiO1xuY29uc3QgdXNpbmdNb3VzZUNsYXNzID0gXCJ0Yy11c2luZy1tb3VzZVwiO1xuY29uc3QgR2xvYmFsU3R5bGVzID0gKCkgPT4ge1xuICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgKCkgPT4gZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKHVzaW5nTW91c2VDbGFzcykpO1xuICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5rZXkgPT09IFwiVGFiXCIpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSh1c2luZ01vdXNlQ2xhc3MpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IFN0eWxlcyA9IGNyZWF0ZUdsb2JhbFN0eWxlc2BcbiAgICAke2dsb2JhbFN0eWxlc1RhZ30gKiB7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgXG4gICAgICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdSb2JvdG8nLCAnSGVsdmV0aWNhIE5ldWUnLCBBcmlhbCwgVGFob21hLCBWZXJkYW5hLCBzYW5zLXNlcmlmO1xuICAgICAgICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcbiAgICAgICAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTsgICAgICAgIFxuICAgICAgICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgIH1cbiAgICBcbiAgICAke2dsb2JhbFN0eWxlc1RhZ30gaW1nIHtcbiAgICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XG4gICAgfSAgIFxuIFxuICAgICR7Z2xvYmFsU3R5bGVzVGFnfSAqOmZvY3VzIHtcbiAgICAgICAgb3V0bGluZTogIzA4ZiBhdXRvIDJweDtcbiAgICB9XG4gICAgXG4gICAgJHtnbG9iYWxTdHlsZXNUYWd9IGxpIHtcbiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICB9XG4gICAgXG4gICAgJHtnbG9iYWxTdHlsZXNUYWd9IGJ1dHRvbiB7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgfVxuICAgIFxuICAgIGJvZHkuJHtkaXNhYmxlU2Nyb2xsQ2xhc3N9IHtcbiAgICAgICAgcG9zaXRpb246IGZpeGVkOyBcbiAgICAgICAgb3ZlcmZsb3cteTogc2Nyb2xsO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICB9XG4gICAgXG4gICAgYm9keS4ke3VzaW5nTW91c2VDbGFzc30gJHtnbG9iYWxTdHlsZXNUYWd9ICo6Zm9jdXMge1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgIH1cbmA7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoU3R5bGVzLCB7fSk7XG59O1xuZnVuY3Rpb24gaGV4VG9SZ2IoaGV4KSB7XG4gIGlmIChoZXhbMF0gPT09IFwiI1wiKSB7XG4gICAgaGV4ID0gaGV4LnNsaWNlKDEpO1xuICB9XG4gIGNvbnN0IGJpZ2ludCA9IHBhcnNlSW50KGhleCwgMTYpO1xuICBjb25zdCByID0gYmlnaW50ID4+IDE2ICYgMjU1O1xuICBjb25zdCBnID0gYmlnaW50ID4+IDggJiAyNTU7XG4gIGNvbnN0IGIgPSBiaWdpbnQgJiAyNTU7XG4gIHJldHVybiBbciwgZywgYl0uam9pbihcIixcIik7XG59XG5mdW5jdGlvbiByZ2JhKGNvbG9yLCBvcGFjaXR5KSB7XG4gIGlmIChjb2xvclswXSA9PT0gXCIjXCIpIHtcbiAgICBjb2xvciA9IGhleFRvUmdiKGNvbG9yKTtcbiAgfVxuICByZXR1cm4gYHJnYmEoJHtjb2xvcn0sICR7b3BhY2l0eX0pYDtcbn1cbmZ1bmN0aW9uIHRvUHgodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCkgKyBcInB4XCI7XG59XG5jbGFzcyBJbk1lbW9yeVN0b3JhZ2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0b3JhZ2UgPSB7fTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XG4gICAgaWYgKCFJbk1lbW9yeVN0b3JhZ2UuaW5zdGFuY2UpIHtcbiAgICAgIEluTWVtb3J5U3RvcmFnZS5pbnN0YW5jZSA9IG5ldyBJbk1lbW9yeVN0b3JhZ2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIEluTWVtb3J5U3RvcmFnZS5pbnN0YW5jZTtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnN0b3JhZ2UpLmxlbmd0aDtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLnN0b3JhZ2UgPSB7fTtcbiAgfVxuICBnZXRJdGVtKGtleSkge1xuICAgIHZhciBfYTI7XG4gICAgcmV0dXJuIChfYTIgPSB0aGlzLnN0b3JhZ2Vba2V5XSkgIT0gbnVsbCA/IF9hMiA6IG51bGw7XG4gIH1cbiAga2V5KGluZGV4KSB7XG4gICAgdmFyIF9hMjtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5zdG9yYWdlKTtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IGtleXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChfYTIgPSBrZXlzW2luZGV4XSkgIT0gbnVsbCA/IF9hMiA6IG51bGw7XG4gIH1cbiAgcmVtb3ZlSXRlbShrZXkpIHtcbiAgICBkZWxldGUgdGhpcy5zdG9yYWdlW2tleV07XG4gIH1cbiAgc2V0SXRlbShrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5zdG9yYWdlW2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuY2xhc3MgVG9uQ29ubmVjdFVJRXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFRvbkNvbm5lY3RVSUVycm9yLnByb3RvdHlwZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGxvZ0RlYnVnKC4uLmFyZ3MpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmRlYnVnKFwiW1RPTl9DT05ORUNUX1VJXVwiLCAuLi5hcmdzKTtcbiAgICB9IGNhdGNoIChlMikge1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbG9nRXJyb3IoLi4uYXJncykge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbVE9OX0NPTk5FQ1RfVUldXCIsIC4uLmFyZ3MpO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBsb2dXYXJuaW5nKC4uLmFyZ3MpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbVE9OX0NPTk5FQ1RfVUldXCIsIC4uLmFyZ3MpO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBvcGVuTGluayhocmVmLCB0YXJnZXQgPSBcIl9zZWxmXCIpIHtcbiAgc2V0TGFzdE9wZW5lZExpbmsoeyBsaW5rOiBocmVmIH0pO1xuICBsb2dEZWJ1ZyhcIm9wZW5MaW5rXCIsIGhyZWYsIHRhcmdldCk7XG4gIHdpbmRvdy5vcGVuKGhyZWYsIHRhcmdldCwgXCJub29wZW5lciBub3JlZmVycmVyXCIpO1xufVxuZnVuY3Rpb24gb3BlbkxpbmtCbGFuayhocmVmKSB7XG4gIG9wZW5MaW5rKGhyZWYsIFwiX2JsYW5rXCIpO1xufVxuZnVuY3Rpb24gb3BlbkRlZXBsaW5rV2l0aEZhbGxiYWNrKGhyZWYsIGZhbGxiYWNrKSB7XG4gIGNvbnN0IGRvRmFsbGJhY2sgPSAoKSA9PiB7XG4gICAgaWYgKGlzQnJvd3NlcihcInNhZmFyaVwiKSB8fCBpc09TKFwiYW5kcm9pZFwiKSAmJiBpc0Jyb3dzZXIoXCJmaXJlZm94XCIpIHx8IGlzT1MoXCJ3aW5kb3dzXCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZhbGxiYWNrKCk7XG4gIH07XG4gIGNvbnN0IGZhbGxiYWNrVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gZG9GYWxsYmFjaygpLCAyMDApO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgKCkgPT4gY2xlYXJUaW1lb3V0KGZhbGxiYWNrVGltZW91dCksIHsgb25jZTogdHJ1ZSB9KTtcbiAgb3BlbkxpbmsoaHJlZiwgXCJfc2VsZlwiKTtcbn1cbmZ1bmN0aW9uIGdldFN5c3RlbVRoZW1lKCkge1xuICBpZiAod2luZG93Lm1hdGNoTWVkaWEgJiYgd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1jb2xvci1zY2hlbWU6IGxpZ2h0KVwiKS5tYXRjaGVzKSB7XG4gICAgcmV0dXJuIFRIRU1FLkxJR0hUO1xuICB9XG4gIHJldHVybiBUSEVNRS5EQVJLO1xufVxuZnVuY3Rpb24gc3Vic2NyaWJlVG9UaGVtZUNoYW5nZShjYWxsYmFjaykge1xuICBjb25zdCBoYW5kbGVyID0gKGV2ZW50KSA9PiBjYWxsYmFjayhldmVudC5tYXRjaGVzID8gVEhFTUUuREFSSyA6IFRIRU1FLkxJR0hUKTtcbiAgd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlcik7XG4gIHJldHVybiAoKSA9PiB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaylcIikucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVyKTtcbn1cbmZ1bmN0aW9uIGRpc2FibGVTY3JvbGwoKSB7XG4gIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRvY3VtZW50LmJvZHkuc3R5bGUudG9wID0gdG9QeCgtZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCk7XG4gIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChkaXNhYmxlU2Nyb2xsQ2xhc3MpO1xufVxuZnVuY3Rpb24gZW5hYmxlU2Nyb2xsKCkge1xuICBpZiAoIWRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmNvbnRhaW5zKGRpc2FibGVTY3JvbGxDbGFzcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKGRpc2FibGVTY3JvbGxDbGFzcyk7XG4gIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUbyh7IHRvcDogLXBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS50b3ApIH0pO1xuICBkb2N1bWVudC5ib2R5LnN0eWxlLnRvcCA9IFwiYXV0b1wiO1xufVxuZnVuY3Rpb24gZml4TW9iaWxlU2FmYXJpQWN0aXZlVHJhbnNpdGlvbigpIHtcbiAgaWYgKCFkb2N1bWVudC5ib2R5Lmhhc0F0dHJpYnV0ZShcIm9udG91Y2hzdGFydFwiKSkge1xuICAgIGRvY3VtZW50LmJvZHkuc2V0QXR0cmlidXRlKFwib250b3VjaHN0YXJ0XCIsIFwiXCIpO1xuICB9XG59XG5mdW5jdGlvbiBkZWZpbmVTdHlsZXNSb290KCkge1xuICBpZiAoIWN1c3RvbUVsZW1lbnRzLmdldChcInRjLXJvb3RcIikpIHtcbiAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoZ2xvYmFsU3R5bGVzVGFnLCBjbGFzcyBUY1Jvb3RFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVNYWNyb3Rhc2soY2FsbGJhY2spIHtcbiAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICB5aWVsZCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc29sdmUpKTtcbiAgICBjYWxsYmFjaygpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1hY3JvdGFza0FzeW5jKGNhbGxiYWNrKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgeWllbGQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZShyZXNvbHZlKSk7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlbG9hZEltYWdlcyhpbWFnZXMpIHtcbiAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwiY29tcGxldGVcIikge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiBjcmVhdGVNYWNyb3Rhc2soKCkgPT4gcHJlbG9hZEltYWdlcyhpbWFnZXMpKSwge1xuICAgICAgb25jZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGltYWdlcy5mb3JFYWNoKChpbWcpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSBuZXcgd2luZG93LkltYWdlKCk7XG4gICAgICBub2RlLnNyYyA9IGltZztcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0V2luZG93JDEoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gdHJ5R2V0TG9jYWxTdG9yYWdlKCkge1xuICBpZiAoaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSkge1xuICAgIHJldHVybiBsb2NhbFN0b3JhZ2U7XG4gIH1cbiAgaWYgKGlzTm9kZUpzKCkpIHtcbiAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdFVJRXJyb3IoXG4gICAgICBcImBsb2NhbFN0b3JhZ2VgIGlzIHVuYXZhaWxhYmxlLCBidXQgaXQgaXMgcmVxdWlyZWQgZm9yIFRvbkNvbm5lY3QuIEZvciBtb3JlIGRldGFpbHMsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdG9uLWNvbm5lY3Qvc2RrL3RyZWUvbWFpbi9wYWNrYWdlcy9zZGsjaW5pdC1jb25uZWN0b3JcIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIEluTWVtb3J5U3RvcmFnZS5nZXRJbnN0YW5jZSgpO1xufVxuZnVuY3Rpb24gaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09IFwidW5kZWZpbmVkXCI7XG4gIH0gY2F0Y2ggKGUyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBpc05vZGVKcygpIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MudmVyc2lvbnMgIT0gbnVsbCAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFVzZXJBZ2VudCgpIHtcbiAgdmFyIF9hMiwgX2IyLCBfYzI7XG4gIGNvbnN0IHJlc3VsdHMgPSBuZXcgVUFQYXJzZXIoKS5nZXRSZXN1bHQoKTtcbiAgY29uc3Qgb3NOYW1lID0gKF9hMiA9IHJlc3VsdHMub3MubmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBkZXZpY2VNb2RlbCA9IChfYjIgPSByZXN1bHRzLmRldmljZS5tb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi50b0xvd2VyQ2FzZSgpO1xuICBsZXQgb3M7XG4gIHN3aXRjaCAodHJ1ZSkge1xuICAgIGNhc2UgZGV2aWNlTW9kZWwgPT09IFwiaXBhZFwiOlxuICAgICAgb3MgPSBcImlwYWRcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2Ugb3NOYW1lID09PSBcImlvc1wiOlxuICAgICAgb3MgPSBcImlvc1wiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBvc05hbWUgPT09IFwiYW5kcm9pZFwiOlxuICAgICAgb3MgPSBcImFuZHJvaWRcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2Ugb3NOYW1lID09PSBcIm1hYyBvc1wiOlxuICAgICAgb3MgPSBcIm1hY29zXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIG9zTmFtZSA9PT0gXCJsaW51eFwiOlxuICAgICAgb3MgPSBcImxpbnV4XCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIChvc05hbWUgPT0gbnVsbCA/IHZvaWQgMCA6IG9zTmFtZS5pbmNsdWRlcyhcIndpbmRvd3NcIikpOlxuICAgICAgb3MgPSBcIndpbmRvd3NcIjtcbiAgICAgIGJyZWFrO1xuICB9XG4gIGNvbnN0IGJyb3dzZXJOYW1lID0gKF9jMiA9IHJlc3VsdHMuYnJvd3Nlci5uYW1lKSA9PSBudWxsID8gdm9pZCAwIDogX2MyLnRvTG93ZXJDYXNlKCk7XG4gIGxldCBicm93c2VyO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGJyb3dzZXJOYW1lID09PSBcImNocm9tZVwiOlxuICAgICAgYnJvd3NlciA9IFwiY2hyb21lXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGJyb3dzZXJOYW1lID09PSBcImZpcmVmb3hcIjpcbiAgICAgIGJyb3dzZXIgPSBcImZpcmVmb3hcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgKGJyb3dzZXJOYW1lID09IG51bGwgPyB2b2lkIDAgOiBicm93c2VyTmFtZS5pbmNsdWRlcyhcInNhZmFyaVwiKSk6XG4gICAgICBicm93c2VyID0gXCJzYWZhcmlcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgKGJyb3dzZXJOYW1lID09IG51bGwgPyB2b2lkIDAgOiBicm93c2VyTmFtZS5pbmNsdWRlcyhcIm9wZXJhXCIpKTpcbiAgICAgIGJyb3dzZXIgPSBcIm9wZXJhXCI7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4ge1xuICAgIG9zLFxuICAgIGJyb3dzZXJcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzT1MoLi4ub3MpIHtcbiAgcmV0dXJuIG9zLmluY2x1ZGVzKGdldFVzZXJBZ2VudCgpLm9zKTtcbn1cbmZ1bmN0aW9uIGlzQnJvd3NlciguLi5icm93c2VyKSB7XG4gIHJldHVybiBicm93c2VyLmluY2x1ZGVzKGdldFVzZXJBZ2VudCgpLmJyb3dzZXIpO1xufVxuZnVuY3Rpb24gdG9EZWVwbGluayh1bml2ZXJzYWxMaW5rLCBkZWVwbGluaykge1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKHVuaXZlcnNhbExpbmspO1xuICByZXR1cm4gZGVlcGxpbmsgKyB1cmwuc2VhcmNoO1xufVxuY2xhc3MgV2FsbGV0SW5mb1N0b3JhZ2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0b3JhZ2VLZXkgPSBcInRvbi1jb25uZWN0LXVpX3dhbGxldC1pbmZvXCI7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UgPSB0cnlHZXRMb2NhbFN0b3JhZ2UoKTtcbiAgfVxuICBzZXRXYWxsZXRJbmZvKHdhbGxldEluZm8pIHtcbiAgICB0aGlzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmFnZUtleSwgSlNPTi5zdHJpbmdpZnkod2FsbGV0SW5mbykpO1xuICB9XG4gIGdldFdhbGxldEluZm8oKSB7XG4gICAgY29uc3Qgd2FsbGV0SW5mb1N0cmluZyA9IHRoaXMubG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcbiAgICBpZiAoIXdhbGxldEluZm9TdHJpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5wYXJzZSh3YWxsZXRJbmZvU3RyaW5nKTtcbiAgfVxuICByZW1vdmVXYWxsZXRJbmZvKCkge1xuICAgIHRoaXMubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcbiAgfVxufVxuY2xhc3MgUHJlZmVycmVkV2FsbGV0U3RvcmFnZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RvcmFnZUtleSA9IFwidG9uLWNvbm5lY3QtdWlfcHJlZmVycmVkLXdhbGxldFwiO1xuICAgIHRoaXMubG9jYWxTdG9yYWdlID0gdHJ5R2V0TG9jYWxTdG9yYWdlKCk7XG4gIH1cbiAgc2V0UHJlZmVycmVkV2FsbGV0QXBwTmFtZShuYW1lKSB7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXksIG5hbWUpO1xuICB9XG4gIGdldFByZWZlcnJlZFdhbGxldEFwcE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yYWdlS2V5KSB8fCB2b2lkIDA7XG4gIH1cbn1cbmNsYXNzIExhc3RTZWxlY3RlZFdhbGxldEluZm9TdG9yYWdlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdG9yYWdlS2V5ID0gXCJ0b24tY29ubmVjdC11aV9sYXN0LXNlbGVjdGVkLXdhbGxldC1pbmZvXCI7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UgPSB0cnlHZXRMb2NhbFN0b3JhZ2UoKTtcbiAgfVxuICBzZXRMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvKHdhbGxldEluZm8pIHtcbiAgICB0aGlzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmFnZUtleSwgSlNPTi5zdHJpbmdpZnkod2FsbGV0SW5mbykpO1xuICB9XG4gIGdldExhc3RTZWxlY3RlZFdhbGxldEluZm8oKSB7XG4gICAgY29uc3Qgd2FsbGV0SW5mb1N0cmluZyA9IHRoaXMubG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcbiAgICBpZiAoIXdhbGxldEluZm9TdHJpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5wYXJzZSh3YWxsZXRJbmZvU3RyaW5nKTtcbiAgfVxuICByZW1vdmVMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvKCkge1xuICAgIHRoaXMubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcbiAgfVxufVxuY29uc3QgW3dhbGxldHNNb2RhbFN0YXRlLCBzZXRXYWxsZXRzTW9kYWxTdGF0ZV0gPSBjcmVhdGVTaWduYWwoe1xuICBzdGF0dXM6IFwiY2xvc2VkXCIsXG4gIGNsb3NlUmVhc29uOiBudWxsXG59KTtcbmNvbnN0IGdldFdhbGxldHNNb2RhbElzT3BlbmVkID0gY3JlYXRlTWVtbygoKSA9PiB3YWxsZXRzTW9kYWxTdGF0ZSgpLnN0YXR1cyA9PT0gXCJvcGVuZWRcIik7XG5jb25zdCBbc2luZ2xlV2FsbGV0TW9kYWxTdGF0ZSwgc2V0U2luZ2xlV2FsbGV0TW9kYWxTdGF0ZV0gPSBjcmVhdGVTaWduYWwoe1xuICBzdGF0dXM6IFwiY2xvc2VkXCIsXG4gIGNsb3NlUmVhc29uOiBudWxsXG59KTtcbmNvbnN0IGdldFNpbmdsZVdhbGxldE1vZGFsSXNPcGVuZWQgPSBjcmVhdGVNZW1vKFxuICAoKSA9PiBzaW5nbGVXYWxsZXRNb2RhbFN0YXRlKCkuc3RhdHVzID09PSBcIm9wZW5lZFwiXG4pO1xuY29uc3QgZ2V0U2luZ2xlV2FsbGV0TW9kYWxXYWxsZXRJbmZvID0gY3JlYXRlTWVtbygoKSA9PiB7XG4gIGNvbnN0IHN0YXRlID0gc2luZ2xlV2FsbGV0TW9kYWxTdGF0ZSgpO1xuICBpZiAoc3RhdGUuc3RhdHVzID09PSBcIm9wZW5lZFwiKSB7XG4gICAgcmV0dXJuIHN0YXRlLndhbGxldEluZm87XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59KTtcbmxldCBsYXN0U2VsZWN0ZWRXYWxsZXRJbmZvU3RvcmFnZSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyBuZXcgTGFzdFNlbGVjdGVkV2FsbGV0SW5mb1N0b3JhZ2UoKSA6IHZvaWQgMDtcbmNvbnN0IFtsYXN0U2VsZWN0ZWRXYWxsZXRJbmZvLCBfc2V0TGFzdFNlbGVjdGVkV2FsbGV0SW5mb10gPSBjcmVhdGVTaWduYWwoKGxhc3RTZWxlY3RlZFdhbGxldEluZm9TdG9yYWdlID09IG51bGwgPyB2b2lkIDAgOiBsYXN0U2VsZWN0ZWRXYWxsZXRJbmZvU3RvcmFnZS5nZXRMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvKCkpIHx8IG51bGwpO1xuY29uc3Qgc2V0TGFzdFNlbGVjdGVkV2FsbGV0SW5mbyA9ICh3YWxsZXRJbmZvKSA9PiB7XG4gIGlmICghbGFzdFNlbGVjdGVkV2FsbGV0SW5mb1N0b3JhZ2UpIHtcbiAgICBsYXN0U2VsZWN0ZWRXYWxsZXRJbmZvU3RvcmFnZSA9IG5ldyBMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvU3RvcmFnZSgpO1xuICB9XG4gIGlmICh3YWxsZXRJbmZvKSB7XG4gICAgbGFzdFNlbGVjdGVkV2FsbGV0SW5mb1N0b3JhZ2Uuc2V0TGFzdFNlbGVjdGVkV2FsbGV0SW5mbyh3YWxsZXRJbmZvKTtcbiAgfSBlbHNlIHtcbiAgICBsYXN0U2VsZWN0ZWRXYWxsZXRJbmZvU3RvcmFnZS5yZW1vdmVMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvKCk7XG4gIH1cbiAgX3NldExhc3RTZWxlY3RlZFdhbGxldEluZm8od2FsbGV0SW5mbyk7XG59O1xuY29uc3QgW2FjdGlvbiwgc2V0QWN0aW9uXSA9IGNyZWF0ZVNpZ25hbChudWxsKTtcbmNvbnN0IFtsYXN0VmlzaWJsZVdhbGxldHNJbmZvLCBzZXRMYXN0VmlzaWJsZVdhbGxldHNJbmZvXSA9IGNyZWF0ZVNpZ25hbCh7XG4gIHdhbGxldHNNZW51OiBcImV4cGxpY2l0X3dhbGxldFwiLFxuICB3YWxsZXRzOiBbXVxufSk7XG5jb25zdCBbbGFzdE9wZW5lZExpbmssIHNldExhc3RPcGVuZWRMaW5rXSA9IGNyZWF0ZVNpZ25hbCh7XG4gIGxpbms6IFwiXCJcbn0pO1xuY29uc3QgY29tbW9uJDEgPSB7IFwiY2xvc2VcIjogXCJDbG9zZVwiLCBcIm9wZW5XYWxsZXRcIjogXCJPcGVuIHdhbGxldFwiLCBcImNvcHlMaW5rXCI6IFwiQ29weSBMaW5rXCIsIFwibGlua0NvcGllZFwiOiBcIkxpbmsgQ29waWVkXCIsIFwiY29waWVkXCI6IFwiQ29waWVkXCIsIFwieW91cldhbGxldFwiOiBcIllvdXIgV2FsbGV0XCIsIFwicmV0cnlcIjogXCJSZXRyeVwiLCBcImdldFwiOiBcIkdFVFwiLCBcIm1vYmlsZVwiOiBcIk1vYmlsZVwiLCBcImJyb3dzZXJFeHRlbnNpb25cIjogXCJCcm93c2VyIEV4dGVuc2lvblwiLCBcImRlc2t0b3BcIjogXCJEZXNrdG9wXCIgfTtcbmNvbnN0IGJ1dHRvbiQxID0geyBcImNvbm5lY3RXYWxsZXRcIjogXCJDb25uZWN0IFdhbGxldFwiLCBcImRyb3Bkb3duXCI6IHsgXCJjb3B5XCI6IFwiQ29weSBhZGRyZXNzXCIsIFwiY29waWVkXCI6IFwiQWRkcmVzcyBjb3BpZWQhXCIsIFwiZGlzY29ubmVjdFwiOiBcIkRpc2Nvbm5lY3RcIiB9IH07XG5jb25zdCBub3RpZmljYXRpb25zJDEgPSB7IFwiY29uZmlybVwiOiB7IFwiaGVhZGVyXCI6IFwiT3BlbiB7eyBuYW1lIH19IHRvwqBjb25maXJtIHRoZcKgdHJhbnNhY3Rpb24uXCIgfSwgXCJ0cmFuc2FjdGlvblNlbnRcIjogeyBcImhlYWRlclwiOiBcIlRyYW5zYWN0aW9uIHNlbnRcIiwgXCJ0ZXh0XCI6IFwiWW91ciB0cmFuc2FjdGlvbsKgd2lsbCBiZcKgcHJvY2Vzc2VkIGluwqBhwqBmZXcgc2Vjb25kcy5cIiB9LCBcInRyYW5zYWN0aW9uQ2FuY2VsZWRcIjogeyBcImhlYWRlclwiOiBcIlRyYW5zYWN0aW9uIGNhbmNlbGVkXCIsIFwidGV4dFwiOiBcIlRoZXJlIHdpbGwgYmUgbm8gY2hhbmdlcyB0b8KgeW91ciBhY2NvdW50LlwiIH0sIFwiZGF0YVNpZ25lZFwiOiB7IFwiaGVhZGVyXCI6IFwiRGF0YSBzaWduZWRcIiB9LCBcInNpZ25EYXRhQ2FuY2VsZWRcIjogeyBcImhlYWRlclwiOiBcIlNpZ24gZGF0YSBjYW5jZWxlZFwiIH0gfTtcbmNvbnN0IHdhbGxldEl0ZW0kMSA9IHsgXCJ3YWxsZXRPblwiOiBcIldhbGxldCBpblwiLCBcInJlY2VudFwiOiBcIlJlY2VudFwiLCBcImluc3RhbGxlZFwiOiBcIkluc3RhbGxlZFwiLCBcInBvcHVsYXJcIjogXCJQb3B1bGFyXCIgfTtcbmNvbnN0IHdhbGxldE1vZGFsJDEgPSB7IFwibG9hZGluZ1wiOiBcIkxvYWRpbmcgd2FsbGV0c1wiLCBcIndhbGxldHNcIjogXCJXYWxsZXRzXCIsIFwibW9iaWxlVW5pdmVyc2FsTW9kYWxcIjogeyBcImNvbm5lY3RZb3VyV2FsbGV0XCI6IFwiQ29ubmVjdCB5b3VyIFRPTsKgd2FsbGV0XCIsIFwib3BlbldhbGxldE9uVGVsZWdyYW1PclNlbGVjdFwiOiBcIlVzZSBXYWxsZXQgaW4gVGVsZWdyYW0gb3IgY2hvb3NlIG90aGVyIGFwcGxpY2F0aW9uXCIsIFwib3BlbldhbGxldE9uVGVsZWdyYW1cIjogXCJDb25uZWN0IFdhbGxldCBpbiBUZWxlZ3JhbVwiLCBcImNob29zZU90aGVyQXBwbGljYXRpb25cIjogXCJDaG9vc2Ugb3RoZXIgYXBwbGljYXRpb25cIiwgXCJvcGVuTGlua1wiOiBcIk9wZW4gTGlua1wiLCBcInNjYW5cIjogXCJTY2FuIHdpdGggeW91ciBtb2JpbGXCoHdhbGxldFwiIH0sIFwiZGVza3RvcFVuaXZlcnNhbE1vZGFsXCI6IHsgXCJjb25uZWN0WW91cldhbGxldFwiOiBcIkNvbm5lY3QgeW91ciBUT04gd2FsbGV0XCIsIFwic2NhblwiOiBcIlNjYW4gd2l0aCB5b3VyIG1vYmlsZSB3YWxsZXRcIiwgXCJhdmFpbGFibGVXYWxsZXRzXCI6IFwiQXZhaWxhYmxlIHdhbGxldHNcIiB9LCBcIm1vYmlsZUNvbm5lY3Rpb25Nb2RhbFwiOiB7IFwic2hvd1FSXCI6IFwiU2hvdyBRUiBDb2RlXCIsIFwic2NhblFSXCI6IFwiU2NhbiB0aGXCoFFSIGNvZGUgYmVsb3cgd2l0aCB5b3VyIHBob25l4oCZc8Kgb3LCoHt7IG5hbWUgfX3igJlzIGNhbWVyYVwiLCBcIm1pc3NpbmdGZWF0dXJlc1wiOiBcIlBsZWFzZSB1cGRhdGUge3sgbmFtZSB9fSwgeW91ciB2ZXJzaW9uIGRvZXMgbm90IHN1cHBvcnQgcmVxdWlyZWQgZmVhdHVyZXMgZm9yIHRoaXMgZEFwcFwiLCBcIndyb25nTmV0d29ya1wiOiBcIkNvbm5lY3RlZCB3YWxsZXQgaXMgb24gYSBkaWZmZXJlbnQgbmV0d29yay4gUGxlYXNlIHN3aXRjaCBuZXR3b3JrIGluIHt7IG5hbWUgfX0gYW5kIHRyeSBhZ2FpblwiLCBcIm5vdFN1cHBvcnRlZFdhbGxldFwiOiBcInt7IG5hbWUgfX0gZG9lc27igJl0IHN1cHBvcnQgdGhlIHJlcXVlc3RlZCBhY3Rpb24uIFBsZWFzZSBjb25uZWN0IGFub3RoZXIgd2FsbGV0IHRoYXQgc3VwcG9ydHMgaXRcIiwgXCJjb250aW51ZUluXCI6IFwiQ29udGludWUgaW4ge3sgbmFtZSB9feKAplwiLCBcInVwZGF0ZVdhbGxldFwiOiBcIlVwZGF0ZSB7eyBuYW1lIH19XCIsIFwiY2hvb3NlQW5vdGhlcldhbGxldFwiOiBcIkNob29zZSBBbm90aGVyIFdhbGxldFwiLCBcImNvbm5lY3Rpb25EZWNsaW5lZFwiOiBcIkNvbm5lY3Rpb24gZGVjbGluZWRcIiB9LCBcImRlc2t0b3BDb25uZWN0aW9uTW9kYWxcIjogeyBcInNjYW5RUlwiOiBcIlNjYW4gdGhlwqBRUiBjb2RlIGJlbG93IHdpdGggeW91ciBwaG9uZeKAmXPCoG9ywqB7eyBuYW1lIH194oCZcyBjYW1lcmFcIiwgXCJjb250aW51ZUluRXh0ZW5zaW9uXCI6IFwiQ29udGludWUgaW7CoHt7IG5hbWUgfX0gYnJvd3NlciBleHRlbnNpb27igKZcIiwgXCJkb250SGF2ZUV4dGVuc2lvblwiOiBcIlNlZW1zIHlvdSBkb24ndCBoYXZlIGluc3RhbGxlZCB7eyBuYW1lIH19wqBicm93c2VywqBleHRlbnNpb25cIiwgXCJtaXNzaW5nRmVhdHVyZXNcIjogXCJQbGVhc2UgdXBkYXRlIHt7IG5hbWUgfX0sIHlvdXIgdmVyc2lvbiBkb2VzIG5vdCBzdXBwb3J0IHJlcXVpcmVkIGZlYXR1cmVzIGZvciB0aGlzIGRBcHBcIiwgXCJ3cm9uZ05ldHdvcmtcIjogXCJDb25uZWN0ZWQgd2FsbGV0IGlzIG9uIGEgZGlmZmVyZW50IG5ldHdvcmsuIFBsZWFzZSBzd2l0Y2ggbmV0d29yayBpbiB7eyBuYW1lIH19IGFuZCB0cnkgYWdhaW5cIiwgXCJub3RTdXBwb3J0ZWRXYWxsZXRcIjogXCJ7eyBuYW1lIH19IGRvZXNu4oCZdCBzdXBwb3J0IHRoZSByZXF1ZXN0ZWQgYWN0aW9uLiBQbGVhc2UgY29ubmVjdCBhbm90aGVyIHdhbGxldCB0aGF0IHN1cHBvcnRzIGl0XCIsIFwiZ2V0V2FsbGV0XCI6IFwiR2V0IHt7IG5hbWUgfX1cIiwgXCJ1cGRhdGVXYWxsZXRcIjogXCJVcGRhdGUge3sgbmFtZSB9fVwiLCBcImNob29zZUFub3RoZXJXYWxsZXRcIjogXCJDaG9vc2UgQW5vdGhlciBXYWxsZXRcIiwgXCJjb250aW51ZU9uRGVza3RvcFwiOiBcIkNvbnRpbnVlIGluwqB7eyBuYW1lIH19IG9uIGRlc2t0b3DigKZcIiwgXCJvcGVuV2FsbGV0T25UZWxlZ3JhbVwiOiBcIkNvbm5lY3QgV2FsbGV0IGluIFRlbGVncmFtIG9uIGRlc2t0b3BcIiwgXCJjb25uZWN0aW9uRGVjbGluZWRcIjogXCJDb25uZWN0aW9uIGRlY2xpbmVkXCIgfSwgXCJpbmZvTW9kYWxcIjogeyBcIndoYXRJc0FXYWxsZXRcIjogXCJXaGF0IGlzIGEgd2FsbGV0XCIsIFwic2VjdXJlRGlnaXRhbEFzc2V0c1wiOiBcIlNlY3VyZSBkaWdpdGFsIGFzc2V0cyBzdG9yYWdlXCIsIFwid2FsbGV0UHJvdGVjdHNcIjogXCJBIHdhbGxldCBwcm90ZWN0cyBhbmQgbWFuYWdlcyB5b3VyIGRpZ2l0YWwgYXNzZXRzwqBpbmNsdWRpbmcgVE9OLCB0b2tlbnMgYW5kIGNvbGxlY3RhYmxlcy5cIiwgXCJjb250cm9sSWRlbnRpdHlcIjogXCJDb250cm9sIHlvdXIgV2ViMyBpZGVudGl0eVwiLCBcIm1hbmFnZUlkZW50aXR5XCI6IFwiTWFuYWdlIHlvdXIgZGlnaXRhbCBpZGVudGl0eSBhbmQgYWNjZXNzIGRlY2VudHJhbGl6ZWQgYXBwbGljYXRpb25zIHdpdGggZWFzZS4gTWFpbnRhaW4gY29udHJvbCBvdmVyIHlvdXIgZGF0YSBhbmQgZW5nYWdlIHNlY3VyZWx5IGluwqB0aGXCoGJsb2NrY2hhaW4gZWNvc3lzdGVtLlwiLCBcImVmZm9ydGxlc3NDcnlwdG9UcmFuc2FjdGlvbnNcIjogXCJFZmZvcnRsZXNzIGNyeXB0byB0cmFuc2FjdGlvbnNcIiwgXCJlYXNpbHlTZW5kXCI6IFwiRWFzaWx5IHNlbmQsIHJlY2VpdmUsIG1vbml0b3IgeW91ciBjcnlwdG9jdXJyZW5jaWVzLsKgU3RyZWFtbGluZSB5b3VyIG9wZXJhdGlvbnMgd2l0aMKgZGVjZW50cmFsaXplZCBhcHBsaWNhdGlvbnMuXCIsIFwiZ2V0QVdhbGxldFwiOiBcIkdldCBhIFdhbGxldFwiIH0sIFwicmVzdG9yZU1vZGFsXCI6IHsgXCJ0aXRsZVwiOiBcIlJlc3RvcmVcIiwgXCJzdGVwMVwiOiB7IFwidGl0bGVcIjogXCJGaW5kIHlvdXIgY3VycmVudCByZWNvdmVyeSBwaHJhc2VcIiwgXCJ0ZXh0XCI6IFwiT3BlbiB5b3VyIHdhbGxldCBzZXR0aW5ncyBhbmQgbG9jYXRlIHRoZcKgcmVjb3ZlcnnCoHBocmFzZVwiIH0sIFwic3RlcDJcIjogeyBcInRpdGxlXCI6IFwiQ29weSB5b3VyIHJlY292ZXJ5IHBocmFzZVwiLCBcInRleHRcIjogXCJXcml0ZSBpdCBkb3duIG9yIGNvcHkgaXQgdG8gYSBzYWZlIHBsYWNlXCIgfSwgXCJzdGVwM1wiOiB7IFwidGl0bGVcIjogXCJSZXN0b3JlIGluIGEgc3VwcG9ydGVkIHdhbGxldFwiLCBcInRleHRcIjogXCJFbnRlciB0aGUgcmVjb3ZlcnkgcGhyYXNlIHRvIGFjY2VzcyB5b3VyIHdhbGxldFwiIH0gfSwgXCJhbGxXYWxsZXRzXCI6IHsgXCJ3YWxsZXRzQmVsb3dOb3RTdXBwb3J0ZWRcIjogXCJUaGUgd2FsbGV0cyBiZWxvdyBkb27igJl0IHN1cHBvcnQgYWxsIGZlYXR1cmVzIG9mwqB0aGUgY29ubmVjdGVkIHNlcnZpY2UuIFlvdSBjYW4gdXNlIHlvdXIgcmVjb3ZlcnkgcGhyYXNlIGluIG9uZSBvZiB0aGUgc3VwcG9ydGVkIHdhbGxldHMgYWJvdmUuXCIsIFwid2FsbGV0Tm90U3VwcG9ydFNlcnZpY2VcIjogXCJ7eyBuYW1lIH19IGRvZXNu4oCZdCBzdXBwb3J0IGNvbm5lY3RlZCBzZXJ2aWNlXCIgfSwgXCJmZWF0dXJlTm90U3VwcG9ydGVkXCI6IHsgXCJ3YWxsZXRcIjogeyBcInRpdGxlXCI6IFwie3sgbmFtZSB9fSBkb2VzbuKAmXQgc3VwcG9ydCB0aGUgcmVxdWVzdGVkwqBhY3Rpb25cIiwgXCJkZXNjcmlwdGlvblwiOiBcIkluc3RhbGwgYSBzdXBwb3J0ZWQgd2FsbGV0IGZyb20gdGhlIGxpc3QgYmVsb3csIHJlc3RvcmUgaXQgd2l0aCB5b3VyIHJlY292ZXJ5IHBocmFzZSwgdGhlbiBjb25uZWN0IGl0IGFuZCB0cnkgYWdhaW4uXCIsIFwiaW5mb1wiOiBcIkxlYXJuIGhvdyB0byByZXN0b3JlIHlvdXIgd2FsbGV0XCIgfSwgXCJ2ZXJzaW9uXCI6IHsgXCJkZXNjcmlwdGlvblwiOiBcIllvdXIgY3VycmVudCB2ZXJzaW9uIG9mIHt7IG5hbWUgfX0gb3Igd2FsbGV0IGNvbnRyYWN0IHR5cGUgZG9lc24ndCBzdXBwb3J0IHRoZSByZXF1aXJlZCBmZWF0dXJlcy4gUGxlYXNlIHVwZGF0ZSBpdCB0byBjb250aW51ZS5cIiwgXCJ1cGRhdGVCdXR0b25cIjogXCJVcGRhdGUge3sgbmFtZSB9fVwiLCBcImFib3V0VzVcIjogXCJBYm91dCBXNVwiIH0sIFwiZGlzY29ubmVjdFwiOiB7IFwidGl0bGVcIjogXCJDb25maXJtIERpc2Nvbm5lY3RcIiwgXCJkZXNjcmlwdGlvblwiOiBcIllvdSB3aWxsIGJlIGRpc2Nvbm5lY3RlZCBmcm9tIHlvdXIgY3VycmVudCB3YWxsZXQgYW5kIHJlZGlyZWN0ZWQgdG8gY29ubmVjdCB7eyBuYW1lIH19LlwiLCBcImJ1dHRvblwiOiBcIkRpc2Nvbm5lY3RcIiB9IH0gfTtcbmNvbnN0IGFjdGlvbk1vZGFsJDEgPSB7IFwiY29uZmlybVRyYW5zYWN0aW9uXCI6IHsgXCJoZWFkZXJcIjogXCJDb25maXJtIHRoZcKgdHJhbnNhY3Rpb24gaW7CoHt7IG5hbWUgfX1cIiwgXCJ0ZXh0XCI6IFwiSXQgd2lsbCBvbmx5IHRha2UgYcKgbW9tZW50LlwiIH0sIFwic2lnbkRhdGFcIjogeyBcImhlYWRlclwiOiBcIlNpZ24gdGhlwqBkYXRhIGluwqB7eyBuYW1lIH19XCIsIFwidGV4dFwiOiBcIkl0IHdpbGwgb25seSB0YWtlIGHCoG1vbWVudC5cIiB9LCBcInRyYW5zYWN0aW9uU2VudFwiOiBcIiRub3RpZmljYXRpb25zLnRyYW5zYWN0aW9uU2VudFwiLCBcInRyYW5zYWN0aW9uQ2FuY2VsZWRcIjogXCIkbm90aWZpY2F0aW9ucy50cmFuc2FjdGlvbkNhbmNlbGVkXCIsIFwiZGF0YVNpZ25lZFwiOiBcIiRub3RpZmljYXRpb25zLmRhdGFTaWduZWRcIiwgXCJzaWduRGF0YUNhbmNlbGVkXCI6IFwiJG5vdGlmaWNhdGlvbnMuc2lnbkRhdGFDYW5jZWxlZFwiIH07XG5jb25zdCBlbiA9IHtcbiAgY29tbW9uOiBjb21tb24kMSxcbiAgYnV0dG9uOiBidXR0b24kMSxcbiAgbm90aWZpY2F0aW9uczogbm90aWZpY2F0aW9ucyQxLFxuICB3YWxsZXRJdGVtOiB3YWxsZXRJdGVtJDEsXG4gIHdhbGxldE1vZGFsOiB3YWxsZXRNb2RhbCQxLFxuICBhY3Rpb25Nb2RhbDogYWN0aW9uTW9kYWwkMVxufTtcbmNvbnN0IGNvbW1vbiA9IHsgXCJjbG9zZVwiOiBcItCX0LDQutGA0YvRgtGMXCIsIFwib3BlbldhbGxldFwiOiBcItCe0YLQutGA0YvRgtGMINC60L7RiNC10LvRkdC6XCIsIFwiY29weUxpbmtcIjogXCLQodC60L7Qv9C40YDQvtCy0LDRgtGMXCIsIFwibGlua0NvcGllZFwiOiBcItCh0YHRi9C70LrQsCDRgdC60L7Qv9C40YDQvtCy0LDQvdCwXCIsIFwiY29waWVkXCI6IFwi0KHQutC+0L/QuNGA0L7QstCw0L3QvlwiLCBcInlvdXJXYWxsZXRcIjogXCLQktCw0Ygg0LrQvtGI0LXQu9GR0LpcIiwgXCJyZXRyeVwiOiBcItCf0L7QstGC0L7RgNC40YLRjFwiLCBcImdldFwiOiBcItCh0LrQsNGH0LDRgtGMXCIsIFwibW9iaWxlXCI6IFwi0JzQvtCx0LjQu9GM0L3Ri9C5XCIsIFwiYnJvd3NlckV4dGVuc2lvblwiOiBcItCg0LDRgdGI0LjRgNC10L3QuNC1XCIsIFwiZGVza3RvcFwiOiBcItCU0LXRgdC60YLQvtC/XCIgfTtcbmNvbnN0IGJ1dHRvbiA9IHsgXCJjb25uZWN0V2FsbGV0XCI6IFwi0J/QvtC00LrQu9GO0YfQuNGC0Ywg0LrQvtGI0LXQu9GR0LpcIiwgXCJkcm9wZG93blwiOiB7IFwiY29weVwiOiBcItCh0LrQvtC/0LjRgNC+0LLQsNGC0Ywg0LDQtNGA0LXRgVwiLCBcImNvcGllZFwiOiBcItCQ0LTRgNC10YEg0YHQutC+0L/QuNGA0L7QstCw0L0hXCIsIFwiZGlzY29ubmVjdFwiOiBcItCe0YLQutC70Y7Rh9C40YLRjCDQutC+0YjQtdC70ZHQulwiIH0gfTtcbmNvbnN0IG5vdGlmaWNhdGlvbnMgPSB7IFwiY29uZmlybVwiOiB7IFwiaGVhZGVyXCI6IFwi0J7RgtC60YDQvtC50YLQtSB7eyBuYW1lIH19LCDRh9GC0L7QsdGLwqDQv9C+0LTRgtCy0LXRgNC00LjRgtGMINGC0YDQsNC90LfQsNC60YbQuNGOLlwiIH0sIFwidHJhbnNhY3Rpb25TZW50XCI6IHsgXCJoZWFkZXJcIjogXCLQotGA0LDQvdC30LDQutGG0LjRjyDQvtGC0L/RgNCw0LLQu9C10L3QsFwiLCBcInRleHRcIjogXCLQktCw0YjQsCDRgtGA0LDQvdC30LDQutGG0LjRj8Kg0LHRg9C00LXRgiDQvtCx0YDQsNCx0L7RgtCw0L3QsCDRh9C10YDQtdC3wqDQvdC10YHQutC+0LvRjNC60L4g0YHQtdC60YPQvdC0LlwiIH0sIFwidHJhbnNhY3Rpb25DYW5jZWxlZFwiOiB7IFwiaGVhZGVyXCI6IFwi0KLRgNCw0L3Qt9Cw0LrRhtC40Y8g0L7RgtC80LXQvdC10L3QsFwiLCBcInRleHRcIjogXCLQodC+0YHRgtC+0Y/QvdC40LUg0LLQsNGI0LXQs9C+INGB0YfRkdGC0LAg0L3QtcKg0LjQt9C80LXQvdC40YLRgdGPLlwiIH0sIFwiZGF0YVNpZ25lZFwiOiB7IFwiaGVhZGVyXCI6IFwi0JTQsNC90L3Ri9C1INC/0L7QtNC/0LjRgdCw0L3Ri1wiIH0sIFwic2lnbkRhdGFDYW5jZWxlZFwiOiB7IFwiaGVhZGVyXCI6IFwi0J/QvtC00L/QuNGB0Ywg0LTQsNC90L3Ri9GFINC+0YLQvNC10L3QtdC90LBcIiB9IH07XG5jb25zdCB3YWxsZXRJdGVtID0geyBcIndhbGxldE9uXCI6IFwiV2FsbGV0INCyXCIsIFwicmVjZW50XCI6IFwi0J3QtdC00LDQstC90LjQuVwiLCBcImluc3RhbGxlZFwiOiBcItCj0YHRgtCw0L3QvtCy0LvQtdC9XCIsIFwicG9wdWxhclwiOiBcItCf0L7Qv9GD0LvRj9GA0LXQvVwiIH07XG5jb25zdCB3YWxsZXRNb2RhbCA9IHsgXCJsb2FkaW5nXCI6IFwi0JrQvtGI0LXQu9GM0LrQuCDQt9Cw0LPRgNGD0LbQsNGO0YLRgdGPXCIsIFwid2FsbGV0c1wiOiBcItCa0L7RiNC10LvRjNC60LhcIiwgXCJtb2JpbGVVbml2ZXJzYWxNb2RhbFwiOiB7IFwiY29ubmVjdFlvdXJXYWxsZXRcIjogXCLQn9C+0LTQutC70Y7Rh9C40YLQtSBUT07CoNC60L7RiNC10LvRkdC6XCIsIFwib3BlbldhbGxldE9uVGVsZWdyYW1PclNlbGVjdFwiOiBcItCf0L7QtNC60LvRjtGH0LjRgtC1IFdhbGxldCDQssKgVGVsZWdyYW0g0LjQu9C4wqDQstGL0LHQtdGA0LXRgtC1INC00YDRg9Cz0L7QtSDQv9GA0LjQu9C+0LbQtdC90LjQtVwiLCBcIm9wZW5XYWxsZXRPblRlbGVncmFtXCI6IFwi0J7RgtC60YDRi9GC0YwgV2FsbGV0INCyIFRlbGVncmFtXCIsIFwiY2hvb3NlT3RoZXJBcHBsaWNhdGlvblwiOiBcItCS0YvQsdC10YDQuNGC0LUg0LTRgNGD0LPQvtC1INC/0YDQuNC70L7QttC10L3QuNC1XCIsIFwib3BlbkxpbmtcIjogXCLQntGC0LrRgNGL0YLRjFwiLCBcInNjYW5cIjogXCLQntGC0YHQutCw0L3QuNGA0YPQudGC0LUg0LrQsNC80LXRgNC+0Lkg0LLQsNGI0LXQs9C+wqDRgtC10LvQtdGE0L7QvdCwXCIgfSwgXCJkZXNrdG9wVW5pdmVyc2FsTW9kYWxcIjogeyBcImNvbm5lY3RZb3VyV2FsbGV0XCI6IFwi0J/QvtC00LrQu9GO0YfQuNGC0LUgVE9OINC60L7RiNC10LvRkdC6XCIsIFwic2NhblwiOiBcItCe0YLRgdC60LDQvdC40YDRg9C50YLQtSBRUi3QutC+0LQg0LrQsNC80LXRgNC+0Lkg0LLQsNGI0LXQs9C+wqDRgtC10LvQtdGE0L7QvdCwXCIsIFwiYXZhaWxhYmxlV2FsbGV0c1wiOiBcItCU0L7RgdGC0YPQv9C90YvQtSDQutC+0YjQtdC70YzQutC4XCIgfSwgXCJtb2JpbGVDb25uZWN0aW9uTW9kYWxcIjogeyBcInNob3dRUlwiOiBcItCf0L7QutCw0LfQsNGC0YwgUVIt0LrQvtC0XCIsIFwic2NhblFSXCI6IFwi0J7RgtGB0LrQsNC90LjRgNGD0LnRgtC1IFFSLdC60L7QtCDQvdC40LbQtSDQutCw0LzQtdGA0L7QuSDQssKg0L/RgNC40LvQvtC20LXQvdC40Lgge3sgbmFtZSB9fSwg0LjQu9C4wqDQutCw0LzQtdGA0L7QuSDRgtC10LvQtdGE0L7QvdCwXCIsIFwibWlzc2luZ0ZlYXR1cmVzXCI6IFwi0J7QsdC90L7QstC40YLQtSB7eyBuYW1lIH19LCDQstCw0YjQsCDQstC10YDRgdC40Y8g0L3QtSDQv9C+0LTQtNC10YDQttC40LLQsNC10YIg0L3QtdC+0LHRhdC+0LTQuNC80YvQtSDRhNGD0L3QutGG0LjQuCDQtNC70Y8g0Y3RgtC+0LPQviBkQXBwXCIsIFwid3JvbmdOZXR3b3JrXCI6IFwi0J/QvtC00LrQu9GO0YfRkdC90L3Ri9C5INC60L7RiNC10LvRkdC6INC90LDRhdC+0LTQuNGC0YHRjyDQsiDQtNGA0YPQs9C+0Lkg0YHQtdGC0LguINCf0L7QttCw0LvRg9C50YHRgtCwLCDQv9C10YDQtdC60LvRjtGH0LjRgtC1INGB0LXRgtGMINCyIHt7IG5hbWUgfX0g0Lgg0L/QvtC/0YDQvtCx0YPQudGC0LUg0YHQvdC+0LLQsFwiLCBcIm5vdFN1cHBvcnRlZFdhbGxldFwiOiBcInt7IG5hbWUgfX0g0L3QtSDQv9C+0LTQtNC10YDQttC40LLQsNC10YIg0LfQsNC/0YDQvtGI0LXQvdC90L7QtSDQtNC10LnRgdGC0LLQuNC1LiDQn9C+0LbQsNC70YPQudGB0YLQsCwg0L/QvtC00LrQu9GO0YfQuNGC0LUg0LTRgNGD0LPQvtC5INC60L7RiNC10LvRkdC6LCDQutC+0YLQvtGA0YvQuSDQv9C+0LTQtNC10YDQttC40LLQsNC10YIg0Y3RgtC+XCIsIFwiY29udGludWVJblwiOiBcItCf0YDQvtC00L7Qu9C20LjRgtC1INCyIHt7IG5hbWUgfX3igKZcIiwgXCJ1cGRhdGVXYWxsZXRcIjogXCLQntCx0L3QvtCy0LjRgtGMIHt7IG5hbWUgfX1cIiwgXCJjaG9vc2VBbm90aGVyV2FsbGV0XCI6IFwi0JLRi9Cx0YDQsNGC0Ywg0LTRgNGD0LPQvtC5INC60L7RiNC10LvRkdC6XCIsIFwiY29ubmVjdGlvbkRlY2xpbmVkXCI6IFwi0J/QvtC00LrQu9GO0YfQtdC90LjQtSDQvtGC0LrQu9C+0L3QtdC90L5cIiB9LCBcImRlc2t0b3BDb25uZWN0aW9uTW9kYWxcIjogeyBcInNjYW5RUlwiOiBcItCe0YLRgdC60LDQvdC40YDRg9C50YLQtSBRUi3QutC+0LQg0L3QuNC20LUg0LrQsNC80LXRgNC+0Lkg0LLCoNC/0YDQuNC70L7QttC10L3QuNC4IHt7IG5hbWUgfX0sINC40LvQuMKg0LrQsNC80LXRgNC+0Lkg0YLQtdC70LXRhNC+0L3QsFwiLCBcImNvbnRpbnVlSW5FeHRlbnNpb25cIjogXCLQntGC0LrRgNC+0LnRgtC1INCx0YDQsNGD0LfQtdGA0L3QvtC1INGA0LDRgdGI0LjRgNC10L3QuNC1IHt7IG5hbWUgfX1cIiwgXCJkb250SGF2ZUV4dGVuc2lvblwiOiBcItCf0L7RhdC+0LbQtSwg0YMg0LLQsNGBINC90LXCoNGD0YHRgtCw0L3QvtCy0LvQtdC90L4g0LHRgNCw0YPQt9C10YDQvdC+0LXCoNGA0LDRgdGI0LjRgNC10L3QuNC1wqB7eyBuYW1lIH19XCIsIFwibWlzc2luZ0ZlYXR1cmVzXCI6IFwi0J7QsdC90L7QstC40YLQtSB7eyBuYW1lIH19LCDQstCw0YjQsCDQstC10YDRgdC40Y8g0L3QtSDQv9C+0LTQtNC10YDQttC40LLQsNC10YIg0L3QtdC+0LHRhdC+0LTQuNC80YvQtSDRhNGD0L3QutGG0LjQuCDQtNC70Y8g0Y3RgtC+0LPQviBkQXBwXCIsIFwid3JvbmdOZXR3b3JrXCI6IFwi0J/QvtC00LrQu9GO0YfRkdC90L3Ri9C5INC60L7RiNC10LvRkdC6INC90LDRhdC+0LTQuNGC0YHRjyDQsiDQtNGA0YPQs9C+0Lkg0YHQtdGC0LguINCf0L7QttCw0LvRg9C50YHRgtCwLCDQv9C10YDQtdC60LvRjtGH0LjRgtC1INGB0LXRgtGMINCyIHt7IG5hbWUgfX0g0Lgg0L/QvtC/0YDQvtCx0YPQudGC0LUg0YHQvdC+0LLQsFwiLCBcIm5vdFN1cHBvcnRlZFdhbGxldFwiOiBcInt7IG5hbWUgfX0g0L3QtSDQv9C+0LTQtNC10YDQttC40LLQsNC10YIg0LfQsNC/0YDQvtGI0LXQvdC90L7QtSDQtNC10LnRgdGC0LLQuNC1LiDQn9C+0LbQsNC70YPQudGB0YLQsCwg0L/QvtC00LrQu9GO0YfQuNGC0LUg0LTRgNGD0LPQvtC5INC60L7RiNC10LvRkdC6LCDQutC+0YLQvtGA0YvQuSDQv9C+0LTQtNC10YDQttC40LLQsNC10YIg0Y3RgtC+XCIsIFwiZ2V0V2FsbGV0XCI6IFwi0KHQutCw0YfQsNGC0Ywge3sgbmFtZSB9fVwiLCBcInVwZGF0ZVdhbGxldFwiOiBcItCe0LHQvdC+0LLQuNGC0Ywge3sgbmFtZSB9fVwiLCBcImNob29zZUFub3RoZXJXYWxsZXRcIjogXCLQktGL0LHRgNCw0YLRjCDQtNGA0YPQs9C+0Lkg0LrQvtGI0LXQu9GR0LpcIiwgXCJjb250aW51ZU9uRGVza3RvcFwiOiBcItCe0YLQutGA0L7QudGC0LUge3sgbmFtZSB9fSDQvdCwwqDQutC+0LzQv9GM0Y7RgtC10YDQteKAplwiLCBcIm9wZW5XYWxsZXRPblRlbGVncmFtXCI6IFwi0J7RgtC60YDRi9GC0YwgV2FsbGV0INCywqBUZWxlZ3JhbVwiLCBcImNvbm5lY3Rpb25EZWNsaW5lZFwiOiBcItCf0L7QtNC60LvRjtGH0LXQvdC40LUg0L7RgtC60LvQvtC90LXQvdC+XCIgfSwgXCJpbmZvTW9kYWxcIjogeyBcIndoYXRJc0FXYWxsZXRcIjogXCLQp9GC0L4g0YLQsNC60L7QtSDQutC+0YjQtdC70ZHQuj9cIiwgXCJzZWN1cmVEaWdpdGFsQXNzZXRzXCI6IFwi0J3QsNC00LXQttC90L7QtSDRhdGA0LDQvdC40LvQuNGJ0LUg0YbQuNGE0YDQvtCy0YvRhSDQsNC60YLQuNCy0L7QslwiLCBcIndhbGxldFByb3RlY3RzXCI6IFwi0JrQvtGI0LXQu9GR0Log0LfQsNGJ0LjRidCw0LXRgiDQstCw0YjQuCDRhtC40YTRgNC+0LLRi9C1INCw0LrRgtC40LLRiywg0LLQutC70Y7Rh9Cw0Y8gVE9OLCDRgtC+0LrQtdC90Ysg0LjCoNC/0YDQtdC00LzQtdGC0Ysg0LrQvtC70LvQtdC60YbQuNC+0L3QuNGA0L7QstCw0L3QuNGPLCDQuMKg0YPQv9GA0LDQstC70Y/QtdGCINC40LzQuC5cIiwgXCJjb250cm9sSWRlbnRpdHlcIjogXCLQmtC+0L3RgtGA0L7Qu9GMINGB0LLQvtC10Lkg0LvQuNGH0L3QvtGB0YLQuCBXZWIzXCIsIFwibWFuYWdlSWRlbnRpdHlcIjogXCLQo9C/0YDQsNCy0LvRj9C50YLQtSDRgdCy0L7QtdC5INGG0LjRhNGA0L7QstC+0Lkg0LjQtNC10L3RgtC40YTQuNC60LDRhtC40LXQuSDQuMKg0YHCoNC70LXQs9C60L7RgdGC0YzRjiDQv9C+0LvRg9GH0LDQudGC0LUg0LTQvtGB0YLRg9C/INC6wqDQtNC10YbQtdC90YLRgNCw0LvQuNC30L7QstCw0L3QvdGL0Lwg0L/RgNC40LvQvtC20LXQvdC40Y/QvC4g0KHQvtGF0YDQsNC90Y/QudGC0LUg0LrQvtC90YLRgNC+0LvRjCDQvdCw0LTCoNGB0LLQvtC40LzQuCDQtNCw0L3QvdGL0LzQuCDQuMKg0LHQtdC30L7Qv9Cw0YHQvdC+INGD0YfQsNGB0YLQstGD0LnRgtC1INCywqDRjdC60L7RgdC40YHRgtC10LzQtcKg0LHQu9C+0LrRh9C10LnQvdCwLlwiLCBcImVmZm9ydGxlc3NDcnlwdG9UcmFuc2FjdGlvbnNcIjogXCLQn9GA0L7RgdGC0YvQtSDQutGA0LjQv9GC0L7RgtGA0LDQvdC30LDQutGG0LjQuFwiLCBcImVhc2lseVNlbmRcIjogXCLQm9C10LPQutC+INC+0YLQv9GA0LDQstC70Y/QudGC0LUsINC/0L7Qu9GD0YfQsNC50YLQtSDQuMKg0L7RgtGB0LvQtdC20LjQstCw0LnRgtC1INGB0LLQvtC4INC60YDQuNC/0YLQvtCy0LDQu9GO0YLRiy4g0J7Qv9GC0LjQvNC40LfQuNGA0YPQudGC0LUg0YHQstC+0Lgg0L7Qv9C10YDQsNGG0LjQuCDRgcKg0L/QvtC80L7RidGM0Y4g0LTQtdGG0LXQvdGC0YDQsNC70LjQt9C+0LLQsNC90L3Ri9GFINC/0YDQuNC70L7QttC10L3QuNC5LlwiLCBcImdldEFXYWxsZXRcIjogXCLQodC60LDRh9Cw0YLRjCDQutC+0YjQtdC70ZHQulwiIH0sIFwicmVzdG9yZU1vZGFsXCI6IHsgXCJ0aXRsZVwiOiBcItCS0L7RgdGB0YLQsNC90L7QstC70LXQvdC40LVcIiwgXCJzdGVwMVwiOiB7IFwidGl0bGVcIjogXCLQndCw0LnQtNC40YLQtSDQstCw0YjRgyDRgtC10LrRg9GJ0YPRjiDRhNGA0LDQt9GDINCy0L7RgdGB0YLQsNC90L7QstC70LXQvdC40Y9cIiwgXCJ0ZXh0XCI6IFwi0J7RgtC60YDQvtC50YLQtSDQvdCw0YHRgtGA0L7QudC60Lgg0LrQvtGI0LXQu9GM0LrQsCDQuCDQvdCw0LnQtNC40YLQtSDRhNGA0LDQt9GDwqDQstC+0YHRgdGC0LDQvdC+0LLQu9C10L3QuNGPXCIgfSwgXCJzdGVwMlwiOiB7IFwidGl0bGVcIjogXCLQodC60L7Qv9C40YDRg9C50YLQtSDQstCw0YjRgyDRhNGA0LDQt9GDINCy0L7RgdGB0YLQsNC90L7QstC70LXQvdC40Y9cIiwgXCJ0ZXh0XCI6IFwi0JfQsNC/0LjRiNC40YLQtSDQtdGRINC40LvQuCDRgdC+0YXRgNCw0L3QuNGC0LUg0LIg0LHQtdC30L7Qv9Cw0YHQvdC+0Lwg0LzQtdGB0YLQtVwiIH0sIFwic3RlcDNcIjogeyBcInRpdGxlXCI6IFwi0JLQvtGB0YHRgtCw0L3QvtCy0LjRgtC1INCyINC/0L7QtNC00LXRgNC20LjQstCw0LXQvNC+0Lwg0LrQvtGI0LXQu9GM0LrQtVwiLCBcInRleHRcIjogXCLQktCy0LXQtNC40YLQtSDRhNGA0LDQt9GDINCy0L7RgdGB0YLQsNC90L7QstC70LXQvdC40Y8g0LTQu9GPINC00L7RgdGC0YPQv9CwwqDQusKg0LLQsNGI0LXQvNGDwqDQutC+0YjQtdC70YzQutGDXCIgfSB9LCBcImFsbFdhbGxldHNcIjogeyBcIndhbGxldHNCZWxvd05vdFN1cHBvcnRlZFwiOiBcItCa0L7RiNC10LvRjNC60Lgg0L3QuNC20LUg0L3QtSDQv9C+0LTQtNC10YDQttC40LLQsNGO0YIg0LLRgdC1INGE0YPQvdC60YbQuNC4INC/0L7QtNC60LvRjtGH0ZHQvdC90L7Qs9C+INGB0LXRgNCy0LjRgdCwLiDQktGLINC80L7QttC10YLQtSDQuNGB0L/QvtC70YzQt9C+0LLQsNGC0Ywg0YHQstC+0Y4g0YTRgNCw0LfRgyDQstC+0YHRgdGC0LDQvdC+0LLQu9C10L3QuNGPINCyINC+0LTQvdC+0Lwg0LjQtyDQv9C+0LTQtNC10YDQttC40LLQsNC10LzRi9GFINCy0YvRiNC1INC60L7RiNC10LvRjNC60L7Qsi5cIiwgXCJ3YWxsZXROb3RTdXBwb3J0U2VydmljZVwiOiBcInt7IG5hbWUgfX0g0L3QtSDQv9C+0LTQtNC10YDQttC40LLQsNC10YIg0L/QvtC00LrQu9GO0YfRkdC90L3Ri9C5INGB0LXRgNCy0LjRgVwiIH0sIFwiZmVhdHVyZU5vdFN1cHBvcnRlZFwiOiB7IFwid2FsbGV0XCI6IHsgXCJ0aXRsZVwiOiBcInt7IG5hbWUgfX0g0L3QtSDQv9C+0LTQtNC10YDQttC40LLQsNC10YIg0LfQsNC/0YDQvtGI0LXQvdC90L7QtcKg0LTQtdC50YHRgtCy0LjQtVwiLCBcImRlc2NyaXB0aW9uXCI6IFwi0KPRgdGC0LDQvdC+0LLQuNGC0LUg0L/QvtC00LTQtdGA0LbQuNCy0LDQtdC80YvQuSDQutC+0YjQtdC70ZHQuiDQuNC3INGB0L/QuNGB0LrQsCDQvdC40LbQtSwg0LLQvtGB0YHRgtCw0L3QvtCy0LjRgtC1INC10LPQviDRgSDQv9C+0LzQvtGJ0YzRjiDRhNGA0LDQt9GLINCy0L7RgdGB0YLQsNC90L7QstC70LXQvdC40Y8sINC30LDRgtC10Lwg0L/QvtC00LrQu9GO0YfQuNGC0LXRgdGMINC4INC/0L7Qv9GA0L7QsdGD0LnRgtC1INGB0L3QvtCy0LAuXCIsIFwiaW5mb1wiOiBcItCj0LfQvdCw0YLRjCwg0LrQsNC6INCy0L7RgdGB0YLQsNC90L7QstC40YLRjCDQutC+0YjQtdC70ZHQulwiIH0sIFwidmVyc2lvblwiOiB7IFwiZGVzY3JpcHRpb25cIjogXCLQotC10LrRg9GJ0LDRjyDQstC10YDRgdC40Y8ge3sgbmFtZSB9fSDQuNC70Lgg0YLQuNC/INC60L7QvdGC0YDQsNC60YLQsCDQutC+0YjQtdC70YzQutCwINC90LUg0L/QvtC00LTQtdGA0LbQuNCy0LDQtdGCINC90LXQvtCx0YXQvtC00LjQvNGL0LUg0YTRg9C90LrRhtC40LguINCe0LHQvdC+0LLQuNGC0LUg0LrQvtGI0LXQu9GR0LosINGH0YLQvtCx0Ysg0L/RgNC+0LTQvtC70LbQuNGC0YwuXCIsIFwidXBkYXRlQnV0dG9uXCI6IFwi0J7QsdC90L7QstC40YLRjCB7eyBuYW1lIH19XCIsIFwiYWJvdXRXNVwiOiBcItCf0YDQviBXNVwiIH0sIFwiZGlzY29ubmVjdFwiOiB7IFwidGl0bGVcIjogXCLQn9C+0LTRgtCy0LXRgNC00LjRgtC1INC+0YLQutC70Y7Rh9C10L3QuNC1XCIsIFwiZGVzY3JpcHRpb25cIjogXCLQktGLINCx0YPQtNC10YLQtSDQvtGC0LrQu9GO0YfQtdC90Ysg0L7RgiDRgtC10LrRg9GJ0LXQs9C+INC60L7RiNC10LvRjNC60LAg0Lgg0L/QtdGA0LXQvdCw0L/RgNCw0LLQu9C10L3RiyDQvdCwINC/0L7QtNC60LvRjtGH0LXQvdC40LUge3sgbmFtZSB9fS5cIiwgXCJidXR0b25cIjogXCLQntGC0LrQu9GO0YfQuNGC0YzRgdGPXCIgfSB9IH07XG5jb25zdCBhY3Rpb25Nb2RhbCA9IHsgXCJjb25maXJtVHJhbnNhY3Rpb25cIjogeyBcImhlYWRlclwiOiBcItCf0L7QtNGC0LLQtdGA0LTQuNGC0LUg0LTQtdC50YHRgtCy0LjQtSDQssKge3sgbmFtZSB9fVwiLCBcInRleHRcIjogXCLQrdGC0L4g0LfQsNC50LzQtdGCINC/0LDRgNGDINGB0LXQutGD0L3QtC5cIiB9LCBcInNpZ25EYXRhXCI6IHsgXCJoZWFkZXJcIjogXCLQn9C+0LTQv9C40YjQuNGC0LUg0LTQsNC90L3Ri9C1INCywqB7eyBuYW1lIH19XCIsIFwidGV4dFwiOiBcItCt0YLQviDQt9Cw0LnQvNC10YIg0L/QsNGA0YMg0YHQtdC60YPQvdC0LlwiIH0sIFwidHJhbnNhY3Rpb25TZW50XCI6IFwiJG5vdGlmaWNhdGlvbnMudHJhbnNhY3Rpb25TZW50XCIsIFwidHJhbnNhY3Rpb25DYW5jZWxlZFwiOiBcIiRub3RpZmljYXRpb25zLnRyYW5zYWN0aW9uQ2FuY2VsZWRcIiwgXCJkYXRhU2lnbmVkXCI6IFwiJG5vdGlmaWNhdGlvbnMuZGF0YVNpZ25lZFwiLCBcInNpZ25EYXRhQ2FuY2VsZWRcIjogXCIkbm90aWZpY2F0aW9ucy5zaWduRGF0YUNhbmNlbGVkXCIgfTtcbmNvbnN0IHJ1ID0ge1xuICBjb21tb24sXG4gIGJ1dHRvbixcbiAgbm90aWZpY2F0aW9ucyxcbiAgd2FsbGV0SXRlbSxcbiAgd2FsbGV0TW9kYWwsXG4gIGFjdGlvbk1vZGFsXG59O1xuY29uc3QgaTE4bkRpY3Rpb25hcnkgPSB7XG4gIGVuOiBwYXJzZURpY3Rpb25hcnkoZW4pLFxuICBydTogcGFyc2VEaWN0aW9uYXJ5KHJ1KVxufTtcbmZ1bmN0aW9uIHBhcnNlRGljdGlvbmFyeShkaWN0aW9uYXJ5KSB7XG4gIGNvbnN0IHJlZlN5bWJvbCA9IFwiJFwiO1xuICBjb25zdCBpdGVyYXRlID0gKHN1YkRpY3Rpb25hcnkpID0+IHtcbiAgICBPYmplY3QuZW50cmllcyhzdWJEaWN0aW9uYXJ5KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodmFsdWVbMF0gPT09IHJlZlN5bWJvbCkge1xuICAgICAgICAgIGNvbnN0IHBhdGggPSB2YWx1ZS5zbGljZSgxKS5zcGxpdChcIi5cIik7XG4gICAgICAgICAgbGV0IG9iaiA9IGRpY3Rpb25hcnk7XG4gICAgICAgICAgcGF0aC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgb2JqID0gb2JqW2l0ZW1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBDYW5ub3QgcGFyc2UgdHJhbnNsYXRpb25zOiB0aGVyZSBpcyBubyBwcm9wZXJ0eSAke2l0ZW19IGluIHRyYW5zbGF0aW9uYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN1YkRpY3Rpb25hcnlba2V5XSA9IG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUuc2xpY2UoMCwgMikgPT09IGBcXFxcJHtyZWZTeW1ib2x9YCkge1xuICAgICAgICAgIHN1YkRpY3Rpb25hcnlba2V5XSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGl0ZXJhdGUoZGljdGlvbmFyeSk7XG4gIHJldHVybiBkaWN0aW9uYXJ5O1xufVxuY29uc3QgQ29ubmVjdG9yQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoKTtcbmNvbnN0ICRSQVcgPSBTeW1ib2woXCJzdG9yZS1yYXdcIiksICROT0RFID0gU3ltYm9sKFwic3RvcmUtbm9kZVwiKSwgJEhBUyA9IFN5bWJvbChcInN0b3JlLWhhc1wiKSwgJFNFTEYgPSBTeW1ib2woXCJzdG9yZS1zZWxmXCIpO1xuZnVuY3Rpb24gd3JhcCQxKHZhbHVlKSB7XG4gIGxldCBwMiA9IHZhbHVlWyRQUk9YWV07XG4gIGlmICghcDIpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWUsICRQUk9YWSwge1xuICAgICAgdmFsdWU6IHAyID0gbmV3IFByb3h5KHZhbHVlLCBwcm94eVRyYXBzJDEpXG4gICAgfSk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKSwgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHZhbHVlKTtcbiAgICAgIGZvciAobGV0IGkyID0gMCwgbDIgPSBrZXlzLmxlbmd0aDsgaTIgPCBsMjsgaTIrKykge1xuICAgICAgICBjb25zdCBwcm9wID0ga2V5c1tpMl07XG4gICAgICAgIGlmIChkZXNjW3Byb3BdLmdldCkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZSwgcHJvcCwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZGVzY1twcm9wXS5lbnVtZXJhYmxlLFxuICAgICAgICAgICAgZ2V0OiBkZXNjW3Byb3BdLmdldC5iaW5kKHAyKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwMjtcbn1cbmZ1bmN0aW9uIGlzV3JhcHBhYmxlKG9iaikge1xuICBsZXQgcHJvdG87XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIChvYmpbJFBST1hZXSB8fCAhKHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikpIHx8IHByb3RvID09PSBPYmplY3QucHJvdG90eXBlIHx8IEFycmF5LmlzQXJyYXkob2JqKSk7XG59XG5mdW5jdGlvbiB1bndyYXAoaXRlbSwgc2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkge1xuICBsZXQgcmVzdWx0LCB1bndyYXBwZWQsIHYsIHByb3A7XG4gIGlmIChyZXN1bHQgPSBpdGVtICE9IG51bGwgJiYgaXRlbVskUkFXXSkgcmV0dXJuIHJlc3VsdDtcbiAgaWYgKCFpc1dyYXBwYWJsZShpdGVtKSB8fCBzZXQuaGFzKGl0ZW0pKSByZXR1cm4gaXRlbTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICBpZiAoT2JqZWN0LmlzRnJvemVuKGl0ZW0pKSBpdGVtID0gaXRlbS5zbGljZSgwKTtcbiAgICBlbHNlIHNldC5hZGQoaXRlbSk7XG4gICAgZm9yIChsZXQgaTIgPSAwLCBsMiA9IGl0ZW0ubGVuZ3RoOyBpMiA8IGwyOyBpMisrKSB7XG4gICAgICB2ID0gaXRlbVtpMl07XG4gICAgICBpZiAoKHVud3JhcHBlZCA9IHVud3JhcCh2LCBzZXQpKSAhPT0gdikgaXRlbVtpMl0gPSB1bndyYXBwZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChPYmplY3QuaXNGcm96ZW4oaXRlbSkpIGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBpdGVtKTtcbiAgICBlbHNlIHNldC5hZGQoaXRlbSk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGl0ZW0pLCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoaXRlbSk7XG4gICAgZm9yIChsZXQgaTIgPSAwLCBsMiA9IGtleXMubGVuZ3RoOyBpMiA8IGwyOyBpMisrKSB7XG4gICAgICBwcm9wID0ga2V5c1tpMl07XG4gICAgICBpZiAoZGVzY1twcm9wXS5nZXQpIGNvbnRpbnVlO1xuICAgICAgdiA9IGl0ZW1bcHJvcF07XG4gICAgICBpZiAoKHVud3JhcHBlZCA9IHVud3JhcCh2LCBzZXQpKSAhPT0gdikgaXRlbVtwcm9wXSA9IHVud3JhcHBlZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5mdW5jdGlvbiBnZXROb2Rlcyh0YXJnZXQsIHN5bWJvbCkge1xuICBsZXQgbm9kZXMgPSB0YXJnZXRbc3ltYm9sXTtcbiAgaWYgKCFub2RlcykgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgc3ltYm9sLCB7XG4gICAgdmFsdWU6IG5vZGVzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbClcbiAgfSk7XG4gIHJldHVybiBub2Rlcztcbn1cbmZ1bmN0aW9uIGdldE5vZGUobm9kZXMsIHByb3BlcnR5LCB2YWx1ZSkge1xuICBpZiAobm9kZXNbcHJvcGVydHldKSByZXR1cm4gbm9kZXNbcHJvcGVydHldO1xuICBjb25zdCBbczIsIHNldF0gPSBjcmVhdGVTaWduYWwodmFsdWUsIHtcbiAgICBlcXVhbHM6IGZhbHNlLFxuICAgIGludGVybmFsOiB0cnVlXG4gIH0pO1xuICBzMi4kID0gc2V0O1xuICByZXR1cm4gbm9kZXNbcHJvcGVydHldID0gczI7XG59XG5mdW5jdGlvbiBwcm94eURlc2NyaXB0b3IkMSh0YXJnZXQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IGRlc2MgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5KTtcbiAgaWYgKCFkZXNjIHx8IGRlc2MuZ2V0IHx8ICFkZXNjLmNvbmZpZ3VyYWJsZSB8fCBwcm9wZXJ0eSA9PT0gJFBST1hZIHx8IHByb3BlcnR5ID09PSAkTk9ERSkgcmV0dXJuIGRlc2M7XG4gIGRlbGV0ZSBkZXNjLnZhbHVlO1xuICBkZWxldGUgZGVzYy53cml0YWJsZTtcbiAgZGVzYy5nZXQgPSAoKSA9PiB0YXJnZXRbJFBST1hZXVtwcm9wZXJ0eV07XG4gIHJldHVybiBkZXNjO1xufVxuZnVuY3Rpb24gdHJhY2tTZWxmKHRhcmdldCkge1xuICBnZXRMaXN0ZW5lcigpICYmIGdldE5vZGUoZ2V0Tm9kZXModGFyZ2V0LCAkTk9ERSksICRTRUxGKSgpO1xufVxuZnVuY3Rpb24gb3duS2V5cyh0YXJnZXQpIHtcbiAgdHJhY2tTZWxmKHRhcmdldCk7XG4gIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbn1cbmNvbnN0IHByb3h5VHJhcHMkMSA9IHtcbiAgZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgaWYgKHByb3BlcnR5ID09PSAkUkFXKSByZXR1cm4gdGFyZ2V0O1xuICAgIGlmIChwcm9wZXJ0eSA9PT0gJFBST1hZKSByZXR1cm4gcmVjZWl2ZXI7XG4gICAgaWYgKHByb3BlcnR5ID09PSAkVFJBQ0spIHtcbiAgICAgIHRyYWNrU2VsZih0YXJnZXQpO1xuICAgICAgcmV0dXJuIHJlY2VpdmVyO1xuICAgIH1cbiAgICBjb25zdCBub2RlcyA9IGdldE5vZGVzKHRhcmdldCwgJE5PREUpO1xuICAgIGNvbnN0IHRyYWNrZWQgPSBub2Rlc1twcm9wZXJ0eV07XG4gICAgbGV0IHZhbHVlID0gdHJhY2tlZCA/IHRyYWNrZWQoKSA6IHRhcmdldFtwcm9wZXJ0eV07XG4gICAgaWYgKHByb3BlcnR5ID09PSAkTk9ERSB8fCBwcm9wZXJ0eSA9PT0gJEhBUyB8fCBwcm9wZXJ0eSA9PT0gXCJfX3Byb3RvX19cIikgcmV0dXJuIHZhbHVlO1xuICAgIGlmICghdHJhY2tlZCkge1xuICAgICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICBpZiAoZ2V0TGlzdGVuZXIoKSAmJiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIgfHwgdGFyZ2V0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSkgJiYgIShkZXNjICYmIGRlc2MuZ2V0KSkgdmFsdWUgPSBnZXROb2RlKG5vZGVzLCBwcm9wZXJ0eSwgdmFsdWUpKCk7XG4gICAgfVxuICAgIHJldHVybiBpc1dyYXBwYWJsZSh2YWx1ZSkgPyB3cmFwJDEodmFsdWUpIDogdmFsdWU7XG4gIH0sXG4gIGhhcyh0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgaWYgKHByb3BlcnR5ID09PSAkUkFXIHx8IHByb3BlcnR5ID09PSAkUFJPWFkgfHwgcHJvcGVydHkgPT09ICRUUkFDSyB8fCBwcm9wZXJ0eSA9PT0gJE5PREUgfHwgcHJvcGVydHkgPT09ICRIQVMgfHwgcHJvcGVydHkgPT09IFwiX19wcm90b19fXCIpIHJldHVybiB0cnVlO1xuICAgIGdldExpc3RlbmVyKCkgJiYgZ2V0Tm9kZShnZXROb2Rlcyh0YXJnZXQsICRIQVMpLCBwcm9wZXJ0eSkoKTtcbiAgICByZXR1cm4gcHJvcGVydHkgaW4gdGFyZ2V0O1xuICB9LFxuICBzZXQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGRlbGV0ZVByb3BlcnR5KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBvd25LZXlzLFxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IHByb3h5RGVzY3JpcHRvciQxXG59O1xuZnVuY3Rpb24gc2V0UHJvcGVydHkoc3RhdGUsIHByb3BlcnR5LCB2YWx1ZSwgZGVsZXRpbmcgPSBmYWxzZSkge1xuICBpZiAoIWRlbGV0aW5nICYmIHN0YXRlW3Byb3BlcnR5XSA9PT0gdmFsdWUpIHJldHVybjtcbiAgY29uc3QgcHJldiA9IHN0YXRlW3Byb3BlcnR5XSwgbGVuID0gc3RhdGUubGVuZ3RoO1xuICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgIGRlbGV0ZSBzdGF0ZVtwcm9wZXJ0eV07XG4gICAgaWYgKHN0YXRlWyRIQVNdICYmIHN0YXRlWyRIQVNdW3Byb3BlcnR5XSAmJiBwcmV2ICE9PSB2b2lkIDApIHN0YXRlWyRIQVNdW3Byb3BlcnR5XS4kKCk7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgaWYgKHN0YXRlWyRIQVNdICYmIHN0YXRlWyRIQVNdW3Byb3BlcnR5XSAmJiBwcmV2ID09PSB2b2lkIDApIHN0YXRlWyRIQVNdW3Byb3BlcnR5XS4kKCk7XG4gIH1cbiAgbGV0IG5vZGVzID0gZ2V0Tm9kZXMoc3RhdGUsICROT0RFKSwgbm9kZTtcbiAgaWYgKG5vZGUgPSBnZXROb2RlKG5vZGVzLCBwcm9wZXJ0eSwgcHJldikpIG5vZGUuJCgoKSA9PiB2YWx1ZSk7XG4gIGlmIChBcnJheS5pc0FycmF5KHN0YXRlKSAmJiBzdGF0ZS5sZW5ndGggIT09IGxlbikge1xuICAgIGZvciAobGV0IGkyID0gc3RhdGUubGVuZ3RoOyBpMiA8IGxlbjsgaTIrKykgKG5vZGUgPSBub2Rlc1tpMl0pICYmIG5vZGUuJCgpO1xuICAgIChub2RlID0gZ2V0Tm9kZShub2RlcywgXCJsZW5ndGhcIiwgbGVuKSkgJiYgbm9kZS4kKHN0YXRlLmxlbmd0aCk7XG4gIH1cbiAgKG5vZGUgPSBub2Rlc1skU0VMRl0pICYmIG5vZGUuJCgpO1xufVxuZnVuY3Rpb24gbWVyZ2VTdG9yZU5vZGUoc3RhdGUsIHZhbHVlKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBrZXlzLmxlbmd0aDsgaTIgKz0gMSkge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaTJdO1xuICAgIHNldFByb3BlcnR5KHN0YXRlLCBrZXksIHZhbHVlW2tleV0pO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVBcnJheShjdXJyZW50LCBuZXh0KSB7XG4gIGlmICh0eXBlb2YgbmV4dCA9PT0gXCJmdW5jdGlvblwiKSBuZXh0ID0gbmV4dChjdXJyZW50KTtcbiAgbmV4dCA9IHVud3JhcChuZXh0KTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbmV4dCkgcmV0dXJuO1xuICAgIGxldCBpMiA9IDAsIGxlbiA9IG5leHQubGVuZ3RoO1xuICAgIGZvciAoOyBpMiA8IGxlbjsgaTIrKykge1xuICAgICAgY29uc3QgdmFsdWUgPSBuZXh0W2kyXTtcbiAgICAgIGlmIChjdXJyZW50W2kyXSAhPT0gdmFsdWUpIHNldFByb3BlcnR5KGN1cnJlbnQsIGkyLCB2YWx1ZSk7XG4gICAgfVxuICAgIHNldFByb3BlcnR5KGN1cnJlbnQsIFwibGVuZ3RoXCIsIGxlbik7XG4gIH0gZWxzZSBtZXJnZVN0b3JlTm9kZShjdXJyZW50LCBuZXh0KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVBhdGgoY3VycmVudCwgcGF0aCwgdHJhdmVyc2VkID0gW10pIHtcbiAgbGV0IHBhcnQsIHByZXYgPSBjdXJyZW50O1xuICBpZiAocGF0aC5sZW5ndGggPiAxKSB7XG4gICAgcGFydCA9IHBhdGguc2hpZnQoKTtcbiAgICBjb25zdCBwYXJ0VHlwZSA9IHR5cGVvZiBwYXJ0LCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShjdXJyZW50KTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJ0KSkge1xuICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHBhcnQubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIHVwZGF0ZVBhdGgoY3VycmVudCwgW3BhcnRbaTJdXS5jb25jYXQocGF0aCksIHRyYXZlcnNlZCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChpc0FycmF5ICYmIHBhcnRUeXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBjdXJyZW50Lmxlbmd0aDsgaTIrKykge1xuICAgICAgICBpZiAocGFydChjdXJyZW50W2kyXSwgaTIpKSB1cGRhdGVQYXRoKGN1cnJlbnQsIFtpMl0uY29uY2F0KHBhdGgpLCB0cmF2ZXJzZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSAmJiBwYXJ0VHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmcm9tID0gMCxcbiAgICAgICAgdG8gPSBjdXJyZW50Lmxlbmd0aCAtIDEsXG4gICAgICAgIGJ5ID0gMVxuICAgICAgfSA9IHBhcnQ7XG4gICAgICBmb3IgKGxldCBpMiA9IGZyb207IGkyIDw9IHRvOyBpMiArPSBieSkge1xuICAgICAgICB1cGRhdGVQYXRoKGN1cnJlbnQsIFtpMl0uY29uY2F0KHBhdGgpLCB0cmF2ZXJzZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAocGF0aC5sZW5ndGggPiAxKSB7XG4gICAgICB1cGRhdGVQYXRoKGN1cnJlbnRbcGFydF0sIHBhdGgsIFtwYXJ0XS5jb25jYXQodHJhdmVyc2VkKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByZXYgPSBjdXJyZW50W3BhcnRdO1xuICAgIHRyYXZlcnNlZCA9IFtwYXJ0XS5jb25jYXQodHJhdmVyc2VkKTtcbiAgfVxuICBsZXQgdmFsdWUgPSBwYXRoWzBdO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YWx1ZSA9IHZhbHVlKHByZXYsIHRyYXZlcnNlZCk7XG4gICAgaWYgKHZhbHVlID09PSBwcmV2KSByZXR1cm47XG4gIH1cbiAgaWYgKHBhcnQgPT09IHZvaWQgMCAmJiB2YWx1ZSA9PSB2b2lkIDApIHJldHVybjtcbiAgdmFsdWUgPSB1bndyYXAodmFsdWUpO1xuICBpZiAocGFydCA9PT0gdm9pZCAwIHx8IGlzV3JhcHBhYmxlKHByZXYpICYmIGlzV3JhcHBhYmxlKHZhbHVlKSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBtZXJnZVN0b3JlTm9kZShwcmV2LCB2YWx1ZSk7XG4gIH0gZWxzZSBzZXRQcm9wZXJ0eShjdXJyZW50LCBwYXJ0LCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTdG9yZSguLi5bc3RvcmUsIG9wdGlvbnNdKSB7XG4gIGNvbnN0IHVud3JhcHBlZFN0b3JlID0gdW53cmFwKHN0b3JlIHx8IHt9KTtcbiAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkodW53cmFwcGVkU3RvcmUpO1xuICBjb25zdCB3cmFwcGVkU3RvcmUgPSB3cmFwJDEodW53cmFwcGVkU3RvcmUpO1xuICBmdW5jdGlvbiBzZXRTdG9yZSguLi5hcmdzKSB7XG4gICAgYmF0Y2goKCkgPT4ge1xuICAgICAgaXNBcnJheSAmJiBhcmdzLmxlbmd0aCA9PT0gMSA/IHVwZGF0ZUFycmF5KHVud3JhcHBlZFN0b3JlLCBhcmdzWzBdKSA6IHVwZGF0ZVBhdGgodW53cmFwcGVkU3RvcmUsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBbd3JhcHBlZFN0b3JlLCBzZXRTdG9yZV07XG59XG5jb25zdCBkZWZhdWx0TGlnaHRDb2xvcnNTZXQgPSB7XG4gIGNvbnN0YW50OiB7XG4gICAgYmxhY2s6IFwiIzAwMDAwMFwiLFxuICAgIHdoaXRlOiBcIiNGRkZGRkZcIlxuICB9LFxuICBjb25uZWN0QnV0dG9uOiB7XG4gICAgYmFja2dyb3VuZDogXCIjMDA5OEVBXCIsXG4gICAgZm9yZWdyb3VuZDogXCIjRkZGRkZGXCJcbiAgfSxcbiAgYWNjZW50OiBcIiMwMDk4RUFcIixcbiAgdGVsZWdyYW1CdXR0b246IFwiIzAwOThFQVwiLFxuICBpY29uOiB7XG4gICAgcHJpbWFyeTogXCIjMEYwRjBGXCIsXG4gICAgc2Vjb25kYXJ5OiBcIiM3QTg5OTlcIixcbiAgICB0ZXJ0aWFyeTogXCIjQzFDQUQyXCIsXG4gICAgc3VjY2VzczogXCIjMjlDQzZBXCIsXG4gICAgZXJyb3I6IFwiI0Y1QTczQlwiXG4gIH0sXG4gIGJhY2tncm91bmQ6IHtcbiAgICBwcmltYXJ5OiBcIiNGRkZGRkZcIixcbiAgICBzZWNvbmRhcnk6IFwiI0YxRjNGNVwiLFxuICAgIHNlZ21lbnQ6IFwiI0ZGRkZGRlwiLFxuICAgIHRpbnQ6IFwiI0YxRjNGNVwiLFxuICAgIHFyOiBcIiNGMUYzRjVcIlxuICB9LFxuICB0ZXh0OiB7XG4gICAgcHJpbWFyeTogXCIjMEYwRjBGXCIsXG4gICAgc2Vjb25kYXJ5OiBcIiM2QTc3ODVcIlxuICB9XG59O1xuY29uc3QgZGVmYXVsdERhcmtDb2xvcnNTZXQgPSB7XG4gIGNvbnN0YW50OiB7XG4gICAgYmxhY2s6IFwiIzAwMDAwMFwiLFxuICAgIHdoaXRlOiBcIiNGRkZGRkZcIlxuICB9LFxuICBjb25uZWN0QnV0dG9uOiB7XG4gICAgYmFja2dyb3VuZDogXCIjMDA5OEVBXCIsXG4gICAgZm9yZWdyb3VuZDogXCIjRkZGRkZGXCJcbiAgfSxcbiAgYWNjZW50OiBcIiNFNUU1RUFcIixcbiAgdGVsZWdyYW1CdXR0b246IFwiIzMxQTZGNVwiLFxuICBpY29uOiB7XG4gICAgcHJpbWFyeTogXCIjRTVFNUVBXCIsXG4gICAgc2Vjb25kYXJ5OiBcIiM5MDkwOTlcIixcbiAgICB0ZXJ0aWFyeTogXCIjNDM0MzQ3XCIsXG4gICAgc3VjY2VzczogXCIjMjlDQzZBXCIsXG4gICAgZXJyb3I6IFwiI0Y1QTczQlwiXG4gIH0sXG4gIGJhY2tncm91bmQ6IHtcbiAgICBwcmltYXJ5OiBcIiMxMjEyMTRcIixcbiAgICBzZWNvbmRhcnk6IFwiIzE4MTgxQVwiLFxuICAgIHNlZ21lbnQ6IFwiIzI2MjYyOVwiLFxuICAgIHRpbnQ6IFwiIzIyMjIyNFwiLFxuICAgIHFyOiBcIiNGRkZGRkZcIlxuICB9LFxuICB0ZXh0OiB7XG4gICAgcHJpbWFyeTogXCIjRTVFNUVBXCIsXG4gICAgc2Vjb25kYXJ5OiBcIiM3RDdEODVcIlxuICB9XG59O1xuLyohXG4gKiBpcy1wbGFpbi1vYmplY3QgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLXBsYWluLW9iamVjdD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KG8yKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobzIpID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvMikge1xuICB2YXIgY3RvciwgcHJvdDtcbiAgaWYgKGlzT2JqZWN0KG8yKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgY3RvciA9IG8yLmNvbnN0cnVjdG9yO1xuICBpZiAoY3RvciA9PT0gdm9pZCAwKSByZXR1cm4gdHJ1ZTtcbiAgcHJvdCA9IGN0b3IucHJvdG90eXBlO1xuICBpZiAoaXNPYmplY3QocHJvdCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChwcm90Lmhhc093blByb3BlcnR5KFwiaXNQcm90b3R5cGVPZlwiKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMob3B0aW9ucywgZGVmYXVsdE9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRPcHRpb25zO1xuICB9XG4gIGNvbnN0IG92ZXJ3cml0ZU1lcmdlID0gKF8sIHNvdXJjZUFycmF5LCBfXykgPT4gc291cmNlQXJyYXk7XG4gIHJldHVybiBkZWVwbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMsIHtcbiAgICBhcnJheU1lcmdlOiBvdmVyd3JpdGVNZXJnZSxcbiAgICBpc01lcmdlYWJsZU9iamVjdDogaXNQbGFpbk9iamVjdFxuICB9KTtcbn1cbmNvbnN0IFt0aGVtZVN0YXRlLCBzZXRUaGVtZVN0YXRlXSA9IGNyZWF0ZVN0b3JlKHtcbiAgdGhlbWU6IFRIRU1FLkxJR0hULFxuICBjb2xvcnM6IGRlZmF1bHRMaWdodENvbG9yc1NldCxcbiAgYm9yZGVyUmFkaXVzOiBcIm1cIlxufSk7XG5jb25zdCB0aGVtZUNvbG9yc01hcHBpbmdEZWZhdWx0ID0ge1xuICBbVEhFTUUuTElHSFRdOiBkZWZhdWx0TGlnaHRDb2xvcnNTZXQsXG4gIFtUSEVNRS5EQVJLXTogZGVmYXVsdERhcmtDb2xvcnNTZXRcbn07XG5jb25zdCB0aGVtZUN1c3RvbUNvbG9ycyA9IHtcbiAgW1RIRU1FLkxJR0hUXTogdm9pZCAwLFxuICBbVEhFTUUuREFSS106IHZvaWQgMFxufTtcbmZ1bmN0aW9uIHNldFRoZW1lKHRoZW1lLCBjb2xvcnNTZXQpIHtcbiAgaWYgKGNvbG9yc1NldCkge1xuICAgIHRoZW1lQ3VzdG9tQ29sb3JzW1RIRU1FLkRBUktdID0gbWVyZ2VPcHRpb25zKFxuICAgICAgY29sb3JzU2V0W1RIRU1FLkRBUktdLFxuICAgICAgdGhlbWVDdXN0b21Db2xvcnNbVEhFTUUuREFSS11cbiAgICApO1xuICAgIHRoZW1lQ3VzdG9tQ29sb3JzW1RIRU1FLkxJR0hUXSA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIGNvbG9yc1NldFtUSEVNRS5MSUdIVF0sXG4gICAgICB0aGVtZUN1c3RvbUNvbG9yc1tUSEVNRS5MSUdIVF1cbiAgICApO1xuICB9XG4gIHNldFRoZW1lU3RhdGUoe1xuICAgIHRoZW1lLFxuICAgIGNvbG9yczogbWVyZ2VPcHRpb25zKHRoZW1lQ3VzdG9tQ29sb3JzW3RoZW1lXSwgdGhlbWVDb2xvcnNNYXBwaW5nRGVmYXVsdFt0aGVtZV0pXG4gIH0pO1xufVxuZnVuY3Rpb24gc2V0Qm9yZGVyUmFkaXVzKGJvcmRlclJhZGl1cykge1xuICBzZXRUaGVtZVN0YXRlKHsgYm9yZGVyUmFkaXVzIH0pO1xufVxuZnVuY3Rpb24gc2V0Q29sb3JzKGNvbG9yc1NldCkge1xuICB0aGVtZUN1c3RvbUNvbG9yc1tUSEVNRS5EQVJLXSA9IG1lcmdlT3B0aW9ucyhcbiAgICBjb2xvcnNTZXRbVEhFTUUuREFSS10sXG4gICAgdGhlbWVDdXN0b21Db2xvcnNbVEhFTUUuREFSS11cbiAgKTtcbiAgdGhlbWVDdXN0b21Db2xvcnNbVEhFTUUuTElHSFRdID0gbWVyZ2VPcHRpb25zKFxuICAgIGNvbG9yc1NldFtUSEVNRS5MSUdIVF0sXG4gICAgdGhlbWVDdXN0b21Db2xvcnNbVEhFTUUuTElHSFRdXG4gICk7XG4gIHNldFRoZW1lU3RhdGUoKHN0YXRlKSA9PiAoe1xuICAgIGNvbG9yczogbWVyZ2VPcHRpb25zKFxuICAgICAgdGhlbWVDdXN0b21Db2xvcnNbc3RhdGUudGhlbWVdLFxuICAgICAgdGhlbWVDb2xvcnNNYXBwaW5nRGVmYXVsdFtzdGF0ZS50aGVtZV1cbiAgICApXG4gIH0pKTtcbn1cbmNvbnN0IEltYWdlUGxhY2Vob2xkZXIgPSBzdHlsZWQuZGl2YFxuICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5zZWNvbmRhcnl9O1xuYDtcbmNvbnN0IEltYWdlID0gKHByb3BzKSA9PiB7XG4gIGxldCBpbWdSZWY7XG4gIGNvbnN0IFtpbWFnZSwgc2V0SW1hZ2VdID0gY3JlYXRlU2lnbmFsKG51bGwpO1xuICBjcmVhdGVFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGltZyA9IG5ldyB3aW5kb3cuSW1hZ2UoKTtcbiAgICBpbWcuc3JjID0gcHJvcHMuc3JjO1xuICAgIGltZy5hbHQgPSBwcm9wcy5hbHQgfHwgXCJcIjtcbiAgICBpbWcuc2V0QXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIsIFwiZmFsc2VcIik7XG4gICAgaWYgKHByb3BzLmNsYXNzKSB7XG4gICAgICBpbWcuY2xhc3NMaXN0LmFkZChwcm9wcy5jbGFzcyk7XG4gICAgfVxuICAgIGlmIChpbWcuY29tcGxldGUpIHtcbiAgICAgIHJldHVybiBzZXRJbWFnZShpbWcpO1xuICAgIH1cbiAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4gc2V0SW1hZ2UoaW1nKSk7XG4gICAgcmV0dXJuICgpID0+IGltZy5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiBzZXRJbWFnZShpbWcpKTtcbiAgfSk7XG4gIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICBnZXQgd2hlbigpIHtcbiAgICAgIHJldHVybiBpbWFnZSgpO1xuICAgIH0sXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIGltYWdlKCk7XG4gICAgfVxuICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICBnZXQgd2hlbigpIHtcbiAgICAgIHJldHVybiAhaW1hZ2UoKTtcbiAgICB9LFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoSW1hZ2VQbGFjZWhvbGRlciwge1xuICAgICAgICBnZXQgW1wiY2xhc3NcIl0oKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgICAgICB9LFxuICAgICAgICByZWYociQpIHtcbiAgICAgICAgICB2YXIgX3JlZiQgPSBpbWdSZWY7XG4gICAgICAgICAgdHlwZW9mIF9yZWYkID09PSBcImZ1bmN0aW9uXCIgPyBfcmVmJChyJCkgOiBpbWdSZWYgPSByJDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KV07XG59O1xubGV0IGluaXRQYXJhbXMgPSB7fTtcbnRyeSB7XG4gIGxldCBsb2NhdGlvbkhhc2ggPSBsb2NhdGlvbi5oYXNoLnRvU3RyaW5nKCk7XG4gIGluaXRQYXJhbXMgPSB1cmxQYXJzZUhhc2hQYXJhbXMobG9jYXRpb25IYXNoKTtcbn0gY2F0Y2ggKGUyKSB7XG59XG50cnkge1xuICBjb25zdCBsYXVuY2hQYXJhbXNTdG9yYWdlS2V5ID0gXCJ0b24tY29ubmVjdC1zZXNzaW9uX3N0b3JhZ2VfbGF1bmNoUGFyYW1zXCI7XG4gIGlmIChPYmplY3QuZW50cmllcyhpbml0UGFyYW1zKS5sZW5ndGggPiAwKSB7XG4gICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShsYXVuY2hQYXJhbXNTdG9yYWdlS2V5LCBKU09OLnN0cmluZ2lmeShpbml0UGFyYW1zKSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc2F2ZWRJbml0UGFyYW1zID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShsYXVuY2hQYXJhbXNTdG9yYWdlS2V5KTtcbiAgICBpZiAoc2F2ZWRJbml0UGFyYW1zKSB7XG4gICAgICBpbml0UGFyYW1zID0gSlNPTi5wYXJzZShzYXZlZEluaXRQYXJhbXMpO1xuICAgIH1cbiAgfVxufSBjYXRjaCAoZTIpIHtcbn1cbmxldCB0bWFQbGF0Zm9ybSA9IFwidW5rbm93blwiO1xuaWYgKGluaXRQYXJhbXMgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXRQYXJhbXMudGdXZWJBcHBQbGF0Zm9ybSkge1xuICB0bWFQbGF0Zm9ybSA9IChfYSA9IGluaXRQYXJhbXMudGdXZWJBcHBQbGF0Zm9ybSkgIT0gbnVsbCA/IF9hIDogXCJ1bmtub3duXCI7XG59XG5pZiAodG1hUGxhdGZvcm0gPT09IFwidW5rbm93blwiKSB7XG4gIGNvbnN0IHdpbmRvdzIgPSBnZXRXaW5kb3ckMSgpO1xuICB0bWFQbGF0Zm9ybSA9IChfZCA9IChfYyA9IChfYiA9IHdpbmRvdzIgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdzIuVGVsZWdyYW0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5XZWJBcHApID09IG51bGwgPyB2b2lkIDAgOiBfYy5wbGF0Zm9ybSkgIT0gbnVsbCA/IF9kIDogXCJ1bmtub3duXCI7XG59XG5sZXQgd2ViQXBwVmVyc2lvbiA9IFwiNi4wXCI7XG5pZiAoaW5pdFBhcmFtcyA9PSBudWxsID8gdm9pZCAwIDogaW5pdFBhcmFtcy50Z1dlYkFwcFZlcnNpb24pIHtcbiAgd2ViQXBwVmVyc2lvbiA9IGluaXRQYXJhbXMudGdXZWJBcHBWZXJzaW9uO1xufVxuaWYgKCF3ZWJBcHBWZXJzaW9uKSB7XG4gIGNvbnN0IHdpbmRvdzIgPSBnZXRXaW5kb3ckMSgpO1xuICB3ZWJBcHBWZXJzaW9uID0gKF9nID0gKF9mID0gKF9lID0gd2luZG93MiA9PSBudWxsID8gdm9pZCAwIDogd2luZG93Mi5UZWxlZ3JhbSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLldlYkFwcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLnZlcnNpb24pICE9IG51bGwgPyBfZyA6IFwiNi4wXCI7XG59XG5jb25zdCBpbml0RGF0YVJhdyA9IGluaXRQYXJhbXMgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXRQYXJhbXMudGdXZWJBcHBEYXRhO1xubGV0IHRlbGVncmFtVXNlciA9IHZvaWQgMDtcbnRyeSB7XG4gIGlmIChpbml0RGF0YVJhdykge1xuICAgIGxldCBpbml0RGF0YSA9IHVybFBhcnNlUXVlcnlTdHJpbmcoaW5pdERhdGFSYXcpO1xuICAgIGxldCB1c2VyUmF3ID0gaW5pdERhdGEudXNlcjtcbiAgICBpZiAodXNlclJhdykge1xuICAgICAgbGV0IHVzZXIgPSBKU09OLnBhcnNlKHVzZXJSYXcpO1xuICAgICAgaWYgKHR5cGVvZiB1c2VyLmlkID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB1c2VyLmlzX3ByZW1pdW0gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHRlbGVncmFtVXNlciA9IHtcbiAgICAgICAgICBpZDogdXNlci5pZCxcbiAgICAgICAgICBpc1ByZW1pdW06IHVzZXIuaXNfcHJlbWl1bVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufSBjYXRjaCAoZTIpIHtcbn1cbmZ1bmN0aW9uIGdldFRnVXNlcigpIHtcbiAgcmV0dXJuIHRlbGVncmFtVXNlcjtcbn1cbmZ1bmN0aW9uIGlzVG1hUGxhdGZvcm0oLi4ucGxhdGZvcm1zKSB7XG4gIHJldHVybiBwbGF0Zm9ybXMuaW5jbHVkZXModG1hUGxhdGZvcm0pO1xufVxuZnVuY3Rpb24gaXNJblRNQSgpIHtcbiAgdmFyIF9hMjtcbiAgcmV0dXJuIHRtYVBsYXRmb3JtICE9PSBcInVua25vd25cIiB8fCAhISgoX2EyID0gZ2V0V2luZG93JDEoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5UZWxlZ3JhbVdlYnZpZXdQcm94eSk7XG59XG5mdW5jdGlvbiBpc0luVGVsZWdyYW1Ccm93c2VyKCkge1xuICB2YXIgX2EyO1xuICBjb25zdCBpc1RlbGVncmFtV2VidmlldyA9ICEhKChfYTIgPSBnZXRXaW5kb3ckMSgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLlRlbGVncmFtV2Vidmlldyk7XG4gIHJldHVybiAoaXNJblRNQSgpIHx8IGlzVGVsZWdyYW1XZWJ2aWV3KSAmJiB0bWFQbGF0Zm9ybSA9PT0gXCJ1bmtub3duXCI7XG59XG5mdW5jdGlvbiBzZW5kRXhwYW5kKCkge1xuICBwb3N0RXZlbnQoXCJ3ZWJfYXBwX2V4cGFuZFwiLCB7fSk7XG59XG5mdW5jdGlvbiBzZW5kT3BlblRlbGVncmFtTGluayhsaW5rLCBmYWxsYmFjaykge1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKGxpbmspO1xuICBpZiAodXJsLnByb3RvY29sICE9PSBcImh0dHA6XCIgJiYgdXJsLnByb3RvY29sICE9PSBcImh0dHBzOlwiKSB7XG4gICAgaWYgKGZhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZmFsbGJhY2soKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RVSUVycm9yKGBVcmwgcHJvdG9jb2wgaXMgbm90IHN1cHBvcnRlZDogJHt1cmx9YCk7XG4gIH1cbiAgaWYgKHVybC5ob3N0bmFtZSAhPT0gXCJ0Lm1lXCIpIHtcbiAgICBpZiAoZmFsbGJhY2spIHtcbiAgICAgIHJldHVybiBmYWxsYmFjaygpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdFVJRXJyb3IoYFVybCBob3N0IGlzIG5vdCBzdXBwb3J0ZWQ6ICR7dXJsfWApO1xuICB9XG4gIGNvbnN0IHBhdGhGdWxsID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgaWYgKGlzSWZyYW1lKCkgfHwgdmVyc2lvbkF0TGVhc3QoXCI2LjFcIikpIHtcbiAgICBzZXRMYXN0T3BlbmVkTGluayh7IGxpbms6IHBhdGhGdWxsLCB0eXBlOiBcInRnX2xpbmtcIiB9KTtcbiAgICBwb3N0RXZlbnQoXCJ3ZWJfYXBwX29wZW5fdGdfbGlua1wiLCB7IHBhdGhfZnVsbDogcGF0aEZ1bGwgfSk7XG4gIH0gZWxzZSB7XG4gICAgb3BlbkxpbmtCbGFuayhcImh0dHBzOi8vdC5tZVwiICsgcGF0aEZ1bGwpO1xuICB9XG59XG5mdW5jdGlvbiBpc0lmcmFtZSgpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB3aW5kb3cyID0gZ2V0V2luZG93JDEoKTtcbiAgICBpZiAoIXdpbmRvdzIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdzIucGFyZW50ICE9IG51bGwgJiYgd2luZG93MiAhPT0gd2luZG93Mi5wYXJlbnQ7XG4gIH0gY2F0Y2ggKGUyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBwb3N0RXZlbnQoZXZlbnRUeXBlLCBldmVudERhdGEpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB3aW5kb3cyID0gZ2V0V2luZG93JDEoKTtcbiAgICBpZiAoIXdpbmRvdzIpIHtcbiAgICAgIHRocm93IG5ldyBUb25Db25uZWN0VUlFcnJvcihgQ2FuJ3QgcG9zdCBldmVudCB0byBwYXJlbnQgd2luZG93OiB3aW5kb3cgaXMgbm90IGRlZmluZWRgKTtcbiAgICB9XG4gICAgaWYgKHdpbmRvdzIuVGVsZWdyYW1XZWJ2aWV3UHJveHkgIT09IHZvaWQgMCkge1xuICAgICAgbG9nRGVidWcoXCJwb3N0RXZlbnRcIiwgZXZlbnRUeXBlLCBldmVudERhdGEpO1xuICAgICAgd2luZG93Mi5UZWxlZ3JhbVdlYnZpZXdQcm94eS5wb3N0RXZlbnQoZXZlbnRUeXBlLCBKU09OLnN0cmluZ2lmeShldmVudERhdGEpKTtcbiAgICB9IGVsc2UgaWYgKHdpbmRvdzIuZXh0ZXJuYWwgJiYgXCJub3RpZnlcIiBpbiB3aW5kb3cyLmV4dGVybmFsKSB7XG4gICAgICBsb2dEZWJ1ZyhcInBvc3RFdmVudFwiLCBldmVudFR5cGUsIGV2ZW50RGF0YSk7XG4gICAgICB3aW5kb3cyLmV4dGVybmFsLm5vdGlmeShKU09OLnN0cmluZ2lmeSh7IGV2ZW50VHlwZSwgZXZlbnREYXRhIH0pKTtcbiAgICB9IGVsc2UgaWYgKGlzSWZyYW1lKCkpIHtcbiAgICAgIGNvbnN0IHRydXN0ZWRUYXJnZXQgPSBcIipcIjtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeSh7IGV2ZW50VHlwZSwgZXZlbnREYXRhIH0pO1xuICAgICAgbG9nRGVidWcoXCJwb3N0RXZlbnRcIiwgZXZlbnRUeXBlLCBldmVudERhdGEpO1xuICAgICAgd2luZG93Mi5wYXJlbnQucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJ1c3RlZFRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUb25Db25uZWN0VUlFcnJvcihgQ2FuJ3QgcG9zdCBldmVudCB0byBUTUFgKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUyKSB7XG4gICAgbG9nRXJyb3IoYENhbid0IHBvc3QgZXZlbnQgdG8gcGFyZW50IHdpbmRvdzogJHtlMn1gKTtcbiAgfVxufVxuZnVuY3Rpb24gdXJsUGFyc2VIYXNoUGFyYW1zKGxvY2F0aW9uSGFzaCkge1xuICBsb2NhdGlvbkhhc2ggPSBsb2NhdGlvbkhhc2gucmVwbGFjZSgvXiMvLCBcIlwiKTtcbiAgbGV0IHBhcmFtcyA9IHt9O1xuICBpZiAoIWxvY2F0aW9uSGFzaC5sZW5ndGgpIHtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG4gIGlmIChsb2NhdGlvbkhhc2guaW5kZXhPZihcIj1cIikgPCAwICYmIGxvY2F0aW9uSGFzaC5pbmRleE9mKFwiP1wiKSA8IDApIHtcbiAgICBwYXJhbXMuX3BhdGggPSB1cmxTYWZlRGVjb2RlKGxvY2F0aW9uSGFzaCk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuICBsZXQgcUluZGV4ID0gbG9jYXRpb25IYXNoLmluZGV4T2YoXCI/XCIpO1xuICBpZiAocUluZGV4ID49IDApIHtcbiAgICBsZXQgcGF0aFBhcmFtID0gbG9jYXRpb25IYXNoLnN1YnN0cigwLCBxSW5kZXgpO1xuICAgIHBhcmFtcy5fcGF0aCA9IHVybFNhZmVEZWNvZGUocGF0aFBhcmFtKTtcbiAgICBsb2NhdGlvbkhhc2ggPSBsb2NhdGlvbkhhc2guc3Vic3RyKHFJbmRleCArIDEpO1xuICB9XG4gIGxldCBxdWVyeV9wYXJhbXMgPSB1cmxQYXJzZVF1ZXJ5U3RyaW5nKGxvY2F0aW9uSGFzaCk7XG4gIGZvciAobGV0IGsgaW4gcXVlcnlfcGFyYW1zKSB7XG4gICAgcGFyYW1zW2tdID0gcXVlcnlfcGFyYW1zW2tdO1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59XG5mdW5jdGlvbiB1cmxTYWZlRGVjb2RlKHVybGVuY29kZWQpIHtcbiAgdHJ5IHtcbiAgICB1cmxlbmNvZGVkID0gdXJsZW5jb2RlZC5yZXBsYWNlKC9cXCsvZywgXCIlMjBcIik7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh1cmxlbmNvZGVkKTtcbiAgfSBjYXRjaCAoZTIpIHtcbiAgICByZXR1cm4gdXJsZW5jb2RlZDtcbiAgfVxufVxuZnVuY3Rpb24gdXJsUGFyc2VRdWVyeVN0cmluZyhxdWVyeVN0cmluZykge1xuICBsZXQgcGFyYW1zID0ge307XG4gIGlmICghcXVlcnlTdHJpbmcubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuICBsZXQgcXVlcnlTdHJpbmdQYXJhbXMgPSBxdWVyeVN0cmluZy5zcGxpdChcIiZcIik7XG4gIGxldCBpMiwgcGFyYW0sIHBhcmFtTmFtZSwgcGFyYW1WYWx1ZTtcbiAgZm9yIChpMiA9IDA7IGkyIDwgcXVlcnlTdHJpbmdQYXJhbXMubGVuZ3RoOyBpMisrKSB7XG4gICAgcGFyYW0gPSBxdWVyeVN0cmluZ1BhcmFtc1tpMl0uc3BsaXQoXCI9XCIpO1xuICAgIHBhcmFtTmFtZSA9IHVybFNhZmVEZWNvZGUocGFyYW1bMF0pO1xuICAgIHBhcmFtVmFsdWUgPSBwYXJhbVsxXSA9PSBudWxsID8gbnVsbCA6IHVybFNhZmVEZWNvZGUocGFyYW1bMV0pO1xuICAgIHBhcmFtc1twYXJhbU5hbWVdID0gcGFyYW1WYWx1ZTtcbiAgfVxuICByZXR1cm4gcGFyYW1zO1xufVxuZnVuY3Rpb24gdmVyc2lvbkNvbXBhcmUodjEsIHYyKSB7XG4gIGlmICh0eXBlb2YgdjEgIT09IFwic3RyaW5nXCIpIHYxID0gXCJcIjtcbiAgbGV0IHYxTGlzdCA9IHYxLnJlcGxhY2UoL15cXHMrfFxccyskL2csIFwiXCIpLnNwbGl0KFwiLlwiKTtcbiAgbGV0IHYyTGlzdCA9IHYyLnJlcGxhY2UoL15cXHMrfFxccyskL2csIFwiXCIpLnNwbGl0KFwiLlwiKTtcbiAgbGV0IGEyLCBpMiwgcDEsIHAyO1xuICBhMiA9IE1hdGgubWF4KHYxTGlzdC5sZW5ndGgsIHYyTGlzdC5sZW5ndGgpO1xuICBmb3IgKGkyID0gMDsgaTIgPCBhMjsgaTIrKykge1xuICAgIHAxID0gcGFyc2VJbnQodjFMaXN0W2kyXSkgfHwgMDtcbiAgICBwMiA9IHBhcnNlSW50KHYyTGlzdFtpMl0pIHx8IDA7XG4gICAgaWYgKHAxID09PSBwMikgY29udGludWU7XG4gICAgaWYgKHAxID4gcDIpIHJldHVybiAxO1xuICAgIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHZlcnNpb25BdExlYXN0KHZlcikge1xuICByZXR1cm4gdmVyc2lvbkNvbXBhcmUod2ViQXBwVmVyc2lvbiwgdmVyKSA+PSAwO1xufVxuY29uc3QgbWF4V2lkdGggPSB7XG4gIG1vYmlsZTogNDQwLFxuICB0YWJsZXQ6IDEwMjBcbn07XG5mdW5jdGlvbiBpc0RldmljZShkZXZpY2UpIHtcbiAgY29uc3Qgd2luZG93MiA9IGdldFdpbmRvdyQxKCk7XG4gIGlmICghd2luZG93Mikge1xuICAgIHJldHVybiBkZXZpY2UgPT09IFwiZGVza3RvcFwiO1xuICB9XG4gIGlmIChpc1RtYVBsYXRmb3JtKFwid2ViYVwiKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHdpZHRoID0gd2luZG93Mi5pbm5lcldpZHRoO1xuICBzd2l0Y2ggKGRldmljZSkge1xuICAgIGNhc2UgXCJkZXNrdG9wXCI6XG4gICAgICByZXR1cm4gd2lkdGggPiBtYXhXaWR0aC50YWJsZXQ7XG4gICAgY2FzZSBcInRhYmxldFwiOlxuICAgICAgcmV0dXJuIHdpZHRoID4gbWF4V2lkdGgubW9iaWxlO1xuICAgIGRlZmF1bHQ6XG4gICAgY2FzZSBcIm1vYmlsZVwiOlxuICAgICAgcmV0dXJuIHdpZHRoIDw9IG1heFdpZHRoLm1vYmlsZSB8fCBpc09TKFwiaW9zXCIsIFwiYW5kcm9pZFwiLCBcImlwYWRcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIG1lZGlhKGRldmljZSkge1xuICBzd2l0Y2ggKGRldmljZSkge1xuICAgIGNhc2UgXCJtb2JpbGVcIjpcbiAgICAgIHJldHVybiBgQG1lZGlhIChtYXgtd2lkdGg6ICR7bWF4V2lkdGgubW9iaWxlfXB4KWA7XG4gICAgY2FzZSBcInRhYmxldFwiOlxuICAgICAgcmV0dXJuIGBAbWVkaWEgKG1heC13aWR0aDogJHttYXhXaWR0aC50YWJsZXR9cHgpIChtaW4td2lkdGg6ICR7bWF4V2lkdGgubW9iaWxlfXB4KWA7XG4gICAgZGVmYXVsdDpcbiAgICBjYXNlIFwiZGVza3RvcFwiOlxuICAgICAgcmV0dXJuIGBAbWVkaWEgKG1pbi13aWR0aDogJHttYXhXaWR0aC50YWJsZXR9cHgpYDtcbiAgfVxufVxuY29uc3QgbWVkaWFUb3VjaCA9IFwiQG1lZGlhIChob3Zlcjogbm9uZSlcIjtcbmNvbnN0IG1lZGlhTm90VG91Y2ggPSBcIkBtZWRpYSBub3QgYWxsIGFuZCAoaG92ZXI6IG5vbmUpXCI7XG5jb25zdCBib3JkZXJzJDYgPSB7XG4gIG06IFwiMTAwdmhcIixcbiAgczogXCI4cHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCBzY2FsZVZhbHVlcyA9IHtcbiAgczogMC4wMixcbiAgbTogMC4wNFxufTtcbmNvbnN0IEJ1dHRvblN0eWxlZCQxID0gc3R5bGVkLmJ1dHRvbmBcbiAgICBkaXNwbGF5OiAkeyhwcm9wcykgPT4gcHJvcHMubGVmdEljb24gfHwgcHJvcHMucmlnaHRJY29uID8gXCJmbGV4XCIgOiBcImlubGluZS1ibG9ja1wifTtcbiAgICBnYXA6ICR7KHByb3BzKSA9PiBwcm9wcy5sZWZ0SWNvbiB8fCBwcm9wcy5yaWdodEljb24gPyBcIjZweFwiIDogXCJ1bnNldFwifTtcbiAgICBhbGlnbi1pdGVtczogJHsocHJvcHMpID0+IHByb3BzLmxlZnRJY29uIHx8IHByb3BzLnJpZ2h0SWNvbiA/IFwiY2VudGVyXCIgOiBcInVuc2V0XCJ9O1xuICAgIGp1c3RpZnktY29udGVudDogJHsocHJvcHMpID0+IHByb3BzLmxlZnRJY29uIHx8IHByb3BzLnJpZ2h0SWNvbiA/IFwic3BhY2UtYmV0d2VlblwiIDogXCJ1bnNldFwifTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMuYXBwZWFyYW5jZSA9PT0gXCJmbGF0XCIgPyBcInRyYW5zcGFyZW50XCIgOiBwcm9wcy5hcHBlYXJhbmNlID09PSBcInNlY29uZGFyeVwiID8gcHJvcHMudGhlbWUuY29sb3JzLmJhY2tncm91bmQudGludCA6IHJnYmEocHJvcHMudGhlbWUuY29sb3JzLmFjY2VudCwgMC4xMil9O1xuICAgIGNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMuYXBwZWFyYW5jZSA9PT0gXCJzZWNvbmRhcnlcIiA/IHByb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnByaW1hcnkgOiBwcm9wcy50aGVtZS5jb2xvcnMuYWNjZW50fTtcblxuICAgIHBhZGRpbmc6ICR7KHByb3BzKSA9PiBwcm9wcy5hcHBlYXJhbmNlID09PSBcImZsYXRcIiA/IFwiMFwiIDogXCI5cHggMTZweFwifTtcbiAgICBwYWRkaW5nLWxlZnQ6ICR7KHByb3BzKSA9PiBwcm9wcy5sZWZ0SWNvbiAmJiBwcm9wcy5hcHBlYXJhbmNlICE9PSBcImZsYXRcIiA/IFwiMTJweFwiIDogXCIxNnB4XCJ9O1xuICAgIHBhZGRpbmctcmlnaHQ6ICR7KHByb3BzKSA9PiBwcm9wcy5yaWdodEljb24gJiYgcHJvcHMuYXBwZWFyYW5jZSAhPT0gXCJmbGF0XCIgPyBcIjEycHhcIiA6IFwiMTZweFwifTtcbiAgICBib3JkZXI6IG5vbmU7XG4gICAgYm9yZGVyLXJhZGl1czogJHsocHJvcHMpID0+IGJvcmRlcnMkNltwcm9wcy50aGVtZS5ib3JkZXJSYWRpdXNdfTtcbiAgICBjdXJzb3I6ICR7KHByb3BzKSA9PiBwcm9wcy5kaXNhYmxlZCA/IFwibm90LWFsbG93ZWRcIiA6IFwicG9pbnRlclwifTtcblxuICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICBmb250LXdlaWdodDogNTEwO1xuICAgIGxpbmUtaGVpZ2h0OiAxOHB4O1xuXG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMTI1cyBlYXNlLWluLW91dDtcblxuICAgICR7bWVkaWFOb3RUb3VjaH0ge1xuICAgICAgICAmOmhvdmVyIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJHsocHJvcHMpID0+IHByb3BzLmRpc2FibGVkID8gXCJ1bnNldFwiIDogYHNjYWxlKCR7MSArIHNjYWxlVmFsdWVzW3Byb3BzLnNjYWxlXX0pYH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAmOmFjdGl2ZSB7XG4gICAgICAgIHRyYW5zZm9ybTogJHsocHJvcHMpID0+IHByb3BzLmRpc2FibGVkID8gXCJ1bnNldFwiIDogYHNjYWxlKCR7MSAtIHNjYWxlVmFsdWVzW3Byb3BzLnNjYWxlXX0pYH07XG4gICAgfVxuXG4gICAgJHttZWRpYVRvdWNofSB7XG4gICAgICAgICY6YWN0aXZlIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJHsocHJvcHMpID0+IHByb3BzLmRpc2FibGVkID8gXCJ1bnNldFwiIDogYHNjYWxlKCR7MSAtIHNjYWxlVmFsdWVzW3Byb3BzLnNjYWxlXSAqIDJ9KWB9O1xuICAgICAgICB9XG4gICAgfVxuYDtcbmZ1bmN0aW9uIHVzZURhdGFBdHRyaWJ1dGVzKHByb3BzKSB7XG4gIGNvbnN0IGtleXMgPSB1bnRyYWNrKCgpID0+IE9iamVjdC5rZXlzKHByb3BzKS5maWx0ZXIoKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoXCJkYXRhLVwiKSkpO1xuICBjb25zdCBbZGF0YUF0dHJzXSA9IHNwbGl0UHJvcHMocHJvcHMsIGtleXMpO1xuICByZXR1cm4gZGF0YUF0dHJzO1xufVxuY29uc3QgQnV0dG9uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IGRhdGFBdHRycyA9IHVzZURhdGFBdHRyaWJ1dGVzKHByb3BzKTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChCdXR0b25TdHlsZWQkMSwgbWVyZ2VQcm9wcyh7XG4gICAgdHlwZTogXCJidXR0b25cIixcbiAgICBnZXQgYXBwZWFyYW5jZSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5hcHBlYXJhbmNlIHx8IFwicHJpbWFyeVwiO1xuICAgIH0sXG4gICAgZ2V0IFtcImNsYXNzXCJdKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgIH0sXG4gICAgb25DbGljazogKGUyKSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgcmV0dXJuIChfYTIgPSBwcm9wcy5vbkNsaWNrKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwocHJvcHMsIGUyKTtcbiAgICB9LFxuICAgIG9uTW91c2VFbnRlcjogKGUyKSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgcmV0dXJuIChfYTIgPSBwcm9wcy5vbk1vdXNlRW50ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChwcm9wcywgZTIpO1xuICAgIH0sXG4gICAgb25Nb3VzZUxlYXZlOiAoZTIpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICByZXR1cm4gKF9hMiA9IHByb3BzLm9uTW91c2VMZWF2ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYWxsKHByb3BzLCBlMik7XG4gICAgfSxcbiAgICByZWYociQpIHtcbiAgICAgIHZhciBfcmVmJCA9IHByb3BzLnJlZjtcbiAgICAgIHR5cGVvZiBfcmVmJCA9PT0gXCJmdW5jdGlvblwiID8gX3JlZiQociQpIDogcHJvcHMucmVmID0gciQ7XG4gICAgfSxcbiAgICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgICByZXR1cm4gcHJvcHMuZGlzYWJsZWQ7XG4gICAgfSxcbiAgICBnZXQgc2NhbGUoKSB7XG4gICAgICByZXR1cm4gcHJvcHMuc2NhbGUgfHwgXCJtXCI7XG4gICAgfSxcbiAgICBnZXQgbGVmdEljb24oKSB7XG4gICAgICByZXR1cm4gISFwcm9wcy5sZWZ0SWNvbjtcbiAgICB9LFxuICAgIGdldCByaWdodEljb24oKSB7XG4gICAgICByZXR1cm4gISFwcm9wcy5yaWdodEljb247XG4gICAgfSxcbiAgICBcImRhdGEtdGMtYnV0dG9uXCI6IFwidHJ1ZVwiXG4gIH0sIGRhdGFBdHRycywge1xuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBbbWVtbygoKSA9PiBwcm9wcy5sZWZ0SWNvbiksIG1lbW8oKCkgPT4gcHJvcHMuY2hpbGRyZW4pLCBtZW1vKCgpID0+IHByb3BzLnJpZ2h0SWNvbildO1xuICAgIH1cbiAgfSkpO1xufTtcbmNvbnN0IG5vb3AgPSAoKSA9PiB7XG59O1xuY29uc3Qgbm9vcFRyYW5zaXRpb24gPSAoZWwsIGRvbmUpID0+IGRvbmUoKTtcbmZ1bmN0aW9uIGNyZWF0ZVN3aXRjaFRyYW5zaXRpb24oc291cmNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGluaXRTb3VyY2UgPSB1bnRyYWNrKHNvdXJjZSk7XG4gIGNvbnN0IGluaXRSZXR1cm5lZCA9IGluaXRTb3VyY2UgPyBbaW5pdFNvdXJjZV0gOiBbXTtcbiAgY29uc3QgeyBvbkVudGVyID0gbm9vcFRyYW5zaXRpb24sIG9uRXhpdCA9IG5vb3BUcmFuc2l0aW9uIH0gPSBvcHRpb25zO1xuICBjb25zdCBbcmV0dXJuZWQsIHNldFJldHVybmVkXSA9IGNyZWF0ZVNpZ25hbChvcHRpb25zLmFwcGVhciA/IFtdIDogaW5pdFJldHVybmVkKTtcbiAgY29uc3QgW2lzVHJhbnNpdGlvblBlbmRpbmddID0gdXNlVHJhbnNpdGlvbigpO1xuICBsZXQgbmV4dDtcbiAgbGV0IGlzRXhpdGluZyA9IGZhbHNlO1xuICBmdW5jdGlvbiBleGl0VHJhbnNpdGlvbjIoZWwsIGFmdGVyKSB7XG4gICAgaWYgKCFlbClcbiAgICAgIHJldHVybiBhZnRlciAmJiBhZnRlcigpO1xuICAgIGlzRXhpdGluZyA9IHRydWU7XG4gICAgb25FeGl0KGVsLCAoKSA9PiB7XG4gICAgICBiYXRjaCgoKSA9PiB7XG4gICAgICAgIGlzRXhpdGluZyA9IGZhbHNlO1xuICAgICAgICBzZXRSZXR1cm5lZCgocDIpID0+IHAyLmZpbHRlcigoZTIpID0+IGUyICE9PSBlbCkpO1xuICAgICAgICBhZnRlciAmJiBhZnRlcigpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZW50ZXJUcmFuc2l0aW9uMihhZnRlcikge1xuICAgIGNvbnN0IGVsID0gbmV4dDtcbiAgICBpZiAoIWVsKVxuICAgICAgcmV0dXJuIGFmdGVyICYmIGFmdGVyKCk7XG4gICAgbmV4dCA9IHZvaWQgMDtcbiAgICBzZXRSZXR1cm5lZCgocDIpID0+IFtlbCwgLi4ucDJdKTtcbiAgICBvbkVudGVyKGVsLCBhZnRlciAhPSBudWxsID8gYWZ0ZXIgOiBub29wKTtcbiAgfVxuICBjb25zdCB0cmlnZ2VyVHJhbnNpdGlvbnMgPSBvcHRpb25zLm1vZGUgPT09IFwib3V0LWluXCIgPyAoXG4gICAgLy8gZXhpdCAtPiBlbnRlclxuICAgIC8vIGV4aXQgLT4gZW50ZXJcbiAgICAocHJldikgPT4gaXNFeGl0aW5nIHx8IGV4aXRUcmFuc2l0aW9uMihwcmV2LCBlbnRlclRyYW5zaXRpb24yKVxuICApIDogb3B0aW9ucy5tb2RlID09PSBcImluLW91dFwiID8gKFxuICAgIC8vIGVudGVyIC0+IGV4aXRcbiAgICAvLyBlbnRlciAtPiBleGl0XG4gICAgKHByZXYpID0+IGVudGVyVHJhbnNpdGlvbjIoKCkgPT4gZXhpdFRyYW5zaXRpb24yKHByZXYpKVxuICApIDogKFxuICAgIC8vIGV4aXQgJiBlbnRlclxuICAgIC8vIGV4aXQgJiBlbnRlclxuICAgIChwcmV2KSA9PiB7XG4gICAgICBleGl0VHJhbnNpdGlvbjIocHJldik7XG4gICAgICBlbnRlclRyYW5zaXRpb24yKCk7XG4gICAgfVxuICApO1xuICBjcmVhdGVDb21wdXRlZCgocHJldikgPT4ge1xuICAgIGNvbnN0IGVsID0gc291cmNlKCk7XG4gICAgaWYgKHVudHJhY2soaXNUcmFuc2l0aW9uUGVuZGluZykpIHtcbiAgICAgIGlzVHJhbnNpdGlvblBlbmRpbmcoKTtcbiAgICAgIHJldHVybiBwcmV2O1xuICAgIH1cbiAgICBpZiAoZWwgIT09IHByZXYpIHtcbiAgICAgIG5leHQgPSBlbDtcbiAgICAgIGJhdGNoKCgpID0+IHVudHJhY2soKCkgPT4gdHJpZ2dlclRyYW5zaXRpb25zKHByZXYpKSk7XG4gICAgfVxuICAgIHJldHVybiBlbDtcbiAgfSwgb3B0aW9ucy5hcHBlYXIgPyB2b2lkIDAgOiBpbml0U291cmNlKTtcbiAgcmV0dXJuIHJldHVybmVkO1xufVxuZnVuY3Rpb24gY3JlYXRlTGlzdFRyYW5zaXRpb24oc291cmNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGluaXRTb3VyY2UgPSB1bnRyYWNrKHNvdXJjZSk7XG4gIGNvbnN0IHsgb25DaGFuZ2UgfSA9IG9wdGlvbnM7XG4gIGxldCBwcmV2U2V0ID0gbmV3IFNldChvcHRpb25zLmFwcGVhciA/IHZvaWQgMCA6IGluaXRTb3VyY2UpO1xuICBjb25zdCBleGl0aW5nID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gIGNvbnN0IFt0b1JlbW92ZSwgc2V0VG9SZW1vdmVdID0gY3JlYXRlU2lnbmFsKFtdLCB7IGVxdWFsczogZmFsc2UgfSk7XG4gIGNvbnN0IFtpc1RyYW5zaXRpb25QZW5kaW5nXSA9IHVzZVRyYW5zaXRpb24oKTtcbiAgY29uc3QgZmluaXNoUmVtb3ZlZCA9IChlbHMpID0+IHtcbiAgICBzZXRUb1JlbW92ZSgocDIpID0+IChwMi5wdXNoLmFwcGx5KHAyLCBlbHMpLCBwMikpO1xuICAgIGZvciAoY29uc3QgZWwgb2YgZWxzKVxuICAgICAgZXhpdGluZy5kZWxldGUoZWwpO1xuICB9O1xuICBjb25zdCBoYW5kbGVSZW1vdmVkID0gKGVscywgZWwsIGkyKSA9PiBlbHMuc3BsaWNlKGkyLCAwLCBlbCk7XG4gIHJldHVybiBjcmVhdGVNZW1vKChwcmV2KSA9PiB7XG4gICAgY29uc3QgZWxzVG9SZW1vdmUgPSB0b1JlbW92ZSgpO1xuICAgIGNvbnN0IHNvdXJjZUxpc3QgPSBzb3VyY2UoKTtcbiAgICBzb3VyY2VMaXN0WyRUUkFDS107XG4gICAgaWYgKHVudHJhY2soaXNUcmFuc2l0aW9uUGVuZGluZykpIHtcbiAgICAgIGlzVHJhbnNpdGlvblBlbmRpbmcoKTtcbiAgICAgIHJldHVybiBwcmV2O1xuICAgIH1cbiAgICBpZiAoZWxzVG9SZW1vdmUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBuZXh0ID0gcHJldi5maWx0ZXIoKGUyKSA9PiAhZWxzVG9SZW1vdmUuaW5jbHVkZXMoZTIpKTtcbiAgICAgIGVsc1RvUmVtb3ZlLmxlbmd0aCA9IDA7XG4gICAgICBvbkNoYW5nZSh7IGxpc3Q6IG5leHQsIGFkZGVkOiBbXSwgcmVtb3ZlZDogW10sIHVuY2hhbmdlZDogbmV4dCwgZmluaXNoUmVtb3ZlZCB9KTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdW50cmFjaygoKSA9PiB7XG4gICAgICBjb25zdCBuZXh0U2V0ID0gbmV3IFNldChzb3VyY2VMaXN0KTtcbiAgICAgIGNvbnN0IG5leHQgPSBzb3VyY2VMaXN0LnNsaWNlKCk7XG4gICAgICBjb25zdCBhZGRlZCA9IFtdO1xuICAgICAgY29uc3QgcmVtb3ZlZCA9IFtdO1xuICAgICAgY29uc3QgdW5jaGFuZ2VkID0gW107XG4gICAgICBmb3IgKGNvbnN0IGVsIG9mIHNvdXJjZUxpc3QpIHtcbiAgICAgICAgKHByZXZTZXQuaGFzKGVsKSA/IHVuY2hhbmdlZCA6IGFkZGVkKS5wdXNoKGVsKTtcbiAgICAgIH1cbiAgICAgIGxldCBub3RoaW5nQ2hhbmdlZCA9ICFhZGRlZC5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgcHJldi5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgY29uc3QgZWwgPSBwcmV2W2kyXTtcbiAgICAgICAgaWYgKCFuZXh0U2V0LmhhcyhlbCkpIHtcbiAgICAgICAgICBpZiAoIWV4aXRpbmcuaGFzKGVsKSkge1xuICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGVsKTtcbiAgICAgICAgICAgIGV4aXRpbmcuYWRkKGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGFuZGxlUmVtb3ZlZChuZXh0LCBlbCwgaTIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3RoaW5nQ2hhbmdlZCAmJiBlbCAhPT0gbmV4dFtpMl0pXG4gICAgICAgICAgbm90aGluZ0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghcmVtb3ZlZC5sZW5ndGggJiYgbm90aGluZ0NoYW5nZWQpXG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgb25DaGFuZ2UoeyBsaXN0OiBuZXh0LCBhZGRlZCwgcmVtb3ZlZCwgdW5jaGFuZ2VkLCBmaW5pc2hSZW1vdmVkIH0pO1xuICAgICAgcHJldlNldCA9IG5leHRTZXQ7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9KTtcbiAgfSwgb3B0aW9ucy5hcHBlYXIgPyBbXSA6IGluaXRTb3VyY2Uuc2xpY2UoKSk7XG59XG5jb25zdCBkZWZhdWx0RWxlbWVudFByZWRpY2F0ZSA9IChpdGVtKSA9PiBpdGVtIGluc3RhbmNlb2YgRWxlbWVudDtcbmZ1bmN0aW9uIGdldFJlc29sdmVkRWxlbWVudHModmFsdWUsIHByZWRpY2F0ZSkge1xuICBpZiAocHJlZGljYXRlKHZhbHVlKSlcbiAgICByZXR1cm4gdmFsdWU7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJiAhdmFsdWUubGVuZ3RoKVxuICAgIHJldHVybiBnZXRSZXNvbHZlZEVsZW1lbnRzKHZhbHVlKCksIHByZWRpY2F0ZSk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGdldFJlc29sdmVkRWxlbWVudHMoaXRlbSwgcHJlZGljYXRlKTtcbiAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgIEFycmF5LmlzQXJyYXkocmVzdWx0KSA/IHJlc3VsdHMucHVzaC5hcHBseShyZXN1bHRzLCByZXN1bHQpIDogcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzLmxlbmd0aCA/IHJlc3VsdHMgOiBudWxsO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVsZW1lbnRzKGZuLCBwcmVkaWNhdGUgPSBkZWZhdWx0RWxlbWVudFByZWRpY2F0ZSwgc2VydmVyUHJlZGljYXRlID0gZGVmYXVsdEVsZW1lbnRQcmVkaWNhdGUpIHtcbiAgY29uc3QgY2hpbGRyZW4yID0gY3JlYXRlTWVtbyhmbik7XG4gIGNvbnN0IG1lbW8yID0gY3JlYXRlTWVtbygoKSA9PiBnZXRSZXNvbHZlZEVsZW1lbnRzKGNoaWxkcmVuMigpLCBwcmVkaWNhdGUpKTtcbiAgbWVtbzIudG9BcnJheSA9ICgpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IG1lbW8yKCk7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiB2YWx1ZSA/IFt2YWx1ZV0gOiBbXTtcbiAgfTtcbiAgcmV0dXJuIG1lbW8yO1xufVxuZnVuY3Rpb24gZ2V0Rmlyc3RDaGlsZCh2YWx1ZSwgcHJlZGljYXRlKSB7XG4gIGlmIChwcmVkaWNhdGUodmFsdWUpKVxuICAgIHJldHVybiB2YWx1ZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiICYmICF2YWx1ZS5sZW5ndGgpXG4gICAgcmV0dXJuIGdldEZpcnN0Q2hpbGQodmFsdWUoKSwgcHJlZGljYXRlKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBnZXRGaXJzdENoaWxkKGl0ZW0sIHByZWRpY2F0ZSk7XG4gICAgICBpZiAocmVzdWx0KVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVGaXJzdChmbiwgcHJlZGljYXRlID0gZGVmYXVsdEVsZW1lbnRQcmVkaWNhdGUsIHNlcnZlclByZWRpY2F0ZSA9IGRlZmF1bHRFbGVtZW50UHJlZGljYXRlKSB7XG4gIGNvbnN0IGNoaWxkcmVuMiA9IGNyZWF0ZU1lbW8oZm4pO1xuICByZXR1cm4gY3JlYXRlTWVtbygoKSA9PiBnZXRGaXJzdENoaWxkKGNoaWxkcmVuMigpLCBwcmVkaWNhdGUpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzbmFtZXMocHJvcHMpIHtcbiAgcmV0dXJuIGNyZWF0ZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IG5hbWUgPSBwcm9wcy5uYW1lIHx8IFwic1wiO1xuICAgIHJldHVybiB7XG4gICAgICBlbnRlckFjdGl2ZTogKHByb3BzLmVudGVyQWN0aXZlQ2xhc3MgfHwgbmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKS5zcGxpdChcIiBcIiksXG4gICAgICBlbnRlcjogKHByb3BzLmVudGVyQ2xhc3MgfHwgbmFtZSArIFwiLWVudGVyXCIpLnNwbGl0KFwiIFwiKSxcbiAgICAgIGVudGVyVG86IChwcm9wcy5lbnRlclRvQ2xhc3MgfHwgbmFtZSArIFwiLWVudGVyLXRvXCIpLnNwbGl0KFwiIFwiKSxcbiAgICAgIGV4aXRBY3RpdmU6IChwcm9wcy5leGl0QWN0aXZlQ2xhc3MgfHwgbmFtZSArIFwiLWV4aXQtYWN0aXZlXCIpLnNwbGl0KFwiIFwiKSxcbiAgICAgIGV4aXQ6IChwcm9wcy5leGl0Q2xhc3MgfHwgbmFtZSArIFwiLWV4aXRcIikuc3BsaXQoXCIgXCIpLFxuICAgICAgZXhpdFRvOiAocHJvcHMuZXhpdFRvQ2xhc3MgfHwgbmFtZSArIFwiLWV4aXQtdG9cIikuc3BsaXQoXCIgXCIpLFxuICAgICAgbW92ZTogKHByb3BzLm1vdmVDbGFzcyB8fCBuYW1lICsgXCItbW92ZVwiKS5zcGxpdChcIiBcIilcbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIG5leHRGcmFtZShmbikge1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKSk7XG59XG5mdW5jdGlvbiBlbnRlclRyYW5zaXRpb24oY2xhc3NlcywgZXZlbnRzLCBlbCwgZG9uZSkge1xuICBjb25zdCB7IG9uQmVmb3JlRW50ZXIsIG9uRW50ZXIsIG9uQWZ0ZXJFbnRlciB9ID0gZXZlbnRzO1xuICBvbkJlZm9yZUVudGVyID09IG51bGwgPyB2b2lkIDAgOiBvbkJlZm9yZUVudGVyKGVsKTtcbiAgZWwuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzLmVudGVyKTtcbiAgZWwuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzLmVudGVyQWN0aXZlKTtcbiAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgIGlmICghZWwucGFyZW50Tm9kZSlcbiAgICAgIHJldHVybiBkb25lID09IG51bGwgPyB2b2lkIDAgOiBkb25lKCk7XG4gICAgb25FbnRlciA9PSBudWxsID8gdm9pZCAwIDogb25FbnRlcihlbCwgKCkgPT4gZW5kVHJhbnNpdGlvbigpKTtcbiAgfSk7XG4gIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc2VzLmVudGVyKTtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXMuZW50ZXJUbyk7XG4gICAgaWYgKCFvbkVudGVyIHx8IG9uRW50ZXIubGVuZ3RoIDwgMikge1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgZW5kVHJhbnNpdGlvbik7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsIGVuZFRyYW5zaXRpb24pO1xuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIGVuZFRyYW5zaXRpb24oZTIpIHtcbiAgICBpZiAoIWUyIHx8IGUyLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGRvbmUgPT0gbnVsbCA/IHZvaWQgMCA6IGRvbmUoKTtcbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIGVuZFRyYW5zaXRpb24pO1xuICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLCBlbmRUcmFuc2l0aW9uKTtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3Nlcy5lbnRlckFjdGl2ZSk7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzZXMuZW50ZXJUbyk7XG4gICAgICBvbkFmdGVyRW50ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQWZ0ZXJFbnRlcihlbCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBleGl0VHJhbnNpdGlvbihjbGFzc2VzLCBldmVudHMsIGVsLCBkb25lKSB7XG4gIGNvbnN0IHsgb25CZWZvcmVFeGl0LCBvbkV4aXQsIG9uQWZ0ZXJFeGl0IH0gPSBldmVudHM7XG4gIGlmICghZWwucGFyZW50Tm9kZSlcbiAgICByZXR1cm4gZG9uZSA9PSBudWxsID8gdm9pZCAwIDogZG9uZSgpO1xuICBvbkJlZm9yZUV4aXQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQmVmb3JlRXhpdChlbCk7XG4gIGVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3Nlcy5leGl0KTtcbiAgZWwuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzLmV4aXRBY3RpdmUpO1xuICBvbkV4aXQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRXhpdChlbCwgKCkgPT4gZW5kVHJhbnNpdGlvbigpKTtcbiAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzZXMuZXhpdCk7XG4gICAgZWwuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzLmV4aXRUbyk7XG4gICAgaWYgKCFvbkV4aXQgfHwgb25FeGl0Lmxlbmd0aCA8IDIpIHtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIGVuZFRyYW5zaXRpb24pO1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLCBlbmRUcmFuc2l0aW9uKTtcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBlbmRUcmFuc2l0aW9uKGUyKSB7XG4gICAgaWYgKCFlMiB8fCBlMi50YXJnZXQgPT09IGVsKSB7XG4gICAgICBkb25lID09IG51bGwgPyB2b2lkIDAgOiBkb25lKCk7XG4gICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCBlbmRUcmFuc2l0aW9uKTtcbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgZW5kVHJhbnNpdGlvbik7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzZXMuZXhpdEFjdGl2ZSk7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzZXMuZXhpdFRvKTtcbiAgICAgIG9uQWZ0ZXJFeGl0ID09IG51bGwgPyB2b2lkIDAgOiBvbkFmdGVyRXhpdChlbCk7XG4gICAgfVxuICB9XG59XG5jb25zdCBUUkFOU0lUSU9OX01PREVfTUFQID0ge1xuICBpbm91dDogXCJpbi1vdXRcIixcbiAgb3V0aW46IFwib3V0LWluXCJcbn07XG5jb25zdCBUcmFuc2l0aW9uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IGNsYXNzbmFtZXMgPSBjcmVhdGVDbGFzc25hbWVzKHByb3BzKTtcbiAgcmV0dXJuIGNyZWF0ZVN3aXRjaFRyYW5zaXRpb24ocmVzb2x2ZUZpcnN0KCgpID0+IHByb3BzLmNoaWxkcmVuKSwge1xuICAgIG1vZGU6IFRSQU5TSVRJT05fTU9ERV9NQVBbcHJvcHMubW9kZV0sXG4gICAgYXBwZWFyOiBwcm9wcy5hcHBlYXIsXG4gICAgb25FbnRlcihlbCwgZG9uZSkge1xuICAgICAgZW50ZXJUcmFuc2l0aW9uKGNsYXNzbmFtZXMoKSwgcHJvcHMsIGVsLCBkb25lKTtcbiAgICB9LFxuICAgIG9uRXhpdChlbCwgZG9uZSkge1xuICAgICAgZXhpdFRyYW5zaXRpb24oY2xhc3NuYW1lcygpLCBwcm9wcywgZWwsIGRvbmUpO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3QgVHJhbnNpdGlvbkdyb3VwID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IGNsYXNzbmFtZXMgPSBjcmVhdGVDbGFzc25hbWVzKHByb3BzKTtcbiAgcmV0dXJuIGNyZWF0ZUxpc3RUcmFuc2l0aW9uKHJlc29sdmVFbGVtZW50cygoKSA9PiBwcm9wcy5jaGlsZHJlbikudG9BcnJheSwge1xuICAgIGFwcGVhcjogcHJvcHMuYXBwZWFyLFxuICAgIG9uQ2hhbmdlKHsgYWRkZWQsIHJlbW92ZWQsIGZpbmlzaFJlbW92ZWQsIGxpc3QgfSkge1xuICAgICAgY29uc3QgY2xhc3NlcyA9IGNsYXNzbmFtZXMoKTtcbiAgICAgIGZvciAoY29uc3QgZWwgb2YgYWRkZWQpIHtcbiAgICAgICAgZW50ZXJUcmFuc2l0aW9uKGNsYXNzZXMsIHByb3BzLCBlbCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0b01vdmUgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZWwgb2YgbGlzdCkge1xuICAgICAgICBpZiAoZWwuaXNDb25uZWN0ZWQgJiYgKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgZWwgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSkge1xuICAgICAgICAgIHRvTW92ZS5wdXNoKHsgZWwsIHJlY3Q6IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vdmVkID0gW107XG4gICAgICAgIGZvciAoY29uc3QgeyBlbCwgcmVjdCB9IG9mIHRvTW92ZSkge1xuICAgICAgICAgIGlmIChlbC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgY29uc3QgbmV3UmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBkWCA9IHJlY3QubGVmdCAtIG5ld1JlY3QubGVmdCwgZFkgPSByZWN0LnRvcCAtIG5ld1JlY3QudG9wO1xuICAgICAgICAgICAgaWYgKGRYIHx8IGRZKSB7XG4gICAgICAgICAgICAgIGVsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtkWH1weCwgJHtkWX1weClgO1xuICAgICAgICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBcIjBzXCI7XG4gICAgICAgICAgICAgIG1vdmVkLnB1c2goZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcbiAgICAgICAgZm9yIChjb25zdCBlbCBvZiBtb3ZlZCkge1xuICAgICAgICAgIGxldCBlbmRUcmFuc2l0aW9uID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICAgIGlmIChlMi50YXJnZXQgPT09IGVsIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUyLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgZW5kVHJhbnNpdGlvbik7XG4gICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3Nlcy5tb3ZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3Nlcy5tb3ZlKTtcbiAgICAgICAgICBlbC5zdHlsZS50cmFuc2Zvcm0gPSBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBcIlwiO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIGVuZFRyYW5zaXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGZvciAoY29uc3QgZWwgb2YgcmVtb3ZlZCkge1xuICAgICAgICBleGl0VHJhbnNpdGlvbihjbGFzc2VzLCBwcm9wcywgZWwsICgpID0+IGZpbmlzaFJlbW92ZWQoW2VsXSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuZnVuY3Rpb24gY2xpY2tPdXRzaWRlJDEoZWwsIGFjY2Vzc29yKSB7XG4gIGNvbnN0IG9uQ2xpY2sgPSAoZTIpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIHJldHVybiAhZWwuY29udGFpbnMoZTIudGFyZ2V0KSAmJiAoKF9hMiA9IGFjY2Vzc29yKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIoKSk7XG4gIH07XG4gIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uQ2xpY2spO1xuICBvbkNsZWFudXAoKCkgPT4gZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb25DbGljaykpO1xufVxuZnVuY3Rpb24gZXNjUHJlc3NlZChfLCBhY2Nlc3Nvcikge1xuICBjb25zdCBvbktleVByZXNzID0gKGUyKSA9PiB7XG4gICAgdmFyIF9hMiwgX2IyO1xuICAgIGlmIChlMi5rZXkgPT09IFwiRXNjYXBlXCIpIHtcbiAgICAgIChfYTIgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmJsdXIoKTtcbiAgICAgIChfYjIgPSBhY2Nlc3NvcigpKSA9PSBudWxsID8gdm9pZCAwIDogX2IyKCk7XG4gICAgfVxuICB9O1xuICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5UHJlc3MpO1xuICBvbkNsZWFudXAoKCkgPT4gZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleVByZXNzKSk7XG59XG5mdW5jdGlvbiBhbmRyb2lkQmFja0hhbmRsZXIkMShfLCBjb25maWcpIHtcbiAgY29uc3Qge1xuICAgIGlzRW5hYmxlZCxcbiAgICBvbkNsb3NlXG4gIH0gPSBjb25maWcoKTtcbiAgaWYgKCFpc0VuYWJsZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdXNlck9TSXNBbmRyb2lkID0gZ2V0VXNlckFnZW50KCkub3MgPT09IFwiYW5kcm9pZFwiO1xuICBpZiAoIXVzZXJPU0lzQW5kcm9pZCkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoUk9VVEVfU1RBVEUsIFwiXCIpO1xuICBjb25zdCBwb3BzdGF0ZUhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIG9uQ2xvc2UoKTtcbiAgfTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCBwb3BzdGF0ZUhhbmRsZXIsIHtcbiAgICBvbmNlOiB0cnVlXG4gIH0pO1xuICBvbkNsZWFudXAoKCkgPT4ge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgcG9wc3RhdGVIYW5kbGVyKTtcbiAgICBjcmVhdGVNYWNyb3Rhc2soKCkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGlmICgoKF9hMiA9IHdpbmRvdy5oaXN0b3J5LnN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyW1JPVVRFX1NUQVRFX0tFWV0pID09PSB0cnVlKSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5jb25zdCBST1VURV9TVEFURV9LRVkgPSBcImFuZHJvaWRCYWNrSGFuZGxlclwiO1xuY29uc3QgUk9VVEVfU1RBVEUgPSB7XG4gIFtST1VURV9TVEFURV9LRVldOiB0cnVlXG59O1xudmFyIF90bXBsJCR2ID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmc+PHBhdGggZmlsbC1ydWxlPWV2ZW5vZGQgY2xpcC1ydWxlPWV2ZW5vZGQgZD1cIk0xMC4yMTIyIDE0LjM0MDdDMTAuNTM4NCAxNC4wODU0IDEwLjU5NTkgMTMuNjE0IDEwLjM0MDYgMTMuMjg3OEw2LjIwMjM3IDguMDAwMDNMMTAuMzQwNiAyLjcxMjI3QzEwLjU5NTkgMi4zODYwNyAxMC41Mzg0IDEuOTE0NjkgMTAuMjEyMiAxLjY1OTRDOS44ODYwNCAxLjQwNDEyIDkuNDE0NjUgMS40NjE2MSA5LjE1OTM3IDEuNzg3OEw0LjY1OTM3IDcuNTM3OEM0LjQ0Njg4IDcuODA5MzIgNC40NDY4OCA4LjE5MDc0IDQuNjU5MzcgOC40NjIyNkw5LjE1OTM3IDE0LjIxMjNDOS40MTQ2NSAxNC41Mzg1IDkuODg2MDQgMTQuNTk1OSAxMC4yMTIyIDE0LjM0MDdaXCI+PC9zdmc+YCwgZmFsc2UsIHRydWUsIGZhbHNlKTtcbmNvbnN0IHJvdGF0aW9uRGVncmVlcyA9IHtcbiAgbGVmdDogMCxcbiAgdG9wOiA5MCxcbiAgcmlnaHQ6IDE4MCxcbiAgYm90dG9tOiAyNzBcbn07XG5jb25zdCBBcnJvd0ljb24gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCBmaWxsID0gKCkgPT4gcHJvcHMuZmlsbCB8fCB0aGVtZS5jb2xvcnMuaWNvbi5zZWNvbmRhcnk7XG4gIGNvbnN0IGRpcmVjdGlvbiA9ICgpID0+IHByb3BzLmRpcmVjdGlvbiB8fCBcImxlZnRcIjtcbiAgY29uc3QgU3ZnID0gc3R5bGVkKFwic3ZnXCIpYFxuICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgkeyhwcm9wczIpID0+IHJvdGF0aW9uRGVncmVlc1twcm9wczIuc3ZnRGlyZWN0aW9uXX1kZWcpO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4xcyBlYXNlLWluLW91dDtcbiAgICBgO1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFN2Zywge1xuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgd2lkdGg6IFwiMTZcIixcbiAgICBoZWlnaHQ6IFwiMTZcIixcbiAgICB2aWV3Qm94OiBcIjAgMCAxNiAxNlwiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIGdldCBzdmdEaXJlY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZGlyZWN0aW9uKCk7XG4gICAgfSxcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICB2YXIgX2VsJCA9IF90bXBsJCR2KCk7XG4gICAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKCkgPT4gc2V0QXR0cmlidXRlKF9lbCQsIFwiZmlsbFwiLCBmaWxsKCkpKTtcbiAgICAgIHJldHVybiBfZWwkO1xuICAgIH1cbiAgfSk7XG59O1xudmFyIF90bXBsJCR1ID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcgd2lkdGg9MTYgaGVpZ2h0PTE2IHZpZXdCb3g9XCIwIDAgMTYgMTZcImZpbGw9bm9uZT48cGF0aCBmaWxsLXJ1bGU9ZXZlbm9kZCBjbGlwLXJ1bGU9ZXZlbm9kZCBkPVwiTTIuNzE5NjYgMi43MTk2OEMzLjAxMjU1IDIuNDI2NzggMy40ODc0MyAyLjQyNjc3IDMuNzgwMzIgMi43MTk2Nkw4LjAwMDAyIDYuOTM5MjVMMTIuMjE5NyAyLjcxOTY3QzEyLjUxMjYgMi40MjY3NyAxMi45ODc0IDIuNDI2NzggMTMuMjgwMyAyLjcxOTY3QzEzLjU3MzIgMy4wMTI1NyAxMy41NzMyIDMuNDg3NDQgMTMuMjgwMyAzLjc4MDMzTDkuMDYwNjggNy45OTk5MUwxMy4yODAzIDEyLjIxOTdDMTMuNTczMiAxMi41MTI2IDEzLjU3MzIgMTIuOTg3NCAxMy4yODAzIDEzLjI4MDNDMTIuOTg3NCAxMy41NzMyIDEyLjUxMjYgMTMuNTczMiAxMi4yMTk3IDEzLjI4MDNMOC4wMDAwMiA5LjA2MDU3TDMuNzgwMzMgMTMuMjgwM0MzLjQ4NzQ0IDEzLjU3MzIgMy4wMTI1NyAxMy41NzMyIDIuNzE5NjcgMTMuMjgwM0MyLjQyNjc4IDEyLjk4NzQgMi40MjY3NyAxMi41MTI2IDIuNzE5NjcgMTIuMjE5N0w2LjkzOTM2IDcuOTk5OTFMMi43MTk2OCAzLjc4MDM0QzIuNDI2NzggMy40ODc0NSAyLjQyNjc3IDMuMDEyNTcgMi43MTk2NiAyLjcxOTY4WlwiPmApO1xuY29uc3QgQ2xvc2VJY29uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3QgZmlsbCA9ICgpID0+IHByb3BzLmZpbGwgfHwgdGhlbWUuY29sb3JzLmljb24uc2Vjb25kYXJ5O1xuICByZXR1cm4gKCgpID0+IHtcbiAgICB2YXIgX2VsJCA9IF90bXBsJCR1KCksIF9lbCQyID0gX2VsJC5maXJzdENoaWxkO1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoKSA9PiBzZXRBdHRyaWJ1dGUoX2VsJDIsIFwiZmlsbFwiLCBmaWxsKCkpKTtcbiAgICByZXR1cm4gX2VsJDtcbiAgfSkoKTtcbn07XG5jb25zdCBJY29uQnV0dG9uU3R5bGVkID0gc3R5bGVkLmJ1dHRvbmBcbiAgICBwYWRkaW5nOiAwO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICB3aWR0aDogMzJweDtcbiAgICBoZWlnaHQ6IDMycHg7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuYmFja2dyb3VuZC50aW50fTtcbiAgICBib3JkZXI6IG5vbmU7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMTI1cyBlYXNlLWluLW91dDtcblxuICAgICR7bWVkaWFOb3RUb3VjaH0ge1xuICAgICAgICAmOmhvdmVyIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMS4wNCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAmOmFjdGl2ZSB7XG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC45Nik7XG4gICAgfVxuXG4gICAgJHttZWRpYVRvdWNofSB7XG4gICAgICAgICY6YWN0aXZlIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC45Mik7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuY29uc3QgSWNvbkJ1dHRvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCBkYXRhQXR0cnMgPSB1c2VEYXRhQXR0cmlidXRlcyhwcm9wcyk7XG4gIGNvbnN0IGljb24gPSAoKSA9PiBwcm9wcy5pY29uIHx8IFwiY2xvc2VcIjtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChJY29uQnV0dG9uU3R5bGVkLCBtZXJnZVByb3BzKHtcbiAgICBnZXQgW1wiY2xhc3NcIl0oKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2xhc3M7XG4gICAgfSxcbiAgICBvbkNsaWNrOiAoKSA9PiBwcm9wcy5vbkNsaWNrKCksXG4gICAgXCJkYXRhLXRjLWljb24tYnV0dG9uXCI6IFwidHJ1ZVwiXG4gIH0sIGRhdGFBdHRycywge1xuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgcmV0dXJuICEhcHJvcHMuY2hpbGRyZW47XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICByZXR1cm4gIXByb3BzLmNoaWxkcmVuO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChTd2l0Y2gsIHtcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpY29uKCkgPT09IFwiY2xvc2VcIjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQ2xvc2VJY29uLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCBmaWxsKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy5maWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpY29uKCkgPT09IFwiYXJyb3dcIjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQXJyb3dJY29uLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCBmaWxsKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy5maWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpY29uKCkgPT09IFwicXVlc3Rpb25cIjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoUXVlc3Rpb25JY29uLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCBmaWxsKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy5maWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgaWNvbigpICE9PSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGljb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSldO1xuICAgIH1cbiAgfSkpO1xufTtcbmNvbnN0IGJvcmRlcnMkNSA9IHtcbiAgbTogXCIyNHB4XCIsXG4gIHM6IFwiMTZweFwiLFxuICBub25lOiBcIjBcIlxufTtcbmNvbnN0IE1vZGFsQmFja2dyb3VuZFN0eWxlZCA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgei1pbmRleDogMTAwMDtcbiAgICBsZWZ0OiAwO1xuICAgIHRvcDogMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjQpO1xuICAgIHBhZGRpbmc6IDIwcHggMDtcbiAgICBvdmVyZmxvdy15OiBhdXRvO1xuXG4gICAgJHttZWRpYShcIm1vYmlsZVwiKX0ge1xuICAgICAgICBwYWRkaW5nLWJvdHRvbTogMDtcbiAgICB9XG5gO1xuY29uc3QgTW9kYWxXcmFwcGVyQ2xhc3MgPSB1YFxuICAgIGJveC1zaGFkb3c6XG4gICAgICAgIDAgNHB4IDE2cHggcmdiYSgwLCAwLCAwLCAwLjA4KSxcbiAgICAgICAgMCAxNnB4IDY0cHggcmdiYSgwLCAwLCAwLCAwLjE2KTtcbiAgICB3aWR0aDogZml0LWNvbnRlbnQ7XG4gICAgbWFyZ2luOiBhdXRvO1xuXG4gICAgJHttZWRpYShcIm1vYmlsZVwiKX0ge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiBmaXQtY29udGVudDtcbiAgICAgICAgbWFyZ2luOiBhdXRvIDAgMCAwO1xuICAgIH1cbmA7XG5jb25zdCBNb2RhbEJvZHlTdHlsZWQgPSBzdHlsZWQuZGl2YFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBtaW4taGVpZ2h0OiAxMDBweDtcbiAgICB3aWR0aDogNDE2cHg7XG4gICAgcGFkZGluZzogNDRweCA1NnB4IDI0cHg7XG5cbiAgICBib3gtc2hhZG93OiAwIDJweCA4cHggMCByZ2JhKDAsIDAsIDAsIDAuMDQpO1xuXG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnByaW1hcnl9O1xuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiBib3JkZXJzJDVbcHJvcHMudGhlbWUuYm9yZGVyUmFkaXVzXX07XG5cbiAgICAke21lZGlhKFwibW9iaWxlXCIpfSB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgIH1cbmA7XG5jb25zdCBDbG9zZUJ1dHRvblN0eWxlZCA9IHN0eWxlZChJY29uQnV0dG9uKWBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgcmlnaHQ6IDE2cHg7XG4gICAgdG9wOiAxNnB4O1xuYDtcbmNvbnN0IE1vZGFsRm9vdGVyU3R5bGVkID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIHBhZGRpbmc6IDE2cHggMTZweCAxNnB4IDE4cHg7XG4gICAgYm9yZGVyLXJhZGl1czogMCAwICR7KHByb3BzKSA9PiBib3JkZXJzJDVbcHJvcHMudGhlbWUuYm9yZGVyUmFkaXVzXX1cbiAgICAgICAgJHsocHJvcHMpID0+IGJvcmRlcnMkNVtwcm9wcy50aGVtZS5ib3JkZXJSYWRpdXNdfTtcbmA7XG5jb25zdCBRdWVzdGlvbkJ1dHRvblN0eWxlZCA9IHN0eWxlZChJY29uQnV0dG9uKWBcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4gcmdiYShwcm9wcy50aGVtZS5jb2xvcnMuaWNvbi5zZWNvbmRhcnksIDAuMTIpfTtcbmA7XG5jbGFzcyBBbmltYXRpb25UaW1lbGluZU5vb3Age1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgfVxufVxuY29uc3QgX0FuaW1hdGlvbk5vb3AgPSBjbGFzcyBfQW5pbWF0aW9uTm9vcCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICAgIHRoaXMucGxheWJhY2tSYXRlID0gMTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gICAgdGhpcy50aW1lbGluZSA9IG5ldyBBbmltYXRpb25UaW1lbGluZU5vb3AoKTtcbiAgICB0aGlzLmZpbmlzaGVkID0gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuICAgIHRoaXMuZWZmZWN0ID0gbnVsbDtcbiAgICB0aGlzLmlkID0gXCJcIjtcbiAgICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnBsYXlTdGF0ZSA9IFwiZmluaXNoZWRcIjtcbiAgICB0aGlzLnJlcGxhY2VTdGF0ZSA9IFwiYWN0aXZlXCI7XG4gICAgdGhpcy5yZWFkeSA9IFByb21pc2UucmVzb2x2ZSh0aGlzKTtcbiAgICB0aGlzLm9uY2FuY2VsID0gbnVsbDtcbiAgICB0aGlzLm9uZmluaXNoID0gbnVsbDtcbiAgICB0aGlzLm9ucmVtb3ZlID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKCkge1xuICAgIGlmICghX0FuaW1hdGlvbk5vb3AuX2luc3RhbmNlKSB7XG4gICAgICBsb2dXYXJuaW5nKFxuICAgICAgICBcIkFuaW1hdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQ6IHBsZWFzZSBjb25zaWRlciB1c2luZyB0aGUgYHdlYi1hbmltYXRpb25zLWpzYCBwb2x5ZmlsbCB0byBwcm92aWRlIGEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgdGhlIFdlYiBBbmltYXRpb25zIEFQSS5cIlxuICAgICAgKTtcbiAgICAgIF9BbmltYXRpb25Ob29wLl9pbnN0YW5jZSA9IG5ldyBfQW5pbWF0aW9uTm9vcCgpO1xuICAgIH1cbiAgICByZXR1cm4gX0FuaW1hdGlvbk5vb3AuX2luc3RhbmNlO1xuICB9XG4gIGNhbmNlbCgpIHtcbiAgfVxuICBmaW5pc2goKSB7XG4gIH1cbiAgcGF1c2UoKSB7XG4gIH1cbiAgcGxheSgpIHtcbiAgfVxuICByZXZlcnNlKCkge1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIoX3R5cGUsIF9saXN0ZW5lciwgX29wdGlvbnMpIHtcbiAgfVxuICBkaXNwYXRjaEV2ZW50KF9ldmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZW1vdmVFdmVudExpc3RlbmVyKF90eXBlLCBfY2FsbGJhY2ssIF9vcHRpb25zKSB7XG4gIH1cbiAgdXBkYXRlUGxheWJhY2tSYXRlKF9wbGF5YmFja1JhdGUpIHtcbiAgfVxuICBjb21taXRTdHlsZXMoKSB7XG4gIH1cbiAgcGVyc2lzdCgpIHtcbiAgfVxufTtcbl9BbmltYXRpb25Ob29wLl9pbnN0YW5jZSA9IG51bGw7XG5sZXQgQW5pbWF0aW9uTm9vcCA9IF9BbmltYXRpb25Ob29wO1xuZnVuY3Rpb24gYW5pbWF0ZShlbGVtZW50LCBrZXlmcmFtZXMsIG9wdGlvbnMpIHtcbiAgaWYgKFwiYW5pbWF0ZVwiIGluIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5hbmltYXRlKGtleWZyYW1lcywgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIEFuaW1hdGlvbk5vb3AuY3JlYXRlKCk7XG59XG52YXIgX3RtcGwkJHQgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPGRpdj5gKTtcbmNvbnN0IGNsaWNrT3V0c2lkZSA9IGNsaWNrT3V0c2lkZSQxO1xuY29uc3Qga2V5UHJlc3NlZCA9IGVzY1ByZXNzZWQ7XG5jb25zdCBhbmRyb2lkQmFja0hhbmRsZXIgPSBhbmRyb2lkQmFja0hhbmRsZXIkMTtcbmNvbnN0IE1vZGFsID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3QgZGF0YUF0dHJzID0gdXNlRGF0YUF0dHJpYnV0ZXMocHJvcHMpO1xuICBjcmVhdGVFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcm9wcy5vcGVuZWQpIHtcbiAgICAgIGRpc2FibGVTY3JvbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5hYmxlU2Nyb2xsKCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2l0aW9uLCB7XG4gICAgb25CZWZvcmVFbnRlcjogKGVsKSA9PiB7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IGlzRGV2aWNlKFwibW9iaWxlXCIpID8gMjAwIDogMTAwO1xuICAgICAgYW5pbWF0ZShlbCwgW3tcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSwge1xuICAgICAgICBvcGFjaXR5OiAxXG4gICAgICB9XSwge1xuICAgICAgICBkdXJhdGlvblxuICAgICAgfSk7XG4gICAgICBpZiAoaXNEZXZpY2UoXCJtb2JpbGVcIikpIHtcbiAgICAgICAgYW5pbWF0ZShlbC5maXJzdEVsZW1lbnRDaGlsZCwgW3tcbiAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSgzOTBweClcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoMClcIlxuICAgICAgICB9XSwge1xuICAgICAgICAgIGR1cmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25FeGl0OiAoZWwsIGRvbmUpID0+IHtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gaXNEZXZpY2UoXCJtb2JpbGVcIikgPyAyMDAgOiAxMDA7XG4gICAgICBjb25zdCBiYWNrZ3JvdW5kQW5pbWF0aW9uID0gYW5pbWF0ZShlbCwgW3tcbiAgICAgICAgb3BhY2l0eTogMVxuICAgICAgfSwge1xuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9XSwge1xuICAgICAgICBkdXJhdGlvblxuICAgICAgfSk7XG4gICAgICBpZiAoaXNEZXZpY2UoXCJtb2JpbGVcIikpIHtcbiAgICAgICAgY29uc3QgY29udGVudEFuaW1hdGlvbiA9IGFuaW1hdGUoZWwuZmlyc3RFbGVtZW50Q2hpbGQsIFt7XG4gICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoMClcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoMzkwcHgpXCJcbiAgICAgICAgfV0sIHtcbiAgICAgICAgICBkdXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgUHJvbWlzZS5hbGwoW2JhY2tncm91bmRBbmltYXRpb24uZmluaXNoZWQsIGNvbnRlbnRBbmltYXRpb24uZmluaXNoZWRdKS50aGVuKGRvbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFja2dyb3VuZEFuaW1hdGlvbi5maW5pc2hlZC50aGVuKGRvbmUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wcy5vcGVuZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KE1vZGFsQmFja2dyb3VuZFN0eWxlZCwgbWVyZ2VQcm9wcyh7XG4gICAgICAgICAgICBcImRhdGEtdGMtbW9kYWxcIjogXCJ0cnVlXCJcbiAgICAgICAgICB9LCBkYXRhQXR0cnMsIHtcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgdmFyIF9lbCQgPSBfdG1wbCQkdCgpO1xuICAgICAgICAgICAgICB1c2UoYW5kcm9pZEJhY2tIYW5kbGVyLCBfZWwkLCAoKSA9PiAoe1xuICAgICAgICAgICAgICAgIGlzRW5hYmxlZDogcHJvcHMuZW5hYmxlQW5kcm9pZEJhY2tIYW5kbGVyLFxuICAgICAgICAgICAgICAgIG9uQ2xvc2U6ICgpID0+IHByb3BzLm9uQ2xvc2UoKVxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIHVzZShrZXlQcmVzc2VkLCBfZWwkLCAoKSA9PiAoKSA9PiBwcm9wcy5vbkNsb3NlKCkpO1xuICAgICAgICAgICAgICB1c2UoY2xpY2tPdXRzaWRlLCBfZWwkLCAoKSA9PiAoKSA9PiBwcm9wcy5vbkNsb3NlKCkpO1xuICAgICAgICAgICAgICBpbnNlcnQoX2VsJCwgY3JlYXRlQ29tcG9uZW50KE1vZGFsQm9keVN0eWxlZCwge1xuICAgICAgICAgICAgICAgIGdldCBbXCJjbGFzc1wiXSgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy5jbGFzcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KENsb3NlQnV0dG9uU3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgICAgIGljb246IFwiY2xvc2VcIixcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gcHJvcHMub25DbG9zZSgpXG4gICAgICAgICAgICAgICAgICB9KSwgbWVtbygoKSA9PiBwcm9wcy5jaGlsZHJlbildO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIG51bGwpO1xuICAgICAgICAgICAgICBpbnNlcnQoX2VsJCwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy5vbkNsaWNrUXVlc3Rpb24gJiYgcHJvcHMuc2hvd0Zvb3RlcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoTW9kYWxGb290ZXJTdHlsZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFRvbkNvbm5lY3RCcmFuZCwge30pLCBjcmVhdGVDb21wb25lbnQoUXVlc3Rpb25CdXR0b25TdHlsZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBvbkNsaWNrKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMub25DbGlja1F1ZXN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb246IFwicXVlc3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSwgbnVsbCk7XG4gICAgICAgICAgICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoKSA9PiBjbGFzc05hbWUoX2VsJCwgY24oTW9kYWxXcmFwcGVyQ2xhc3MsIHVgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6ICR7Ym9yZGVycyQ1W3RoZW1lLmJvcmRlclJhZGl1c119O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnRpbnR9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7bWVkaWEoXCJtb2JpbGVcIil9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6ICR7Ym9yZGVycyQ1W3RoZW1lLmJvcmRlclJhZGl1c119XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtib3JkZXJzJDVbdGhlbWUuYm9yZGVyUmFkaXVzXX0gMCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYCkpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9lbCQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IHdyYXBwZXJCb3JkZXJSYWRpdXMgPSB7XG4gIG06IFwiMjJweFwiLFxuICBzOiBcIjEycHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCBzbGlkZXJCb3JkZXJSYWRpdXMgPSB7XG4gIG06IFwiMThweFwiLFxuICBzOiBcIjhweFwiLFxuICBub25lOiBcIjBcIlxufTtcbmNvbnN0IFRhYkJhclN0eWxlZCA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZ3JpZDtcbiAgICBncmlkLXRlbXBsYXRlOiAxZnIgLyAxZnIgMWZyO1xuICAgIHdpZHRoOiBmaXQtY29udGVudDtcbiAgICBqdXN0aWZ5LWl0ZW1zOiBjZW50ZXI7XG4gICAgZ2FwOiA0cHg7XG5cbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgcGFkZGluZzogNHB4O1xuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiB3cmFwcGVyQm9yZGVyUmFkaXVzW3Byb3BzLnRoZW1lLmJvcmRlclJhZGl1c119O1xuXG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnNlY29uZGFyeX07XG5gO1xuY29uc3QgU2xpZGVyU3R5bGVkID0gc3R5bGVkLmRpdmBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiA0cHg7XG4gICAgbGVmdDogNHB4O1xuXG4gICAgaGVpZ2h0OiBjYWxjKDEwMCUgLSA4cHgpO1xuICAgIHdpZHRoOiBjYWxjKDUwJSAtIDRweCk7XG5cbiAgICBib3JkZXItcmFkaXVzOiAkeyhwcm9wcykgPT4gc2xpZGVyQm9yZGVyUmFkaXVzW3Byb3BzLnRoZW1lLmJvcmRlclJhZGl1c119O1xuICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5zZWdtZW50fTtcblxuICAgIHRyYW5zZm9ybTogJHsocHJvcHMpID0+IHByb3BzLnJpZ2h0ID8gXCJ0cmFuc2xhdGVYKDEwMCUpXCIgOiBcInRyYW5zbGF0ZVgoMClcIn07XG5cbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4xM3MgZWFzZS1pbi1vdXQ7XG5gO1xuY29uc3QgSW5wdXRTdHlsZWQgPSBzdHlsZWQuaW5wdXRgXG4gICAgZGlzcGxheTogbm9uZTtcbmA7XG5jb25zdCBMYWJlbFN0eWxlZCA9IHN0eWxlZC5sYWJlbGBcbiAgICBwYWRkaW5nOiA5cHggMTJweDtcbiAgICB6LWluZGV4OiAxO1xuXG4gICAgY3Vyc29yOiAkeyhwcm9wcykgPT4gcHJvcHMuaXNBY3RpdmUgPyBcImRlZmF1bHRcIiA6IFwicG9pbnRlclwifTtcblxuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjEzcyBlYXNlLWluLW91dDtcblxuICAgICY6aG92ZXIge1xuICAgICAgICB0cmFuc2Zvcm06ICR7KHByb3BzKSA9PiBwcm9wcy5pc0FjdGl2ZSA/IFwibm9uZVwiIDogXCJzY2FsZSgxLjAyNSlcIn07XG4gICAgfVxuXG4gICAgPiAqIHtcbiAgICAgICAgJHsocHJvcHMpID0+ICFwcm9wcy5pc0FjdGl2ZSA/IGBjb2xvcjogJHtwcm9wcy50aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnl9O2AgOiBcIlwifVxuICAgIH1cbmA7XG5jb25zdCBUYWJCYXIgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgZ3JvdXBOYW1lID0gXCJ0YWJCYXJcIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlNCk7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoVGFiQmFyU3R5bGVkLCB7XG4gICAgZ2V0IFtcImNsYXNzXCJdKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgIH0sXG4gICAgXCJkYXRhLXRjLXRhYi1iYXJcIjogXCJ0cnVlXCIsXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoU2xpZGVyU3R5bGVkLCB7XG4gICAgICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcHMuc2VsZWN0ZWRUYWJJbmRleCA9PT0gMTtcbiAgICAgICAgfVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChMYWJlbFN0eWxlZCwge1xuICAgICAgICBnZXQgaXNBY3RpdmUoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLnNlbGVjdGVkVGFiSW5kZXggPT09IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChJbnB1dFN0eWxlZCwge1xuICAgICAgICAgICAgdHlwZTogXCJyYWRpb1wiLFxuICAgICAgICAgICAgbmFtZTogZ3JvdXBOYW1lLFxuICAgICAgICAgICAgZ2V0IGNoZWNrZWQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wcy5zZWxlY3RlZFRhYkluZGV4ID09PSAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uSW5wdXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICAgICAgcmV0dXJuIChfYTIgPSBwcm9wcy5vblNlbGVjdGVkVGFiSW5kZXhDaGFuZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChwcm9wcywgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIG1lbW8oKCkgPT4gcHJvcHMudGFiMSldO1xuICAgICAgICB9XG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KExhYmVsU3R5bGVkLCB7XG4gICAgICAgIGdldCBpc0FjdGl2ZSgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcHMuc2VsZWN0ZWRUYWJJbmRleCA9PT0gMTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KElucHV0U3R5bGVkLCB7XG4gICAgICAgICAgICB0eXBlOiBcInJhZGlvXCIsXG4gICAgICAgICAgICBnZXQgY2hlY2tlZCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLnNlbGVjdGVkVGFiSW5kZXggPT09IDE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogZ3JvdXBOYW1lLFxuICAgICAgICAgICAgb25JbnB1dDogKCkgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgICAgICByZXR1cm4gKF9hMiA9IHByb3BzLm9uU2VsZWN0ZWRUYWJJbmRleENoYW5nZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYWxsKHByb3BzLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgbWVtbygoKSA9PiBwcm9wcy50YWIyKV07XG4gICAgICAgIH1cbiAgICAgIH0pXTtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IGJhY2tncm91bmRCb3JkZXJzID0ge1xuICBtOiBcIjE2cHhcIixcbiAgczogXCIxMnB4XCIsXG4gIG5vbmU6IFwiMFwiXG59O1xuY29uc3QgaW1hZ2VCb3JkZXJzID0ge1xuICBtOiBcIjEycHhcIixcbiAgczogXCI4cHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCBxck5vcm1hbFNpemUgPSAyNTY7XG5jb25zdCBpbWdTaXplRGVmYXVsdCA9IDYwO1xuY29uc3QgcGljU2l6ZURlZmF1bHQgPSA0ODtcbmNvbnN0IHFyUGFkZGluZ1RvcCA9IDI0O1xuY29uc3QgQ29weUljb25CdXR0b24gPSBzdHlsZWQuZGl2YFxuICAgIHdpZHRoOiA1MnB4O1xuICAgIGhlaWdodDogNTJweDtcbiAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgcmlnaHQ6IDA7XG4gICAgYm90dG9tOiAwO1xuXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjEyNXMgZWFzZS1pbi1vdXQ7XG5gO1xuY29uc3QgUXJDb2RlQmFja2dyb3VuZCA9IHN0eWxlZC5idXR0b25gXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmJhY2tncm91bmQucXJ9O1xuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiBiYWNrZ3JvdW5kQm9yZGVyc1twcm9wcy50aGVtZS5ib3JkZXJSYWRpdXNdfTtcbiAgICBwYWRkaW5nOiAke3RvUHgocXJQYWRkaW5nVG9wKX0gMDtcbiAgICBoZWlnaHQ6ICR7dG9QeChxck5vcm1hbFNpemUgKyBxclBhZGRpbmdUb3AgKiAyKX07XG4gICAgd2lkdGg6IDEwMCU7XG5cbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBib3JkZXI6IG5vbmU7XG5cbiAgICAke21lZGlhTm90VG91Y2h9IHtcbiAgICAgICAgJjpob3ZlciB7XG4gICAgICAgICAgICAke0NvcHlJY29uQnV0dG9uLmNsYXNzfSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLjA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgICY6YWN0aXZlIHtcbiAgICAgICAgJHtDb3B5SWNvbkJ1dHRvbi5jbGFzc30ge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjk2KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICR7bWVkaWFUb3VjaH0ge1xuICAgICAgICAmOmFjdGl2ZSB7XG4gICAgICAgICAgICAke0NvcHlJY29uQnV0dG9uLmNsYXNzfSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbmA7XG5jb25zdCBRckNvZGVXcmFwcGVyJDIgPSBzdHlsZWQuZGl2YFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgbWFyZ2luOiAwIGF1dG87XG5cbiAgICA+IGRpdjpmaXJzdC1jaGlsZCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIH1cblxuICAgIHJlY3Qge1xuICAgICAgICBmaWxsOiB0cmFuc3BhcmVudDtcbiAgICB9XG5cbiAgICBwYXRoIHtcbiAgICAgICAgZmlsbDogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5jb25zdGFudC5ibGFja307XG4gICAgfVxuYDtcbmNvbnN0IEltYWdlQmFja2dyb3VuZCA9IHN0eWxlZC5kaXZgXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHdpZHRoOiAke3RvUHgoaW1nU2l6ZURlZmF1bHQpfTtcbiAgICBoZWlnaHQ6ICR7dG9QeChpbWdTaXplRGVmYXVsdCl9O1xuICAgIGJhY2tncm91bmQ6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5xcn07XG5cbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5gO1xuY29uc3QgSW1hZ2VTdHlsZWQkMyA9IHN0eWxlZChJbWFnZSlgXG4gICAgd2lkdGg6ICR7KHByb3BzKSA9PiB0b1B4KHByb3BzLnNpemUpfTtcbiAgICBoZWlnaHQ6ICR7KHByb3BzKSA9PiB0b1B4KHByb3BzLnNpemUpfTtcbiAgICBib3JkZXItcmFkaXVzOiAkeyhwcm9wcykgPT4gaW1hZ2VCb3JkZXJzW3Byb3BzLnRoZW1lLmJvcmRlclJhZGl1c119O1xuICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5xcn07XG5gO1xuY29uc3QgQ29waWVkQm94U3R5bGVkID0gc3R5bGVkLmRpdmBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYm90dG9tOiAxNHB4O1xuICAgIGxlZnQ6IDUwJTtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAwKTtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZ2FwOiA2cHg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBib3JkZXItcmFkaXVzOiAxOHB4O1xuICAgIG1pbi13aWR0aDogMTI2cHg7XG4gICAgcGFkZGluZzogOXB4IDE2cHggOXB4IDEwcHg7XG5cbiAgICBmaWx0ZXI6IGRyb3Atc2hhZG93KDBweCAycHggOHB4IHJnYmEoMCwgMCwgMCwgMC4wOCkpO1xuICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5zZWdtZW50fTtcbmA7XG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyh4KSB7XG4gIHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgXCJkZWZhdWx0XCIpID8geFtcImRlZmF1bHRcIl0gOiB4O1xufVxudmFyIHFyY29kZSQxID0geyBleHBvcnRzOiB7fSB9O1xudmFyIGhhc1JlcXVpcmVkUXJjb2RlO1xuZnVuY3Rpb24gcmVxdWlyZVFyY29kZSgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkUXJjb2RlKSByZXR1cm4gcXJjb2RlJDEuZXhwb3J0cztcbiAgaGFzUmVxdWlyZWRRcmNvZGUgPSAxO1xuICAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG4gICAgdmFyIHFyY29kZTIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBxcmNvZGUzID0gZnVuY3Rpb24odHlwZU51bWJlciwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpIHtcbiAgICAgICAgdmFyIFBBRDAgPSAyMzY7XG4gICAgICAgIHZhciBQQUQxID0gMTc7XG4gICAgICAgIHZhciBfdHlwZU51bWJlciA9IHR5cGVOdW1iZXI7XG4gICAgICAgIHZhciBfZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBRUkVycm9yQ29ycmVjdGlvbkxldmVsW2Vycm9yQ29ycmVjdGlvbkxldmVsXTtcbiAgICAgICAgdmFyIF9tb2R1bGVzID0gbnVsbDtcbiAgICAgICAgdmFyIF9tb2R1bGVDb3VudCA9IDA7XG4gICAgICAgIHZhciBfZGF0YUNhY2hlID0gbnVsbDtcbiAgICAgICAgdmFyIF9kYXRhTGlzdCA9IFtdO1xuICAgICAgICB2YXIgX3RoaXMgPSB7fTtcbiAgICAgICAgdmFyIG1ha2VJbXBsID0gZnVuY3Rpb24odGVzdCwgbWFza1BhdHRlcm4pIHtcbiAgICAgICAgICBfbW9kdWxlQ291bnQgPSBfdHlwZU51bWJlciAqIDQgKyAxNztcbiAgICAgICAgICBfbW9kdWxlcyA9IGZ1bmN0aW9uKG1vZHVsZUNvdW50KSB7XG4gICAgICAgICAgICB2YXIgbW9kdWxlcyA9IG5ldyBBcnJheShtb2R1bGVDb3VudCk7XG4gICAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudDsgcm93ICs9IDEpIHtcbiAgICAgICAgICAgICAgbW9kdWxlc1tyb3ddID0gbmV3IEFycmF5KG1vZHVsZUNvdW50KTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlc1tyb3ddW2NvbF0gPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlcztcbiAgICAgICAgICB9KF9tb2R1bGVDb3VudCk7XG4gICAgICAgICAgc2V0dXBQb3NpdGlvblByb2JlUGF0dGVybigwLCAwKTtcbiAgICAgICAgICBzZXR1cFBvc2l0aW9uUHJvYmVQYXR0ZXJuKF9tb2R1bGVDb3VudCAtIDcsIDApO1xuICAgICAgICAgIHNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4oMCwgX21vZHVsZUNvdW50IC0gNyk7XG4gICAgICAgICAgc2V0dXBQb3NpdGlvbkFkanVzdFBhdHRlcm4oKTtcbiAgICAgICAgICBzZXR1cFRpbWluZ1BhdHRlcm4oKTtcbiAgICAgICAgICBzZXR1cFR5cGVJbmZvKHRlc3QsIG1hc2tQYXR0ZXJuKTtcbiAgICAgICAgICBpZiAoX3R5cGVOdW1iZXIgPj0gNykge1xuICAgICAgICAgICAgc2V0dXBUeXBlTnVtYmVyKHRlc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX2RhdGFDYWNoZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBfZGF0YUNhY2hlID0gY3JlYXRlRGF0YShfdHlwZU51bWJlciwgX2Vycm9yQ29ycmVjdGlvbkxldmVsLCBfZGF0YUxpc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXBEYXRhKF9kYXRhQ2FjaGUsIG1hc2tQYXR0ZXJuKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4gPSBmdW5jdGlvbihyb3csIGNvbCkge1xuICAgICAgICAgIGZvciAodmFyIHIgPSAtMTsgciA8PSA3OyByICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChyb3cgKyByIDw9IC0xIHx8IF9tb2R1bGVDb3VudCA8PSByb3cgKyByKSBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGMyID0gLTE7IGMyIDw9IDc7IGMyICs9IDEpIHtcbiAgICAgICAgICAgICAgaWYgKGNvbCArIGMyIDw9IC0xIHx8IF9tb2R1bGVDb3VudCA8PSBjb2wgKyBjMikgY29udGludWU7XG4gICAgICAgICAgICAgIGlmICgwIDw9IHIgJiYgciA8PSA2ICYmIChjMiA9PSAwIHx8IGMyID09IDYpIHx8IDAgPD0gYzIgJiYgYzIgPD0gNiAmJiAociA9PSAwIHx8IHIgPT0gNikgfHwgMiA8PSByICYmIHIgPD0gNCAmJiAyIDw9IGMyICYmIGMyIDw9IDQpIHtcbiAgICAgICAgICAgICAgICBfbW9kdWxlc1tyb3cgKyByXVtjb2wgKyBjMl0gPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9tb2R1bGVzW3JvdyArIHJdW2NvbCArIGMyXSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2V0QmVzdE1hc2tQYXR0ZXJuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIG1pbkxvc3RQb2ludCA9IDA7XG4gICAgICAgICAgdmFyIHBhdHRlcm4gPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCA4OyBpMiArPSAxKSB7XG4gICAgICAgICAgICBtYWtlSW1wbCh0cnVlLCBpMik7XG4gICAgICAgICAgICB2YXIgbG9zdFBvaW50ID0gUVJVdGlsLmdldExvc3RQb2ludChfdGhpcyk7XG4gICAgICAgICAgICBpZiAoaTIgPT0gMCB8fCBtaW5Mb3N0UG9pbnQgPiBsb3N0UG9pbnQpIHtcbiAgICAgICAgICAgICAgbWluTG9zdFBvaW50ID0gbG9zdFBvaW50O1xuICAgICAgICAgICAgICBwYXR0ZXJuID0gaTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgc2V0dXBUaW1pbmdQYXR0ZXJuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgciA9IDg7IHIgPCBfbW9kdWxlQ291bnQgLSA4OyByICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChfbW9kdWxlc1tyXVs2XSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX21vZHVsZXNbcl1bNl0gPSByICUgMiA9PSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBjMiA9IDg7IGMyIDwgX21vZHVsZUNvdW50IC0gODsgYzIgKz0gMSkge1xuICAgICAgICAgICAgaWYgKF9tb2R1bGVzWzZdW2MyXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX21vZHVsZXNbNl1bYzJdID0gYzIgJSAyID09IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgc2V0dXBQb3NpdGlvbkFkanVzdFBhdHRlcm4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcG9zID0gUVJVdGlsLmdldFBhdHRlcm5Qb3NpdGlvbihfdHlwZU51bWJlcik7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHBvcy5sZW5ndGg7IGkyICs9IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9zLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciByb3cgPSBwb3NbaTJdO1xuICAgICAgICAgICAgICB2YXIgY29sID0gcG9zW2pdO1xuICAgICAgICAgICAgICBpZiAoX21vZHVsZXNbcm93XVtjb2xdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKHZhciByID0gLTI7IHIgPD0gMjsgciArPSAxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYzIgPSAtMjsgYzIgPD0gMjsgYzIgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHIgPT0gLTIgfHwgciA9PSAyIHx8IGMyID09IC0yIHx8IGMyID09IDIgfHwgciA9PSAwICYmIGMyID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX21vZHVsZXNbcm93ICsgcl1bY29sICsgYzJdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9tb2R1bGVzW3JvdyArIHJdW2NvbCArIGMyXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNldHVwVHlwZU51bWJlciA9IGZ1bmN0aW9uKHRlc3QpIHtcbiAgICAgICAgICB2YXIgYml0cyA9IFFSVXRpbC5nZXRCQ0hUeXBlTnVtYmVyKF90eXBlTnVtYmVyKTtcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgMTg7IGkyICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBtb2QgPSAhdGVzdCAmJiAoYml0cyA+PiBpMiAmIDEpID09IDE7XG4gICAgICAgICAgICBfbW9kdWxlc1tNYXRoLmZsb29yKGkyIC8gMyldW2kyICUgMyArIF9tb2R1bGVDb3VudCAtIDggLSAzXSA9IG1vZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IDE4OyBpMiArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbW9kID0gIXRlc3QgJiYgKGJpdHMgPj4gaTIgJiAxKSA9PSAxO1xuICAgICAgICAgICAgX21vZHVsZXNbaTIgJSAzICsgX21vZHVsZUNvdW50IC0gOCAtIDNdW01hdGguZmxvb3IoaTIgLyAzKV0gPSBtb2Q7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgc2V0dXBUeXBlSW5mbyA9IGZ1bmN0aW9uKHRlc3QsIG1hc2tQYXR0ZXJuKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBfZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPDwgMyB8IG1hc2tQYXR0ZXJuO1xuICAgICAgICAgIHZhciBiaXRzID0gUVJVdGlsLmdldEJDSFR5cGVJbmZvKGRhdGEpO1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCAxNTsgaTIgKz0gMSkge1xuICAgICAgICAgICAgdmFyIG1vZCA9ICF0ZXN0ICYmIChiaXRzID4+IGkyICYgMSkgPT0gMTtcbiAgICAgICAgICAgIGlmIChpMiA8IDYpIHtcbiAgICAgICAgICAgICAgX21vZHVsZXNbaTJdWzhdID0gbW9kO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpMiA8IDgpIHtcbiAgICAgICAgICAgICAgX21vZHVsZXNbaTIgKyAxXVs4XSA9IG1vZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9tb2R1bGVzW19tb2R1bGVDb3VudCAtIDE1ICsgaTJdWzhdID0gbW9kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgMTU7IGkyICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBtb2QgPSAhdGVzdCAmJiAoYml0cyA+PiBpMiAmIDEpID09IDE7XG4gICAgICAgICAgICBpZiAoaTIgPCA4KSB7XG4gICAgICAgICAgICAgIF9tb2R1bGVzWzhdW19tb2R1bGVDb3VudCAtIGkyIC0gMV0gPSBtb2Q7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkyIDwgOSkge1xuICAgICAgICAgICAgICBfbW9kdWxlc1s4XVsxNSAtIGkyIC0gMSArIDFdID0gbW9kO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX21vZHVsZXNbOF1bMTUgLSBpMiAtIDFdID0gbW9kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBfbW9kdWxlc1tfbW9kdWxlQ291bnQgLSA4XVs4XSA9ICF0ZXN0O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbWFwRGF0YSA9IGZ1bmN0aW9uKGRhdGEsIG1hc2tQYXR0ZXJuKSB7XG4gICAgICAgICAgdmFyIGluYyA9IC0xO1xuICAgICAgICAgIHZhciByb3cgPSBfbW9kdWxlQ291bnQgLSAxO1xuICAgICAgICAgIHZhciBiaXRJbmRleCA9IDc7XG4gICAgICAgICAgdmFyIGJ5dGVJbmRleCA9IDA7XG4gICAgICAgICAgdmFyIG1hc2tGdW5jID0gUVJVdGlsLmdldE1hc2tGdW5jdGlvbihtYXNrUGF0dGVybik7XG4gICAgICAgICAgZm9yICh2YXIgY29sID0gX21vZHVsZUNvdW50IC0gMTsgY29sID4gMDsgY29sIC09IDIpIHtcbiAgICAgICAgICAgIGlmIChjb2wgPT0gNikgY29sIC09IDE7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBjMiA9IDA7IGMyIDwgMjsgYzIgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChfbW9kdWxlc1tyb3ddW2NvbCAtIGMyXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZGFyayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVJbmRleCA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhcmsgPSAoZGF0YVtieXRlSW5kZXhdID4+PiBiaXRJbmRleCAmIDEpID09IDE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YXIgbWFzayA9IG1hc2tGdW5jKHJvdywgY29sIC0gYzIpO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgZGFyayA9ICFkYXJrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX21vZHVsZXNbcm93XVtjb2wgLSBjMl0gPSBkYXJrO1xuICAgICAgICAgICAgICAgICAgYml0SW5kZXggLT0gMTtcbiAgICAgICAgICAgICAgICAgIGlmIChiaXRJbmRleCA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBieXRlSW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgYml0SW5kZXggPSA3O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByb3cgKz0gaW5jO1xuICAgICAgICAgICAgICBpZiAocm93IDwgMCB8fCBfbW9kdWxlQ291bnQgPD0gcm93KSB7XG4gICAgICAgICAgICAgICAgcm93IC09IGluYztcbiAgICAgICAgICAgICAgICBpbmMgPSAtaW5jO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgY3JlYXRlQnl0ZXMgPSBmdW5jdGlvbihidWZmZXIsIHJzQmxvY2tzKSB7XG4gICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgdmFyIG1heERjQ291bnQgPSAwO1xuICAgICAgICAgIHZhciBtYXhFY0NvdW50ID0gMDtcbiAgICAgICAgICB2YXIgZGNkYXRhID0gbmV3IEFycmF5KHJzQmxvY2tzLmxlbmd0aCk7XG4gICAgICAgICAgdmFyIGVjZGF0YSA9IG5ldyBBcnJheShyc0Jsb2Nrcy5sZW5ndGgpO1xuICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcnNCbG9ja3MubGVuZ3RoOyByICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBkY0NvdW50ID0gcnNCbG9ja3Nbcl0uZGF0YUNvdW50O1xuICAgICAgICAgICAgdmFyIGVjQ291bnQgPSByc0Jsb2Nrc1tyXS50b3RhbENvdW50IC0gZGNDb3VudDtcbiAgICAgICAgICAgIG1heERjQ291bnQgPSBNYXRoLm1heChtYXhEY0NvdW50LCBkY0NvdW50KTtcbiAgICAgICAgICAgIG1heEVjQ291bnQgPSBNYXRoLm1heChtYXhFY0NvdW50LCBlY0NvdW50KTtcbiAgICAgICAgICAgIGRjZGF0YVtyXSA9IG5ldyBBcnJheShkY0NvdW50KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBkY2RhdGFbcl0ubGVuZ3RoOyBpMiArPSAxKSB7XG4gICAgICAgICAgICAgIGRjZGF0YVtyXVtpMl0gPSAyNTUgJiBidWZmZXIuZ2V0QnVmZmVyKClbaTIgKyBvZmZzZXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGRjQ291bnQ7XG4gICAgICAgICAgICB2YXIgcnNQb2x5ID0gUVJVdGlsLmdldEVycm9yQ29ycmVjdFBvbHlub21pYWwoZWNDb3VudCk7XG4gICAgICAgICAgICB2YXIgcmF3UG9seSA9IHFyUG9seW5vbWlhbChkY2RhdGFbcl0sIHJzUG9seS5nZXRMZW5ndGgoKSAtIDEpO1xuICAgICAgICAgICAgdmFyIG1vZFBvbHkgPSByYXdQb2x5Lm1vZChyc1BvbHkpO1xuICAgICAgICAgICAgZWNkYXRhW3JdID0gbmV3IEFycmF5KHJzUG9seS5nZXRMZW5ndGgoKSAtIDEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGVjZGF0YVtyXS5sZW5ndGg7IGkyICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIG1vZEluZGV4ID0gaTIgKyBtb2RQb2x5LmdldExlbmd0aCgpIC0gZWNkYXRhW3JdLmxlbmd0aDtcbiAgICAgICAgICAgICAgZWNkYXRhW3JdW2kyXSA9IG1vZEluZGV4ID49IDAgPyBtb2RQb2x5LmdldEF0KG1vZEluZGV4KSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0b3RhbENvZGVDb3VudCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHJzQmxvY2tzLmxlbmd0aDsgaTIgKz0gMSkge1xuICAgICAgICAgICAgdG90YWxDb2RlQ291bnQgKz0gcnNCbG9ja3NbaTJdLnRvdGFsQ291bnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXRhID0gbmV3IEFycmF5KHRvdGFsQ29kZUNvdW50KTtcbiAgICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBtYXhEY0NvdW50OyBpMiArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHJzQmxvY2tzLmxlbmd0aDsgciArPSAxKSB7XG4gICAgICAgICAgICAgIGlmIChpMiA8IGRjZGF0YVtyXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkYXRhW2luZGV4XSA9IGRjZGF0YVtyXVtpMl07XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgbWF4RWNDb3VudDsgaTIgKz0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCByc0Jsb2Nrcy5sZW5ndGg7IHIgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAoaTIgPCBlY2RhdGFbcl0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtpbmRleF0gPSBlY2RhdGFbcl1baTJdO1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjcmVhdGVEYXRhID0gZnVuY3Rpb24odHlwZU51bWJlcjIsIGVycm9yQ29ycmVjdGlvbkxldmVsMiwgZGF0YUxpc3QpIHtcbiAgICAgICAgICB2YXIgcnNCbG9ja3MgPSBRUlJTQmxvY2suZ2V0UlNCbG9ja3ModHlwZU51bWJlcjIsIGVycm9yQ29ycmVjdGlvbkxldmVsMik7XG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IHFyQml0QnVmZmVyKCk7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGRhdGFMaXN0Lmxlbmd0aDsgaTIgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhTGlzdFtpMl07XG4gICAgICAgICAgICBidWZmZXIucHV0KGRhdGEuZ2V0TW9kZSgpLCA0KTtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXQoZGF0YS5nZXRMZW5ndGgoKSwgUVJVdGlsLmdldExlbmd0aEluQml0cyhkYXRhLmdldE1vZGUoKSwgdHlwZU51bWJlcjIpKTtcbiAgICAgICAgICAgIGRhdGEud3JpdGUoYnVmZmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRvdGFsRGF0YUNvdW50ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgcnNCbG9ja3MubGVuZ3RoOyBpMiArPSAxKSB7XG4gICAgICAgICAgICB0b3RhbERhdGFDb3VudCArPSByc0Jsb2Nrc1tpMl0uZGF0YUNvdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpID4gdG90YWxEYXRhQ291bnQgKiA4KSB7XG4gICAgICAgICAgICB0aHJvdyBcImNvZGUgbGVuZ3RoIG92ZXJmbG93LiAoXCIgKyBidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgKyBcIj5cIiArIHRvdGFsRGF0YUNvdW50ICogOCArIFwiKVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpICsgNCA8PSB0b3RhbERhdGFDb3VudCAqIDgpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXQoMCwgNCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgJSA4ICE9IDApIHtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXRCaXQoZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSA+PSB0b3RhbERhdGFDb3VudCAqIDgpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIucHV0KFBBRDAsIDgpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSA+PSB0b3RhbERhdGFDb3VudCAqIDgpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIucHV0KFBBRDEsIDgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY3JlYXRlQnl0ZXMoYnVmZmVyLCByc0Jsb2Nrcyk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmFkZERhdGEgPSBmdW5jdGlvbihkYXRhLCBtb2RlKSB7XG4gICAgICAgICAgbW9kZSA9IG1vZGUgfHwgXCJCeXRlXCI7XG4gICAgICAgICAgdmFyIG5ld0RhdGEgPSBudWxsO1xuICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgY2FzZSBcIk51bWVyaWNcIjpcbiAgICAgICAgICAgICAgbmV3RGF0YSA9IHFyTnVtYmVyKGRhdGEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBbHBoYW51bWVyaWNcIjpcbiAgICAgICAgICAgICAgbmV3RGF0YSA9IHFyQWxwaGFOdW0oZGF0YSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkJ5dGVcIjpcbiAgICAgICAgICAgICAgbmV3RGF0YSA9IHFyOEJpdEJ5dGUoZGF0YSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkthbmppXCI6XG4gICAgICAgICAgICAgIG5ld0RhdGEgPSBxckthbmppKGRhdGEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IFwibW9kZTpcIiArIG1vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9kYXRhTGlzdC5wdXNoKG5ld0RhdGEpO1xuICAgICAgICAgIF9kYXRhQ2FjaGUgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc0RhcmsgPSBmdW5jdGlvbihyb3csIGNvbCkge1xuICAgICAgICAgIGlmIChyb3cgPCAwIHx8IF9tb2R1bGVDb3VudCA8PSByb3cgfHwgY29sIDwgMCB8fCBfbW9kdWxlQ291bnQgPD0gY29sKSB7XG4gICAgICAgICAgICB0aHJvdyByb3cgKyBcIixcIiArIGNvbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9tb2R1bGVzW3Jvd11bY29sXTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0TW9kdWxlQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX21vZHVsZUNvdW50O1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5tYWtlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKF90eXBlTnVtYmVyIDwgMSkge1xuICAgICAgICAgICAgdmFyIHR5cGVOdW1iZXIyID0gMTtcbiAgICAgICAgICAgIGZvciAoOyB0eXBlTnVtYmVyMiA8IDQwOyB0eXBlTnVtYmVyMisrKSB7XG4gICAgICAgICAgICAgIHZhciByc0Jsb2NrcyA9IFFSUlNCbG9jay5nZXRSU0Jsb2Nrcyh0eXBlTnVtYmVyMiwgX2Vycm9yQ29ycmVjdGlvbkxldmVsKTtcbiAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IHFyQml0QnVmZmVyKCk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBfZGF0YUxpc3QubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfZGF0YUxpc3RbaTJdO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXQoZGF0YS5nZXRNb2RlKCksIDQpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXQoZGF0YS5nZXRMZW5ndGgoKSwgUVJVdGlsLmdldExlbmd0aEluQml0cyhkYXRhLmdldE1vZGUoKSwgdHlwZU51bWJlcjIpKTtcbiAgICAgICAgICAgICAgICBkYXRhLndyaXRlKGJ1ZmZlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHRvdGFsRGF0YUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHJzQmxvY2tzLmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgICAgICAgIHRvdGFsRGF0YUNvdW50ICs9IHJzQmxvY2tzW2kyXS5kYXRhQ291bnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSA8PSB0b3RhbERhdGFDb3VudCAqIDgpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3R5cGVOdW1iZXIgPSB0eXBlTnVtYmVyMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFrZUltcGwoZmFsc2UsIGdldEJlc3RNYXNrUGF0dGVybigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuY3JlYXRlVGFibGVUYWcgPSBmdW5jdGlvbihjZWxsU2l6ZSwgbWFyZ2luKSB7XG4gICAgICAgICAgY2VsbFNpemUgPSBjZWxsU2l6ZSB8fCAyO1xuICAgICAgICAgIG1hcmdpbiA9IHR5cGVvZiBtYXJnaW4gPT0gXCJ1bmRlZmluZWRcIiA/IGNlbGxTaXplICogNCA6IG1hcmdpbjtcbiAgICAgICAgICB2YXIgcXJIdG1sID0gXCJcIjtcbiAgICAgICAgICBxckh0bWwgKz0gJzx0YWJsZSBzdHlsZT1cIic7XG4gICAgICAgICAgcXJIdG1sICs9IFwiIGJvcmRlci13aWR0aDogMHB4OyBib3JkZXItc3R5bGU6IG5vbmU7XCI7XG4gICAgICAgICAgcXJIdG1sICs9IFwiIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XCI7XG4gICAgICAgICAgcXJIdG1sICs9IFwiIHBhZGRpbmc6IDBweDsgbWFyZ2luOiBcIiArIG1hcmdpbiArIFwicHg7XCI7XG4gICAgICAgICAgcXJIdG1sICs9ICdcIj4nO1xuICAgICAgICAgIHFySHRtbCArPSBcIjx0Ym9keT5cIjtcbiAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IF90aGlzLmdldE1vZHVsZUNvdW50KCk7IHIgKz0gMSkge1xuICAgICAgICAgICAgcXJIdG1sICs9IFwiPHRyPlwiO1xuICAgICAgICAgICAgZm9yICh2YXIgYzIgPSAwOyBjMiA8IF90aGlzLmdldE1vZHVsZUNvdW50KCk7IGMyICs9IDEpIHtcbiAgICAgICAgICAgICAgcXJIdG1sICs9ICc8dGQgc3R5bGU9XCInO1xuICAgICAgICAgICAgICBxckh0bWwgKz0gXCIgYm9yZGVyLXdpZHRoOiAwcHg7IGJvcmRlci1zdHlsZTogbm9uZTtcIjtcbiAgICAgICAgICAgICAgcXJIdG1sICs9IFwiIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XCI7XG4gICAgICAgICAgICAgIHFySHRtbCArPSBcIiBwYWRkaW5nOiAwcHg7IG1hcmdpbjogMHB4O1wiO1xuICAgICAgICAgICAgICBxckh0bWwgKz0gXCIgd2lkdGg6IFwiICsgY2VsbFNpemUgKyBcInB4O1wiO1xuICAgICAgICAgICAgICBxckh0bWwgKz0gXCIgaGVpZ2h0OiBcIiArIGNlbGxTaXplICsgXCJweDtcIjtcbiAgICAgICAgICAgICAgcXJIdG1sICs9IFwiIGJhY2tncm91bmQtY29sb3I6IFwiO1xuICAgICAgICAgICAgICBxckh0bWwgKz0gX3RoaXMuaXNEYXJrKHIsIGMyKSA/IFwiIzAwMDAwMFwiIDogXCIjZmZmZmZmXCI7XG4gICAgICAgICAgICAgIHFySHRtbCArPSBcIjtcIjtcbiAgICAgICAgICAgICAgcXJIdG1sICs9ICdcIi8+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHFySHRtbCArPSBcIjwvdHI+XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHFySHRtbCArPSBcIjwvdGJvZHk+XCI7XG4gICAgICAgICAgcXJIdG1sICs9IFwiPC90YWJsZT5cIjtcbiAgICAgICAgICByZXR1cm4gcXJIdG1sO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5jcmVhdGVTdmdUYWcgPSBmdW5jdGlvbihjZWxsU2l6ZSwgbWFyZ2luLCBhbHQsIHRpdGxlKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBvcHRzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgY2VsbFNpemUgPSBvcHRzLmNlbGxTaXplO1xuICAgICAgICAgICAgbWFyZ2luID0gb3B0cy5tYXJnaW47XG4gICAgICAgICAgICBhbHQgPSBvcHRzLmFsdDtcbiAgICAgICAgICAgIHRpdGxlID0gb3B0cy50aXRsZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2VsbFNpemUgPSBjZWxsU2l6ZSB8fCAyO1xuICAgICAgICAgIG1hcmdpbiA9IHR5cGVvZiBtYXJnaW4gPT0gXCJ1bmRlZmluZWRcIiA/IGNlbGxTaXplICogNCA6IG1hcmdpbjtcbiAgICAgICAgICBhbHQgPSB0eXBlb2YgYWx0ID09PSBcInN0cmluZ1wiID8geyB0ZXh0OiBhbHQgfSA6IGFsdCB8fCB7fTtcbiAgICAgICAgICBhbHQudGV4dCA9IGFsdC50ZXh0IHx8IG51bGw7XG4gICAgICAgICAgYWx0LmlkID0gYWx0LnRleHQgPyBhbHQuaWQgfHwgXCJxcmNvZGUtZGVzY3JpcHRpb25cIiA6IG51bGw7XG4gICAgICAgICAgdGl0bGUgPSB0eXBlb2YgdGl0bGUgPT09IFwic3RyaW5nXCIgPyB7IHRleHQ6IHRpdGxlIH0gOiB0aXRsZSB8fCB7fTtcbiAgICAgICAgICB0aXRsZS50ZXh0ID0gdGl0bGUudGV4dCB8fCBudWxsO1xuICAgICAgICAgIHRpdGxlLmlkID0gdGl0bGUudGV4dCA/IHRpdGxlLmlkIHx8IFwicXJjb2RlLXRpdGxlXCIgOiBudWxsO1xuICAgICAgICAgIHZhciBzaXplID0gX3RoaXMuZ2V0TW9kdWxlQ291bnQoKSAqIGNlbGxTaXplICsgbWFyZ2luICogMjtcbiAgICAgICAgICB2YXIgYzIsIG1jLCByLCBtciwgcXJTdmcgPSBcIlwiLCByZWN0O1xuICAgICAgICAgIHJlY3QgPSBcImxcIiArIGNlbGxTaXplICsgXCIsMCAwLFwiICsgY2VsbFNpemUgKyBcIiAtXCIgKyBjZWxsU2l6ZSArIFwiLDAgMCwtXCIgKyBjZWxsU2l6ZSArIFwieiBcIjtcbiAgICAgICAgICBxclN2ZyArPSAnPHN2ZyB2ZXJzaW9uPVwiMS4xXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiJztcbiAgICAgICAgICBxclN2ZyArPSAhb3B0cy5zY2FsYWJsZSA/ICcgd2lkdGg9XCInICsgc2l6ZSArICdweFwiIGhlaWdodD1cIicgKyBzaXplICsgJ3B4XCInIDogXCJcIjtcbiAgICAgICAgICBxclN2ZyArPSAnIHZpZXdCb3g9XCIwIDAgJyArIHNpemUgKyBcIiBcIiArIHNpemUgKyAnXCIgJztcbiAgICAgICAgICBxclN2ZyArPSAnIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWluWU1pbiBtZWV0XCInO1xuICAgICAgICAgIHFyU3ZnICs9IHRpdGxlLnRleHQgfHwgYWx0LnRleHQgPyAnIHJvbGU9XCJpbWdcIiBhcmlhLWxhYmVsbGVkYnk9XCInICsgZXNjYXBlWG1sKFt0aXRsZS5pZCwgYWx0LmlkXS5qb2luKFwiIFwiKS50cmltKCkpICsgJ1wiJyA6IFwiXCI7XG4gICAgICAgICAgcXJTdmcgKz0gXCI+XCI7XG4gICAgICAgICAgcXJTdmcgKz0gdGl0bGUudGV4dCA/ICc8dGl0bGUgaWQ9XCInICsgZXNjYXBlWG1sKHRpdGxlLmlkKSArICdcIj4nICsgZXNjYXBlWG1sKHRpdGxlLnRleHQpICsgXCI8L3RpdGxlPlwiIDogXCJcIjtcbiAgICAgICAgICBxclN2ZyArPSBhbHQudGV4dCA/ICc8ZGVzY3JpcHRpb24gaWQ9XCInICsgZXNjYXBlWG1sKGFsdC5pZCkgKyAnXCI+JyArIGVzY2FwZVhtbChhbHQudGV4dCkgKyBcIjwvZGVzY3JpcHRpb24+XCIgOiBcIlwiO1xuICAgICAgICAgIHFyU3ZnICs9ICc8cmVjdCB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCIgZmlsbD1cIndoaXRlXCIgY3g9XCIwXCIgY3k9XCIwXCIvPic7XG4gICAgICAgICAgcXJTdmcgKz0gJzxwYXRoIGQ9XCInO1xuICAgICAgICAgIGZvciAociA9IDA7IHIgPCBfdGhpcy5nZXRNb2R1bGVDb3VudCgpOyByICs9IDEpIHtcbiAgICAgICAgICAgIG1yID0gciAqIGNlbGxTaXplICsgbWFyZ2luO1xuICAgICAgICAgICAgZm9yIChjMiA9IDA7IGMyIDwgX3RoaXMuZ2V0TW9kdWxlQ291bnQoKTsgYzIgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNEYXJrKHIsIGMyKSkge1xuICAgICAgICAgICAgICAgIG1jID0gYzIgKiBjZWxsU2l6ZSArIG1hcmdpbjtcbiAgICAgICAgICAgICAgICBxclN2ZyArPSBcIk1cIiArIG1jICsgXCIsXCIgKyBtciArIHJlY3Q7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcXJTdmcgKz0gJ1wiIHN0cm9rZT1cInRyYW5zcGFyZW50XCIgZmlsbD1cImJsYWNrXCIvPic7XG4gICAgICAgICAgcXJTdmcgKz0gXCI8L3N2Zz5cIjtcbiAgICAgICAgICByZXR1cm4gcXJTdmc7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmNyZWF0ZURhdGFVUkwgPSBmdW5jdGlvbihjZWxsU2l6ZSwgbWFyZ2luKSB7XG4gICAgICAgICAgY2VsbFNpemUgPSBjZWxsU2l6ZSB8fCAyO1xuICAgICAgICAgIG1hcmdpbiA9IHR5cGVvZiBtYXJnaW4gPT0gXCJ1bmRlZmluZWRcIiA/IGNlbGxTaXplICogNCA6IG1hcmdpbjtcbiAgICAgICAgICB2YXIgc2l6ZSA9IF90aGlzLmdldE1vZHVsZUNvdW50KCkgKiBjZWxsU2l6ZSArIG1hcmdpbiAqIDI7XG4gICAgICAgICAgdmFyIG1pbjIgPSBtYXJnaW47XG4gICAgICAgICAgdmFyIG1heDIgPSBzaXplIC0gbWFyZ2luO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVEYXRhVVJMKHNpemUsIHNpemUsIGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgIGlmIChtaW4yIDw9IHggJiYgeCA8IG1heDIgJiYgbWluMiA8PSB5ICYmIHkgPCBtYXgyKSB7XG4gICAgICAgICAgICAgIHZhciBjMiA9IE1hdGguZmxvb3IoKHggLSBtaW4yKSAvIGNlbGxTaXplKTtcbiAgICAgICAgICAgICAgdmFyIHIgPSBNYXRoLmZsb29yKCh5IC0gbWluMikgLyBjZWxsU2l6ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5pc0RhcmsociwgYzIpID8gMCA6IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuY3JlYXRlSW1nVGFnID0gZnVuY3Rpb24oY2VsbFNpemUsIG1hcmdpbiwgYWx0KSB7XG4gICAgICAgICAgY2VsbFNpemUgPSBjZWxsU2l6ZSB8fCAyO1xuICAgICAgICAgIG1hcmdpbiA9IHR5cGVvZiBtYXJnaW4gPT0gXCJ1bmRlZmluZWRcIiA/IGNlbGxTaXplICogNCA6IG1hcmdpbjtcbiAgICAgICAgICB2YXIgc2l6ZSA9IF90aGlzLmdldE1vZHVsZUNvdW50KCkgKiBjZWxsU2l6ZSArIG1hcmdpbiAqIDI7XG4gICAgICAgICAgdmFyIGltZyA9IFwiXCI7XG4gICAgICAgICAgaW1nICs9IFwiPGltZ1wiO1xuICAgICAgICAgIGltZyArPSAnIHNyYz1cIic7XG4gICAgICAgICAgaW1nICs9IF90aGlzLmNyZWF0ZURhdGFVUkwoY2VsbFNpemUsIG1hcmdpbik7XG4gICAgICAgICAgaW1nICs9ICdcIic7XG4gICAgICAgICAgaW1nICs9ICcgd2lkdGg9XCInO1xuICAgICAgICAgIGltZyArPSBzaXplO1xuICAgICAgICAgIGltZyArPSAnXCInO1xuICAgICAgICAgIGltZyArPSAnIGhlaWdodD1cIic7XG4gICAgICAgICAgaW1nICs9IHNpemU7XG4gICAgICAgICAgaW1nICs9ICdcIic7XG4gICAgICAgICAgaWYgKGFsdCkge1xuICAgICAgICAgICAgaW1nICs9ICcgYWx0PVwiJztcbiAgICAgICAgICAgIGltZyArPSBlc2NhcGVYbWwoYWx0KTtcbiAgICAgICAgICAgIGltZyArPSAnXCInO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbWcgKz0gXCIvPlwiO1xuICAgICAgICAgIHJldHVybiBpbWc7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBlc2NhcGVYbWwgPSBmdW5jdGlvbihzMikge1xuICAgICAgICAgIHZhciBlc2NhcGVkID0gXCJcIjtcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgczIubGVuZ3RoOyBpMiArPSAxKSB7XG4gICAgICAgICAgICB2YXIgYzIgPSBzMi5jaGFyQXQoaTIpO1xuICAgICAgICAgICAgc3dpdGNoIChjMikge1xuICAgICAgICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgICAgICAgIGVzY2FwZWQgKz0gXCImbHQ7XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgICAgICAgICAgZXNjYXBlZCArPSBcIiZndDtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIiZcIjpcbiAgICAgICAgICAgICAgICBlc2NhcGVkICs9IFwiJmFtcDtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgICAgIGVzY2FwZWQgKz0gXCImcXVvdDtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBlc2NhcGVkICs9IGMyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZXNjYXBlZDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9jcmVhdGVIYWxmQVNDSUkgPSBmdW5jdGlvbihtYXJnaW4pIHtcbiAgICAgICAgICB2YXIgY2VsbFNpemUgPSAxO1xuICAgICAgICAgIG1hcmdpbiA9IHR5cGVvZiBtYXJnaW4gPT0gXCJ1bmRlZmluZWRcIiA/IGNlbGxTaXplICogMiA6IG1hcmdpbjtcbiAgICAgICAgICB2YXIgc2l6ZSA9IF90aGlzLmdldE1vZHVsZUNvdW50KCkgKiBjZWxsU2l6ZSArIG1hcmdpbiAqIDI7XG4gICAgICAgICAgdmFyIG1pbjIgPSBtYXJnaW47XG4gICAgICAgICAgdmFyIG1heDIgPSBzaXplIC0gbWFyZ2luO1xuICAgICAgICAgIHZhciB5LCB4LCByMSwgcjIsIHAyO1xuICAgICAgICAgIHZhciBibG9ja3MgPSB7XG4gICAgICAgICAgICBcIuKWiOKWiFwiOiBcIuKWiFwiLFxuICAgICAgICAgICAgXCLiloggXCI6IFwi4paAXCIsXG4gICAgICAgICAgICBcIiDilohcIjogXCLiloRcIixcbiAgICAgICAgICAgIFwiICBcIjogXCIgXCJcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBibG9ja3NMYXN0TGluZU5vTWFyZ2luID0ge1xuICAgICAgICAgICAgXCLilojilohcIjogXCLiloBcIixcbiAgICAgICAgICAgIFwi4paIIFwiOiBcIuKWgFwiLFxuICAgICAgICAgICAgXCIg4paIXCI6IFwiIFwiLFxuICAgICAgICAgICAgXCIgIFwiOiBcIiBcIlxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGFzY2lpID0gXCJcIjtcbiAgICAgICAgICBmb3IgKHkgPSAwOyB5IDwgc2l6ZTsgeSArPSAyKSB7XG4gICAgICAgICAgICByMSA9IE1hdGguZmxvb3IoKHkgLSBtaW4yKSAvIGNlbGxTaXplKTtcbiAgICAgICAgICAgIHIyID0gTWF0aC5mbG9vcigoeSArIDEgLSBtaW4yKSAvIGNlbGxTaXplKTtcbiAgICAgICAgICAgIGZvciAoeCA9IDA7IHggPCBzaXplOyB4ICs9IDEpIHtcbiAgICAgICAgICAgICAgcDIgPSBcIuKWiFwiO1xuICAgICAgICAgICAgICBpZiAobWluMiA8PSB4ICYmIHggPCBtYXgyICYmIG1pbjIgPD0geSAmJiB5IDwgbWF4MiAmJiBfdGhpcy5pc0RhcmsocjEsIE1hdGguZmxvb3IoKHggLSBtaW4yKSAvIGNlbGxTaXplKSkpIHtcbiAgICAgICAgICAgICAgICBwMiA9IFwiIFwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtaW4yIDw9IHggJiYgeCA8IG1heDIgJiYgbWluMiA8PSB5ICsgMSAmJiB5ICsgMSA8IG1heDIgJiYgX3RoaXMuaXNEYXJrKHIyLCBNYXRoLmZsb29yKCh4IC0gbWluMikgLyBjZWxsU2l6ZSkpKSB7XG4gICAgICAgICAgICAgICAgcDIgKz0gXCIgXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcDIgKz0gXCLilohcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhc2NpaSArPSBtYXJnaW4gPCAxICYmIHkgKyAxID49IG1heDIgPyBibG9ja3NMYXN0TGluZU5vTWFyZ2luW3AyXSA6IGJsb2Nrc1twMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc2NpaSArPSBcIlxcblwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2l6ZSAlIDIgJiYgbWFyZ2luID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzY2lpLnN1YnN0cmluZygwLCBhc2NpaS5sZW5ndGggLSBzaXplIC0gMSkgKyBBcnJheShzaXplICsgMSkuam9pbihcIuKWgFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFzY2lpLnN1YnN0cmluZygwLCBhc2NpaS5sZW5ndGggLSAxKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuY3JlYXRlQVNDSUkgPSBmdW5jdGlvbihjZWxsU2l6ZSwgbWFyZ2luKSB7XG4gICAgICAgICAgY2VsbFNpemUgPSBjZWxsU2l6ZSB8fCAxO1xuICAgICAgICAgIGlmIChjZWxsU2l6ZSA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlSGFsZkFTQ0lJKG1hcmdpbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNlbGxTaXplIC09IDE7XG4gICAgICAgICAgbWFyZ2luID0gdHlwZW9mIG1hcmdpbiA9PSBcInVuZGVmaW5lZFwiID8gY2VsbFNpemUgKiAyIDogbWFyZ2luO1xuICAgICAgICAgIHZhciBzaXplID0gX3RoaXMuZ2V0TW9kdWxlQ291bnQoKSAqIGNlbGxTaXplICsgbWFyZ2luICogMjtcbiAgICAgICAgICB2YXIgbWluMiA9IG1hcmdpbjtcbiAgICAgICAgICB2YXIgbWF4MiA9IHNpemUgLSBtYXJnaW47XG4gICAgICAgICAgdmFyIHksIHgsIHIsIHAyO1xuICAgICAgICAgIHZhciB3aGl0ZSA9IEFycmF5KGNlbGxTaXplICsgMSkuam9pbihcIuKWiOKWiFwiKTtcbiAgICAgICAgICB2YXIgYmxhY2sgPSBBcnJheShjZWxsU2l6ZSArIDEpLmpvaW4oXCIgIFwiKTtcbiAgICAgICAgICB2YXIgYXNjaWkgPSBcIlwiO1xuICAgICAgICAgIHZhciBsaW5lID0gXCJcIjtcbiAgICAgICAgICBmb3IgKHkgPSAwOyB5IDwgc2l6ZTsgeSArPSAxKSB7XG4gICAgICAgICAgICByID0gTWF0aC5mbG9vcigoeSAtIG1pbjIpIC8gY2VsbFNpemUpO1xuICAgICAgICAgICAgbGluZSA9IFwiXCI7XG4gICAgICAgICAgICBmb3IgKHggPSAwOyB4IDwgc2l6ZTsgeCArPSAxKSB7XG4gICAgICAgICAgICAgIHAyID0gMTtcbiAgICAgICAgICAgICAgaWYgKG1pbjIgPD0geCAmJiB4IDwgbWF4MiAmJiBtaW4yIDw9IHkgJiYgeSA8IG1heDIgJiYgX3RoaXMuaXNEYXJrKHIsIE1hdGguZmxvb3IoKHggLSBtaW4yKSAvIGNlbGxTaXplKSkpIHtcbiAgICAgICAgICAgICAgICBwMiA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGluZSArPSBwMiA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHIgPSAwOyByIDwgY2VsbFNpemU7IHIgKz0gMSkge1xuICAgICAgICAgICAgICBhc2NpaSArPSBsaW5lICsgXCJcXG5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFzY2lpLnN1YnN0cmluZygwLCBhc2NpaS5sZW5ndGggLSAxKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyVG8yZENvbnRleHQgPSBmdW5jdGlvbihjb250ZXh0LCBjZWxsU2l6ZSkge1xuICAgICAgICAgIGNlbGxTaXplID0gY2VsbFNpemUgfHwgMjtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gX3RoaXMuZ2V0TW9kdWxlQ291bnQoKTtcbiAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBsZW5ndGg7IHJvdysrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBsZW5ndGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gX3RoaXMuaXNEYXJrKHJvdywgY29sKSA/IFwiYmxhY2tcIiA6IFwid2hpdGVcIjtcbiAgICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdChyb3cgKiBjZWxsU2l6ZSwgY29sICogY2VsbFNpemUsIGNlbGxTaXplLCBjZWxsU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9O1xuICAgICAgcXJjb2RlMy5zdHJpbmdUb0J5dGVzRnVuY3MgPSB7XG4gICAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbihzMikge1xuICAgICAgICAgIHZhciBieXRlcyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBzMi5sZW5ndGg7IGkyICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBjMiA9IHMyLmNoYXJDb2RlQXQoaTIpO1xuICAgICAgICAgICAgYnl0ZXMucHVzaChjMiAmIDI1NSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBieXRlcztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHFyY29kZTMuc3RyaW5nVG9CeXRlcyA9IHFyY29kZTMuc3RyaW5nVG9CeXRlc0Z1bmNzW1wiZGVmYXVsdFwiXTtcbiAgICAgIHFyY29kZTMuY3JlYXRlU3RyaW5nVG9CeXRlcyA9IGZ1bmN0aW9uKHVuaWNvZGVEYXRhLCBudW1DaGFycykge1xuICAgICAgICB2YXIgdW5pY29kZU1hcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBiaW4gPSBiYXNlNjREZWNvZGVJbnB1dFN0cmVhbSh1bmljb2RlRGF0YSk7XG4gICAgICAgICAgdmFyIHJlYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBiID0gYmluLnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChiID09IC0xKSB0aHJvdyBcImVvZlwiO1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgIHZhciB1bmljb2RlTWFwMiA9IHt9O1xuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgYjAgPSBiaW4ucmVhZCgpO1xuICAgICAgICAgICAgaWYgKGIwID09IC0xKSBicmVhaztcbiAgICAgICAgICAgIHZhciBiMSA9IHJlYWQoKTtcbiAgICAgICAgICAgIHZhciBiMiA9IHJlYWQoKTtcbiAgICAgICAgICAgIHZhciBiMyA9IHJlYWQoKTtcbiAgICAgICAgICAgIHZhciBrID0gU3RyaW5nLmZyb21DaGFyQ29kZShiMCA8PCA4IHwgYjEpO1xuICAgICAgICAgICAgdmFyIHYgPSBiMiA8PCA4IHwgYjM7XG4gICAgICAgICAgICB1bmljb2RlTWFwMltrXSA9IHY7XG4gICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY291bnQgIT0gbnVtQ2hhcnMpIHtcbiAgICAgICAgICAgIHRocm93IGNvdW50ICsgXCIgIT0gXCIgKyBudW1DaGFycztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHVuaWNvZGVNYXAyO1xuICAgICAgICB9KCk7XG4gICAgICAgIHZhciB1bmtub3duQ2hhciA9IFwiP1wiLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzMikge1xuICAgICAgICAgIHZhciBieXRlcyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBzMi5sZW5ndGg7IGkyICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBjMiA9IHMyLmNoYXJDb2RlQXQoaTIpO1xuICAgICAgICAgICAgaWYgKGMyIDwgMTI4KSB7XG4gICAgICAgICAgICAgIGJ5dGVzLnB1c2goYzIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGIgPSB1bmljb2RlTWFwW3MyLmNoYXJBdChpMildO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGIgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGlmICgoYiAmIDI1NSkgPT0gYikge1xuICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaChiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaChiID4+PiA4KTtcbiAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goYiAmIDI1NSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2godW5rbm93bkNoYXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBieXRlcztcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICB2YXIgUVJNb2RlID0ge1xuICAgICAgICBNT0RFX05VTUJFUjogMSA8PCAwLFxuICAgICAgICBNT0RFX0FMUEhBX05VTTogMSA8PCAxLFxuICAgICAgICBNT0RFXzhCSVRfQllURTogMSA8PCAyLFxuICAgICAgICBNT0RFX0tBTkpJOiAxIDw8IDNcbiAgICAgIH07XG4gICAgICB2YXIgUVJFcnJvckNvcnJlY3Rpb25MZXZlbCA9IHtcbiAgICAgICAgTDogMSxcbiAgICAgICAgTTogMCxcbiAgICAgICAgUTogMyxcbiAgICAgICAgSDogMlxuICAgICAgfTtcbiAgICAgIHZhciBRUk1hc2tQYXR0ZXJuID0ge1xuICAgICAgICBQQVRURVJOMDAwOiAwLFxuICAgICAgICBQQVRURVJOMDAxOiAxLFxuICAgICAgICBQQVRURVJOMDEwOiAyLFxuICAgICAgICBQQVRURVJOMDExOiAzLFxuICAgICAgICBQQVRURVJOMTAwOiA0LFxuICAgICAgICBQQVRURVJOMTAxOiA1LFxuICAgICAgICBQQVRURVJOMTEwOiA2LFxuICAgICAgICBQQVRURVJOMTExOiA3XG4gICAgICB9O1xuICAgICAgdmFyIFFSVXRpbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgUEFUVEVSTl9QT1NJVElPTl9UQUJMRSA9IFtcbiAgICAgICAgICBbXSxcbiAgICAgICAgICBbNiwgMThdLFxuICAgICAgICAgIFs2LCAyMl0sXG4gICAgICAgICAgWzYsIDI2XSxcbiAgICAgICAgICBbNiwgMzBdLFxuICAgICAgICAgIFs2LCAzNF0sXG4gICAgICAgICAgWzYsIDIyLCAzOF0sXG4gICAgICAgICAgWzYsIDI0LCA0Ml0sXG4gICAgICAgICAgWzYsIDI2LCA0Nl0sXG4gICAgICAgICAgWzYsIDI4LCA1MF0sXG4gICAgICAgICAgWzYsIDMwLCA1NF0sXG4gICAgICAgICAgWzYsIDMyLCA1OF0sXG4gICAgICAgICAgWzYsIDM0LCA2Ml0sXG4gICAgICAgICAgWzYsIDI2LCA0NiwgNjZdLFxuICAgICAgICAgIFs2LCAyNiwgNDgsIDcwXSxcbiAgICAgICAgICBbNiwgMjYsIDUwLCA3NF0sXG4gICAgICAgICAgWzYsIDMwLCA1NCwgNzhdLFxuICAgICAgICAgIFs2LCAzMCwgNTYsIDgyXSxcbiAgICAgICAgICBbNiwgMzAsIDU4LCA4Nl0sXG4gICAgICAgICAgWzYsIDM0LCA2MiwgOTBdLFxuICAgICAgICAgIFs2LCAyOCwgNTAsIDcyLCA5NF0sXG4gICAgICAgICAgWzYsIDI2LCA1MCwgNzQsIDk4XSxcbiAgICAgICAgICBbNiwgMzAsIDU0LCA3OCwgMTAyXSxcbiAgICAgICAgICBbNiwgMjgsIDU0LCA4MCwgMTA2XSxcbiAgICAgICAgICBbNiwgMzIsIDU4LCA4NCwgMTEwXSxcbiAgICAgICAgICBbNiwgMzAsIDU4LCA4NiwgMTE0XSxcbiAgICAgICAgICBbNiwgMzQsIDYyLCA5MCwgMTE4XSxcbiAgICAgICAgICBbNiwgMjYsIDUwLCA3NCwgOTgsIDEyMl0sXG4gICAgICAgICAgWzYsIDMwLCA1NCwgNzgsIDEwMiwgMTI2XSxcbiAgICAgICAgICBbNiwgMjYsIDUyLCA3OCwgMTA0LCAxMzBdLFxuICAgICAgICAgIFs2LCAzMCwgNTYsIDgyLCAxMDgsIDEzNF0sXG4gICAgICAgICAgWzYsIDM0LCA2MCwgODYsIDExMiwgMTM4XSxcbiAgICAgICAgICBbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDJdLFxuICAgICAgICAgIFs2LCAzNCwgNjIsIDkwLCAxMTgsIDE0Nl0sXG4gICAgICAgICAgWzYsIDMwLCA1NCwgNzgsIDEwMiwgMTI2LCAxNTBdLFxuICAgICAgICAgIFs2LCAyNCwgNTAsIDc2LCAxMDIsIDEyOCwgMTU0XSxcbiAgICAgICAgICBbNiwgMjgsIDU0LCA4MCwgMTA2LCAxMzIsIDE1OF0sXG4gICAgICAgICAgWzYsIDMyLCA1OCwgODQsIDExMCwgMTM2LCAxNjJdLFxuICAgICAgICAgIFs2LCAyNiwgNTQsIDgyLCAxMTAsIDEzOCwgMTY2XSxcbiAgICAgICAgICBbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDIsIDE3MF1cbiAgICAgICAgXTtcbiAgICAgICAgdmFyIEcxNSA9IDEgPDwgMTAgfCAxIDw8IDggfCAxIDw8IDUgfCAxIDw8IDQgfCAxIDw8IDIgfCAxIDw8IDEgfCAxIDw8IDA7XG4gICAgICAgIHZhciBHMTggPSAxIDw8IDEyIHwgMSA8PCAxMSB8IDEgPDwgMTAgfCAxIDw8IDkgfCAxIDw8IDggfCAxIDw8IDUgfCAxIDw8IDIgfCAxIDw8IDA7XG4gICAgICAgIHZhciBHMTVfTUFTSyA9IDEgPDwgMTQgfCAxIDw8IDEyIHwgMSA8PCAxMCB8IDEgPDwgNCB8IDEgPDwgMTtcbiAgICAgICAgdmFyIF90aGlzID0ge307XG4gICAgICAgIHZhciBnZXRCQ0hEaWdpdCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICB2YXIgZGlnaXQgPSAwO1xuICAgICAgICAgIHdoaWxlIChkYXRhICE9IDApIHtcbiAgICAgICAgICAgIGRpZ2l0ICs9IDE7XG4gICAgICAgICAgICBkYXRhID4+Pj0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRpZ2l0O1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRCQ0hUeXBlSW5mbyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICB2YXIgZCA9IGRhdGEgPDwgMTA7XG4gICAgICAgICAgd2hpbGUgKGdldEJDSERpZ2l0KGQpIC0gZ2V0QkNIRGlnaXQoRzE1KSA+PSAwKSB7XG4gICAgICAgICAgICBkIF49IEcxNSA8PCBnZXRCQ0hEaWdpdChkKSAtIGdldEJDSERpZ2l0KEcxNSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAoZGF0YSA8PCAxMCB8IGQpIF4gRzE1X01BU0s7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldEJDSFR5cGVOdW1iZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgdmFyIGQgPSBkYXRhIDw8IDEyO1xuICAgICAgICAgIHdoaWxlIChnZXRCQ0hEaWdpdChkKSAtIGdldEJDSERpZ2l0KEcxOCkgPj0gMCkge1xuICAgICAgICAgICAgZCBePSBHMTggPDwgZ2V0QkNIRGlnaXQoZCkgLSBnZXRCQ0hEaWdpdChHMTgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGF0YSA8PCAxMiB8IGQ7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldFBhdHRlcm5Qb3NpdGlvbiA9IGZ1bmN0aW9uKHR5cGVOdW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gUEFUVEVSTl9QT1NJVElPTl9UQUJMRVt0eXBlTnVtYmVyIC0gMV07XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldE1hc2tGdW5jdGlvbiA9IGZ1bmN0aW9uKG1hc2tQYXR0ZXJuKSB7XG4gICAgICAgICAgc3dpdGNoIChtYXNrUGF0dGVybikge1xuICAgICAgICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4wMDA6XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihpMiwgaikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaTIgKyBqKSAlIDIgPT0gMDtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMDAxOlxuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oaTIsIGopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTIgJSAyID09IDA7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjAxMDpcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGkyLCBqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGogJSAzID09IDA7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjAxMTpcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGkyLCBqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpMiArIGopICUgMyA9PSAwO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4xMDA6XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihpMiwgaikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoTWF0aC5mbG9vcihpMiAvIDIpICsgTWF0aC5mbG9vcihqIC8gMykpICUgMiA9PSAwO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4xMDE6XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihpMiwgaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpMiAqIGogJSAyICsgaTIgKiBqICUgMyA9PSAwO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4xMTA6XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihpMiwgaikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaTIgKiBqICUgMiArIGkyICogaiAlIDMpICUgMiA9PSAwO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4xMTE6XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihpMiwgaikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaTIgKiBqICUgMyArIChpMiArIGopICUgMikgJSAyID09IDA7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBcImJhZCBtYXNrUGF0dGVybjpcIiArIG1hc2tQYXR0ZXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0RXJyb3JDb3JyZWN0UG9seW5vbWlhbCA9IGZ1bmN0aW9uKGVycm9yQ29ycmVjdExlbmd0aCkge1xuICAgICAgICAgIHZhciBhMiA9IHFyUG9seW5vbWlhbChbMV0sIDApO1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBlcnJvckNvcnJlY3RMZW5ndGg7IGkyICs9IDEpIHtcbiAgICAgICAgICAgIGEyID0gYTIubXVsdGlwbHkocXJQb2x5bm9taWFsKFsxLCBRUk1hdGguZ2V4cChpMildLCAwKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhMjtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0TGVuZ3RoSW5CaXRzID0gZnVuY3Rpb24obW9kZSwgdHlwZSkge1xuICAgICAgICAgIGlmICgxIDw9IHR5cGUgJiYgdHlwZSA8IDEwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9OVU1CRVI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEwO1xuICAgICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX0FMUEhBX05VTTpcbiAgICAgICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV84QklUX0JZVEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfS0FOSkk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJtb2RlOlwiICsgbW9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPCAyNykge1xuICAgICAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfTlVNQkVSOlxuICAgICAgICAgICAgICAgIHJldHVybiAxMjtcbiAgICAgICAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9BTFBIQV9OVU06XG4gICAgICAgICAgICAgICAgcmV0dXJuIDExO1xuICAgICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFXzhCSVRfQllURTpcbiAgICAgICAgICAgICAgICByZXR1cm4gMTY7XG4gICAgICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfS0FOSkk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEwO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IFwibW9kZTpcIiArIG1vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlIDwgNDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX05VTUJFUjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMTQ7XG4gICAgICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfQUxQSEFfTlVNOlxuICAgICAgICAgICAgICAgIHJldHVybiAxMztcbiAgICAgICAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV84QklUX0JZVEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE2O1xuICAgICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX0tBTkpJOlxuICAgICAgICAgICAgICAgIHJldHVybiAxMjtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBcIm1vZGU6XCIgKyBtb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBcInR5cGU6XCIgKyB0eXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0TG9zdFBvaW50ID0gZnVuY3Rpb24ocXJjb2RlNCkge1xuICAgICAgICAgIHZhciBtb2R1bGVDb3VudCA9IHFyY29kZTQuZ2V0TW9kdWxlQ291bnQoKTtcbiAgICAgICAgICB2YXIgbG9zdFBvaW50ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudDsgcm93ICs9IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50OyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgc2FtZUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGRhcmsgPSBxcmNvZGU0LmlzRGFyayhyb3csIGNvbCk7XG4gICAgICAgICAgICAgIGZvciAodmFyIHIgPSAtMTsgciA8PSAxOyByICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAocm93ICsgciA8IDAgfHwgbW9kdWxlQ291bnQgPD0gcm93ICsgcikge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGMyID0gLTE7IGMyIDw9IDE7IGMyICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjb2wgKyBjMiA8IDAgfHwgbW9kdWxlQ291bnQgPD0gY29sICsgYzIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAociA9PSAwICYmIGMyID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoZGFyayA9PSBxcmNvZGU0LmlzRGFyayhyb3cgKyByLCBjb2wgKyBjMikpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtZUNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzYW1lQ291bnQgPiA1KSB7XG4gICAgICAgICAgICAgICAgbG9zdFBvaW50ICs9IDMgKyBzYW1lQ291bnQgLSA1O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vZHVsZUNvdW50IC0gMTsgcm93ICs9IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50IC0gMTsgY29sICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgaWYgKHFyY29kZTQuaXNEYXJrKHJvdywgY29sKSkgY291bnQgKz0gMTtcbiAgICAgICAgICAgICAgaWYgKHFyY29kZTQuaXNEYXJrKHJvdyArIDEsIGNvbCkpIGNvdW50ICs9IDE7XG4gICAgICAgICAgICAgIGlmIChxcmNvZGU0LmlzRGFyayhyb3csIGNvbCArIDEpKSBjb3VudCArPSAxO1xuICAgICAgICAgICAgICBpZiAocXJjb2RlNC5pc0Rhcmsocm93ICsgMSwgY29sICsgMSkpIGNvdW50ICs9IDE7XG4gICAgICAgICAgICAgIGlmIChjb3VudCA9PSAwIHx8IGNvdW50ID09IDQpIHtcbiAgICAgICAgICAgICAgICBsb3N0UG9pbnQgKz0gMztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudDsgcm93ICs9IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50IC0gNjsgY29sICs9IDEpIHtcbiAgICAgICAgICAgICAgaWYgKHFyY29kZTQuaXNEYXJrKHJvdywgY29sKSAmJiAhcXJjb2RlNC5pc0Rhcmsocm93LCBjb2wgKyAxKSAmJiBxcmNvZGU0LmlzRGFyayhyb3csIGNvbCArIDIpICYmIHFyY29kZTQuaXNEYXJrKHJvdywgY29sICsgMykgJiYgcXJjb2RlNC5pc0Rhcmsocm93LCBjb2wgKyA0KSAmJiAhcXJjb2RlNC5pc0Rhcmsocm93LCBjb2wgKyA1KSAmJiBxcmNvZGU0LmlzRGFyayhyb3csIGNvbCArIDYpKSB7XG4gICAgICAgICAgICAgICAgbG9zdFBvaW50ICs9IDQwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50OyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQgLSA2OyByb3cgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAocXJjb2RlNC5pc0Rhcmsocm93LCBjb2wpICYmICFxcmNvZGU0LmlzRGFyayhyb3cgKyAxLCBjb2wpICYmIHFyY29kZTQuaXNEYXJrKHJvdyArIDIsIGNvbCkgJiYgcXJjb2RlNC5pc0Rhcmsocm93ICsgMywgY29sKSAmJiBxcmNvZGU0LmlzRGFyayhyb3cgKyA0LCBjb2wpICYmICFxcmNvZGU0LmlzRGFyayhyb3cgKyA1LCBjb2wpICYmIHFyY29kZTQuaXNEYXJrKHJvdyArIDYsIGNvbCkpIHtcbiAgICAgICAgICAgICAgICBsb3N0UG9pbnQgKz0gNDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRhcmtDb3VudCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudDsgcm93ICs9IDEpIHtcbiAgICAgICAgICAgICAgaWYgKHFyY29kZTQuaXNEYXJrKHJvdywgY29sKSkge1xuICAgICAgICAgICAgICAgIGRhcmtDb3VudCArPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByYXRpbyA9IE1hdGguYWJzKDEwMCAqIGRhcmtDb3VudCAvIG1vZHVsZUNvdW50IC8gbW9kdWxlQ291bnQgLSA1MCkgLyA1O1xuICAgICAgICAgIGxvc3RQb2ludCArPSByYXRpbyAqIDEwO1xuICAgICAgICAgIHJldHVybiBsb3N0UG9pbnQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH0oKTtcbiAgICAgIHZhciBRUk1hdGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIEVYUF9UQUJMRSA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgICB2YXIgTE9HX1RBQkxFID0gbmV3IEFycmF5KDI1Nik7XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCA4OyBpMiArPSAxKSB7XG4gICAgICAgICAgRVhQX1RBQkxFW2kyXSA9IDEgPDwgaTI7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaTIgPSA4OyBpMiA8IDI1NjsgaTIgKz0gMSkge1xuICAgICAgICAgIEVYUF9UQUJMRVtpMl0gPSBFWFBfVEFCTEVbaTIgLSA0XSBeIEVYUF9UQUJMRVtpMiAtIDVdIF4gRVhQX1RBQkxFW2kyIC0gNl0gXiBFWFBfVEFCTEVbaTIgLSA4XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgMjU1OyBpMiArPSAxKSB7XG4gICAgICAgICAgTE9HX1RBQkxFW0VYUF9UQUJMRVtpMl1dID0gaTI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF90aGlzID0ge307XG4gICAgICAgIF90aGlzLmdsb2cgPSBmdW5jdGlvbihuMikge1xuICAgICAgICAgIGlmIChuMiA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IFwiZ2xvZyhcIiArIG4yICsgXCIpXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBMT0dfVEFCTEVbbjJdO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXhwID0gZnVuY3Rpb24objIpIHtcbiAgICAgICAgICB3aGlsZSAobjIgPCAwKSB7XG4gICAgICAgICAgICBuMiArPSAyNTU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChuMiA+PSAyNTYpIHtcbiAgICAgICAgICAgIG4yIC09IDI1NTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIEVYUF9UQUJMRVtuMl07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH0oKTtcbiAgICAgIGZ1bmN0aW9uIHFyUG9seW5vbWlhbChudW0sIHNoaWZ0Mikge1xuICAgICAgICBpZiAodHlwZW9mIG51bS5sZW5ndGggPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHRocm93IG51bS5sZW5ndGggKyBcIi9cIiArIHNoaWZ0MjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX251bSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBudW0ubGVuZ3RoICYmIG51bVtvZmZzZXRdID09IDApIHtcbiAgICAgICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgX251bTIgPSBuZXcgQXJyYXkobnVtLmxlbmd0aCAtIG9mZnNldCArIHNoaWZ0Mik7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IG51bS5sZW5ndGggLSBvZmZzZXQ7IGkyICs9IDEpIHtcbiAgICAgICAgICAgIF9udW0yW2kyXSA9IG51bVtpMiArIG9mZnNldF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfbnVtMjtcbiAgICAgICAgfSgpO1xuICAgICAgICB2YXIgX3RoaXMgPSB7fTtcbiAgICAgICAgX3RoaXMuZ2V0QXQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgIHJldHVybiBfbnVtW2luZGV4XTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF9udW0ubGVuZ3RoO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5tdWx0aXBseSA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgdmFyIG51bTIgPSBuZXcgQXJyYXkoX3RoaXMuZ2V0TGVuZ3RoKCkgKyBlMi5nZXRMZW5ndGgoKSAtIDEpO1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBfdGhpcy5nZXRMZW5ndGgoKTsgaTIgKz0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlMi5nZXRMZW5ndGgoKTsgaiArPSAxKSB7XG4gICAgICAgICAgICAgIG51bTJbaTIgKyBqXSBePSBRUk1hdGguZ2V4cChRUk1hdGguZ2xvZyhfdGhpcy5nZXRBdChpMikpICsgUVJNYXRoLmdsb2coZTIuZ2V0QXQoaikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHFyUG9seW5vbWlhbChudW0yLCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMubW9kID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICBpZiAoX3RoaXMuZ2V0TGVuZ3RoKCkgLSBlMi5nZXRMZW5ndGgoKSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJhdGlvID0gUVJNYXRoLmdsb2coX3RoaXMuZ2V0QXQoMCkpIC0gUVJNYXRoLmdsb2coZTIuZ2V0QXQoMCkpO1xuICAgICAgICAgIHZhciBudW0yID0gbmV3IEFycmF5KF90aGlzLmdldExlbmd0aCgpKTtcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgX3RoaXMuZ2V0TGVuZ3RoKCk7IGkyICs9IDEpIHtcbiAgICAgICAgICAgIG51bTJbaTJdID0gX3RoaXMuZ2V0QXQoaTIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgZTIuZ2V0TGVuZ3RoKCk7IGkyICs9IDEpIHtcbiAgICAgICAgICAgIG51bTJbaTJdIF49IFFSTWF0aC5nZXhwKFFSTWF0aC5nbG9nKGUyLmdldEF0KGkyKSkgKyByYXRpbyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBxclBvbHlub21pYWwobnVtMiwgMCkubW9kKGUyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfVxuICAgICAgdmFyIFFSUlNCbG9jayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgUlNfQkxPQ0tfVEFCTEUgPSBbXG4gICAgICAgICAgLy8gTFxuICAgICAgICAgIC8vIE1cbiAgICAgICAgICAvLyBRXG4gICAgICAgICAgLy8gSFxuICAgICAgICAgIC8vIDFcbiAgICAgICAgICBbMSwgMjYsIDE5XSxcbiAgICAgICAgICBbMSwgMjYsIDE2XSxcbiAgICAgICAgICBbMSwgMjYsIDEzXSxcbiAgICAgICAgICBbMSwgMjYsIDldLFxuICAgICAgICAgIC8vIDJcbiAgICAgICAgICBbMSwgNDQsIDM0XSxcbiAgICAgICAgICBbMSwgNDQsIDI4XSxcbiAgICAgICAgICBbMSwgNDQsIDIyXSxcbiAgICAgICAgICBbMSwgNDQsIDE2XSxcbiAgICAgICAgICAvLyAzXG4gICAgICAgICAgWzEsIDcwLCA1NV0sXG4gICAgICAgICAgWzEsIDcwLCA0NF0sXG4gICAgICAgICAgWzIsIDM1LCAxN10sXG4gICAgICAgICAgWzIsIDM1LCAxM10sXG4gICAgICAgICAgLy8gNFxuICAgICAgICAgIFsxLCAxMDAsIDgwXSxcbiAgICAgICAgICBbMiwgNTAsIDMyXSxcbiAgICAgICAgICBbMiwgNTAsIDI0XSxcbiAgICAgICAgICBbNCwgMjUsIDldLFxuICAgICAgICAgIC8vIDVcbiAgICAgICAgICBbMSwgMTM0LCAxMDhdLFxuICAgICAgICAgIFsyLCA2NywgNDNdLFxuICAgICAgICAgIFsyLCAzMywgMTUsIDIsIDM0LCAxNl0sXG4gICAgICAgICAgWzIsIDMzLCAxMSwgMiwgMzQsIDEyXSxcbiAgICAgICAgICAvLyA2XG4gICAgICAgICAgWzIsIDg2LCA2OF0sXG4gICAgICAgICAgWzQsIDQzLCAyN10sXG4gICAgICAgICAgWzQsIDQzLCAxOV0sXG4gICAgICAgICAgWzQsIDQzLCAxNV0sXG4gICAgICAgICAgLy8gN1xuICAgICAgICAgIFsyLCA5OCwgNzhdLFxuICAgICAgICAgIFs0LCA0OSwgMzFdLFxuICAgICAgICAgIFsyLCAzMiwgMTQsIDQsIDMzLCAxNV0sXG4gICAgICAgICAgWzQsIDM5LCAxMywgMSwgNDAsIDE0XSxcbiAgICAgICAgICAvLyA4XG4gICAgICAgICAgWzIsIDEyMSwgOTddLFxuICAgICAgICAgIFsyLCA2MCwgMzgsIDIsIDYxLCAzOV0sXG4gICAgICAgICAgWzQsIDQwLCAxOCwgMiwgNDEsIDE5XSxcbiAgICAgICAgICBbNCwgNDAsIDE0LCAyLCA0MSwgMTVdLFxuICAgICAgICAgIC8vIDlcbiAgICAgICAgICBbMiwgMTQ2LCAxMTZdLFxuICAgICAgICAgIFszLCA1OCwgMzYsIDIsIDU5LCAzN10sXG4gICAgICAgICAgWzQsIDM2LCAxNiwgNCwgMzcsIDE3XSxcbiAgICAgICAgICBbNCwgMzYsIDEyLCA0LCAzNywgMTNdLFxuICAgICAgICAgIC8vIDEwXG4gICAgICAgICAgWzIsIDg2LCA2OCwgMiwgODcsIDY5XSxcbiAgICAgICAgICBbNCwgNjksIDQzLCAxLCA3MCwgNDRdLFxuICAgICAgICAgIFs2LCA0MywgMTksIDIsIDQ0LCAyMF0sXG4gICAgICAgICAgWzYsIDQzLCAxNSwgMiwgNDQsIDE2XSxcbiAgICAgICAgICAvLyAxMVxuICAgICAgICAgIFs0LCAxMDEsIDgxXSxcbiAgICAgICAgICBbMSwgODAsIDUwLCA0LCA4MSwgNTFdLFxuICAgICAgICAgIFs0LCA1MCwgMjIsIDQsIDUxLCAyM10sXG4gICAgICAgICAgWzMsIDM2LCAxMiwgOCwgMzcsIDEzXSxcbiAgICAgICAgICAvLyAxMlxuICAgICAgICAgIFsyLCAxMTYsIDkyLCAyLCAxMTcsIDkzXSxcbiAgICAgICAgICBbNiwgNTgsIDM2LCAyLCA1OSwgMzddLFxuICAgICAgICAgIFs0LCA0NiwgMjAsIDYsIDQ3LCAyMV0sXG4gICAgICAgICAgWzcsIDQyLCAxNCwgNCwgNDMsIDE1XSxcbiAgICAgICAgICAvLyAxM1xuICAgICAgICAgIFs0LCAxMzMsIDEwN10sXG4gICAgICAgICAgWzgsIDU5LCAzNywgMSwgNjAsIDM4XSxcbiAgICAgICAgICBbOCwgNDQsIDIwLCA0LCA0NSwgMjFdLFxuICAgICAgICAgIFsxMiwgMzMsIDExLCA0LCAzNCwgMTJdLFxuICAgICAgICAgIC8vIDE0XG4gICAgICAgICAgWzMsIDE0NSwgMTE1LCAxLCAxNDYsIDExNl0sXG4gICAgICAgICAgWzQsIDY0LCA0MCwgNSwgNjUsIDQxXSxcbiAgICAgICAgICBbMTEsIDM2LCAxNiwgNSwgMzcsIDE3XSxcbiAgICAgICAgICBbMTEsIDM2LCAxMiwgNSwgMzcsIDEzXSxcbiAgICAgICAgICAvLyAxNVxuICAgICAgICAgIFs1LCAxMDksIDg3LCAxLCAxMTAsIDg4XSxcbiAgICAgICAgICBbNSwgNjUsIDQxLCA1LCA2NiwgNDJdLFxuICAgICAgICAgIFs1LCA1NCwgMjQsIDcsIDU1LCAyNV0sXG4gICAgICAgICAgWzExLCAzNiwgMTIsIDcsIDM3LCAxM10sXG4gICAgICAgICAgLy8gMTZcbiAgICAgICAgICBbNSwgMTIyLCA5OCwgMSwgMTIzLCA5OV0sXG4gICAgICAgICAgWzcsIDczLCA0NSwgMywgNzQsIDQ2XSxcbiAgICAgICAgICBbMTUsIDQzLCAxOSwgMiwgNDQsIDIwXSxcbiAgICAgICAgICBbMywgNDUsIDE1LCAxMywgNDYsIDE2XSxcbiAgICAgICAgICAvLyAxN1xuICAgICAgICAgIFsxLCAxMzUsIDEwNywgNSwgMTM2LCAxMDhdLFxuICAgICAgICAgIFsxMCwgNzQsIDQ2LCAxLCA3NSwgNDddLFxuICAgICAgICAgIFsxLCA1MCwgMjIsIDE1LCA1MSwgMjNdLFxuICAgICAgICAgIFsyLCA0MiwgMTQsIDE3LCA0MywgMTVdLFxuICAgICAgICAgIC8vIDE4XG4gICAgICAgICAgWzUsIDE1MCwgMTIwLCAxLCAxNTEsIDEyMV0sXG4gICAgICAgICAgWzksIDY5LCA0MywgNCwgNzAsIDQ0XSxcbiAgICAgICAgICBbMTcsIDUwLCAyMiwgMSwgNTEsIDIzXSxcbiAgICAgICAgICBbMiwgNDIsIDE0LCAxOSwgNDMsIDE1XSxcbiAgICAgICAgICAvLyAxOVxuICAgICAgICAgIFszLCAxNDEsIDExMywgNCwgMTQyLCAxMTRdLFxuICAgICAgICAgIFszLCA3MCwgNDQsIDExLCA3MSwgNDVdLFxuICAgICAgICAgIFsxNywgNDcsIDIxLCA0LCA0OCwgMjJdLFxuICAgICAgICAgIFs5LCAzOSwgMTMsIDE2LCA0MCwgMTRdLFxuICAgICAgICAgIC8vIDIwXG4gICAgICAgICAgWzMsIDEzNSwgMTA3LCA1LCAxMzYsIDEwOF0sXG4gICAgICAgICAgWzMsIDY3LCA0MSwgMTMsIDY4LCA0Ml0sXG4gICAgICAgICAgWzE1LCA1NCwgMjQsIDUsIDU1LCAyNV0sXG4gICAgICAgICAgWzE1LCA0MywgMTUsIDEwLCA0NCwgMTZdLFxuICAgICAgICAgIC8vIDIxXG4gICAgICAgICAgWzQsIDE0NCwgMTE2LCA0LCAxNDUsIDExN10sXG4gICAgICAgICAgWzE3LCA2OCwgNDJdLFxuICAgICAgICAgIFsxNywgNTAsIDIyLCA2LCA1MSwgMjNdLFxuICAgICAgICAgIFsxOSwgNDYsIDE2LCA2LCA0NywgMTddLFxuICAgICAgICAgIC8vIDIyXG4gICAgICAgICAgWzIsIDEzOSwgMTExLCA3LCAxNDAsIDExMl0sXG4gICAgICAgICAgWzE3LCA3NCwgNDZdLFxuICAgICAgICAgIFs3LCA1NCwgMjQsIDE2LCA1NSwgMjVdLFxuICAgICAgICAgIFszNCwgMzcsIDEzXSxcbiAgICAgICAgICAvLyAyM1xuICAgICAgICAgIFs0LCAxNTEsIDEyMSwgNSwgMTUyLCAxMjJdLFxuICAgICAgICAgIFs0LCA3NSwgNDcsIDE0LCA3NiwgNDhdLFxuICAgICAgICAgIFsxMSwgNTQsIDI0LCAxNCwgNTUsIDI1XSxcbiAgICAgICAgICBbMTYsIDQ1LCAxNSwgMTQsIDQ2LCAxNl0sXG4gICAgICAgICAgLy8gMjRcbiAgICAgICAgICBbNiwgMTQ3LCAxMTcsIDQsIDE0OCwgMTE4XSxcbiAgICAgICAgICBbNiwgNzMsIDQ1LCAxNCwgNzQsIDQ2XSxcbiAgICAgICAgICBbMTEsIDU0LCAyNCwgMTYsIDU1LCAyNV0sXG4gICAgICAgICAgWzMwLCA0NiwgMTYsIDIsIDQ3LCAxN10sXG4gICAgICAgICAgLy8gMjVcbiAgICAgICAgICBbOCwgMTMyLCAxMDYsIDQsIDEzMywgMTA3XSxcbiAgICAgICAgICBbOCwgNzUsIDQ3LCAxMywgNzYsIDQ4XSxcbiAgICAgICAgICBbNywgNTQsIDI0LCAyMiwgNTUsIDI1XSxcbiAgICAgICAgICBbMjIsIDQ1LCAxNSwgMTMsIDQ2LCAxNl0sXG4gICAgICAgICAgLy8gMjZcbiAgICAgICAgICBbMTAsIDE0MiwgMTE0LCAyLCAxNDMsIDExNV0sXG4gICAgICAgICAgWzE5LCA3NCwgNDYsIDQsIDc1LCA0N10sXG4gICAgICAgICAgWzI4LCA1MCwgMjIsIDYsIDUxLCAyM10sXG4gICAgICAgICAgWzMzLCA0NiwgMTYsIDQsIDQ3LCAxN10sXG4gICAgICAgICAgLy8gMjdcbiAgICAgICAgICBbOCwgMTUyLCAxMjIsIDQsIDE1MywgMTIzXSxcbiAgICAgICAgICBbMjIsIDczLCA0NSwgMywgNzQsIDQ2XSxcbiAgICAgICAgICBbOCwgNTMsIDIzLCAyNiwgNTQsIDI0XSxcbiAgICAgICAgICBbMTIsIDQ1LCAxNSwgMjgsIDQ2LCAxNl0sXG4gICAgICAgICAgLy8gMjhcbiAgICAgICAgICBbMywgMTQ3LCAxMTcsIDEwLCAxNDgsIDExOF0sXG4gICAgICAgICAgWzMsIDczLCA0NSwgMjMsIDc0LCA0Nl0sXG4gICAgICAgICAgWzQsIDU0LCAyNCwgMzEsIDU1LCAyNV0sXG4gICAgICAgICAgWzExLCA0NSwgMTUsIDMxLCA0NiwgMTZdLFxuICAgICAgICAgIC8vIDI5XG4gICAgICAgICAgWzcsIDE0NiwgMTE2LCA3LCAxNDcsIDExN10sXG4gICAgICAgICAgWzIxLCA3MywgNDUsIDcsIDc0LCA0Nl0sXG4gICAgICAgICAgWzEsIDUzLCAyMywgMzcsIDU0LCAyNF0sXG4gICAgICAgICAgWzE5LCA0NSwgMTUsIDI2LCA0NiwgMTZdLFxuICAgICAgICAgIC8vIDMwXG4gICAgICAgICAgWzUsIDE0NSwgMTE1LCAxMCwgMTQ2LCAxMTZdLFxuICAgICAgICAgIFsxOSwgNzUsIDQ3LCAxMCwgNzYsIDQ4XSxcbiAgICAgICAgICBbMTUsIDU0LCAyNCwgMjUsIDU1LCAyNV0sXG4gICAgICAgICAgWzIzLCA0NSwgMTUsIDI1LCA0NiwgMTZdLFxuICAgICAgICAgIC8vIDMxXG4gICAgICAgICAgWzEzLCAxNDUsIDExNSwgMywgMTQ2LCAxMTZdLFxuICAgICAgICAgIFsyLCA3NCwgNDYsIDI5LCA3NSwgNDddLFxuICAgICAgICAgIFs0MiwgNTQsIDI0LCAxLCA1NSwgMjVdLFxuICAgICAgICAgIFsyMywgNDUsIDE1LCAyOCwgNDYsIDE2XSxcbiAgICAgICAgICAvLyAzMlxuICAgICAgICAgIFsxNywgMTQ1LCAxMTVdLFxuICAgICAgICAgIFsxMCwgNzQsIDQ2LCAyMywgNzUsIDQ3XSxcbiAgICAgICAgICBbMTAsIDU0LCAyNCwgMzUsIDU1LCAyNV0sXG4gICAgICAgICAgWzE5LCA0NSwgMTUsIDM1LCA0NiwgMTZdLFxuICAgICAgICAgIC8vIDMzXG4gICAgICAgICAgWzE3LCAxNDUsIDExNSwgMSwgMTQ2LCAxMTZdLFxuICAgICAgICAgIFsxNCwgNzQsIDQ2LCAyMSwgNzUsIDQ3XSxcbiAgICAgICAgICBbMjksIDU0LCAyNCwgMTksIDU1LCAyNV0sXG4gICAgICAgICAgWzExLCA0NSwgMTUsIDQ2LCA0NiwgMTZdLFxuICAgICAgICAgIC8vIDM0XG4gICAgICAgICAgWzEzLCAxNDUsIDExNSwgNiwgMTQ2LCAxMTZdLFxuICAgICAgICAgIFsxNCwgNzQsIDQ2LCAyMywgNzUsIDQ3XSxcbiAgICAgICAgICBbNDQsIDU0LCAyNCwgNywgNTUsIDI1XSxcbiAgICAgICAgICBbNTksIDQ2LCAxNiwgMSwgNDcsIDE3XSxcbiAgICAgICAgICAvLyAzNVxuICAgICAgICAgIFsxMiwgMTUxLCAxMjEsIDcsIDE1MiwgMTIyXSxcbiAgICAgICAgICBbMTIsIDc1LCA0NywgMjYsIDc2LCA0OF0sXG4gICAgICAgICAgWzM5LCA1NCwgMjQsIDE0LCA1NSwgMjVdLFxuICAgICAgICAgIFsyMiwgNDUsIDE1LCA0MSwgNDYsIDE2XSxcbiAgICAgICAgICAvLyAzNlxuICAgICAgICAgIFs2LCAxNTEsIDEyMSwgMTQsIDE1MiwgMTIyXSxcbiAgICAgICAgICBbNiwgNzUsIDQ3LCAzNCwgNzYsIDQ4XSxcbiAgICAgICAgICBbNDYsIDU0LCAyNCwgMTAsIDU1LCAyNV0sXG4gICAgICAgICAgWzIsIDQ1LCAxNSwgNjQsIDQ2LCAxNl0sXG4gICAgICAgICAgLy8gMzdcbiAgICAgICAgICBbMTcsIDE1MiwgMTIyLCA0LCAxNTMsIDEyM10sXG4gICAgICAgICAgWzI5LCA3NCwgNDYsIDE0LCA3NSwgNDddLFxuICAgICAgICAgIFs0OSwgNTQsIDI0LCAxMCwgNTUsIDI1XSxcbiAgICAgICAgICBbMjQsIDQ1LCAxNSwgNDYsIDQ2LCAxNl0sXG4gICAgICAgICAgLy8gMzhcbiAgICAgICAgICBbNCwgMTUyLCAxMjIsIDE4LCAxNTMsIDEyM10sXG4gICAgICAgICAgWzEzLCA3NCwgNDYsIDMyLCA3NSwgNDddLFxuICAgICAgICAgIFs0OCwgNTQsIDI0LCAxNCwgNTUsIDI1XSxcbiAgICAgICAgICBbNDIsIDQ1LCAxNSwgMzIsIDQ2LCAxNl0sXG4gICAgICAgICAgLy8gMzlcbiAgICAgICAgICBbMjAsIDE0NywgMTE3LCA0LCAxNDgsIDExOF0sXG4gICAgICAgICAgWzQwLCA3NSwgNDcsIDcsIDc2LCA0OF0sXG4gICAgICAgICAgWzQzLCA1NCwgMjQsIDIyLCA1NSwgMjVdLFxuICAgICAgICAgIFsxMCwgNDUsIDE1LCA2NywgNDYsIDE2XSxcbiAgICAgICAgICAvLyA0MFxuICAgICAgICAgIFsxOSwgMTQ4LCAxMTgsIDYsIDE0OSwgMTE5XSxcbiAgICAgICAgICBbMTgsIDc1LCA0NywgMzEsIDc2LCA0OF0sXG4gICAgICAgICAgWzM0LCA1NCwgMjQsIDM0LCA1NSwgMjVdLFxuICAgICAgICAgIFsyMCwgNDUsIDE1LCA2MSwgNDYsIDE2XVxuICAgICAgICBdO1xuICAgICAgICB2YXIgcXJSU0Jsb2NrID0gZnVuY3Rpb24odG90YWxDb3VudCwgZGF0YUNvdW50KSB7XG4gICAgICAgICAgdmFyIF90aGlzMiA9IHt9O1xuICAgICAgICAgIF90aGlzMi50b3RhbENvdW50ID0gdG90YWxDb3VudDtcbiAgICAgICAgICBfdGhpczIuZGF0YUNvdW50ID0gZGF0YUNvdW50O1xuICAgICAgICAgIHJldHVybiBfdGhpczI7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBfdGhpcyA9IHt9O1xuICAgICAgICB2YXIgZ2V0UnNCbG9ja1RhYmxlID0gZnVuY3Rpb24odHlwZU51bWJlciwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpIHtcbiAgICAgICAgICBzd2l0Y2ggKGVycm9yQ29ycmVjdGlvbkxldmVsKSB7XG4gICAgICAgICAgICBjYXNlIFFSRXJyb3JDb3JyZWN0aW9uTGV2ZWwuTDpcbiAgICAgICAgICAgICAgcmV0dXJuIFJTX0JMT0NLX1RBQkxFWyh0eXBlTnVtYmVyIC0gMSkgKiA0ICsgMF07XG4gICAgICAgICAgICBjYXNlIFFSRXJyb3JDb3JyZWN0aW9uTGV2ZWwuTTpcbiAgICAgICAgICAgICAgcmV0dXJuIFJTX0JMT0NLX1RBQkxFWyh0eXBlTnVtYmVyIC0gMSkgKiA0ICsgMV07XG4gICAgICAgICAgICBjYXNlIFFSRXJyb3JDb3JyZWN0aW9uTGV2ZWwuUTpcbiAgICAgICAgICAgICAgcmV0dXJuIFJTX0JMT0NLX1RBQkxFWyh0eXBlTnVtYmVyIC0gMSkgKiA0ICsgMl07XG4gICAgICAgICAgICBjYXNlIFFSRXJyb3JDb3JyZWN0aW9uTGV2ZWwuSDpcbiAgICAgICAgICAgICAgcmV0dXJuIFJTX0JMT0NLX1RBQkxFWyh0eXBlTnVtYmVyIC0gMSkgKiA0ICsgM107XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0UlNCbG9ja3MgPSBmdW5jdGlvbih0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3Rpb25MZXZlbCkge1xuICAgICAgICAgIHZhciByc0Jsb2NrID0gZ2V0UnNCbG9ja1RhYmxlKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdGlvbkxldmVsKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHJzQmxvY2sgPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhyb3cgXCJiYWQgcnMgYmxvY2sgQCB0eXBlTnVtYmVyOlwiICsgdHlwZU51bWJlciArIFwiL2Vycm9yQ29ycmVjdGlvbkxldmVsOlwiICsgZXJyb3JDb3JyZWN0aW9uTGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsZW5ndGggPSByc0Jsb2NrLmxlbmd0aCAvIDM7XG4gICAgICAgICAgdmFyIGxpc3QgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgbGVuZ3RoOyBpMiArPSAxKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSByc0Jsb2NrW2kyICogMyArIDBdO1xuICAgICAgICAgICAgdmFyIHRvdGFsQ291bnQgPSByc0Jsb2NrW2kyICogMyArIDFdO1xuICAgICAgICAgICAgdmFyIGRhdGFDb3VudCA9IHJzQmxvY2tbaTIgKiAzICsgMl07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50OyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgbGlzdC5wdXNoKHFyUlNCbG9jayh0b3RhbENvdW50LCBkYXRhQ291bnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH0oKTtcbiAgICAgIHZhciBxckJpdEJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2J1ZmZlciA9IFtdO1xuICAgICAgICB2YXIgX2xlbmd0aCA9IDA7XG4gICAgICAgIHZhciBfdGhpcyA9IHt9O1xuICAgICAgICBfdGhpcy5nZXRCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX2J1ZmZlcjtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0QXQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgIHZhciBidWZJbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyA4KTtcbiAgICAgICAgICByZXR1cm4gKF9idWZmZXJbYnVmSW5kZXhdID4+PiA3IC0gaW5kZXggJSA4ICYgMSkgPT0gMTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucHV0ID0gZnVuY3Rpb24obnVtLCBsZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgbGVuZ3RoOyBpMiArPSAxKSB7XG4gICAgICAgICAgICBfdGhpcy5wdXRCaXQoKG51bSA+Pj4gbGVuZ3RoIC0gaTIgLSAxICYgMSkgPT0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRMZW5ndGhJbkJpdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX2xlbmd0aDtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucHV0Qml0ID0gZnVuY3Rpb24oYml0KSB7XG4gICAgICAgICAgdmFyIGJ1ZkluZGV4ID0gTWF0aC5mbG9vcihfbGVuZ3RoIC8gOCk7XG4gICAgICAgICAgaWYgKF9idWZmZXIubGVuZ3RoIDw9IGJ1ZkluZGV4KSB7XG4gICAgICAgICAgICBfYnVmZmVyLnB1c2goMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgIF9idWZmZXJbYnVmSW5kZXhdIHw9IDEyOCA+Pj4gX2xlbmd0aCAlIDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9sZW5ndGggKz0gMTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfTtcbiAgICAgIHZhciBxck51bWJlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIF9tb2RlID0gUVJNb2RlLk1PREVfTlVNQkVSO1xuICAgICAgICB2YXIgX2RhdGEgPSBkYXRhO1xuICAgICAgICB2YXIgX3RoaXMgPSB7fTtcbiAgICAgICAgX3RoaXMuZ2V0TW9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfbW9kZTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIF9kYXRhLmxlbmd0aDtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgICAgICB2YXIgZGF0YTIgPSBfZGF0YTtcbiAgICAgICAgICB2YXIgaTIgPSAwO1xuICAgICAgICAgIHdoaWxlIChpMiArIDIgPCBkYXRhMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXQoc3RyVG9OdW0oZGF0YTIuc3Vic3RyaW5nKGkyLCBpMiArIDMpKSwgMTApO1xuICAgICAgICAgICAgaTIgKz0gMztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkyIDwgZGF0YTIubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoZGF0YTIubGVuZ3RoIC0gaTIgPT0gMSkge1xuICAgICAgICAgICAgICBidWZmZXIucHV0KHN0clRvTnVtKGRhdGEyLnN1YnN0cmluZyhpMiwgaTIgKyAxKSksIDQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhMi5sZW5ndGggLSBpMiA9PSAyKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlci5wdXQoc3RyVG9OdW0oZGF0YTIuc3Vic3RyaW5nKGkyLCBpMiArIDIpKSwgNyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgc3RyVG9OdW0gPSBmdW5jdGlvbihzMikge1xuICAgICAgICAgIHZhciBudW0gPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBzMi5sZW5ndGg7IGkyICs9IDEpIHtcbiAgICAgICAgICAgIG51bSA9IG51bSAqIDEwICsgY2hhdFRvTnVtKHMyLmNoYXJBdChpMikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY2hhdFRvTnVtID0gZnVuY3Rpb24oYzIpIHtcbiAgICAgICAgICBpZiAoXCIwXCIgPD0gYzIgJiYgYzIgPD0gXCI5XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjMi5jaGFyQ29kZUF0KDApIC0gXCIwXCIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgXCJpbGxlZ2FsIGNoYXIgOlwiICsgYzI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH07XG4gICAgICB2YXIgcXJBbHBoYU51bSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIF9tb2RlID0gUVJNb2RlLk1PREVfQUxQSEFfTlVNO1xuICAgICAgICB2YXIgX2RhdGEgPSBkYXRhO1xuICAgICAgICB2YXIgX3RoaXMgPSB7fTtcbiAgICAgICAgX3RoaXMuZ2V0TW9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfbW9kZTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIF9kYXRhLmxlbmd0aDtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgICAgICB2YXIgczIgPSBfZGF0YTtcbiAgICAgICAgICB2YXIgaTIgPSAwO1xuICAgICAgICAgIHdoaWxlIChpMiArIDEgPCBzMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXQoXG4gICAgICAgICAgICAgIGdldENvZGUoczIuY2hhckF0KGkyKSkgKiA0NSArIGdldENvZGUoczIuY2hhckF0KGkyICsgMSkpLFxuICAgICAgICAgICAgICAxMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGkyICs9IDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpMiA8IHMyLmxlbmd0aCkge1xuICAgICAgICAgICAgYnVmZmVyLnB1dChnZXRDb2RlKHMyLmNoYXJBdChpMikpLCA2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXRDb2RlID0gZnVuY3Rpb24oYzIpIHtcbiAgICAgICAgICBpZiAoXCIwXCIgPD0gYzIgJiYgYzIgPD0gXCI5XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjMi5jaGFyQ29kZUF0KDApIC0gXCIwXCIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFwiQVwiIDw9IGMyICYmIGMyIDw9IFwiWlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYzIuY2hhckNvZGVBdCgwKSAtIFwiQVwiLmNoYXJDb2RlQXQoMCkgKyAxMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoIChjMikge1xuICAgICAgICAgICAgICBjYXNlIFwiIFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAzNjtcbiAgICAgICAgICAgICAgY2FzZSBcIiRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMzc7XG4gICAgICAgICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDM4O1xuICAgICAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAzOTtcbiAgICAgICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gNDA7XG4gICAgICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDQxO1xuICAgICAgICAgICAgICBjYXNlIFwiLlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiA0MjtcbiAgICAgICAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gNDM7XG4gICAgICAgICAgICAgIGNhc2UgXCI6XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDQ0O1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IFwiaWxsZWdhbCBjaGFyIDpcIiArIGMyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfTtcbiAgICAgIHZhciBxcjhCaXRCeXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgX21vZGUgPSBRUk1vZGUuTU9ERV84QklUX0JZVEU7XG4gICAgICAgIHZhciBfYnl0ZXMgPSBxcmNvZGUzLnN0cmluZ1RvQnl0ZXMoZGF0YSk7XG4gICAgICAgIHZhciBfdGhpcyA9IHt9O1xuICAgICAgICBfdGhpcy5nZXRNb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF9tb2RlO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gX2J5dGVzLmxlbmd0aDtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgX2J5dGVzLmxlbmd0aDsgaTIgKz0gMSkge1xuICAgICAgICAgICAgYnVmZmVyLnB1dChfYnl0ZXNbaTJdLCA4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH07XG4gICAgICB2YXIgcXJLYW5qaSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIF9tb2RlID0gUVJNb2RlLk1PREVfS0FOSkk7XG4gICAgICAgIHZhciBzdHJpbmdUb0J5dGVzID0gcXJjb2RlMy5zdHJpbmdUb0J5dGVzRnVuY3NbXCJTSklTXCJdO1xuICAgICAgICBpZiAoIXN0cmluZ1RvQnl0ZXMpIHtcbiAgICAgICAgICB0aHJvdyBcInNqaXMgbm90IHN1cHBvcnRlZC5cIjtcbiAgICAgICAgfVxuICAgICAgICAhZnVuY3Rpb24oYzIsIGNvZGUpIHtcbiAgICAgICAgICB2YXIgdGVzdCA9IHN0cmluZ1RvQnl0ZXMoYzIpO1xuICAgICAgICAgIGlmICh0ZXN0Lmxlbmd0aCAhPSAyIHx8ICh0ZXN0WzBdIDw8IDggfCB0ZXN0WzFdKSAhPSBjb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBcInNqaXMgbm90IHN1cHBvcnRlZC5cIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0oXCLlj4tcIiwgMzg3MjYpO1xuICAgICAgICB2YXIgX2J5dGVzID0gc3RyaW5nVG9CeXRlcyhkYXRhKTtcbiAgICAgICAgdmFyIF90aGlzID0ge307XG4gICAgICAgIF90aGlzLmdldE1vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX21vZGU7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldExlbmd0aCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiB+fihfYnl0ZXMubGVuZ3RoIC8gMik7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgICAgdmFyIGRhdGEyID0gX2J5dGVzO1xuICAgICAgICAgIHZhciBpMiA9IDA7XG4gICAgICAgICAgd2hpbGUgKGkyICsgMSA8IGRhdGEyLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGMyID0gKDI1NSAmIGRhdGEyW2kyXSkgPDwgOCB8IDI1NSAmIGRhdGEyW2kyICsgMV07XG4gICAgICAgICAgICBpZiAoMzMwODggPD0gYzIgJiYgYzIgPD0gNDA5NTYpIHtcbiAgICAgICAgICAgICAgYzIgLT0gMzMwODg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKDU3NDA4IDw9IGMyICYmIGMyIDw9IDYwMzUxKSB7XG4gICAgICAgICAgICAgIGMyIC09IDQ5NDcyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJpbGxlZ2FsIGNoYXIgYXQgXCIgKyAoaTIgKyAxKSArIFwiL1wiICsgYzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjMiA9IChjMiA+Pj4gOCAmIDI1NSkgKiAxOTIgKyAoYzIgJiAyNTUpO1xuICAgICAgICAgICAgYnVmZmVyLnB1dChjMiwgMTMpO1xuICAgICAgICAgICAgaTIgKz0gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkyIDwgZGF0YTIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBcImlsbGVnYWwgY2hhciBhdCBcIiArIChpMiArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfTtcbiAgICAgIHZhciBieXRlQXJyYXlPdXRwdXRTdHJlYW0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9ieXRlcyA9IFtdO1xuICAgICAgICB2YXIgX3RoaXMgPSB7fTtcbiAgICAgICAgX3RoaXMud3JpdGVCeXRlID0gZnVuY3Rpb24oYikge1xuICAgICAgICAgIF9ieXRlcy5wdXNoKGIgJiAyNTUpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy53cml0ZVNob3J0ID0gZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICBfdGhpcy53cml0ZUJ5dGUoaTIpO1xuICAgICAgICAgIF90aGlzLndyaXRlQnl0ZShpMiA+Pj4gOCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLndyaXRlQnl0ZXMgPSBmdW5jdGlvbihiLCBvZmYsIGxlbikge1xuICAgICAgICAgIG9mZiA9IG9mZiB8fCAwO1xuICAgICAgICAgIGxlbiA9IGxlbiB8fCBiLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgbGVuOyBpMiArPSAxKSB7XG4gICAgICAgICAgICBfdGhpcy53cml0ZUJ5dGUoYltpMiArIG9mZl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMud3JpdGVTdHJpbmcgPSBmdW5jdGlvbihzMikge1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBzMi5sZW5ndGg7IGkyICs9IDEpIHtcbiAgICAgICAgICAgIF90aGlzLndyaXRlQnl0ZShzMi5jaGFyQ29kZUF0KGkyKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy50b0J5dGVBcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfYnl0ZXM7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHMyID0gXCJcIjtcbiAgICAgICAgICBzMiArPSBcIltcIjtcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgX2J5dGVzLmxlbmd0aDsgaTIgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGkyID4gMCkge1xuICAgICAgICAgICAgICBzMiArPSBcIixcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMyICs9IF9ieXRlc1tpMl07XG4gICAgICAgICAgfVxuICAgICAgICAgIHMyICs9IFwiXVwiO1xuICAgICAgICAgIHJldHVybiBzMjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfTtcbiAgICAgIHZhciBiYXNlNjRFbmNvZGVPdXRwdXRTdHJlYW0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9idWZmZXIgPSAwO1xuICAgICAgICB2YXIgX2J1ZmxlbiA9IDA7XG4gICAgICAgIHZhciBfbGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIF9iYXNlNjQgPSBcIlwiO1xuICAgICAgICB2YXIgX3RoaXMgPSB7fTtcbiAgICAgICAgdmFyIHdyaXRlRW5jb2RlZCA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICBfYmFzZTY0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZW5jb2RlKGIgJiA2MykpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZW5jb2RlID0gZnVuY3Rpb24objIpIHtcbiAgICAgICAgICBpZiAobjIgPCAwKSA7XG4gICAgICAgICAgZWxzZSBpZiAobjIgPCAyNikge1xuICAgICAgICAgICAgcmV0dXJuIDY1ICsgbjI7XG4gICAgICAgICAgfSBlbHNlIGlmIChuMiA8IDUyKSB7XG4gICAgICAgICAgICByZXR1cm4gOTcgKyAobjIgLSAyNik7XG4gICAgICAgICAgfSBlbHNlIGlmIChuMiA8IDYyKSB7XG4gICAgICAgICAgICByZXR1cm4gNDggKyAobjIgLSA1Mik7XG4gICAgICAgICAgfSBlbHNlIGlmIChuMiA9PSA2Mikge1xuICAgICAgICAgICAgcmV0dXJuIDQzO1xuICAgICAgICAgIH0gZWxzZSBpZiAobjIgPT0gNjMpIHtcbiAgICAgICAgICAgIHJldHVybiA0NztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgXCJuOlwiICsgbjI7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLndyaXRlQnl0ZSA9IGZ1bmN0aW9uKG4yKSB7XG4gICAgICAgICAgX2J1ZmZlciA9IF9idWZmZXIgPDwgOCB8IG4yICYgMjU1O1xuICAgICAgICAgIF9idWZsZW4gKz0gODtcbiAgICAgICAgICBfbGVuZ3RoICs9IDE7XG4gICAgICAgICAgd2hpbGUgKF9idWZsZW4gPj0gNikge1xuICAgICAgICAgICAgd3JpdGVFbmNvZGVkKF9idWZmZXIgPj4+IF9idWZsZW4gLSA2KTtcbiAgICAgICAgICAgIF9idWZsZW4gLT0gNjtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKF9idWZsZW4gPiAwKSB7XG4gICAgICAgICAgICB3cml0ZUVuY29kZWQoX2J1ZmZlciA8PCA2IC0gX2J1Zmxlbik7XG4gICAgICAgICAgICBfYnVmZmVyID0gMDtcbiAgICAgICAgICAgIF9idWZsZW4gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX2xlbmd0aCAlIDMgIT0gMCkge1xuICAgICAgICAgICAgdmFyIHBhZGxlbiA9IDMgLSBfbGVuZ3RoICUgMztcbiAgICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBwYWRsZW47IGkyICs9IDEpIHtcbiAgICAgICAgICAgICAgX2Jhc2U2NCArPSBcIj1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF9iYXNlNjQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH07XG4gICAgICB2YXIgYmFzZTY0RGVjb2RlSW5wdXRTdHJlYW0gPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgdmFyIF9zdHIgPSBzdHI7XG4gICAgICAgIHZhciBfcG9zID0gMDtcbiAgICAgICAgdmFyIF9idWZmZXIgPSAwO1xuICAgICAgICB2YXIgX2J1ZmxlbiA9IDA7XG4gICAgICAgIHZhciBfdGhpcyA9IHt9O1xuICAgICAgICBfdGhpcy5yZWFkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgd2hpbGUgKF9idWZsZW4gPCA4KSB7XG4gICAgICAgICAgICBpZiAoX3BvcyA+PSBfc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAoX2J1ZmxlbiA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IFwidW5leHBlY3RlZCBlbmQgb2YgZmlsZS4vXCIgKyBfYnVmbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGMyID0gX3N0ci5jaGFyQXQoX3Bvcyk7XG4gICAgICAgICAgICBfcG9zICs9IDE7XG4gICAgICAgICAgICBpZiAoYzIgPT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgX2J1ZmxlbiA9IDA7XG4gICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYzIubWF0Y2goL15cXHMkLykpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfYnVmZmVyID0gX2J1ZmZlciA8PCA2IHwgZGVjb2RlKGMyLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICAgICAgX2J1ZmxlbiArPSA2O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbjIgPSBfYnVmZmVyID4+PiBfYnVmbGVuIC0gOCAmIDI1NTtcbiAgICAgICAgICBfYnVmbGVuIC09IDg7XG4gICAgICAgICAgcmV0dXJuIG4yO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZGVjb2RlID0gZnVuY3Rpb24oYzIpIHtcbiAgICAgICAgICBpZiAoNjUgPD0gYzIgJiYgYzIgPD0gOTApIHtcbiAgICAgICAgICAgIHJldHVybiBjMiAtIDY1O1xuICAgICAgICAgIH0gZWxzZSBpZiAoOTcgPD0gYzIgJiYgYzIgPD0gMTIyKSB7XG4gICAgICAgICAgICByZXR1cm4gYzIgLSA5NyArIDI2O1xuICAgICAgICAgIH0gZWxzZSBpZiAoNDggPD0gYzIgJiYgYzIgPD0gNTcpIHtcbiAgICAgICAgICAgIHJldHVybiBjMiAtIDQ4ICsgNTI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjMiA9PSA0Mykge1xuICAgICAgICAgICAgcmV0dXJuIDYyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYzIgPT0gNDcpIHtcbiAgICAgICAgICAgIHJldHVybiA2MztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgXCJjOlwiICsgYzI7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9O1xuICAgICAgdmFyIGdpZkltYWdlID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHZhciBfaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB2YXIgX2RhdGEgPSBuZXcgQXJyYXkod2lkdGggKiBoZWlnaHQpO1xuICAgICAgICB2YXIgX3RoaXMgPSB7fTtcbiAgICAgICAgX3RoaXMuc2V0UGl4ZWwgPSBmdW5jdGlvbih4LCB5LCBwaXhlbCkge1xuICAgICAgICAgIF9kYXRhW3kgKiBfd2lkdGggKyB4XSA9IHBpeGVsO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uKG91dCkge1xuICAgICAgICAgIG91dC53cml0ZVN0cmluZyhcIkdJRjg3YVwiKTtcbiAgICAgICAgICBvdXQud3JpdGVTaG9ydChfd2lkdGgpO1xuICAgICAgICAgIG91dC53cml0ZVNob3J0KF9oZWlnaHQpO1xuICAgICAgICAgIG91dC53cml0ZUJ5dGUoMTI4KTtcbiAgICAgICAgICBvdXQud3JpdGVCeXRlKDApO1xuICAgICAgICAgIG91dC53cml0ZUJ5dGUoMCk7XG4gICAgICAgICAgb3V0LndyaXRlQnl0ZSgwKTtcbiAgICAgICAgICBvdXQud3JpdGVCeXRlKDApO1xuICAgICAgICAgIG91dC53cml0ZUJ5dGUoMCk7XG4gICAgICAgICAgb3V0LndyaXRlQnl0ZSgyNTUpO1xuICAgICAgICAgIG91dC53cml0ZUJ5dGUoMjU1KTtcbiAgICAgICAgICBvdXQud3JpdGVCeXRlKDI1NSk7XG4gICAgICAgICAgb3V0LndyaXRlU3RyaW5nKFwiLFwiKTtcbiAgICAgICAgICBvdXQud3JpdGVTaG9ydCgwKTtcbiAgICAgICAgICBvdXQud3JpdGVTaG9ydCgwKTtcbiAgICAgICAgICBvdXQud3JpdGVTaG9ydChfd2lkdGgpO1xuICAgICAgICAgIG91dC53cml0ZVNob3J0KF9oZWlnaHQpO1xuICAgICAgICAgIG91dC53cml0ZUJ5dGUoMCk7XG4gICAgICAgICAgdmFyIGx6d01pbkNvZGVTaXplID0gMjtcbiAgICAgICAgICB2YXIgcmFzdGVyID0gZ2V0TFpXUmFzdGVyKGx6d01pbkNvZGVTaXplKTtcbiAgICAgICAgICBvdXQud3JpdGVCeXRlKGx6d01pbkNvZGVTaXplKTtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICB3aGlsZSAocmFzdGVyLmxlbmd0aCAtIG9mZnNldCA+IDI1NSkge1xuICAgICAgICAgICAgb3V0LndyaXRlQnl0ZSgyNTUpO1xuICAgICAgICAgICAgb3V0LndyaXRlQnl0ZXMocmFzdGVyLCBvZmZzZXQsIDI1NSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMjU1O1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQud3JpdGVCeXRlKHJhc3Rlci5sZW5ndGggLSBvZmZzZXQpO1xuICAgICAgICAgIG91dC53cml0ZUJ5dGVzKHJhc3Rlciwgb2Zmc2V0LCByYXN0ZXIubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgICAgICAgICBvdXQud3JpdGVCeXRlKDApO1xuICAgICAgICAgIG91dC53cml0ZVN0cmluZyhcIjtcIik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBiaXRPdXRwdXRTdHJlYW0gPSBmdW5jdGlvbihvdXQpIHtcbiAgICAgICAgICB2YXIgX291dCA9IG91dDtcbiAgICAgICAgICB2YXIgX2JpdExlbmd0aCA9IDA7XG4gICAgICAgICAgdmFyIF9iaXRCdWZmZXIgPSAwO1xuICAgICAgICAgIHZhciBfdGhpczIgPSB7fTtcbiAgICAgICAgICBfdGhpczIud3JpdGUgPSBmdW5jdGlvbihkYXRhLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChkYXRhID4+PiBsZW5ndGggIT0gMCkge1xuICAgICAgICAgICAgICB0aHJvdyBcImxlbmd0aCBvdmVyXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoX2JpdExlbmd0aCArIGxlbmd0aCA+PSA4KSB7XG4gICAgICAgICAgICAgIF9vdXQud3JpdGVCeXRlKDI1NSAmIChkYXRhIDw8IF9iaXRMZW5ndGggfCBfYml0QnVmZmVyKSk7XG4gICAgICAgICAgICAgIGxlbmd0aCAtPSA4IC0gX2JpdExlbmd0aDtcbiAgICAgICAgICAgICAgZGF0YSA+Pj49IDggLSBfYml0TGVuZ3RoO1xuICAgICAgICAgICAgICBfYml0QnVmZmVyID0gMDtcbiAgICAgICAgICAgICAgX2JpdExlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfYml0QnVmZmVyID0gZGF0YSA8PCBfYml0TGVuZ3RoIHwgX2JpdEJ1ZmZlcjtcbiAgICAgICAgICAgIF9iaXRMZW5ndGggPSBfYml0TGVuZ3RoICsgbGVuZ3RoO1xuICAgICAgICAgIH07XG4gICAgICAgICAgX3RoaXMyLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoX2JpdExlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgX291dC53cml0ZUJ5dGUoX2JpdEJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2V0TFpXUmFzdGVyID0gZnVuY3Rpb24obHp3TWluQ29kZVNpemUpIHtcbiAgICAgICAgICB2YXIgY2xlYXJDb2RlID0gMSA8PCBsendNaW5Db2RlU2l6ZTtcbiAgICAgICAgICB2YXIgZW5kQ29kZSA9ICgxIDw8IGx6d01pbkNvZGVTaXplKSArIDE7XG4gICAgICAgICAgdmFyIGJpdExlbmd0aCA9IGx6d01pbkNvZGVTaXplICsgMTtcbiAgICAgICAgICB2YXIgdGFibGUgPSBsendUYWJsZSgpO1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBjbGVhckNvZGU7IGkyICs9IDEpIHtcbiAgICAgICAgICAgIHRhYmxlLmFkZChTdHJpbmcuZnJvbUNoYXJDb2RlKGkyKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhYmxlLmFkZChTdHJpbmcuZnJvbUNoYXJDb2RlKGNsZWFyQ29kZSkpO1xuICAgICAgICAgIHRhYmxlLmFkZChTdHJpbmcuZnJvbUNoYXJDb2RlKGVuZENvZGUpKTtcbiAgICAgICAgICB2YXIgYnl0ZU91dCA9IGJ5dGVBcnJheU91dHB1dFN0cmVhbSgpO1xuICAgICAgICAgIHZhciBiaXRPdXQgPSBiaXRPdXRwdXRTdHJlYW0oYnl0ZU91dCk7XG4gICAgICAgICAgYml0T3V0LndyaXRlKGNsZWFyQ29kZSwgYml0TGVuZ3RoKTtcbiAgICAgICAgICB2YXIgZGF0YUluZGV4ID0gMDtcbiAgICAgICAgICB2YXIgczIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKF9kYXRhW2RhdGFJbmRleF0pO1xuICAgICAgICAgIGRhdGFJbmRleCArPSAxO1xuICAgICAgICAgIHdoaWxlIChkYXRhSW5kZXggPCBfZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjMiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoX2RhdGFbZGF0YUluZGV4XSk7XG4gICAgICAgICAgICBkYXRhSW5kZXggKz0gMTtcbiAgICAgICAgICAgIGlmICh0YWJsZS5jb250YWlucyhzMiArIGMyKSkge1xuICAgICAgICAgICAgICBzMiA9IHMyICsgYzI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBiaXRPdXQud3JpdGUodGFibGUuaW5kZXhPZihzMiksIGJpdExlbmd0aCk7XG4gICAgICAgICAgICAgIGlmICh0YWJsZS5zaXplKCkgPCA0MDk1KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhYmxlLnNpemUoKSA9PSAxIDw8IGJpdExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgYml0TGVuZ3RoICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhYmxlLmFkZChzMiArIGMyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzMiA9IGMyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBiaXRPdXQud3JpdGUodGFibGUuaW5kZXhPZihzMiksIGJpdExlbmd0aCk7XG4gICAgICAgICAgYml0T3V0LndyaXRlKGVuZENvZGUsIGJpdExlbmd0aCk7XG4gICAgICAgICAgYml0T3V0LmZsdXNoKCk7XG4gICAgICAgICAgcmV0dXJuIGJ5dGVPdXQudG9CeXRlQXJyYXkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGx6d1RhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9tYXAgPSB7fTtcbiAgICAgICAgICB2YXIgX3NpemUgPSAwO1xuICAgICAgICAgIHZhciBfdGhpczIgPSB7fTtcbiAgICAgICAgICBfdGhpczIuYWRkID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMyLmNvbnRhaW5zKGtleSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJkdXAga2V5OlwiICsga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX21hcFtrZXldID0gX3NpemU7XG4gICAgICAgICAgICBfc2l6ZSArPSAxO1xuICAgICAgICAgIH07XG4gICAgICAgICAgX3RoaXMyLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBfc2l6ZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIF90aGlzMi5pbmRleE9mID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gX21hcFtrZXldO1xuICAgICAgICAgIH07XG4gICAgICAgICAgX3RoaXMyLmNvbnRhaW5zID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIF9tYXBba2V5XSAhPSBcInVuZGVmaW5lZFwiO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIF90aGlzMjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfTtcbiAgICAgIHZhciBjcmVhdGVEYXRhVVJMID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgZ2V0UGl4ZWwpIHtcbiAgICAgICAgdmFyIGdpZiA9IGdpZkltYWdlKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSArPSAxKSB7XG4gICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgeCArPSAxKSB7XG4gICAgICAgICAgICBnaWYuc2V0UGl4ZWwoeCwgeSwgZ2V0UGl4ZWwoeCwgeSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYiA9IGJ5dGVBcnJheU91dHB1dFN0cmVhbSgpO1xuICAgICAgICBnaWYud3JpdGUoYik7XG4gICAgICAgIHZhciBiYXNlNjQgPSBiYXNlNjRFbmNvZGVPdXRwdXRTdHJlYW0oKTtcbiAgICAgICAgdmFyIGJ5dGVzID0gYi50b0J5dGVBcnJheSgpO1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgYnl0ZXMubGVuZ3RoOyBpMiArPSAxKSB7XG4gICAgICAgICAgYmFzZTY0LndyaXRlQnl0ZShieXRlc1tpMl0pO1xuICAgICAgICB9XG4gICAgICAgIGJhc2U2NC5mbHVzaCgpO1xuICAgICAgICByZXR1cm4gXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsXCIgKyBiYXNlNjQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHFyY29kZTM7XG4gICAgfSgpO1xuICAgICFmdW5jdGlvbigpIHtcbiAgICAgIHFyY29kZTIuc3RyaW5nVG9CeXRlc0Z1bmNzW1wiVVRGLThcIl0gPSBmdW5jdGlvbihzMikge1xuICAgICAgICBmdW5jdGlvbiB0b1VURjhBcnJheShzdHIpIHtcbiAgICAgICAgICB2YXIgdXRmOCA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBzdHIubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgICB2YXIgY2hhcmNvZGUgPSBzdHIuY2hhckNvZGVBdChpMik7XG4gICAgICAgICAgICBpZiAoY2hhcmNvZGUgPCAxMjgpIHV0ZjgucHVzaChjaGFyY29kZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyY29kZSA8IDIwNDgpIHtcbiAgICAgICAgICAgICAgdXRmOC5wdXNoKFxuICAgICAgICAgICAgICAgIDE5MiB8IGNoYXJjb2RlID4+IDYsXG4gICAgICAgICAgICAgICAgMTI4IHwgY2hhcmNvZGUgJiA2M1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyY29kZSA8IDU1Mjk2IHx8IGNoYXJjb2RlID49IDU3MzQ0KSB7XG4gICAgICAgICAgICAgIHV0ZjgucHVzaChcbiAgICAgICAgICAgICAgICAyMjQgfCBjaGFyY29kZSA+PiAxMixcbiAgICAgICAgICAgICAgICAxMjggfCBjaGFyY29kZSA+PiA2ICYgNjMsXG4gICAgICAgICAgICAgICAgMTI4IHwgY2hhcmNvZGUgJiA2M1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaTIrKztcbiAgICAgICAgICAgICAgY2hhcmNvZGUgPSA2NTUzNiArICgoY2hhcmNvZGUgJiAxMDIzKSA8PCAxMCB8IHN0ci5jaGFyQ29kZUF0KGkyKSAmIDEwMjMpO1xuICAgICAgICAgICAgICB1dGY4LnB1c2goXG4gICAgICAgICAgICAgICAgMjQwIHwgY2hhcmNvZGUgPj4gMTgsXG4gICAgICAgICAgICAgICAgMTI4IHwgY2hhcmNvZGUgPj4gMTIgJiA2MyxcbiAgICAgICAgICAgICAgICAxMjggfCBjaGFyY29kZSA+PiA2ICYgNjMsXG4gICAgICAgICAgICAgICAgMTI4IHwgY2hhcmNvZGUgJiA2M1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdXRmODtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9VVEY4QXJyYXkoczIpO1xuICAgICAgfTtcbiAgICB9KCk7XG4gICAgKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICAgIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgICB9XG4gICAgfSkoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcXJjb2RlMjtcbiAgICB9KTtcbiAgfSkocXJjb2RlJDEpO1xuICByZXR1cm4gcXJjb2RlJDEuZXhwb3J0cztcbn1cbnZhciBxcmNvZGVFeHBvcnRzID0gcmVxdWlyZVFyY29kZSgpO1xuY29uc3QgcXJjb2RlID0gLyogQF9fUFVSRV9fICovIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHFyY29kZUV4cG9ydHMpO1xuZnVuY3Rpb24gY29weVRvQ2xpcGJvYXJkKHRleHQpIHtcbiAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCEobmF2aWdhdG9yID09IG51bGwgPyB2b2lkIDAgOiBuYXZpZ2F0b3IuY2xpcGJvYXJkKSkge1xuICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdFVJRXJyb3IoXCJDbGlwYm9hcmQgQVBJIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4geWllbGQgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGV4dCk7XG4gICAgfSBjYXRjaCAoZTIpIHtcbiAgICB9XG4gICAgZmFsbGJhY2tDb3B5VGV4dFRvQ2xpcGJvYXJkKHRleHQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGZhbGxiYWNrQ29weVRleHRUb0NsaXBib2FyZCh0ZXh0KSB7XG4gIGNvbnN0IHRleHRBcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xuICB0ZXh0QXJlYS52YWx1ZSA9IHRleHQ7XG4gIHRleHRBcmVhLnN0eWxlLnRvcCA9IFwiMFwiO1xuICB0ZXh0QXJlYS5zdHlsZS5sZWZ0ID0gXCIwXCI7XG4gIHRleHRBcmVhLnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRleHRBcmVhKTtcbiAgdGV4dEFyZWEuZm9jdXMoKTtcbiAgdGV4dEFyZWEuc2VsZWN0KCk7XG4gIHRyeSB7XG4gICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJjb3B5XCIpO1xuICB9IGZpbmFsbHkge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGV4dEFyZWEpO1xuICB9XG59XG52YXIgX3RtcGwkJHMgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPGRpdj5gKTtcbmNvbnN0IFFSQ29kZSA9IChwcm9wcykgPT4ge1xuICBsZXQgcXJDb2RlQ2FudmFzUmVmO1xuICBsZXQgcXJDb2RlV3JhcHBlclJlZjtcbiAgbGV0IGltYWdlUmVmO1xuICBjb25zdCBbY29weUJ1dHRvbk9wZW5lZCwgc2V0Q29weUJ1dHRvbk9wZW5lZF0gPSBjcmVhdGVTaWduYWwoZmFsc2UpO1xuICBjb25zdCBbcGljU2l6ZSwgc2V0UGljU2l6ZV0gPSBjcmVhdGVTaWduYWwocGljU2l6ZURlZmF1bHQpO1xuICBjcmVhdGVFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGVycm9yQ29ycmVjdGlvbkxldmVsID0gXCJMXCI7XG4gICAgY29uc3QgY2VsbFNpemUgPSA0O1xuICAgIGNvbnN0IHFyID0gcXJjb2RlKDAsIGVycm9yQ29ycmVjdGlvbkxldmVsKTtcbiAgICBxci5hZGREYXRhKHByb3BzLnNvdXJjZVVybCk7XG4gICAgcXIubWFrZSgpO1xuICAgIHFyQ29kZUNhbnZhc1JlZi5pbm5lckhUTUwgPSBxci5jcmVhdGVTdmdUYWcoY2VsbFNpemUsIDApO1xuICAgIGNvbnN0IHFyU2l6ZSA9IHFyQ29kZUNhbnZhc1JlZi5maXJzdEVsZW1lbnRDaGlsZC5jbGllbnRXaWR0aDtcbiAgICBjb25zdCBzY2FsZSA9IE1hdGgucm91bmQocXJOb3JtYWxTaXplIC8gcXJTaXplICogMWU1KSAvIDFlNTtcbiAgICBpZiAoaW1hZ2VSZWYpIHtcbiAgICAgIGNvbnN0IGltZ1NpemUgPSBNYXRoLmNlaWwoaW1nU2l6ZURlZmF1bHQgLyAoc2NhbGUgKiBjZWxsU2l6ZSkpICogY2VsbFNpemU7XG4gICAgICBjb25zdCBpbWdPZmZzZXQgPSB0b1B4KE1hdGguY2VpbCgocXJTaXplIC0gaW1nU2l6ZSkgLyAoMiAqIGNlbGxTaXplKSkgKiBjZWxsU2l6ZSk7XG4gICAgICBpbWFnZVJlZi5zdHlsZS50b3AgPSBpbWdPZmZzZXQ7XG4gICAgICBpbWFnZVJlZi5zdHlsZS5sZWZ0ID0gaW1nT2Zmc2V0O1xuICAgICAgaW1hZ2VSZWYuc3R5bGUuaGVpZ2h0ID0gdG9QeChpbWdTaXplKTtcbiAgICAgIGltYWdlUmVmLnN0eWxlLndpZHRoID0gdG9QeChpbWdTaXplKTtcbiAgICAgIHNldFBpY1NpemUoTWF0aC5yb3VuZChwaWNTaXplRGVmYXVsdCAvIHNjYWxlKSk7XG4gICAgfVxuICAgIHFyQ29kZVdyYXBwZXJSZWYuc3R5bGUudHJhbnNmb3JtID0gYHNjYWxlKCR7c2NhbGV9KWA7XG4gIH0pO1xuICBsZXQgdGltZW91dElkID0gbnVsbDtcbiAgY29uc3Qgb25Db3B5Q2xpY2sgPSAoKSA9PiB7XG4gICAgc2V0Q29weUJ1dHRvbk9wZW5lZCh0cnVlKTtcbiAgICBjb3B5VG9DbGlwYm9hcmQocHJvcHMuc291cmNlVXJsKTtcbiAgICBpZiAodGltZW91dElkICE9IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH1cbiAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHNldENvcHlCdXR0b25PcGVuZWQoZmFsc2UpLCAxNTAwKTtcbiAgfTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChRckNvZGVCYWNrZ3JvdW5kLCB7XG4gICAgZ2V0IFtcImNsYXNzXCJdKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgIH0sXG4gICAgb25DbGljazogb25Db3B5Q2xpY2ssXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoUXJDb2RlV3JhcHBlciQyLCB7XG4gICAgICAgIHJlZihyJCkge1xuICAgICAgICAgIHZhciBfcmVmJCA9IHFyQ29kZVdyYXBwZXJSZWY7XG4gICAgICAgICAgdHlwZW9mIF9yZWYkID09PSBcImZ1bmN0aW9uXCIgPyBfcmVmJChyJCkgOiBxckNvZGVXcmFwcGVyUmVmID0gciQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gWygoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2VsJCA9IF90bXBsJCRzKCk7XG4gICAgICAgICAgICB2YXIgX3JlZiQyID0gcXJDb2RlQ2FudmFzUmVmO1xuICAgICAgICAgICAgdHlwZW9mIF9yZWYkMiA9PT0gXCJmdW5jdGlvblwiID8gdXNlKF9yZWYkMiwgX2VsJCkgOiBxckNvZGVDYW52YXNSZWYgPSBfZWwkO1xuICAgICAgICAgICAgcmV0dXJuIF9lbCQ7XG4gICAgICAgICAgfSkoKSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuaW1hZ2VVcmw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEltYWdlQmFja2dyb3VuZCwge1xuICAgICAgICAgICAgICAgIHJlZihyJCkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9yZWYkMyA9IGltYWdlUmVmO1xuICAgICAgICAgICAgICAgICAgdHlwZW9mIF9yZWYkMyA9PT0gXCJmdW5jdGlvblwiID8gX3JlZiQzKHIkKSA6IGltYWdlUmVmID0gciQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEltYWdlU3R5bGVkJDMsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IHNyYygpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuaW1hZ2VVcmw7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFsdDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0IHNpemUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBpY1NpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KV07XG4gICAgICAgIH1cbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoVHJhbnNpdGlvbiwge1xuICAgICAgICBvbkJlZm9yZUVudGVyOiAoZWwpID0+IHtcbiAgICAgICAgICBhbmltYXRlKGVsLCBbe1xuICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoLTUwJSwgNDRweClcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKC01MCUsIDApXCJcbiAgICAgICAgICB9XSwge1xuICAgICAgICAgICAgZHVyYXRpb246IDE1MCxcbiAgICAgICAgICAgIGVhc2luZzogXCJlYXNlLW91dFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXhpdDogKGVsLCBkb25lKSA9PiB7XG4gICAgICAgICAgYW5pbWF0ZShlbCwgW3tcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKC01MCUsIDApXCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgtNTAlLCA0NHB4KVwiXG4gICAgICAgICAgfV0sIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiAxNTAsXG4gICAgICAgICAgICBlYXNpbmc6IFwiZWFzZS1vdXRcIlxuICAgICAgICAgIH0pLmZpbmlzaGVkLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvcHlCdXR0b25PcGVuZWQoKSAmJiAhcHJvcHMuZGlzYWJsZUNvcHk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KENvcGllZEJveFN0eWxlZCwge1xuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFN1Y2Nlc3NJY29uLCB7XG4gICAgICAgICAgICAgICAgICAgIHNpemU6IFwieHNcIlxuICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChUZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcImNvbW1vbi5saW5rQ29waWVkXCIsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkxpbmsgQ29waWVkXCJcbiAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgcmV0dXJuICFwcm9wcy5kaXNhYmxlQ29weTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQ29weUljb25CdXR0b24sIHtcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChDb3B5TGlnaHRJY29uLCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pXTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciBkZWVwUmVhZE9iamVjdCA9IChvYmosIHBhdGgsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICBjb25zdCB2YWx1ZSA9IHBhdGgudHJpbSgpLnNwbGl0KFwiLlwiKS5yZWR1Y2UoKGEyLCBiKSA9PiBhMiA/IGEyW2JdIDogdm9pZCAwLCBvYmopO1xuICByZXR1cm4gdmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xufTtcbnZhciB0ZW1wbGF0ZSA9IChzdHIsIHBhcmFtcywgcmVnID0gL3t7KC4qPyl9fS9nKSA9PiBzdHIucmVwbGFjZShyZWcsIChfLCBrZXkpID0+IGRlZXBSZWFkT2JqZWN0KHBhcmFtcywga2V5LCBcIlwiKSk7XG52YXIgY3JlYXRlSTE4bkNvbnRleHQgPSAoaW5pdCA9IHt9LCBsYW5nID0gbmF2aWdhdG9yLmxhbmd1YWdlIGluIGluaXQgPyBuYXZpZ2F0b3IubGFuZ3VhZ2UgOiBPYmplY3Qua2V5cyhpbml0KVswXSkgPT4ge1xuICBjb25zdCBbbG9jYWxlLCBzZXRMb2NhbGVdID0gY3JlYXRlU2lnbmFsKGxhbmcpO1xuICBjb25zdCBbZGljdCwgc2V0RGljdF0gPSBjcmVhdGVTdG9yZShpbml0KTtcbiAgY29uc3QgdHJhbnNsYXRlID0gKGtleSwgcGFyYW1zLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgICBjb25zdCB2YWwgPSBkZWVwUmVhZE9iamVjdChkaWN0W2xvY2FsZSgpXSwga2V5LCBkZWZhdWx0VmFsdWUgfHwgXCJcIik7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHJldHVybiB2YWwocGFyYW1zKTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiB0ZW1wbGF0ZSh2YWwsIHBhcmFtcyB8fCB7fSk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcbiAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICBhZGQobGFuZzIsIHRhYmxlKSB7XG4gICAgICBzZXREaWN0KGxhbmcyLCAodDIpID0+IE9iamVjdC5hc3NpZ24odDIgfHwge30sIHRhYmxlKSk7XG4gICAgfSxcbiAgICBsb2NhbGU6IChsYW5nMikgPT4gbGFuZzIgPyBzZXRMb2NhbGUobGFuZzIpIDogbG9jYWxlKCksXG4gICAgZGljdDogKGxhbmcyKSA9PiBkZWVwUmVhZE9iamVjdChkaWN0LCBsYW5nMilcbiAgfTtcbiAgcmV0dXJuIFt0cmFuc2xhdGUsIGFjdGlvbnNdO1xufTtcbnZhciBJMThuQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pO1xudmFyIHVzZUkxOG4gPSAoKSA9PiB1c2VDb250ZXh0KEkxOG5Db250ZXh0KTtcbmNvbnN0IFRleHRTdHlsZWQkNCA9IHN0eWxlZC5kaXZgXG4gICAgZm9udC1zdHlsZTogbm9ybWFsO1xuICAgIGZvbnQtd2VpZ2h0OiAkeyhwcm9wcykgPT4gcHJvcHMuZm9udFdlaWdodH07XG4gICAgZm9udC1zaXplOiAkeyhwcm9wcykgPT4gcHJvcHMuZm9udFNpemV9O1xuICAgIGxpbmUtaGVpZ2h0OiAkeyhwcm9wcykgPT4gcHJvcHMubGluZUhlaWdodH07XG5cbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLmNvbG9yfTtcbmA7XG5jb25zdCBUZXh0ID0gKGlucHV0cykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IFt0Ml0gPSB1c2VJMThuKCk7XG4gIGxldCB0ZXh0UmVmO1xuICBjb25zdCBjb2xvciA9ICgpID0+IGlucHV0cy5jb2xvciB8fCB0aGVtZS5jb2xvcnMudGV4dC5wcmltYXJ5O1xuICBjb25zdCBwcm9wcyA9IG1lcmdlUHJvcHMoe1xuICAgIGZvbnRTaXplOiBcIjE0cHhcIixcbiAgICBmb250V2VpZ2h0OiBcIjUxMFwiLFxuICAgIGxpbmVIZWlnaHQ6IFwiMTMwJVwiXG4gIH0sIGlucHV0cyk7XG4gIGNyZWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF0ZXh0UmVmKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcm9wcy5jdXJzb3IgPT09IFwidW5zZXRcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZSh0ZXh0UmVmKS5jdXJzb3IgIT09IFwicG9pbnRlclwiKSB7XG4gICAgICB0ZXh0UmVmLnN0eWxlLmN1cnNvciA9IFwiZGVmYXVsdFwiO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoVGV4dFN0eWxlZCQ0LCB7XG4gICAgZ2V0IGZvbnRTaXplKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmZvbnRTaXplO1xuICAgIH0sXG4gICAgZ2V0IGZvbnRXZWlnaHQoKSB7XG4gICAgICByZXR1cm4gcHJvcHMuZm9udFdlaWdodDtcbiAgICB9LFxuICAgIGdldCBsaW5lSGVpZ2h0KCkge1xuICAgICAgcmV0dXJuIHByb3BzLmxpbmVIZWlnaHQ7XG4gICAgfSxcbiAgICBnZXQgY29sb3IoKSB7XG4gICAgICByZXR1cm4gY29sb3IoKTtcbiAgICB9LFxuICAgIGdldCBbXCJjbGFzc1wiXSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5jbGFzcztcbiAgICB9LFxuICAgIHJlZihyJCkge1xuICAgICAgdmFyIF9yZWYkID0gdGV4dFJlZjtcbiAgICAgIHR5cGVvZiBfcmVmJCA9PT0gXCJmdW5jdGlvblwiID8gX3JlZiQociQpIDogdGV4dFJlZiA9IHIkO1xuICAgIH0sXG4gICAgXCJkYXRhLXRjLXRleHRcIjogXCJ0cnVlXCIsXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIHJldHVybiBtZW1vKCgpID0+ICEhcHJvcHMudHJhbnNsYXRpb25LZXkpKCkgPyB0Mihwcm9wcy50cmFuc2xhdGlvbktleSwgcHJvcHMudHJhbnNsYXRpb25WYWx1ZXMsIChfYTIgPSBwcm9wcy5jaGlsZHJlbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi50b1N0cmluZygpKSA6IHByb3BzLmNoaWxkcmVuO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3QgSW1hZ2VDb250YWluZXIgPSBzdHlsZWQuZGl2YFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcblxuICAgICY6OmFmdGVyIHtcbiAgICAgICAgY29udGVudDogJyc7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgYm9yZGVyOiAwLjVweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMDgpO1xuICAgICAgICBib3JkZXItcmFkaXVzOiBpbmhlcml0O1xuICAgIH1cbmA7XG5jb25zdCBJbWFnZVN0eWxlZCQyID0gc3R5bGVkKEltYWdlKWBcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgYm9yZGVyLXJhZGl1czogaW5oZXJpdDtcbmA7XG5jb25zdCBXYWxsZXRJbWFnZSA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEltYWdlQ29udGFpbmVyLCB7XG4gICAgZ2V0IFtcImNsYXNzXCJdKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgIH0sXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoSW1hZ2VTdHlsZWQkMiwge1xuICAgICAgICBnZXQgc3JjKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wcy5zcmM7XG4gICAgICAgIH1cbiAgICAgIH0pLCBtZW1vKCgpID0+IHByb3BzLmJhZGdlKV07XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBib3JkZXJzJDQgPSB7XG4gIG06IFwiMTZweFwiLFxuICBzOiBcIjEycHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCBiYWRnZUJvcmRlcnMgPSB7XG4gIG06IFwiNnB4XCIsXG4gIHM6IFwiNnB4XCIsXG4gIG5vbmU6IFwiMFwiXG59O1xuY29uc3QgV2FsbGV0VWxDb250YWluZXIgPSBzdHlsZWQudWxgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBnYXA6IDA7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgb3ZlcmZsb3cteDogYXV0bztcbiAgICBwYWRkaW5nOiA4cHggMTJweCAxNnB4IDEycHg7XG4gICAgbWFyZ2luOiAwO1xuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgZmxleC13cmFwOiBub3dyYXA7XG5cbiAgICAmJjo6LXdlYmtpdC1zY3JvbGxiYXIge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cbiAgICAtbXMtb3ZlcmZsb3ctc3R5bGU6IG5vbmU7XG4gICAgc2Nyb2xsYmFyLXdpZHRoOiBub25lO1xuXG4gICAgPiBsaSB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgICAgIG1pbi13aWR0aDogNzhweDtcbiAgICAgICAgaGVpZ2h0OiBmaXQtY29udGVudDtcbiAgICB9XG5cbiAgICA+IGxpID4gYnV0dG9uIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgfVxuYDtcbmNvbnN0IFdhbGxldEl0ZW1TdHlsZWQgPSBzdHlsZWQuYnV0dG9uYFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgYm9yZGVyOiBub25lO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHVuc2V0O1xuICAgIHBhZGRpbmc6IDhweCA0cHg7XG4gICAgbWluLXdpZHRoOiA3OHB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMTI1cyBlYXNlLWluLW91dDtcblxuICAgICR7bWVkaWFOb3RUb3VjaH0ge1xuICAgICAgICAmOmhvdmVyIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMS4wNCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAmOmFjdGl2ZSB7XG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC45Nik7XG4gICAgfVxuXG4gICAgJHttZWRpYVRvdWNofSB7XG4gICAgICAgICY6YWN0aXZlIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC45Mik7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuY29uc3QgSW1hZ2VTdHlsZWQkMSA9IHN0eWxlZChXYWxsZXRJbWFnZSlgXG4gICAgd2lkdGg6IDYwcHg7XG4gICAgaGVpZ2h0OiA2MHB4O1xuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiBib3JkZXJzJDRbcHJvcHMudGhlbWUuYm9yZGVyUmFkaXVzXX07XG4gICAgbWFyZ2luLWJvdHRvbTogOHB4O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbmA7XG5jb25zdCBCYWRnZVN0eWxlZCA9IHN0eWxlZChJbWFnZSlgXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHJpZ2h0OiAtNnB4O1xuICAgIGJvdHRvbTogLTZweDtcbiAgICB3aWR0aDogMjRweDtcbiAgICBoZWlnaHQ6IDI0cHg7XG4gICAgYm9yZGVyLXJhZGl1czogJHsocHJvcHMpID0+IGJhZGdlQm9yZGVyc1twcm9wcy50aGVtZS5ib3JkZXJSYWRpdXNdfTtcbiAgICBib3gtc2hhZG93OiAwIDJweCA4cHggMCByZ2JhKDAsIDAsIDAsIDAuMDgpO1xuYDtcbmNvbnN0IFN0eWxlZFRleHQgPSBzdHlsZWQoVGV4dClgXG4gICAgbWF4LXdpZHRoOiA5MHB4O1xuICAgIGZvbnQtd2VpZ2h0OiA1MTA7XG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuXG4gICAgJHttZWRpYShcIm1vYmlsZVwiKX0ge1xuICAgICAgICBtYXgtd2lkdGg6IDgwcHg7XG4gICAgfVxuYDtcbmNvbnN0IFN0eWxlZFNlY29uZExpbmUgPSBzdHlsZWQoVGV4dClgXG4gICAgZm9udC13ZWlnaHQ6ICR7KHByb3BzKSA9PiBwcm9wcy5jb2xvclByaW1hcnkgPyBcIjUxMFwiIDogXCI0MDBcIn07XG4gICAgbWF4LXdpZHRoOiA5MHB4O1xuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLmNvbG9yUHJpbWFyeSA/IHByb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnByaW1hcnkgOiBwcm9wcy50aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnl9O1xuXG4gICAgJHttZWRpYShcIm1vYmlsZVwiKX0ge1xuICAgICAgICBtYXgtd2lkdGg6IDgwcHg7XG4gICAgfVxuYDtcbnZhciBfdG1wbCQkciA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8ZGl2PmApO1xuY29uc3QgV2FsbGV0SXRlbSA9IChwcm9wcykgPT4ge1xuICBsZXQgY3R4UmVmID0gbnVsbDtcbiAgY29uc3QgYWRqdXN0TGV0dGVyU3BhY2luZyA9ICgpID0+IHtcbiAgICBjb25zdCBuYW1lID0gY3R4UmVmID09IG51bGwgPyB2b2lkIDAgOiBjdHhSZWYucXVlcnlTZWxlY3RvcihcImRpdlwiKTtcbiAgICBpZiAobmFtZSAmJiBuYW1lLnNjcm9sbFdpZHRoID4gbmFtZS5jbGllbnRXaWR0aCkge1xuICAgICAgbGV0IHNwYWNpbmcgPSAwO1xuICAgICAgY29uc3QgbWluU3BhY2luZyA9IC0wLjQ7XG4gICAgICBjb25zdCBzdGVwID0gMC4wNTtcbiAgICAgIHdoaWxlIChuYW1lLnNjcm9sbFdpZHRoID4gbmFtZS5jbGllbnRXaWR0aCAmJiBzcGFjaW5nID49IG1pblNwYWNpbmcpIHtcbiAgICAgICAgc3BhY2luZyAtPSBzdGVwO1xuICAgICAgICBuYW1lLnN0eWxlLmxldHRlclNwYWNpbmcgPSBgJHtzcGFjaW5nfXB4YDtcbiAgICAgIH1cbiAgICAgIGlmIChzcGFjaW5nICE9PSAwKSB7XG4gICAgICAgIHNwYWNpbmcgLT0gc3RlcDtcbiAgICAgICAgbmFtZS5zdHlsZS5sZXR0ZXJTcGFjaW5nID0gYCR7c3BhY2luZ31weGA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBvbk1vdW50KCgpID0+IGFkanVzdExldHRlclNwYWNpbmcoKSk7XG4gIGNyZWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgYWRqdXN0TGV0dGVyU3BhY2luZygpO1xuICB9KTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChXYWxsZXRJdGVtU3R5bGVkLCB7XG4gICAgZ2V0IFtcImNsYXNzXCJdKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgIH0sXG4gICAgb25DbGljazogKCkgPT4gcHJvcHMub25DbGljaygpLFxuICAgIFwiZGF0YS10Yy13YWxsZXQtaXRlbVwiOiBcInRydWVcIixcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gW21lbW8oKCkgPT4gbWVtbygoKSA9PiB0eXBlb2YgcHJvcHMuaWNvbiA9PT0gXCJzdHJpbmdcIikoKSA/IGNyZWF0ZUNvbXBvbmVudChJbWFnZVN0eWxlZCQxLCB7XG4gICAgICAgIGdldCBzcmMoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLmljb247XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBiYWRnZSgpIHtcbiAgICAgICAgICByZXR1cm4gbWVtbygoKSA9PiAhIXByb3BzLmJhZGdlVXJsKSgpICYmIGNyZWF0ZUNvbXBvbmVudChCYWRnZVN0eWxlZCwge1xuICAgICAgICAgICAgZ2V0IHNyYygpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLmJhZGdlVXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSA6IHByb3BzLmljb24pLCAoKCkgPT4ge1xuICAgICAgICB2YXIgX2VsJCA9IF90bXBsJCRyKCk7XG4gICAgICAgIHVzZSgoZWwpID0+IGN0eFJlZiA9IGVsLCBfZWwkKTtcbiAgICAgICAgaW5zZXJ0KF9lbCQsIGNyZWF0ZUNvbXBvbmVudChTdHlsZWRUZXh0LCB7XG4gICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBfZWwkO1xuICAgICAgfSkoKSwgbWVtbygoKSA9PiBtZW1vKCgpID0+ICEhcHJvcHMuc2Vjb25kTGluZSkoKSAmJiBjcmVhdGVDb21wb25lbnQoU3R5bGVkU2Vjb25kTGluZSwge1xuICAgICAgICBnZXQgY29sb3JQcmltYXJ5KCkge1xuICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgcmV0dXJuIChfYTIgPSBwcm9wcy5zZWNvbmRMaW5lQ29sb3JQcmltYXJ5KSAhPSBudWxsID8gX2EyIDogdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wcy5zZWNvbmRMaW5lO1xuICAgICAgICB9XG4gICAgICB9KSldO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3QgSDFTdHlsZWQkYiA9IHN0eWxlZC5oMWBcbiAgICBmb250LXN0eWxlOiBub3JtYWw7XG4gICAgZm9udC13ZWlnaHQ6IDU5MDtcbiAgICBmb250LXNpemU6IDIwcHg7XG4gICAgbGluZS1oZWlnaHQ6IDI4cHg7XG5cbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG5cbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnByaW1hcnl9O1xuXG4gICAgbWFyZ2luLXRvcDogMDtcbiAgICBtYXJnaW4tYm90dG9tOiAwO1xuXG4gICAgY3Vyc29yOiBkZWZhdWx0O1xuYDtcbmNvbnN0IEgxID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IFt0Ml0gPSB1c2VJMThuKCk7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoSDFTdHlsZWQkYiwge1xuICAgIGdldCBbXCJjbGFzc1wiXSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5jbGFzcztcbiAgICB9LFxuICAgIFwiZGF0YS10Yy1oMVwiOiBcInRydWVcIixcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgcmV0dXJuIG1lbW8oKCkgPT4gISFwcm9wcy50cmFuc2xhdGlvbktleSkoKSA/IHQyKHByb3BzLnRyYW5zbGF0aW9uS2V5LCBwcm9wcy50cmFuc2xhdGlvblZhbHVlcywgKF9hMiA9IHByb3BzLmNoaWxkcmVuKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnRvU3RyaW5nKCkpIDogcHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBIMlN0eWxlZCQ1ID0gc3R5bGVkLmgyYFxuICAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcbiAgICBmb250LXdlaWdodDogNDAwO1xuICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICBsaW5lLWhlaWdodDogMjJweDtcblxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcblxuICAgIGNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5fTtcblxuICAgIG1hcmdpbi10b3A6IDA7XG4gICAgbWFyZ2luLWJvdHRvbTogMzJweDtcblxuICAgIGN1cnNvcjogZGVmYXVsdDtcbmA7XG5jb25zdCBIMiA9IChwcm9wcykgPT4ge1xuICBjb25zdCBbdDJdID0gdXNlSTE4bigpO1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEgyU3R5bGVkJDUsIHtcbiAgICBnZXQgW1wiY2xhc3NcIl0oKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2xhc3M7XG4gICAgfSxcbiAgICBcImRhdGEtdGMtaDJcIjogXCJ0cnVlXCIsXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIHJldHVybiBtZW1vKCgpID0+ICEhcHJvcHMudHJhbnNsYXRpb25LZXkpKCkgPyB0Mihwcm9wcy50cmFuc2xhdGlvbktleSwgcHJvcHMudHJhbnNsYXRpb25WYWx1ZXMsIChfYTIgPSBwcm9wcy5jaGlsZHJlbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi50b1N0cmluZygpKSA6IHByb3BzLmNoaWxkcmVuO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3QgSDNTdHlsZWQkMiA9IHN0eWxlZC5oM2BcbiAgICBmb250LXN0eWxlOiBub3JtYWw7XG4gICAgZm9udC13ZWlnaHQ6IDUxMDtcbiAgICBmb250LXNpemU6IDE2cHg7XG4gICAgbGluZS1oZWlnaHQ6IDIwcHg7XG5cbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnByaW1hcnl9O1xuXG4gICAgbWFyZ2luLXRvcDogMDtcbiAgICBtYXJnaW4tYm90dG9tOiAwO1xuXG4gICAgY3Vyc29yOiBkZWZhdWx0O1xuYDtcbmNvbnN0IEgzID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IFt0Ml0gPSB1c2VJMThuKCk7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoSDNTdHlsZWQkMiwge1xuICAgIFwiZGF0YS10Yy1oM1wiOiBcInRydWVcIixcbiAgICBnZXQgW1wiY2xhc3NcIl0oKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2xhc3M7XG4gICAgfSxcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgcmV0dXJuIG1lbW8oKCkgPT4gISFwcm9wcy50cmFuc2xhdGlvbktleSkoKSA/IHQyKHByb3BzLnRyYW5zbGF0aW9uS2V5LCBwcm9wcy50cmFuc2xhdGlvblZhbHVlcywgKF9hMiA9IHByb3BzLmNoaWxkcmVuKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnRvU3RyaW5nKCkpIDogcHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICB9KTtcbn07XG52YXIgX3RtcGwkJHEgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB3aWR0aD0yNCBoZWlnaHQ9MjQgdmlld0JveD1cIjAgMCAyNCAyNFwiZmlsbD1ub25lIHhtbG5zPWh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnPjxwYXRoIGZpbGwtcnVsZT1ldmVub2RkIGNsaXAtcnVsZT1ldmVub2RkIGQ9XCJNMTQuMTgzOSAxNy43MDY5QzEzLjY0MDUgMTguNjUwNyAxMy4zNjg4IDE5LjEyMjYgMTMuMDU5MSAxOS4zNDhDMTIuNDI3OCAxOS44MDc0IDExLjU3MjMgMTkuODA3NCAxMC45NDEgMTkuMzQ4QzEwLjYzMTIgMTkuMTIyNiAxMC4zNTk1IDE4LjY1MDcgOS44MTYxMyAxNy43MDY5TDUuNTIwNjYgMTAuMjQ2NEM0Ljc2ODY0IDguOTQwMjQgNC4zOTI2MyA4LjI4NzE3IDQuMzM3NjIgNy43NTg5NEM0LjIyNTUgNi42ODIzNiA0LjgxODk0IDUuNjU1OTEgNS44MDc4OCA1LjIxNTg5QzYuMjkzMDkgNSA3LjA0NjY3IDUgOC41NTM4MyA1SDE1LjQ0NjJDMTYuOTUzNCA1IDE3LjcwNjkgNSAxOC4xOTIyIDUuMjE1ODlDMTkuMTgxMSA1LjY1NTkxIDE5Ljc3NDUgNi42ODIzNiAxOS42NjI0IDcuNzU4OTRDMTkuNjA3NCA4LjI4NzE3IDE5LjIzMTQgOC45NDAyNCAxOC40Nzk0IDEwLjI0NjRMMTQuMTgzOSAxNy43MDY5Wk0xMS4xIDE2LjM0MTJMNi41NjEzOSA4LjQ4MDAyQzYuMzE5OTUgOC4wNjE4NSA2LjE5OTI0IDcuODUyNzYgNi4xODE0NiA3LjY4MzY1QzYuMTQ1MjMgNy4zMzg5NiA2LjMzNTA3IDcuMDEwMTUgNi42NTE2OSA2Ljg2OTE5QzYuODA3MDMgNi44MDAwMiA3LjA0ODQ3IDYuODAwMDIgNy41MzEzMyA2LjgwMDAySDcuNTMxMzRMMTEuMSA2LjgwMDAyVjE2LjM0MTJaTTEyLjkgMTYuMzQxMkwxNy40Mzg3IDguNDgwMDJDMTcuNjgwMSA4LjA2MTg1IDE3LjgwMDggNy44NTI3NiAxNy44MTg2IDcuNjgzNjVDMTcuODU0OCA3LjMzODk2IDE3LjY2NSA3LjAxMDE1IDE3LjM0ODQgNi44NjkxOUMxNy4xOTMgNi44MDAwMiAxNi45NTE2IDYuODAwMDIgMTYuNDY4NyA2LjgwMDAyTDEyLjkgNi44MDAwMlYxNi4zNDEyWlwiPmApO1xuY29uc3QgVG9uSWNvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IGZpbGwgPSAoKSA9PiBwcm9wcy5maWxsIHx8IHRoZW1lLmNvbG9ycy5pY29uLnByaW1hcnk7XG4gIHJldHVybiAoKCkgPT4ge1xuICAgIHZhciBfZWwkID0gX3RtcGwkJHEoKSwgX2VsJDIgPSBfZWwkLmZpcnN0Q2hpbGQ7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KCgpID0+IHNldEF0dHJpYnV0ZShfZWwkMiwgXCJmaWxsXCIsIGZpbGwoKSkpO1xuICAgIHJldHVybiBfZWwkO1xuICB9KSgpO1xufTtcbnZhciBfdG1wbCQkcCA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8c3ZnIHhtbG5zPWh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIHdpZHRoPTE2IGhlaWdodD0xNiB2aWV3Qm94PVwiMCAwIDE2IDE2XCJmaWxsPW5vbmU+PGcgY2xpcC1wYXRoPXVybCgjY2xpcDBfMzc4M18yMDQ1KT48Y2lyY2xlIGN4PTggY3k9OC4wMDA5OCByPTg+PC9jaXJjbGU+PHBhdGggZD1cIk00Ljc1IDguNTAwOThMNyAxMC43NTFMMTEuNzUgNi4wMDA5OFwic3Ryb2tlLXdpZHRoPTEuNSBzdHJva2UtbGluZWNhcD1yb3VuZCBzdHJva2UtbGluZWpvaW49cm91bmQ+PC9wYXRoPjwvZz48ZGVmcz48Y2xpcFBhdGggaWQ9Y2xpcDBfMzc4M18yMDQ1PjxyZWN0IHdpZHRoPTE2IGhlaWdodD0xNiBmaWxsPXdoaXRlIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgwIDAuMDAwOTc2NTYyKVwiPmApLCBfdG1wbCQyJDQgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB3aWR0aD0yNCBoZWlnaHQ9MjQgdmlld0JveD1cIjAgMCAyNCAyNFwiZmlsbD1ub25lIHhtbG5zPWh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnPjxjaXJjbGUgY3g9MTIgY3k9MTIgcj0xMT48L2NpcmNsZT48cGF0aCBkPVwiTTE3LjEzNjQgOS42MzY0QzE3LjQ4NzkgOS4yODQ5MyAxNy40ODc5IDguNzE1MDggMTcuMTM2NCA4LjM2MzYxQzE2Ljc4NDkgOC4wMTIxNCAxNi4yMTUxIDguMDEyMTQgMTUuODYzNiA4LjM2MzYxTDEwIDE0LjIyNzJMOC4xMzY0IDEyLjM2MzZDNy43ODQ5MyAxMi4wMTIxIDcuMjE1MDggMTIuMDEyMSA2Ljg2MzYxIDEyLjM2MzZDNi41MTIxNCAxMi43MTUxIDYuNTEyMTQgMTMuMjg0OSA2Ljg2MzYxIDEzLjYzNjRMOS4zNjM2MSAxNi4xMzY0QzkuNzE1MDggMTYuNDg3OSAxMC4yODQ5IDE2LjQ4NzkgMTAuNjM2NCAxNi4xMzY0TDE3LjEzNjQgOS42MzY0WlwiPmApLCBfdG1wbCQzJDIgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB3aWR0aD03MiBoZWlnaHQ9NzIgdmlld0JveD1cIjAgMCA3MiA3MlwiZmlsbD1ub25lIHhtbG5zPWh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnPjxjaXJjbGUgY3g9MzYgY3k9MzYgcj0zMz48L2NpcmNsZT48cGF0aCBkPVwiTTUwLjkxNDIgMjguNDE0MkM1MS42OTUzIDI3LjYzMzIgNTEuNjk1MyAyNi4zNjY4IDUwLjkxNDIgMjUuNTg1OEM1MC4xMzMyIDI0LjgwNDcgNDguODY2OCAyNC44MDQ3IDQ4LjA4NTggMjUuNTg1OEwzMCA0My42NzE2TDIzLjkxNDIgMzcuNTg1OEMyMy4xMzMyIDM2LjgwNDcgMjEuODY2OCAzNi44MDQ3IDIxLjA4NTggMzcuNTg1OEMyMC4zMDQ3IDM4LjM2NjggMjAuMzA0NyAzOS42MzMyIDIxLjA4NTggNDAuNDE0MkwyOC41ODU4IDQ3LjkxNDJDMjkuMzY2OCA0OC42OTUzIDMwLjYzMzIgNDguNjk1MyAzMS40MTQyIDQ3LjkxNDJMNTAuOTE0MiAyOC40MTQyWlwiPmApO1xuY29uc3QgU3VjY2Vzc0ljb24gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCBzaXplID0gKCkgPT4gcHJvcHMuc2l6ZSB8fCBcInNcIjtcbiAgY29uc3QgZmlsbCA9ICgpID0+IHByb3BzLmZpbGwgfHwgdGhlbWUuY29sb3JzLmljb24uc3VjY2VzcztcbiAgcmV0dXJuIG1lbW8oKCkgPT4gbWVtbygoKSA9PiBzaXplKCkgPT09IFwieHNcIikoKSA/ICgoKSA9PiB7XG4gICAgdmFyIF9lbCQgPSBfdG1wbCQkcCgpLCBfZWwkMiA9IF9lbCQuZmlyc3RDaGlsZCwgX2VsJDMgPSBfZWwkMi5maXJzdENoaWxkLCBfZWwkNCA9IF9lbCQzLm5leHRTaWJsaW5nO1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoX3AkKSA9PiB7XG4gICAgICB2YXIgX3YkID0gcHJvcHMuY2xhc3MsIF92JDIgPSBmaWxsKCksIF92JDMgPSB0aGVtZS5jb2xvcnMuY29uc3RhbnQud2hpdGU7XG4gICAgICBfdiQgIT09IF9wJC5lICYmIHNldEF0dHJpYnV0ZShfZWwkLCBcImNsYXNzXCIsIF9wJC5lID0gX3YkKTtcbiAgICAgIF92JDIgIT09IF9wJC50ICYmIHNldEF0dHJpYnV0ZShfZWwkMywgXCJmaWxsXCIsIF9wJC50ID0gX3YkMik7XG4gICAgICBfdiQzICE9PSBfcCQuYSAmJiBzZXRBdHRyaWJ1dGUoX2VsJDQsIFwic3Ryb2tlXCIsIF9wJC5hID0gX3YkMyk7XG4gICAgICByZXR1cm4gX3AkO1xuICAgIH0sIHtcbiAgICAgIGU6IHZvaWQgMCxcbiAgICAgIHQ6IHZvaWQgMCxcbiAgICAgIGE6IHZvaWQgMFxuICAgIH0pO1xuICAgIHJldHVybiBfZWwkO1xuICB9KSgpIDogbWVtbygoKSA9PiBzaXplKCkgPT09IFwic1wiKSgpID8gKCgpID0+IHtcbiAgICB2YXIgX2VsJDUgPSBfdG1wbCQyJDQoKSwgX2VsJDYgPSBfZWwkNS5maXJzdENoaWxkLCBfZWwkNyA9IF9lbCQ2Lm5leHRTaWJsaW5nO1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoX3AkKSA9PiB7XG4gICAgICB2YXIgX3YkNCA9IHByb3BzLmNsYXNzLCBfdiQ1ID0gZmlsbCgpLCBfdiQ2ID0gdGhlbWUuY29sb3JzLmNvbnN0YW50LndoaXRlO1xuICAgICAgX3YkNCAhPT0gX3AkLmUgJiYgc2V0QXR0cmlidXRlKF9lbCQ1LCBcImNsYXNzXCIsIF9wJC5lID0gX3YkNCk7XG4gICAgICBfdiQ1ICE9PSBfcCQudCAmJiBzZXRBdHRyaWJ1dGUoX2VsJDYsIFwiZmlsbFwiLCBfcCQudCA9IF92JDUpO1xuICAgICAgX3YkNiAhPT0gX3AkLmEgJiYgc2V0QXR0cmlidXRlKF9lbCQ3LCBcImZpbGxcIiwgX3AkLmEgPSBfdiQ2KTtcbiAgICAgIHJldHVybiBfcCQ7XG4gICAgfSwge1xuICAgICAgZTogdm9pZCAwLFxuICAgICAgdDogdm9pZCAwLFxuICAgICAgYTogdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIF9lbCQ1O1xuICB9KSgpIDogKCgpID0+IHtcbiAgICB2YXIgX2VsJDggPSBfdG1wbCQzJDIoKSwgX2VsJDkgPSBfZWwkOC5maXJzdENoaWxkLCBfZWwkMCA9IF9lbCQ5Lm5leHRTaWJsaW5nO1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoX3AkKSA9PiB7XG4gICAgICB2YXIgX3YkNyA9IHByb3BzLmNsYXNzLCBfdiQ4ID0gZmlsbCgpLCBfdiQ5ID0gdGhlbWUuY29sb3JzLmNvbnN0YW50LndoaXRlO1xuICAgICAgX3YkNyAhPT0gX3AkLmUgJiYgc2V0QXR0cmlidXRlKF9lbCQ4LCBcImNsYXNzXCIsIF9wJC5lID0gX3YkNyk7XG4gICAgICBfdiQ4ICE9PSBfcCQudCAmJiBzZXRBdHRyaWJ1dGUoX2VsJDksIFwiZmlsbFwiLCBfcCQudCA9IF92JDgpO1xuICAgICAgX3YkOSAhPT0gX3AkLmEgJiYgc2V0QXR0cmlidXRlKF9lbCQwLCBcImZpbGxcIiwgX3AkLmEgPSBfdiQ5KTtcbiAgICAgIHJldHVybiBfcCQ7XG4gICAgfSwge1xuICAgICAgZTogdm9pZCAwLFxuICAgICAgdDogdm9pZCAwLFxuICAgICAgYTogdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIF9lbCQ4O1xuICB9KSgpKTtcbn07XG52YXIgX3RtcGwkJG8gPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB3aWR0aD03MiBoZWlnaHQ9NzIgdmlld0JveD1cIjAgMCA3MiA3MlwiZmlsbD1ub25lIHhtbG5zPWh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnPjxjaXJjbGUgY3g9MzYgY3k9MzYgcj0zMz48L2NpcmNsZT48cGF0aCBkPVwiTTI0LjA4NTggMjYuOTE0MkMyMy4zMDQ3IDI2LjEzMzIgMjMuMzA0NyAyNC44NjY4IDI0LjA4NTggMjQuMDg1OEMyNC44NjY4IDIzLjMwNDcgMjYuMTMzMiAyMy4zMDQ3IDI2LjkxNDIgMjQuMDg1OEwzNiAzMy4xNzE2TDQ1LjA4NTggMjQuMDg1OEM0NS44NjY4IDIzLjMwNDcgNDcuMTMzMiAyMy4zMDQ3IDQ3LjkxNDIgMjQuMDg1OEM0OC42OTUzIDI0Ljg2NjggNDguNjk1MyAyNi4xMzMyIDQ3LjkxNDIgMjYuOTE0MkwzOC44Mjg0IDM2TDQ3LjkxNDIgNDUuMDg1OEM0OC42OTUzIDQ1Ljg2NjggNDguNjk1MyA0Ny4xMzMyIDQ3LjkxNDIgNDcuOTE0MkM0Ny4xMzMyIDQ4LjY5NTMgNDUuODY2OCA0OC42OTUzIDQ1LjA4NTggNDcuOTE0MkwzNiAzOC44Mjg0TDI2LjkxNDIgNDcuOTE0MkMyNi4xMzMyIDQ4LjY5NTMgMjQuODY2OCA0OC42OTUzIDI0LjA4NTggNDcuOTE0MkMyMy4zMDQ3IDQ3LjEzMzIgMjMuMzA0NyA0NS44NjY4IDI0LjA4NTggNDUuMDg1OEwzMy4xNzE2IDM2TDI0LjA4NTggMjYuOTE0MlpcIj5gKSwgX3RtcGwkMiQzID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcgd2lkdGg9NDggaGVpZ2h0PTQ4IHZpZXdCb3g9XCIwIDAgNDggNDhcImZpbGw9bm9uZT48Y2lyY2xlIGN4PTI0IGN5PTI0LjAwMSByPTIyPjwvY2lyY2xlPjxwYXRoIGQ9XCJNMjQgMjQuMDAxTDMxLjUgMTYuNTAxTTI0IDI0LjAwMUwxNi41IDE2LjUwMU0yNCAyNC4wMDFMMTYuNSAzMS41MDFNMjQgMjQuMDAxTDMxLjUgMzEuNTAxXCJzdHJva2Utd2lkdGg9MyBzdHJva2UtbGluZWNhcD1yb3VuZCBzdHJva2UtbGluZWpvaW49cm91bmQ+YCksIF90bXBsJDMkMSA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8c3ZnIHdpZHRoPTI0IGhlaWdodD0yNCB2aWV3Qm94PVwiMCAwIDI0IDI0XCJmaWxsPW5vbmUgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmc+PGNpcmNsZSBjeD0xMiBjeT0xMiByPTExPjwvY2lyY2xlPjxwYXRoIGQ9XCJNNy44NjM2MSA5LjEzNjRDNy41MTIxNCA4Ljc4NDkzIDcuNTEyMTQgOC4yMTUwOCA3Ljg2MzYxIDcuODYzNjFDOC4yMTUwOCA3LjUxMjE0IDguNzg0OTMgNy41MTIxNCA5LjEzNjQgNy44NjM2MUwxMiAxMC43MjcyTDE0Ljg2MzYgNy44NjM2MUMxNS4yMTUxIDcuNTEyMTQgMTUuNzg0OSA3LjUxMjE0IDE2LjEzNjQgNy44NjM2MUMxNi40ODc5IDguMjE1MDggMTYuNDg3OSA4Ljc4NDkzIDE2LjEzNjQgOS4xMzY0TDEzLjI3MjggMTJMMTYuMTM2NCAxNC44NjM2QzE2LjQ4NzkgMTUuMjE1MSAxNi40ODc5IDE1Ljc4NDkgMTYuMTM2NCAxNi4xMzY0QzE1Ljc4NDkgMTYuNDg3OSAxNS4yMTUxIDE2LjQ4NzkgMTQuODYzNiAxNi4xMzY0TDEyIDEzLjI3MjhMOS4xMzY0IDE2LjEzNjRDOC43ODQ5MyAxNi40ODc5IDguMjE1MDggMTYuNDg3OSA3Ljg2MzYxIDE2LjEzNjRDNy41MTIxNCAxNS43ODQ5IDcuNTEyMTQgMTUuMjE1MSA3Ljg2MzYxIDE0Ljg2MzZMMTAuNzI3MiAxMkw3Ljg2MzYxIDkuMTM2NFpcIj5gKTtcbmNvbnN0IEVycm9ySWNvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IHNpemUgPSAoKSA9PiBwcm9wcy5zaXplIHx8IFwibVwiO1xuICBjb25zdCBmaWxsID0gKCkgPT4gcHJvcHMuZmlsbCB8fCB0aGVtZS5jb2xvcnMuaWNvbi5lcnJvcjtcbiAgcmV0dXJuIG1lbW8oKCkgPT4gbWVtbygoKSA9PiBzaXplKCkgPT09IFwibVwiKSgpID8gKCgpID0+IHtcbiAgICB2YXIgX2VsJCA9IF90bXBsJCRvKCksIF9lbCQyID0gX2VsJC5maXJzdENoaWxkLCBfZWwkMyA9IF9lbCQyLm5leHRTaWJsaW5nO1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoX3AkKSA9PiB7XG4gICAgICB2YXIgX3YkID0gcHJvcHMuY2xhc3MsIF92JDIgPSBmaWxsKCksIF92JDMgPSB0aGVtZS5jb2xvcnMuY29uc3RhbnQud2hpdGU7XG4gICAgICBfdiQgIT09IF9wJC5lICYmIHNldEF0dHJpYnV0ZShfZWwkLCBcImNsYXNzXCIsIF9wJC5lID0gX3YkKTtcbiAgICAgIF92JDIgIT09IF9wJC50ICYmIHNldEF0dHJpYnV0ZShfZWwkMiwgXCJmaWxsXCIsIF9wJC50ID0gX3YkMik7XG4gICAgICBfdiQzICE9PSBfcCQuYSAmJiBzZXRBdHRyaWJ1dGUoX2VsJDMsIFwiZmlsbFwiLCBfcCQuYSA9IF92JDMpO1xuICAgICAgcmV0dXJuIF9wJDtcbiAgICB9LCB7XG4gICAgICBlOiB2b2lkIDAsXG4gICAgICB0OiB2b2lkIDAsXG4gICAgICBhOiB2b2lkIDBcbiAgICB9KTtcbiAgICByZXR1cm4gX2VsJDtcbiAgfSkoKSA6IG1lbW8oKCkgPT4gc2l6ZSgpID09PSBcInNcIikoKSA/ICgoKSA9PiB7XG4gICAgdmFyIF9lbCQ0ID0gX3RtcGwkMiQzKCksIF9lbCQ1ID0gX2VsJDQuZmlyc3RDaGlsZCwgX2VsJDYgPSBfZWwkNS5uZXh0U2libGluZztcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKF9wJCkgPT4ge1xuICAgICAgdmFyIF92JDQgPSBwcm9wcy5jbGFzcywgX3YkNSA9IGZpbGwoKSwgX3YkNiA9IHRoZW1lLmNvbG9ycy5jb25zdGFudC53aGl0ZTtcbiAgICAgIF92JDQgIT09IF9wJC5lICYmIHNldEF0dHJpYnV0ZShfZWwkNCwgXCJjbGFzc1wiLCBfcCQuZSA9IF92JDQpO1xuICAgICAgX3YkNSAhPT0gX3AkLnQgJiYgc2V0QXR0cmlidXRlKF9lbCQ1LCBcImZpbGxcIiwgX3AkLnQgPSBfdiQ1KTtcbiAgICAgIF92JDYgIT09IF9wJC5hICYmIHNldEF0dHJpYnV0ZShfZWwkNiwgXCJzdHJva2VcIiwgX3AkLmEgPSBfdiQ2KTtcbiAgICAgIHJldHVybiBfcCQ7XG4gICAgfSwge1xuICAgICAgZTogdm9pZCAwLFxuICAgICAgdDogdm9pZCAwLFxuICAgICAgYTogdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIF9lbCQ0O1xuICB9KSgpIDogKCgpID0+IHtcbiAgICB2YXIgX2VsJDcgPSBfdG1wbCQzJDEoKSwgX2VsJDggPSBfZWwkNy5maXJzdENoaWxkLCBfZWwkOSA9IF9lbCQ4Lm5leHRTaWJsaW5nO1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoX3AkKSA9PiB7XG4gICAgICB2YXIgX3YkNyA9IHByb3BzLmNsYXNzLCBfdiQ4ID0gZmlsbCgpLCBfdiQ5ID0gdGhlbWUuY29sb3JzLmNvbnN0YW50LndoaXRlO1xuICAgICAgX3YkNyAhPT0gX3AkLmUgJiYgc2V0QXR0cmlidXRlKF9lbCQ3LCBcImNsYXNzXCIsIF9wJC5lID0gX3YkNyk7XG4gICAgICBfdiQ4ICE9PSBfcCQudCAmJiBzZXRBdHRyaWJ1dGUoX2VsJDgsIFwiZmlsbFwiLCBfcCQudCA9IF92JDgpO1xuICAgICAgX3YkOSAhPT0gX3AkLmEgJiYgc2V0QXR0cmlidXRlKF9lbCQ5LCBcImZpbGxcIiwgX3AkLmEgPSBfdiQ5KTtcbiAgICAgIHJldHVybiBfcCQ7XG4gICAgfSwge1xuICAgICAgZTogdm9pZCAwLFxuICAgICAgdDogdm9pZCAwLFxuICAgICAgYTogdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIF9lbCQ3O1xuICB9KSgpKTtcbn07XG52YXIgX3RtcGwkJG4gPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB3aWR0aD0yNCBoZWlnaHQ9MjQgdmlld0JveD1cIjAgMCAyNCAyNFwiZmlsbD1ub25lIHhtbG5zPWh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnPjxwYXRoIGQ9XCJNMTUuNTUgNS44NTEyM0MxOC45NDU5IDcuODExODQgMjAuMTA5NCAxMi4xNTQxIDE4LjE0ODggMTUuNTVDMTYuMTg4MiAxOC45NDU5IDExLjg0NTkgMjAuMTA5NCA4LjQ0OTk4IDE4LjE0ODhDOC4wMTk1MiAxNy45MDAzIDcuNDY5MDkgMTguMDQ3OCA3LjIyMDU2IDE4LjQ3ODJDNi45NzIwMyAxOC45MDg3IDcuMTE5NTIgMTkuNDU5MSA3LjU0OTk4IDE5LjcwNzZDMTEuODA2OCAyMi4xNjUzIDE3LjI0OTkgMjAuNzA2OCAxOS43MDc2IDE2LjQ1QzIyLjE2NTMgMTIuMTkzMiAyMC43MDY4IDYuNzUwMDUgMTYuNDUgNC4yOTIzOUMxMi4xOTMyIDEuODM0NzIgNi43NTAwMyAzLjI5MzIxIDQuMjkyMzYgNy41NTAwMUM0LjA0MzgzIDcuOTgwNDcgNC4xOTEzMiA4LjUzMDkxIDQuNjIxNzggOC43Nzk0M0M1LjA1MjI0IDkuMDI3OTYgNS42MDI2OCA4Ljg4MDQ4IDUuODUxMiA4LjQ1MDAxQzcuODExODEgNS4wNTQxMyAxMi4xNTQxIDMuODkwNjIgMTUuNTUgNS44NTEyM1pcIj5gKSwgX3RtcGwkMiQyID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcgd2lkdGg9NDQgaGVpZ2h0PTQ0IHZpZXdCb3g9XCIwIDAgNDQgNDRcImZpbGw9bm9uZT48cGF0aCBmaWxsLXJ1bGU9ZXZlbm9kZCBjbGlwLXJ1bGU9ZXZlbm9kZCBkPVwiTTIyIDIuOTk5NTFDMTEuNTA2NiAyLjk5OTUxIDMgMTEuNTA2MSAzIDIxLjk5OTVDMyAzMi40OTI5IDExLjUwNjYgNDAuOTk5NSAyMiA0MC45OTk1QzIyLjgyODQgNDAuOTk5NSAyMy41IDQxLjY3MTEgMjMuNSA0Mi40OTk1QzIzLjUgNDMuMzI3OSAyMi44Mjg0IDQzLjk5OTUgMjIgNDMuOTk5NUM5Ljg0OTc0IDQzLjk5OTUgMCAzNC4xNDk4IDAgMjEuOTk5NUMwIDkuODQ5MjUgOS44NDk3NCAtMC4wMDA0ODgyODEgMjIgLTAuMDAwNDg4MjgxQzM0LjE1MDMgLTAuMDAwNDg4MjgxIDQ0IDkuODQ5MjUgNDQgMjEuOTk5NUM0NCAyMi44Mjc5IDQzLjMyODQgMjMuNDk5NSA0Mi41IDIzLjQ5OTVDNDEuNjcxNiAyMy40OTk1IDQxIDIyLjgyNzkgNDEgMjEuOTk5NUM0MSAxMS41MDYxIDMyLjQ5MzQgMi45OTk1MSAyMiAyLjk5OTUxWlwiPmApLCBfdG1wbCQzID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgd2lkdGg9NzIgaGVpZ2h0PTcyIHZpZXdCb3g9XCIwIDAgNzIgNzJcImZpbGw9bm9uZSB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zz48cGF0aCBkPVwiTTI0IDU2Ljc4NDZDMzUuNDc5IDYzLjQxMiA1MC4xNTcyIDU5LjQ3OSA1Ni43ODQ2IDQ3Ljk5OTlDNjMuNDEyIDM2LjUyMDkgNTkuNDc5IDIxLjg0MjcgNDggMTUuMjE1M0MzNi41MjEgOC41ODc5MSAyMS44NDI4IDEyLjUyMDkgMTUuMjE1NCAyMy45OTk5XCJzdHJva2Utd2lkdGg9NCBzdHJva2UtbGluZWNhcD1yb3VuZCBzdHJva2UtbGluZWpvaW49cm91bmQ+YCk7XG5jb25zdCBMb2FkZXJJY29uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3Qgc2l6ZSA9ICgpID0+IHByb3BzLnNpemUgfHwgXCJ4c1wiO1xuICBjb25zdCBmaWxsID0gKCkgPT4gcHJvcHMuZmlsbCB8fCB0aGVtZS5jb2xvcnMuaWNvbi50ZXJ0aWFyeTtcbiAgY29uc3Qgcm90YXRlQW5pbWF0aW9uID0gaGBcbiAgICAgICAgMCUge1xuICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xuICAgICAgICB9XG4gICAgICAgIDEwMCUge1xuICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XG4gICAgICAgIH1cbiAgICBgO1xuICBjb25zdCBzdmdDbGFzcyA9IHVgXG4gICAgICAgIGFuaW1hdGlvbjogJHtyb3RhdGVBbmltYXRpb259IDFzIGxpbmVhciBpbmZpbml0ZTtcbiAgICBgO1xuICByZXR1cm4gbWVtbygoKSA9PiBtZW1vKCgpID0+IHNpemUoKSA9PT0gXCJ4c1wiKSgpID8gKCgpID0+IHtcbiAgICB2YXIgX2VsJCA9IF90bXBsJCRuKCksIF9lbCQyID0gX2VsJC5maXJzdENoaWxkO1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoX3AkKSA9PiB7XG4gICAgICB2YXIgX3YkID0gY24oc3ZnQ2xhc3MsIHByb3BzLmNsYXNzKSwgX3YkMiA9IGZpbGwoKTtcbiAgICAgIF92JCAhPT0gX3AkLmUgJiYgc2V0QXR0cmlidXRlKF9lbCQsIFwiY2xhc3NcIiwgX3AkLmUgPSBfdiQpO1xuICAgICAgX3YkMiAhPT0gX3AkLnQgJiYgc2V0QXR0cmlidXRlKF9lbCQyLCBcImZpbGxcIiwgX3AkLnQgPSBfdiQyKTtcbiAgICAgIHJldHVybiBfcCQ7XG4gICAgfSwge1xuICAgICAgZTogdm9pZCAwLFxuICAgICAgdDogdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIF9lbCQ7XG4gIH0pKCkgOiBtZW1vKCgpID0+IHNpemUoKSA9PT0gXCJzXCIpKCkgPyAoKCkgPT4ge1xuICAgIHZhciBfZWwkMyA9IF90bXBsJDIkMigpLCBfZWwkNCA9IF9lbCQzLmZpcnN0Q2hpbGQ7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KChfcCQpID0+IHtcbiAgICAgIHZhciBfdiQzID0gY24oc3ZnQ2xhc3MsIHByb3BzLmNsYXNzKSwgX3YkNCA9IGZpbGwoKTtcbiAgICAgIF92JDMgIT09IF9wJC5lICYmIHNldEF0dHJpYnV0ZShfZWwkMywgXCJjbGFzc1wiLCBfcCQuZSA9IF92JDMpO1xuICAgICAgX3YkNCAhPT0gX3AkLnQgJiYgc2V0QXR0cmlidXRlKF9lbCQ0LCBcImZpbGxcIiwgX3AkLnQgPSBfdiQ0KTtcbiAgICAgIHJldHVybiBfcCQ7XG4gICAgfSwge1xuICAgICAgZTogdm9pZCAwLFxuICAgICAgdDogdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIF9lbCQzO1xuICB9KSgpIDogKCgpID0+IHtcbiAgICB2YXIgX2VsJDUgPSBfdG1wbCQzKCksIF9lbCQ2ID0gX2VsJDUuZmlyc3RDaGlsZDtcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKF9wJCkgPT4ge1xuICAgICAgdmFyIF92JDUgPSBjbihzdmdDbGFzcywgcHJvcHMuY2xhc3MpLCBfdiQ2ID0gZmlsbCgpO1xuICAgICAgX3YkNSAhPT0gX3AkLmUgJiYgc2V0QXR0cmlidXRlKF9lbCQ1LCBcImNsYXNzXCIsIF9wJC5lID0gX3YkNSk7XG4gICAgICBfdiQ2ICE9PSBfcCQudCAmJiBzZXRBdHRyaWJ1dGUoX2VsJDYsIFwic3Ryb2tlXCIsIF9wJC50ID0gX3YkNik7XG4gICAgICByZXR1cm4gX3AkO1xuICAgIH0sIHtcbiAgICAgIGU6IHZvaWQgMCxcbiAgICAgIHQ6IHZvaWQgMFxuICAgIH0pO1xuICAgIHJldHVybiBfZWwkNTtcbiAgfSkoKSk7XG59O1xudmFyIF90bXBsJCRtID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgd2lkdGg9MTU4IGhlaWdodD0yOCB2aWV3Qm94PVwiMCAwIDE1OCAyOFwiZmlsbD1ub25lIHhtbG5zPWh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnPjxwYXRoIGZpbGwtcnVsZT1ldmVub2RkIGNsaXAtcnVsZT1ldmVub2RkIGQ9XCJNMjggMTQuMDAxQzI4IDIxLjczMyAyMS43MzIgMjguMDAxIDE0IDI4LjAwMUM2LjI2ODAxIDI4LjAwMSAwIDIxLjczMyAwIDE0LjAwMUMwIDYuMjY4OTkgNi4yNjgwMSAwLjAwMDk3NjU2MiAxNCAwLjAwMDk3NjU2MkMyMS43MzIgMC4wMDA5NzY1NjIgMjggNi4yNjg5OSAyOCAxNC4wMDFaTTkuMjE5MzEgOC4wMDA5OEgxOC43ODAxSDE4Ljc4MTNDMjAuNTM4IDguMDAwOTggMjEuNjUyMiA5Ljg5OTY2IDIwLjc2OTEgMTEuNDMwMkwxNC44NjcyIDIxLjY1NzZDMTQuNDgyMiAyMi4zMjU0IDEzLjUxNzIgMjIuMzI1NCAxMy4xMzIyIDIxLjY1NzZMNy4yMzE1OCAxMS40MzAyQzYuMzQ3MjEgOS44OTcyNiA3LjQ2MTQgOC4wMDA5OCA5LjIxOTMxIDguMDAwOThaTTEzLjEyNjIgMTguNTg4MlY5Ljc0ODA2SDkuMjE4MTFDOC43ODk3NiA5Ljc0ODA2IDguNTM3MDggMTAuMjAyOSA4Ljc0MTYzIDEwLjU1NzhMMTEuODQyMyAxNi4xMDM1TDEzLjEyNjIgMTguNTg4MlpNMTYuMTU1OSAxNi4xMDQ3TDE5LjI1NTQgMTAuNTU2NkMxOS40NTk5IDEwLjIwMTcgMTkuMjA3MyA5Ljc0Njg1IDE4Ljc3ODkgOS43NDY4NUgxNC44NzA5VjE4LjU5MDZMMTYuMTU1OSAxNi4xMDQ3WlwiZmlsbD0jMDA5OEVBPjwvcGF0aD48cGF0aCBkPVwiTTE4Ljc4MDIgOC4wMDA5OEg5LjIxOTM2QzcuNDYxNDUgOC4wMDA5OCA2LjM0NzI3IDkuODk3MjYgNy4yMzE2NCAxMS40MzAyTDEzLjEzMjIgMjEuNjU3NkMxMy41MTczIDIyLjMyNTQgMTQuNDgyMyAyMi4zMjU0IDE0Ljg2NzMgMjEuNjU3NkwyMC43NjkxIDExLjQzMDJDMjEuNjUyMyA5Ljg5OTY2IDIwLjUzODEgOC4wMDA5OCAxOC43ODE0IDguMDAwOThIMTguNzgwMlpNMTMuMTI3NCAxOC41OTA2TDExLjg0MjQgMTYuMTAzNUw4Ljc0MTY4IDEwLjU1NzhDOC41MzcxNCAxMC4yMDI5IDguNzg5ODEgOS43NDgwNiA5LjIxODE2IDkuNzQ4MDZIMTMuMTI2MlYxOC41OTE4TDEzLjEyNzQgMTguNTkwNlpNMTkuMjU1NSAxMC41NTY2TDE2LjE1NiAxNi4xMDQ3TDE0Ljg3MDkgMTguNTkwNlY5Ljc0Njg1SDE4Ljc3OUMxOS4yMDczIDkuNzQ2ODUgMTkuNDYgMTAuMjAxNyAxOS4yNTU1IDEwLjU1NjZaXCJmaWxsPXdoaXRlPjwvcGF0aD48cGF0aCBmaWxsLXJ1bGU9ZXZlbm9kZCBjbGlwLXJ1bGU9ZXZlbm9kZCBkPVwiTTUxLjc0ODMgMjIuMTk2N0M1NS43MTgyIDIyLjE5NjcgNTguOTYwOSAxOC45NTQgNTguOTYwOSAxNC45ODQxQzU4Ljk2MDkgMTEuMDE0MiA1NS43MTgyIDcuNzcxNDggNTEuNzQ4MyA3Ljc3MTQ4QzQ3Ljc1ODggNy43NzE0OCA0NC41MzU3IDExLjAxNDIgNDQuNTM1NyAxNC45ODQxQzQ0LjUzNTcgMTguOTU0IDQ3Ljc1ODggMjIuMTk2NyA1MS43NDgzIDIyLjE5NjdaTTUxLjc0ODMgMTkuMTcwMkM0OS40Njg2IDE5LjE3MDIgNDcuNjgwMiAxNy4yNDQyIDQ3LjY4MDIgMTQuOTg0MUM0Ny42ODAyIDEyLjcyNCA0OS40Njg2IDEwLjc5OCA1MS43NDgzIDEwLjc5OEM1NC4wMDg0IDEwLjc5OCA1NS43OTY4IDEyLjcyNCA1NS43OTY4IDE0Ljk4NDFDNTUuNzk2OCAxNy4yNDQyIDU0LjAwODQgMTkuMTcwMiA1MS43NDgzIDE5LjE3MDJaTTM3LjA2OTggMjEuOTYwOUg0MC4yMTQyVjEwLjk5NDZINDQuMjg0M1Y4LjAwNzMySDMzVjEwLjk5NDZIMzcuMDY5OFYyMS45NjA5Wk02OS45Mzc5IDguMDA3MzJINzMuMDgyM1YyMS45NjA5SDcwLjM4OTlMNjMuNTkgMTMuMzMzM1YyMS45NjA5SDYwLjQ2NTJWOC4wMDczMkg2My4xNTc2TDY5LjkzNzkgMTYuNjE1M1Y4LjAwNzMyWk03OS4yMjU5IDE0Ljk4ODdDNzkuMjI1OSAxMC45MjAyIDgyLjM1MSA3Ljc3NTM5IDg2LjQ5ODIgNy43NzUzOUM4OS44NTkyIDcuNzc1MzkgOTIuNTUxOSA5Ljk1NzA5IDkzLjIyMDIgMTIuNjg5MUg5MC43NDM3QzkwLjE1NCAxMS4wOTcxIDg4LjQ2MzcgOS45OTY0IDg2LjQ5ODIgOS45OTY0QzgzLjU4OTMgOS45OTY0IDgxLjU0NTIgMTIuMTc4MSA4MS41NDUyIDE0Ljk4ODdDODEuNTQ1MiAxNy43OTk0IDgzLjU4OTMgMTkuOTgxMSA4Ni40OTgyIDE5Ljk4MTFDODguNDYzNyAxOS45ODExIDkwLjE1NCAxOC44ODA0IDkwLjc0MzcgMTcuMjg4NEg5My4yMjAyQzkyLjU1MTkgMjAuMDIwNCA4OS44NTkyIDIyLjIwMjEgODYuNDk4MiAyMi4yMDIxQzgyLjM1MSAyMi4yMDIxIDc5LjIyNTkgMTkuMDU3MyA3OS4yMjU5IDE0Ljk4ODdaTTEwNC41ODQgMTcuMDUyNUMxMDQuNTg0IDE5LjkwMjUgMTAyLjM0MyAyMi4xNjI4IDk5LjQzNDIgMjIuMTYyOEM5Ni41MjUzIDIyLjE2MjggOTQuMjg0NiAxOS45MDI1IDk0LjI4NDYgMTcuMDUyNUM5NC4yODQ2IDE0LjIwMjUgOTYuNTI1MyAxMS45NDIyIDk5LjQzNDIgMTEuOTQyMkMxMDIuMzQzIDExLjk0MjIgMTA0LjU4NCAxNC4yMDI1IDEwNC41ODQgMTcuMDUyNVpNOTYuNDY2MyAxNy4wNTI1Qzk2LjQ2NjMgMTguODAxOCA5Ny42ODQ5IDIwLjE1OCA5OS40MzQyIDIwLjE1OEMxMDEuMTY0IDIwLjE1OCAxMDIuMzgyIDE4LjgwMTggMTAyLjM4MiAxNy4wNTI1QzEwMi4zODIgMTUuMzAzMiAxMDEuMTY0IDEzLjk0NyA5OS40MzQyIDEzLjk0N0M5Ny42ODQ5IDEzLjk0NyA5Ni40NjYzIDE1LjMwMzIgOTYuNDY2MyAxNy4wNTI1Wk0xMDguNjI2IDEyLjEzODhIMTA2LjQ2M1YyMS45NjYySDEwOC42MjZWMTcuMTMxMUMxMDguNjI2IDE1LjAyODEgMTA5LjcyNiAxMy45MDc3IDExMS4xNjEgMTMuOTA3N0MxMTIuNDE5IDEzLjkwNzcgMTEzLjIwNSAxNC44NTEyIDExMy4yMDUgMTYuNDAzOVYyMS45NjYySDExNS4zNjdWMTYuMDUwMUMxMTUuMzY3IDEzLjU1MzkgMTEzLjg5MyAxMS45NDIyIDExMS42MTMgMTEuOTQyMkMxMTAuMzM1IDExLjk0MjIgMTA5LjIxNSAxMi40OTI2IDEwOC42MjYgMTMuNDc1M1YxMi4xMzg4Wk0xMTcuODM5IDEyLjEzODhIMTIwLjAwMVYxMy40NzUzQzEyMC41OSAxMi40OTI2IDEyMS43MTEgMTEuOTQyMiAxMjIuOTg4IDExLjk0MjJDMTI1LjI2OCAxMS45NDIyIDEyNi43NDIgMTMuNTUzOSAxMjYuNzQyIDE2LjA1MDFWMjEuOTY2MkgxMjQuNThWMTYuNDAzOUMxMjQuNTggMTQuODUxMiAxMjMuNzk0IDEzLjkwNzcgMTIyLjUzNiAxMy45MDc3QzEyMS4xMDEgMTMuOTA3NyAxMjAuMDAxIDE1LjAyODEgMTIwLjAwMSAxNy4xMzExVjIxLjk2NjJIMTE3LjgzOVYxMi4xMzg4Wk0xMzMuNTU4IDIyLjE2MjhDMTM2LjA1NCAyMi4xNjI4IDEzNy44MjMgMjAuNzI4IDEzOC4zNzMgMTguODgwNEgxMzYuMTEzQzEzNS42NjEgMTkuODIzOCAxMzQuNzE3IDIwLjI1NjMgMTMzLjYzNiAyMC4yNTYzQzEzMS44ODcgMjAuMjU2MyAxMzAuNzQ3IDE5LjA3NyAxMzAuNjY4IDE3LjU4MzJIMTM4LjQ5MUMxMzguNjg4IDE0LjI0MTkgMTM2LjU4NSAxMS45NDIyIDEzMy41NzcgMTEuOTQyMkMxMzAuNTUxIDExLjk0MjIgMTI4LjUyNiAxNC4xNDM2IDEyOC41MjYgMTcuMDUyNUMxMjguNTI2IDIwLjAwMDcgMTMwLjYyOSAyMi4xNjI4IDEzMy41NTggMjIuMTYyOFpNMTMwLjc0NyAxNi4wNTAxQzEzMS4wNDIgMTQuNTM2NyAxMzIuMTYyIDEzLjc1MDUgMTMzLjUxOCAxMy43NTA1QzEzNC43MTcgMTMuNzUwNSAxMzUuODM4IDE0LjQ1ODEgMTM2LjE3MiAxNi4wNTAxSDEzMC43NDdaTTE0OS44NTEgMTguMzY5NEMxNDkuMzIgMjAuNTUxMSAxNDcuNDUzIDIyLjE2MjggMTQ0Ljg1OSAyMi4xNjI4QzE0MS44NzEgMjIuMTYyOCAxMzkuNzA5IDE5Ljg4MjggMTM5LjcwOSAxNy4wNTI1QzEzOS43MDkgMTQuMjIyMiAxNDEuODcxIDExLjk0MjIgMTQ0Ljg1OSAxMS45NDIyQzE0Ny40NTMgMTEuOTQyMiAxNDkuMzIgMTMuNTUzOSAxNDkuODUxIDE1LjczNTZIMTQ3LjU3MUMxNDcuMTc4IDE0LjY3NDMgMTQ2LjIxNSAxMy45MDc3IDE0NC44NTkgMTMuOTA3N0MxNDMuMTA5IDEzLjkwNzcgMTQxLjkxIDE1LjIyNDYgMTQxLjkxIDE3LjA1MjVDMTQxLjkxIDE4Ljg4MDQgMTQzLjEwOSAyMC4xOTczIDE0NC44NTkgMjAuMTk3M0MxNDYuMjE1IDIwLjE5NzMgMTQ3LjE3OCAxOS40MzA3IDE0Ny41NzEgMTguMzY5NEgxNDkuODUxWk0xNTUuNzUgMjIuMDY0NUMxNTYuNDE4IDIyLjA2NDUgMTU2LjkyOSAyMS45ODU5IDE1Ny4zNjIgMjEuODQ4M1YxOS45MjIxQzE1Ny4wNDcgMjAuMDQwMSAxNTYuNjE1IDIwLjExODcgMTU2LjIwMiAyMC4xMTg3QzE1NS4wODIgMjAuMTE4NyAxNTQuNTUxIDE5LjY2NjYgMTU0LjU1MSAxOC40NDhWMTQuMDY1SDE1Ny4zNjJWMTIuMTM4OEgxNTQuNTUxVjkuNDA2NzVIMTUyLjM4OVYxMi4xMzg4SDE1MC4zNDVWMTQuMDY1SDE1Mi4zODlWMTguODAxOEMxNTIuMzg5IDIxLjAyMjggMTUzLjg2MyAyMi4wNjQ1IDE1NS43NSAyMi4wNjQ1WlwiPmApO1xuY29uc3QgVG9uQ29ubmVjdEJyYW5kID0gKCkgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IGZpbGwgPSAoKSA9PiB0aGVtZS50aGVtZSA9PT0gVEhFTUUuREFSSyA/IHRoZW1lLmNvbG9ycy5jb25zdGFudC53aGl0ZSA6IHRoZW1lLmNvbG9ycy5jb25zdGFudC5ibGFjaztcbiAgcmV0dXJuICgoKSA9PiB7XG4gICAgdmFyIF9lbCQgPSBfdG1wbCQkbSgpLCBfZWwkMiA9IF9lbCQuZmlyc3RDaGlsZCwgX2VsJDMgPSBfZWwkMi5uZXh0U2libGluZywgX2VsJDQgPSBfZWwkMy5uZXh0U2libGluZztcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKCkgPT4gc2V0QXR0cmlidXRlKF9lbCQ0LCBcImZpbGxcIiwgZmlsbCgpKSk7XG4gICAgcmV0dXJuIF9lbCQ7XG4gIH0pKCk7XG59O1xudmFyIF90bXBsJCRsID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcgd2lkdGg9MTYgaGVpZ2h0PTE2IHZpZXdCb3g9XCIwIDAgMTYgMTZcImZpbGw9bm9uZT48cGF0aCBmaWxsLXJ1bGU9ZXZlbm9kZCBjbGlwLXJ1bGU9ZXZlbm9kZCBkPVwiTTUuNTY2MDggNC40MjU4NEM1LjgyNTI3IDMuMzIxNTggNi44MTc2IDIuNSA4LjAwMDAxIDIuNUM5LjM4MDcyIDIuNSAxMC41IDMuNjE5MjkgMTAuNSA1QzEwLjUgNS42MzAyNiAxMC4zMzkxIDYuMDM4NiAxMC4xMjY0IDYuMzQ0NTVDOS45MDAxOCA2LjY2OTkzIDkuNTg1NjEgNi45MjQ3OCA5LjE4ODY0IDcuMjA4NzdDOS4xMjU3OSA3LjI1MzcyIDkuMDU4NzMgNy4zMDAyNSA4Ljk4ODcgNy4zNDg4M0M4LjI3MzkyIDcuODQ0NzIgNy4yNTAwMSA4LjU1NTA3IDcuMjUwMDEgMTBWMTAuMjVDNy4yNTAwMSAxMC42NjQyIDcuNTg1OCAxMSA4LjAwMDAxIDExQzguNDE0MjIgMTEgOC43NTAwMSAxMC42NjQyIDguNzUwMDEgMTAuMjVWMTBDOC43NTAwMSA5LjM2NTAyIDkuMTA3NzcgOS4xMDk2IDkuOTQ1NTQgOC41MTE0OUwxMC4wNjE0IDguNDI4NzNDMTAuNDc2OSA4LjEzMTQ3IDEwLjk3NDggNy43NTE5NCAxMS4zNTggNy4yMDA3NkMxMS43NTQ3IDYuNjMwMTUgMTIgNS45MTk3MyAxMiA1QzEyIDIuNzkwODYgMTAuMjA5MSAxIDguMDAwMDEgMUM2LjEwNTY0IDEgNC41MjA1IDIuMzE2MTUgNC4xMDU3NyA0LjA4MzA4QzQuMDExMTIgNC40ODYzNCA0LjI2MTI5IDQuODg5OTcgNC42NjQ1NCA0Ljk4NDYyQzUuMDY3OCA1LjA3OTI3IDUuNDcxNDMgNC44MjkxIDUuNTY2MDggNC40MjU4NFpNOC4wMDAwMSAxNUM4LjYwNzUyIDE1IDkuMTAwMDEgMTQuNTA3NSA5LjEwMDAxIDEzLjlDOS4xMDAwMSAxMy4yOTI1IDguNjA3NTIgMTIuOCA4LjAwMDAxIDEyLjhDNy4zOTI0OSAxMi44IDYuOTAwMDEgMTMuMjkyNSA2LjkwMDAxIDEzLjlDNi45MDAwMSAxNC41MDc1IDcuMzkyNDkgMTUgOC4wMDAwMSAxNVpcIj5gKTtcbmNvbnN0IFF1ZXN0aW9uSWNvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IGZpbGwgPSAoKSA9PiBwcm9wcy5maWxsIHx8IHRoZW1lLmNvbG9ycy5pY29uLnNlY29uZGFyeTtcbiAgcmV0dXJuICgoKSA9PiB7XG4gICAgdmFyIF9lbCQgPSBfdG1wbCQkbCgpLCBfZWwkMiA9IF9lbCQuZmlyc3RDaGlsZDtcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKCkgPT4gc2V0QXR0cmlidXRlKF9lbCQyLCBcImZpbGxcIiwgZmlsbCgpKSk7XG4gICAgcmV0dXJuIF9lbCQ7XG4gIH0pKCk7XG59O1xudmFyIF90bXBsJCRrID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcgd2lkdGg9MTYgaGVpZ2h0PTE2IHZpZXdCb3g9XCIwIDAgMTYgMTZcImZpbGw9bm9uZT48cGF0aCBmaWxsLXJ1bGU9ZXZlbm9kZCBjbGlwLXJ1bGU9ZXZlbm9kZCBkPVwiTTkuOTgxNTYgOC43NUM5Ljg0ODU0IDExLjQzMjggOS4wMTIwNiAxMy41IDggMTMuNUM2Ljk4Nzk0IDEzLjUgNi4xNTE0NiAxMS40MzI4IDYuMDE4NDQgOC43NUg5Ljk4MTU2Wk0xMS40ODMyIDguNzVDMTEuNDIxNyAxMC4xMTU1IDExLjE5MjkgMTEuMzg2OSAxMC44MjM5IDEyLjQwMTdDMTAuNzczNCAxMi41NDA1IDEwLjcxODggMTIuNjc4OSAxMC42NTk1IDEyLjgxNTRDMTIuMTQ1NCAxMS45OTMgMTMuMjEwMyAxMC41MDI5IDEzLjQ0OTMgOC43NUgxMS40ODMyWk0xMy40NDkzIDcuMjVIMTEuNDgzMkMxMS40MjE3IDUuODg0NTMgMTEuMTkyOSA0LjYxMzE0IDEwLjgyMzkgMy41OTgzQzEwLjc3MzQgMy40NTk1IDEwLjcxODggMy4zMjExMSAxMC42NTk1IDMuMTg0NTlDMTIuMTQ1NCA0LjAwNjk3IDEzLjIxMDMgNS40OTcwOSAxMy40NDkzIDcuMjVaTTkuOTgxNTYgNy4yNUg2LjAxODQ0QzYuMTUxNDQgNC41Njc2NCA2Ljk4NzY5IDIuNTAwNjIgNy45OTk1NSAyLjVIOEM5LjAxMjA2IDIuNSA5Ljg0ODU0IDQuNTY3MjQgOS45ODE1NiA3LjI1Wk00LjUxNjc4IDcuMjVDNC41NzgyNiA1Ljg4NDUzIDQuODA3MDYgNC42MTMxNCA1LjE3NjEgMy41OTgzQzUuMjI2NTcgMy40NTk1IDUuMjgxMjQgMy4zMjExMSA1LjM0MDUgMy4xODQ1OUMzLjg1NDYzIDQuMDA2OTcgMi43ODk3MiA1LjQ5NzA5IDIuNTUwNzEgNy4yNUg0LjUxNjc4Wk0yLjU1MDcxIDguNzVDMi43ODk3MiAxMC41MDI5IDMuODU0NjMgMTEuOTkzIDUuMzQwNSAxMi44MTU0QzUuMjgxMjQgMTIuNjc4OSA1LjIyNjU3IDEyLjU0MDUgNS4xNzYxIDEyLjQwMTdDNC44MDcwNiAxMS4zODY5IDQuNTc4MjYgMTAuMTE1NSA0LjUxNjc4IDguNzVIMi41NTA3MVpNMTUgOEMxNSAxMS44NjYgMTEuODY2IDE1IDggMTVDNC4xMzQwMSAxNSAxIDExLjg2NiAxIDhDMSA0LjEzNDAxIDQuMTM0MDEgMSA4IDFDMTEuODY2IDEgMTUgNC4xMzQwMSAxNSA4WlwiPmApO1xuY29uc3QgQnJvd3Nlckljb24gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCBmaWxsID0gKCkgPT4gcHJvcHMuZmlsbCB8fCB0aGVtZS5jb2xvcnMuaWNvbi5wcmltYXJ5O1xuICByZXR1cm4gKCgpID0+IHtcbiAgICB2YXIgX2VsJCA9IF90bXBsJCRrKCksIF9lbCQyID0gX2VsJC5maXJzdENoaWxkO1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoKSA9PiBzZXRBdHRyaWJ1dGUoX2VsJDIsIFwiZmlsbFwiLCBmaWxsKCkpKTtcbiAgICByZXR1cm4gX2VsJDtcbiAgfSkoKTtcbn07XG52YXIgX3RtcGwkJGogPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyB3aWR0aD0xNiBoZWlnaHQ9MTYgdmlld0JveD1cIjAgMCAxNiAxNlwiZmlsbD1ub25lPjxwYXRoIGZpbGwtcnVsZT1ldmVub2RkIGNsaXAtcnVsZT1ldmVub2RkIGQ9XCJNMi41IDQuOEMyLjUgMy4xMTk4NCAyLjUgMi4yNzk3NiAyLjgyNjk4IDEuNjM4MDNDMy4xMTQ2IDEuMDczNTQgMy41NzM1NCAwLjYxNDYwMSA0LjEzODAzIDAuMzI2OThDNC43Nzk3NiAwIDUuNjE5ODQgMCA3LjMgMEg4LjdDMTAuMzgwMiAwIDExLjIyMDIgMCAxMS44NjIgMC4zMjY5OEMxMi40MjY1IDAuNjE0NjAxIDEyLjg4NTQgMS4wNzM1NCAxMy4xNzMgMS42MzgwM0MxMy41IDIuMjc5NzYgMTMuNSAzLjExOTg0IDEzLjUgNC44VjExLjJDMTMuNSAxMi44ODAyIDEzLjUgMTMuNzIwMiAxMy4xNzMgMTQuMzYyQzEyLjg4NTQgMTQuOTI2NSAxMi40MjY1IDE1LjM4NTQgMTEuODYyIDE1LjY3M0MxMS4yMjAyIDE2IDEwLjM4MDIgMTYgOC43IDE2SDcuM0M1LjYxOTg0IDE2IDQuNzc5NzYgMTYgNC4xMzgwMyAxNS42NzNDMy41NzM1NCAxNS4zODU0IDMuMTE0NiAxNC45MjY1IDIuODI2OTggMTQuMzYyQzIuNSAxMy43MjAyIDIuNSAxMi44ODAyIDIuNSAxMS4yVjQuOFpNNCAzLjlDNCAzLjA1OTkyIDQgMi42Mzk4OCA0LjE2MzQ5IDIuMzE5MDFDNC4zMDczIDIuMDM2NzcgNC41MzY3NyAxLjgwNzMgNC44MTkwMSAxLjY2MzQ5QzUuMTM5ODggMS41IDUuNTU5OTIgMS41IDYuNCAxLjVIOS42QzEwLjQ0MDEgMS41IDEwLjg2MDEgMS41IDExLjE4MSAxLjY2MzQ5QzExLjQ2MzIgMS44MDczIDExLjY5MjcgMi4wMzY3NyAxMS44MzY1IDIuMzE5MDFDMTIgMi42Mzk4OCAxMiAzLjA1OTkyIDEyIDMuOVYxMi4xQzEyIDEyLjk0MDEgMTIgMTMuMzYwMSAxMS44MzY1IDEzLjY4MUMxMS42OTI3IDEzLjk2MzIgMTEuNDYzMiAxNC4xOTI3IDExLjE4MSAxNC4zMzY1QzEwLjg2MDEgMTQuNSAxMC40NDAxIDE0LjUgOS42IDE0LjVINi40QzUuNTU5OTIgMTQuNSA1LjEzOTg4IDE0LjUgNC44MTkwMSAxNC4zMzY1QzQuNTM2NzcgMTQuMTkyNyA0LjMwNzMgMTMuOTYzMiA0LjE2MzQ5IDEzLjY4MUM0IDEzLjM2MDEgNCAxMi45NDAxIDQgMTIuMVYzLjlaTTcgMi41QzYuNTg1NzkgMi41IDYuMjUgMi44MzU3OSA2LjI1IDMuMjVDNi4yNSAzLjY2NDIxIDYuNTg1NzkgNCA3IDRIOUM5LjQxNDIxIDQgOS43NSAzLjY2NDIxIDkuNzUgMy4yNUM5Ljc1IDIuODM1NzkgOS40MTQyMSAyLjUgOSAyLjVIN1pcIj5gKTtcbmNvbnN0IE1vYmlsZUljb24gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCBmaWxsID0gKCkgPT4gcHJvcHMuZmlsbCB8fCB0aGVtZS5jb2xvcnMuaWNvbi5wcmltYXJ5O1xuICByZXR1cm4gKCgpID0+IHtcbiAgICB2YXIgX2VsJCA9IF90bXBsJCRqKCksIF9lbCQyID0gX2VsJC5maXJzdENoaWxkO1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoKSA9PiBzZXRBdHRyaWJ1dGUoX2VsJDIsIFwiZmlsbFwiLCBmaWxsKCkpKTtcbiAgICByZXR1cm4gX2VsJDtcbiAgfSkoKTtcbn07XG52YXIgX3RtcGwkJGkgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyB3aWR0aD0xNiBoZWlnaHQ9MTYgdmlld0JveD1cIjAgMCAxNiAxNlwiZmlsbD1ub25lPjxwYXRoIGZpbGwtcnVsZT1ldmVub2RkIGNsaXAtcnVsZT1ldmVub2RkIGQ9XCJNMS41IDYuOEMxLjUgNS4xMTk4NCAxLjUgNC4yNzk3NiAxLjgyNjk4IDMuNjM4MDNDMi4xMTQ2IDMuMDczNTQgMi41NzM1NCAyLjYxNDYgMy4xMzgwMyAyLjMyNjk4QzMuNzc5NzYgMiA0LjYxOTg0IDIgNi4zIDJIOS43QzExLjM4MDIgMiAxMi4yMjAyIDIgMTIuODYyIDIuMzI2OThDMTMuNDI2NSAyLjYxNDYgMTMuODg1NCAzLjA3MzU0IDE0LjE3MyAzLjYzODAzQzE0LjUgNC4yNzk3NiAxNC41IDUuMTE5ODQgMTQuNSA2LjhWMTEuNUgxNS4yNUMxNS42NjQyIDExLjUgMTYgMTEuODM1OCAxNiAxMi4yNUMxNiAxMi42NjQyIDE1LjY2NDIgMTMgMTUuMjUgMTNIMC43NUMwLjMzNTc4NiAxMyAwIDEyLjY2NDIgMCAxMi4yNUMwIDExLjgzNTggMC4zMzU3ODYgMTEuNSAwLjc1IDExLjVIMS41VjYuOFpNMyAxMS41SDEzVjUuOUMxMyA1LjA1OTkyIDEzIDQuNjM5ODggMTIuODM2NSA0LjMxOTAxQzEyLjY5MjcgNC4wMzY3NyAxMi40NjMyIDMuODA3MyAxMi4xODEgMy42NjM0OUMxMS44NjAxIDMuNSAxMS40NDAxIDMuNSAxMC42IDMuNUg1LjRDNC41NTk5MiAzLjUgNC4xMzk4OCAzLjUgMy44MTkwMSAzLjY2MzQ5QzMuNTM2NzcgMy44MDczIDMuMzA3MyA0LjAzNjc3IDMuMTYzNDkgNC4zMTkwMUMzIDQuNjM5ODggMyA1LjA1OTkyIDMgNS45VjExLjVaXCI+YCk7XG5jb25zdCBEZXNrdG9wSWNvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IGZpbGwgPSAoKSA9PiBwcm9wcy5maWxsIHx8IHRoZW1lLmNvbG9ycy5pY29uLnByaW1hcnk7XG4gIHJldHVybiAoKCkgPT4ge1xuICAgIHZhciBfZWwkID0gX3RtcGwkJGkoKSwgX2VsJDIgPSBfZWwkLmZpcnN0Q2hpbGQ7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KCgpID0+IHNldEF0dHJpYnV0ZShfZWwkMiwgXCJmaWxsXCIsIGZpbGwoKSkpO1xuICAgIHJldHVybiBfZWwkO1xuICB9KSgpO1xufTtcbnZhciBfdG1wbCQkaCA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8c3ZnIHhtbG5zPWh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIHdpZHRoPTE3IGhlaWdodD0xNiB2aWV3Qm94PVwiMCAwIDE3IDE2XCJmaWxsPW5vbmU+PGcgY2xpcC1wYXRoPXVybCgjY2xpcDBfMzY3Nl8xNjAzKT48cGF0aCBmaWxsLXJ1bGU9ZXZlbm9kZCBjbGlwLXJ1bGU9ZXZlbm9kZCBkPVwiTTE1LjUgMS4yNTA0OUMxNS41IDAuODM2Mjc1IDE1LjE2NDIgMC41MDA0ODggMTQuNzUgMC41MDA0ODhDMTQuMzM1OCAwLjUwMDQ4OCAxNCAwLjgzNjI3NSAxNCAxLjI1MDQ5VjMuNjcwMTJDMTIuNzE4NyAyLjA0NDg3IDEwLjczMTggMS4wMDA0OSA4LjUgMS4wMDA0OUM0LjYzNDAxIDEuMDAwNDkgMS41IDQuMTM0NSAxLjUgOC4wMDA0OUMxLjUgMTEuODY2NSA0LjYzNDAxIDE1LjAwMDUgOC41IDE1LjAwMDVDMTEuNjg0NCAxNS4wMDA1IDE0LjM3MDMgMTIuODc0OCAxNS4yMTk5IDkuOTY2NjFDMTUuMzM2MSA5LjU2OTAyIDE1LjEwNzkgOS4xNTI1NCAxNC43MTAzIDkuMDM2MzhDMTQuMzEyNyA4LjkyMDIzIDEzLjg5NjIgOS4xNDgzOCAxMy43ODAxIDkuNTQ1OTdDMTMuMTEyMyAxMS44MzE5IDExIDEzLjUwMDUgOC41IDEzLjUwMDVDNS40NjI0MyAxMy41MDA1IDMgMTEuMDM4MSAzIDguMDAwNDlDMyA0Ljk2MjkyIDUuNDYyNDMgMi41MDA0OSA4LjUgMi41MDA0OUMxMC4zMjEgMi41MDA0OSAxMS45MzYzIDMuMzg1NSAxMi45Mzc3IDQuNzUwNDlIMTAuNUMxMC4wODU4IDQuNzUwNDkgOS43NSA1LjA4NjI3IDkuNzUgNS41MDA0OUM5Ljc1IDUuOTE0NyAxMC4wODU4IDYuMjUwNDkgMTAuNSA2LjI1MDQ5SDE0Ljc1QzE1LjE2NDIgNi4yNTA0OSAxNS41IDUuOTE0NyAxNS41IDUuNTAwNDlWMS4yNTA0OVpcIj48L3BhdGg+PC9nPjxkZWZzPjxjbGlwUGF0aCBpZD1jbGlwMF8zNjc2XzE2MDM+PHJlY3Qgd2lkdGg9MTYgaGVpZ2h0PTE2IGZpbGw9d2hpdGUgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAuNSAwLjAwMDQ4ODI4MSlcIj5gKTtcbmNvbnN0IFJldHJ5SWNvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IGZpbGwgPSAoKSA9PiBwcm9wcy5maWxsIHx8IHRoZW1lLmNvbG9ycy5hY2NlbnQ7XG4gIHJldHVybiAoKCkgPT4ge1xuICAgIHZhciBfZWwkID0gX3RtcGwkJGgoKSwgX2VsJDIgPSBfZWwkLmZpcnN0Q2hpbGQsIF9lbCQzID0gX2VsJDIuZmlyc3RDaGlsZDtcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKCkgPT4gc2V0QXR0cmlidXRlKF9lbCQzLCBcImZpbGxcIiwgZmlsbCgpKSk7XG4gICAgcmV0dXJuIF9lbCQ7XG4gIH0pKCk7XG59O1xudmFyIF90bXBsJCRnID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcgd2lkdGg9MTYgaGVpZ2h0PTE2IHZpZXdCb3g9XCIwIDAgMTYgMTZcImZpbGw9bm9uZT48cGF0aCBmaWxsLXJ1bGU9ZXZlbm9kZCBjbGlwLXJ1bGU9ZXZlbm9kZCBkPVwiTTEzIDQuMDYxMTlWNi43NTA1M0MxMyA3LjE2NDc0IDEzLjMzNTggNy41MDA1MyAxMy43NSA3LjUwMDUzQzE0LjE2NDIgNy41MDA1MyAxNC41IDcuMTY0NzQgMTQuNSA2Ljc1MDUzVjIuNzUwNTNMMTQuNSAyLjcyODA3QzE0LjUwMDEgMi42MzE5MSAxNC41MDAzIDIuNDk2MjcgMTQuNDg0MiAyLjM3NjI3QzE0LjQ2MzggMi4yMjUwMyAxNC40MDYzIDEuOTkyNjEgMTQuMjA3MSAxLjc5MzQyQzE0LjAwNzkgMS41OTQyMyAxMy43NzU1IDEuNTM2NyAxMy42MjQzIDEuNTE2MzdDMTMuNTA0MyAxLjUwMDIzIDEzLjM2ODYgMS41MDAzOSAxMy4yNzI1IDEuNTAwNTFMMTMuMjUgMS41MDA1M0g5LjI1QzguODM1NzkgMS41MDA1MyA4LjUgMS44MzYzMSA4LjUgMi4yNTA1M0M4LjUgMi42NjQ3NCA4LjgzNTc5IDMuMDAwNTMgOS4yNSAzLjAwMDUzSDExLjkzOTNMNy4yMTk2NyA3LjcyMDJDNi45MjY3OCA4LjAxMzA5IDYuOTI2NzggOC40ODc5NiA3LjIxOTY3IDguNzgwODZDNy41MTI1NiA5LjA3Mzc1IDcuOTg3NDQgOS4wNzM3NSA4LjI4MDMzIDguNzgwODZMMTMgNC4wNjExOVpNNS44NSAxLjUwMDUzSDUuODE5MDNINS44MTg5OUM1LjIxNTI4IDEuNTAwNTIgNC43MTcwMiAxLjUwMDUxIDQuMzExMTMgMS41MzM2N0MzLjg4OTU2IDEuNTY4MTIgMy41MDIwMyAxLjY0MjA0IDMuMTM4MDMgMS44Mjc1MUMyLjU3MzU0IDIuMTE1MTMgMi4xMTQ2IDIuNTc0MDcgMS44MjY5OCAzLjEzODU2QzEuNjQxNTEgMy41MDI1NiAxLjU2NzU5IDMuODkwMDkgMS41MzMxNSA0LjMxMTY2QzEuNDk5OTggNC43MTc1NSAxLjQ5OTk5IDUuMjE1ODEgMS41IDUuODE5NTNWNS44MTk1NVY1Ljg1MDUzVjEwLjE1MDVWMTAuMTgxNVYxMC4xODE1QzEuNDk5OTkgMTAuNzg1MiAxLjQ5OTk4IDExLjI4MzUgMS41MzMxNSAxMS42ODk0QzEuNTY3NTkgMTIuMTExIDEuNjQxNTEgMTIuNDk4NSAxLjgyNjk4IDEyLjg2MjVDMi4xMTQ2IDEzLjQyNyAyLjU3MzU0IDEzLjg4NTkgMy4xMzgwMyAxNC4xNzM1QzMuNTAyMDMgMTQuMzU5IDMuODg5NTYgMTQuNDMyOSA0LjMxMTEzIDE0LjQ2NzRDNC43MTcwMiAxNC41MDA1IDUuMjE1MjcgMTQuNTAwNSA1LjgxODk3IDE0LjUwMDVINS44MTkwMUg1Ljg1SDEwLjE1SDEwLjE4MUgxMC4xODFDMTAuNzg0NyAxNC41MDA1IDExLjI4MyAxNC41MDA1IDExLjY4ODkgMTQuNDY3NEMxMi4xMTA0IDE0LjQzMjkgMTIuNDk4IDE0LjM1OSAxMi44NjIgMTQuMTczNUMxMy40MjY1IDEzLjg4NTkgMTMuODg1NCAxMy40MjcgMTQuMTczIDEyLjg2MjVDMTQuMzU4NSAxMi40OTg1IDE0LjQzMjQgMTIuMTExIDE0LjQ2NjkgMTEuNjg5NEMxNC41IDExLjI4MzUgMTQuNSAxMC43ODUzIDE0LjUgMTAuMTgxNlYxMC4xODE1VjEwLjE1MDVWOS43NTA1M0MxNC41IDkuMzM2MzEgMTQuMTY0MiA5LjAwMDUzIDEzLjc1IDkuMDAwNTNDMTMuMzM1OCA5LjAwMDUzIDEzIDkuMzM2MzEgMTMgOS43NTA1M1YxMC4xNTA1QzEzIDEwLjc5MyAxMi45OTk0IDExLjIyOTcgMTIuOTcxOCAxMS41NjcyQzEyLjk0NSAxMS44OTYxIDEyLjg5NjMgMTIuMDY0MiAxMi44MzY1IDEyLjE4MTVDMTIuNjkyNyAxMi40NjM4IDEyLjQ2MzIgMTIuNjkzMiAxMi4xODEgMTIuODM3QzEyLjA2MzcgMTIuODk2OCAxMS44OTU1IDEyLjk0NTUgMTEuNTY2NyAxMi45NzI0QzExLjIyOTIgMTIuOTk5OSAxMC43OTI0IDEzLjAwMDUgMTAuMTUgMTMuMDAwNUg1Ljg1QzUuMjA3NTcgMTMuMDAwNSA0Ljc3MDg1IDEyLjk5OTkgNC40MzMyOCAxMi45NzI0QzQuMTA0NDcgMTIuOTQ1NSAzLjkzNjMyIDEyLjg5NjggMy44MTkwMiAxMi44MzdDMy41MzY3NyAxMi42OTMyIDMuMzA3MyAxMi40NjM4IDMuMTYzNDkgMTIuMTgxNUMzLjEwMzcyIDEyLjA2NDIgMy4wNTUwMyAxMS44OTYxIDMuMDI4MTYgMTEuNTY3MkMzLjAwMDU4IDExLjIyOTcgMyAxMC43OTMgMyAxMC4xNTA1VjUuODUwNTNDMyA1LjIwODA5IDMuMDAwNTggNC43NzEzNyAzLjAyODE2IDQuNDMzODFDMy4wNTUwMyA0LjEwNDk5IDMuMTAzNzIgMy45MzY4NCAzLjE2MzQ5IDMuODE5NTRDMy4zMDczIDMuNTM3MyAzLjUzNjc3IDMuMzA3ODMgMy44MTkwMiAzLjE2NDAyQzMuOTM2MzIgMy4xMDQyNSA0LjEwNDQ3IDMuMDU1NTYgNC40MzMyOCAzLjAyODY5QzQuNzcwODUgMy4wMDExMSA1LjIwNzU3IDMuMDAwNTMgNS44NSAzLjAwMDUzSDYuMjVDNi42NjQyMiAzLjAwMDUzIDcgMi42NjQ3NCA3IDIuMjUwNTNDNyAxLjgzNjMxIDYuNjY0MjIgMS41MDA1MyA2LjI1IDEuNTAwNTNINS44NVpcIj5gKTtcbmNvbnN0IExpbmtJY29uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3QgZmlsbCA9ICgpID0+IHByb3BzLmZpbGwgfHwgdGhlbWUuY29sb3JzLmFjY2VudDtcbiAgcmV0dXJuICgoKSA9PiB7XG4gICAgdmFyIF9lbCQgPSBfdG1wbCQkZygpLCBfZWwkMiA9IF9lbCQuZmlyc3RDaGlsZDtcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKCkgPT4gc2V0QXR0cmlidXRlKF9lbCQyLCBcImZpbGxcIiwgZmlsbCgpKSk7XG4gICAgcmV0dXJuIF9lbCQ7XG4gIH0pKCk7XG59O1xudmFyIF90bXBsJCRmID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcgd2lkdGg9MTcgaGVpZ2h0PTE2IHZpZXdCb3g9XCIwIDAgMTcgMTZcImZpbGw9bm9uZT48ZyBjbGlwLXBhdGg9dXJsKCNjbGlwMF8zNjc2XzEyNzQpPjxwYXRoIGZpbGwtcnVsZT1ldmVub2RkIGNsaXAtcnVsZT1ldmVub2RkIGQ9XCJNMS44MjY5OCAyLjYzOTAxQzEuNSAzLjI4MDc0IDEuNSA0LjEyMDgyIDEuNSA1LjgwMDk4VjguODAwOThWOS4wMDA5OFYxMC4yMDFDMS41IDExLjg4MTEgMS41IDEyLjcyMTIgMS44MjY5OCAxMy4zNjI5QzIuMTE0NiAxMy45Mjc0IDIuNTczNTQgMTQuMzg2NCAzLjEzODAzIDE0LjY3NEMzLjc3OTc2IDE1LjAwMSA0LjYxOTg0IDE1LjAwMSA2LjMgMTUuMDAxSDExLjdDMTMuMzgwMiAxNS4wMDEgMTQuMjIwMiAxNS4wMDEgMTQuODYyIDE0LjY3NEMxNS40MjY1IDE0LjM4NjQgMTUuODg1NCAxMy45Mjc0IDE2LjE3MyAxMy4zNjI5QzE2LjUgMTIuNzIxMiAxNi41IDExLjg4MTEgMTYuNSAxMC4yMDFWOC44MDA5OEMxNi41IDcuMTIwODIgMTYuNSA2LjI4MDc0IDE2LjE3MyA1LjYzOTAxQzE1Ljg4NTQgNS4wNzQ1MiAxNS40MjY1IDQuNjE1NTggMTQuODYyIDQuMzI3OTZDMTQuNzQzIDQuMjY3MzMgMTQuNjE3MiA0LjIxNzk1IDE0LjQ4MDUgNC4xNzc3MkMxNC40NTAxIDMuNDk0NDkgMTQuMzcyMiAzLjAyOTk0IDE0LjE3MyAyLjYzOTAxQzEzLjg4NTQgMi4wNzQ1MiAxMy40MjY1IDEuNjE1NTggMTIuODYyIDEuMzI3OTZDMTIuMjIwMiAxLjAwMDk4IDExLjM4MDIgMS4wMDA5OCA5LjcgMS4wMDA5OEg2LjNDNC42MTk4NCAxLjAwMDk4IDMuNzc5NzYgMS4wMDA5OCAzLjEzODAzIDEuMzI3OTZDMi41NzM1NCAxLjYxNTU4IDIuMTE0NiAyLjA3NDUyIDEuODI2OTggMi42MzkwMVpNMTIuOTg2MSA0LjAwOTQyQzEyLjk2ODQgMy43MTA4IDEyLjkyODEgMy40OTk4MiAxMi44MzY1IDMuMzE5OTlDMTIuNjkyNyAzLjAzNzc1IDEyLjQ2MzIgMi44MDgyOCAxMi4xODEgMi42NjQ0N0MxMS44NjAxIDIuNTAwOTggMTEuNDQwMSAyLjUwMDk4IDEwLjYgMi41MDA5OEg1LjRDNC41NTk5MiAyLjUwMDk4IDQuMTM5ODggMi41MDA5OCAzLjgxOTAxIDIuNjY0NDdDMy41MzY3NyAyLjgwODI4IDMuMzA3MyAzLjAzNzc1IDMuMTYzNDkgMy4zMTk5OUMzLjAzNjE1IDMuNTY5OTEgMy4wMDc5OSAzLjg4IDMuMDAxNzcgNC40MDE4OEMzLjA0NjQ2IDQuMzc2MTIgMy4wOTE4OSA0LjM1MTQ2IDMuMTM4MDMgNC4zMjc5NkMzLjc3OTc2IDQuMDAwOTggNC42MTk4NCA0LjAwMDk4IDYuMyA0LjAwMDk4SDExLjdDMTIuMTk2NiA0LjAwMDk4IDEyLjYxOTcgNC4wMDA5OCAxMi45ODYxIDQuMDA5NDJaTTMgNy45MDA5OFY4LjEwMDk4QzMgOC40NzQ2OCAzIDguNzY1MjcgMy4wMTQzOSA5LjAwMDk4SDNWMTEuMTAxQzMgMTEuOTQxMSAzIDEyLjM2MTEgMy4xNjM0OSAxMi42ODJDMy4zMDczIDEyLjk2NDIgMy41MzY3NyAxMy4xOTM3IDMuODE5MDEgMTMuMzM3NUM0LjEzOTg4IDEzLjUwMSA0LjU1OTkyIDEzLjUwMSA1LjQgMTMuNTAxSDEyLjZDMTMuNDQwMSAxMy41MDEgMTMuODYwMSAxMy41MDEgMTQuMTgxIDEzLjMzNzVDMTQuNDYzMiAxMy4xOTM3IDE0LjY5MjcgMTIuOTY0MiAxNC44MzY1IDEyLjY4MkMxNSAxMi4zNjExIDE1IDExLjk0MTEgMTUgMTEuMTAxVjcuOTAwOThDMTUgNy4wNjA5IDE1IDYuNjQwODYgMTQuODM2NSA2LjMxOTk5QzE0LjY5MjcgNi4wMzc3NSAxNC40NjMyIDUuODA4MjggMTQuMTgxIDUuNjY0NDdDMTMuODYwMSA1LjUwMDk4IDEzLjQ0MDEgNS41MDA5OCAxMi42IDUuNTAwOThINS40QzQuNTU5OTIgNS41MDA5OCA0LjEzOTg4IDUuNTAwOTggMy44MTkwMSA1LjY2NDQ3QzMuNTM2NzcgNS44MDgyOCAzLjMwNzMgNi4wMzc3NSAzLjE2MzQ5IDYuMzE5OTlDMyA2LjY0MDg2IDMgNy4wNjA5IDMgNy45MDA5OFpNMTAuNSA5Ljc1MDk4QzEwLjUgOS4zMzY3NiAxMC44MzU4IDkuMDAwOTggMTEuMjUgOS4wMDA5OEgxMi43NUMxMy4xNjQyIDkuMDAwOTggMTMuNSA5LjMzNjc2IDEzLjUgOS43NTA5OEMxMy41IDEwLjE2NTIgMTMuMTY0MiAxMC41MDEgMTIuNzUgMTAuNTAxSDExLjI1QzEwLjgzNTggMTAuNTAxIDEwLjUgMTAuMTY1MiAxMC41IDkuNzUwOThaXCI+PC9wYXRoPjwvZz48ZGVmcz48Y2xpcFBhdGggaWQ9Y2xpcDBfMzY3Nl8xMjc0PjxyZWN0IHdpZHRoPTE2IGhlaWdodD0xNiBmaWxsPXdoaXRlIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgwLjUgMC4wMDA5NzY1NjIpXCI+YCk7XG5jb25zdCBXYWxsZXRJY29uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3QgZmlsbCA9ICgpID0+IHByb3BzLmZpbGwgfHwgdGhlbWUuY29sb3JzLmFjY2VudDtcbiAgcmV0dXJuICgoKSA9PiB7XG4gICAgdmFyIF9lbCQgPSBfdG1wbCQkZigpLCBfZWwkMiA9IF9lbCQuZmlyc3RDaGlsZCwgX2VsJDMgPSBfZWwkMi5maXJzdENoaWxkO1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoKSA9PiBzZXRBdHRyaWJ1dGUoX2VsJDMsIFwiZmlsbFwiLCBmaWxsKCkpKTtcbiAgICByZXR1cm4gX2VsJDtcbiAgfSkoKTtcbn07XG52YXIgX3RtcGwkJGUgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyB3aWR0aD00OCBoZWlnaHQ9NDggdmlld0JveD1cIjAgMCA0OCA0OFwiZmlsbD1ub25lPjxwYXRoIGZpbGwtcnVsZT1ldmVub2RkIGNsaXAtcnVsZT1ldmVub2RkIGQ9XCJNMzkuNjMxOSAxNi44NzE5QzM4LjMyMTIgMTYuMjA0MSAzNi43MDAyIDE2LjA0NzggMzQgMTYuMDExMlYxMUMzNCA1LjQ3NzE1IDI5LjUyMjggMSAyNCAxQzE4LjQ3NzIgMSAxNCA1LjQ3NzE1IDE0IDExVjE2LjAxMTJDMTEuMjk5OCAxNi4wNDc4IDkuNjc4OCAxNi4yMDQxIDguMzY4MDggMTYuODcxOUM2Ljg2Mjc4IDE3LjYzODkgNS42Mzg5MyAxOC44NjI4IDQuODcxOTUgMjAuMzY4MUM0IDIyLjA3OTQgNCAyNC4zMTk2IDQgMjguOFYzMi4yQzQgMzYuNjgwNCA0IDM4LjkyMDYgNC44NzE5NSA0MC42MzE5QzUuNjM4OTMgNDIuMTM3MiA2Ljg2Mjc4IDQzLjM2MTEgOC4zNjgwOCA0NC4xMjgxQzEwLjA3OTQgNDUgMTIuMzE5NiA0NSAxNi44IDQ1SDMxLjJDMzUuNjgwNCA0NSAzNy45MjA2IDQ1IDM5LjYzMTkgNDQuMTI4MUM0MS4xMzcyIDQzLjM2MTEgNDIuMzYxMSA0Mi4xMzcyIDQzLjEyODEgNDAuNjMxOUM0NCAzOC45MjA2IDQ0IDM2LjY4MDQgNDQgMzIuMlYyOC44QzQ0IDI0LjMxOTYgNDQgMjIuMDc5NCA0My4xMjgxIDIwLjM2ODFDNDIuMzYxMSAxOC44NjI4IDQxLjEzNzIgMTcuNjM4OSAzOS42MzE5IDE2Ljg3MTlaTTMxIDExVjE2SDE3VjExQzE3IDcuMTM0MDEgMjAuMTM0IDQgMjQgNEMyNy44NjYgNCAzMSA3LjEzNDAxIDMxIDExWk03LjU0NDk3IDIxLjczQzcgMjIuNzk5NiA3IDI0LjE5OTcgNyAyN1YzNEM3IDM2LjgwMDMgNyAzOC4yMDA0IDcuNTQ0OTcgMzkuMjdDOC4wMjQzMyA0MC4yMTA4IDguNzg5MjQgNDAuOTc1NyA5LjczMDA1IDQxLjQ1NUMxMC43OTk2IDQyIDEyLjE5OTcgNDIgMTUgNDJIMzNDMzUuODAwMyA0MiAzNy4yMDA0IDQyIDM4LjI3IDQxLjQ1NUMzOS4yMTA4IDQwLjk3NTcgMzkuOTc1NyA0MC4yMTA4IDQwLjQ1NSAzOS4yN0M0MSAzOC4yMDA0IDQxIDM2LjgwMDMgNDEgMzRWMjdDNDEgMjQuMTk5NyA0MSAyMi43OTk2IDQwLjQ1NSAyMS43M0MzOS45NzU3IDIwLjc4OTIgMzkuMjEwOCAyMC4wMjQzIDM4LjI3IDE5LjU0NUMzNy4yMDA0IDE5IDM1LjgwMDMgMTkgMzMgMTlIMTVDMTIuMTk5NyAxOSAxMC43OTk2IDE5IDkuNzMwMDUgMTkuNTQ1QzguNzg5MjQgMjAuMDI0MyA4LjAyNDMzIDIwLjc4OTIgNy41NDQ5NyAyMS43M1pNMjQgMjRDMjMuMTcxNiAyNCAyMi41IDI0LjY3MTYgMjIuNSAyNS41VjI5LjVDMjIuNSAzMC4zMjg0IDIzLjE3MTYgMzEgMjQgMzFDMjQuODI4NCAzMSAyNS41IDMwLjMyODQgMjUuNSAyOS41VjI1LjVDMjUuNSAyNC42NzE2IDI0LjgyODQgMjQgMjQgMjRaXCI+YCk7XG5jb25zdCBTZWN1cml0eUljb24gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCBmaWxsID0gKCkgPT4gcHJvcHMuZmlsbCB8fCB0aGVtZS5jb2xvcnMuaWNvbi5zZWNvbmRhcnk7XG4gIHJldHVybiAoKCkgPT4ge1xuICAgIHZhciBfZWwkID0gX3RtcGwkJGUoKSwgX2VsJDIgPSBfZWwkLmZpcnN0Q2hpbGQ7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KChfcCQpID0+IHtcbiAgICAgIHZhciBfdiQgPSBwcm9wcy5jbGFzcywgX3YkMiA9IGZpbGwoKTtcbiAgICAgIF92JCAhPT0gX3AkLmUgJiYgc2V0QXR0cmlidXRlKF9lbCQsIFwiY2xhc3NcIiwgX3AkLmUgPSBfdiQpO1xuICAgICAgX3YkMiAhPT0gX3AkLnQgJiYgc2V0QXR0cmlidXRlKF9lbCQyLCBcImZpbGxcIiwgX3AkLnQgPSBfdiQyKTtcbiAgICAgIHJldHVybiBfcCQ7XG4gICAgfSwge1xuICAgICAgZTogdm9pZCAwLFxuICAgICAgdDogdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIF9lbCQ7XG4gIH0pKCk7XG59O1xudmFyIF90bXBsJCRkID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcgd2lkdGg9NDggaGVpZ2h0PTQ4IHZpZXdCb3g9XCIwIDAgNDggNDhcImZpbGw9bm9uZT48cGF0aCBmaWxsLXJ1bGU9ZXZlbm9kZCBjbGlwLXJ1bGU9ZXZlbm9kZCBkPVwiTTM3LjQ4NSAzNy4zODQ5QzQwLjg5NCAzMy45NTA2IDQzIDI5LjIyMTIgNDMgMjRDNDMgMTMuNTA2NiAzNC40OTM0IDUgMjQgNUMxMy41MDY2IDUgNSAxMy41MDY2IDUgMjRDNSAyOS4yMjEzIDcuMTA2MSAzMy45NTA3IDEwLjUxNTEgMzcuMzg1QzEzLjM1ODMgMzIuOTQzOCAxOC4zMzU0IDMwIDI0LjAwMDEgMzBDMjkuNjY0NyAzMCAzNC42NDE4IDMyLjk0MzcgMzcuNDg1IDM3LjM4NDlaTTM1LjE4MDkgMzkuMzYzNUMzMi45MTQzIDM1LjU1MzIgMjguNzU1NCAzMyAyNC4wMDAxIDMzQzE5LjI0NDggMzMgMTUuMDg1OCAzNS41NTMzIDEyLjgxOTMgMzkuMzYzNkMxNS45NTY0IDQxLjY1MDYgMTkuODIwNiA0MyAyNCA0M0MyOC4xNzk1IDQzIDMyLjA0MzcgNDEuNjUwNSAzNS4xODA5IDM5LjM2MzVaTTI0IDQ2QzM2LjE1MDMgNDYgNDYgMzYuMTUwMyA0NiAyNEM0NiAxMS44NDk3IDM2LjE1MDMgMiAyNCAyQzExLjg0OTcgMiAyIDExLjg0OTcgMiAyNEMyIDM2LjE1MDMgMTEuODQ5NyA0NiAyNCA0NlpNMjQgMjRDMjYuNzYxNCAyNCAyOSAyMS43NjE0IDI5IDE5QzI5IDE2LjIzODYgMjYuNzYxNCAxNCAyNCAxNEMyMS4yMzg2IDE0IDE5IDE2LjIzODYgMTkgMTlDMTkgMjEuNzYxNCAyMS4yMzg2IDI0IDI0IDI0Wk0yNCAyN0MyOC40MTgzIDI3IDMyIDIzLjQxODMgMzIgMTlDMzIgMTQuNTgxNyAyOC40MTgzIDExIDI0IDExQzE5LjU4MTcgMTEgMTYgMTQuNTgxNyAxNiAxOUMxNiAyMy40MTgzIDE5LjU4MTcgMjcgMjQgMjdaXCI+YCk7XG5jb25zdCBQZXJzb25hbGl0eUljb24gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCBmaWxsID0gKCkgPT4gcHJvcHMuZmlsbCB8fCB0aGVtZS5jb2xvcnMuaWNvbi5zZWNvbmRhcnk7XG4gIHJldHVybiAoKCkgPT4ge1xuICAgIHZhciBfZWwkID0gX3RtcGwkJGQoKSwgX2VsJDIgPSBfZWwkLmZpcnN0Q2hpbGQ7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KChfcCQpID0+IHtcbiAgICAgIHZhciBfdiQgPSBwcm9wcy5jbGFzcywgX3YkMiA9IGZpbGwoKTtcbiAgICAgIF92JCAhPT0gX3AkLmUgJiYgc2V0QXR0cmlidXRlKF9lbCQsIFwiY2xhc3NcIiwgX3AkLmUgPSBfdiQpO1xuICAgICAgX3YkMiAhPT0gX3AkLnQgJiYgc2V0QXR0cmlidXRlKF9lbCQyLCBcImZpbGxcIiwgX3AkLnQgPSBfdiQyKTtcbiAgICAgIHJldHVybiBfcCQ7XG4gICAgfSwge1xuICAgICAgZTogdm9pZCAwLFxuICAgICAgdDogdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIF9lbCQ7XG4gIH0pKCk7XG59O1xudmFyIF90bXBsJCRjID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcgd2lkdGg9NDggaGVpZ2h0PTQ4IHZpZXdCb3g9XCIwIDAgNDggNDhcImZpbGw9bm9uZT48cGF0aCBmaWxsLXJ1bGU9ZXZlbm9kZCBjbGlwLXJ1bGU9ZXZlbm9kZCBkPVwiTTM0LjU2MDcgNC40MzkzNEMzMy45NzQ5IDMuODUzNTUgMzMuMDI1MSAzLjg1MzU1IDMyLjQzOTMgNC40MzkzNEMzMS44NTM2IDUuMDI1MTMgMzEuODUzNiA1Ljk3NDg3IDMyLjQzOTMgNi41NjA2NkwzNy44Nzg3IDEySDEwLjVDOS42NzE1NyAxMiA5IDEyLjY3MTYgOSAxMy41QzkgMTQuMzI4NCA5LjY3MTU3IDE1IDEwLjUgMTVIMzcuODc4N0wzMi40MzkzIDIwLjQzOTNDMzEuODUzNiAyMS4wMjUxIDMxLjg1MzYgMjEuOTc0OSAzMi40MzkzIDIyLjU2MDdDMzMuMDI1MSAyMy4xNDY0IDMzLjk3NDkgMjMuMTQ2NCAzNC41NjA3IDIyLjU2MDdMNDIuNTYwNyAxNC41NjA3QzQzLjE0NjQgMTMuOTc0OSA0My4xNDY0IDEzLjAyNTEgNDIuNTYwNyAxMi40MzkzTDM0LjU2MDcgNC40MzkzNFpNMTMuNDM5MyAyNS40MzkzQzE0LjAyNTEgMjQuODUzNiAxNC45NzQ5IDI0Ljg1MzYgMTUuNTYwNyAyNS40MzkzQzE2LjE0NjQgMjYuMDI1MSAxNi4xNDY0IDI2Ljk3NDkgMTUuNTYwNyAyNy41NjA3TDEwLjEyMTMgMzNIMzcuNUMzOC4zMjg0IDMzIDM5IDMzLjY3MTYgMzkgMzQuNUMzOSAzNS4zMjg0IDM4LjMyODQgMzYgMzcuNSAzNkgxMC4xMjEzTDE1LjU2MDcgNDEuNDM5M0MxNi4xNDY0IDQyLjAyNTEgMTYuMTQ2NCA0Mi45NzQ5IDE1LjU2MDcgNDMuNTYwN0MxNC45NzQ5IDQ0LjE0NjQgMTQuMDI1MSA0NC4xNDY0IDEzLjQzOTMgNDMuNTYwN0w1LjQzOTM0IDM1LjU2MDdDNC44NTM1NSAzNC45NzQ5IDQuODUzNTUgMzQuMDI1MSA1LjQzOTM0IDMzLjQzOTNMMTMuNDM5MyAyNS40MzkzWlwiPmApO1xuY29uc3QgU3dhcEljb24gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCBmaWxsID0gKCkgPT4gcHJvcHMuZmlsbCB8fCB0aGVtZS5jb2xvcnMuaWNvbi5zZWNvbmRhcnk7XG4gIHJldHVybiAoKCkgPT4ge1xuICAgIHZhciBfZWwkID0gX3RtcGwkJGMoKSwgX2VsJDIgPSBfZWwkLmZpcnN0Q2hpbGQ7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KChfcCQpID0+IHtcbiAgICAgIHZhciBfdiQgPSBwcm9wcy5jbGFzcywgX3YkMiA9IGZpbGwoKTtcbiAgICAgIF92JCAhPT0gX3AkLmUgJiYgc2V0QXR0cmlidXRlKF9lbCQsIFwiY2xhc3NcIiwgX3AkLmUgPSBfdiQpO1xuICAgICAgX3YkMiAhPT0gX3AkLnQgJiYgc2V0QXR0cmlidXRlKF9lbCQyLCBcImZpbGxcIiwgX3AkLnQgPSBfdiQyKTtcbiAgICAgIHJldHVybiBfcCQ7XG4gICAgfSwge1xuICAgICAgZTogdm9pZCAwLFxuICAgICAgdDogdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIF9lbCQ7XG4gIH0pKCk7XG59O1xudmFyIF90bXBsJCRiID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcgd2lkdGg9MjggaGVpZ2h0PTI4IHZpZXdCb3g9XCIwIDAgMjggMjhcImZpbGw9bm9uZT48cGF0aCBmaWxsLXJ1bGU9ZXZlbm9kZCBjbGlwLXJ1bGU9ZXZlbm9kZCBkPVwiTTEuNzUgMTIuMDAyQzEuNzUgOS4yMDE2OSAxLjc1IDcuODAxNTYgMi4yOTQ5NyA2LjczMkMyLjc3NDMzIDUuNzkxMTkgMy41MzkyNCA1LjAyNjI5IDQuNDgwMDUgNC41NDY5MkM1LjU0OTYxIDQuMDAxOTUgNi45NDk3NCA0LjAwMTk1IDkuNzUgNC4wMDE5NUgxNy4yNUMyMC4wNTAzIDQuMDAxOTUgMjEuNDUwNCA0LjAwMTk1IDIyLjUyIDQuNTQ2OTJDMjMuNDYwOCA1LjAyNjI5IDI0LjIyNTcgNS43OTExOSAyNC43MDUgNi43MzJDMjQuODI1NiA2Ljk2ODYxIDI0LjkxOTUgNy4yMjE0IDI0Ljk5MjYgNy41MDE5NUgyMS41QzE5LjYzNzcgNy41MDE5NSAxOC43MDY1IDcuNTAxOTUgMTcuOTYwOSA3Ljc3MzM0QzE2LjcxMSA4LjIyODI4IDE1LjcyNjMgOS4yMTI5MSAxNS4yNzE0IDEwLjQ2MjlDMTUgMTEuMjA4NSAxNSAxMi4xMzk2IDE1IDE0LjAwMkMxNSAxNS44NjQzIDE1IDE2Ljc5NTQgMTUuMjcxNCAxNy41NDFDMTUuNzI2MyAxOC43OTEgMTYuNzExIDE5Ljc3NTYgMTcuOTYwOSAyMC4yMzA2QzE4LjcwNjUgMjAuNTAyIDE5LjYzNzcgMjAuNTAyIDIxLjUgMjAuNTAySDI0Ljk5MjZDMjQuOTE5NSAyMC43ODI1IDI0LjgyNTYgMjEuMDM1MyAyNC43MDUgMjEuMjcxOUMyNC4yMjU3IDIyLjIxMjcgMjMuNDYwOCAyMi45Nzc2IDIyLjUyIDIzLjQ1N0MyMS40NTA0IDI0LjAwMiAyMC4wNTAzIDI0LjAwMiAxNy4yNSAyNC4wMDJIOS43NUM2Ljk0OTc0IDI0LjAwMiA1LjU0OTYxIDI0LjAwMiA0LjQ4MDA1IDIzLjQ1N0MzLjUzOTI0IDIyLjk3NzYgMi43NzQzMyAyMi4yMTI3IDIuMjk0OTcgMjEuMjcxOUMxLjc1IDIwLjIwMjMgMS43NSAxOC44MDIyIDEuNzUgMTYuMDAyVjEyLjAwMlpNMTYuNDk5OSAxMy44MDJDMTYuNDk5OSAxMi4xMjE4IDE2LjQ5OTkgMTEuMjgxNyAxNi44MjY5IDEwLjY0QzE3LjExNDUgMTAuMDc1NSAxNy41NzM1IDkuNjE2NTYgMTguMTM4IDkuMzI4OTRDMTguNzc5NyA5LjAwMTk2IDE5LjYxOTggOS4wMDE5NiAyMS4yOTk5IDkuMDAxOTZIMjMuMTk5OUMyNC44ODAxIDkuMDAxOTYgMjUuNzIwMiA5LjAwMTk2IDI2LjM2MTkgOS4zMjg5NEMyNi45MjY0IDkuNjE2NTYgMjcuMzg1MyAxMC4wNzU1IDI3LjY3MyAxMC42NEMyNy45OTk5IDExLjI4MTcgMjcuOTk5OSAxMi4xMjE4IDI3Ljk5OTkgMTMuODAyVjE0LjIwMkMyNy45OTk5IDE1Ljg4MjEgMjcuOTk5OSAxNi43MjIyIDI3LjY3MyAxNy4zNjM5QzI3LjM4NTMgMTcuOTI4NCAyNi45MjY0IDE4LjM4NzQgMjYuMzYxOSAxOC42NzVDMjUuNzIwMiAxOS4wMDIgMjQuODgwMSAxOS4wMDIgMjMuMTk5OSAxOS4wMDJIMjEuMjk5OUMxOS42MTk4IDE5LjAwMiAxOC43Nzk3IDE5LjAwMiAxOC4xMzggMTguNjc1QzE3LjU3MzUgMTguMzg3NCAxNy4xMTQ1IDE3LjkyODQgMTYuODI2OSAxNy4zNjM5QzE2LjQ5OTkgMTYuNzIyMiAxNi40OTk5IDE1Ljg4MjEgMTYuNDk5OSAxNC4yMDJWMTMuODAyWk0yMi40OTk5IDE0LjAwMkMyMi40OTk5IDE0Ljk2ODUgMjEuNzE2NCAxNS43NTIgMjAuNzQ5OSAxNS43NTJDMTkuNzgzNCAxNS43NTIgMTguOTk5OSAxNC45Njg1IDE4Ljk5OTkgMTQuMDAyQzE4Ljk5OTkgMTMuMDM1NSAxOS43ODM0IDEyLjI1MiAyMC43NDk5IDEyLjI1MkMyMS43MTY0IDEyLjI1MiAyMi40OTk5IDEzLjAzNTUgMjIuNDk5OSAxNC4wMDJaXCI+YCk7XG5jb25zdCBBdFdhbGxldEljb24gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCBmaWxsID0gKCkgPT4gcHJvcHMuZmlsbCB8fCB0aGVtZS5jb2xvcnMuY29uc3RhbnQud2hpdGU7XG4gIHJldHVybiAoKCkgPT4ge1xuICAgIHZhciBfZWwkID0gX3RtcGwkJGIoKSwgX2VsJDIgPSBfZWwkLmZpcnN0Q2hpbGQ7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KChfcCQpID0+IHtcbiAgICAgIHZhciBfdiQgPSBwcm9wcy5jbGFzcywgX3YkMiA9IGZpbGwoKTtcbiAgICAgIF92JCAhPT0gX3AkLmUgJiYgc2V0QXR0cmlidXRlKF9lbCQsIFwiY2xhc3NcIiwgX3AkLmUgPSBfdiQpO1xuICAgICAgX3YkMiAhPT0gX3AkLnQgJiYgc2V0QXR0cmlidXRlKF9lbCQyLCBcImZpbGxcIiwgX3AkLnQgPSBfdiQyKTtcbiAgICAgIHJldHVybiBfcCQ7XG4gICAgfSwge1xuICAgICAgZTogdm9pZCAwLFxuICAgICAgdDogdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIF9lbCQ7XG4gIH0pKCk7XG59O1xudmFyIF90bXBsJCRhID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcgd2lkdGg9MjggaGVpZ2h0PTI4IHZpZXdCb3g9XCIwIDAgMjggMjhcIj48cGF0aCBmaWxsLXJ1bGU9ZXZlbm9kZCBjbGlwLXJ1bGU9ZXZlbm9kZCBkPVwiTTEwLjAwMDEgMTAuMDAwMUMxMC4wMDE2IDguMDIzMzMgMTAuMDI2NyA2Ljk4NzE5IDEwLjQzNiA2LjE4NDA0QzEwLjgxOTUgNS40MzEzOSAxMS40MzE0IDQuODE5NDcgMTIuMTg0IDQuNDM1OTdDMTMuMDM5NyA0IDE0LjE1OTggNCAxNi40IDRIMTcuNkMxOS44NDAyIDQgMjAuOTYwMyA0IDIxLjgxNiA0LjQzNTk3QzIyLjU2ODYgNC44MTk0NyAyMy4xODA1IDUuNDMxMzkgMjMuNTY0IDYuMTg0MDRDMjQgNy4wMzk2OSAyNCA4LjE1OTc5IDI0IDEwLjRWMTEuNkMyNCAxMy44NDAyIDI0IDE0Ljk2MDMgMjMuNTY0IDE1LjgxNkMyMy4xODA1IDE2LjU2ODYgMjIuNTY4NiAxNy4xODA1IDIxLjgxNiAxNy41NjRDMjEuMDEyOCAxNy45NzMzIDE5Ljk3NjcgMTcuOTk4NCAxNy45OTk5IDE3Ljk5OTlDMTcuOTk4NCAxOS45NzY3IDE3Ljk3MzMgMjEuMDEyOCAxNy41NjQgMjEuODE2QzE3LjE4MDUgMjIuNTY4NiAxNi41Njg2IDIzLjE4MDUgMTUuODE2IDIzLjU2NEMxNC45NjAzIDI0IDEzLjg0MDIgMjQgMTEuNiAyNEgxMC40QzguMTU5NzkgMjQgNy4wMzk2OSAyNCA2LjE4NDA0IDIzLjU2NEM1LjQzMTM5IDIzLjE4MDUgNC44MTk0NyAyMi41Njg2IDQuNDM1OTcgMjEuODE2QzQgMjAuOTYwMyA0IDE5Ljg0MDIgNCAxNy42VjE2LjRDNCAxNC4xNTk4IDQgMTMuMDM5NyA0LjQzNTk3IDEyLjE4NEM0LjgxOTQ3IDExLjQzMTQgNS40MzEzOSAxMC44MTk1IDYuMTg0MDQgMTAuNDM2QzYuOTg3MTkgMTAuMDI2NyA4LjAyMzMzIDEwLjAwMTYgMTAuMDAwMSAxMC4wMDAxWk0xMCAxMS41SDkuNUM4LjA5OTg3IDExLjUgNy4zOTk4IDExLjUgNi44NjUwMiAxMS43NzI1QzYuMzk0NjIgMTIuMDEyMiA2LjAxMjE3IDEyLjM5NDYgNS43NzI0OCAxMi44NjVDNS41IDEzLjM5OTggNS41IDE0LjA5OTkgNS41IDE1LjVWMTguNUM1LjUgMTkuOTAwMSA1LjUgMjAuNjAwMiA1Ljc3MjQ4IDIxLjEzNUM2LjAxMjE3IDIxLjYwNTQgNi4zOTQ2MiAyMS45ODc4IDYuODY1MDIgMjIuMjI3NUM3LjM5OTggMjIuNSA4LjA5OTg3IDIyLjUgOS41IDIyLjVIMTIuNUMxMy45MDAxIDIyLjUgMTQuNjAwMiAyMi41IDE1LjEzNSAyMi4yMjc1QzE1LjYwNTQgMjEuOTg3OCAxNS45ODc4IDIxLjYwNTQgMTYuMjI3NSAyMS4xMzVDMTYuNSAyMC42MDAyIDE2LjUgMTkuOTAwMSAxNi41IDE4LjVWMThIMTYuNEMxNC4xNTk4IDE4IDEzLjAzOTcgMTggMTIuMTg0IDE3LjU2NEMxMS40MzE0IDE3LjE4MDUgMTAuODE5NSAxNi41Njg2IDEwLjQzNiAxNS44MTZDMTAgMTQuOTYwMyAxMCAxMy44NDAyIDEwIDExLjZWMTEuNVpNMTEuNSA5LjVDMTEuNSA4LjA5OTg3IDExLjUgNy4zOTk4IDExLjc3MjUgNi44NjUwMkMxMi4wMTIyIDYuMzk0NjIgMTIuMzk0NiA2LjAxMjE3IDEyLjg2NSA1Ljc3MjQ4QzEzLjM5OTggNS41IDE0LjA5OTkgNS41IDE1LjUgNS41SDE4LjVDMTkuOTAwMSA1LjUgMjAuNjAwMiA1LjUgMjEuMTM1IDUuNzcyNDhDMjEuNjA1NCA2LjAxMjE3IDIxLjk4NzggNi4zOTQ2MiAyMi4yMjc1IDYuODY1MDJDMjIuNSA3LjM5OTggMjIuNSA4LjA5OTg3IDIyLjUgOS41VjEyLjVDMjIuNSAxMy45MDAxIDIyLjUgMTQuNjAwMiAyMi4yMjc1IDE1LjEzNUMyMS45ODc4IDE1LjYwNTQgMjEuNjA1NCAxNS45ODc4IDIxLjEzNSAxNi4yMjc1QzIwLjYwMDIgMTYuNSAxOS45MDAxIDE2LjUgMTguNSAxNi41SDE1LjVDMTQuMDk5OSAxNi41IDEzLjM5OTggMTYuNSAxMi44NjUgMTYuMjI3NUMxMi4zOTQ2IDE1Ljk4NzggMTIuMDEyMiAxNS42MDU0IDExLjc3MjUgMTUuMTM1QzExLjUgMTQuNjAwMiAxMS41IDEzLjkwMDEgMTEuNSAxMi41VjkuNVpcIj5gKTtcbmNvbnN0IENvcHlMaWdodEljb24gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCBmaWxsID0gKCkgPT4gcHJvcHMuZmlsbCB8fCB0aGVtZS5jb2xvcnMuaWNvbi5zZWNvbmRhcnk7XG4gIHJldHVybiAoKCkgPT4ge1xuICAgIHZhciBfZWwkID0gX3RtcGwkJGEoKSwgX2VsJDIgPSBfZWwkLmZpcnN0Q2hpbGQ7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KChfcCQpID0+IHtcbiAgICAgIHZhciBfdiQgPSBmaWxsKCksIF92JDIgPSBmaWxsKCk7XG4gICAgICBfdiQgIT09IF9wJC5lICYmIHNldEF0dHJpYnV0ZShfZWwkLCBcImZpbGxcIiwgX3AkLmUgPSBfdiQpO1xuICAgICAgX3YkMiAhPT0gX3AkLnQgJiYgc2V0QXR0cmlidXRlKF9lbCQyLCBcImZpbGxcIiwgX3AkLnQgPSBfdiQyKTtcbiAgICAgIHJldHVybiBfcCQ7XG4gICAgfSwge1xuICAgICAgZTogdm9pZCAwLFxuICAgICAgdDogdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIF9lbCQ7XG4gIH0pKCk7XG59O1xudmFyIF90bXBsJCQ5ID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcgd2lkdGg9MTYgaGVpZ2h0PTE3IHZpZXdCb3g9XCIwIDAgMTYgMTdcImZpbGw9bm9uZT48cGF0aCBmaWxsLXJ1bGU9ZXZlbm9kZCBjbGlwLXJ1bGU9ZXZlbm9kZCBkPVwiTTEgNC4xMjY5NUMxIDMuMDc3NTQgMSAyLjU1Mjg0IDEuMTkyMDIgMi4xNDY4NEMxLjM4OTg2IDEuNzI4NTYgMS43MjY2IDEuMzkxODEgMi4xNDQ4OSAxLjE5Mzk3QzIuNTUwODggMS4wMDE5NSAzLjA3NTU5IDEuMDAxOTUgNC4xMjUgMS4wMDE5NUM1LjE3NDQxIDEuMDAxOTUgNS42OTkxMiAxLjAwMTk1IDYuMTA1MTEgMS4xOTM5N0M2LjUyMzQgMS4zOTE4MSA2Ljg2MDE0IDEuNzI4NTYgNy4wNTc5OCAyLjE0Njg0QzcuMjUgMi41NTI4NCA3LjI1IDMuMDc3NTQgNy4yNSA0LjEyNjk1QzcuMjUgNS4xNzYzNiA3LjI1IDUuNzAxMDcgNy4wNTc5OCA2LjEwNzA2QzYuODYwMTQgNi41MjUzNSA2LjUyMzQgNi44NjIxIDYuMTA1MTEgNy4wNTk5M0M1LjY5OTEyIDcuMjUxOTUgNS4xNzQ0MSA3LjI1MTk1IDQuMTI1IDcuMjUxOTVDMy4wNzU1OSA3LjI1MTk1IDIuNTUwODggNy4yNTE5NSAyLjE0NDg5IDcuMDU5OTNDMS43MjY2IDYuODYyMSAxLjM4OTg2IDYuNTI1MzUgMS4xOTIwMiA2LjEwNzA2QzEgNS43MDEwNyAxIDUuMTc2MzYgMSA0LjEyNjk1Wk0yLjUgMy4zMDE5NUMyLjUgMy4wMjE5MyAyLjUgMi44ODE5MSAyLjU1NDUgMi43NzQ5NkMyLjYwMjQzIDIuNjgwODggMi42Nzg5MiAyLjYwNDM5IDIuNzczIDIuNTU2NDVDMi44Nzk5NiAyLjUwMTk1IDMuMDE5OTcgMi41MDE5NSAzLjMgMi41MDE5NUg0Ljk1QzUuMjMwMDMgMi41MDE5NSA1LjM3MDA0IDIuNTAxOTUgNS40NzcgMi41NTY0NUM1LjU3MTA4IDIuNjA0MzkgNS42NDc1NyAyLjY4MDg4IDUuNjk1NSAyLjc3NDk2QzUuNzUgMi44ODE5MSA1Ljc1IDMuMDIxOTMgNS43NSAzLjMwMTk1VjQuOTUxOTVDNS43NSA1LjIzMTk4IDUuNzUgNS4zNzE5OSA1LjY5NTUgNS40Nzg5NUM1LjY0NzU3IDUuNTczMDMgNS41NzEwOCA1LjY0OTUyIDUuNDc3IDUuNjk3NDZDNS4zNzAwNCA1Ljc1MTk1IDUuMjMwMDMgNS43NTE5NSA0Ljk1IDUuNzUxOTVIMy4zQzMuMDE5OTcgNS43NTE5NSAyLjg3OTk2IDUuNzUxOTUgMi43NzMgNS42OTc0NkMyLjY3ODkyIDUuNjQ5NTIgMi42MDI0MyA1LjU3MzAzIDIuNTU0NSA1LjQ3ODk1QzIuNSA1LjM3MTk5IDIuNSA1LjIzMTk4IDIuNSA0Ljk1MTk1VjMuMzAxOTVaTTEgMTEuODc3QzEgMTAuODI3NSAxIDEwLjMwMjggMS4xOTIwMiA5Ljg5Njg0QzEuMzg5ODYgOS40Nzg1NiAxLjcyNjYgOS4xNDE4MSAyLjE0NDg5IDguOTQzOTdDMi41NTA4OCA4Ljc1MTk1IDMuMDc1NTkgOC43NTE5NSA0LjEyNSA4Ljc1MTk1QzUuMTc0NDEgOC43NTE5NSA1LjY5OTEyIDguNzUxOTUgNi4xMDUxMSA4Ljk0Mzk3QzYuNTIzNCA5LjE0MTgxIDYuODYwMTQgOS40Nzg1NiA3LjA1Nzk4IDkuODk2ODRDNy4yNSAxMC4zMDI4IDcuMjUgMTAuODI3NSA3LjI1IDExLjg3N0M3LjI1IDEyLjkyNjQgNy4yNSAxMy40NTExIDcuMDU3OTggMTMuODU3MUM2Ljg2MDE0IDE0LjI3NTMgNi41MjM0IDE0LjYxMjEgNi4xMDUxMSAxNC44MDk5QzUuNjk5MTIgMTUuMDAyIDUuMTc0NDEgMTUuMDAyIDQuMTI1IDE1LjAwMkMzLjA3NTU5IDE1LjAwMiAyLjU1MDg4IDE1LjAwMiAyLjE0NDg5IDE0LjgwOTlDMS43MjY2IDE0LjYxMjEgMS4zODk4NiAxNC4yNzUzIDEuMTkyMDIgMTMuODU3MUMxIDEzLjQ1MTEgMSAxMi45MjY0IDEgMTEuODc3Wk0yLjUgMTEuMDUyQzIuNSAxMC43NzE5IDIuNSAxMC42MzE5IDIuNTU0NSAxMC41MjVDMi42MDI0MyAxMC40MzA5IDIuNjc4OTIgMTAuMzU0NCAyLjc3MyAxMC4zMDY0QzIuODc5OTYgMTAuMjUyIDMuMDE5OTcgMTAuMjUyIDMuMyAxMC4yNTJINC45NUM1LjIzMDAzIDEwLjI1MiA1LjM3MDA0IDEwLjI1MiA1LjQ3NyAxMC4zMDY0QzUuNTcxMDggMTAuMzU0NCA1LjY0NzU3IDEwLjQzMDkgNS42OTU1IDEwLjUyNUM1Ljc1IDEwLjYzMTkgNS43NSAxMC43NzE5IDUuNzUgMTEuMDUyVjEyLjcwMkM1Ljc1IDEyLjk4MiA1Ljc1IDEzLjEyMiA1LjY5NTUgMTMuMjI4OUM1LjY0NzU3IDEzLjMyMyA1LjU3MTA4IDEzLjM5OTUgNS40NzcgMTMuNDQ3NUM1LjM3MDA0IDEzLjUwMiA1LjIzMDAzIDEzLjUwMiA0Ljk1IDEzLjUwMkgzLjNDMy4wMTk5NyAxMy41MDIgMi44Nzk5NiAxMy41MDIgMi43NzMgMTMuNDQ3NUMyLjY3ODkyIDEzLjM5OTUgMi42MDI0MyAxMy4zMjMgMi41NTQ1IDEzLjIyODlDMi41IDEzLjEyMiAyLjUgMTIuOTgyIDIuNSAxMi43MDJWMTEuMDUyWk04Ljk0MjAyIDIuMTQ2ODRDOC43NSAyLjU1Mjg0IDguNzUgMy4wNzc1NCA4Ljc1IDQuMTI2OTVDOC43NSA1LjE3NjM2IDguNzUgNS43MDEwNyA4Ljk0MjAyIDYuMTA3MDZDOS4xMzk4NiA2LjUyNTM1IDkuNDc2NiA2Ljg2MjEgOS44OTQ4OSA3LjA1OTkzQzEwLjMwMDkgNy4yNTE5NSAxMC44MjU2IDcuMjUxOTUgMTEuODc1IDcuMjUxOTVDMTIuOTI0NCA3LjI1MTk1IDEzLjQ0OTEgNy4yNTE5NSAxMy44NTUxIDcuMDU5OTNDMTQuMjczNCA2Ljg2MjEgMTQuNjEwMSA2LjUyNTM1IDE0LjgwOCA2LjEwNzA2QzE1IDUuNzAxMDcgMTUgNS4xNzYzNiAxNSA0LjEyNjk1QzE1IDMuMDc3NTQgMTUgMi41NTI4NCAxNC44MDggMi4xNDY4NEMxNC42MTAxIDEuNzI4NTYgMTQuMjczNCAxLjM5MTgxIDEzLjg1NTEgMS4xOTM5N0MxMy40NDkxIDEuMDAxOTUgMTIuOTI0NCAxLjAwMTk1IDExLjg3NSAxLjAwMTk1QzEwLjgyNTYgMS4wMDE5NSAxMC4zMDA5IDEuMDAxOTUgOS44OTQ4OSAxLjE5Mzk3QzkuNDc2NiAxLjM5MTgxIDkuMTM5ODYgMS43Mjg1NiA4Ljk0MjAyIDIuMTQ2ODRaTTEwLjMwNDUgMi43NzQ5NkMxMC4yNSAyLjg4MTkxIDEwLjI1IDMuMDIxOTMgMTAuMjUgMy4zMDE5NVY0Ljk1MTk1QzEwLjI1IDUuMjMxOTggMTAuMjUgNS4zNzE5OSAxMC4zMDQ1IDUuNDc4OTVDMTAuMzUyNCA1LjU3MzAzIDEwLjQyODkgNS42NDk1MiAxMC41MjMgNS42OTc0NkMxMC42MyA1Ljc1MTk1IDEwLjc3IDUuNzUxOTUgMTEuMDUgNS43NTE5NUgxMi43QzEyLjk4IDUuNzUxOTUgMTMuMTIgNS43NTE5NSAxMy4yMjcgNS42OTc0NkMxMy4zMjExIDUuNjQ5NTIgMTMuMzk3NiA1LjU3MzAzIDEzLjQ0NTUgNS40Nzg5NUMxMy41IDUuMzcxOTkgMTMuNSA1LjIzMTk4IDEzLjUgNC45NTE5NVYzLjMwMTk1QzEzLjUgMy4wMjE5MyAxMy41IDIuODgxOTEgMTMuNDQ1NSAyLjc3NDk2QzEzLjM5NzYgMi42ODA4OCAxMy4zMjExIDIuNjA0MzkgMTMuMjI3IDIuNTU2NDVDMTMuMTIgMi41MDE5NSAxMi45OCAyLjUwMTk1IDEyLjcgMi41MDE5NUgxMS4wNUMxMC43NyAyLjUwMTk1IDEwLjYzIDIuNTAxOTUgMTAuNTIzIDIuNTU2NDVDMTAuNDI4OSAyLjYwNDM5IDEwLjM1MjQgMi42ODA4OCAxMC4zMDQ1IDIuNzc0OTZaTTguODA3MjcgOS4xMzUxOEM4Ljc1IDkuMjYyNDIgOC43NSA5LjQyNTYgOC43NSA5Ljc1MTk1QzguNzUgMTAuMDc4MyA4Ljc1IDEwLjI0MTUgOC44MDcyNyAxMC4zNjg3QzguODcyNDUgMTAuNTEzNiA4Ljk4ODQgMTAuNjI5NSA5LjEzMzIzIDEwLjY5NDdDOS4yNjA0NyAxMC43NTIgOS40MjM2NSAxMC43NTIgOS43NSAxMC43NTJDMTAuMDc2NCAxMC43NTIgMTAuMjM5NSAxMC43NTIgMTAuMzY2OCAxMC42OTQ3QzEwLjUxMTYgMTAuNjI5NSAxMC42Mjc2IDEwLjUxMzYgMTAuNjkyNyAxMC4zNjg3QzEwLjc1IDEwLjI0MTUgMTAuNzUgMTAuMDc4MyAxMC43NSA5Ljc1MTk1QzEwLjc1IDkuNDI1NiAxMC43NSA5LjI2MjQyIDEwLjY5MjcgOS4xMzUxOEMxMC42Mjc2IDguOTkwMzUgMTAuNTExNiA4Ljg3NDQgMTAuMzY2OCA4LjgwOTIyQzEwLjIzOTUgOC43NTE5NSAxMC4wNzY0IDguNzUxOTUgOS43NSA4Ljc1MTk1QzkuNDIzNjUgOC43NTE5NSA5LjI2MDQ3IDguNzUxOTUgOS4xMzMyMyA4LjgwOTIyQzguOTg4NCA4Ljg3NDQgOC44NzI0NSA4Ljk5MDM1IDguODA3MjcgOS4xMzUxOFpNMTAuODcgMTEuODc3MUMxMC44NyAxMS41NDYgMTAuODcgMTEuMzgwNSAxMC45Mjg5IDExLjI1MTdDMTAuOTkzOCAxMS4xMDk4IDExLjEwNzcgMTAuOTk1OSAxMS4yNDk3IDEwLjkzMUMxMS4zNzg0IDEwLjg3MjEgMTEuNTQzOSAxMC44NzIxIDExLjg3NSAxMC44NzIxQzEyLjIwNjEgMTAuODcyMSAxMi4zNzE2IDEwLjg3MjEgMTIuNTAwMyAxMC45MzFDMTIuNjQyMyAxMC45OTU5IDEyLjc1NjIgMTEuMTA5OCAxMi44MjExIDExLjI1MTdDMTIuODggMTEuMzgwNSAxMi44OCAxMS41NDYgMTIuODggMTEuODc3MUMxMi44OCAxMi4yMDgxIDEyLjg4IDEyLjM3MzcgMTIuODIxMSAxMi41MDI0QzEyLjc1NjIgMTIuNjQ0NCAxMi42NDIzIDEyLjc1ODMgMTIuNTAwMyAxMi44MjMyQzEyLjM3MTYgMTIuODgyMSAxMi4yMDYxIDEyLjg4MjEgMTEuODc1IDEyLjg4MjFDMTEuNTQzOSAxMi44ODIxIDExLjM3ODQgMTIuODgyMSAxMS4yNDk3IDEyLjgyMzJDMTEuMTA3NyAxMi43NTgzIDEwLjk5MzggMTIuNjQ0NCAxMC45Mjg5IDEyLjUwMjRDMTAuODcgMTIuMzczNyAxMC44NyAxMi4yMDgxIDEwLjg3IDExLjg3NzFaTTguODA3MjcgMTMuMzg1MkM4Ljc1IDEzLjUxMjQgOC43NSAxMy42NzU2IDguNzUgMTQuMDAyQzguNzUgMTQuMzI4MyA4Ljc1IDE0LjQ5MTUgOC44MDcyNyAxNC42MTg3QzguODcyNDUgMTQuNzYzNiA4Ljk4ODQgMTQuODc5NSA5LjEzMzIzIDE0Ljk0NDdDOS4yNjA0NyAxNS4wMDIgOS40MjM2NSAxNS4wMDIgOS43NSAxNS4wMDJDMTAuMDc2NCAxNS4wMDIgMTAuMjM5NSAxNS4wMDIgMTAuMzY2OCAxNC45NDQ3QzEwLjUxMTYgMTQuODc5NSAxMC42Mjc2IDE0Ljc2MzYgMTAuNjkyNyAxNC42MTg3QzEwLjc1IDE0LjQ5MTUgMTAuNzUgMTQuMzI4MyAxMC43NSAxNC4wMDJDMTAuNzUgMTMuNjc1NiAxMC43NSAxMy41MTI0IDEwLjY5MjcgMTMuMzg1MkMxMC42Mjc2IDEzLjI0MDQgMTAuNTExNiAxMy4xMjQ0IDEwLjM2NjggMTMuMDU5MkMxMC4yMzk1IDEzLjAwMiAxMC4wNzY0IDEzLjAwMiA5Ljc1IDEzLjAwMkM5LjQyMzY1IDEzLjAwMiA5LjI2MDQ3IDEzLjAwMiA5LjEzMzIzIDEzLjA1OTJDOC45ODg0IDEzLjEyNDQgOC44NzI0NSAxMy4yNDA0IDguODA3MjcgMTMuMzg1MlpNMTMgOS43NTE5NUMxMyA5LjQyNTYgMTMgOS4yNjI0MiAxMy4wNTczIDkuMTM1MThDMTMuMTIyNCA4Ljk5MDM1IDEzLjIzODQgOC44NzQ0IDEzLjM4MzIgOC44MDkyMkMxMy41MTA1IDguNzUxOTUgMTMuNjczNiA4Ljc1MTk1IDE0IDguNzUxOTVDMTQuMzI2NCA4Ljc1MTk1IDE0LjQ4OTUgOC43NTE5NSAxNC42MTY4IDguODA5MjJDMTQuNzYxNiA4Ljg3NDQgMTQuODc3NiA4Ljk5MDM1IDE0Ljk0MjcgOS4xMzUxOEMxNSA5LjI2MjQyIDE1IDkuNDI1NiAxNSA5Ljc1MTk1QzE1IDEwLjA3ODMgMTUgMTAuMjQxNSAxNC45NDI3IDEwLjM2ODdDMTQuODc3NiAxMC41MTM2IDE0Ljc2MTYgMTAuNjI5NSAxNC42MTY4IDEwLjY5NDdDMTQuNDg5NSAxMC43NTIgMTQuMzI2NCAxMC43NTIgMTQgMTAuNzUyQzEzLjY3MzYgMTAuNzUyIDEzLjUxMDUgMTAuNzUyIDEzLjM4MzIgMTAuNjk0N0MxMy4yMzg0IDEwLjYyOTUgMTMuMTIyNCAxMC41MTM2IDEzLjA1NzMgMTAuMzY4N0MxMyAxMC4yNDE1IDEzIDEwLjA3ODMgMTMgOS43NTE5NVpNMTMuMDU3MyAxMy4zODUyQzEzIDEzLjUxMjQgMTMgMTMuNjc1NiAxMyAxNC4wMDJDMTMgMTQuMzI4MyAxMyAxNC40OTE1IDEzLjA1NzMgMTQuNjE4N0MxMy4xMjI0IDE0Ljc2MzYgMTMuMjM4NCAxNC44Nzk1IDEzLjM4MzIgMTQuOTQ0N0MxMy41MTA1IDE1LjAwMiAxMy42NzM2IDE1LjAwMiAxNCAxNS4wMDJDMTQuMzI2NCAxNS4wMDIgMTQuNDg5NSAxNS4wMDIgMTQuNjE2OCAxNC45NDQ3QzE0Ljc2MTYgMTQuODc5NSAxNC44Nzc2IDE0Ljc2MzYgMTQuOTQyNyAxNC42MTg3QzE1IDE0LjQ5MTUgMTUgMTQuMzI4MyAxNSAxNC4wMDJDMTUgMTMuNjc1NiAxNSAxMy41MTI0IDE0Ljk0MjcgMTMuMzg1MkMxNC44Nzc2IDEzLjI0MDQgMTQuNzYxNiAxMy4xMjQ0IDE0LjYxNjggMTMuMDU5MkMxNC40ODk1IDEzLjAwMiAxNC4zMjY0IDEzLjAwMiAxNCAxMy4wMDJDMTMuNjczNiAxMy4wMDIgMTMuNTEwNSAxMy4wMDIgMTMuMzgzMiAxMy4wNTkyQzEzLjIzODQgMTMuMTI0NCAxMy4xMjI0IDEzLjI0MDQgMTMuMDU3MyAxMy4zODUyWlwiPmApO1xuY29uc3QgUVJJY29uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3QgZmlsbCA9ICgpID0+IHByb3BzLmZpbGwgfHwgdGhlbWUuY29sb3JzLmljb24uc2Vjb25kYXJ5O1xuICByZXR1cm4gKCgpID0+IHtcbiAgICB2YXIgX2VsJCA9IF90bXBsJCQ5KCksIF9lbCQyID0gX2VsJC5maXJzdENoaWxkO1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoKSA9PiBzZXRBdHRyaWJ1dGUoX2VsJDIsIFwiZmlsbFwiLCBmaWxsKCkpKTtcbiAgICByZXR1cm4gX2VsJDtcbiAgfSkoKTtcbn07XG5jb25zdCBjb250YWluZXJCb3JkZXJzID0ge1xuICBtOiBcIjE2cHhcIixcbiAgczogXCIxMnB4XCIsXG4gIG5vbmU6IFwiMFwiXG59O1xuY29uc3Qgd2FsbGV0Qm9yZGVycyA9IHtcbiAgbTogXCI2cHhcIixcbiAgczogXCI2cHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCBGb3VyV2FsbGV0c0NhcmQgPSBzdHlsZWQuZGl2YFxuICAgIHdpZHRoOiA2MHB4O1xuICAgIGhlaWdodDogNjBweDtcbiAgICBwYWRkaW5nOiA4cHg7XG4gICAgbWFyZ2luLWJvdHRvbTogOHB4O1xuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiBjb250YWluZXJCb3JkZXJzW3Byb3BzLnRoZW1lLmJvcmRlclJhZGl1c119O1xuICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuYmFja2dyb3VuZC50aW50fTtcbiAgICBkaXNwbGF5OiBncmlkO1xuICAgIGdyaWQtdGVtcGxhdGU6IDFmciAxZnIgLyAxZnIgMWZyO1xuICAgIGdhcDogNHB4O1xuYDtcbmNvbnN0IEZvdXJXYWxsZXRzSW1hZ2UgPSBzdHlsZWQoV2FsbGV0SW1hZ2UpYFxuICAgIHdpZHRoOiAyMHB4O1xuICAgIGhlaWdodDogMjBweDtcbiAgICBib3JkZXItcmFkaXVzOiAkeyhwcm9wcykgPT4gd2FsbGV0Qm9yZGVyc1twcm9wcy50aGVtZS5ib3JkZXJSYWRpdXNdfTtcbmA7XG5jb25zdCBGb3VyV2FsbGV0c0l0ZW0gPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChXYWxsZXRJdGVtLCB7XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICByZXR1cm4gcHJvcHMubGFiZWxMaW5lMTtcbiAgICB9LFxuICAgIGdldCBzZWNvbmRMaW5lKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmxhYmVsTGluZTI7XG4gICAgfSxcbiAgICBnZXQgaWNvbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoRm91cldhbGxldHNDYXJkLCB7XG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEZvciwge1xuICAgICAgICAgICAgZWFjaDogWzAsIDEsIDIsIDNdLFxuICAgICAgICAgICAgY2hpbGRyZW46IChpbmRleCkgPT4gY3JlYXRlQ29tcG9uZW50KEZvdXJXYWxsZXRzSW1hZ2UsIHtcbiAgICAgICAgICAgICAgZ2V0IHNyYygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuaW1hZ2VzW2luZGV4XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBvbkNsaWNrOiAoKSA9PiBwcm9wcy5vbkNsaWNrKClcbiAgfSk7XG59O1xuY29uc3QgQVRfV0FMTEVUX0FQUF9OQU1FID0gXCJ0ZWxlZ3JhbS13YWxsZXRcIjtcbmNvbnN0IElNRyA9IHtcbiAgVE9OOiBcImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS90b24tY29ubmVjdC9zZGsvbWFpbi9hc3NldHMvdG9uLWljb24tNDgucG5nXCIsXG4gIFRHOiBcImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS90b24tY29ubmVjdC9zZGsvbWFpbi9hc3NldHMvdGcucG5nXCIsXG4gIFdBTExFVF9DT05ORUNUOiBcImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS90b24tY29ubmVjdC9zZGsvbWFpbi9hc3NldHMvd2FsbGV0Y29ubmVjdC1pY29uLTI4OC5wbmdcIlxufTtcbmZ1bmN0aW9uIGlzV2FsbGV0VWkod2FsbGV0KSB7XG4gIHJldHVybiAhKFwidHlwZVwiIGluIHdhbGxldCkgfHwgd2FsbGV0LnR5cGUgIT09IFwid2FsbGV0LWNvbm5lY3RcIjtcbn1cbmNvbnN0IFdhbGxldExhYmVsZWRJdGVtID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IFt0Ml0gPSB1c2VJMThuKCk7XG4gIGNvbnN0IHdhbGxldHNTZWNvbmRMaW5lID0gKCkgPT4ge1xuICAgIGlmIChwcm9wcy53YWxsZXQuYXBwTmFtZSA9PT0gQVRfV0FMTEVUX0FQUF9OQU1FKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoXCJpc1ByZWZlcnJlZFwiIGluIHByb3BzLndhbGxldCAmJiBwcm9wcy53YWxsZXQuaXNQcmVmZXJyZWQpIHtcbiAgICAgIHJldHVybiB0MihcIndhbGxldEl0ZW0ucmVjZW50XCIsIHt9LCBcIlJlY2VudFwiKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLndhbGxldC5uYW1lID09PSBcIlRvbmtlZXBlclwiKSB7XG4gICAgICByZXR1cm4gdDIoXCJ3YWxsZXRJdGVtLnBvcHVsYXJcIiwge30sIFwiUG9wdWxhclwiKTtcbiAgICB9XG4gICAgaWYgKGlzV2FsbGV0VWkocHJvcHMud2FsbGV0KSAmJiBpc1dhbGxldEluZm9DdXJyZW50bHlJbmplY3RlZChwcm9wcy53YWxsZXQpKSB7XG4gICAgICByZXR1cm4gdDIoXCJ3YWxsZXRJdGVtLmluc3RhbGxlZFwiLCB7fSwgXCJJbnN0YWxsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH07XG4gIHJldHVybiBtZW1vKCgpID0+IG1lbW8oKCkgPT4gcHJvcHMud2FsbGV0LmFwcE5hbWUgPT09IEFUX1dBTExFVF9BUFBfTkFNRSkoKSA/IGNyZWF0ZUNvbXBvbmVudChXYWxsZXRJdGVtLCB7XG4gICAgZ2V0IGljb24oKSB7XG4gICAgICByZXR1cm4gcHJvcHMud2FsbGV0LmltYWdlVXJsO1xuICAgIH0sXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICByZXR1cm4gdDIoXCJ3YWxsZXRJdGVtLndhbGxldE9uXCIsIHt9LCBcIldhbGxldCBpblwiKTtcbiAgICB9LFxuICAgIHNlY29uZExpbmU6IFwiVGVsZWdyYW1cIixcbiAgICBnZXQgYmFkZ2VVcmwoKSB7XG4gICAgICByZXR1cm4gSU1HLlRHO1xuICAgIH0sXG4gICAgb25DbGljazogKCkgPT4gcHJvcHMub25DbGljaygpLFxuICAgIGdldCBbXCJjbGFzc1wiXSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5jbGFzcztcbiAgICB9XG4gIH0pIDogY3JlYXRlQ29tcG9uZW50KFdhbGxldEl0ZW0sIHtcbiAgICBnZXQgaWNvbigpIHtcbiAgICAgIHJldHVybiBwcm9wcy53YWxsZXQuaW1hZ2VVcmw7XG4gICAgfSxcbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy53YWxsZXQubmFtZTtcbiAgICB9LFxuICAgIGdldCBzZWNvbmRMaW5lKCkge1xuICAgICAgcmV0dXJuIHdhbGxldHNTZWNvbmRMaW5lKCk7XG4gICAgfSxcbiAgICBzZWNvbmRMaW5lQ29sb3JQcmltYXJ5OiBmYWxzZSxcbiAgICBvbkNsaWNrOiAoKSA9PiBwcm9wcy5vbkNsaWNrKCksXG4gICAgZ2V0IFtcImNsYXNzXCJdKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgIH1cbiAgfSkpO1xufTtcbmNvbnN0IFNjcm9sbENvbnRhaW5lclN0eWxlZCA9IHN0eWxlZC5kaXZgXG4gICAgd2lkdGg6IDEwMCU7XG4gICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICBtYXgtaGVpZ2h0OiAkeyhwcm9wcykgPT4gcHJvcHMubWF4SGVpZ2h0fTtcblxuICAgIHNjcm9sbGJhci13aWR0aDogbm9uZTtcbiAgICAmJjo6LXdlYmtpdC1zY3JvbGxiYXIge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cblxuICAgICYmOjotd2Via2l0LXNjcm9sbGJhci10cmFjayB7XG4gICAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICAgIH1cblxuICAgICYmOjotd2Via2l0LXNjcm9sbGJhci10aHVtYiB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuYDtcbmNvbnN0IFNjcm9sbERpdmlkZXIgPSBzdHlsZWQuZGl2YFxuICAgIGhlaWdodDogMXB4O1xuICAgIG1hcmdpbjogMCAtMjRweDtcbiAgICB3aWR0aDogY2FsYygxMDAlICsgNDhweCk7XG4gICAgb3BhY2l0eTogMC4wODtcbiAgICBiYWNrZ3JvdW5kOiAkeyhwcm9wcykgPT4gcHJvcHMuaXNTaG93biA/IHByb3BzLnRoZW1lLmNvbG9ycy5pY29uLnNlY29uZGFyeSA6IFwidHJhbnNwYXJlbnRcIn07XG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZCAwLjE1cyBlYXNlLWluLW91dDtcblxuICAgICR7bWVkaWEoXCJtb2JpbGVcIil9IHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICB9XG5gO1xuY29uc3QgW3dpbmRvd0hlaWdodCwgc2V0V2luZG93SGVpZ2h0XSA9IGNyZWF0ZVNpZ25hbCgoKF9oID0gZ2V0V2luZG93JDEoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9oLmlubmVySGVpZ2h0KSB8fCAwKTtcbmlmIChnZXRXaW5kb3ckMSgpKSB7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsICgpID0+IHNldFdpbmRvd0hlaWdodCh3aW5kb3cuaW5uZXJIZWlnaHQpKTtcbn1cbmNvbnN0IFtpc01vYmlsZSwgc2V0SXNNb2JpbGVdID0gY3JlYXRlU2lnbmFsKGlzRGV2aWNlKFwibW9iaWxlXCIpKTtcbmNvbnN0IHVwZGF0ZUlzTW9iaWxlID0gKCkgPT4gc2V0SXNNb2JpbGUoaXNEZXZpY2UoXCJtb2JpbGVcIikpO1xuaWYgKGdldFdpbmRvdyQxKCkpIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgKCkgPT4gdXBkYXRlSXNNb2JpbGUoKSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB1cGRhdGVJc01vYmlsZSgpLCB7IG9uY2U6IHRydWUgfSk7XG59XG5jb25zdCBTY3JvbGxDb250YWluZXIgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgW3Njcm9sbGVkLCBzZXRTY3JvbGxlZF0gPSBjcmVhdGVTaWduYWwoZmFsc2UpO1xuICBjb25zdCBvblNjcm9sbCA9IChlMikgPT4ge1xuICAgIHNldFNjcm9sbGVkKGUyLnRhcmdldC5zY3JvbGxUb3AgPiAwKTtcbiAgfTtcbiAgY29uc3Qgb2Zmc2V0ID0gKCkgPT4gaXNNb2JpbGUoKSA/IDE1MCA6IDIwMDtcbiAgY29uc3QgbWF4SGVpZ2h0ID0gKCkgPT4gcHJvcHMubWF4SGVpZ2h0ICE9PSB2b2lkIDAgPyBgJHtwcm9wcy5tYXhIZWlnaHR9cHhgIDogYCR7d2luZG93SGVpZ2h0KCkgLSBvZmZzZXQoKX1weGA7XG4gIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFNjcm9sbERpdmlkZXIsIHtcbiAgICBnZXQgaXNTaG93bigpIHtcbiAgICAgIHJldHVybiBzY3JvbGxlZCgpO1xuICAgIH1cbiAgfSksIGNyZWF0ZUNvbXBvbmVudChTY3JvbGxDb250YWluZXJTdHlsZWQsIHtcbiAgICBnZXQgbWF4SGVpZ2h0KCkge1xuICAgICAgcmV0dXJuIG1heEhlaWdodCgpO1xuICAgIH0sXG4gICAgb25TY3JvbGwsXG4gICAgZ2V0IFtcImNsYXNzXCJdKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgIH0sXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuO1xuICAgIH1cbiAgfSldO1xufTtcbmNvbnN0IEFTdHlsZWQgPSBzdHlsZWQuYWBcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuc2V0O1xuYDtcbmNvbnN0IExpbmsgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgYXR0cmlidXRlcyA9ICgpID0+IHByb3BzLmJsYW5rID8ge1xuICAgIHJlbDogXCJub3JlZmVycmVyIG5vb3BlbmVyXCJcbiAgfSA6IHt9O1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEFTdHlsZWQsIG1lcmdlUHJvcHMoe1xuICAgIGdldCBocmVmKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmhyZWY7XG4gICAgfSxcbiAgICBnZXQgdGFyZ2V0KCkge1xuICAgICAgcmV0dXJuIHByb3BzLmJsYW5rID8gXCJfYmxhbmtcIiA6IFwiX3NlbGZcIjtcbiAgICB9LFxuICAgIGdldCBbXCJjbGFzc1wiXSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5jbGFzcztcbiAgICB9XG4gIH0sIGF0dHJpYnV0ZXMsIHtcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICB9KSk7XG59O1xuY29uc3QgVG9uQ29ubmVjdFVpQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoKTtcbnZhciBfdG1wbCQkOCA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8c3ZnIHdpZHRoPTI0IGhlaWdodD0yNCB2aWV3Qm94PVwiMCAwIDI0IDI0XCJmaWxsPW5vbmUgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmc+PHBhdGggZmlsbC1ydWxlPWV2ZW5vZGQgY2xpcC1ydWxlPWV2ZW5vZGQgZD1cIk03Ljc2MjI4IDIuMDk5OThIMTAuMjM3OEMxMS4wNDU4IDIuMDk5OTcgMTEuNzA2NyAyLjA5OTk2IDEyLjI0MzggMi4xNDM4NEMxMi43OTk3IDIuMTg5MjYgMTMuMzAxNyAyLjI4NjE0IDEzLjc3MDYgMi41MjUwNUMxNC41MDQ1IDIuODk4OTYgMTUuMTAxMSAzLjQ5NTU4IDE1LjQ3NSA0LjIyOTQxQzE1LjcxMzkgNC42OTgzIDE1LjgxMDggNS4yMDAzOCAxNS44NTYyIDUuNzU2MjlDMTUuOTAwMSA2LjI5MzM3IDE1LjkwMDEgNi45NTQyMiAxNS45MDAxIDcuNzYyMjdWOC4xSDE2LjIzNzdDMTcuMDQ1NyA4LjA5OTk5IDE3LjcwNjYgOC4wOTk5OCAxOC4yNDM3IDguMTQzODZDMTguNzk5NiA4LjE4OTI4IDE5LjMwMTcgOC4yODYxNiAxOS43NzA1IDguNTI1MDdDMjAuNTA0NCA4Ljg5ODk4IDIxLjEwMSA5LjQ5NTYgMjEuNDc0OSAxMC4yMjk0QzIxLjcxMzggMTAuNjk4MyAyMS44MTA3IDExLjIwMDQgMjEuODU2MSAxMS43NTYzQzIxLjkgMTIuMjkzNCAyMS45IDEyLjk1NDIgMjEuOSAxMy43NjIzVjE2LjIzNzdDMjEuOSAxNy4wNDU4IDIxLjkgMTcuNzA2NiAyMS44NTYxIDE4LjI0MzdDMjEuODEwNyAxOC43OTk2IDIxLjcxMzggMTkuMzAxNyAyMS40NzQ5IDE5Ljc3MDZDMjEuMTAxIDIwLjUwNDQgMjAuNTA0NCAyMS4xMDEgMTkuNzcwNSAyMS40NzQ5QzE5LjMwMTcgMjEuNzEzOCAxOC43OTk2IDIxLjgxMDcgMTguMjQzNyAyMS44NTYxQzE3LjcwNjYgMjEuOSAxNy4wNDU4IDIxLjkgMTYuMjM3OCAyMS45SDEzLjc2MjNDMTIuOTU0MyAyMS45IDEyLjI5MzQgMjEuOSAxMS43NTYzIDIxLjg1NjFDMTEuMjAwNCAyMS44MTA3IDEwLjY5ODMgMjEuNzEzOCAxMC4yMjk0IDIxLjQ3NDlDOS40OTU2MSAyMS4xMDEgOC44OTg5OCAyMC41MDQ0IDguNTI1MDggMTkuNzcwNkM4LjI4NjE2IDE5LjMwMTcgOC4xODkyOCAxOC43OTk2IDguMTQzODYgMTguMjQzN0M4LjA5OTk4IDE3LjcwNjYgOC4wOTk5OSAxNy4wNDU4IDguMSAxNi4yMzc3VjE1LjlINy43NjIyN0M2Ljk1NDI2IDE1LjkgNi4yOTMzNSAxNS45IDUuNzU2MjkgMTUuODU2MUM1LjIwMDM4IDE1LjgxMDcgNC42OTgzIDE1LjcxMzggNC4yMjk0MSAxNS40NzQ5QzMuNDk1NTggMTUuMTAxIDIuODk4OTYgMTQuNTA0NCAyLjUyNTA1IDEzLjc3MDVDMi4yODYxNCAxMy4zMDE3IDIuMTg5MjYgMTIuNzk5NiAyLjE0Mzg0IDEyLjI0MzdDMi4wOTk5NiAxMS43MDY2IDIuMDk5OTcgMTEuMDQ1OCAyLjA5OTk4IDEwLjIzNzdWNy43NjIyOEMyLjA5OTk3IDYuOTU0MjQgMi4wOTk5NiA2LjI5MzM2IDIuMTQzODQgNS43NTYyOUMyLjE4OTI2IDUuMjAwMzggMi4yODYxNCA0LjY5ODMgMi41MjUwNSA0LjIyOTQxQzIuODk4OTYgMy40OTU1OCAzLjQ5NTU4IDIuODk4OTYgNC4yMjk0MSAyLjUyNTA1QzQuNjk4MyAyLjI4NjE0IDUuMjAwMzggMi4xODkyNiA1Ljc1NjI5IDIuMTQzODRDNi4yOTMzNiAyLjA5OTk2IDYuOTU0MjUgMi4wOTk5NyA3Ljc2MjI4IDIuMDk5OThaTTguMSAxNC4xVjEzLjc2MjNDOC4wOTk5OSAxMi45NTQyIDguMDk5OTggMTIuMjkzNCA4LjE0Mzg2IDExLjc1NjNDOC4xODkyOCAxMS4yMDA0IDguMjg2MTYgMTAuNjk4MyA4LjUyNTA4IDEwLjIyOTRDOC44OTg5OCA5LjQ5NTYgOS40OTU2MSA4Ljg5ODk4IDEwLjIyOTQgOC41MjUwN0MxMC42OTgzIDguMjg2MTYgMTEuMjAwNCA4LjE4OTI4IDExLjc1NjMgOC4xNDM4NkMxMi4yOTM0IDguMDk5OTggMTIuOTU0MiA4LjA5OTk5IDEzLjc2MjMgOC4xSDE0LjEwMDFWNy43OTk5OEMxNC4xMDAxIDYuOTQ1MDUgMTQuMDk5NCA2LjM1Nzk4IDE0LjA2MjIgNS45MDI4N0MxNC4wMjU5IDUuNDU4MjcgMTMuOTU5MyA1LjIxOTQ0IDEzLjg3MTIgNS4wNDY2QzEzLjY2OTkgNC42NTE0NiAxMy4zNDg2IDQuMzMwMiAxMi45NTM1IDQuMTI4ODZDMTIuNzgwNiA0LjA0MDc5IDEyLjU0MTggMy45NzQxOSAxMi4wOTcyIDMuOTM3ODZDMTEuNjQyMSAzLjkwMDY4IDExLjA1NSAzLjg5OTk4IDEwLjIwMDEgMy44OTk5OEg3Ljc5OTk4QzYuOTQ1MDUgMy44OTk5OCA2LjM1Nzk4IDMuOTAwNjggNS45MDI4NyAzLjkzNzg2QzUuNDU4MjcgMy45NzQxOSA1LjIxOTQ0IDQuMDQwNzkgNS4wNDY2IDQuMTI4ODZDNC42NTE0NiA0LjMzMDIgNC4zMzAyIDQuNjUxNDYgNC4xMjg4NiA1LjA0NjZDNC4wNDA3OSA1LjIxOTQ0IDMuOTc0MTkgNS40NTgyNyAzLjkzNzg2IDUuOTAyODdDMy45MDA2OCA2LjM1Nzk4IDMuODk5OTggNi45NDUwNSAzLjg5OTk4IDcuNzk5OThWMTAuMkMzLjg5OTk4IDExLjA1NDkgMy45MDA2OCAxMS42NDIgMy45Mzc4NiAxMi4wOTcxQzMuOTc0MTkgMTIuNTQxNyA0LjA0MDc5IDEyLjc4MDUgNC4xMjg4NiAxMi45NTM0QzQuMzMwMiAxMy4zNDg1IDQuNjUxNDYgMTMuNjY5OCA1LjA0NjYgMTMuODcxMUM1LjIxOTQ0IDEzLjk1OTIgNS40NTgyNyAxNC4wMjU4IDUuOTAyODcgMTQuMDYyMUM2LjM1Nzk4IDE0LjA5OTMgNi45NDUwNSAxNC4xIDcuNzk5OTggMTQuMUg4LjFaTTExLjA0NjYgMTAuMTI4OUMxMS4yMTk1IDEwLjA0MDggMTEuNDU4MyA5Ljk3NDIxIDExLjkwMjkgOS45Mzc4OEMxMi4zNTggOS45MDA3IDEyLjk0NTEgOS45IDEzLjggOS45SDE2LjJDMTcuMDU0OSA5LjkgMTcuNjQyIDkuOTAwNyAxOC4wOTcxIDkuOTM3ODhDMTguNTQxNyA5Ljk3NDIxIDE4Ljc4MDUgMTAuMDQwOCAxOC45NTM0IDEwLjEyODlDMTkuMzQ4NSAxMC4zMzAyIDE5LjY2OTggMTAuNjUxNSAxOS44NzExIDExLjA0NjZDMTkuOTU5MiAxMS4yMTk1IDIwLjAyNTggMTEuNDU4MyAyMC4wNjIxIDExLjkwMjlDMjAuMDk5MyAxMi4zNTggMjAuMSAxMi45NDUxIDIwLjEgMTMuOFYxNi4yQzIwLjEgMTcuMDU0OSAyMC4wOTkzIDE3LjY0MiAyMC4wNjIxIDE4LjA5NzFDMjAuMDI1OCAxOC41NDE3IDE5Ljk1OTIgMTguNzgwNSAxOS44NzExIDE4Ljk1MzRDMTkuNjY5OCAxOS4zNDg1IDE5LjM0ODUgMTkuNjY5OCAxOC45NTM0IDE5Ljg3MTFDMTguNzgwNSAxOS45NTkyIDE4LjU0MTcgMjAuMDI1OCAxOC4wOTcxIDIwLjA2MjFDMTcuNjQyIDIwLjA5OTMgMTcuMDU0OSAyMC4xIDE2LjIgMjAuMUgxMy44QzEyLjk0NTEgMjAuMSAxMi4zNTggMjAuMDk5MyAxMS45MDI5IDIwLjA2MjFDMTEuNDU4MyAyMC4wMjU4IDExLjIxOTUgMTkuOTU5MiAxMS4wNDY2IDE5Ljg3MTFDMTAuNjUxNSAxOS42Njk4IDEwLjMzMDIgMTkuMzQ4NSAxMC4xMjg5IDE4Ljk1MzRDMTAuMDQwOCAxOC43ODA1IDkuOTc0MjEgMTguNTQxNyA5LjkzNzg4IDE4LjA5NzFDOS45MDA3IDE3LjY0MiA5LjkgMTcuMDU0OSA5LjkgMTYuMlYxMy44QzkuOSAxMi45NDUxIDkuOTAwNyAxMi4zNTggOS45Mzc4OCAxMS45MDI5QzkuOTc0MjEgMTEuNDU4MyAxMC4wNDA4IDExLjIxOTUgMTAuMTI4OSAxMS4wNDY2QzEwLjMzMDIgMTAuNjUxNSAxMC42NTE1IDEwLjMzMDIgMTEuMDQ2NiAxMC4xMjg5WlwiPmApO1xuY29uc3QgQ29weUljb24gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCBmaWxsID0gKCkgPT4gcHJvcHMuZmlsbCB8fCB0aGVtZS5jb2xvcnMuaWNvbi5wcmltYXJ5O1xuICByZXR1cm4gKCgpID0+IHtcbiAgICB2YXIgX2VsJCA9IF90bXBsJCQ4KCksIF9lbCQyID0gX2VsJC5maXJzdENoaWxkO1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoX3AkKSA9PiB7XG4gICAgICB2YXIgX3YkID0gcHJvcHMuY2xhc3MsIF92JDIgPSBmaWxsKCk7XG4gICAgICBfdiQgIT09IF9wJC5lICYmIHNldEF0dHJpYnV0ZShfZWwkLCBcImNsYXNzXCIsIF9wJC5lID0gX3YkKTtcbiAgICAgIF92JDIgIT09IF9wJC50ICYmIHNldEF0dHJpYnV0ZShfZWwkMiwgXCJmaWxsXCIsIF9wJC50ID0gX3YkMik7XG4gICAgICByZXR1cm4gX3AkO1xuICAgIH0sIHtcbiAgICAgIGU6IHZvaWQgMCxcbiAgICAgIHQ6IHZvaWQgMFxuICAgIH0pO1xuICAgIHJldHVybiBfZWwkO1xuICB9KSgpO1xufTtcbnZhciBfdG1wbCQkNyA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8c3ZnIHdpZHRoPTI0IGhlaWdodD0yNCB2aWV3Qm94PVwiMCAwIDI0IDI0XCJmaWxsPW5vbmUgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmc+PHBhdGggZD1cIk04Ljc2MjQgMy4xMDAwMUM3Ljk1NDM1IDMuMSA3LjI5MzQ5IDMuMDk5OTkgNi43NTY0MiAzLjE0Mzg3QzYuMjAwNSAzLjE4OTI5IDUuNjk4NDIgMy4yODYxNyA1LjIyOTU0IDMuNTI1MDhDNC40OTU3IDMuODk4OTkgMy44OTkwOCA0LjQ5NTYxIDMuNTI1MTcgNS4yMjk0NEMzLjI4NjI2IDUuNjk4MzMgMy4xODkzOCA2LjIwMDQxIDMuMTQzOTYgNi43NTYzMkMzLjEwMDA4IDcuMjkzNCAzLjEwMDA5IDcuOTU0MjQgMy4xMDAxIDguNzYyMjlWMTUuMjM3N0MzLjEwMDA5IDE2LjA0NTggMy4xMDAwOCAxNi43MDY2IDMuMTQzOTYgMTcuMjQzN0MzLjE4OTM4IDE3Ljc5OTYgMy4yODYyNiAxOC4zMDE3IDMuNTI1MTcgMTguNzcwNkMzLjg5OTA4IDE5LjUwNDQgNC40OTU3IDIwLjEwMSA1LjIyOTU0IDIwLjQ3NDlDNS42OTg0MiAyMC43MTM4IDYuMjAwNSAyMC44MTA3IDYuNzU2NDIgMjAuODU2MUM3LjI5MzQ5IDIwLjkgNy45NTQzNCAyMC45IDguNzYyMzkgMjAuOUgxMi4wMDAxQzEyLjQ5NzIgMjAuOSAxMi45MDAxIDIwLjQ5NzEgMTIuOTAwMSAyMEMxMi45MDAxIDE5LjUwMyAxMi40OTcyIDE5LjEgMTIuMDAwMSAxOS4xSDguODAwMUM3Ljk0NTE3IDE5LjEgNy4zNTgxIDE5LjA5OTMgNi45MDI5OSAxOS4wNjIxQzYuNDU4MzkgMTkuMDI1OCA2LjIxOTU2IDE4Ljk1OTIgNi4wNDY3MiAxOC44NzExQzUuNjUxNTggMTguNjY5OCA1LjMzMDMyIDE4LjM0ODUgNS4xMjg5OCAxNy45NTM0QzUuMDQwOTIgMTcuNzgwNSA0Ljk3NDMxIDE3LjU0MTcgNC45Mzc5OCAxNy4wOTcxQzQuOTAwOCAxNi42NDIgNC45MDAxIDE2LjA1NDkgNC45MDAxIDE1LjJWOC44MDAwMUM0LjkwMDEgNy45NDUwOCA0LjkwMDggNy4zNTgwMSA0LjkzNzk4IDYuOTAyOUM0Ljk3NDMxIDYuNDU4MyA1LjA0MDkyIDYuMjE5NDcgNS4xMjg5OCA2LjA0NjYzQzUuMzMwMzIgNS42NTE0OSA1LjY1MTU4IDUuMzMwMjMgNi4wNDY3MiA1LjEyODg5QzYuMjE5NTYgNS4wNDA4MiA2LjQ1ODM5IDQuOTc0MjIgNi45MDI5OSA0LjkzNzg5QzcuMzU4MSA0LjkwMDcxIDcuOTQ1MTcgNC45MDAwMSA4LjgwMDEgNC45MDAwMUgxMi4wMDAxQzEyLjQ5NzIgNC45MDAwMSAxMi45MDAxIDQuNDk3MDYgMTIuOTAwMSA0LjAwMDAxQzEyLjkwMDEgMy41MDI5NSAxMi40OTcyIDMuMTAwMDEgMTIuMDAwMSAzLjEwMDAxSDguNzYyNFpcIj48L3BhdGg+PHBhdGggZD1cIk0xNy42MzY0IDcuMzYzNkMxNy4yODQ5IDcuMDEyMTIgMTYuNzE1MSA3LjAxMjEyIDE2LjM2MzYgNy4zNjM2QzE2LjAxMjEgNy43MTUwNyAxNi4wMTIxIDguMjg0OTIgMTYuMzYzNiA4LjYzNjM5TDE4LjgyNzIgMTEuMUg5LjAwMDAxQzguNTAyOTUgMTEuMSA4LjEwMDAxIDExLjUwMjkgOC4xMDAwMSAxMkM4LjEwMDAxIDEyLjQ5NyA4LjUwMjk1IDEyLjkgOS4wMDAwMSAxMi45SDE4LjgyNzJMMTYuMzYzNiAxNS4zNjM2QzE2LjAxMjEgMTUuNzE1MSAxNi4wMTIxIDE2LjI4NDkgMTYuMzYzNiAxNi42MzY0QzE2LjcxNTEgMTYuOTg3OSAxNy4yODQ5IDE2Ljk4NzkgMTcuNjM2NCAxNi42MzY0TDIxLjYzNjQgMTIuNjM2NEMyMS45ODc5IDEyLjI4NDkgMjEuOTg3OSAxMS43MTUxIDIxLjYzNjQgMTEuMzYzNkwxNy42MzY0IDcuMzYzNlpcIj5gKTtcbmNvbnN0IERpc2Nvbm5lY3RJY29uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3QgZmlsbCA9ICgpID0+IHByb3BzLmZpbGwgfHwgdGhlbWUuY29sb3JzLmljb24ucHJpbWFyeTtcbiAgcmV0dXJuICgoKSA9PiB7XG4gICAgdmFyIF9lbCQgPSBfdG1wbCQkNygpLCBfZWwkMiA9IF9lbCQuZmlyc3RDaGlsZCwgX2VsJDMgPSBfZWwkMi5uZXh0U2libGluZztcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKF9wJCkgPT4ge1xuICAgICAgdmFyIF92JCA9IGZpbGwoKSwgX3YkMiA9IGZpbGwoKTtcbiAgICAgIF92JCAhPT0gX3AkLmUgJiYgc2V0QXR0cmlidXRlKF9lbCQyLCBcImZpbGxcIiwgX3AkLmUgPSBfdiQpO1xuICAgICAgX3YkMiAhPT0gX3AkLnQgJiYgc2V0QXR0cmlidXRlKF9lbCQzLCBcImZpbGxcIiwgX3AkLnQgPSBfdiQyKTtcbiAgICAgIHJldHVybiBfcCQ7XG4gICAgfSwge1xuICAgICAgZTogdm9pZCAwLFxuICAgICAgdDogdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIF9lbCQ7XG4gIH0pKCk7XG59O1xuY29uc3QgaG92ZXJCb3JkZXJzJDEgPSB7XG4gIG06IFwiOHB4XCIsXG4gIHM6IFwiNHB4XCIsXG4gIG5vbmU6IFwiMFwiXG59O1xuY29uc3QgZHJvcGRvd25Cb3JkZXJzID0ge1xuICBtOiBcIjE2cHhcIixcbiAgczogXCI4cHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCBBY2NvdW50QnV0dG9uRHJvcGRvd25TdHlsZWQgPSBzdHlsZWQuZGl2YFxuICAgIHdpZHRoOiAyNTZweDtcbiAgICBib3gtc2hhZG93OiAwIDRweCAyNHB4IHJnYmEoMCwgMCwgMCwgMC4xNik7XG4gICAgYm9yZGVyLXJhZGl1czogJHsocHJvcHMpID0+IGRyb3Bkb3duQm9yZGVyc1twcm9wcy50aGVtZS5ib3JkZXJSYWRpdXNdfTtcblxuICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5wcmltYXJ5fVxuICAgICAgICAgICBcbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnByaW1hcnl9XG5gO1xuY29uc3QgVWxTdHlsZWQgPSBzdHlsZWQudWxgXG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnByaW1hcnl9O1xuICAgIHBhZGRpbmc6IDhweDtcbmA7XG5jb25zdCBNZW51QnV0dG9uU3R5bGVkID0gc3R5bGVkLmJ1dHRvbmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZ2FwOiA4cHg7XG4gICAgaGVpZ2h0OiA0MHB4O1xuICAgIHBhZGRpbmctbGVmdDogOHB4O1xuICAgIHdpZHRoOiAxMDAlO1xuXG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnByaW1hcnl9O1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBib3JkZXItcmFkaXVzOiAkeyhwcm9wcykgPT4gaG92ZXJCb3JkZXJzJDFbcHJvcHMudGhlbWUuYm9yZGVyUmFkaXVzXX07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgdHJhbnNpdGlvbjpcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcixcbiAgICAgICAgdHJhbnNmb3JtIDAuMXMgZWFzZS1pbi1vdXQ7XG5cbiAgICAmOmhvdmVyIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnNlY29uZGFyeX07XG4gICAgfVxuXG4gICAgJjphY3RpdmUge1xuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuOTYpO1xuICAgIH1cbmA7XG52YXIgX3RtcGwkJDYgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPGxpPmApO1xuY29uc3QgTWVudUl0ZW1UZXh0ID0gKHByb3BzKSA9PiBjcmVhdGVDb21wb25lbnQoVGV4dCwge1xuICBnZXQgdHJhbnNsYXRpb25LZXkoKSB7XG4gICAgcmV0dXJuIHByb3BzLnRyYW5zbGF0aW9uS2V5O1xuICB9LFxuICBmb250U2l6ZTogXCIxNXB4XCIsXG4gIGZvbnRXZWlnaHQ6IFwiNTkwXCIsXG4gIGdldCBjaGlsZHJlbigpIHtcbiAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW47XG4gIH1cbn0pO1xuY29uc3QgQWNjb3VudEJ1dHRvbkRyb3Bkb3duID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRvbkNvbm5lY3RVaSA9IHVzZUNvbnRleHQoVG9uQ29ubmVjdFVpQ29udGV4dCk7XG4gIGNvbnN0IFtpc0NvcGllZFNob3duLCBzZXRJc0NvcGllZFNob3duXSA9IGNyZWF0ZVNpZ25hbChmYWxzZSk7XG4gIGNvbnN0IG9uQ29weSA9ICgpID0+IF9fYXN5bmMobnVsbCwgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCB1c2VyRnJpZW5kbHlBZGRyZXNzID0gdG9Vc2VyRnJpZW5kbHlBZGRyZXNzKHRvbkNvbm5lY3RVaS5hY2NvdW50LmFkZHJlc3MsIHRvbkNvbm5lY3RVaS5hY2NvdW50LmNoYWluID09PSBDSEFJTi5URVNUTkVUKTtcbiAgICB5aWVsZCBjb3B5VG9DbGlwYm9hcmQodXNlckZyaWVuZGx5QWRkcmVzcyk7XG4gICAgc2V0SXNDb3BpZWRTaG93bih0cnVlKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHNldElzQ29waWVkU2hvd24oZmFsc2UpLCAxZTMpO1xuICB9KTtcbiAgY29uc3Qgb25EaXNjb25uZWN0ID0gKCkgPT4ge1xuICAgIHRvbkNvbm5lY3RVaS5kaXNjb25uZWN0KCk7XG4gICAgcHJvcHMub25DbG9zZSgpO1xuICB9O1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEFjY291bnRCdXR0b25Ecm9wZG93blN0eWxlZCwge1xuICAgIHJlZihyJCkge1xuICAgICAgdmFyIF9yZWYkID0gcHJvcHMucmVmO1xuICAgICAgdHlwZW9mIF9yZWYkID09PSBcImZ1bmN0aW9uXCIgPyBfcmVmJChyJCkgOiBwcm9wcy5yZWYgPSByJDtcbiAgICB9LFxuICAgIGdldCBbXCJjbGFzc1wiXSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5jbGFzcztcbiAgICB9LFxuICAgIFwiZGF0YS10Yy1kcm9wZG93blwiOiBcInRydWVcIixcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFVsU3R5bGVkLCB7XG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gWygoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2VsJCA9IF90bXBsJCQ2KCk7XG4gICAgICAgICAgICBpbnNlcnQoX2VsJCwgY3JlYXRlQ29tcG9uZW50KE1lbnVCdXR0b25TdHlsZWQsIHtcbiAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gb25Db3B5KCksXG4gICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChDb3B5SWNvbiwge30pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhaXNDb3BpZWRTaG93bigpO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChNZW51SXRlbVRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJidXR0b24uZHJvcGRvd24uY29weVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkNvcHkgYWRkcmVzc1wiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0NvcGllZFNob3duKCk7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KE1lbnVJdGVtVGV4dCwge1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcImJ1dHRvbi5kcm9wZG93bi5jb3BpZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJBZGRyZXNzIGNvcGllZCFcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBfZWwkO1xuICAgICAgICAgIH0pKCksICgoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2VsJDIgPSBfdG1wbCQkNigpO1xuICAgICAgICAgICAgaW5zZXJ0KF9lbCQyLCBjcmVhdGVDb21wb25lbnQoTWVudUJ1dHRvblN0eWxlZCwge1xuICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBvbkRpc2Nvbm5lY3QoKSxcbiAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KERpc2Nvbm5lY3RJY29uLCB7fSksIGNyZWF0ZUNvbXBvbmVudChNZW51SXRlbVRleHQsIHtcbiAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcImJ1dHRvbi5kcm9wZG93bi5kaXNjb25uZWN0XCIsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJEaXNjb25uZWN0XCJcbiAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBfZWwkMjtcbiAgICAgICAgICB9KSgpXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBib3JkZXJzJDMgPSB7XG4gIG06IFwiMTZweFwiLFxuICBzOiBcIjhweFwiLFxuICBub25lOiBcIjBcIlxufTtcbmNvbnN0IE5vdGlmaWNhdGlvblN0eWxlZCA9IHN0eWxlZC5kaXZgXG4gICAgd2lkdGg6IDI1NnB4O1xuICAgIHBhZGRpbmc6IDEycHggMTZweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGdhcDogOXB4O1xuXG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnByaW1hcnl9O1xuICAgIGJveC1zaGFkb3c6IDAgNHB4IDI0cHggcmdiYSgwLCAwLCAwLCAwLjE2KTtcbiAgICBib3JkZXItcmFkaXVzOiAkeyhwcm9wcykgPT4gYm9yZGVycyQzW3Byb3BzLnRoZW1lLmJvcmRlclJhZGl1c119O1xuYDtcbmNvbnN0IE5vdGlmaWNhdGlvbkNvbnRlbnRTdHlsZWQgPSBzdHlsZWQuZGl2YFxuICAgIHdpZHRoOiAxOTJweDtcblxuICAgID4gaDMge1xuICAgICAgICBmb250LXNpemU6IDE1cHg7XG4gICAgfVxuYDtcbmNvbnN0IFRleHRTdHlsZWQkMyA9IHN0eWxlZChUZXh0KWBcbiAgICBtYXJnaW4tdG9wOiA0cHg7XG4gICAgY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnl9O1xuYDtcbmNvbnN0IE5vdGlmaWNhdGlvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCBkYXRhQXR0cnMgPSB1c2VEYXRhQXR0cmlidXRlcyhwcm9wcyk7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoTm90aWZpY2F0aW9uU3R5bGVkLCBtZXJnZVByb3BzKHtcbiAgICBnZXQgW1wiY2xhc3NcIl0oKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2xhc3M7XG4gICAgfSxcbiAgICBcImRhdGEtdGMtbm90aWZpY2F0aW9uXCI6IFwidHJ1ZVwiXG4gIH0sIGRhdGFBdHRycywge1xuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KE5vdGlmaWNhdGlvbkNvbnRlbnRTdHlsZWQsIHtcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KEgzLCB7XG4gICAgICAgICAgICBnZXQgdHJhbnNsYXRpb25LZXkoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wcy5oZWFkZXIudHJhbnNsYXRpb25LZXk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuaGVhZGVyLnRyYW5zbGF0aW9uVmFsdWVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wcy50ZXh0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUZXh0U3R5bGVkJDMsIHtcbiAgICAgICAgICAgICAgICBnZXQgdHJhbnNsYXRpb25LZXkoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMudGV4dC50cmFuc2xhdGlvbktleTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy50ZXh0LnRyYW5zbGF0aW9uVmFsdWVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSldO1xuICAgICAgICB9XG4gICAgICB9KSwgbWVtbygoKSA9PiBwcm9wcy5pY29uKV07XG4gICAgfVxuICB9KSk7XG59O1xuY29uc3QgTG9hZGVySWNvblN0eWxlZCQyID0gc3R5bGVkKExvYWRlckljb24pYFxuICAgIGFsaWduLXNlbGY6IGNlbnRlcjtcbmA7XG5jb25zdCBDb25maXJtT3BlcmF0aW9uTm90aWZpY2F0aW9uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRvbkNvbm5lY3RVSSA9IHVzZUNvbnRleHQoVG9uQ29ubmVjdFVpQ29udGV4dCk7XG4gIGNvbnN0IFt0Ml0gPSB1c2VJMThuKCk7XG4gIGNvbnN0IG5hbWUgPSAoKSA9PiB0b25Db25uZWN0VUkud2FsbGV0ICYmIFwibmFtZVwiIGluIHRvbkNvbm5lY3RVSS53YWxsZXQgPyB0b25Db25uZWN0VUkud2FsbGV0Lm5hbWUgOiB0MihcImNvbW1vbi55b3VyV2FsbGV0XCIsIHt9LCBcIllvdXIgd2FsbGV0XCIpO1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KE5vdGlmaWNhdGlvbiwge1xuICAgIGdldCBoZWFkZXIoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFuc2xhdGlvbktleTogXCJub3RpZmljYXRpb25zLmNvbmZpcm0uaGVhZGVyXCIsXG4gICAgICAgIHRyYW5zbGF0aW9uVmFsdWVzOiB7XG4gICAgICAgICAgbmFtZTogbmFtZSgpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXQgW1wiY2xhc3NcIl0oKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2xhc3M7XG4gICAgfSxcbiAgICBnZXQgaWNvbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoTG9hZGVySWNvblN0eWxlZCQyLCB7fSk7XG4gICAgfSxcbiAgICBcImRhdGEtdGMtbm90aWZpY2F0aW9uLWNvbmZpcm1cIjogXCJ0cnVlXCIsXG4gICAgY2hpbGRyZW46IFwiQ29uZmlybSBvcGVyYXRpb24gaW4geW91ciB3YWxsZXRcIlxuICB9KTtcbn07XG5jb25zdCBFcnJvckljb25TdHlsZWQkNCA9IHN0eWxlZChFcnJvckljb24pYFxuICAgIG1hcmdpbi10b3A6IDJweDtcbmA7XG5jb25zdCBFcnJvclRyYW5zYWN0aW9uTm90aWZpY2F0aW9uID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoTm90aWZpY2F0aW9uLCB7XG4gICAgaGVhZGVyOiB7XG4gICAgICB0cmFuc2xhdGlvbktleTogXCJub3RpZmljYXRpb25zLnRyYW5zYWN0aW9uQ2FuY2VsZWQuaGVhZGVyXCJcbiAgICB9LFxuICAgIHRleHQ6IHtcbiAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIm5vdGlmaWNhdGlvbnMudHJhbnNhY3Rpb25DYW5jZWxlZC50ZXh0XCJcbiAgICB9LFxuICAgIGdldCBpY29uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChFcnJvckljb25TdHlsZWQkNCwge1xuICAgICAgICBzaXplOiBcInhzXCJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0IFtcImNsYXNzXCJdKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgIH0sXG4gICAgXCJkYXRhLXRjLW5vdGlmaWNhdGlvbi10eC1jYW5jZWxsZWRcIjogXCJ0cnVlXCIsXG4gICAgY2hpbGRyZW46IFwiVHJhbnNhY3Rpb24gY2FuY2VsbGVkXCJcbiAgfSk7XG59O1xuY29uc3QgU3VjY2Vzc0ljb25TdHlsZWQgPSBzdHlsZWQoU3VjY2Vzc0ljb24pYFxuICAgIG1hcmdpbi10b3A6IDJweDtcbmA7XG5jb25zdCBTdWNjZXNzVHJhbnNhY3Rpb25Ob3RpZmljYXRpb24gPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChOb3RpZmljYXRpb24sIHtcbiAgICBoZWFkZXI6IHtcbiAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIm5vdGlmaWNhdGlvbnMudHJhbnNhY3Rpb25TZW50LmhlYWRlclwiXG4gICAgfSxcbiAgICB0ZXh0OiB7XG4gICAgICB0cmFuc2xhdGlvbktleTogXCJub3RpZmljYXRpb25zLnRyYW5zYWN0aW9uU2VudC50ZXh0XCJcbiAgICB9LFxuICAgIGdldCBpY29uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChTdWNjZXNzSWNvblN0eWxlZCwge30pO1xuICAgIH0sXG4gICAgZ2V0IFtcImNsYXNzXCJdKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgIH0sXG4gICAgXCJkYXRhLXRjLW5vdGlmaWNhdGlvbi10eC1zZW50XCI6IFwidHJ1ZVwiLFxuICAgIGNoaWxkcmVuOiBcIlRyYW5zYWN0aW9uIHNlbnRcIlxuICB9KTtcbn07XG5jb25zdCBOb3RpZmljYXRpb25DbGFzcyA9IHVgXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC04cHgpO1xuICAgIG1hcmdpbi1ib3R0b206IDEycHg7XG5gO1xuY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcbiAgdGltZW91dDogNDUwMFxufTtcbmNvbnN0IFtsYXRlc3RBY3Rpb24sIHNldExhdGVzdEFjdGlvbl0gPSBjcmVhdGVTaWduYWwobnVsbCk7XG5mdW5jdGlvbiB1c2VPcGVuZWROb3RpZmljYXRpb25zKGNvbmZpZykge1xuICBjb25zdCB7IHRpbWVvdXQgfSA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBkZWZhdWx0Q29uZmlnKSwgY29uZmlnKTtcbiAgY29uc3QgW29wZW5lZE5vdGlmaWNhdGlvbnMsIHNldE9wZW5lZE5vdGlmaWNhdGlvbnNdID0gY3JlYXRlU2lnbmFsKFtdKTtcbiAgY29uc3QgW3RpbWVvdXRJZHMsIHNldFRpbWVvdXRJZHNdID0gY3JlYXRlU2lnbmFsKFtdKTtcbiAgY3JlYXRlRWZmZWN0KFxuICAgIG9uKGFjdGlvbiwgKGFjdGlvbjIpID0+IHtcbiAgICAgIHZhciBfYTIsIF9iMjtcbiAgICAgIGlmICghYWN0aW9uMiB8fCAhYWN0aW9uMi5zaG93Tm90aWZpY2F0aW9uKSB7XG4gICAgICAgIHNldE9wZW5lZE5vdGlmaWNhdGlvbnMoXG4gICAgICAgICAgKG9wZW5lZE5vdGlmaWNhdGlvbnMyKSA9PiBvcGVuZWROb3RpZmljYXRpb25zMi5maWx0ZXIoKG4yKSA9PiBuMi5hY3Rpb24gIT09IFwiY29uZmlybS10cmFuc2FjdGlvblwiKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobGF0ZXN0QWN0aW9uKCkgPT09IGFjdGlvbjIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNDb25maXJtVHJhbnNhY3Rpb25BY3Rpb24gPSAoKF9hMiA9IGxhdGVzdEFjdGlvbigpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLm5hbWUpID09PSBcImNvbmZpcm0tdHJhbnNhY3Rpb25cIiAmJiBhY3Rpb24yLm5hbWUgPT09IFwiY29uZmlybS10cmFuc2FjdGlvblwiO1xuICAgICAgY29uc3QgaXNDb25maXJtU2lnbkRhdGFBY3Rpb24gPSAoKF9iMiA9IGxhdGVzdEFjdGlvbigpKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLm5hbWUpID09PSBcImNvbmZpcm0tc2lnbi1kYXRhXCIgJiYgYWN0aW9uMi5uYW1lID09PSBcImNvbmZpcm0tc2lnbi1kYXRhXCI7XG4gICAgICBpZiAoaXNDb25maXJtVHJhbnNhY3Rpb25BY3Rpb24gfHwgaXNDb25maXJtU2lnbkRhdGFBY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0TGF0ZXN0QWN0aW9uKGFjdGlvbjIpO1xuICAgICAgc2V0T3BlbmVkTm90aWZpY2F0aW9ucyhcbiAgICAgICAgKG9wZW5lZE5vdGlmaWNhdGlvbnMyKSA9PiBvcGVuZWROb3RpZmljYXRpb25zMi5maWx0ZXIoXG4gICAgICAgICAgKG4yKSA9PiBuMi5hY3Rpb24gIT09IFwiY29uZmlybS10cmFuc2FjdGlvblwiICYmIG4yLmFjdGlvbiAhPT0gXCJjb25maXJtLXNpZ24tZGF0YVwiXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBjb25zdCBub3RpZmljYXRpb24gPSB7IGFjdGlvbjogYWN0aW9uMi5uYW1lIH07XG4gICAgICBzZXRPcGVuZWROb3RpZmljYXRpb25zKChvcGVuZWROb3RpZmljYXRpb25zMikgPT4gWy4uLm9wZW5lZE5vdGlmaWNhdGlvbnMyLCBub3RpZmljYXRpb25dKTtcbiAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzZXRPcGVuZWROb3RpZmljYXRpb25zKFxuICAgICAgICAgIChvcGVuZWROb3RpZmljYXRpb25zMikgPT4gb3BlbmVkTm90aWZpY2F0aW9uczIuZmlsdGVyKChuMikgPT4gbjIgIT09IG5vdGlmaWNhdGlvbilcbiAgICAgICAgKTtcbiAgICAgICAgc2V0VGltZW91dElkcygodGltZW91dElkczIpID0+IHRpbWVvdXRJZHMyLmZpbHRlcigoaWQpID0+IGlkICE9PSB0aW1lb3V0SWQpKTtcbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgc2V0VGltZW91dElkcygodGltZW91dElkczIpID0+IFsuLi50aW1lb3V0SWRzMiwgdGltZW91dElkXSk7XG4gICAgfSlcbiAgKTtcbiAgb25DbGVhbnVwKCgpID0+IHtcbiAgICB0aW1lb3V0SWRzKCkuZm9yRWFjaCgoaWQpID0+IGNsZWFyVGltZW91dChpZCkpO1xuICB9KTtcbiAgcmV0dXJuIG9wZW5lZE5vdGlmaWNhdGlvbnM7XG59XG5jb25zdCBFcnJvckljb25TdHlsZWQkMyA9IHN0eWxlZChFcnJvckljb24pYFxuICAgIG1hcmdpbi10b3A6IDJweDtcbmA7XG5jb25zdCBFcnJvclNpZ25EYXRhTm90aWZpY2F0aW9uID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoTm90aWZpY2F0aW9uLCB7XG4gICAgaGVhZGVyOiB7XG4gICAgICB0cmFuc2xhdGlvbktleTogXCJub3RpZmljYXRpb25zLnNpZ25EYXRhQ2FuY2VsZWQuaGVhZGVyXCJcbiAgICB9LFxuICAgIGdldCBpY29uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChFcnJvckljb25TdHlsZWQkMywge1xuICAgICAgICBzaXplOiBcInhzXCJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0IFtcImNsYXNzXCJdKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgIH0sXG4gICAgXCJkYXRhLXRjLW5vdGlmaWNhdGlvbi1zaWduLWRhdGEtY2FuY2VsbGVkXCI6IFwidHJ1ZVwiLFxuICAgIGNoaWxkcmVuOiBcIlNpZ24gZGF0YSBjYW5jZWxlZFwiXG4gIH0pO1xufTtcbmNvbnN0IFN1Y2Nlc3NTaWduRGF0YU5vdGlmaWNhdGlvbiA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KE5vdGlmaWNhdGlvbiwge1xuICAgIGhlYWRlcjoge1xuICAgICAgdHJhbnNsYXRpb25LZXk6IFwibm90aWZpY2F0aW9ucy5kYXRhU2lnbmVkLmhlYWRlclwiXG4gICAgfSxcbiAgICBnZXQgaWNvbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoU3VjY2Vzc0ljb25TdHlsZWQsIHt9KTtcbiAgICB9LFxuICAgIGdldCBbXCJjbGFzc1wiXSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5jbGFzcztcbiAgICB9LFxuICAgIFwiZGF0YS10Yy1ub3RpZmljYXRpb24tZGF0YS1zaWduZWRcIjogXCJ0cnVlXCIsXG4gICAgY2hpbGRyZW46IFwiRGF0YSBzaWduZWRcIlxuICB9KTtcbn07XG52YXIgX3RtcGwkJDUgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPGRpdiBkYXRhLXRjLWxpc3Qtbm90aWZpY2F0aW9ucz10cnVlPmApO1xuY29uc3QgTm90aWZpY2F0aW9ucyA9IChwcm9wcykgPT4ge1xuICBjb25zdCBvcGVuZWROb3RpZmljYXRpb25zID0gdXNlT3BlbmVkTm90aWZpY2F0aW9ucygpO1xuICByZXR1cm4gKCgpID0+IHtcbiAgICB2YXIgX2VsJCA9IF90bXBsJCQ1KCk7XG4gICAgaW5zZXJ0KF9lbCQsIGNyZWF0ZUNvbXBvbmVudChUcmFuc2l0aW9uR3JvdXAsIHtcbiAgICAgIG9uQmVmb3JlRW50ZXI6IChlbCkgPT4ge1xuICAgICAgICBhbmltYXRlKGVsLCBbe1xuICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoMClcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSgtOHB4KVwiXG4gICAgICAgIH1dLCB7XG4gICAgICAgICAgZHVyYXRpb246IDIwMFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvbkV4aXQ6IChlbCwgZG9uZSkgPT4ge1xuICAgICAgICBjb25zdCBhMiA9IGFuaW1hdGUoZWwsIFt7XG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSgtOHB4KVwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVZKC0zMHB4KVwiXG4gICAgICAgIH1dLCB7XG4gICAgICAgICAgZHVyYXRpb246IDIwMFxuICAgICAgICB9KTtcbiAgICAgICAgYTIuZmluaXNoZWQudGhlbihkb25lKTtcbiAgICAgIH0sXG4gICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoRm9yLCB7XG4gICAgICAgICAgZ2V0IGVhY2goKSB7XG4gICAgICAgICAgICByZXR1cm4gb3BlbmVkTm90aWZpY2F0aW9ucygpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2hpbGRyZW46IChvcGVuZWROb3RpZmljYXRpb24pID0+IGNyZWF0ZUNvbXBvbmVudChTd2l0Y2gsIHtcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVuZWROb3RpZmljYXRpb24uYWN0aW9uID09PSBcInRyYW5zYWN0aW9uLXNlbnRcIjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoU3VjY2Vzc1RyYW5zYWN0aW9uTm90aWZpY2F0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIFwiY2xhc3NcIjogTm90aWZpY2F0aW9uQ2xhc3NcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZW5lZE5vdGlmaWNhdGlvbi5hY3Rpb24gPT09IFwidHJhbnNhY3Rpb24tY2FuY2VsZWRcIjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoRXJyb3JUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCI6IE5vdGlmaWNhdGlvbkNsYXNzXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVuZWROb3RpZmljYXRpb24uYWN0aW9uID09PSBcImRhdGEtc2lnbmVkXCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFN1Y2Nlc3NTaWduRGF0YU5vdGlmaWNhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCI6IE5vdGlmaWNhdGlvbkNsYXNzXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVuZWROb3RpZmljYXRpb24uYWN0aW9uID09PSBcInNpZ24tZGF0YS1jYW5jZWxlZFwiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChFcnJvclNpZ25EYXRhTm90aWZpY2F0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIFwiY2xhc3NcIjogTm90aWZpY2F0aW9uQ2xhc3NcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZW5lZE5vdGlmaWNhdGlvbi5hY3Rpb24gPT09IFwiY29uZmlybS10cmFuc2FjdGlvblwiIHx8IG9wZW5lZE5vdGlmaWNhdGlvbi5hY3Rpb24gPT09IFwiY29uZmlybS1zaWduLWRhdGFcIjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQ29uZmlybU9wZXJhdGlvbk5vdGlmaWNhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCI6IE5vdGlmaWNhdGlvbkNsYXNzXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KCgpID0+IGNsYXNzTmFtZShfZWwkLCBwcm9wcy5jbGFzcykpO1xuICAgIHJldHVybiBfZWwkO1xuICB9KSgpO1xufTtcbmNvbnN0IEFjY291bnRCdXR0b25TdHlsZWQgPSBzdHlsZWQoQnV0dG9uKWBcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmNvbm5lY3RCdXR0b24uYmFja2dyb3VuZH07XG4gICAgY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuY29ubmVjdEJ1dHRvbi5mb3JlZ3JvdW5kfTtcbiAgICBib3gtc2hhZG93OiAkeyhwcm9wcykgPT4gYDAgNHB4IDI0cHggJHtyZ2JhKHByb3BzLnRoZW1lLmNvbG9ycy5jb25zdGFudC5ibGFjaywgMC4xNil9YH07XG4gICAgcGFkZGluZzogOHB4IDE2cHggOHB4IDEycHg7XG5cbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZ2FwOiA0cHg7XG4gICAgaGVpZ2h0OiA0MHB4O1xuYDtcbmNvbnN0IERyb3Bkb3duQnV0dG9uU3R5bGVkID0gc3R5bGVkKEFjY291bnRCdXR0b25TdHlsZWQpYFxuICAgIHBhZGRpbmc6IDEycHggMTZweDtcbiAgICBtaW4td2lkdGg6IDE0OHB4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5wcmltYXJ5fTtcbmA7XG5jb25zdCBMb2FkZXJCdXR0b25TdHlsZWQkMSA9IHN0eWxlZChCdXR0b24pYFxuICAgIG1pbi13aWR0aDogMTQ4cHg7XG4gICAgaGVpZ2h0OiA0MHB4O1xuXG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnByaW1hcnl9O1xuICAgIGNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmNvbm5lY3RCdXR0b24uZm9yZWdyb3VuZH07XG4gICAgYm94LXNoYWRvdzogJHsocHJvcHMpID0+IGAwIDRweCAyNHB4ICR7cmdiYShwcm9wcy50aGVtZS5jb2xvcnMuY29uc3RhbnQuYmxhY2ssIDAuMTYpfWB9O1xuXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuYDtcbmNvbnN0IExvYWRlckljb25TdHlsZWQkMSA9IHN0eWxlZChMb2FkZXJJY29uKWBcbiAgICBoZWlnaHQ6IDE4cHg7XG4gICAgd2lkdGg6IDE4cHg7XG5gO1xuY29uc3QgRHJvcGRvd25Db250YWluZXJTdHlsZWQgPSBzdHlsZWQuZGl2YFxuICAgIHdpZHRoOiBmaXQtY29udGVudDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgYWxpZ24taXRlbXM6IGZsZXgtZW5kO1xuYDtcbmNvbnN0IERyb3Bkb3duU3R5bGVkID0gc3R5bGVkKEFjY291bnRCdXR0b25Ecm9wZG93bilgXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIG1hcmdpbi10b3A6IDEycHg7XG5gO1xuY29uc3QgTm90aWZpY2F0aW9uc1N0eWxlZCA9IHN0eWxlZChOb3RpZmljYXRpb25zKWBcbiAgICA+IGRpdjpmaXJzdC1jaGlsZCB7XG4gICAgICAgIG1hcmdpbi10b3A6IDIwcHg7XG4gICAgfVxuYDtcbmNvbnN0IG1pbiA9IE1hdGgubWluO1xuY29uc3QgbWF4ID0gTWF0aC5tYXg7XG5jb25zdCByb3VuZCA9IE1hdGgucm91bmQ7XG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5jb25zdCBjcmVhdGVDb29yZHMgPSAodikgPT4gKHtcbiAgeDogdixcbiAgeTogdlxufSk7XG5jb25zdCBvcHBvc2l0ZVNpZGVNYXAgPSB7XG4gIGxlZnQ6IFwicmlnaHRcIixcbiAgcmlnaHQ6IFwibGVmdFwiLFxuICBib3R0b206IFwidG9wXCIsXG4gIHRvcDogXCJib3R0b21cIlxufTtcbmNvbnN0IG9wcG9zaXRlQWxpZ25tZW50TWFwID0ge1xuICBzdGFydDogXCJlbmRcIixcbiAgZW5kOiBcInN0YXJ0XCJcbn07XG5mdW5jdGlvbiBjbGFtcChzdGFydCwgdmFsdWUsIGVuZCkge1xuICByZXR1cm4gbWF4KHN0YXJ0LCBtaW4odmFsdWUsIGVuZCkpO1xufVxuZnVuY3Rpb24gZXZhbHVhdGUodmFsdWUsIHBhcmFtKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlKHBhcmFtKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0U2lkZShwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdChcIi1cIilbMF07XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoXCItXCIpWzFdO1xufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVBeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09IFwieFwiID8gXCJ5XCIgOiBcInhcIjtcbn1cbmZ1bmN0aW9uIGdldEF4aXNMZW5ndGgoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gXCJ5XCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiO1xufVxuY29uc3QgeUF4aXNTaWRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRvcFwiLCBcImJvdHRvbVwiXSk7XG5mdW5jdGlvbiBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHlBeGlzU2lkZXMuaGFzKGdldFNpZGUocGxhY2VtZW50KSkgPyBcInlcIiA6IFwieFwiO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGdldE9wcG9zaXRlQXhpcyhnZXRTaWRlQXhpcyhwbGFjZW1lbnQpKTtcbn1cbmZ1bmN0aW9uIGdldEFsaWdubWVudFNpZGVzKHBsYWNlbWVudCwgcmVjdHMsIHJ0bCkge1xuICBpZiAocnRsID09PSB2b2lkIDApIHtcbiAgICBydGwgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50QXhpcyA9IGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgbGVuZ3RoID0gZ2V0QXhpc0xlbmd0aChhbGlnbm1lbnRBeGlzKTtcbiAgbGV0IG1haW5BbGlnbm1lbnRTaWRlID0gYWxpZ25tZW50QXhpcyA9PT0gXCJ4XCIgPyBhbGlnbm1lbnQgPT09IChydGwgPyBcImVuZFwiIDogXCJzdGFydFwiKSA/IFwicmlnaHRcIiA6IFwibGVmdFwiIDogYWxpZ25tZW50ID09PSBcInN0YXJ0XCIgPyBcImJvdHRvbVwiIDogXCJ0b3BcIjtcbiAgaWYgKHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdID4gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXSkge1xuICAgIG1haW5BbGlnbm1lbnRTaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpbkFsaWdubWVudFNpZGUpO1xuICB9XG4gIHJldHVybiBbbWFpbkFsaWdubWVudFNpZGUsIGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5BbGlnbm1lbnRTaWRlKV07XG59XG5mdW5jdGlvbiBnZXRFeHBhbmRlZFBsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGNvbnN0IG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cbmZ1bmN0aW9uIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCAoYWxpZ25tZW50KSA9PiBvcHBvc2l0ZUFsaWdubWVudE1hcFthbGlnbm1lbnRdKTtcbn1cbmNvbnN0IGxyUGxhY2VtZW50ID0gW1wibGVmdFwiLCBcInJpZ2h0XCJdO1xuY29uc3QgcmxQbGFjZW1lbnQgPSBbXCJyaWdodFwiLCBcImxlZnRcIl07XG5jb25zdCB0YlBsYWNlbWVudCA9IFtcInRvcFwiLCBcImJvdHRvbVwiXTtcbmNvbnN0IGJ0UGxhY2VtZW50ID0gW1wiYm90dG9tXCIsIFwidG9wXCJdO1xuZnVuY3Rpb24gZ2V0U2lkZUxpc3Qoc2lkZSwgaXNTdGFydCwgcnRsKSB7XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgXCJ0b3BcIjpcbiAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICBpZiAocnRsKSByZXR1cm4gaXNTdGFydCA/IHJsUGxhY2VtZW50IDogbHJQbGFjZW1lbnQ7XG4gICAgICByZXR1cm4gaXNTdGFydCA/IGxyUGxhY2VtZW50IDogcmxQbGFjZW1lbnQ7XG4gICAgY2FzZSBcImxlZnRcIjpcbiAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgIHJldHVybiBpc1N0YXJ0ID8gdGJQbGFjZW1lbnQgOiBidFBsYWNlbWVudDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFtdO1xuICB9XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzKHBsYWNlbWVudCwgZmxpcEFsaWdubWVudCwgZGlyZWN0aW9uLCBydGwpIHtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGxldCBsaXN0ID0gZ2V0U2lkZUxpc3QoZ2V0U2lkZShwbGFjZW1lbnQpLCBkaXJlY3Rpb24gPT09IFwic3RhcnRcIiwgcnRsKTtcbiAgaWYgKGFsaWdubWVudCkge1xuICAgIGxpc3QgPSBsaXN0Lm1hcCgoc2lkZSkgPT4gc2lkZSArIFwiLVwiICsgYWxpZ25tZW50KTtcbiAgICBpZiAoZmxpcEFsaWdubWVudCkge1xuICAgICAgbGlzdCA9IGxpc3QuY29uY2F0KGxpc3QubWFwKGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsaXN0O1xufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIChzaWRlKSA9PiBvcHBvc2l0ZVNpZGVNYXBbc2lkZV0pO1xufVxuZnVuY3Rpb24gZXhwYW5kUGFkZGluZ09iamVjdChwYWRkaW5nKSB7XG4gIHJldHVybiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH0sIHBhZGRpbmcpO1xufVxuZnVuY3Rpb24gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKSB7XG4gIHJldHVybiB0eXBlb2YgcGFkZGluZyAhPT0gXCJudW1iZXJcIiA/IGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykgOiB7XG4gICAgdG9wOiBwYWRkaW5nLFxuICAgIHJpZ2h0OiBwYWRkaW5nLFxuICAgIGJvdHRvbTogcGFkZGluZyxcbiAgICBsZWZ0OiBwYWRkaW5nXG4gIH07XG59XG5mdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IHJlY3Q7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICBsZWZ0OiB4LFxuICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgYm90dG9tOiB5ICsgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQoX3JlZiwgcGxhY2VtZW50LCBydGwpIHtcbiAgbGV0IHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmdcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHNpZGVBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50QXhpcyA9IGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25MZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpO1xuICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gc2lkZUF4aXMgPT09IFwieVwiO1xuICBjb25zdCBjb21tb25YID0gcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gZmxvYXRpbmcud2lkdGggLyAyO1xuICBjb25zdCBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGZsb2F0aW5nLmhlaWdodCAvIDI7XG4gIGNvbnN0IGNvbW1vbkFsaWduID0gcmVmZXJlbmNlW2FsaWduTGVuZ3RoXSAvIDIgLSBmbG9hdGluZ1thbGlnbkxlbmd0aF0gLyAyO1xuICBsZXQgY29vcmRzO1xuICBzd2l0Y2ggKHNpZGUpIHtcbiAgICBjYXNlIFwidG9wXCI6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZmxvYXRpbmcuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGZsb2F0aW5nLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG4gIHN3aXRjaCAoZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkpIHtcbiAgICBjYXNlIFwic3RhcnRcIjpcbiAgICAgIGNvb3Jkc1thbGlnbm1lbnRBeGlzXSAtPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZW5kXCI6XG4gICAgICBjb29yZHNbYWxpZ25tZW50QXhpc10gKz0gY29tbW9uQWxpZ24gKiAocnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDEpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGNvb3Jkcztcbn1cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiQxID0gKHJlZmVyZW5jZSwgZmxvYXRpbmcsIGNvbmZpZykgPT4gX19hc3luYyhudWxsLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICBjb25zdCB7XG4gICAgcGxhY2VtZW50ID0gXCJib3R0b21cIixcbiAgICBzdHJhdGVneSA9IFwiYWJzb2x1dGVcIixcbiAgICBtaWRkbGV3YXJlID0gW10sXG4gICAgcGxhdGZvcm06IHBsYXRmb3JtMlxuICB9ID0gY29uZmlnO1xuICBjb25zdCB2YWxpZE1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlLmZpbHRlcihCb29sZWFuKTtcbiAgY29uc3QgcnRsID0geWllbGQgcGxhdGZvcm0yLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybTIuaXNSVEwoZmxvYXRpbmcpO1xuICBsZXQgcmVjdHMgPSB5aWVsZCBwbGF0Zm9ybTIuZ2V0RWxlbWVudFJlY3RzKHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmcsXG4gICAgc3RyYXRlZ3lcbiAgfSk7XG4gIGxldCB7XG4gICAgeCxcbiAgICB5XG4gIH0gPSBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChyZWN0cywgcGxhY2VtZW50LCBydGwpO1xuICBsZXQgc3RhdGVmdWxQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gIGxldCBtaWRkbGV3YXJlRGF0YSA9IHt9O1xuICBsZXQgcmVzZXRDb3VudCA9IDA7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCB2YWxpZE1pZGRsZXdhcmUubGVuZ3RoOyBpMisrKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGZuXG4gICAgfSA9IHZhbGlkTWlkZGxld2FyZVtpMl07XG4gICAgY29uc3Qge1xuICAgICAgeDogbmV4dFgsXG4gICAgICB5OiBuZXh0WSxcbiAgICAgIGRhdGEsXG4gICAgICByZXNldFxuICAgIH0gPSB5aWVsZCBmbih7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGluaXRpYWxQbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIHBsYWNlbWVudDogc3RhdGVmdWxQbGFjZW1lbnQsXG4gICAgICBzdHJhdGVneSxcbiAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgcmVjdHMsXG4gICAgICBwbGF0Zm9ybTogcGxhdGZvcm0yLFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICBmbG9hdGluZ1xuICAgICAgfVxuICAgIH0pO1xuICAgIHggPSBuZXh0WCAhPSBudWxsID8gbmV4dFggOiB4O1xuICAgIHkgPSBuZXh0WSAhPSBudWxsID8gbmV4dFkgOiB5O1xuICAgIG1pZGRsZXdhcmVEYXRhID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgbWlkZGxld2FyZURhdGEpLCB7XG4gICAgICBbbmFtZV06IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBtaWRkbGV3YXJlRGF0YVtuYW1lXSksIGRhdGEpXG4gICAgfSk7XG4gICAgaWYgKHJlc2V0ICYmIHJlc2V0Q291bnQgPD0gNTApIHtcbiAgICAgIHJlc2V0Q291bnQrKztcbiAgICAgIGlmICh0eXBlb2YgcmVzZXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKHJlc2V0LnBsYWNlbWVudCkge1xuICAgICAgICAgIHN0YXRlZnVsUGxhY2VtZW50ID0gcmVzZXQucGxhY2VtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNldC5yZWN0cykge1xuICAgICAgICAgIHJlY3RzID0gcmVzZXQucmVjdHMgPT09IHRydWUgPyB5aWVsZCBwbGF0Zm9ybTIuZ2V0RWxlbWVudFJlY3RzKHtcbiAgICAgICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgICAgIGZsb2F0aW5nLFxuICAgICAgICAgICAgc3RyYXRlZ3lcbiAgICAgICAgICB9KSA6IHJlc2V0LnJlY3RzO1xuICAgICAgICB9XG4gICAgICAgICh7XG4gICAgICAgICAgeCxcbiAgICAgICAgICB5XG4gICAgICAgIH0gPSBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChyZWN0cywgc3RhdGVmdWxQbGFjZW1lbnQsIHJ0bCkpO1xuICAgICAgfVxuICAgICAgaTIgPSAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHksXG4gICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICBzdHJhdGVneSxcbiAgICBtaWRkbGV3YXJlRGF0YVxuICB9O1xufSk7XG5mdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgb3B0aW9ucykge1xuICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIHZhciBfYXdhaXQkcGxhdGZvcm0kaXNFbGU7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHBsYXRmb3JtOiBwbGF0Zm9ybTIsXG4gICAgICByZWN0cyxcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgc3RyYXRlZ3lcbiAgICB9ID0gc3RhdGU7XG4gICAgY29uc3Qge1xuICAgICAgYm91bmRhcnkgPSBcImNsaXBwaW5nQW5jZXN0b3JzXCIsXG4gICAgICByb290Qm91bmRhcnkgPSBcInZpZXdwb3J0XCIsXG4gICAgICBlbGVtZW50Q29udGV4dCA9IFwiZmxvYXRpbmdcIixcbiAgICAgIGFsdEJvdW5kYXJ5ID0gZmFsc2UsXG4gICAgICBwYWRkaW5nID0gMFxuICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFBhZGRpbmdPYmplY3QocGFkZGluZyk7XG4gICAgY29uc3QgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSBcImZsb2F0aW5nXCIgPyBcInJlZmVyZW5jZVwiIDogXCJmbG9hdGluZ1wiO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gICAgY29uc3QgY2xpcHBpbmdDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdCh5aWVsZCBwbGF0Zm9ybTIuZ2V0Q2xpcHBpbmdSZWN0KHtcbiAgICAgIGVsZW1lbnQ6ICgoX2F3YWl0JHBsYXRmb3JtJGlzRWxlID0geWllbGQgcGxhdGZvcm0yLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0yLmlzRWxlbWVudChlbGVtZW50KSkgIT0gbnVsbCA/IF9hd2FpdCRwbGF0Zm9ybSRpc0VsZSA6IHRydWUpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgKHlpZWxkIHBsYXRmb3JtMi5nZXREb2N1bWVudEVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtMi5nZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudHMuZmxvYXRpbmcpKSxcbiAgICAgIGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5LFxuICAgICAgc3RyYXRlZ3lcbiAgICB9KSk7XG4gICAgY29uc3QgcmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSBcImZsb2F0aW5nXCIgPyB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoOiByZWN0cy5mbG9hdGluZy53aWR0aCxcbiAgICAgIGhlaWdodDogcmVjdHMuZmxvYXRpbmcuaGVpZ2h0XG4gICAgfSA6IHJlY3RzLnJlZmVyZW5jZTtcbiAgICBjb25zdCBvZmZzZXRQYXJlbnQgPSB5aWVsZCBwbGF0Zm9ybTIuZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybTIuZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnRzLmZsb2F0aW5nKTtcbiAgICBjb25zdCBvZmZzZXRTY2FsZSA9ICh5aWVsZCBwbGF0Zm9ybTIuaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybTIuaXNFbGVtZW50KG9mZnNldFBhcmVudCkpID8gKHlpZWxkIHBsYXRmb3JtMi5nZXRTY2FsZSA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0yLmdldFNjYWxlKG9mZnNldFBhcmVudCkpIHx8IHtcbiAgICAgIHg6IDEsXG4gICAgICB5OiAxXG4gICAgfSA6IHtcbiAgICAgIHg6IDEsXG4gICAgICB5OiAxXG4gICAgfTtcbiAgICBjb25zdCBlbGVtZW50Q2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QocGxhdGZvcm0yLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0ID8geWllbGQgcGxhdGZvcm0yLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KHtcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgcmVjdCxcbiAgICAgIG9mZnNldFBhcmVudCxcbiAgICAgIHN0cmF0ZWd5XG4gICAgfSkgOiByZWN0KTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiAoY2xpcHBpbmdDbGllbnRSZWN0LnRvcCAtIGVsZW1lbnRDbGllbnRSZWN0LnRvcCArIHBhZGRpbmdPYmplY3QudG9wKSAvIG9mZnNldFNjYWxlLnksXG4gICAgICBib3R0b206IChlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20pIC8gb2Zmc2V0U2NhbGUueSxcbiAgICAgIGxlZnQ6IChjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQpIC8gb2Zmc2V0U2NhbGUueCxcbiAgICAgIHJpZ2h0OiAoZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0KSAvIG9mZnNldFNjYWxlLnhcbiAgICB9O1xuICB9KTtcbn1cbmNvbnN0IGZsaXAkMSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6IFwiZmxpcFwiLFxuICAgIG9wdGlvbnMsXG4gICAgZm4oc3RhdGUpIHtcbiAgICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkYXJyb3csIF9taWRkbGV3YXJlRGF0YSRmbGlwO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgICAgIHJlY3RzLFxuICAgICAgICAgIGluaXRpYWxQbGFjZW1lbnQsXG4gICAgICAgICAgcGxhdGZvcm06IHBsYXRmb3JtMixcbiAgICAgICAgICBlbGVtZW50c1xuICAgICAgICB9ID0gc3RhdGU7XG4gICAgICAgIGNvbnN0IF9hMyA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKSwge1xuICAgICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gdHJ1ZSxcbiAgICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgICAgICBmYWxsYmFja1N0cmF0ZWd5ID0gXCJiZXN0Rml0XCIsXG4gICAgICAgICAgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiA9IFwibm9uZVwiLFxuICAgICAgICAgIGZsaXBBbGlnbm1lbnQgPSB0cnVlXG4gICAgICAgIH0gPSBfYTMsIGRldGVjdE92ZXJmbG93T3B0aW9ucyA9IF9fb2JqUmVzdChfYTMsIFtcbiAgICAgICAgICBcIm1haW5BeGlzXCIsXG4gICAgICAgICAgXCJjcm9zc0F4aXNcIixcbiAgICAgICAgICBcImZhbGxiYWNrUGxhY2VtZW50c1wiLFxuICAgICAgICAgIFwiZmFsbGJhY2tTdHJhdGVneVwiLFxuICAgICAgICAgIFwiZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvblwiLFxuICAgICAgICAgIFwiZmxpcEFsaWdubWVudFwiXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoKF9taWRkbGV3YXJlRGF0YSRhcnJvdyA9IG1pZGRsZXdhcmVEYXRhLmFycm93KSAhPSBudWxsICYmIF9taWRkbGV3YXJlRGF0YSRhcnJvdy5hbGlnbm1lbnRPZmZzZXQpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgICAgICAgY29uc3QgaW5pdGlhbFNpZGVBeGlzID0gZ2V0U2lkZUF4aXMoaW5pdGlhbFBsYWNlbWVudCk7XG4gICAgICAgIGNvbnN0IGlzQmFzZVBsYWNlbWVudCA9IGdldFNpZGUoaW5pdGlhbFBsYWNlbWVudCkgPT09IGluaXRpYWxQbGFjZW1lbnQ7XG4gICAgICAgIGNvbnN0IHJ0bCA9IHlpZWxkIHBsYXRmb3JtMi5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0yLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKTtcbiAgICAgICAgY29uc3QgZmFsbGJhY2tQbGFjZW1lbnRzID0gc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8IChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBBbGlnbm1lbnQgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQoaW5pdGlhbFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRQbGFjZW1lbnRzKGluaXRpYWxQbGFjZW1lbnQpKTtcbiAgICAgICAgY29uc3QgaGFzRmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiA9IGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24gIT09IFwibm9uZVwiO1xuICAgICAgICBpZiAoIXNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyAmJiBoYXNGYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uKSB7XG4gICAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzLnB1c2goLi4uZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyhpbml0aWFsUGxhY2VtZW50LCBmbGlwQWxpZ25tZW50LCBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uLCBydGwpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbGFjZW1lbnRzID0gW2luaXRpYWxQbGFjZW1lbnQsIC4uLmZhbGxiYWNrUGxhY2VtZW50c107XG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID0geWllbGQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93cyA9IFtdO1xuICAgICAgICBsZXQgb3ZlcmZsb3dzRGF0YSA9ICgoX21pZGRsZXdhcmVEYXRhJGZsaXAgPSBtaWRkbGV3YXJlRGF0YS5mbGlwKSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGZsaXAub3ZlcmZsb3dzKSB8fCBbXTtcbiAgICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgICBvdmVyZmxvd3MucHVzaChvdmVyZmxvd1tzaWRlXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgICAgY29uc3Qgc2lkZXMgPSBnZXRBbGlnbm1lbnRTaWRlcyhwbGFjZW1lbnQsIHJlY3RzLCBydGwpO1xuICAgICAgICAgIG92ZXJmbG93cy5wdXNoKG92ZXJmbG93W3NpZGVzWzBdXSwgb3ZlcmZsb3dbc2lkZXNbMV1dKTtcbiAgICAgICAgfVxuICAgICAgICBvdmVyZmxvd3NEYXRhID0gWy4uLm92ZXJmbG93c0RhdGEsIHtcbiAgICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgICAgb3ZlcmZsb3dzXG4gICAgICAgIH1dO1xuICAgICAgICBpZiAoIW92ZXJmbG93cy5ldmVyeSgoc2lkZTIpID0+IHNpZGUyIDw9IDApKSB7XG4gICAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRmbGlwMiwgX292ZXJmbG93c0RhdGEkZmlsdGVyO1xuICAgICAgICAgIGNvbnN0IG5leHRJbmRleCA9ICgoKF9taWRkbGV3YXJlRGF0YSRmbGlwMiA9IG1pZGRsZXdhcmVEYXRhLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkZmxpcDIuaW5kZXgpIHx8IDApICsgMTtcbiAgICAgICAgICBjb25zdCBuZXh0UGxhY2VtZW50ID0gcGxhY2VtZW50c1tuZXh0SW5kZXhdO1xuICAgICAgICAgIGlmIChuZXh0UGxhY2VtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBpZ25vcmVDcm9zc0F4aXNPdmVyZmxvdyA9IGNoZWNrQ3Jvc3NBeGlzID09PSBcImFsaWdubWVudFwiID8gaW5pdGlhbFNpZGVBeGlzICE9PSBnZXRTaWRlQXhpcyhuZXh0UGxhY2VtZW50KSA6IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFpZ25vcmVDcm9zc0F4aXNPdmVyZmxvdyB8fCAvLyBXZSBsZWF2ZSB0aGUgY3VycmVudCBtYWluIGF4aXMgb25seSBpZiBldmVyeSBwbGFjZW1lbnQgb24gdGhhdCBheGlzXG4gICAgICAgICAgICAvLyBvdmVyZmxvd3MgdGhlIG1haW4gYXhpcy5cbiAgICAgICAgICAgIG92ZXJmbG93c0RhdGEuZXZlcnkoKGQpID0+IGdldFNpZGVBeGlzKGQucGxhY2VtZW50KSA9PT0gaW5pdGlhbFNpZGVBeGlzID8gZC5vdmVyZmxvd3NbMF0gPiAwIDogdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICAgICAgICAgICAgb3ZlcmZsb3dzOiBvdmVyZmxvd3NEYXRhXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcmVzZXRQbGFjZW1lbnQgPSAoX292ZXJmbG93c0RhdGEkZmlsdGVyID0gb3ZlcmZsb3dzRGF0YS5maWx0ZXIoKGQpID0+IGQub3ZlcmZsb3dzWzBdIDw9IDApLnNvcnQoKGEyLCBiKSA9PiBhMi5vdmVyZmxvd3NbMV0gLSBiLm92ZXJmbG93c1sxXSlbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIucGxhY2VtZW50O1xuICAgICAgICAgIGlmICghcmVzZXRQbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZmFsbGJhY2tTdHJhdGVneSkge1xuICAgICAgICAgICAgICBjYXNlIFwiYmVzdEZpdFwiOiB7XG4gICAgICAgICAgICAgICAgdmFyIF9vdmVyZmxvd3NEYXRhJGZpbHRlcjI7XG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2VtZW50MiA9IChfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIyID0gb3ZlcmZsb3dzRGF0YS5maWx0ZXIoKGQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChoYXNGYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTaWRlQXhpcyA9IGdldFNpZGVBeGlzKGQucGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTaWRlQXhpcyA9PT0gaW5pdGlhbFNpZGVBeGlzIHx8IC8vIENyZWF0ZSBhIGJpYXMgdG8gdGhlIGB5YCBzaWRlIGF4aXMgZHVlIHRvIGhvcml6b250YWxcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZGluZyBkaXJlY3Rpb25zIGZhdm9yaW5nIGdyZWF0ZXIgd2lkdGguXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaWRlQXhpcyA9PT0gXCJ5XCI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KS5tYXAoKGQpID0+IFtkLnBsYWNlbWVudCwgZC5vdmVyZmxvd3MuZmlsdGVyKChvdmVyZmxvdzIpID0+IG92ZXJmbG93MiA+IDApLnJlZHVjZSgoYWNjLCBvdmVyZmxvdzIpID0+IGFjYyArIG92ZXJmbG93MiwgMCldKS5zb3J0KChhMiwgYikgPT4gYTJbMV0gLSBiWzFdKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vdmVyZmxvd3NEYXRhJGZpbHRlcjJbMF07XG4gICAgICAgICAgICAgICAgaWYgKHBsYWNlbWVudDIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc2V0UGxhY2VtZW50ID0gcGxhY2VtZW50MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcImluaXRpYWxQbGFjZW1lbnRcIjpcbiAgICAgICAgICAgICAgICByZXNldFBsYWNlbWVudCA9IGluaXRpYWxQbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwbGFjZW1lbnQgIT09IHJlc2V0UGxhY2VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogcmVzZXRQbGFjZW1lbnRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcbmNvbnN0IHNoaWZ0JDEgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBcInNoaWZ0XCIsXG4gICAgb3B0aW9ucyxcbiAgICBmbihzdGF0ZSkge1xuICAgICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICBwbGFjZW1lbnRcbiAgICAgICAgfSA9IHN0YXRlO1xuICAgICAgICBjb25zdCBfYTMgPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSksIHtcbiAgICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IGZhbHNlLFxuICAgICAgICAgIGxpbWl0ZXIgPSB7XG4gICAgICAgICAgICBmbjogKF9yZWYpID0+IHtcbiAgICAgICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgICAgICB4OiB4MixcbiAgICAgICAgICAgICAgICB5OiB5MlxuICAgICAgICAgICAgICB9ID0gX3JlZjtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB4MixcbiAgICAgICAgICAgICAgICB5OiB5MlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSA9IF9hMywgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zID0gX19vYmpSZXN0KF9hMywgW1xuICAgICAgICAgIFwibWFpbkF4aXNcIixcbiAgICAgICAgICBcImNyb3NzQXhpc1wiLFxuICAgICAgICAgIFwibGltaXRlclwiXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBjb29yZHMgPSB7XG4gICAgICAgICAgeCxcbiAgICAgICAgICB5XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID0geWllbGQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNyb3NzQXhpcyA9IGdldFNpZGVBeGlzKGdldFNpZGUocGxhY2VtZW50KSk7XG4gICAgICAgIGNvbnN0IG1haW5BeGlzID0gZ2V0T3Bwb3NpdGVBeGlzKGNyb3NzQXhpcyk7XG4gICAgICAgIGxldCBtYWluQXhpc0Nvb3JkID0gY29vcmRzW21haW5BeGlzXTtcbiAgICAgICAgbGV0IGNyb3NzQXhpc0Nvb3JkID0gY29vcmRzW2Nyb3NzQXhpc107XG4gICAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgICAgY29uc3QgbWluU2lkZSA9IG1haW5BeGlzID09PSBcInlcIiA/IFwidG9wXCIgOiBcImxlZnRcIjtcbiAgICAgICAgICBjb25zdCBtYXhTaWRlID0gbWFpbkF4aXMgPT09IFwieVwiID8gXCJib3R0b21cIiA6IFwicmlnaHRcIjtcbiAgICAgICAgICBjb25zdCBtaW4yID0gbWFpbkF4aXNDb29yZCArIG92ZXJmbG93W21pblNpZGVdO1xuICAgICAgICAgIGNvbnN0IG1heDIgPSBtYWluQXhpc0Nvb3JkIC0gb3ZlcmZsb3dbbWF4U2lkZV07XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGNsYW1wKG1pbjIsIG1haW5BeGlzQ29vcmQsIG1heDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICAgIGNvbnN0IG1pblNpZGUgPSBjcm9zc0F4aXMgPT09IFwieVwiID8gXCJ0b3BcIiA6IFwibGVmdFwiO1xuICAgICAgICAgIGNvbnN0IG1heFNpZGUgPSBjcm9zc0F4aXMgPT09IFwieVwiID8gXCJib3R0b21cIiA6IFwicmlnaHRcIjtcbiAgICAgICAgICBjb25zdCBtaW4yID0gY3Jvc3NBeGlzQ29vcmQgKyBvdmVyZmxvd1ttaW5TaWRlXTtcbiAgICAgICAgICBjb25zdCBtYXgyID0gY3Jvc3NBeGlzQ29vcmQgLSBvdmVyZmxvd1ttYXhTaWRlXTtcbiAgICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGNsYW1wKG1pbjIsIGNyb3NzQXhpc0Nvb3JkLCBtYXgyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW1pdGVkQ29vcmRzID0gbGltaXRlci5mbihfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBzdGF0ZSksIHtcbiAgICAgICAgICBbbWFpbkF4aXNdOiBtYWluQXhpc0Nvb3JkLFxuICAgICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBsaW1pdGVkQ29vcmRzKSwge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHg6IGxpbWl0ZWRDb29yZHMueCAtIHgsXG4gICAgICAgICAgICB5OiBsaW1pdGVkQ29vcmRzLnkgLSB5LFxuICAgICAgICAgICAgZW5hYmxlZDoge1xuICAgICAgICAgICAgICBbbWFpbkF4aXNdOiBjaGVja01haW5BeGlzLFxuICAgICAgICAgICAgICBbY3Jvc3NBeGlzXTogY2hlY2tDcm9zc0F4aXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIGhhc1dpbmRvdygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59XG5mdW5jdGlvbiBnZXROb2RlTmFtZShub2RlKSB7XG4gIGlmIChpc05vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gKG5vZGUubm9kZU5hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgfVxuICByZXR1cm4gXCIjZG9jdW1lbnRcIjtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gIHZhciBfbm9kZSRvd25lckRvY3VtZW50O1xuICByZXR1cm4gKG5vZGUgPT0gbnVsbCB8fCAoX25vZGUkb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIHx8IHdpbmRvdztcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChub2RlKSB7XG4gIHZhciBfcmVmO1xuICByZXR1cm4gKF9yZWYgPSAoaXNOb2RlKG5vZGUpID8gbm9kZS5vd25lckRvY3VtZW50IDogbm9kZS5kb2N1bWVudCkgfHwgd2luZG93LmRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3JlZi5kb2N1bWVudEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc05vZGUodmFsdWUpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBOb2RlIHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5Ob2RlO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gIGlmICghaGFzV2luZG93KCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQodmFsdWUpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuSFRNTEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3QodmFsdWUpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSB8fCB0eXBlb2YgU2hhZG93Um9vdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTaGFkb3dSb290IHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5TaGFkb3dSb290O1xufVxuY29uc3QgaW52YWxpZE92ZXJmbG93RGlzcGxheVZhbHVlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImlubGluZVwiLCBcImNvbnRlbnRzXCJdKTtcbmZ1bmN0aW9uIGlzT3ZlcmZsb3dFbGVtZW50KGVsZW1lbnQpIHtcbiAgY29uc3Qge1xuICAgIG92ZXJmbG93LFxuICAgIG92ZXJmbG93WCxcbiAgICBvdmVyZmxvd1ksXG4gICAgZGlzcGxheVxuICB9ID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpO1xuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVufGNsaXAvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpICYmICFpbnZhbGlkT3ZlcmZsb3dEaXNwbGF5VmFsdWVzLmhhcyhkaXNwbGF5KTtcbn1cbmNvbnN0IHRhYmxlRWxlbWVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJ0YWJsZVwiLCBcInRkXCIsIFwidGhcIl0pO1xuZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gdGFibGVFbGVtZW50cy5oYXMoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpO1xufVxuY29uc3QgdG9wTGF5ZXJTZWxlY3RvcnMgPSBbXCI6cG9wb3Zlci1vcGVuXCIsIFwiOm1vZGFsXCJdO1xuZnVuY3Rpb24gaXNUb3BMYXllcihlbGVtZW50KSB7XG4gIHJldHVybiB0b3BMYXllclNlbGVjdG9ycy5zb21lKChzZWxlY3RvcikgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICB9IGNhdGNoIChfZTIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xufVxuY29uc3QgdHJhbnNmb3JtUHJvcGVydGllcyA9IFtcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZVwiLCBcInNjYWxlXCIsIFwicm90YXRlXCIsIFwicGVyc3BlY3RpdmVcIl07XG5jb25zdCB3aWxsQ2hhbmdlVmFsdWVzID0gW1widHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlXCIsIFwic2NhbGVcIiwgXCJyb3RhdGVcIiwgXCJwZXJzcGVjdGl2ZVwiLCBcImZpbHRlclwiXTtcbmNvbnN0IGNvbnRhaW5WYWx1ZXMgPSBbXCJwYWludFwiLCBcImxheW91dFwiLCBcInN0cmljdFwiLCBcImNvbnRlbnRcIl07XG5mdW5jdGlvbiBpc0NvbnRhaW5pbmdCbG9jayhlbGVtZW50T3JDc3MpIHtcbiAgY29uc3Qgd2Via2l0ID0gaXNXZWJLaXQoKTtcbiAgY29uc3QgY3NzID0gaXNFbGVtZW50KGVsZW1lbnRPckNzcykgPyBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudE9yQ3NzKSA6IGVsZW1lbnRPckNzcztcbiAgcmV0dXJuIHRyYW5zZm9ybVByb3BlcnRpZXMuc29tZSgodmFsdWUpID0+IGNzc1t2YWx1ZV0gPyBjc3NbdmFsdWVdICE9PSBcIm5vbmVcIiA6IGZhbHNlKSB8fCAoY3NzLmNvbnRhaW5lclR5cGUgPyBjc3MuY29udGFpbmVyVHlwZSAhPT0gXCJub3JtYWxcIiA6IGZhbHNlKSB8fCAhd2Via2l0ICYmIChjc3MuYmFja2Ryb3BGaWx0ZXIgPyBjc3MuYmFja2Ryb3BGaWx0ZXIgIT09IFwibm9uZVwiIDogZmFsc2UpIHx8ICF3ZWJraXQgJiYgKGNzcy5maWx0ZXIgPyBjc3MuZmlsdGVyICE9PSBcIm5vbmVcIiA6IGZhbHNlKSB8fCB3aWxsQ2hhbmdlVmFsdWVzLnNvbWUoKHZhbHVlKSA9PiAoY3NzLndpbGxDaGFuZ2UgfHwgXCJcIikuaW5jbHVkZXModmFsdWUpKSB8fCBjb250YWluVmFsdWVzLnNvbWUoKHZhbHVlKSA9PiAoY3NzLmNvbnRhaW4gfHwgXCJcIikuaW5jbHVkZXModmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiAhaXNMYXN0VHJhdmVyc2FibGVOb2RlKGN1cnJlbnROb2RlKSkge1xuICAgIGlmIChpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2UgaWYgKGlzVG9wTGF5ZXIoY3VycmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzV2ViS2l0KCkge1xuICBpZiAodHlwZW9mIENTUyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhQ1NTLnN1cHBvcnRzKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBDU1Muc3VwcG9ydHMoXCItd2Via2l0LWJhY2tkcm9wLWZpbHRlclwiLCBcIm5vbmVcIik7XG59XG5jb25zdCBsYXN0VHJhdmVyc2FibGVOb2RlTmFtZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJodG1sXCIsIFwiYm9keVwiLCBcIiNkb2N1bWVudFwiXSk7XG5mdW5jdGlvbiBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUobm9kZSkge1xuICByZXR1cm4gbGFzdFRyYXZlcnNhYmxlTm9kZU5hbWVzLmhhcyhnZXROb2RlTmFtZShub2RlKSk7XG59XG5mdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59XG5mdW5jdGlvbiBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpIHtcbiAgaWYgKGlzRWxlbWVudChlbGVtZW50KSkge1xuICAgIHJldHVybiB7XG4gICAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsWCxcbiAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsWVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShub2RlKSB7XG4gIGlmIChnZXROb2RlTmFtZShub2RlKSA9PT0gXCJodG1sXCIpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSAoXG4gICAgLy8gU3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGUuXG4gICAgbm9kZS5hc3NpZ25lZFNsb3QgfHwgLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWQuXG4gICAgbm9kZS5wYXJlbnROb2RlIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWQuXG4gICAgaXNTaGFkb3dSb290KG5vZGUpICYmIG5vZGUuaG9zdCB8fCAvLyBGYWxsYmFjay5cbiAgICBnZXREb2N1bWVudEVsZW1lbnQobm9kZSlcbiAgKTtcbiAgcmV0dXJuIGlzU2hhZG93Um9vdChyZXN1bHQpID8gcmVzdWx0Lmhvc3QgOiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKG5vZGUpO1xuICBpZiAoaXNMYXN0VHJhdmVyc2FibGVOb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudCA/IG5vZGUub3duZXJEb2N1bWVudC5ib2R5IDogbm9kZS5ib2R5O1xuICB9XG4gIGlmIChpc0hUTUxFbGVtZW50KHBhcmVudE5vZGUpICYmIGlzT3ZlcmZsb3dFbGVtZW50KHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKHBhcmVudE5vZGUpO1xufVxuZnVuY3Rpb24gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMobm9kZSwgbGlzdCwgdHJhdmVyc2VJZnJhbWVzKSB7XG4gIHZhciBfbm9kZSRvd25lckRvY3VtZW50MjtcbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuICBpZiAodHJhdmVyc2VJZnJhbWVzID09PSB2b2lkIDApIHtcbiAgICB0cmF2ZXJzZUlmcmFtZXMgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvciA9IGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKG5vZGUpO1xuICBjb25zdCBpc0JvZHkgPSBzY3JvbGxhYmxlQW5jZXN0b3IgPT09ICgoX25vZGUkb3duZXJEb2N1bWVudDIgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50Mi5ib2R5KTtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KHNjcm9sbGFibGVBbmNlc3Rvcik7XG4gIGlmIChpc0JvZHkpIHtcbiAgICBjb25zdCBmcmFtZUVsZW1lbnQgPSBnZXRGcmFtZUVsZW1lbnQod2luKTtcbiAgICByZXR1cm4gbGlzdC5jb25jYXQod2luLCB3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzT3ZlcmZsb3dFbGVtZW50KHNjcm9sbGFibGVBbmNlc3RvcikgPyBzY3JvbGxhYmxlQW5jZXN0b3IgOiBbXSwgZnJhbWVFbGVtZW50ICYmIHRyYXZlcnNlSWZyYW1lcyA/IGdldE92ZXJmbG93QW5jZXN0b3JzKGZyYW1lRWxlbWVudCkgOiBbXSk7XG4gIH1cbiAgcmV0dXJuIGxpc3QuY29uY2F0KHNjcm9sbGFibGVBbmNlc3RvciwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoc2Nyb2xsYWJsZUFuY2VzdG9yLCBbXSwgdHJhdmVyc2VJZnJhbWVzKSk7XG59XG5mdW5jdGlvbiBnZXRGcmFtZUVsZW1lbnQod2luKSB7XG4gIHJldHVybiB3aW4ucGFyZW50ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZih3aW4ucGFyZW50KSA/IHdpbi5mcmFtZUVsZW1lbnQgOiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0Q3NzRGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIGNvbnN0IGNzcyA9IGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KTtcbiAgbGV0IHdpZHRoID0gcGFyc2VGbG9hdChjc3Mud2lkdGgpIHx8IDA7XG4gIGxldCBoZWlnaHQgPSBwYXJzZUZsb2F0KGNzcy5oZWlnaHQpIHx8IDA7XG4gIGNvbnN0IGhhc09mZnNldCA9IGlzSFRNTEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IG9mZnNldFdpZHRoID0gaGFzT2Zmc2V0ID8gZWxlbWVudC5vZmZzZXRXaWR0aCA6IHdpZHRoO1xuICBjb25zdCBvZmZzZXRIZWlnaHQgPSBoYXNPZmZzZXQgPyBlbGVtZW50Lm9mZnNldEhlaWdodCA6IGhlaWdodDtcbiAgY29uc3Qgc2hvdWxkRmFsbGJhY2sgPSByb3VuZCh3aWR0aCkgIT09IG9mZnNldFdpZHRoIHx8IHJvdW5kKGhlaWdodCkgIT09IG9mZnNldEhlaWdodDtcbiAgaWYgKHNob3VsZEZhbGxiYWNrKSB7XG4gICAgd2lkdGggPSBvZmZzZXRXaWR0aDtcbiAgICBoZWlnaHQgPSBvZmZzZXRIZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgJDogc2hvdWxkRmFsbGJhY2tcbiAgfTtcbn1cbmZ1bmN0aW9uIHVud3JhcEVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gIWlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgOiBlbGVtZW50O1xufVxuZnVuY3Rpb24gZ2V0U2NhbGUoZWxlbWVudCkge1xuICBjb25zdCBkb21FbGVtZW50ID0gdW53cmFwRWxlbWVudChlbGVtZW50KTtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGRvbUVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvb3JkcygxKTtcbiAgfVxuICBjb25zdCByZWN0ID0gZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICAkXG4gIH0gPSBnZXRDc3NEaW1lbnNpb25zKGRvbUVsZW1lbnQpO1xuICBsZXQgeCA9ICgkID8gcm91bmQocmVjdC53aWR0aCkgOiByZWN0LndpZHRoKSAvIHdpZHRoO1xuICBsZXQgeSA9ICgkID8gcm91bmQocmVjdC5oZWlnaHQpIDogcmVjdC5oZWlnaHQpIC8gaGVpZ2h0O1xuICBpZiAoIXggfHwgIU51bWJlci5pc0Zpbml0ZSh4KSkge1xuICAgIHggPSAxO1xuICB9XG4gIGlmICgheSB8fCAhTnVtYmVyLmlzRmluaXRlKHkpKSB7XG4gICAgeSA9IDE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cbmNvbnN0IG5vT2Zmc2V0cyA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVDb29yZHMoMCk7XG5mdW5jdGlvbiBnZXRWaXN1YWxPZmZzZXRzKGVsZW1lbnQpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBpZiAoIWlzV2ViS2l0KCkgfHwgIXdpbi52aXN1YWxWaWV3cG9ydCkge1xuICAgIHJldHVybiBub09mZnNldHM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiB3aW4udmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdCxcbiAgICB5OiB3aW4udmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wXG4gIH07XG59XG5mdW5jdGlvbiBzaG91bGRBZGRWaXN1YWxPZmZzZXRzKGVsZW1lbnQsIGlzRml4ZWQsIGZsb2F0aW5nT2Zmc2V0UGFyZW50KSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cbiAgaWYgKCFmbG9hdGluZ09mZnNldFBhcmVudCB8fCBpc0ZpeGVkICYmIGZsb2F0aW5nT2Zmc2V0UGFyZW50ICE9PSBnZXRXaW5kb3coZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQ7XG59XG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3ksIG9mZnNldFBhcmVudCkge1xuICBpZiAoaW5jbHVkZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICBpbmNsdWRlU2NhbGUgPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgZG9tRWxlbWVudCA9IHVud3JhcEVsZW1lbnQoZWxlbWVudCk7XG4gIGxldCBzY2FsZSA9IGNyZWF0ZUNvb3JkcygxKTtcbiAgaWYgKGluY2x1ZGVTY2FsZSkge1xuICAgIGlmIChvZmZzZXRQYXJlbnQpIHtcbiAgICAgIGlmIChpc0VsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgICBzY2FsZSA9IGdldFNjYWxlKG9mZnNldFBhcmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gZ2V0U2NhbGUoZWxlbWVudCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHZpc3VhbE9mZnNldHMgPSBzaG91bGRBZGRWaXN1YWxPZmZzZXRzKGRvbUVsZW1lbnQsIGlzRml4ZWRTdHJhdGVneSwgb2Zmc2V0UGFyZW50KSA/IGdldFZpc3VhbE9mZnNldHMoZG9tRWxlbWVudCkgOiBjcmVhdGVDb29yZHMoMCk7XG4gIGxldCB4ID0gKGNsaWVudFJlY3QubGVmdCArIHZpc3VhbE9mZnNldHMueCkgLyBzY2FsZS54O1xuICBsZXQgeSA9IChjbGllbnRSZWN0LnRvcCArIHZpc3VhbE9mZnNldHMueSkgLyBzY2FsZS55O1xuICBsZXQgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGUueDtcbiAgbGV0IGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0IC8gc2NhbGUueTtcbiAgaWYgKGRvbUVsZW1lbnQpIHtcbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZG9tRWxlbWVudCk7XG4gICAgY29uc3Qgb2Zmc2V0V2luID0gb2Zmc2V0UGFyZW50ICYmIGlzRWxlbWVudChvZmZzZXRQYXJlbnQpID8gZ2V0V2luZG93KG9mZnNldFBhcmVudCkgOiBvZmZzZXRQYXJlbnQ7XG4gICAgbGV0IGN1cnJlbnRXaW4gPSB3aW47XG4gICAgbGV0IGN1cnJlbnRJRnJhbWUgPSBnZXRGcmFtZUVsZW1lbnQoY3VycmVudFdpbik7XG4gICAgd2hpbGUgKGN1cnJlbnRJRnJhbWUgJiYgb2Zmc2V0UGFyZW50ICYmIG9mZnNldFdpbiAhPT0gY3VycmVudFdpbikge1xuICAgICAgY29uc3QgaWZyYW1lU2NhbGUgPSBnZXRTY2FsZShjdXJyZW50SUZyYW1lKTtcbiAgICAgIGNvbnN0IGlmcmFtZVJlY3QgPSBjdXJyZW50SUZyYW1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY29uc3QgbGVmdCA9IGlmcmFtZVJlY3QubGVmdCArIChjdXJyZW50SUZyYW1lLmNsaWVudExlZnQgKyBwYXJzZUZsb2F0KGNzcy5wYWRkaW5nTGVmdCkpICogaWZyYW1lU2NhbGUueDtcbiAgICAgIGNvbnN0IHRvcCA9IGlmcmFtZVJlY3QudG9wICsgKGN1cnJlbnRJRnJhbWUuY2xpZW50VG9wICsgcGFyc2VGbG9hdChjc3MucGFkZGluZ1RvcCkpICogaWZyYW1lU2NhbGUueTtcbiAgICAgIHggKj0gaWZyYW1lU2NhbGUueDtcbiAgICAgIHkgKj0gaWZyYW1lU2NhbGUueTtcbiAgICAgIHdpZHRoICo9IGlmcmFtZVNjYWxlLng7XG4gICAgICBoZWlnaHQgKj0gaWZyYW1lU2NhbGUueTtcbiAgICAgIHggKz0gbGVmdDtcbiAgICAgIHkgKz0gdG9wO1xuICAgICAgY3VycmVudFdpbiA9IGdldFdpbmRvdyhjdXJyZW50SUZyYW1lKTtcbiAgICAgIGN1cnJlbnRJRnJhbWUgPSBnZXRGcmFtZUVsZW1lbnQoY3VycmVudFdpbik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50LCByZWN0KSB7XG4gIGNvbnN0IGxlZnRTY3JvbGwgPSBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG4gIGlmICghcmVjdCkge1xuICAgIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgbGVmdFNjcm9sbDtcbiAgfVxuICByZXR1cm4gcmVjdC5sZWZ0ICsgbGVmdFNjcm9sbDtcbn1cbmZ1bmN0aW9uIGdldEhUTUxPZmZzZXQoZG9jdW1lbnRFbGVtZW50LCBzY3JvbGwsIGlnbm9yZVNjcm9sbGJhclgpIHtcbiAgaWYgKGlnbm9yZVNjcm9sbGJhclggPT09IHZvaWQgMCkge1xuICAgIGlnbm9yZVNjcm9sbGJhclggPSBmYWxzZTtcbiAgfVxuICBjb25zdCBodG1sUmVjdCA9IGRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgeCA9IGh0bWxSZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIChpZ25vcmVTY3JvbGxiYXJYID8gMCA6IChcbiAgICAvLyBSVEwgPGJvZHk+IHNjcm9sbGJhci5cbiAgICBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCwgaHRtbFJlY3QpXG4gICkpO1xuICBjb25zdCB5ID0gaHRtbFJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcDtcbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50cyxcbiAgICByZWN0LFxuICAgIG9mZnNldFBhcmVudCxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgaXNGaXhlZCA9IHN0cmF0ZWd5ID09PSBcImZpeGVkXCI7XG4gIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCB0b3BMYXllciA9IGVsZW1lbnRzID8gaXNUb3BMYXllcihlbGVtZW50cy5mbG9hdGluZykgOiBmYWxzZTtcbiAgaWYgKG9mZnNldFBhcmVudCA9PT0gZG9jdW1lbnRFbGVtZW50IHx8IHRvcExheWVyICYmIGlzRml4ZWQpIHtcbiAgICByZXR1cm4gcmVjdDtcbiAgfVxuICBsZXQgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIGxldCBzY2FsZSA9IGNyZWF0ZUNvb3JkcygxKTtcbiAgY29uc3Qgb2Zmc2V0cyA9IGNyZWF0ZUNvb3JkcygwKTtcbiAgY29uc3QgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gXCJib2R5XCIgfHwgaXNPdmVyZmxvd0VsZW1lbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBjb25zdCBvZmZzZXRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG4gICAgICBzY2FsZSA9IGdldFNjYWxlKG9mZnNldFBhcmVudCk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfVxuICB9XG4gIGNvbnN0IGh0bWxPZmZzZXQgPSBkb2N1bWVudEVsZW1lbnQgJiYgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkID8gZ2V0SFRNTE9mZnNldChkb2N1bWVudEVsZW1lbnQsIHNjcm9sbCwgdHJ1ZSkgOiBjcmVhdGVDb29yZHMoMCk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHJlY3Qud2lkdGggKiBzY2FsZS54LFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHQgKiBzY2FsZS55LFxuICAgIHg6IHJlY3QueCAqIHNjYWxlLnggLSBzY3JvbGwuc2Nyb2xsTGVmdCAqIHNjYWxlLnggKyBvZmZzZXRzLnggKyBodG1sT2Zmc2V0LngsXG4gICAgeTogcmVjdC55ICogc2NhbGUueSAtIHNjcm9sbC5zY3JvbGxUb3AgKiBzY2FsZS55ICsgb2Zmc2V0cy55ICsgaHRtbE9mZnNldC55XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0cyhlbGVtZW50KSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKSk7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpO1xuICBjb25zdCBib2R5ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gIGNvbnN0IHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkuc2Nyb2xsV2lkdGgsIGJvZHkuY2xpZW50V2lkdGgpO1xuICBjb25zdCBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5LnNjcm9sbEhlaWdodCwgYm9keS5jbGllbnRIZWlnaHQpO1xuICBsZXQgeCA9IC1zY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIGNvbnN0IHkgPSAtc2Nyb2xsLnNjcm9sbFRvcDtcbiAgaWYgKGdldENvbXB1dGVkU3R5bGUkMShib2R5KS5kaXJlY3Rpb24gPT09IFwicnRsXCIpIHtcbiAgICB4ICs9IG1heChodG1sLmNsaWVudFdpZHRoLCBib2R5LmNsaWVudFdpZHRoKSAtIHdpZHRoO1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgY29uc3QgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIGxldCB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIGxldCBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0O1xuICAgIGNvbnN0IHZpc3VhbFZpZXdwb3J0QmFzZWQgPSBpc1dlYktpdCgpO1xuICAgIGlmICghdmlzdWFsVmlld3BvcnRCYXNlZCB8fCB2aXN1YWxWaWV3cG9ydEJhc2VkICYmIHN0cmF0ZWd5ID09PSBcImZpeGVkXCIpIHtcbiAgICAgIHggPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0O1xuICAgICAgeSA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5jb25zdCBhYnNvbHV0ZU9yRml4ZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJhYnNvbHV0ZVwiLCBcImZpeGVkXCJdKTtcbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgc3RyYXRlZ3kgPT09IFwiZml4ZWRcIik7XG4gIGNvbnN0IHRvcCA9IGNsaWVudFJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gIGNvbnN0IGxlZnQgPSBjbGllbnRSZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudExlZnQ7XG4gIGNvbnN0IHNjYWxlID0gaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldFNjYWxlKGVsZW1lbnQpIDogY3JlYXRlQ29vcmRzKDEpO1xuICBjb25zdCB3aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGggKiBzY2FsZS54O1xuICBjb25zdCBoZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjYWxlLnk7XG4gIGNvbnN0IHggPSBsZWZ0ICogc2NhbGUueDtcbiAgY29uc3QgeSA9IHRvcCAqIHNjYWxlLnk7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KSB7XG4gIGxldCByZWN0O1xuICBpZiAoY2xpcHBpbmdBbmNlc3RvciA9PT0gXCJ2aWV3cG9ydFwiKSB7XG4gICAgcmVjdCA9IGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSk7XG4gIH0gZWxzZSBpZiAoY2xpcHBpbmdBbmNlc3RvciA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgcmVjdCA9IGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpO1xuICB9IGVsc2UgaWYgKGlzRWxlbWVudChjbGlwcGluZ0FuY2VzdG9yKSkge1xuICAgIHJlY3QgPSBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdmlzdWFsT2Zmc2V0cyA9IGdldFZpc3VhbE9mZnNldHMoZWxlbWVudCk7XG4gICAgcmVjdCA9IHtcbiAgICAgIHg6IGNsaXBwaW5nQW5jZXN0b3IueCAtIHZpc3VhbE9mZnNldHMueCxcbiAgICAgIHk6IGNsaXBwaW5nQW5jZXN0b3IueSAtIHZpc3VhbE9mZnNldHMueSxcbiAgICAgIHdpZHRoOiBjbGlwcGluZ0FuY2VzdG9yLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjbGlwcGluZ0FuY2VzdG9yLmhlaWdodFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlY3RUb0NsaWVudFJlY3QocmVjdCk7XG59XG5mdW5jdGlvbiBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IoZWxlbWVudCwgc3RvcE5vZGUpIHtcbiAgY29uc3QgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIGlmIChwYXJlbnROb2RlID09PSBzdG9wTm9kZSB8fCAhaXNFbGVtZW50KHBhcmVudE5vZGUpIHx8IGlzTGFzdFRyYXZlcnNhYmxlTm9kZShwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZSQxKHBhcmVudE5vZGUpLnBvc2l0aW9uID09PSBcImZpeGVkXCIgfHwgaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKHBhcmVudE5vZGUsIHN0b3BOb2RlKTtcbn1cbmZ1bmN0aW9uIGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9ycyhlbGVtZW50LCBjYWNoZSkge1xuICBjb25zdCBjYWNoZWRSZXN1bHQgPSBjYWNoZS5nZXQoZWxlbWVudCk7XG4gIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICB9XG4gIGxldCByZXN1bHQgPSBnZXRPdmVyZmxvd0FuY2VzdG9ycyhlbGVtZW50LCBbXSwgZmFsc2UpLmZpbHRlcigoZWwpID0+IGlzRWxlbWVudChlbCkgJiYgZ2V0Tm9kZU5hbWUoZWwpICE9PSBcImJvZHlcIik7XG4gIGxldCBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IG51bGw7XG4gIGNvbnN0IGVsZW1lbnRJc0ZpeGVkID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpLnBvc2l0aW9uID09PSBcImZpeGVkXCI7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSA6IGVsZW1lbnQ7XG4gIHdoaWxlIChpc0VsZW1lbnQoY3VycmVudE5vZGUpICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUkMShjdXJyZW50Tm9kZSk7XG4gICAgY29uc3QgY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgPSBpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSk7XG4gICAgaWYgKCFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSBcImZpeGVkXCIpIHtcbiAgICAgIGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkRHJvcEN1cnJlbnROb2RlID0gZWxlbWVudElzRml4ZWQgPyAhY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlIDogIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmIGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09IFwic3RhdGljXCIgJiYgISFjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSAmJiBhYnNvbHV0ZU9yRml4ZWQuaGFzKGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlLnBvc2l0aW9uKSB8fCBpc092ZXJmbG93RWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmIGhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvcihlbGVtZW50LCBjdXJyZW50Tm9kZSk7XG4gICAgaWYgKHNob3VsZERyb3BDdXJyZW50Tm9kZSkge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LmZpbHRlcigoYW5jZXN0b3IpID0+IGFuY2VzdG9yICE9PSBjdXJyZW50Tm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgfVxuICBjYWNoZS5zZXQoZWxlbWVudCwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChfcmVmKSB7XG4gIGxldCB7XG4gICAgZWxlbWVudCxcbiAgICBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnksXG4gICAgc3RyYXRlZ3lcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGVsZW1lbnRDbGlwcGluZ0FuY2VzdG9ycyA9IGJvdW5kYXJ5ID09PSBcImNsaXBwaW5nQW5jZXN0b3JzXCIgPyBpc1RvcExheWVyKGVsZW1lbnQpID8gW10gOiBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMoZWxlbWVudCwgdGhpcy5fYykgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICBjb25zdCBjbGlwcGluZ0FuY2VzdG9ycyA9IFsuLi5lbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMsIHJvb3RCb3VuZGFyeV07XG4gIGNvbnN0IGZpcnN0Q2xpcHBpbmdBbmNlc3RvciA9IGNsaXBwaW5nQW5jZXN0b3JzWzBdO1xuICBjb25zdCBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ0FuY2VzdG9ycy5yZWR1Y2UoKGFjY1JlY3QsIGNsaXBwaW5nQW5jZXN0b3IpID0+IHtcbiAgICBjb25zdCByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgZmlyc3RDbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdCxcbiAgICBoZWlnaHQ6IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wLFxuICAgIHg6IGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIHk6IGNsaXBwaW5nUmVjdC50b3BcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERpbWVuc2lvbnMoZWxlbWVudCkge1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSBnZXRDc3NEaW1lbnNpb25zKGVsZW1lbnQpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQoZWxlbWVudCwgb2Zmc2V0UGFyZW50LCBzdHJhdGVneSkge1xuICBjb25zdCBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IGlzRml4ZWQgPSBzdHJhdGVneSA9PT0gXCJmaXhlZFwiO1xuICBjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHRydWUsIGlzRml4ZWQsIG9mZnNldFBhcmVudCk7XG4gIGxldCBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgY29uc3Qgb2Zmc2V0cyA9IGNyZWF0ZUNvb3JkcygwKTtcbiAgZnVuY3Rpb24gc2V0TGVmdFJUTFNjcm9sbGJhck9mZnNldCgpIHtcbiAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gIH1cbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSBcImJvZHlcIiB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCkge1xuICAgICAgY29uc3Qgb2Zmc2V0UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUsIGlzRml4ZWQsIG9mZnNldFBhcmVudCk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIHNldExlZnRSVExTY3JvbGxiYXJPZmZzZXQoKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRml4ZWQgJiYgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmIGRvY3VtZW50RWxlbWVudCkge1xuICAgIHNldExlZnRSVExTY3JvbGxiYXJPZmZzZXQoKTtcbiAgfVxuICBjb25zdCBodG1sT2Zmc2V0ID0gZG9jdW1lbnRFbGVtZW50ICYmICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCA/IGdldEhUTUxPZmZzZXQoZG9jdW1lbnRFbGVtZW50LCBzY3JvbGwpIDogY3JlYXRlQ29vcmRzKDApO1xuICBjb25zdCB4ID0gcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLnggLSBodG1sT2Zmc2V0Lng7XG4gIGNvbnN0IHkgPSByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnkgLSBodG1sT2Zmc2V0Lnk7XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzU3RhdGljUG9zaXRpb25lZChlbGVtZW50KSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkucG9zaXRpb24gPT09IFwic3RhdGljXCI7XG59XG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkucG9zaXRpb24gPT09IFwiZml4ZWRcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwb2x5ZmlsbCkge1xuICAgIHJldHVybiBwb2x5ZmlsbChlbGVtZW50KTtcbiAgfVxuICBsZXQgcmF3T2Zmc2V0UGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG4gIGlmIChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgPT09IHJhd09mZnNldFBhcmVudCkge1xuICAgIHJhd09mZnNldFBhcmVudCA9IHJhd09mZnNldFBhcmVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gIH1cbiAgcmV0dXJuIHJhd09mZnNldFBhcmVudDtcbn1cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50LCBwb2x5ZmlsbCkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGlmIChpc1RvcExheWVyKGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHdpbjtcbiAgfVxuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICBsZXQgc3ZnT2Zmc2V0UGFyZW50ID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgICB3aGlsZSAoc3ZnT2Zmc2V0UGFyZW50ICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoc3ZnT2Zmc2V0UGFyZW50KSkge1xuICAgICAgaWYgKGlzRWxlbWVudChzdmdPZmZzZXRQYXJlbnQpICYmICFpc1N0YXRpY1Bvc2l0aW9uZWQoc3ZnT2Zmc2V0UGFyZW50KSkge1xuICAgICAgICByZXR1cm4gc3ZnT2Zmc2V0UGFyZW50O1xuICAgICAgfVxuICAgICAgc3ZnT2Zmc2V0UGFyZW50ID0gZ2V0UGFyZW50Tm9kZShzdmdPZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gd2luO1xuICB9XG4gIGxldCBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKTtcbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGlzU3RhdGljUG9zaXRpb25lZChvZmZzZXRQYXJlbnQpKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQsIHBvbHlmaWxsKTtcbiAgfVxuICBpZiAob2Zmc2V0UGFyZW50ICYmIGlzTGFzdFRyYXZlcnNhYmxlTm9kZShvZmZzZXRQYXJlbnQpICYmIGlzU3RhdGljUG9zaXRpb25lZChvZmZzZXRQYXJlbnQpICYmICFpc0NvbnRhaW5pbmdCbG9jayhvZmZzZXRQYXJlbnQpKSB7XG4gICAgcmV0dXJuIHdpbjtcbiAgfVxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW47XG59XG5jb25zdCBnZXRFbGVtZW50UmVjdHMgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgZ2V0T2Zmc2V0UGFyZW50Rm4gPSB0aGlzLmdldE9mZnNldFBhcmVudCB8fCBnZXRPZmZzZXRQYXJlbnQ7XG4gICAgY29uc3QgZ2V0RGltZW5zaW9uc0ZuID0gdGhpcy5nZXREaW1lbnNpb25zO1xuICAgIGNvbnN0IGZsb2F0aW5nRGltZW5zaW9ucyA9IHlpZWxkIGdldERpbWVuc2lvbnNGbihkYXRhLmZsb2F0aW5nKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiBnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudChkYXRhLnJlZmVyZW5jZSwgeWllbGQgZ2V0T2Zmc2V0UGFyZW50Rm4oZGF0YS5mbG9hdGluZyksIGRhdGEuc3RyYXRlZ3kpLFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IGZsb2F0aW5nRGltZW5zaW9ucy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBmbG9hdGluZ0RpbWVuc2lvbnMuaGVpZ2h0XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59O1xuZnVuY3Rpb24gaXNSVEwoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpLmRpcmVjdGlvbiA9PT0gXCJydGxcIjtcbn1cbmNvbnN0IHBsYXRmb3JtID0ge1xuICBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCxcbiAgZ2V0RG9jdW1lbnRFbGVtZW50LFxuICBnZXRDbGlwcGluZ1JlY3QsXG4gIGdldE9mZnNldFBhcmVudCxcbiAgZ2V0RWxlbWVudFJlY3RzLFxuICBnZXRDbGllbnRSZWN0cyxcbiAgZ2V0RGltZW5zaW9ucyxcbiAgZ2V0U2NhbGUsXG4gIGlzRWxlbWVudCxcbiAgaXNSVExcbn07XG5mdW5jdGlvbiByZWN0c0FyZUVxdWFsKGEyLCBiKSB7XG4gIHJldHVybiBhMi54ID09PSBiLnggJiYgYTIueSA9PT0gYi55ICYmIGEyLndpZHRoID09PSBiLndpZHRoICYmIGEyLmhlaWdodCA9PT0gYi5oZWlnaHQ7XG59XG5mdW5jdGlvbiBvYnNlcnZlTW92ZShlbGVtZW50LCBvbk1vdmUpIHtcbiAgbGV0IGlvID0gbnVsbDtcbiAgbGV0IHRpbWVvdXRJZDtcbiAgY29uc3Qgcm9vdCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICB2YXIgX2lvO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIChfaW8gPSBpbykgPT0gbnVsbCB8fCBfaW8uZGlzY29ubmVjdCgpO1xuICAgIGlvID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiByZWZyZXNoKHNraXAsIHRocmVzaG9sZCkge1xuICAgIGlmIChza2lwID09PSB2b2lkIDApIHtcbiAgICAgIHNraXAgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRocmVzaG9sZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJlc2hvbGQgPSAxO1xuICAgIH1cbiAgICBjbGVhbnVwKCk7XG4gICAgY29uc3QgZWxlbWVudFJlY3RGb3JSb290TWFyZ2luID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB7XG4gICAgICBsZWZ0LFxuICAgICAgdG9wLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZWxlbWVudFJlY3RGb3JSb290TWFyZ2luO1xuICAgIGlmICghc2tpcCkge1xuICAgICAgb25Nb3ZlKCk7XG4gICAgfVxuICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbnNldFRvcCA9IGZsb29yKHRvcCk7XG4gICAgY29uc3QgaW5zZXRSaWdodCA9IGZsb29yKHJvb3QuY2xpZW50V2lkdGggLSAobGVmdCArIHdpZHRoKSk7XG4gICAgY29uc3QgaW5zZXRCb3R0b20gPSBmbG9vcihyb290LmNsaWVudEhlaWdodCAtICh0b3AgKyBoZWlnaHQpKTtcbiAgICBjb25zdCBpbnNldExlZnQgPSBmbG9vcihsZWZ0KTtcbiAgICBjb25zdCByb290TWFyZ2luID0gLWluc2V0VG9wICsgXCJweCBcIiArIC1pbnNldFJpZ2h0ICsgXCJweCBcIiArIC1pbnNldEJvdHRvbSArIFwicHggXCIgKyAtaW5zZXRMZWZ0ICsgXCJweFwiO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICByb290TWFyZ2luLFxuICAgICAgdGhyZXNob2xkOiBtYXgoMCwgbWluKDEsIHRocmVzaG9sZCkpIHx8IDFcbiAgICB9O1xuICAgIGxldCBpc0ZpcnN0VXBkYXRlID0gdHJ1ZTtcbiAgICBmdW5jdGlvbiBoYW5kbGVPYnNlcnZlKGVudHJpZXMpIHtcbiAgICAgIGNvbnN0IHJhdGlvID0gZW50cmllc1swXS5pbnRlcnNlY3Rpb25SYXRpbztcbiAgICAgIGlmIChyYXRpbyAhPT0gdGhyZXNob2xkKSB7XG4gICAgICAgIGlmICghaXNGaXJzdFVwZGF0ZSkge1xuICAgICAgICAgIHJldHVybiByZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyYXRpbykge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmVmcmVzaChmYWxzZSwgMWUtNyk7XG4gICAgICAgICAgfSwgMWUzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZyZXNoKGZhbHNlLCByYXRpbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyYXRpbyA9PT0gMSAmJiAhcmVjdHNBcmVFcXVhbChlbGVtZW50UmVjdEZvclJvb3RNYXJnaW4sIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpKSB7XG4gICAgICAgIHJlZnJlc2goKTtcbiAgICAgIH1cbiAgICAgIGlzRmlyc3RVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlvID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZU9ic2VydmUsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICAgIC8vIEhhbmRsZSA8aWZyYW1lPnNcbiAgICAgICAgcm9vdDogcm9vdC5vd25lckRvY3VtZW50XG4gICAgICB9KSk7XG4gICAgfSBjYXRjaCAoX2UyKSB7XG4gICAgICBpbyA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihoYW5kbGVPYnNlcnZlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaW8ub2JzZXJ2ZShlbGVtZW50KTtcbiAgfVxuICByZWZyZXNoKHRydWUpO1xuICByZXR1cm4gY2xlYW51cDtcbn1cbmZ1bmN0aW9uIGF1dG9VcGRhdGUocmVmZXJlbmNlLCBmbG9hdGluZywgdXBkYXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGFuY2VzdG9yU2Nyb2xsID0gdHJ1ZSxcbiAgICBhbmNlc3RvclJlc2l6ZSA9IHRydWUsXG4gICAgZWxlbWVudFJlc2l6ZSA9IHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gXCJmdW5jdGlvblwiLFxuICAgIGxheW91dFNoaWZ0ID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSBcImZ1bmN0aW9uXCIsXG4gICAgYW5pbWF0aW9uRnJhbWUgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcmVmZXJlbmNlRWwgPSB1bndyYXBFbGVtZW50KHJlZmVyZW5jZSk7XG4gIGNvbnN0IGFuY2VzdG9ycyA9IGFuY2VzdG9yU2Nyb2xsIHx8IGFuY2VzdG9yUmVzaXplID8gWy4uLnJlZmVyZW5jZUVsID8gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMocmVmZXJlbmNlRWwpIDogW10sIC4uLmdldE92ZXJmbG93QW5jZXN0b3JzKGZsb2F0aW5nKV0gOiBbXTtcbiAgYW5jZXN0b3JzLmZvckVhY2goKGFuY2VzdG9yKSA9PiB7XG4gICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB1cGRhdGUsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBhbmNlc3RvclJlc2l6ZSAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHVwZGF0ZSk7XG4gIH0pO1xuICBjb25zdCBjbGVhbnVwSW8gPSByZWZlcmVuY2VFbCAmJiBsYXlvdXRTaGlmdCA/IG9ic2VydmVNb3ZlKHJlZmVyZW5jZUVsLCB1cGRhdGUpIDogbnVsbDtcbiAgbGV0IHJlb2JzZXJ2ZUZyYW1lID0gLTE7XG4gIGxldCByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gIGlmIChlbGVtZW50UmVzaXplKSB7XG4gICAgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKF9yZWYpID0+IHtcbiAgICAgIGxldCBbZmlyc3RFbnRyeV0gPSBfcmVmO1xuICAgICAgaWYgKGZpcnN0RW50cnkgJiYgZmlyc3RFbnRyeS50YXJnZXQgPT09IHJlZmVyZW5jZUVsICYmIHJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgIHJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShmbG9hdGluZyk7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlb2JzZXJ2ZUZyYW1lKTtcbiAgICAgICAgcmVvYnNlcnZlRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHZhciBfcmVzaXplT2JzZXJ2ZXI7XG4gICAgICAgICAgKF9yZXNpemVPYnNlcnZlciA9IHJlc2l6ZU9ic2VydmVyKSA9PSBudWxsIHx8IF9yZXNpemVPYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB1cGRhdGUoKTtcbiAgICB9KTtcbiAgICBpZiAocmVmZXJlbmNlRWwgJiYgIWFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKHJlZmVyZW5jZUVsKTtcbiAgICB9XG4gICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShmbG9hdGluZyk7XG4gIH1cbiAgbGV0IGZyYW1lSWQ7XG4gIGxldCBwcmV2UmVmUmVjdCA9IGFuaW1hdGlvbkZyYW1lID8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZSkgOiBudWxsO1xuICBpZiAoYW5pbWF0aW9uRnJhbWUpIHtcbiAgICBmcmFtZUxvb3AoKTtcbiAgfVxuICBmdW5jdGlvbiBmcmFtZUxvb3AoKSB7XG4gICAgY29uc3QgbmV4dFJlZlJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKTtcbiAgICBpZiAocHJldlJlZlJlY3QgJiYgIXJlY3RzQXJlRXF1YWwocHJldlJlZlJlY3QsIG5leHRSZWZSZWN0KSkge1xuICAgICAgdXBkYXRlKCk7XG4gICAgfVxuICAgIHByZXZSZWZSZWN0ID0gbmV4dFJlZlJlY3Q7XG4gICAgZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZUxvb3ApO1xuICB9XG4gIHVwZGF0ZSgpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHZhciBfcmVzaXplT2JzZXJ2ZXIyO1xuICAgIGFuY2VzdG9ycy5mb3JFYWNoKChhbmNlc3RvcikgPT4ge1xuICAgICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB1cGRhdGUpO1xuICAgICAgYW5jZXN0b3JSZXNpemUgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB1cGRhdGUpO1xuICAgIH0pO1xuICAgIGNsZWFudXBJbyA9PSBudWxsIHx8IGNsZWFudXBJbygpO1xuICAgIChfcmVzaXplT2JzZXJ2ZXIyID0gcmVzaXplT2JzZXJ2ZXIpID09IG51bGwgfHwgX3Jlc2l6ZU9ic2VydmVyMi5kaXNjb25uZWN0KCk7XG4gICAgcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICAgIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgfVxuICB9O1xufVxuY29uc3Qgc2hpZnQgPSBzaGlmdCQxO1xuY29uc3QgZmxpcCA9IGZsaXAkMTtcbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IChyZWZlcmVuY2UsIGZsb2F0aW5nLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICBwbGF0Zm9ybVxuICB9LCBvcHRpb25zKTtcbiAgY29uc3QgcGxhdGZvcm1XaXRoQ2FjaGUgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBtZXJnZWRPcHRpb25zLnBsYXRmb3JtKSwge1xuICAgIF9jOiBjYWNoZVxuICB9KTtcbiAgcmV0dXJuIGNvbXB1dGVQb3NpdGlvbiQxKHJlZmVyZW5jZSwgZmxvYXRpbmcsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG1lcmdlZE9wdGlvbnMpLCB7XG4gICAgcGxhdGZvcm06IHBsYXRmb3JtV2l0aENhY2hlXG4gIH0pKTtcbn07XG5mdW5jdGlvbiBDKGwyLCB1MiwgZTIpIHtcbiAgbGV0IGMyID0gKCkgPT4ge1xuICAgIHZhciB0MjtcbiAgICByZXR1cm4gKHQyID0gZTIgPT0gbnVsbCA/IHZvaWQgMCA6IGUyLnBsYWNlbWVudCkgIT0gbnVsbCA/IHQyIDogXCJib3R0b21cIjtcbiAgfSwgZCA9ICgpID0+IHtcbiAgICB2YXIgdDI7XG4gICAgcmV0dXJuICh0MiA9IGUyID09IG51bGwgPyB2b2lkIDAgOiBlMi5zdHJhdGVneSkgIT0gbnVsbCA/IHQyIDogXCJhYnNvbHV0ZVwiO1xuICB9LCBbbjIsIG8yXSA9IGNyZWF0ZVNpZ25hbCh7IHg6IG51bGwsIHk6IG51bGwsIHBsYWNlbWVudDogYzIoKSwgc3RyYXRlZ3k6IGQoKSwgbWlkZGxld2FyZURhdGE6IHt9IH0pLCBbeCwgRl0gPSBjcmVhdGVTaWduYWwoKTtcbiAgY3JlYXRlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgdDIgPSB4KCk7XG4gICAgaWYgKHQyKSB0aHJvdyB0Mi52YWx1ZTtcbiAgfSk7XG4gIGxldCBzMiA9IGNyZWF0ZU1lbW8oKCkgPT4gKGwyKCksIHUyKCksIHt9KSk7XG4gIGZ1bmN0aW9uIG0oKSB7XG4gICAgbGV0IHQyID0gbDIoKSwgciA9IHUyKCk7XG4gICAgaWYgKHQyICYmIHIpIHtcbiAgICAgIGxldCBhMiA9IHMyKCk7XG4gICAgICBjb21wdXRlUG9zaXRpb24odDIsIHIsIHsgbWlkZGxld2FyZTogZTIgPT0gbnVsbCA/IHZvaWQgMCA6IGUyLm1pZGRsZXdhcmUsIHBsYWNlbWVudDogYzIoKSwgc3RyYXRlZ3k6IGQoKSB9KS50aGVuKChpMikgPT4ge1xuICAgICAgICBhMiA9PT0gczIoKSAmJiBvMihpMik7XG4gICAgICB9LCAoaTIpID0+IHtcbiAgICAgICAgRihpMik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IHQyID0gbDIoKSwgciA9IHUyKCk7XG4gICAgaWYgKGMyKCksIGQoKSwgdDIgJiYgcikgaWYgKGUyICE9IG51bGwgJiYgZTIud2hpbGVFbGVtZW50c01vdW50ZWQpIHtcbiAgICAgIGxldCBhMiA9IGUyLndoaWxlRWxlbWVudHNNb3VudGVkKHQyLCByLCBtKTtcbiAgICAgIGEyICYmIG9uQ2xlYW51cChhMik7XG4gICAgfSBlbHNlIG0oKTtcbiAgfSksIHsgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIG4yKCkueDtcbiAgfSwgZ2V0IHkoKSB7XG4gICAgcmV0dXJuIG4yKCkueTtcbiAgfSwgZ2V0IHBsYWNlbWVudCgpIHtcbiAgICByZXR1cm4gbjIoKS5wbGFjZW1lbnQ7XG4gIH0sIGdldCBzdHJhdGVneSgpIHtcbiAgICByZXR1cm4gbjIoKS5zdHJhdGVneTtcbiAgfSwgZ2V0IG1pZGRsZXdhcmVEYXRhKCkge1xuICAgIHJldHVybiBuMigpLm1pZGRsZXdhcmVEYXRhO1xuICB9LCB1cGRhdGU6IG0gfTtcbn1cbnZhciBfdG1wbCQkNCA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8dGMtcm9vdCBkYXRhLXRjLWRyb3Bkb3duLWNvbnRhaW5lcj10cnVlPmAsIHRydWUsIGZhbHNlLCBmYWxzZSk7XG5jb25zdCBBY2NvdW50QnV0dG9uID0gKCkgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IGNvbm5lY3RvciA9IHVzZUNvbnRleHQoQ29ubmVjdG9yQ29udGV4dCk7XG4gIGNvbnN0IHRvbkNvbm5lY3RVSSA9IHVzZUNvbnRleHQoVG9uQ29ubmVjdFVpQ29udGV4dCk7XG4gIGNvbnN0IFtpc09wZW5lZCwgc2V0SXNPcGVuZWRdID0gY3JlYXRlU2lnbmFsKGZhbHNlKTtcbiAgY29uc3QgW2FjY291bnQsIHNldEFjY291bnRdID0gY3JlYXRlU2lnbmFsKGNvbm5lY3Rvci5hY2NvdW50KTtcbiAgY29uc3QgW3Jlc3RvcmluZ1Byb2Nlc3MsIHNldFJlc3RvcmluZ1Byb2Nlc3NdID0gY3JlYXRlU2lnbmFsKCFjb25uZWN0b3IuYWNjb3VudCk7XG4gIGxldCBkcm9wRG93blJlZjtcbiAgY29uc3QgW2Zsb2F0aW5nLCBzZXRGbG9hdGluZ10gPSBjcmVhdGVTaWduYWwoKTtcbiAgY29uc3QgW2FuY2hvciwgc2V0QW5jaG9yXSA9IGNyZWF0ZVNpZ25hbCgpO1xuICBjb25zdCBwb3NpdGlvbiA9IEMoYW5jaG9yLCBmbG9hdGluZywge1xuICAgIHdoaWxlRWxlbWVudHNNb3VudGVkOiBhdXRvVXBkYXRlLFxuICAgIHBsYWNlbWVudDogXCJib3R0b20tZW5kXCIsXG4gICAgbWlkZGxld2FyZTogW2ZsaXAoKSwgc2hpZnQoKV1cbiAgfSk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRBZGRyZXNzID0gKCkgPT4ge1xuICAgIGNvbnN0IGFjYyA9IGFjY291bnQoKTtcbiAgICBpZiAoYWNjKSB7XG4gICAgICBjb25zdCB1c2VyRnJpZW5kbHlBZGRyZXNzID0gdG9Vc2VyRnJpZW5kbHlBZGRyZXNzKGFjYy5hZGRyZXNzLCBhY2MuY2hhaW4gPT09IENIQUlOLlRFU1RORVQpO1xuICAgICAgcmV0dXJuIHVzZXJGcmllbmRseUFkZHJlc3Muc2xpY2UoMCwgNCkgKyBcIuKAplwiICsgdXNlckZyaWVuZGx5QWRkcmVzcy5zbGljZSgtNCk7XG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xuICB9O1xuICB0b25Db25uZWN0VUkuY29ubmVjdGlvblJlc3RvcmVkLnRoZW4oKCkgPT4gc2V0UmVzdG9yaW5nUHJvY2VzcyhmYWxzZSkpO1xuICBjb25zdCB1bnN1YnNjcmliZSA9IGNvbm5lY3Rvci5vblN0YXR1c0NoYW5nZSgod2FsbGV0KSA9PiB7XG4gICAgaWYgKCF3YWxsZXQpIHtcbiAgICAgIHNldElzT3BlbmVkKGZhbHNlKTtcbiAgICAgIHNldEFjY291bnQobnVsbCk7XG4gICAgICBzZXRSZXN0b3JpbmdQcm9jZXNzKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0QWNjb3VudCh3YWxsZXQuYWNjb3VudCk7XG4gICAgc2V0UmVzdG9yaW5nUHJvY2VzcyhmYWxzZSk7XG4gIH0pO1xuICBjb25zdCBvbkNsaWNrID0gKGUyKSA9PiB7XG4gICAgaWYgKCFhY2NvdW50KCkgfHwgIWlzT3BlbmVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2xpY2tUb0J1dHRvbiA9IGFuY2hvcigpLmNvbnRhaW5zKGUyLnRhcmdldCk7XG4gICAgY29uc3QgY2xpY2tUb0Ryb3Bkb3duID0gZHJvcERvd25SZWYuY29udGFpbnMoZTIudGFyZ2V0KTtcbiAgICBpZiAoIWNsaWNrVG9CdXR0b24gJiYgIWNsaWNrVG9Ecm9wZG93bikge1xuICAgICAgc2V0SXNPcGVuZWQoZmFsc2UpO1xuICAgIH1cbiAgfTtcbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb25DbGljayk7XG4gIH0pO1xuICBvbkNsZWFudXAoKCkgPT4ge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uQ2xpY2spO1xuICAgIHVuc3Vic2NyaWJlKCk7XG4gIH0pO1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KER5bmFtaWMsIHtcbiAgICBjb21wb25lbnQ6IGdsb2JhbFN0eWxlc1RhZyxcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgIHJldHVybiByZXN0b3JpbmdQcm9jZXNzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KExvYWRlckJ1dHRvblN0eWxlZCQxLCB7XG4gICAgICAgICAgICBkaXNhYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIFwiZGF0YS10Yy1jb25uZWN0LWJ1dHRvbi1sb2FkaW5nXCI6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KExvYWRlckljb25TdHlsZWQkMSwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgcmV0dXJuICFyZXN0b3JpbmdQcm9jZXNzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICFhY2NvdW50KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEFjY291bnRCdXR0b25TdHlsZWQsIHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB0b25Db25uZWN0VUkub3Blbk1vZGFsKCksXG4gICAgICAgICAgICAgICAgXCJkYXRhLXRjLWNvbm5lY3QtYnV0dG9uXCI6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgICAgIHNjYWxlOiBcInNcIixcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChUb25JY29uLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCBmaWxsKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGVtZS5jb2xvcnMuY29ubmVjdEJ1dHRvbi5mb3JlZ3JvdW5kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwiYnV0dG9uLmNvbm5lY3RXYWxsZXRcIixcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IFwiMTVweFwiLFxuICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiBcIjE4cHhcIixcbiAgICAgICAgICAgICAgICAgICAgZm9udFdlaWdodDogXCI1OTBcIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGVtZS5jb2xvcnMuY29ubmVjdEJ1dHRvbi5mb3JlZ3JvdW5kO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJDb25uZWN0IHdhbGxldFwiXG4gICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gYWNjb3VudCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChEcm9wZG93bkNvbnRhaW5lclN0eWxlZCwge1xuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KERyb3Bkb3duQnV0dG9uU3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHNldElzT3BlbmVkKCh2KSA9PiAhdiksXG4gICAgICAgICAgICAgICAgICAgIHJlZjogc2V0QW5jaG9yLFxuICAgICAgICAgICAgICAgICAgICBcImRhdGEtdGMtZHJvcGRvd24tYnV0dG9uXCI6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBzY2FsZTogXCJzXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChUZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogXCIxNXB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiBcIjU5MFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodDogXCIxOHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkQWRkcmVzcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoQXJyb3dJY29uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IFwiYm90dG9tXCJcbiAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoUG9ydGFsLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgX2VsJCA9IF90bXBsJCQ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgdXNlKHNldEZsb2F0aW5nLCBfZWwkKTtcbiAgICAgICAgICAgICAgICAgICAgICBfZWwkLnN0eWxlLnNldFByb3BlcnR5KFwiei1pbmRleFwiLCBcIjk5OVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICBfZWwkLl8kb3duZXIgPSBnZXRPd25lcigpO1xuICAgICAgICAgICAgICAgICAgICAgIGluc2VydChfZWwkLCBjcmVhdGVDb21wb25lbnQoVHJhbnNpdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25CZWZvcmVFbnRlcjogKGVsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoZWwsIFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSgtOHB4KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVZKDApXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogMTUwXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXhpdDogKGVsLCBkb25lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGEyID0gYW5pbWF0ZShlbCwgW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVZKDApXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoLThweClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAxNTBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGEyLmZpbmlzaGVkLnRoZW4oZG9uZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc09wZW5lZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChEcm9wZG93blN0eWxlZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgaGlkZGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhaXNPcGVuZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbG9zZTogKCkgPT4gc2V0SXNPcGVuZWQoZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYociQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZiQgPSBkcm9wRG93blJlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgX3JlZiQgPT09IFwiZnVuY3Rpb25cIiA/IF9yZWYkKHIkKSA6IGRyb3BEb3duUmVmID0gciQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSksIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgIGluc2VydChfZWwkLCBjcmVhdGVDb21wb25lbnQoTm90aWZpY2F0aW9uc1N0eWxlZCwge30pLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKF9wJCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hMiwgX2IyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF92JCA9IHBvc2l0aW9uLnN0cmF0ZWd5LCBfdiQyID0gYCR7KF9hMiA9IHBvc2l0aW9uLnkpICE9IG51bGwgPyBfYTIgOiAwfXB4YCwgX3YkMyA9IGAkeyhfYjIgPSBwb3NpdGlvbi54KSAhPSBudWxsID8gX2IyIDogMH1weGA7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdiQgIT09IF9wJC5lICYmICgoX3AkLmUgPSBfdiQpICE9IG51bGwgPyBfZWwkLnN0eWxlLnNldFByb3BlcnR5KFwicG9zaXRpb25cIiwgX3YkKSA6IF9lbCQuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJwb3NpdGlvblwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdiQyICE9PSBfcCQudCAmJiAoKF9wJC50ID0gX3YkMikgIT0gbnVsbCA/IF9lbCQuc3R5bGUuc2V0UHJvcGVydHkoXCJ0b3BcIiwgX3YkMikgOiBfZWwkLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwidG9wXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF92JDMgIT09IF9wJC5hICYmICgoX3AkLmEgPSBfdiQzKSAhPSBudWxsID8gX2VsJC5zdHlsZS5zZXRQcm9wZXJ0eShcImxlZnRcIiwgX3YkMykgOiBfZWwkLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwibGVmdFwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3AkO1xuICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGU6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHQ6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGE6IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZWwkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KV07XG4gICAgICAgIH1cbiAgICAgIH0pXTtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IFN0eWxlZE1vZGFsID0gc3R5bGVkKE1vZGFsKWBcbiAgICBwYWRkaW5nLWxlZnQ6IDI0cHg7XG4gICAgcGFkZGluZy1yaWdodDogMjRweDtcbiAgICBwYWRkaW5nLXRvcDogMThweDtcbiAgICBwYWRkaW5nLWJvdHRvbTogMDtcblxuICAgICR7bWVkaWEoXCJtb2JpbGVcIil9IHtcbiAgICAgICAgcGFkZGluZy1sZWZ0OiAwO1xuICAgICAgICBwYWRkaW5nLXJpZ2h0OiAwO1xuICAgIH1cbmA7XG5jb25zdCBIMVN0eWxlZCRhID0gc3R5bGVkKEgxKWBcbiAgICBtYXJnaW4tdG9wOiAxMnB4O1xuXG4gICAgJHttZWRpYShcIm1vYmlsZVwiKX0ge1xuICAgICAgICBwYWRkaW5nOiAwIDEwcHg7XG4gICAgfVxuYDtcbmNvbnN0IExvYWRlckNvbnRhaW5lclN0eWxlZCA9IHN0eWxlZC5kaXZgXG4gICAgbWFyZ2luOiAzMHB4IDA7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblxuICAgICR7bWVkaWEoXCJtb2JpbGVcIil9IHtcbiAgICAgICAgaGVpZ2h0OiAxNjBweDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICB9XG5gO1xuc3R5bGVkKFRleHQpYFxuICAgIG1pbi13aWR0aDogODRweDtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgZm9udC13ZWlnaHQ6IDU5MDtcbmA7XG5zdHlsZWQoVGFiQmFyKWBcbiAgICBtYXJnaW46IDAgYXV0byAyMnB4O1xuYDtcbmNvbnN0IFthcHBTdGF0ZSwgc2V0QXBwU3RhdGVdID0gY3JlYXRlU3RvcmUoe1xuICBidXR0b25Sb290SWQ6IG51bGwsXG4gIGxhbmd1YWdlOiBcImVuXCIsXG4gIHJldHVyblN0cmF0ZWd5OiBcImJhY2tcIixcbiAgdHdhUmV0dXJuVXJsOiB2b2lkIDAsXG4gIHdhbGxldHNMaXN0Q29uZmlndXJhdGlvbjoge30sXG4gIGVuYWJsZUFuZHJvaWRCYWNrSGFuZGxlcjogdHJ1ZVxufSk7XG5mdW5jdGlvbiB1bmlxKGFycmF5KSB7XG4gIHJldHVybiBbLi4ubmV3IFNldChhcnJheSldO1xufVxuZnVuY3Rpb24gbWVyZ2VDb25jYXQoaWRLZXksIGFycmF5MSwgYXJyYXkyKSB7XG4gIHJldHVybiBhcnJheTEubWFwKChpdGVtMSkgPT4ge1xuICAgIGNvbnN0IGl0ZW0yID0gYXJyYXkyLmZpbmQoKGVsZW0pID0+IGVsZW1baWRLZXldID09PSBpdGVtMVtpZEtleV0pO1xuICAgIGFycmF5MiA9IGFycmF5Mi5maWx0ZXIoKGVsZW0pID0+IGVsZW1baWRLZXldICE9PSBpdGVtMVtpZEtleV0pO1xuICAgIHJldHVybiBpdGVtMiA9PT0gdm9pZCAwID8gaXRlbTEgOiBpdGVtMjtcbiAgfSkuY29uY2F0KGFycmF5Mik7XG59XG5mdW5jdGlvbiB1aVdhbGxldFRvV2FsbGV0SW5mbyh1aVdhbGxldCkge1xuICBpZiAoXCJqc0JyaWRnZUtleVwiIGluIHVpV2FsbGV0KSB7XG4gICAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHVpV2FsbGV0KSwge1xuICAgICAgaW5qZWN0ZWQ6IFRvbkNvbm5lY3QuaXNXYWxsZXRJbmplY3RlZCh1aVdhbGxldC5qc0JyaWRnZUtleSksXG4gICAgICBlbWJlZGRlZDogVG9uQ29ubmVjdC5pc0luc2lkZVdhbGxldEJyb3dzZXIodWlXYWxsZXQuanNCcmlkZ2VLZXkpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHVpV2FsbGV0O1xufVxuZnVuY3Rpb24gYXBwbHlXYWxsZXRzTGlzdENvbmZpZ3VyYXRpb24od2FsbGV0c0xpc3QsIGNvbmZpZ3VyYXRpb24pIHtcbiAgdmFyIF9hMjtcbiAgaWYgKCFjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHdhbGxldHNMaXN0O1xuICB9XG4gIGlmICgoX2EyID0gY29uZmlndXJhdGlvbi5pbmNsdWRlV2FsbGV0cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5sZW5ndGgpIHtcbiAgICB3YWxsZXRzTGlzdCA9IG1lcmdlQ29uY2F0KFxuICAgICAgXCJuYW1lXCIsXG4gICAgICB3YWxsZXRzTGlzdCxcbiAgICAgIGNvbmZpZ3VyYXRpb24uaW5jbHVkZVdhbGxldHMubWFwKHVpV2FsbGV0VG9XYWxsZXRJbmZvKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHdhbGxldHNMaXN0O1xufVxuZnVuY3Rpb24gc3VwcG9ydHNEZXNrdG9wKHdhbGxldEluZm8pIHtcbiAgcmV0dXJuIHdhbGxldEluZm8ucGxhdGZvcm1zLnNvbWUoKHcpID0+IFtcIm1hY29zXCIsIFwibGludXhcIiwgXCJ3aW5kb3dzXCJdLmluY2x1ZGVzKHcpKTtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzTW9iaWxlKHdhbGxldEluZm8pIHtcbiAgcmV0dXJuIHdhbGxldEluZm8ucGxhdGZvcm1zLnNvbWUoKHcpID0+IFtcImlvc1wiLCBcImFuZHJvaWRcIl0uaW5jbHVkZXModykpO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNFeHRlbnNpb24od2FsbGV0SW5mbykge1xuICByZXR1cm4gd2FsbGV0SW5mby5wbGF0Zm9ybXMuc29tZSgodykgPT4gW1wiY2hyb21lXCIsIFwiZmlyZWZveFwiLCBcInNhZmFyaVwiXS5pbmNsdWRlcyh3KSk7XG59XG5mdW5jdGlvbiBlcVdhbGxldE5hbWUod2FsbGV0MSwgbmFtZSkge1xuICBpZiAoIW5hbWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHdhbGxldDEubmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCkgfHwgd2FsbGV0MS5hcHBOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcbn1cbmNvbnN0IERlc2t0b3BTZWxlY3RXYWxsZXRNb2RhbFN0eWxlZCA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5gO1xuY29uc3QgSDFTdHlsZWQkOSA9IHN0eWxlZChIMSlgXG4gICAgbWFyZ2luLWJvdHRvbTogMThweDtcbmA7XG5zdHlsZWQuZGl2YFxuICAgIGhlaWdodDogMXB4O1xuICAgIG1hcmdpbjogMCAtMjRweDtcbiAgICB3aWR0aDogY2FsYygxMDAlICsgNDhweCk7XG4gICAgb3BhY2l0eTogMC4xMjtcbiAgICBiYWNrZ3JvdW5kOiAkeyhwcm9wcykgPT4gcHJvcHMuaXNTaG93biA/IHByb3BzLnRoZW1lLmNvbG9ycy5pY29uLnNlY29uZGFyeSA6IFwidHJhbnNwYXJlbnRcIn07XG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZCAwLjE1cyBlYXNlLWluLW91dDtcblxuICAgICR7bWVkaWEoXCJtb2JpbGVcIil9IHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgfVxuYDtcbmNvbnN0IFdhbGxldHNVbCA9IHN0eWxlZC51bGBcbiAgICBkaXNwbGF5OiBncmlkO1xuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KGF1dG8tZml0LCA5MnB4KTtcbiAgICBncmlkLXRlbXBsYXRlLXJvd3M6IGF1dG87XG4gICAgYWxpZ24tY29udGVudDogZmxleC1zdGFydDtcbiAgICByb3ctZ2FwOiA4cHg7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgcGFkZGluZzogMCAwIDE2cHg7XG4gICAgYWxpZ24tc2VsZjogZmxleC1zdGFydDtcbiAgICBtYXgtd2lkdGg6IDQwMHB4O1xuICAgIG1hcmdpbjogMCBhdXRvO1xuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG5cbiAgICA+IGxpIHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIGhlaWdodDogZml0LWNvbnRlbnQ7XG4gICAgfVxuXG4gICAgJHttZWRpYShcIm1vYmlsZVwiKX0ge1xuICAgICAgICBkaXNwbGF5OiBncmlkO1xuICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCg0LCAxZnIpO1xuICAgICAgICBnYXA6IDA7XG4gICAgICAgIHBhZGRpbmc6IDhweCAxMnB4IDE2cHg7XG4gICAgICAgIG1heC13aWR0aDogbm9uZTtcblxuICAgICAgICA+IGxpIHtcbiAgICAgICAgICAgIG1pbi13aWR0aDogNzhweDtcbiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIH1cblxuICAgICAgICA+IGxpID4gKiB7XG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5zdHlsZWQoQnV0dG9uKWBcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBtYXJnaW46IDAgYXV0byAxcHg7XG4gICAgZm9udC1zaXplOiAxNXB4O1xuYDtcbmNvbnN0IFN0eWxlZEljb25CdXR0b24kNSA9IHN0eWxlZChJY29uQnV0dG9uKWBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAxNnB4O1xuICAgIGxlZnQ6IDE2cHg7XG5gO1xuY29uc3QgV2FsbGV0TGFiZWxlZEl0ZW1TdHlsZWQgPSBzdHlsZWQoV2FsbGV0TGFiZWxlZEl0ZW0pYFxuICAgIG9wYWNpdHk6ICR7KHByb3BzKSA9PiBwcm9wcy53aXRoT3BhY2l0eSA/IFwiMC40XCIgOiBcIjFcIn07XG5gO1xuY29uc3QgV2FsbGV0c05vdFN1cHBvcnRlZE5vdGlmaWVyID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBncmlkO1xuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogYXV0byAyOHB4O1xuICAgIGdhcDogMTZweDtcbiAgICBwYWRkaW5nOiAxNnB4O1xuICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XG4gICAgYm9yZGVyLXJhZGl1czogMTZweDtcbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeX07XG4gICAgYmFja2dyb3VuZDogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnRpbnR9O1xuXG4gICAgJHttZWRpYShcIm1vYmlsZVwiKX0ge1xuICAgICAgICBtYXJnaW4tbGVmdDogMTZweDtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAxNnB4O1xuICAgIH1cbmA7XG5jb25zdCBXYWxsZXRzTm90U3VwcG9ydGVkTm90aWZpZXJUZXh0ID0gc3R5bGVkKEgyKWBcbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeX07XG4gICAgdGV4dC1hbGlnbjogbGVmdDtcbiAgICBtYXJnaW46IDA7XG5gO1xuY29uc3QgRXJyb3JCb3hTdHlsZWQgPSBzdHlsZWQuZGl2YFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBib3R0b206IDE0cHg7XG4gICAgbGVmdDogNTAlO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIDApO1xuXG4gICAgdGV4dC13cmFwOiBub3dyYXA7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBnYXA6IDZweDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGJvcmRlci1yYWRpdXM6IDE4cHg7XG4gICAgbWluLXdpZHRoOiAxMjZweDtcbiAgICBwYWRkaW5nOiA5cHggMTZweCA5cHggMTBweDtcblxuICAgIGZpbHRlcjogZHJvcC1zaGFkb3coMHB4IDJweCA4cHggcmdiYSgwLCAwLCAwLCAwLjA4KSk7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnNlZ21lbnR9O1xuYDtcbnZhciBfdG1wbCQkMyA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8c3ZnIHdpZHRoPTE2IGhlaWdodD0xNiB2aWV3Qm94PVwiMCAwIDE2IDE2XCJmaWxsPW5vbmUgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmc+PGcgY2xpcC1wYXRoPXVybCgjY2xpcDBfNTEyMl8xMDM1NSk+PGNpcmNsZSBjeD04IGN5PTggcj04PjwvY2lyY2xlPjxjaXJjbGUgY3g9OCBjeT0xMSByPTE+PC9jaXJjbGU+PHBhdGggZD1cIk03LjA0OTk0IDQuOTk4NzVDNy4wMjI3NyA0LjQ1NTQyIDcuNDU1OTggNCA4IDRDOC41NDQwMiA0IDguOTc3MjMgNC40NTU0MSA4Ljk1MDA2IDQuOTk4NzVMOC43ODc0NSA4LjI1MDk0QzguNzY2NDcgOC42NzA1NSA4LjQyMDE0IDkgOCA5QzcuNTc5ODYgOSA3LjIzMzUzIDguNjcwNTUgNy4yMTI1NSA4LjI1MDk0TDcuMDQ5OTQgNC45OTg3NVpcIj48L3BhdGg+PC9nPjxkZWZzPjxjbGlwUGF0aCBpZD1jbGlwMF81MTIyXzEwMzU1PjxyZWN0IHdpZHRoPTE2IGhlaWdodD0xNj5gKSwgX3RtcGwkMiQxID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcgd2lkdGg9MjggaGVpZ2h0PTI4IHZpZXdCb3g9XCIwIDAgMjggMjhcImZpbGw9bm9uZT48Y2lyY2xlIGN4PTE0IGN5PTE0IHI9MTI+PC9jaXJjbGU+PGNpcmNsZSBjeD0xNCBjeT0xOC45IHI9MS40PjwvY2lyY2xlPjxwYXRoIGQ9XCJNMTIuNjY1OCA4Ljg5ODQ1QzEyLjYzIDguMTM2OTggMTMuMjM3NyA3LjUgMTQgNy41QzE0Ljc2MjMgNy41IDE1LjM3IDguMTM2OTggMTUuMzM0MiA4Ljg5ODQ1TDE1LjA0NyAxNS4wMDEzQzE1LjAyMDcgMTUuNTYwNCAxNC41NTk3IDE2LjAwMDIgMTQgMTYuMDAwMkMxMy40NDAzIDE2LjAwMDIgMTIuOTc5MyAxNS41NjA0IDEyLjk1MyAxNS4wMDEzTDEyLjY2NTggOC44OTg0NVpcIj5gKTtcbmNvbnN0IEV4Y2xhbWF0aW9uSWNvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IHNpemUgPSAoKSA9PiBwcm9wcy5zaXplO1xuICBjb25zdCBmaWxsID0gKCkgPT4gcHJvcHMuZmlsbCB8fCB0aGVtZS5jb2xvcnMuaWNvbi5lcnJvcjtcbiAgcmV0dXJuIG1lbW8oKCkgPT4gbWVtbygoKSA9PiBzaXplKCkgPT09IFwiMTZcIikoKSA/ICgoKSA9PiB7XG4gICAgdmFyIF9lbCQgPSBfdG1wbCQkMygpLCBfZWwkMiA9IF9lbCQuZmlyc3RDaGlsZCwgX2VsJDMgPSBfZWwkMi5maXJzdENoaWxkLCBfZWwkNCA9IF9lbCQzLm5leHRTaWJsaW5nLCBfZWwkNSA9IF9lbCQ0Lm5leHRTaWJsaW5nLCBfZWwkNiA9IF9lbCQyLm5leHRTaWJsaW5nLCBfZWwkNyA9IF9lbCQ2LmZpcnN0Q2hpbGQsIF9lbCQ4ID0gX2VsJDcuZmlyc3RDaGlsZDtcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKF9wJCkgPT4ge1xuICAgICAgdmFyIF92JCA9IGZpbGwoKSwgX3YkMiA9IHRoZW1lLmNvbG9ycy5jb25zdGFudC53aGl0ZSwgX3YkMyA9IHRoZW1lLmNvbG9ycy5jb25zdGFudC53aGl0ZSwgX3YkNCA9IHRoZW1lLmNvbG9ycy5jb25zdGFudC53aGl0ZTtcbiAgICAgIF92JCAhPT0gX3AkLmUgJiYgc2V0QXR0cmlidXRlKF9lbCQzLCBcImZpbGxcIiwgX3AkLmUgPSBfdiQpO1xuICAgICAgX3YkMiAhPT0gX3AkLnQgJiYgc2V0QXR0cmlidXRlKF9lbCQ0LCBcImZpbGxcIiwgX3AkLnQgPSBfdiQyKTtcbiAgICAgIF92JDMgIT09IF9wJC5hICYmIHNldEF0dHJpYnV0ZShfZWwkNSwgXCJmaWxsXCIsIF9wJC5hID0gX3YkMyk7XG4gICAgICBfdiQ0ICE9PSBfcCQubyAmJiBzZXRBdHRyaWJ1dGUoX2VsJDgsIFwiZmlsbFwiLCBfcCQubyA9IF92JDQpO1xuICAgICAgcmV0dXJuIF9wJDtcbiAgICB9LCB7XG4gICAgICBlOiB2b2lkIDAsXG4gICAgICB0OiB2b2lkIDAsXG4gICAgICBhOiB2b2lkIDAsXG4gICAgICBvOiB2b2lkIDBcbiAgICB9KTtcbiAgICByZXR1cm4gX2VsJDtcbiAgfSkoKSA6IG1lbW8oKCkgPT4gc2l6ZSgpID09PSBcIjI4XCIpKCkgPyAoKCkgPT4ge1xuICAgIHZhciBfZWwkOSA9IF90bXBsJDIkMSgpLCBfZWwkMCA9IF9lbCQ5LmZpcnN0Q2hpbGQsIF9lbCQxID0gX2VsJDAubmV4dFNpYmxpbmcsIF9lbCQxMCA9IF9lbCQxLm5leHRTaWJsaW5nO1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoX3AkKSA9PiB7XG4gICAgICB2YXIgX3YkNSA9IHByb3BzLmNsYXNzLCBfdiQ2ID0gZmlsbCgpLCBfdiQ3ID0gdGhlbWUuY29sb3JzLmNvbnN0YW50LndoaXRlLCBfdiQ4ID0gdGhlbWUuY29sb3JzLmNvbnN0YW50LndoaXRlO1xuICAgICAgX3YkNSAhPT0gX3AkLmUgJiYgc2V0QXR0cmlidXRlKF9lbCQ5LCBcImNsYXNzXCIsIF9wJC5lID0gX3YkNSk7XG4gICAgICBfdiQ2ICE9PSBfcCQudCAmJiBzZXRBdHRyaWJ1dGUoX2VsJDAsIFwiZmlsbFwiLCBfcCQudCA9IF92JDYpO1xuICAgICAgX3YkNyAhPT0gX3AkLmEgJiYgc2V0QXR0cmlidXRlKF9lbCQxLCBcImZpbGxcIiwgX3AkLmEgPSBfdiQ3KTtcbiAgICAgIF92JDggIT09IF9wJC5vICYmIHNldEF0dHJpYnV0ZShfZWwkMTAsIFwiZmlsbFwiLCBfcCQubyA9IF92JDgpO1xuICAgICAgcmV0dXJuIF9wJDtcbiAgICB9LCB7XG4gICAgICBlOiB2b2lkIDAsXG4gICAgICB0OiB2b2lkIDAsXG4gICAgICBhOiB2b2lkIDAsXG4gICAgICBvOiB2b2lkIDBcbiAgICB9KTtcbiAgICByZXR1cm4gX2VsJDk7XG4gIH0pKCkgOiBudWxsKTtcbn07XG5jb25zdCBXQUxMRVRfQ09OTkVDVF9BUFBfTkFNRSA9IFwid2FsbGV0X2Nvbm5lY3RcIjtcbmNvbnN0IFdBTExFVF9DT05ORUNUX1dBTExFVF9OQU1FID0gXCJXYWxsZXRDb25uZWN0XCI7XG5jb25zdCBXQUxMRVRfQ09OTkVDVF9BQk9VVF9VUkwgPSBcImh0dHBzOi8vcmVvd24uY29tL1wiO1xudmFyIF90bXBsJCQyID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxsaT5gKTtcbmNvbnN0IEFsbFdhbGxldHNMaXN0TW9kYWwgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgbWF4SGVpZ2h0ID0gKCkgPT4gaXNNb2JpbGUoKSA/IHZvaWQgMCA6IDUxMDtcbiAgY29uc3QgY29ubmVjdG9yID0gYXBwU3RhdGUuY29ubmVjdG9yO1xuICBjb25zdCBhZGRpdGlvbmFsUmVxdWVzdCA9IGFwcFN0YXRlLmNvbm5lY3RSZXF1ZXN0UGFyYW1ldGVycztcbiAgY29uc3QgY29ubmVjdFdhbGxldENvbm5lY3QgPSAoKSA9PiB7XG4gICAgY29ubmVjdG9yLmNvbm5lY3Qoe1xuICAgICAgdHlwZTogXCJ3YWxsZXQtY29ubmVjdFwiXG4gICAgfSwgKGFkZGl0aW9uYWxSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBhZGRpdGlvbmFsUmVxdWVzdC5zdGF0ZSkgPT09IFwicmVhZHlcIiA/IGFkZGl0aW9uYWxSZXF1ZXN0LnZhbHVlIDogdm9pZCAwKTtcbiAgfTtcbiAgY29uc3QgW2Vycm9yU3VwcG9ydE9wZW5lZCwgc2V0RXJyb3JTdXBwb3J0T3BlbmVkXSA9IGNyZWF0ZVNpZ25hbChudWxsKTtcbiAgbGV0IHRpbWVvdXRJZCA9IG51bGw7XG4gIGNvbnN0IG9uRXJyb3JDbGljayA9ICh3YWxsZXQpID0+IHtcbiAgICBzZXRFcnJvclN1cHBvcnRPcGVuZWQod2FsbGV0KTtcbiAgICBpZiAodGltZW91dElkICE9IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH1cbiAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHNldEVycm9yU3VwcG9ydE9wZW5lZChudWxsKSwgMTUwMCk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZVNlbGVjdFdhbGxldCA9ICh3YWxsZXQpID0+IHtcbiAgICBpZiAoIXdhbGxldC5pc1N1cHBvcnRSZXF1aXJlZEZlYXR1cmVzICYmIHByb3BzLmZlYXR1cmVDaGVja01vZGUgPT09IFwic3RyaWN0XCIpIHtcbiAgICAgIG9uRXJyb3JDbGljayh3YWxsZXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwcm9wcy5vblNlbGVjdCh3YWxsZXQpO1xuICB9O1xuICBjb25zdCB3YWxsZXRzTGlzdCA9ICgpID0+IGlzTW9iaWxlKCkgPyBwcm9wcy53YWxsZXRzTGlzdC5maWx0ZXIoc3VwcG9ydHNNb2JpbGUpIDogcHJvcHMud2FsbGV0c0xpc3Q7XG4gIGNvbnN0IHN1cHBvcnRlZFdhbGxldHMgPSAoKSA9PiB3YWxsZXRzTGlzdCgpLmZpbHRlcigod2FsbGV0KSA9PiB3YWxsZXQuaXNTdXBwb3J0UmVxdWlyZWRGZWF0dXJlcyk7XG4gIHNldExhc3RWaXNpYmxlV2FsbGV0c0luZm8oe1xuICAgIHdhbGxldHNNZW51OiBcIm90aGVyX3dhbGxldHNcIixcbiAgICB3YWxsZXRzOiBzdXBwb3J0ZWRXYWxsZXRzKClcbiAgfSk7XG4gIGNvbnN0IHVuc3VwcG9ydGVkV2FsbGV0cyA9ICgpID0+IHdhbGxldHNMaXN0KCkuZmlsdGVyKCh3YWxsZXQpID0+ICF3YWxsZXQuaXNTdXBwb3J0UmVxdWlyZWRGZWF0dXJlcyk7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoRGVza3RvcFNlbGVjdFdhbGxldE1vZGFsU3R5bGVkLCB7XG4gICAgXCJkYXRhLXRjLXdhbGxldHMtbW9kYWwtbGlzdFwiOiBcInRydWVcIixcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTdHlsZWRJY29uQnV0dG9uJDUsIHtcbiAgICAgICAgaWNvbjogXCJhcnJvd1wiLFxuICAgICAgICBvbkNsaWNrOiAoKSA9PiBwcm9wcy5vbkJhY2soKVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChIMVN0eWxlZCQ5LCB7XG4gICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLndhbGxldHNcIixcbiAgICAgICAgY2hpbGRyZW46IFwiV2FsbGV0c1wiXG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNjcm9sbENvbnRhaW5lciwge1xuICAgICAgICBnZXQgbWF4SGVpZ2h0KCkge1xuICAgICAgICAgIHJldHVybiBtYXhIZWlnaHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFdhbGxldHNVbCwge1xuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChGb3IsIHtcbiAgICAgICAgICAgICAgICBnZXQgZWFjaCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzdXBwb3J0ZWRXYWxsZXRzKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogKHdhbGxldCkgPT4gKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIHZhciBfZWwkID0gX3RtcGwkJDIoKTtcbiAgICAgICAgICAgICAgICAgIGluc2VydChfZWwkLCBjcmVhdGVDb21wb25lbnQoV2FsbGV0TGFiZWxlZEl0ZW1TdHlsZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0LFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBwcm9wcy5vblNlbGVjdCh3YWxsZXQpXG4gICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2VsJDtcbiAgICAgICAgICAgICAgICB9KSgpXG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbW8oKCkgPT4gISEhaXNJblRNQSgpKSgpICYmIGlzV2FsbGV0Q29ubmVjdEluaXRpYWxpemVkKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFdhbGxldExhYmVsZWRJdGVtU3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCB3YWxsZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwid2FsbGV0LWNvbm5lY3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFdBTExFVF9DT05ORUNUX1dBTExFVF9OQU1FLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwTmFtZTogV0FMTEVUX0NPTk5FQ1RfQVBQX05BTUUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVVybDogSU1HLldBTExFVF9DT05ORUNUXG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogY29ubmVjdFdhbGxldENvbm5lY3RcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bnN1cHBvcnRlZFdhbGxldHMoKS5sZW5ndGggPiAwICYmIHByb3BzLmZlYXR1cmVDaGVja01vZGUgIT09IFwiaGlkZVwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoV2FsbGV0c05vdFN1cHBvcnRlZE5vdGlmaWVyLCB7XG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoV2FsbGV0c05vdFN1cHBvcnRlZE5vdGlmaWVyVGV4dCwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5hbGxXYWxsZXRzLndhbGxldHNCZWxvd05vdFN1cHBvcnRlZFwiLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJUaGUgd2FsbGV0cyBiZWxvdyBkb27igJl0IHN1cHBvcnQgYWxsIGZlYXR1cmVzIG9mIHRoZSBjb25uZWN0ZWQgc2VydmljZS4gWW91IGNhbiB1c2UgeW91ciByZWNvdmVyeSBwaHJhc2UgaW4gb25lIG9mIHRoZSBzdXBwb3J0ZWQgd2FsbGV0cyBhYm92ZS5cIlxuICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChFeGNsYW1hdGlvbkljb24sIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogXCIyOFwiXG4gICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFdhbGxldHNVbCwge1xuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoRm9yLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCBlYWNoKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bnN1cHBvcnRlZFdhbGxldHMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46ICh3YWxsZXQpID0+ICgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIF9lbCQyID0gX3RtcGwkJDIoKTtcbiAgICAgICAgICAgICAgICAgICAgICBpbnNlcnQoX2VsJDIsIGNyZWF0ZUNvbXBvbmVudChXYWxsZXRMYWJlbGVkSXRlbVN0eWxlZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FsbGV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gaGFuZGxlU2VsZWN0V2FsbGV0KHdhbGxldCksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2l0aE9wYWNpdHkoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy5mZWF0dXJlQ2hlY2tNb2RlID09PSBcInN0cmljdFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2VsJDI7XG4gICAgICAgICAgICAgICAgICAgIH0pKClcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChUcmFuc2l0aW9uLCB7XG4gICAgICAgICAgICAgICAgb25CZWZvcmVFbnRlcjogKGVsKSA9PiB7XG4gICAgICAgICAgICAgICAgICBhbmltYXRlKGVsLCBbe1xuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKC01MCUsIDQ0cHgpXCJcbiAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgtNTAlLCAwKVwiXG4gICAgICAgICAgICAgICAgICB9XSwge1xuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogMTUwLFxuICAgICAgICAgICAgICAgICAgICBlYXNpbmc6IFwiZWFzZS1vdXRcIlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkV4aXQ6IChlbCwgZG9uZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgYW5pbWF0ZShlbCwgW3tcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgtNTAlLCAwKVwiXG4gICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoLTUwJSwgNDRweClcIlxuICAgICAgICAgICAgICAgICAgfV0sIHtcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IDE1MCxcbiAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiBcImVhc2Utb3V0XCJcbiAgICAgICAgICAgICAgICAgIH0pLmZpbmlzaGVkLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JTdXBwb3J0T3BlbmVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEVycm9yQm94U3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KEVycm9ySWNvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IFwieHNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5hbGxXYWxsZXRzLndhbGxldE5vdFN1cHBvcnRTZXJ2aWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZXJyb3JTdXBwb3J0T3BlbmVkKCkubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWVtbygoKSA9PiBlcnJvclN1cHBvcnRPcGVuZWQoKS5uYW1lKSwgXCIgZG9lc27igJl0IHN1cHBvcnQgY29ubmVjdGVkIHNlcnZpY2VcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXTtcbiAgICAgICAgfVxuICAgICAgfSldO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3QgdGdCdXR0b25Cb3JkZXJzID0ge1xuICBtOiBcIjE2cHhcIixcbiAgczogXCIxMnB4XCIsXG4gIG5vbmU6IFwiMFwiXG59O1xuY29uc3QgdGdJY29uQm9yZGVycyA9IHtcbiAgbTogXCI2cHhcIixcbiAgczogXCI2cHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCBEZXNrdG9wQ29ubmVjdGlvbk1vZGFsU3R5bGVkID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5gO1xuY29uc3QgQm9keVN0eWxlZCQxID0gc3R5bGVkLmRpdmBcbiAgICBmbGV4OiAxO1xuICAgIG1hcmdpbi10b3A6ICR7KHByb3BzKSA9PiBwcm9wcy5xciA/IFwiMFwiIDogXCIxOHB4XCJ9O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIG1pbi1oZWlnaHQ6IDIzMnB4O1xuYDtcbmNvbnN0IFFSQ29kZVN0eWxlZCQxID0gc3R5bGVkKFFSQ29kZSlgXG4gICAgbWFyZ2luLWJvdHRvbTogMjRweDtcbmA7XG5jb25zdCBIMVN0eWxlZCQ4ID0gc3R5bGVkKEgxKWBcbiAgICBtYXgtd2lkdGg6IDI4OHB4O1xuICAgIG1hcmdpbjogMCBhdXRvIDJweDtcbmA7XG5jb25zdCBIMlN0eWxlZCQ0ID0gc3R5bGVkKEgyKWBcbiAgICBtYXgtd2lkdGg6IDI4OHB4O1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBtYXJnaW46IDAgYXV0byAyMHB4O1xuYDtcbmNvbnN0IFN0eWxlZEljb25CdXR0b24kNCA9IHN0eWxlZChJY29uQnV0dG9uKWBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAxNnB4O1xuICAgIGxlZnQ6IDE2cHg7XG5gO1xuY29uc3QgQnV0dG9uc0NvbnRhaW5lclN0eWxlZCQyID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGdhcDogOHB4O1xuICAgIHBhZGRpbmctYm90dG9tOiAxNnB4O1xuYDtcbmNvbnN0IEJvdHRvbUJ1dHRvbnNDb250YWluZXJTdHlsZWQgPSBzdHlsZWQoQnV0dG9uc0NvbnRhaW5lclN0eWxlZCQyKWBcbiAgICBwYWRkaW5nLWJvdHRvbTogMDtcbmA7XG5jb25zdCBGb290ZXJCdXR0b24kMSA9IHN0eWxlZChCdXR0b24pYFxuICAgIG1hcmdpbi1ib3R0b206IDI0cHg7XG5gO1xuY29uc3QgTG9hZGVyU3R5bGVkJDEgPSBzdHlsZWQoTG9hZGVySWNvbilgXG4gICAgbWFyZ2luLWJvdHRvbTogMThweDtcbiAgICBtYXJnaW4tdG9wOiAycHg7XG5gO1xuY29uc3QgRXJyb3JJY29uU3R5bGVkJDIgPSBzdHlsZWQoRXJyb3JJY29uKWBcbiAgICBtYXJnaW4tYm90dG9tOiAxNnB4O1xuYDtcbmNvbnN0IEJvZHlUZXh0U3R5bGVkJDIgPSBzdHlsZWQoSDIpYFxuICAgIGNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5fTtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgbWFyZ2luLWJvdHRvbTogMjBweDtcbmA7XG5jb25zdCBUZ0J1dHRvblN0eWxlZCA9IHN0eWxlZChCdXR0b24pYFxuICAgIG1hcmdpbi10b3A6IC04cHg7XG4gICAgbWFyZ2luLWJvdHRvbTogMjRweDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBwYWRkaW5nOiAxMnB4IDEycHggMTJweCAyMHB4O1xuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiB0Z0J1dHRvbkJvcmRlcnNbcHJvcHMudGhlbWUuYm9yZGVyUmFkaXVzXX07XG4gICAgZm9udC1zaXplOiAxNnB4O1xuICAgIGxpbmUtaGVpZ2h0OiAyMHB4O1xuYDtcbmNvbnN0IFRnSW1hZ2VTdHlsZWQgPSBzdHlsZWQoSW1hZ2UpYFxuICAgIHdpZHRoOiAzMnB4O1xuICAgIGhlaWdodDogMzJweDtcbiAgICBib3JkZXItcmFkaXVzOiAkeyhwcm9wcykgPT4gdGdJY29uQm9yZGVyc1twcm9wcy50aGVtZS5ib3JkZXJSYWRpdXNdfTtcbmA7XG5jb25zdCBUcmFuc2xhdGlvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCBbdDJdID0gdXNlSTE4bigpO1xuICByZXR1cm4gbWVtbygoKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICByZXR1cm4gdDIocHJvcHMudHJhbnNsYXRpb25LZXksIHByb3BzLnRyYW5zbGF0aW9uVmFsdWVzLCAoX2EyID0gcHJvcHMuY2hpbGRyZW4pID09IG51bGwgPyB2b2lkIDAgOiBfYTIudG9TdHJpbmcoKSk7XG4gIH0pO1xufTtcbmZ1bmN0aW9uIGFkZFJldHVyblN0cmF0ZWd5KHVybCwgc3RyYXRlZ3kpIHtcbiAgbGV0IHJldHVyblN0cmF0ZWd5O1xuICBpZiAodHlwZW9mIHN0cmF0ZWd5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuU3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm5TdHJhdGVneSA9IGlzSW5UTUEoKSA/IHN0cmF0ZWd5LnR3YVJldHVyblVybCB8fCBzdHJhdGVneS5yZXR1cm5TdHJhdGVneSA6IFwibm9uZVwiO1xuICB9XG4gIGNvbnN0IG5ld1VybCA9IGFkZFF1ZXJ5UGFyYW1ldGVyKHVybCwgXCJyZXRcIiwgcmV0dXJuU3RyYXRlZ3kpO1xuICBpZiAoIWlzVGVsZWdyYW1VcmwodXJsKSkge1xuICAgIHJldHVybiBuZXdVcmw7XG4gIH1cbiAgY29uc3QgbGFzdFBhcmFtID0gbmV3VXJsLnNsaWNlKG5ld1VybC5sYXN0SW5kZXhPZihcIiZcIikgKyAxKTtcbiAgcmV0dXJuIG5ld1VybC5zbGljZSgwLCBuZXdVcmwubGFzdEluZGV4T2YoXCImXCIpKSArIFwiLVwiICsgZW5jb2RlVGVsZWdyYW1VcmxQYXJhbWV0ZXJzKGxhc3RQYXJhbSk7XG59XG5mdW5jdGlvbiByZWRpcmVjdFRvVGVsZWdyYW0odW5pdmVyc2FsTGluaywgb3B0aW9ucykge1xuICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpO1xuICBjb25zdCBkaXJlY3RMaW5rID0gY29udmVydFRvVEdEaXJlY3RMaW5rKHVuaXZlcnNhbExpbmspO1xuICBjb25zdCBkaXJlY3RMaW5rVXJsID0gbmV3IFVSTChkaXJlY3RMaW5rKTtcbiAgaWYgKCFkaXJlY3RMaW5rVXJsLnNlYXJjaFBhcmFtcy5oYXMoXCJzdGFydGFwcFwiKSkge1xuICAgIGRpcmVjdExpbmtVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcInN0YXJ0YXBwXCIsIFwidG9uY29ubmVjdFwiKTtcbiAgfVxuICBpZiAoaXNJblRlbGVncmFtQnJvd3NlcigpKSB7XG4gICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwiYmFja1wiO1xuICAgIGNvbnN0IGxpbmtXaXRoU3RyYXRlZ3kgPSBhZGRSZXR1cm5TdHJhdGVneShcbiAgICAgIGRpcmVjdExpbmtVcmwudG9TdHJpbmcoKSxcbiAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3lcbiAgICApO1xuICAgIG9wZW5MaW5rQmxhbmsobGlua1dpdGhTdHJhdGVneSk7XG4gIH0gZWxzZSBpZiAoaXNJblRNQSgpKSB7XG4gICAgaWYgKGlzVG1hUGxhdGZvcm0oXCJpb3NcIiwgXCJhbmRyb2lkXCIsIFwibWFjb3NcIiwgXCJ0ZGVza3RvcFwiLCBcIndlYlwiKSkge1xuICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwiYmFja1wiO1xuICAgICAgY29uc3QgbGlua1dpdGhTdHJhdGVneSA9IGFkZFJldHVyblN0cmF0ZWd5KFxuICAgICAgICBkaXJlY3RMaW5rVXJsLnRvU3RyaW5nKCksXG4gICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3lcbiAgICAgICk7XG4gICAgICBzZW5kT3BlblRlbGVncmFtTGluayhsaW5rV2l0aFN0cmF0ZWd5KTtcbiAgICB9IGVsc2UgaWYgKGlzVG1hUGxhdGZvcm0oXCJ3ZWJhXCIpKSB7XG4gICAgICBzZW5kT3BlblRlbGVncmFtTGluayhhZGRSZXR1cm5TdHJhdGVneShkaXJlY3RMaW5rVXJsLnRvU3RyaW5nKCksIG9wdGlvbnMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3BlbkxpbmtCbGFuayhhZGRSZXR1cm5TdHJhdGVneShkaXJlY3RMaW5rVXJsLnRvU3RyaW5nKCksIG9wdGlvbnMpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzT1MoXCJpb3NcIikpIHtcbiAgICAgIGlmIChvcHRpb25zLnJldHVyblN0cmF0ZWd5ID09PSBcImJhY2tcIikge1xuICAgICAgICBpZiAoaXNCcm93c2VyKFwic2FmYXJpXCIpKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwiYmFja1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQnJvd3NlcihcImNocm9tZVwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcImdvb2dsZWNocm9tZTovL1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQnJvd3NlcihcImZpcmVmb3hcIikpIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJmaXJlZm94Oi8vXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKFwib3BlcmFcIikpIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJvcGVyYS1odHRwOi8vXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IGxvY2F0aW9uLmhyZWY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzQ2hyb21lID0gaXNCcm93c2VyKFwiY2hyb21lXCIpO1xuICAgICAgY29uc3QgaXNGaXJlZm94ID0gaXNCcm93c2VyKFwiZmlyZWZveFwiKTtcbiAgICAgIGNvbnN0IHVzZURlZXBMaW5rID0gKGlzQ2hyb21lIHx8IGlzRmlyZWZveCkgJiYgIW9wdGlvbnMuZm9yY2VSZWRpcmVjdDtcbiAgICAgIGlmICh1c2VEZWVwTGluaykge1xuICAgICAgICBjb25zdCBsaW5rV2l0aFN0cmF0ZWd5ID0gYWRkUmV0dXJuU3RyYXRlZ3koXG4gICAgICAgICAgZGlyZWN0TGlua1VybC50b1N0cmluZygpLFxuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3lcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgZGVlcExpbmsgPSBjb252ZXJ0VG9UR0RlZXBMaW5rKGxpbmtXaXRoU3RyYXRlZ3kpO1xuICAgICAgICBvcGVuRGVlcGxpbmtXaXRoRmFsbGJhY2soZGVlcExpbmssICgpID0+IG9wZW5MaW5rQmxhbmsobGlua1dpdGhTdHJhdGVneSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbGlua1dpdGhTdHJhdGVneSA9IGFkZFJldHVyblN0cmF0ZWd5KFxuICAgICAgICAgIGRpcmVjdExpbmtVcmwudG9TdHJpbmcoKSxcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5XG4gICAgICAgICk7XG4gICAgICAgIG9wZW5MaW5rQmxhbmsobGlua1dpdGhTdHJhdGVneSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc09TKFwiYW5kcm9pZFwiKSkge1xuICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwiYmFja1wiO1xuICAgICAgY29uc3QgaXNDaHJvbWUgPSBpc0Jyb3dzZXIoXCJjaHJvbWVcIik7XG4gICAgICBjb25zdCBpc0ZpcmVmb3ggPSBpc0Jyb3dzZXIoXCJmaXJlZm94XCIpO1xuICAgICAgY29uc3QgdXNlRGVlcExpbmsgPSAoaXNDaHJvbWUgfHwgaXNGaXJlZm94KSAmJiAhb3B0aW9ucy5mb3JjZVJlZGlyZWN0O1xuICAgICAgaWYgKHVzZURlZXBMaW5rKSB7XG4gICAgICAgIGNvbnN0IGxpbmtXaXRoU3RyYXRlZ3kgPSBhZGRSZXR1cm5TdHJhdGVneShcbiAgICAgICAgICBkaXJlY3RMaW5rVXJsLnRvU3RyaW5nKCksXG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBkZWVwTGluayA9IGNvbnZlcnRUb1RHRGVlcExpbmsobGlua1dpdGhTdHJhdGVneSk7XG4gICAgICAgIG9wZW5EZWVwbGlua1dpdGhGYWxsYmFjayhkZWVwTGluaywgKCkgPT4gb3BlbkxpbmtCbGFuayhsaW5rV2l0aFN0cmF0ZWd5KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsaW5rV2l0aFN0cmF0ZWd5ID0gYWRkUmV0dXJuU3RyYXRlZ3koXG4gICAgICAgICAgZGlyZWN0TGlua1VybC50b1N0cmluZygpLFxuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3lcbiAgICAgICAgKTtcbiAgICAgICAgb3BlbkxpbmtCbGFuayhsaW5rV2l0aFN0cmF0ZWd5KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzT1MoXCJpcGFkXCIpKSB7XG4gICAgICBpZiAob3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9PT0gXCJiYWNrXCIpIHtcbiAgICAgICAgaWYgKGlzQnJvd3NlcihcInNhZmFyaVwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcImJhY2tcIjtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jyb3dzZXIoXCJjaHJvbWVcIikpIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJnb29nbGVjaHJvbWU6Ly9cIjtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jyb3dzZXIoXCJmaXJlZm94XCIpKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwiZmlyZWZveDovL1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQnJvd3NlcihcIm9wZXJhXCIpKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwib3BlcmEtaHR0cDovL1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBsb2NhdGlvbi5ocmVmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBpc0Nocm9tZSA9IGlzQnJvd3NlcihcImNocm9tZVwiKTtcbiAgICAgIGNvbnN0IGlzRmlyZWZveCA9IGlzQnJvd3NlcihcImZpcmVmb3hcIik7XG4gICAgICBjb25zdCB1c2VEZWVwTGluayA9IChpc0Nocm9tZSB8fCBpc0ZpcmVmb3gpICYmICFvcHRpb25zLmZvcmNlUmVkaXJlY3Q7XG4gICAgICBjb25zdCBsaW5rV2l0aFN0cmF0ZWd5ID0gYWRkUmV0dXJuU3RyYXRlZ3koXG4gICAgICAgIGRpcmVjdExpbmtVcmwudG9TdHJpbmcoKSxcbiAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneVxuICAgICAgKTtcbiAgICAgIGlmICh1c2VEZWVwTGluaykge1xuICAgICAgICBjb25zdCBkZWVwTGluayA9IGNvbnZlcnRUb1RHRGVlcExpbmsobGlua1dpdGhTdHJhdGVneSk7XG4gICAgICAgIG9wZW5EZWVwbGlua1dpdGhGYWxsYmFjayhkZWVwTGluaywgKCkgPT4gb3BlbkxpbmtCbGFuayhsaW5rV2l0aFN0cmF0ZWd5KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcGVuTGlua0JsYW5rKGxpbmtXaXRoU3RyYXRlZ3kpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNPUyhcIm1hY29zXCIsIFwid2luZG93c1wiLCBcImxpbnV4XCIpKSB7XG4gICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJiYWNrXCI7XG4gICAgICBvcHRpb25zLnR3YVJldHVyblVybCA9IHZvaWQgMDtcbiAgICAgIGNvbnN0IGxpbmtXaXRoU3RyYXRlZ3kgPSBhZGRSZXR1cm5TdHJhdGVneShcbiAgICAgICAgZGlyZWN0TGlua1VybC50b1N0cmluZygpLFxuICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5XG4gICAgICApO1xuICAgICAgaWYgKG9wdGlvbnMuZm9yY2VSZWRpcmVjdCkge1xuICAgICAgICBvcGVuTGlua0JsYW5rKGxpbmtXaXRoU3RyYXRlZ3kpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGVlcExpbmsgPSBjb252ZXJ0VG9UR0RlZXBMaW5rKGxpbmtXaXRoU3RyYXRlZ3kpO1xuICAgICAgICBvcGVuRGVlcGxpbmtXaXRoRmFsbGJhY2soZGVlcExpbmssICgpID0+IG9wZW5MaW5rQmxhbmsobGlua1dpdGhTdHJhdGVneSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcGVuTGlua0JsYW5rKGFkZFJldHVyblN0cmF0ZWd5KGRpcmVjdExpbmtVcmwudG9TdHJpbmcoKSwgb3B0aW9ucykpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVkaXJlY3RUb1dhbGxldCh1bml2ZXJzYWxMaW5rLCBkZWVwTGluaywgb3B0aW9ucywgc2V0T3Blbk1ldGhvZCkge1xuICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpO1xuICBpZiAoaXNJblRlbGVncmFtQnJvd3NlcigpKSB7XG4gICAgaWYgKGlzT1MoXCJpb3NcIiwgXCJhbmRyb2lkXCIpKSB7XG4gICAgICBpZiAob3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9PT0gXCJiYWNrXCIpIHtcbiAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwidGc6Ly9yZXNvbHZlXCI7XG4gICAgICB9XG4gICAgICBzZXRPcGVuTWV0aG9kKFwidW5pdmVyc2FsLWxpbmtcIik7XG4gICAgICBvcGVuTGluayhhZGRSZXR1cm5TdHJhdGVneSh1bml2ZXJzYWxMaW5rLCBvcHRpb25zLnJldHVyblN0cmF0ZWd5KSwgXCJfc2VsZlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0T3Blbk1ldGhvZChcInVuaXZlcnNhbC1saW5rXCIpO1xuICAgICAgY29uc3QgbGlua1dpdGhTdHJhdGVneSA9IGFkZFJldHVyblN0cmF0ZWd5KHVuaXZlcnNhbExpbmssIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kpO1xuICAgICAgb3BlbkxpbmtCbGFuayhsaW5rV2l0aFN0cmF0ZWd5KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNJblRNQSgpKSB7XG4gICAgaWYgKGlzVG1hUGxhdGZvcm0oXCJpb3NcIiwgXCJhbmRyb2lkXCIpKSB7XG4gICAgICBpZiAob3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9PT0gXCJiYWNrXCIpIHtcbiAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwidGc6Ly9yZXNvbHZlXCI7XG4gICAgICB9XG4gICAgICBzZXRPcGVuTWV0aG9kKFwidW5pdmVyc2FsLWxpbmtcIik7XG4gICAgICBjb25zdCBsaW5rV2l0aFN0cmF0ZWd5ID0gYWRkUmV0dXJuU3RyYXRlZ3kodW5pdmVyc2FsTGluaywgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSk7XG4gICAgICBzZW5kT3BlblRlbGVncmFtTGluayhsaW5rV2l0aFN0cmF0ZWd5LCAoKSA9PiB7XG4gICAgICAgIHNldE9wZW5NZXRob2QoXCJ1bml2ZXJzYWwtbGlua1wiKTtcbiAgICAgICAgb3BlbkxpbmtCbGFuayhsaW5rV2l0aFN0cmF0ZWd5KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXNUbWFQbGF0Zm9ybShcIm1hY29zXCIsIFwidGRlc2t0b3BcIikpIHtcbiAgICAgIGlmIChvcHRpb25zLnJldHVyblN0cmF0ZWd5ID09PSBcImJhY2tcIikge1xuICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJ0ZzovL3Jlc29sdmVcIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbmtXaXRoU3RyYXRlZ3kgPSBhZGRSZXR1cm5TdHJhdGVneSh1bml2ZXJzYWxMaW5rLCBvcHRpb25zLnJldHVyblN0cmF0ZWd5KTtcbiAgICAgIGNvbnN0IHVzZURlZXBMaW5rID0gISFkZWVwTGluayAmJiAhb3B0aW9ucy5mb3JjZVJlZGlyZWN0O1xuICAgICAgaWYgKHVzZURlZXBMaW5rKSB7XG4gICAgICAgIHNldE9wZW5NZXRob2QoXCJjdXN0b20tZGVlcGxpbmtcIik7XG4gICAgICAgIG9wZW5EZWVwbGlua1dpdGhGYWxsYmFjayh0b0RlZXBsaW5rKGxpbmtXaXRoU3RyYXRlZ3ksIGRlZXBMaW5rKSwgKCkgPT4ge1xuICAgICAgICAgIHNldE9wZW5NZXRob2QoXCJ1bml2ZXJzYWwtbGlua1wiKTtcbiAgICAgICAgICBvcGVuTGlua0JsYW5rKGxpbmtXaXRoU3RyYXRlZ3kpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldE9wZW5NZXRob2QoXCJ1bml2ZXJzYWwtbGlua1wiKTtcbiAgICAgICAgb3BlbkxpbmtCbGFuayhsaW5rV2l0aFN0cmF0ZWd5KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVG1hUGxhdGZvcm0oXCJ3ZWJhXCIpKSB7XG4gICAgICBpZiAob3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9PT0gXCJiYWNrXCIpIHtcbiAgICAgICAgaWYgKGlzQnJvd3NlcihcInNhZmFyaVwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBsb2NhdGlvbi5ocmVmO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQnJvd3NlcihcImNocm9tZVwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcImdvb2dsZWNocm9tZTovL1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQnJvd3NlcihcImZpcmVmb3hcIikpIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJmaXJlZm94Oi8vXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKFwib3BlcmFcIikpIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJvcGVyYS1odHRwOi8vXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IGxvY2F0aW9uLmhyZWY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbmtXaXRoU3RyYXRlZ3kgPSBhZGRSZXR1cm5TdHJhdGVneSh1bml2ZXJzYWxMaW5rLCBvcHRpb25zLnJldHVyblN0cmF0ZWd5KTtcbiAgICAgIGNvbnN0IHVzZURlZXBMaW5rID0gISFkZWVwTGluayAmJiAhb3B0aW9ucy5mb3JjZVJlZGlyZWN0O1xuICAgICAgaWYgKHVzZURlZXBMaW5rKSB7XG4gICAgICAgIHNldE9wZW5NZXRob2QoXCJjdXN0b20tZGVlcGxpbmtcIik7XG4gICAgICAgIG9wZW5EZWVwbGlua1dpdGhGYWxsYmFjayh0b0RlZXBsaW5rKGxpbmtXaXRoU3RyYXRlZ3ksIGRlZXBMaW5rKSwgKCkgPT4ge1xuICAgICAgICAgIHNldE9wZW5NZXRob2QoXCJ1bml2ZXJzYWwtbGlua1wiKTtcbiAgICAgICAgICBvcGVuTGlua0JsYW5rKGxpbmtXaXRoU3RyYXRlZ3kpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldE9wZW5NZXRob2QoXCJ1bml2ZXJzYWwtbGlua1wiKTtcbiAgICAgICAgb3BlbkxpbmtCbGFuayhsaW5rV2l0aFN0cmF0ZWd5KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVG1hUGxhdGZvcm0oXCJ3ZWJcIikpIHtcbiAgICAgIGlmIChvcHRpb25zLnJldHVyblN0cmF0ZWd5ID09PSBcImJhY2tcIikge1xuICAgICAgICBpZiAoaXNCcm93c2VyKFwic2FmYXJpXCIpKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IGxvY2F0aW9uLmhyZWY7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKFwiY2hyb21lXCIpKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwiZ29vZ2xlY2hyb21lOi8vXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKFwiZmlyZWZveFwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcImZpcmVmb3g6Ly9cIjtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jyb3dzZXIoXCJvcGVyYVwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcIm9wZXJhLWh0dHA6Ly9cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gbG9jYXRpb24uaHJlZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbGlua1dpdGhTdHJhdGVneSA9IGFkZFJldHVyblN0cmF0ZWd5KHVuaXZlcnNhbExpbmssIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kpO1xuICAgICAgY29uc3QgdXNlRGVlcExpbmsgPSAhIWRlZXBMaW5rICYmICFvcHRpb25zLmZvcmNlUmVkaXJlY3Q7XG4gICAgICBpZiAodXNlRGVlcExpbmspIHtcbiAgICAgICAgc2V0T3Blbk1ldGhvZChcImN1c3RvbS1kZWVwbGlua1wiKTtcbiAgICAgICAgb3BlbkRlZXBsaW5rV2l0aEZhbGxiYWNrKHRvRGVlcGxpbmsobGlua1dpdGhTdHJhdGVneSwgZGVlcExpbmspLCAoKSA9PiB7XG4gICAgICAgICAgc2V0T3Blbk1ldGhvZChcInVuaXZlcnNhbC1saW5rXCIpO1xuICAgICAgICAgIG9wZW5MaW5rQmxhbmsobGlua1dpdGhTdHJhdGVneSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0T3Blbk1ldGhvZChcInVuaXZlcnNhbC1saW5rXCIpO1xuICAgICAgICBvcGVuTGlua0JsYW5rKGxpbmtXaXRoU3RyYXRlZ3kpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXRPcGVuTWV0aG9kKFwidW5pdmVyc2FsLWxpbmtcIik7XG4gICAgICBjb25zdCBsaW5rV2l0aFN0cmF0ZWd5ID0gYWRkUmV0dXJuU3RyYXRlZ3kodW5pdmVyc2FsTGluaywgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSk7XG4gICAgICBvcGVuTGlua0JsYW5rKGxpbmtXaXRoU3RyYXRlZ3kpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNPUyhcImlvc1wiKSkge1xuICAgICAgaWYgKG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPT09IFwiYmFja1wiKSB7XG4gICAgICAgIGlmIChpc0Jyb3dzZXIoXCJzYWZhcmlcIikpIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJub25lXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKFwiY2hyb21lXCIpKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwiZ29vZ2xlY2hyb21lOi8vXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKFwiZmlyZWZveFwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcImZpcmVmb3g6Ly9cIjtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jyb3dzZXIoXCJvcGVyYVwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcIm9wZXJhLWh0dHA6Ly9cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gbG9jYXRpb24uaHJlZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQnJvd3NlcihcImNocm9tZVwiKSkge1xuICAgICAgICBzZXRPcGVuTWV0aG9kKFwidW5pdmVyc2FsLWxpbmtcIik7XG4gICAgICAgIG9wZW5MaW5rKGFkZFJldHVyblN0cmF0ZWd5KHVuaXZlcnNhbExpbmssIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kpLCBcIl9zZWxmXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0T3Blbk1ldGhvZChcInVuaXZlcnNhbC1saW5rXCIpO1xuICAgICAgICBvcGVuTGlua0JsYW5rKGFkZFJldHVyblN0cmF0ZWd5KHVuaXZlcnNhbExpbmssIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzT1MoXCJhbmRyb2lkXCIpKSB7XG4gICAgICBpZiAob3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9PT0gXCJiYWNrXCIpIHtcbiAgICAgICAgaWYgKGlzQnJvd3NlcihcImNocm9tZVwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcImdvb2dsZWNocm9tZTovL1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQnJvd3NlcihcImZpcmVmb3hcIikpIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJmaXJlZm94Oi8vXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKFwib3BlcmFcIikpIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJvcGVyYS1odHRwOi8vXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IGxvY2F0aW9uLmhyZWY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldE9wZW5NZXRob2QoXCJ1bml2ZXJzYWwtbGlua1wiKTtcbiAgICAgIG9wZW5MaW5rQmxhbmsoYWRkUmV0dXJuU3RyYXRlZ3kodW5pdmVyc2FsTGluaywgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSkpO1xuICAgIH0gZWxzZSBpZiAoaXNPUyhcImlwYWRcIikpIHtcbiAgICAgIGlmIChvcHRpb25zLnJldHVyblN0cmF0ZWd5ID09PSBcImJhY2tcIikge1xuICAgICAgICBpZiAoaXNCcm93c2VyKFwic2FmYXJpXCIpKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwibm9uZVwiO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQnJvd3NlcihcImNocm9tZVwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcImdvb2dsZWNocm9tZTovL1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQnJvd3NlcihcImZpcmVmb3hcIikpIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJmaXJlZm94Oi8vXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKFwib3BlcmFcIikpIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJvcGVyYS1odHRwOi8vXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IGxvY2F0aW9uLmhyZWY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0Jyb3dzZXIoXCJjaHJvbWVcIikpIHtcbiAgICAgICAgc2V0T3Blbk1ldGhvZChcInVuaXZlcnNhbC1saW5rXCIpO1xuICAgICAgICBvcGVuTGluayhhZGRSZXR1cm5TdHJhdGVneSh1bml2ZXJzYWxMaW5rLCBvcHRpb25zLnJldHVyblN0cmF0ZWd5KSwgXCJfc2VsZlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldE9wZW5NZXRob2QoXCJ1bml2ZXJzYWwtbGlua1wiKTtcbiAgICAgICAgb3BlbkxpbmtCbGFuayhhZGRSZXR1cm5TdHJhdGVneSh1bml2ZXJzYWxMaW5rLCBvcHRpb25zLnJldHVyblN0cmF0ZWd5KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc09TKFwibWFjb3NcIiwgXCJ3aW5kb3dzXCIsIFwibGludXhcIikpIHtcbiAgICAgIGlmIChvcHRpb25zLnJldHVyblN0cmF0ZWd5ID09PSBcImJhY2tcIikge1xuICAgICAgICBpZiAoaXNCcm93c2VyKFwic2FmYXJpXCIpKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwibm9uZVwiO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQnJvd3NlcihcImNocm9tZVwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcImdvb2dsZWNocm9tZTovL1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQnJvd3NlcihcImZpcmVmb3hcIikpIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJmaXJlZm94Oi8vXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKFwib3BlcmFcIikpIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJvcGVyYS1odHRwOi8vXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwibm9uZVwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBsaW5rV2l0aFN0cmF0ZWd5ID0gYWRkUmV0dXJuU3RyYXRlZ3kodW5pdmVyc2FsTGluaywgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSk7XG4gICAgICBjb25zdCB1c2VEZWVwTGluayA9ICEhZGVlcExpbmsgJiYgIW9wdGlvbnMuZm9yY2VSZWRpcmVjdDtcbiAgICAgIGlmICh1c2VEZWVwTGluaykge1xuICAgICAgICBzZXRPcGVuTWV0aG9kKFwiY3VzdG9tLWRlZXBsaW5rXCIpO1xuICAgICAgICBvcGVuRGVlcGxpbmtXaXRoRmFsbGJhY2sodG9EZWVwbGluayhsaW5rV2l0aFN0cmF0ZWd5LCBkZWVwTGluayksICgpID0+IHtcbiAgICAgICAgICBzZXRPcGVuTWV0aG9kKFwidW5pdmVyc2FsLWxpbmtcIik7XG4gICAgICAgICAgb3BlbkxpbmtCbGFuayhsaW5rV2l0aFN0cmF0ZWd5KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRPcGVuTWV0aG9kKFwidW5pdmVyc2FsLWxpbmtcIik7XG4gICAgICAgIG9wZW5MaW5rQmxhbmsobGlua1dpdGhTdHJhdGVneSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldE9wZW5NZXRob2QoXCJ1bml2ZXJzYWwtbGlua1wiKTtcbiAgICAgIG9wZW5MaW5rQmxhbmsoYWRkUmV0dXJuU3RyYXRlZ3kodW5pdmVyc2FsTGluaywgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZW5yaWNoVW5pdmVyc2FsTGluayh1bml2ZXJzYWxMaW5rLCBwYXJhbXMpIHtcbiAgdmFyIF9hMiwgX2IyO1xuICBpZiAoIWlzVGVsZWdyYW1VcmwodW5pdmVyc2FsTGluaykpIHtcbiAgICByZXR1cm4gYWRkUXVlcnlQYXJhbWV0ZXJzSWZOb3RQcmVzZW50ZWQodW5pdmVyc2FsTGluaywge1xuICAgICAgaWQ6IHBhcmFtcy5zZXNzaW9uSWQsXG4gICAgICB0cmFjZV9pZDogcGFyYW1zLnRyYWNlSWRcbiAgICB9KTtcbiAgfVxuICBjb25zdCBkaXJlY3RMaW5rID0gY29udmVydFRvVEdEaXJlY3RMaW5rKHVuaXZlcnNhbExpbmspO1xuICBjb25zdCBkaXJlY3RMaW5rVXJsID0gbmV3IFVSTChkaXJlY3RMaW5rKTtcbiAgY29uc3QgcHJldmlvdXNTdGFydEFwcCA9IGRlY29kZVRlbGVncmFtVXJsUGFyYW1ldGVycyhcbiAgICAoX2EyID0gZGlyZWN0TGlua1VybC5zZWFyY2hQYXJhbXMuZ2V0KFwic3RhcnRhcHBcIikpICE9IG51bGwgPyBfYTIgOiBcIlwiXG4gICk7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBidWlsZFNlYXJjaFBhcmFtcyhwcmV2aW91c1N0YXJ0QXBwKTtcbiAgY29uc3Qgc2Vzc2lvbklkID0gKF9iMiA9IHBhcmFtcy5zZXNzaW9uSWQpICE9IG51bGwgPyBfYjIgOiBzZWFyY2hQYXJhbXMuZ2V0KFwiaWRcIik7XG4gIGNvbnN0IHRyYWNlSWQgPSBwYXJhbXMudHJhY2VJZDtcbiAgY29uc3Qgb3JkZXJlZEtleXMgPSBbXCJ0b25jb25uZWN0XCIsIFwidlwiLCBcImlkXCIsIFwidHJhY2VfaWRcIl07XG4gIGNvbnN0IHVub3JkZXJlZFBhcmFtcyA9IEFycmF5LmZyb20oc2VhcmNoUGFyYW1zLmVudHJpZXMoKSkuZmlsdGVyKFxuICAgIChba2V5XSkgPT4gIW9yZGVyZWRLZXlzLmluY2x1ZGVzKGtleSlcbiAgKTtcbiAgY29uc3Qgc3RhcnRBcHAgPSBidWlsZFF1ZXJ5UGFyYW1zKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe1xuICAgIHRvbmNvbm5lY3Q6IFwiXCIsXG4gICAgdjogXCIyXCIsXG4gICAgaWQ6IHNlc3Npb25JZFxuICB9LCBPYmplY3QuZnJvbUVudHJpZXModW5vcmRlcmVkUGFyYW1zKSksIHtcbiAgICB0cmFjZV9pZDogdHJhY2VJZFxuICB9KSkucmVwbGFjZShcIj0mXCIsIFwiJlwiKTtcbiAgZGlyZWN0TGlua1VybC5zZWFyY2hQYXJhbXMuc2V0KFwic3RhcnRhcHBcIiwgZW5jb2RlVGVsZWdyYW1VcmxQYXJhbWV0ZXJzKHN0YXJ0QXBwKSk7XG4gIHJldHVybiBkaXJlY3RMaW5rVXJsLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBhZGRRdWVyeVBhcmFtZXRlcih1cmwsIGtleSwgdmFsdWUpIHtcbiAgY29uc3QgcGFyc2VkID0gbmV3IFVSTCh1cmwpO1xuICBwYXJzZWQuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHBhcnNlZC50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gYWRkUXVlcnlQYXJhbWV0ZXJzSWZOb3RQcmVzZW50ZWQodXJsLCBwYXJhbXMpIHtcbiAgY29uc3QgcGFyc2VkID0gbmV3IFVSTCh1cmwpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbXMpKSB7XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDAgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHBhcnNlZC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyc2VkLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9UR0RpcmVjdExpbmsodW5pdmVyc2FsTGluaykge1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKHVuaXZlcnNhbExpbmspO1xuICBpZiAodXJsLnNlYXJjaFBhcmFtcy5oYXMoXCJhdHRhY2hcIikpIHtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShcImF0dGFjaFwiKTtcbiAgICB1cmwucGF0aG5hbWUgKz0gXCIvc3RhcnRcIjtcbiAgfVxuICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBidWlsZFNlYXJjaFBhcmFtcyhzZWFyY2ggPSBcIlwiKSB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoXCJodHRwczovL2V4YW1wbGUuY29tXCIpO1xuICB1cmwuc2VhcmNoID0gc2VhcmNoO1xuICByZXR1cm4gdXJsLnNlYXJjaFBhcmFtcztcbn1cbmZ1bmN0aW9uIGJ1aWxkUXVlcnlQYXJhbXMocGFyYW1zKSB7XG4gIGNvbnN0IHNlYXJjaFBhcmFtcyA9IGJ1aWxkU2VhcmNoUGFyYW1zKCk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtcykpIHtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlYXJjaFBhcmFtcy50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gY29udmVydFRvVEdEZWVwTGluayhkaXJlY3RMaW5rKSB7XG4gIGNvbnN0IHBhcnNlZCA9IG5ldyBVUkwoZGlyZWN0TGluayk7XG4gIGNvbnN0IFssIGRvbWFpbiwgYXBwbmFtZV0gPSBwYXJzZWQucGF0aG5hbWUuc3BsaXQoXCIvXCIpO1xuICBjb25zdCBzdGFydGFwcCA9IHBhcnNlZC5zZWFyY2hQYXJhbXMuZ2V0KFwic3RhcnRhcHBcIik7XG4gIHJldHVybiBgdGc6Ly9yZXNvbHZlP2RvbWFpbj0ke2RvbWFpbn0mYXBwbmFtZT0ke2FwcG5hbWV9JnN0YXJ0YXBwPSR7c3RhcnRhcHB9YDtcbn1cbmNvbnN0IERlc2t0b3BDb25uZWN0aW9uTW9kYWwgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgW21vZGUsIHNldE1vZGVdID0gY3JlYXRlU2lnbmFsKFwibW9iaWxlXCIpO1xuICBjb25zdCBbY29ubmVjdGlvbkVycm9yZWQsIHNldENvbm5lY3Rpb25FcnJvcmVkXSA9IGNyZWF0ZVNpZ25hbChudWxsKTtcbiAgY3JlYXRlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIHNldENvbm5lY3Rpb25FcnJvcmVkKChfYTIgPSBwcm9wcy5kZWZhdWx0RXJyb3IpICE9IG51bGwgPyBfYTIgOiBudWxsKTtcbiAgfSk7XG4gIGNvbnN0IFt1bml2ZXJzYWxMaW5rLCBzZXRVbml2ZXJzYWxMaW5rXSA9IGNyZWF0ZVNpZ25hbCgpO1xuICBjb25zdCBbZmlyc3RDbGljaywgc2V0Rmlyc3RDbGlja10gPSBjcmVhdGVTaWduYWwodHJ1ZSk7XG4gIGNvbnN0IGNvbm5lY3RvciA9IHVzZUNvbnRleHQoQ29ubmVjdG9yQ29udGV4dCk7XG4gIGNvbnN0IHVuc3Vic2NyaWJlID0gY29ubmVjdG9yLm9uU3RhdHVzQ2hhbmdlKCgpID0+IHtcbiAgfSwgKGVycm9yKSA9PiB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgV2FsbGV0TWlzc2luZ1JlcXVpcmVkRmVhdHVyZXNFcnJvcikge1xuICAgICAgc2V0Q29ubmVjdGlvbkVycm9yZWQoXCJtaXNzaW5nLWZlYXR1cmVzXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBXYWxsZXRXcm9uZ05ldHdvcmtFcnJvcikge1xuICAgICAgc2V0Q29ubmVjdGlvbkVycm9yZWQoXCJ3cm9uZy1uZXR3b3JrXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJvcHMud2FsbGV0LmFwcE5hbWUgIT09IEFUX1dBTExFVF9BUFBfTkFNRSkge1xuICAgICAgc2V0Q29ubmVjdGlvbkVycm9yZWQoXCJjb25uZWN0aW9uLWRlY2xpbmVkXCIpO1xuICAgIH1cbiAgfSk7XG4gIG9uQ2xlYW51cCh1bnN1YnNjcmliZSk7XG4gIGNvbnN0IGdlbmVyYXRlVW5pdmVyc2FsTGluayA9ICgpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1bml2ZXJzYWxMaW5rMiA9IGNvbm5lY3Rvci5jb25uZWN0KHtcbiAgICAgICAgdW5pdmVyc2FsTGluazogcHJvcHMud2FsbGV0LnVuaXZlcnNhbExpbmssXG4gICAgICAgIGJyaWRnZVVybDogcHJvcHMud2FsbGV0LmJyaWRnZVVybFxuICAgICAgfSwgcHJvcHMuYWRkaXRpb25hbFJlcXVlc3QsIHtcbiAgICAgICAgdHJhY2VJZDogKF9hMiA9IHByb3BzLndhbGxldHNNb2RhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnRyYWNlSWRcbiAgICAgIH0pO1xuICAgICAgc2V0VW5pdmVyc2FsTGluayh1bml2ZXJzYWxMaW5rMik7XG4gICAgfSBjYXRjaCAoZTIpIHtcbiAgICB9XG4gIH07XG4gIGNyZWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHVudHJhY2sobW9kZSkgIT09IFwiZXh0ZW5zaW9uXCIgJiYgKHN1cHBvcnRzTW9iaWxlKHByb3BzLndhbGxldCkgfHwgc3VwcG9ydHNEZXNrdG9wKHByb3BzLndhbGxldCkpKSB7XG4gICAgICBnZW5lcmF0ZVVuaXZlcnNhbExpbmsoKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBvbkNsaWNrTW9iaWxlID0gKCkgPT4ge1xuICAgIHNldENvbm5lY3Rpb25FcnJvcmVkKG51bGwpO1xuICAgIGlmIChtb2RlKCkgPT09IFwiZXh0ZW5zaW9uXCIpIHtcbiAgICAgIGdlbmVyYXRlVW5pdmVyc2FsTGluaygpO1xuICAgIH1cbiAgICBzZXRNb2RlKFwibW9iaWxlXCIpO1xuICAgIHNldExhc3RTZWxlY3RlZFdhbGxldEluZm8oX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMud2FsbGV0KSwge1xuICAgICAgb3Blbk1ldGhvZDogXCJxcmNvZGVcIlxuICAgIH0pKTtcbiAgfTtcbiAgY29uc3Qgb25DbGlja0Rlc2t0b3AgPSAoKSA9PiB7XG4gICAgc2V0Q29ubmVjdGlvbkVycm9yZWQobnVsbCk7XG4gICAgaWYgKG1vZGUoKSA9PT0gXCJleHRlbnNpb25cIikge1xuICAgICAgZ2VuZXJhdGVVbml2ZXJzYWxMaW5rKCk7XG4gICAgfVxuICAgIHNldE1vZGUoXCJkZXNrdG9wXCIpO1xuICAgIGlmIChpc1RlbGVncmFtVXJsKHVuaXZlcnNhbExpbmsoKSkpIHtcbiAgICAgIG9uQ2xpY2tUZWxlZ3JhbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmb3JjZVJlZGlyZWN0ID0gIWZpcnN0Q2xpY2soKTtcbiAgICAgIHNldEZpcnN0Q2xpY2soZmFsc2UpO1xuICAgICAgcmVkaXJlY3RUb1dhbGxldCh1bml2ZXJzYWxMaW5rKCksIHByb3BzLndhbGxldC5kZWVwTGluaywge1xuICAgICAgICByZXR1cm5TdHJhdGVneTogYXBwU3RhdGUucmV0dXJuU3RyYXRlZ3ksXG4gICAgICAgIGZvcmNlUmVkaXJlY3RcbiAgICAgIH0sIChtZXRob2QpID0+IHtcbiAgICAgICAgc2V0TGFzdFNlbGVjdGVkV2FsbGV0SW5mbyhfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcm9wcy53YWxsZXQpLCB7XG4gICAgICAgICAgb3Blbk1ldGhvZDogbWV0aG9kXG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgb25DbGlja1RlbGVncmFtID0gKCkgPT4ge1xuICAgIGNvbnN0IGZvcmNlUmVkaXJlY3QgPSAhZmlyc3RDbGljaygpO1xuICAgIHNldEZpcnN0Q2xpY2soZmFsc2UpO1xuICAgIHNldExhc3RTZWxlY3RlZFdhbGxldEluZm8oX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMud2FsbGV0KSwge1xuICAgICAgb3Blbk1ldGhvZDogXCJ1bml2ZXJzYWwtbGlua1wiXG4gICAgfSkpO1xuICAgIHJlZGlyZWN0VG9UZWxlZ3JhbSh1bml2ZXJzYWxMaW5rKCksIHtcbiAgICAgIHJldHVyblN0cmF0ZWd5OiBhcHBTdGF0ZS5yZXR1cm5TdHJhdGVneSxcbiAgICAgIHR3YVJldHVyblVybDogYXBwU3RhdGUudHdhUmV0dXJuVXJsLFxuICAgICAgZm9yY2VSZWRpcmVjdFxuICAgIH0pO1xuICB9O1xuICBjb25zdCBvbkNsaWNrRXh0ZW5zaW9uID0gKCkgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgc2V0Q29ubmVjdGlvbkVycm9yZWQobnVsbCk7XG4gICAgc2V0TW9kZShcImV4dGVuc2lvblwiKTtcbiAgICBpZiAoaXNXYWxsZXRJbmZvQ3VycmVudGx5SW5qZWN0ZWQocHJvcHMud2FsbGV0KSkge1xuICAgICAgc2V0TGFzdFNlbGVjdGVkV2FsbGV0SW5mbyhwcm9wcy53YWxsZXQpO1xuICAgICAgY29ubmVjdG9yLmNvbm5lY3Qoe1xuICAgICAgICBqc0JyaWRnZUtleTogcHJvcHMud2FsbGV0LmpzQnJpZGdlS2V5XG4gICAgICB9LCBwcm9wcy5hZGRpdGlvbmFsUmVxdWVzdCwge1xuICAgICAgICB0cmFjZUlkOiAoX2EyID0gcHJvcHMud2FsbGV0c01vZGFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIudHJhY2VJZFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBpZiAoc3VwcG9ydHNNb2JpbGUocHJvcHMud2FsbGV0KSkge1xuICAgIG9uQ2xpY2tNb2JpbGUoKTtcbiAgfSBlbHNlIGlmIChzdXBwb3J0c0V4dGVuc2lvbihwcm9wcy53YWxsZXQpKSB7XG4gICAgb25DbGlja0V4dGVuc2lvbigpO1xuICB9IGVsc2Uge1xuICAgIG9uQ2xpY2tEZXNrdG9wKCk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChEZXNrdG9wQ29ubmVjdGlvbk1vZGFsU3R5bGVkLCB7XG4gICAgXCJkYXRhLXRjLXdhbGxldHMtbW9kYWwtY29ubmVjdGlvbi1kZXNrdG9wXCI6IFwidHJ1ZVwiLFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgcmV0dXJuICFwcm9wcy5iYWNrRGlzYWJsZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFN0eWxlZEljb25CdXR0b24kNCwge1xuICAgICAgICAgICAgaWNvbjogXCJhcnJvd1wiLFxuICAgICAgICAgICAgb25DbGljazogKCkgPT4gcHJvcHMub25CYWNrQ2xpY2soKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEgxU3R5bGVkJDgsIHtcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wcy53YWxsZXQubmFtZTtcbiAgICAgICAgfVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgIHJldHVybiBtZW1vKCgpID0+IG1vZGUoKSA9PT0gXCJtb2JpbGVcIikoKSAmJiAhY29ubmVjdGlvbkVycm9yZWQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoSDJTdHlsZWQkNCwge1xuICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwuZGVza3RvcENvbm5lY3Rpb25Nb2RhbC5zY2FuUVJcIixcbiAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwcm9wcy53YWxsZXQubmFtZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtcIlNjYW4gdGhlIFFSIGNvZGUgYmVsb3cgd2l0aCB5b3VyIHBob25l4oCZcyBvciBcIiwgbWVtbygoKSA9PiBwcm9wcy53YWxsZXQubmFtZSksIFwi4oCZcyBjYW1lcmFcIl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoQm9keVN0eWxlZCQxLCB7XG4gICAgICAgIGdldCBxcigpIHtcbiAgICAgICAgICByZXR1cm4gbW9kZSgpID09PSBcIm1vYmlsZVwiO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChTd2l0Y2gsIHtcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uRXJyb3JlZCgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoRXJyb3JJY29uU3R5bGVkJDIsIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogXCJzXCJcbiAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU3dpdGNoLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uRXJyb3JlZCgpID09PSBcIm1pc3NpbmctZmVhdHVyZXNcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQm9keVRleHRTdHlsZWQkMiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmRlc2t0b3BDb25uZWN0aW9uTW9kYWwubWlzc2luZ0ZlYXR1cmVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcHJvcHMud2FsbGV0Lm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJQbGVhc2UgdXBkYXRlIFdhbGxldCwgeW91ciB2ZXJzaW9uIGRvZXMgbm90IHN1cHBvcnQgcmVxdWlyZWQgZmVhdHVyZXMgZm9yIHRoaXMgZEFwcFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbkVycm9yZWQoKSA9PT0gXCJjb25uZWN0aW9uLWRlY2xpbmVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEJvZHlUZXh0U3R5bGVkJDIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5kZXNrdG9wQ29ubmVjdGlvbk1vZGFsLmNvbm5lY3Rpb25EZWNsaW5lZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkNvbm5lY3Rpb24gZGVjbGluZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25FcnJvcmVkKCkgPT09IFwibm90LXN1cHBvcnRlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChCb2R5VGV4dFN0eWxlZCQyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwuZGVza3RvcENvbm5lY3Rpb25Nb2RhbC5ub3RTdXBwb3J0ZWRXYWxsZXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgdHJhbnNsYXRpb25WYWx1ZXMoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwcm9wcy53YWxsZXQubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWVtbygoKSA9PiBwcm9wcy53YWxsZXQubmFtZSksIFwiIGRvZXNu4oCZdCBzdXBwb3J0IHRoZSByZXF1ZXN0ZWQgYWN0aW9uLiBQbGVhc2UgY29ubmVjdCBhbm90aGVyIHdhbGxldCB0aGF0IHN1cHBvcnRzIGl0LlwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbkVycm9yZWQoKSA9PT0gXCJ3cm9uZy1uZXR3b3JrXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEJvZHlUZXh0U3R5bGVkJDIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5kZXNrdG9wQ29ubmVjdGlvbk1vZGFsLndyb25nTmV0d29ya1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHByb3BzLndhbGxldC5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcIkNvbm5lY3RlZCB3YWxsZXQgaXMgb24gYSBkaWZmZXJlbnQgbmV0d29yay4gUGxlYXNlIHN3aXRjaCBuZXR3b3JrIGluIFwiLCBtZW1vKCgpID0+IHByb3BzLndhbGxldC5uYW1lKSwgXCIgYW5kIHRyeSBhZ2Fpbi5cIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoQnV0dG9uc0NvbnRhaW5lclN0eWxlZCQyLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25FcnJvcmVkKCkgIT09IFwibm90LXN1cHBvcnRlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChCdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgbGVmdEljb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFJldHJ5SWNvbiwge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IG9uQ2xpY2soKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9kZSgpID09PSBcImV4dGVuc2lvblwiID8gb25DbGlja0V4dGVuc2lvbiA6IG9uQ2xpY2tEZXNrdG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJjb21tb24ucmV0cnlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiUmV0cnlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbkVycm9yZWQoKSA9PT0gXCJtaXNzaW5nLWZlYXR1cmVzXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KExpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgaHJlZigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy53YWxsZXQuYWJvdXRVcmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibGFuazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgbGVmdEljb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChMaW5rSWNvbiwge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwuZGVza3RvcENvbm5lY3Rpb25Nb2RhbC51cGRhdGVXYWxsZXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwcm9wcy53YWxsZXQubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcIlVwZGF0ZSBcIiwgbWVtbygoKSA9PiBwcm9wcy53YWxsZXQubmFtZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uRXJyb3JlZCgpID09PSBcIm5vdC1zdXBwb3J0ZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQnV0dG9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gcHJvcHMub25CYWNrQ2xpY2soKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmRlc2t0b3BDb25uZWN0aW9uTW9kYWwuY2hvb3NlQW5vdGhlcldhbGxldFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJDaG9vc2UgQW5vdGhlciBXYWxsZXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtb2RlKCkgPT09IFwibW9iaWxlXCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFFSQ29kZVN0eWxlZCQxLCB7XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVDb3B5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0IHNvdXJjZVVybCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkUmV0dXJuU3RyYXRlZ3kodW5pdmVyc2FsTGluaygpLCBcIm5vbmVcIik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldCBpbWFnZVVybCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMud2FsbGV0LmltYWdlVXJsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtb2RlKCkgPT09IFwiZXh0ZW5zaW9uXCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1dhbGxldEluZm9DdXJyZW50bHlJbmplY3RlZChwcm9wcy53YWxsZXQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoTG9hZGVyU3R5bGVkJDEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IFwic1wiXG4gICAgICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChCb2R5VGV4dFN0eWxlZCQyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5kZXNrdG9wQ29ubmVjdGlvbk1vZGFsLmNvbnRpbnVlSW5FeHRlbnNpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwcm9wcy53YWxsZXQubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcIkNvbnRpbnVlIGluIFwiLCBtZW1vKCgpID0+IHByb3BzLndhbGxldC5uYW1lKSwgXCIgYnJvd3NlciBleHRlbnNpb27igKZcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChCdXR0b25zQ29udGFpbmVyU3R5bGVkJDIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChCdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgbGVmdEljb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFJldHJ5SWNvbiwge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogb25DbGlja0V4dGVuc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcImNvbW1vbi5yZXRyeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJSZXRyeVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhaXNXYWxsZXRJbmZvQ3VycmVudGx5SW5qZWN0ZWQocHJvcHMud2FsbGV0KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KEJvZHlUZXh0U3R5bGVkJDIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmRlc2t0b3BDb25uZWN0aW9uTW9kYWwuZG9udEhhdmVFeHRlbnNpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwcm9wcy53YWxsZXQubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcIlNlZW1zIHlvdSBkb24ndCBoYXZlIGluc3RhbGxlZCBcIiwgbWVtbygoKSA9PiBwcm9wcy53YWxsZXQubmFtZSksIFwiIGJyb3dzZXIgZXh0ZW5zaW9uXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoQnV0dG9uc0NvbnRhaW5lclN0eWxlZCQyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoTGluaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBocmVmKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLndhbGxldC5hYm91dFVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsYW5rOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQnV0dG9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCByaWdodEljb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChMaW5rSWNvbiwge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBvbkNsaWNrRXh0ZW5zaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwuZGVza3RvcENvbm5lY3Rpb25Nb2RhbC5nZXRXYWxsZXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwcm9wcy53YWxsZXQubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcIkdldCBcIiwgbWVtbygoKSA9PiBwcm9wcy53YWxsZXQubmFtZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZGUoKSA9PT0gXCJkZXNrdG9wXCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChMb2FkZXJJY29uLCB7XG4gICAgICAgICAgICAgICAgICAgIHNpemU6IFwibVwiXG4gICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEJvZHlUZXh0U3R5bGVkJDIsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwuZGVza3RvcENvbm5lY3Rpb25Nb2RhbC5jb250aW51ZU9uRGVza3RvcFwiLFxuICAgICAgICAgICAgICAgICAgICBnZXQgdHJhbnNsYXRpb25WYWx1ZXMoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHByb3BzLndhbGxldC5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJDb250aW51ZSBpbiBcIiwgbWVtbygoKSA9PiBwcm9wcy53YWxsZXQubmFtZSksIFwiIG9uIGRlc2t0b3DigKZcIl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoQnV0dG9uc0NvbnRhaW5lclN0eWxlZCQyLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChCdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBsZWZ0SWNvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChSZXRyeUljb24sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBvbkNsaWNrRGVza3RvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcImNvbW1vbi5yZXRyeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlJldHJ5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChMaW5rLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgaHJlZigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLndhbGxldC5hYm91dFVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBibGFuazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChCdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgcmlnaHRJY29uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChMaW5rSWNvbiwge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5kZXNrdG9wQ29ubmVjdGlvbk1vZGFsLmdldFdhbGxldFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgdHJhbnNsYXRpb25WYWx1ZXMoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHByb3BzLndhbGxldC5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJHZXQgXCIsIG1lbW8oKCkgPT4gcHJvcHMud2FsbGV0Lm5hbWUpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wcy53YWxsZXQuYXBwTmFtZSA9PT0gQVRfV0FMTEVUX0FQUF9OQU1FO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUZ0J1dHRvblN0eWxlZCwge1xuICAgICAgICAgICAgZ2V0IHJpZ2h0SWNvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUZ0ltYWdlU3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgZ2V0IHNyYygpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBJTUcuVEc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY2FsZTogXCJzXCIsXG4gICAgICAgICAgICBvbkNsaWNrOiBvbkNsaWNrVGVsZWdyYW0sXG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNsYXRpb24sIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5kZXNrdG9wQ29ubmVjdGlvbk1vZGFsLm9wZW5XYWxsZXRPblRlbGVncmFtXCIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiT3BlbiBXYWxsZXQgaW4gVGVsZWdyYW0gb24gZGVza3RvcFwiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLndhbGxldC5hcHBOYW1lICE9PSBBVF9XQUxMRVRfQVBQX05BTUU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEJvdHRvbUJ1dHRvbnNDb250YWluZXJTdHlsZWQsIHtcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbW8oKCkgPT4gbW9kZSgpICE9PSBcIm1vYmlsZVwiKSgpICYmIHN1cHBvcnRzTW9iaWxlKHByb3BzLndhbGxldCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEZvb3RlckJ1dHRvbiQxLCB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGVhcmFuY2U6IFwic2Vjb25kYXJ5XCIsXG4gICAgICAgICAgICAgICAgICAgIGdldCBsZWZ0SWNvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KE1vYmlsZUljb24sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogb25DbGlja01vYmlsZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNsYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcImNvbW1vbi5tb2JpbGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIk1vYmlsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbWVtbygoKSA9PiBtb2RlKCkgIT09IFwiZXh0ZW5zaW9uXCIpKCkgJiYgc3VwcG9ydHNFeHRlbnNpb24ocHJvcHMud2FsbGV0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoRm9vdGVyQnV0dG9uJDEsIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwZWFyYW5jZTogXCJzZWNvbmRhcnlcIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGxlZnRJY29uKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQnJvd3Nlckljb24sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogb25DbGlja0V4dGVuc2lvbixcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNsYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcImNvbW1vbi5icm93c2VyRXh0ZW5zaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJCcm93c2VyIEV4dGVuc2lvblwiXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbWVtbygoKSA9PiBtb2RlKCkgIT09IFwiZGVza3RvcFwiKSgpICYmIHN1cHBvcnRzRGVza3RvcChwcm9wcy53YWxsZXQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChGb290ZXJCdXR0b24kMSwge1xuICAgICAgICAgICAgICAgICAgICBhcHBlYXJhbmNlOiBcInNlY29uZGFyeVwiLFxuICAgICAgICAgICAgICAgICAgICBnZXQgbGVmdEljb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChEZXNrdG9wSWNvbiwge30pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBvbkNsaWNrRGVza3RvcCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNsYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcImNvbW1vbi5kZXNrdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJEZXNrdG9wXCJcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pXTtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IEluZm9Nb2RhbFN0eWxlZCA9IHN0eWxlZC5kaXZgYDtcbmNvbnN0IFN0eWxlZEljb25CdXR0b24kMyA9IHN0eWxlZChJY29uQnV0dG9uKWBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAxNnB4O1xuICAgIGxlZnQ6IDE2cHg7XG5gO1xuY29uc3QgSDFTdHlsZWQkNyA9IHN0eWxlZChIMSlgXG4gICAgbWFyZ2luLWJvdHRvbTogMThweDtcbmA7XG5jb25zdCBJbmZvQmxvY2sgPSBzdHlsZWQuZGl2YFxuICAgIHBhZGRpbmc6IDE2cHggMDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbmA7XG5jb25zdCBJbmZvQmxvY2tJY29uQ2xhc3MgPSB1YFxuICAgIG1hcmdpbi1ib3R0b206IDEycHg7XG5gO1xuY29uc3QgSDNTdHlsZWQkMSA9IHN0eWxlZChIMylgXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIG1hcmdpbi1ib3R0b206IDRweDtcbmA7XG5jb25zdCBUZXh0U3R5bGVkJDIgPSBzdHlsZWQoVGV4dClgXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIG1heC13aWR0aDogMzUycHg7XG4gICAgY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnl9O1xuYDtcbmNvbnN0IEJ1dHRvbnNCbG9jayA9IHN0eWxlZC5kaXZgXG4gICAgcGFkZGluZzogMTZweCAyNHB4IDI0cHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGdhcDogOHB4O1xuYDtcbmNvbnN0IExJTktTID0ge1xuICBHRVRfQV9XQUxMRVQ6IFwiaHR0cHM6Ly90b24ub3JnL3dhbGxldHM/ZmlsdGVyc1t3YWxsZXRfZmVhdHVyZXNdW3NsdWddWyRpbl09ZGFwcC1hdXRoJnBhZ2luYXRpb25bbGltaXRdPS0xXCJcbn07XG5jb25zdCBJbmZvTW9kYWwgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChJbmZvTW9kYWxTdHlsZWQsIHtcbiAgICBcImRhdGEtdGMtd2FsbGV0cy1tb2RhbC1pbmZvXCI6IFwidHJ1ZVwiLFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFN0eWxlZEljb25CdXR0b24kMywge1xuICAgICAgICBpY29uOiBcImFycm93XCIsXG4gICAgICAgIG9uQ2xpY2s6ICgpID0+IHByb3BzLm9uQmFja0NsaWNrKClcbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoSDFTdHlsZWQkNywge1xuICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5pbmZvTW9kYWwud2hhdElzQVdhbGxldFwiLFxuICAgICAgICBjaGlsZHJlbjogXCJXaGF0IGlzIGEgd2FsbGV0XCJcbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2Nyb2xsQ29udGFpbmVyLCB7XG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChJbmZvQmxvY2ssIHtcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoU2VjdXJpdHlJY29uLCB7XG4gICAgICAgICAgICAgICAgXCJjbGFzc1wiOiBJbmZvQmxvY2tJY29uQ2xhc3NcbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChIM1N0eWxlZCQxLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwuaW5mb01vZGFsLnNlY3VyZURpZ2l0YWxBc3NldHNcIixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJTZWN1cmUgZGlnaXRhbCBhc3NldHMgc3RvcmFnZVwiXG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoVGV4dFN0eWxlZCQyLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwuaW5mb01vZGFsLndhbGxldFByb3RlY3RzXCIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiQSB3YWxsZXQgcHJvdGVjdHMgYW5kIG1hbmFnZXMgeW91ciBkaWdpdGFsIGFzc2V0cyBpbmNsdWRpbmcgVE9OLCB0b2tlbnMgYW5kIGNvbGxlY3RhYmxlcy5cIlxuICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChJbmZvQmxvY2ssIHtcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoUGVyc29uYWxpdHlJY29uLCB7XG4gICAgICAgICAgICAgICAgXCJjbGFzc1wiOiBJbmZvQmxvY2tJY29uQ2xhc3NcbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChIM1N0eWxlZCQxLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwuaW5mb01vZGFsLmNvbnRyb2xJZGVudGl0eVwiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkNvbnRyb2wgeW91ciBXZWIzIGlkZW50aXR5XCJcbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChUZXh0U3R5bGVkJDIsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5pbmZvTW9kYWwubWFuYWdlSWRlbnRpdHlcIixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJNYW5hZ2UgeW91ciBkaWdpdGFsIGlkZW50aXR5IGFuZCBhY2Nlc3MgZGVjZW50cmFsaXplZCBhcHBsaWNhdGlvbnMgd2l0aCBlYXNlLiBNYWludGFpbiBjb250cm9sIG92ZXIgeW91ciBkYXRhIGFuZCBlbmdhZ2Ugc2VjdXJlbHkgaW4gdGhlIGJsb2NrY2hhaW4gZWNvc3lzdGVtLlwiXG4gICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEluZm9CbG9jaywge1xuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTd2FwSWNvbiwge1xuICAgICAgICAgICAgICAgIFwiY2xhc3NcIjogSW5mb0Jsb2NrSWNvbkNsYXNzXG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoSDNTdHlsZWQkMSwge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmluZm9Nb2RhbC5lZmZvcnRsZXNzQ3J5cHRvVHJhbnNhY3Rpb25zXCIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiRWZmb3J0bGVzcyBjcnlwdG8gdHJhbnNhY3Rpb25zXCJcbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChUZXh0U3R5bGVkJDIsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5pbmZvTW9kYWwuZWFzaWx5U2VuZFwiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkVhc2lseSBzZW5kLCByZWNlaXZlLCBtb25pdG9yIHlvdXIgY3J5cHRvY3VycmVuY2llcy4gU3RyZWFtbGluZSB5b3VyIG9wZXJhdGlvbnMgd2l0aCBkZWNlbnRyYWxpemVkIGFwcGxpY2F0aW9ucy5cIlxuICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChCdXR0b25zQmxvY2ssIHtcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChMaW5rLCB7XG4gICAgICAgICAgICAgICAgZ2V0IGhyZWYoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gTElOS1MuR0VUX0FfV0FMTEVUO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYmxhbms6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChCdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IHJpZ2h0SWNvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFdhbGxldEljb24sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNsYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmluZm9Nb2RhbC5nZXRBV2FsbGV0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJHZXQgYSBXYWxsZXRcIlxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXTtcbiAgICAgICAgfVxuICAgICAgfSldO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3QgTW9iaWxlQ29ubmVjdGlvbk1vZGFsU3R5bGVkID0gc3R5bGVkLmRpdmBgO1xuY29uc3QgQm9keVN0eWxlZCA9IHN0eWxlZC5kaXZgXG4gICAgZmxleDogMTtcbiAgICBtYXJnaW4tdG9wOiAxOHB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIG1pbi1oZWlnaHQ6IDIzMnB4O1xuYDtcbmNvbnN0IEgxU3R5bGVkJDYgPSBzdHlsZWQoSDEpYFxuICAgIG1heC13aWR0aDogMjYycHg7XG4gICAgbWFyZ2luOiAwIGF1dG8gOHB4O1xuYDtcbmNvbnN0IFN0eWxlZEljb25CdXR0b24kMiA9IHN0eWxlZChJY29uQnV0dG9uKWBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAxNnB4O1xuICAgIGxlZnQ6IDE2cHg7XG5gO1xuY29uc3QgRm9vdGVyU3R5bGVkID0gc3R5bGVkLmRpdmBcbiAgICBwYWRkaW5nOiAxNnB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBnYXA6IDEycHg7XG4gICAgYm9yZGVyLXRvcDogMC41cHggc29saWQgJHsocHJvcHMpID0+IHJnYmEocHJvcHMudGhlbWUuY29sb3JzLmljb24uc2Vjb25kYXJ5LCAwLjIpfTtcbmA7XG5jb25zdCBJbWFnZVN0eWxlZCA9IHN0eWxlZChJbWFnZSlgXG4gICAgd2lkdGg6IDM2cHg7XG4gICAgaGVpZ2h0OiAzNnB4O1xuICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7XG5gO1xuY29uc3QgRm9vdGVyQnV0dG9uID0gc3R5bGVkKExpbmspYFxuICAgIG1hcmdpbi1sZWZ0OiBhdXRvO1xuYDtcbmNvbnN0IExvYWRlclN0eWxlZCA9IHN0eWxlZChMb2FkZXJJY29uKWBcbiAgICBtYXJnaW4tYm90dG9tOiAxOHB4O1xuICAgIG1hcmdpbi10b3A6IDJweDtcbmA7XG5jb25zdCBFcnJvckljb25TdHlsZWQkMSA9IHN0eWxlZChFcnJvckljb24pYFxuICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XG5gO1xuY29uc3QgQm9keVRleHRTdHlsZWQkMSA9IHN0eWxlZChIMilgXG4gICAgY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnl9O1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBtYXJnaW4tYm90dG9tOiAyMHB4O1xuYDtcbmNvbnN0IEJ1dHRvbnNDb250YWluZXJTdHlsZWQkMSA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBnYXA6IDhweDtcbiAgICBwYWRkaW5nLWJvdHRvbTogMTZweDtcbmA7XG5jb25zdCBhY3Rpb25CdXR0b25Cb3JkZXJSYWRpdXMkMSA9IHtcbiAgbTogXCIxNnB4XCIsXG4gIHM6IFwiOHB4XCIsXG4gIG5vbmU6IFwiMFwiXG59O1xuY29uc3QgSDFTdHlsZWQkNSA9IHN0eWxlZChIMSlgXG4gICAgbWFyZ2luLWJvdHRvbTogMnB4O1xuICAgIHBhZGRpbmc6IDAgNTJweDtcbmA7XG5jb25zdCBIMlN0eWxlZCQzID0gc3R5bGVkKEgyKWBcbiAgICBtYXJnaW4tYm90dG9tOiAyMHB4O1xuICAgIHBhZGRpbmc6IDAgNjRweDtcbmA7XG5jb25zdCBRckNvZGVXcmFwcGVyJDEgPSBzdHlsZWQuZGl2YFxuICAgIHBhZGRpbmc6IDAgMjRweCAxNnB4O1xuYDtcbmNvbnN0IEJ1dHRvbnNXcmFwcGVyJDEgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICBnYXA6IDE2cHg7XG4gICAgcGFkZGluZzogMCAyNHB4IDI0cHg7XG4gICAgbWFyZ2luLXRvcDogMDtcbmA7XG5jb25zdCBBY3Rpb25CdXR0b24kMSA9IHN0eWxlZChCdXR0b24pYFxuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogNTZweDtcbiAgICBib3JkZXItcmFkaXVzOiAkeyhwcm9wcykgPT4gYWN0aW9uQnV0dG9uQm9yZGVyUmFkaXVzJDFbcHJvcHMudGhlbWUuYm9yZGVyUmFkaXVzXX07XG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHJnYmEocHJvcHMudGhlbWUuY29sb3JzLmFjY2VudCwgMC4xMil9O1xuICAgIGNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmFjY2VudH07XG4gICAgZm9udC1zaXplOiAxNnB4O1xuICAgIGxpbmUtaGVpZ2h0OiAyMHB4O1xuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgcGFkZGluZzogMTdweCAyMHB4IDE5cHggMjBweDtcbmA7XG5jb25zdCBNb2JpbGVDb25uZWN0aW9uUVIgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoSDFTdHlsZWQkNSwge1xuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBwcm9wcy53YWxsZXRJbmZvLm5hbWU7XG4gICAgfVxuICB9KSwgY3JlYXRlQ29tcG9uZW50KEgyU3R5bGVkJDMsIHtcbiAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5tb2JpbGVDb25uZWN0aW9uTW9kYWwuc2NhblFSXCIsXG4gICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogcHJvcHMud2FsbGV0SW5mby5uYW1lXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIFtcIlNjYW4gdGhlIFFSIGNvZGUgYmVsb3cgd2l0aCB5b3VyIHBob25l4oCZcyBvciBcIiwgbWVtbygoKSA9PiBwcm9wcy53YWxsZXRJbmZvLm5hbWUpLCBcIuKAmXMgY2FtZXJhXCJdO1xuICAgIH1cbiAgfSksIGNyZWF0ZUNvbXBvbmVudChRckNvZGVXcmFwcGVyJDEsIHtcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFFSQ29kZSwge1xuICAgICAgICBnZXQgaW1hZ2VVcmwoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLndhbGxldEluZm8uaW1hZ2VVcmw7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBzb3VyY2VVcmwoKSB7XG4gICAgICAgICAgcmV0dXJuIGFkZFJldHVyblN0cmF0ZWd5KHByb3BzLnVuaXZlcnNhbExpbmssIFwibm9uZVwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzYWJsZUNvcHk6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSksIGNyZWF0ZUNvbXBvbmVudChCdXR0b25zV3JhcHBlciQxLCB7XG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoQWN0aW9uQnV0dG9uJDEsIHtcbiAgICAgICAgYXBwZWFyYW5jZTogXCJzZWNvbmRhcnlcIixcbiAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgcmV0dXJuIChfYTIgPSBwcm9wcy5vbk9wZW5MaW5rKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwocHJvcHMpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwubW9iaWxlVW5pdmVyc2FsTW9kYWwub3BlbkxpbmtcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIk9wZW4gTGlua1wiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoQWN0aW9uQnV0dG9uJDEsIHtcbiAgICAgICAgYXBwZWFyYW5jZTogXCJzZWNvbmRhcnlcIixcbiAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgcmV0dXJuIChfYTIgPSBwcm9wcy5vbkNvcHkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChwcm9wcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICBnZXQgdHJhbnNsYXRpb25LZXkoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wcy5pc0NvcGllZFNob3duICE9PSB2b2lkIDAgPyBcImNvbW1vbi5jb3BpZWRcIiA6IFwiY29tbW9uLmNvcHlMaW5rXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuaXNDb3BpZWRTaG93biAhPT0gdm9pZCAwID8gXCJDb3BpZWRcIiA6IFwiQ29weSBMaW5rXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pXTtcbiAgICB9XG4gIH0pXTtcbn07XG5jb25zdCBNb2JpbGVDb25uZWN0aW9uTW9kYWwgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCBbZmlyc3RDbGljaywgc2V0Rmlyc3RDbGlja10gPSBjcmVhdGVTaWduYWwodHJ1ZSk7XG4gIGNvbnN0IFtzaG93UVIsIHNldFNob3dRUl0gPSBjcmVhdGVTaWduYWwoZmFsc2UpO1xuICBjb25zdCBbY29ubmVjdGlvbkVycm9yZWQsIHNldENvbm5lY3Rpb25FcnJvcmVkXSA9IGNyZWF0ZVNpZ25hbChudWxsKTtcbiAgY3JlYXRlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIHNldENvbm5lY3Rpb25FcnJvcmVkKChfYTIgPSBwcm9wcy5kZWZhdWx0RXJyb3IpICE9IG51bGwgPyBfYTIgOiBudWxsKTtcbiAgfSk7XG4gIGNvbnN0IGNvbm5lY3RvciA9IHVzZUNvbnRleHQoQ29ubmVjdG9yQ29udGV4dCk7XG4gIGNvbnN0IHVuc3Vic2NyaWJlID0gY29ubmVjdG9yLm9uU3RhdHVzQ2hhbmdlKCgpID0+IHtcbiAgfSwgKGVycm9yKSA9PiB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgV2FsbGV0TWlzc2luZ1JlcXVpcmVkRmVhdHVyZXNFcnJvcikge1xuICAgICAgc2V0Q29ubmVjdGlvbkVycm9yZWQoXCJtaXNzaW5nLWZlYXR1cmVzXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBXYWxsZXRXcm9uZ05ldHdvcmtFcnJvcikge1xuICAgICAgc2V0Q29ubmVjdGlvbkVycm9yZWQoXCJ3cm9uZy1uZXR3b3JrXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRDb25uZWN0aW9uRXJyb3JlZChudWxsKTtcbiAgfSk7XG4gIGNvbnN0IHVuaXZlcnNhbExpbmsgPSBjcmVhdGVNZW1vKCgpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIHJldHVybiBjb25uZWN0b3IuY29ubmVjdCh7XG4gICAgICB1bml2ZXJzYWxMaW5rOiBwcm9wcy53YWxsZXQudW5pdmVyc2FsTGluayxcbiAgICAgIGJyaWRnZVVybDogcHJvcHMud2FsbGV0LmJyaWRnZVVybFxuICAgIH0sIHByb3BzLmFkZGl0aW9uYWxSZXF1ZXN0LCB7XG4gICAgICB0cmFjZUlkOiAoX2EyID0gcHJvcHMud2FsbGV0TW9kYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi50cmFjZUlkXG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCBvbkNsaWNrVGVsZWdyYW0gPSAoKSA9PiB7XG4gICAgY29uc3QgYWx3YXlzRm9yY2VSZWRpcmVjdCA9IHRydWU7XG4gICAgc2V0TGFzdFNlbGVjdGVkV2FsbGV0SW5mbyhfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcm9wcy53YWxsZXQpLCB7XG4gICAgICBvcGVuTWV0aG9kOiBcInVuaXZlcnNhbC1saW5rXCJcbiAgICB9KSk7XG4gICAgcmVkaXJlY3RUb1RlbGVncmFtKHVuaXZlcnNhbExpbmsoKSwge1xuICAgICAgcmV0dXJuU3RyYXRlZ3k6IGFwcFN0YXRlLnJldHVyblN0cmF0ZWd5LFxuICAgICAgdHdhUmV0dXJuVXJsOiBhcHBTdGF0ZS50d2FSZXR1cm5VcmwsXG4gICAgICBmb3JjZVJlZGlyZWN0OiBhbHdheXNGb3JjZVJlZGlyZWN0XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IG9uUmV0cnkgPSAoKSA9PiB7XG4gICAgY29uc3QgY3VycmVudFVuaXZlcnNhbExpbmsgPSB1bml2ZXJzYWxMaW5rKCk7XG4gICAgaWYgKGlzVGVsZWdyYW1VcmwoY3VycmVudFVuaXZlcnNhbExpbmspKSB7XG4gICAgICByZXR1cm4gb25DbGlja1RlbGVncmFtKCk7XG4gICAgfVxuICAgIHNldENvbm5lY3Rpb25FcnJvcmVkKG51bGwpO1xuICAgIGNvbnN0IGZvcmNlUmVkaXJlY3QgPSAhZmlyc3RDbGljaygpO1xuICAgIHNldEZpcnN0Q2xpY2soZmFsc2UpO1xuICAgIHJlZGlyZWN0VG9XYWxsZXQodW5pdmVyc2FsTGluaygpLCBwcm9wcy53YWxsZXQuZGVlcExpbmssIHtcbiAgICAgIHJldHVyblN0cmF0ZWd5OiBhcHBTdGF0ZS5yZXR1cm5TdHJhdGVneSxcbiAgICAgIGZvcmNlUmVkaXJlY3RcbiAgICB9LCAobWV0aG9kKSA9PiB7XG4gICAgICBzZXRMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHByb3BzLndhbGxldCksIHtcbiAgICAgICAgb3Blbk1ldGhvZDogbWV0aG9kXG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IFtpc0NvcGllZFNob3duLCBzZXRJc0NvcGllZFNob3duXSA9IGNyZWF0ZVNpZ25hbCh2b2lkIDApO1xuICBjb25zdCBvbkNvcHkgPSAoKSA9PiBfX2FzeW5jKG51bGwsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgaWYgKGlzQ29waWVkU2hvd24oKSAhPT0gdm9pZCAwKSB7XG4gICAgICBjbGVhclRpbWVvdXQoaXNDb3BpZWRTaG93bigpKTtcbiAgICB9XG4gICAgeWllbGQgY29weVRvQ2xpcGJvYXJkKHVuaXZlcnNhbExpbmsoKSk7XG4gICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBzZXRJc0NvcGllZFNob3duKHZvaWQgMCksIDE1MDApO1xuICAgIHNldElzQ29waWVkU2hvd24odGltZW91dElkKTtcbiAgfSk7XG4gIGNvbnN0IG9uT3BlblFSID0gKCkgPT4ge1xuICAgIHNldENvbm5lY3Rpb25FcnJvcmVkKG51bGwpO1xuICAgIHNldFNob3dRUih0cnVlKTtcbiAgICBzZXRMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHByb3BzLndhbGxldCksIHtcbiAgICAgIG9wZW5NZXRob2Q6IFwicXJjb2RlXCJcbiAgICB9KSk7XG4gIH07XG4gIGNvbnN0IG9uQ2xvc2VRUiA9ICgpID0+IHtcbiAgICBzZXRTaG93UVIoZmFsc2UpO1xuICAgIHNldExhc3RTZWxlY3RlZFdhbGxldEluZm8oX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMud2FsbGV0KSwge1xuICAgICAgb3Blbk1ldGhvZDogXCJ1bml2ZXJzYWwtbGlua1wiXG4gICAgfSkpO1xuICB9O1xuICBjb25zdCBvbkJhY2sgPSAoKSA9PiB7XG4gICAgaWYgKHNob3dRUigpKSB7XG4gICAgICBvbkNsb3NlUVIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcHMub25CYWNrQ2xpY2soKTtcbiAgICB9XG4gIH07XG4gIG9uQ2xlYW51cCh1bnN1YnNjcmliZSk7XG4gIG9uUmV0cnkoKTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChNb2JpbGVDb25uZWN0aW9uTW9kYWxTdHlsZWQsIHtcbiAgICBcImRhdGEtdGMtd2FsbGV0cy1tb2RhbC1jb25uZWN0aW9uLW1vYmlsZVwiOiBcInRydWVcIixcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgIHJldHVybiAhcHJvcHMuYmFja0Rpc2FibGVkIHx8IHNob3dRUigpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChTdHlsZWRJY29uQnV0dG9uJDIsIHtcbiAgICAgICAgICAgIGljb246IFwiYXJyb3dcIixcbiAgICAgICAgICAgIG9uQ2xpY2s6IG9uQmFja1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIHNob3dRUigpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChNb2JpbGVDb25uZWN0aW9uUVIsIHtcbiAgICAgICAgICAgIGdldCB1bml2ZXJzYWxMaW5rKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdW5pdmVyc2FsTGluaygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCB3YWxsZXRJbmZvKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcHMud2FsbGV0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uT3Blbkxpbms6IG9uUmV0cnksXG4gICAgICAgICAgICBvbkNvcHksXG4gICAgICAgICAgICBnZXQgaXNDb3BpZWRTaG93bigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlzQ29waWVkU2hvd24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgIHJldHVybiAhc2hvd1FSKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChIMVN0eWxlZCQ2LCB7XG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wcy53YWxsZXQubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEJvZHlTdHlsZWQsIHtcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25FcnJvcmVkKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChFcnJvckljb25TdHlsZWQkMSwge1xuICAgICAgICAgICAgICAgICAgICBzaXplOiBcInNcIlxuICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTd2l0Y2gsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25FcnJvcmVkKCkgPT09IFwibWlzc2luZy1mZWF0dXJlc1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChCb2R5VGV4dFN0eWxlZCQxLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwubW9iaWxlQ29ubmVjdGlvbk1vZGFsLm1pc3NpbmdGZWF0dXJlc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHByb3BzLndhbGxldC5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiUGxlYXNlIHVwZGF0ZSBXYWxsZXQsIHlvdXIgdmVyc2lvbiBkb2VzIG5vdCBzdXBwb3J0IHJlcXVpcmVkIGZlYXR1cmVzIGZvciB0aGlzIGRBcHBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25FcnJvcmVkKCkgPT09IFwiY29ubmVjdGlvbi1kZWNsaW5lZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChCb2R5VGV4dFN0eWxlZCQxLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwubW9iaWxlQ29ubmVjdGlvbk1vZGFsLmNvbm5lY3Rpb25EZWNsaW5lZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkNvbm5lY3Rpb24gZGVjbGluZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25FcnJvcmVkKCkgPT09IFwid3JvbmctbmV0d29ya1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChCb2R5VGV4dFN0eWxlZCQxLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwubW9iaWxlQ29ubmVjdGlvbk1vZGFsLndyb25nTmV0d29ya1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHByb3BzLndhbGxldC5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcIkNvbm5lY3RlZCB3YWxsZXQgaXMgb24gYSBkaWZmZXJlbnQgbmV0d29yay4gUGxlYXNlIHN3aXRjaCBuZXR3b3JrIGluIFwiLCBtZW1vKCgpID0+IHByb3BzLndhbGxldC5uYW1lKSwgXCIgYW5kIHRyeSBhZ2Fpbi5cIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25FcnJvcmVkKCkgPT09IFwibm90LXN1cHBvcnRlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChCb2R5VGV4dFN0eWxlZCQxLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwubW9iaWxlQ29ubmVjdGlvbk1vZGFsLm5vdFN1cHBvcnRlZFdhbGxldFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHByb3BzLndhbGxldC5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttZW1vKCgpID0+IHByb3BzLndhbGxldC5uYW1lKSwgXCIgZG9lc24ndCBzdXBwb3J0IHRoZSByZXF1ZXN0ZWQgYWN0aW9uLiBQbGVhc2UgY29ubmVjdCBhbm90aGVyIHdhbGxldCB0aGF0IHN1cHBvcnRzIGl0LlwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChCdXR0b25zQ29udGFpbmVyU3R5bGVkJDEsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoU3dpdGNoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbkVycm9yZWQoKSA9PT0gXCJtaXNzaW5nLWZlYXR1cmVzXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChCdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGxlZnRJY29uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoUmV0cnlJY29uLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IG9uUmV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJjb21tb24ucmV0cnlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlJldHJ5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChMaW5rLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBocmVmKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy53YWxsZXQuYWJvdXRVcmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsYW5rOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChCdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBsZWZ0SWNvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChMaW5rSWNvbiwge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLm1vYmlsZUNvbm5lY3Rpb25Nb2RhbC51cGRhdGVXYWxsZXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgdHJhbnNsYXRpb25WYWx1ZXMoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwcm9wcy53YWxsZXQubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJVcGRhdGUgXCIsIG1lbW8oKCkgPT4gcHJvcHMud2FsbGV0Lm5hbWUpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbkVycm9yZWQoKSA9PT0gXCJub3Qtc3VwcG9ydGVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBwcm9wcy5vbkJhY2tDbGljaygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwubW9iaWxlQ29ubmVjdGlvbk1vZGFsLmNob29zZUFub3RoZXJXYWxsZXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkNob29zZSBBbm90aGVyIFdhbGxldFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25FcnJvcmVkKCkgPT09IFwid3JvbmctbmV0d29ya1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChCdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGxlZnRJY29uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoUmV0cnlJY29uLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IG9uUmV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJjb21tb24ucmV0cnlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlJldHJ5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbkVycm9yZWQoKSA9PT0gXCJjb25uZWN0aW9uLWRlY2xpbmVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChCdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGxlZnRJY29uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoUmV0cnlJY29uLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IG9uUmV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJjb21tb24ucmV0cnlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlJldHJ5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChCdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGxlZnRJY29uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoUVJJY29uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgZmlsbCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoZW1lLmNvbG9ycy5hY2NlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IG9uT3BlblFSLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwubW9iaWxlQ29ubmVjdGlvbk1vZGFsLnNob3dRUlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiU2hvdyBRUiBDb2RlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAhY29ubmVjdGlvbkVycm9yZWQoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KExvYWRlclN0eWxlZCwge1xuICAgICAgICAgICAgICAgICAgICBzaXplOiBcInNcIlxuICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChCb2R5VGV4dFN0eWxlZCQxLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLm1vYmlsZUNvbm5lY3Rpb25Nb2RhbC5jb250aW51ZUluXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcHJvcHMud2FsbGV0Lm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcIkNvbnRpbnVlIGluIFwiLCBtZW1vKCgpID0+IHByb3BzLndhbGxldC5uYW1lKSwgXCLigKZcIl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoQnV0dG9uc0NvbnRhaW5lclN0eWxlZCQxLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChCdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBsZWZ0SWNvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChSZXRyeUljb24sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBvblJldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwiY29tbW9uLnJldHJ5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiUmV0cnlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGxlZnRJY29uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFFSSWNvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBmaWxsKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoZW1lLmNvbG9ycy5hY2NlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBvbk9wZW5RUixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLm1vYmlsZUNvbm5lY3Rpb25Nb2RhbC5zaG93UVJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJTaG93IFFSIENvZGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEZvb3RlclN0eWxlZCwge1xuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChJbWFnZVN0eWxlZCwge1xuICAgICAgICAgICAgICAgIGdldCBzcmMoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMud2FsbGV0LmltYWdlVXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChIMywge1xuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy53YWxsZXQubmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoRm9vdGVyQnV0dG9uLCB7XG4gICAgICAgICAgICAgICAgZ2V0IGhyZWYoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMud2FsbGV0LmFib3V0VXJsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYmxhbms6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChCdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNsYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcImNvbW1vbi5nZXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkdFVFwiXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXTtcbiAgICAgICAgfVxuICAgICAgfSldO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3QgYm9yZGVycyQyID0ge1xuICBtOiBcIjE2cHhcIixcbiAgczogXCIxMnB4XCIsXG4gIG5vbmU6IFwiMFwiXG59O1xuY29uc3QgdGdCb3JkZXJzID0ge1xuICBtOiBcIjZweFwiLFxuICBzOiBcIjZweFwiLFxuICBub25lOiBcIjBcIlxufTtcbnN0eWxlZC5saWBcbiAgICB3aWR0aDogODJweDtcbiAgICBtaW4td2lkdGg6IDgycHg7XG4gICAgaGVpZ2h0OiAxMjRweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBwYWRkaW5nOiA4cHggNHB4O1xuXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjFzIGVhc2UtaW4tb3V0O1xuXG4gICAgJHttZWRpYU5vdFRvdWNofSB7XG4gICAgICAgICY6aG92ZXIge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLjA0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICY6YWN0aXZlIHtcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjk2KTtcbiAgICB9XG5cbiAgICAke21lZGlhVG91Y2h9IHtcbiAgICAgICAgJjphY3RpdmUge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjkyKTtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5jb25zdCBIMVN0eWxlZCQ0ID0gc3R5bGVkKEgxKWBcbiAgICBtYXJnaW4tdG9wOiAzOHB4O1xuICAgIG1hcmdpbi1ib3R0b206IDRweDtcbiAgICBwYWRkaW5nOiAwIDI0cHg7XG5gO1xuY29uc3QgSDJTdHlsZWQkMiA9IHN0eWxlZChIMilgXG4gICAgbWFyZ2luOiAkeyhwcm9wcykgPT4ge1xuICB2YXIgX2EyO1xuICByZXR1cm4gKF9hMiA9IHByb3BzLm1hcmdpbikgIT0gbnVsbCA/IF9hMiA6IFwiMCAwIDI4cHggMFwiO1xufX07XG4gICAgcGFkZGluZzogJHsocHJvcHMpID0+IHtcbiAgdmFyIF9hMjtcbiAgcmV0dXJuIChfYTIgPSBwcm9wcy5wYWRkaW5nKSAhPSBudWxsID8gX2EyIDogXCIwIDI0cHhcIjtcbn19O1xuICAgIG1pbi1oZWlnaHQ6ICR7KHByb3BzKSA9PiB7XG4gIHZhciBfYTI7XG4gIHJldHVybiAoX2EyID0gcHJvcHMucGFkZGluZykgIT0gbnVsbCA/IF9hMiA6IFwiNDRweFwiO1xufX07XG4gICAgbWF4LXdpZHRoOiAkeyhwcm9wcykgPT4gcHJvcHMubWF4V2lkdGh9cHg7XG4gICAgbWFyZ2luLWxlZnQ6ICR7KHByb3BzKSA9PiBwcm9wcy5tYXhXaWR0aCA/IFwiYXV0b1wiIDogXCIwcHhcIn07XG4gICAgbWFyZ2luLXJpZ2h0OiAkeyhwcm9wcykgPT4gcHJvcHMubWF4V2lkdGggPyBcImF1dG9cIiA6IFwiMHB4XCJ9O1xuYDtcbnN0eWxlZChCdXR0b24pYFxuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIG1hcmdpbjogMCBhdXRvO1xuYDtcbmNvbnN0IFRlbGVncmFtQnV0dG9uU3R5bGVkID0gc3R5bGVkKEJ1dHRvbilgXG4gICAgbWFyZ2luOiAwIDI4cHggMjRweDtcbiAgICB3aWR0aDogY2FsYygxMDAlIC0gNTZweCk7XG4gICAgYm9yZGVyLXJhZGl1czogJHsocHJvcHMpID0+IGJvcmRlcnMkMltwcm9wcy50aGVtZS5ib3JkZXJSYWRpdXNdfTtcbiAgICBwYWRkaW5nOiAxNHB4IDE2cHggMTRweCAxNHB4O1xuICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMudGVsZWdyYW1CdXR0b259O1xuXG4gICAgY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuY29uc3RhbnQud2hpdGV9O1xuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgZm9udC1zaXplOiAxNnB4O1xuICAgIGxpbmUtaGVpZ2h0OiAyMHB4O1xuXG4gICAgQG1lZGlhIChtYXgtd2lkdGg6IDM3NXB4KSB7XG4gICAgICAgIG1hcmdpbjogMCAxNnB4IDI0cHg7XG4gICAgICAgIHdpZHRoOiBjYWxjKDEwMCUgLSAzMnB4KTtcbiAgICB9XG5gO1xuY29uc3QgVEdJbWFnZVN0eWxlZCA9IHN0eWxlZChJbWFnZSlgXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgYm9yZGVyLXJhZGl1czogJHsocHJvcHMpID0+IHRnQm9yZGVyc1twcm9wcy50aGVtZS5ib3JkZXJSYWRpdXNdfTtcbiAgICB3aWR0aDogMjRweDtcbiAgICBoZWlnaHQ6IDI0cHg7XG5gO1xuY29uc3QgU3R5bGVkTGVmdEFjdGlvbkJ1dHRvbiA9IHN0eWxlZChJY29uQnV0dG9uKWBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAxNnB4O1xuICAgIGxlZnQ6IDE2cHg7XG5gO1xuY29uc3QgYWN0aW9uQnV0dG9uQm9yZGVyUmFkaXVzID0ge1xuICBtOiBcIjE2cHhcIixcbiAgczogXCI4cHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCBIMVN0eWxlZCQzID0gc3R5bGVkKEgxKWBcbiAgICBtYXJnaW4tYm90dG9tOiAycHg7XG4gICAgcGFkZGluZzogMCA1MnB4O1xuYDtcbmNvbnN0IEgyU3R5bGVkJDEgPSBzdHlsZWQoSDIpYFxuICAgIG1hcmdpbi1ib3R0b206IDIwcHg7XG4gICAgcGFkZGluZzogMCA2NHB4O1xuYDtcbmNvbnN0IFFyQ29kZVdyYXBwZXIgPSBzdHlsZWQuZGl2YFxuICAgIHBhZGRpbmc6IDAgMjRweCAxNnB4O1xuYDtcbmNvbnN0IEJ1dHRvbnNXcmFwcGVyID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgZ2FwOiAxNnB4O1xuICAgIHBhZGRpbmc6IDAgMjRweCAyNHB4O1xuICAgIG1hcmdpbi10b3A6IDA7XG5gO1xuY29uc3QgQWN0aW9uQnV0dG9uID0gc3R5bGVkKEJ1dHRvbilgXG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiA1NnB4O1xuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiBhY3Rpb25CdXR0b25Cb3JkZXJSYWRpdXNbcHJvcHMudGhlbWUuYm9yZGVyUmFkaXVzXX07XG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHJnYmEocHJvcHMudGhlbWUuY29sb3JzLmFjY2VudCwgMC4xMil9O1xuICAgIGNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmFjY2VudH07XG4gICAgZm9udC1zaXplOiAxNnB4O1xuICAgIGxpbmUtaGVpZ2h0OiAyMHB4O1xuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgcGFkZGluZzogMTdweCAyMHB4IDE5cHggMjBweDtcbmA7XG5jb25zdCBNb2JpbGVVbml2ZXJzYWxRUiA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChIMVN0eWxlZCQzLCB7XG4gICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwubW9iaWxlVW5pdmVyc2FsTW9kYWwuY29ubmVjdFlvdXJXYWxsZXRcIixcbiAgICBjaGlsZHJlbjogXCJDb25uZWN0IHlvdXIgVE9OIHdhbGxldFwiXG4gIH0pLCBjcmVhdGVDb21wb25lbnQoSDJTdHlsZWQkMSwge1xuICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLm1vYmlsZVVuaXZlcnNhbE1vZGFsLnNjYW5cIixcbiAgICBjaGlsZHJlbjogXCJTY2FuIHdpdGggeW91ciBtb2JpbGUgd2FsbGV0XCJcbiAgfSksIGNyZWF0ZUNvbXBvbmVudChRckNvZGVXcmFwcGVyLCB7XG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChRUkNvZGUsIHtcbiAgICAgICAgZ2V0IGltYWdlVXJsKCkge1xuICAgICAgICAgIHJldHVybiBJTUcuVE9OO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgc291cmNlVXJsKCkge1xuICAgICAgICAgIHJldHVybiBhZGRSZXR1cm5TdHJhdGVneShwcm9wcy51bml2ZXJzYWxMaW5rLCBcIm5vbmVcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGRpc2FibGVDb3B5OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pLCBjcmVhdGVDb21wb25lbnQoQnV0dG9uc1dyYXBwZXIsIHtcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChBY3Rpb25CdXR0b24sIHtcbiAgICAgICAgYXBwZWFyYW5jZTogXCJzZWNvbmRhcnlcIixcbiAgICAgICAgb25DbGljazogKCkgPT4gcHJvcHMub25PcGVuTGluaygpLFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwubW9iaWxlVW5pdmVyc2FsTW9kYWwub3BlbkxpbmtcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIk9wZW4gTGlua1wiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoQWN0aW9uQnV0dG9uLCB7XG4gICAgICAgIGFwcGVhcmFuY2U6IFwic2Vjb25kYXJ5XCIsXG4gICAgICAgIG9uQ2xpY2s6ICgpID0+IHByb3BzLm9uQ29weSgpLFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgZ2V0IHRyYW5zbGF0aW9uS2V5KCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuaXNDb3BpZWRTaG93biAhPT0gdm9pZCAwID8gXCJjb21tb24uY29waWVkXCIgOiBcImNvbW1vbi5jb3B5TGlua1wiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLmlzQ29waWVkU2hvd24gIT09IHZvaWQgMCA/IFwiQ29waWVkXCIgOiBcIkNvcHkgTGlua1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KV07XG4gICAgfVxuICB9KV07XG59O1xuZnVuY3Rpb24gZ2V0VW5pcXVlQnJpZGdlcyh3YWxsZXRzTGlzdCkge1xuICBjb25zdCB1bmlxdWVCcmlkZ2VzID0gbmV3IFNldChcbiAgICB3YWxsZXRzTGlzdC5maWx0ZXIoaXNXYWxsZXRJbmZvUmVtb3RlKS5tYXAoKGl0ZW0pID0+IGl0ZW0uYnJpZGdlVXJsKVxuICApO1xuICByZXR1cm4gQXJyYXkuZnJvbSh1bmlxdWVCcmlkZ2VzKS5tYXAoKGJyaWRnZVVybCkgPT4gKHsgYnJpZGdlVXJsIH0pKTtcbn1cbmZ1bmN0aW9uIGJyaWRnZXNJc0VxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gIGNvbnN0IGxlZnRTZXQgPSBuZXcgU2V0KGxlZnQgPT0gbnVsbCA/IHZvaWQgMCA6IGxlZnQubWFwKChpMikgPT4gaTIuYnJpZGdlVXJsKSk7XG4gIGNvbnN0IHJpZ2h0U2V0ID0gbmV3IFNldChyaWdodCA9PSBudWxsID8gdm9pZCAwIDogcmlnaHQubWFwKChpMikgPT4gaTIuYnJpZGdlVXJsKSk7XG4gIHJldHVybiBsZWZ0U2V0LnNpemUgPT09IHJpZ2h0U2V0LnNpemUgJiYgWy4uLmxlZnRTZXRdLmV2ZXJ5KCh2YWx1ZSkgPT4gcmlnaHRTZXQuaGFzKHZhbHVlKSk7XG59XG52YXIgX3RtcGwkJDEgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPGxpPmApLCBfdG1wbCQyID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxkaXYgZGF0YS10Yy13YWxsZXRzLW1vZGFsLXVuaXZlcnNhbC1tb2JpbGU9dHJ1ZT5gKTtcbmNvbnN0IE1vYmlsZVVuaXZlcnNhbE1vZGFsID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IFtzaG93UVIsIHNldFNob3dRUl0gPSBjcmVhdGVTaWduYWwoZmFsc2UpO1xuICBjb25zdCBbZmlyc3RDbGljaywgc2V0Rmlyc3RDbGlja10gPSBjcmVhdGVTaWduYWwodHJ1ZSk7XG4gIGNvbnN0IFt1bml2ZXJzYWxMaW5rLCBzZXRVbml2ZXJzYWxMaW5rXSA9IGNyZWF0ZVNpZ25hbChudWxsKTtcbiAgY29uc3QgY29ubmVjdG9yID0gYXBwU3RhdGUuY29ubmVjdG9yO1xuICBjb25zdCB3YWxsZXRzTGlzdCA9ICgpID0+IHByb3BzLndhbGxldHNMaXN0LmZpbHRlcigodykgPT4gc3VwcG9ydHNNb2JpbGUodykgJiYgdy5hcHBOYW1lICE9PSBBVF9XQUxMRVRfQVBQX05BTUUpO1xuICBjb25zdCBzaG91bGRTaG93TW9yZUJ1dHRvbiA9ICgpID0+IHdhbGxldHNMaXN0KCkubGVuZ3RoID4gNztcbiAgY29uc3Qgd2FsbGV0c0JyaWRnZXMgPSBjcmVhdGVNZW1vKCgpID0+IGdldFVuaXF1ZUJyaWRnZXMocHJvcHMud2FsbGV0c0xpc3QpLCBudWxsLCB7XG4gICAgZXF1YWxzOiBicmlkZ2VzSXNFcXVhbFxuICB9KTtcbiAgY29uc3QgYXRXYWxsZXRTdXBwb3J0RmVhdHVyZXMgPSBjcmVhdGVNZW1vKCgpID0+IHtcbiAgICB2YXIgX2EyLCBfYjI7XG4gICAgcmV0dXJuIChfYjIgPSAoX2EyID0gcHJvcHMud2FsbGV0c0xpc3QuZmluZCgod2FsbGV0KSA9PiB3YWxsZXQuYXBwTmFtZSA9PT0gQVRfV0FMTEVUX0FQUF9OQU1FKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5pc1N1cHBvcnRSZXF1aXJlZEZlYXR1cmVzKSAhPSBudWxsID8gX2IyIDogZmFsc2U7XG4gIH0sIG51bGwpO1xuICBjb25zdCBnZXRVbml2ZXJzYWxMaW5rID0gKCkgPT4ge1xuICAgIGlmICghdW5pdmVyc2FsTGluaygpKSB7XG4gICAgICBzZXRVbml2ZXJzYWxMaW5rKGNvbm5lY3Rvci5jb25uZWN0KHdhbGxldHNCcmlkZ2VzKCksIHByb3BzLmFkZGl0aW9uYWxSZXF1ZXN0LCB7XG4gICAgICAgIHRyYWNlSWQ6IHByb3BzLndhbGxldE1vZGFsU3RhdGUudHJhY2VJZFxuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gdW5pdmVyc2FsTGluaygpO1xuICB9O1xuICBzZXRMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvKHtcbiAgICBvcGVuTWV0aG9kOiBcInVuaXZlcnNhbC1saW5rXCJcbiAgfSk7XG4gIGNvbnN0IFtpc0NvcGllZFNob3duLCBzZXRJc0NvcGllZFNob3duXSA9IGNyZWF0ZVNpZ25hbCh2b2lkIDApO1xuICBjb25zdCBvbkNvcHkgPSAoKSA9PiBfX2FzeW5jKG51bGwsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgaWYgKGlzQ29waWVkU2hvd24oKSAhPT0gdm9pZCAwKSB7XG4gICAgICBjbGVhclRpbWVvdXQoaXNDb3BpZWRTaG93bigpKTtcbiAgICB9XG4gICAgeWllbGQgY29weVRvQ2xpcGJvYXJkKGdldFVuaXZlcnNhbExpbmsoKSk7XG4gICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBzZXRJc0NvcGllZFNob3duKHZvaWQgMCksIDE1MDApO1xuICAgIHNldElzQ29waWVkU2hvd24odGltZW91dElkKTtcbiAgfSk7XG4gIGNvbnN0IG9uU2VsZWN0VW5pdmVyc2FsID0gKCkgPT4ge1xuICAgIGNvbnN0IGZvcmNlUmVkaXJlY3QgPSAhZmlyc3RDbGljaygpO1xuICAgIHNldEZpcnN0Q2xpY2soZmFsc2UpO1xuICAgIHJlZGlyZWN0VG9XYWxsZXQoZ2V0VW5pdmVyc2FsTGluaygpLCB2b2lkIDAsIHtcbiAgICAgIHJldHVyblN0cmF0ZWd5OiBhcHBTdGF0ZS5yZXR1cm5TdHJhdGVneSxcbiAgICAgIGZvcmNlUmVkaXJlY3RcbiAgICB9LCAobWV0aG9kKSA9PiB7XG4gICAgICBzZXRMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvKHtcbiAgICAgICAgb3Blbk1ldGhvZDogbWV0aG9kXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgb25TZWxlY3RUZWxlZ3JhbSA9ICgpID0+IHtcbiAgICBzZXRVbml2ZXJzYWxMaW5rKG51bGwpO1xuICAgIGNvbnN0IGF0V2FsbGV0ID0gcHJvcHMud2FsbGV0c0xpc3QuZmluZCgod2FsbGV0KSA9PiB3YWxsZXQuYXBwTmFtZSA9PT0gQVRfV0FMTEVUX0FQUF9OQU1FKTtcbiAgICBpZiAoIWF0V2FsbGV0IHx8ICFpc1dhbGxldEluZm9SZW1vdGUoYXRXYWxsZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdFVJRXJyb3IoXCJAd2FsbGV0IGJvdCBub3QgZm91bmQgaW4gdGhlIHdhbGxldHMgbGlzdFwiKTtcbiAgICB9XG4gICAgY29uc3Qgd2FsbGV0TGluayA9IGNvbm5lY3Rvci5jb25uZWN0KHtcbiAgICAgIGJyaWRnZVVybDogYXRXYWxsZXQuYnJpZGdlVXJsLFxuICAgICAgdW5pdmVyc2FsTGluazogYXRXYWxsZXQudW5pdmVyc2FsTGlua1xuICAgIH0sIHByb3BzLmFkZGl0aW9uYWxSZXF1ZXN0LCB7XG4gICAgICB0cmFjZUlkOiBwcm9wcy53YWxsZXRNb2RhbFN0YXRlLnRyYWNlSWRcbiAgICB9KTtcbiAgICBjb25zdCBmb3JjZVJlZGlyZWN0ID0gIWZpcnN0Q2xpY2soKTtcbiAgICBzZXRGaXJzdENsaWNrKGZhbHNlKTtcbiAgICByZWRpcmVjdFRvVGVsZWdyYW0od2FsbGV0TGluaywge1xuICAgICAgcmV0dXJuU3RyYXRlZ3k6IGFwcFN0YXRlLnJldHVyblN0cmF0ZWd5LFxuICAgICAgdHdhUmV0dXJuVXJsOiBhcHBTdGF0ZS50d2FSZXR1cm5VcmwsXG4gICAgICBmb3JjZVJlZGlyZWN0XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IG9uT3BlblFSID0gKCkgPT4ge1xuICAgIHNldFNob3dRUih0cnVlKTtcbiAgICBzZXRMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvKHtcbiAgICAgIG9wZW5NZXRob2Q6IFwicXJjb2RlXCJcbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgb25DbG9zZVFSID0gKCkgPT4ge1xuICAgIHNldFNob3dRUihmYWxzZSk7XG4gICAgc2V0TGFzdFNlbGVjdGVkV2FsbGV0SW5mbyh7XG4gICAgICBvcGVuTWV0aG9kOiBcInVuaXZlcnNhbC1saW5rXCJcbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgc3VwcG9ydGVkV2FsbGV0cyA9IGNyZWF0ZU1lbW8oKCkgPT4gd2FsbGV0c0xpc3QoKS5maWx0ZXIoKHdhbGxldCkgPT4gd2FsbGV0LmlzU3VwcG9ydFJlcXVpcmVkRmVhdHVyZXMpLCBudWxsKTtcbiAgY29uc3QgdmlzaWJsZVdhbGxldHMgPSBjcmVhdGVNZW1vKCgpID0+IHN1cHBvcnRlZFdhbGxldHMoKS5zbGljZSgwLCAzKSwgbnVsbCk7XG4gIHNldExhc3RWaXNpYmxlV2FsbGV0c0luZm8oe1xuICAgIHdhbGxldHNNZW51OiBcIm1haW5fc2NyZWVuXCIsXG4gICAgd2FsbGV0czogYXRXYWxsZXRTdXBwb3J0RmVhdHVyZXMoKSA/IFtwcm9wcy53YWxsZXRzTGlzdC5maW5kKCh3YWxsZXQpID0+IHdhbGxldC5hcHBOYW1lID09PSBBVF9XQUxMRVRfQVBQX05BTUUpLCAuLi52aXNpYmxlV2FsbGV0cygpXSA6IHZpc2libGVXYWxsZXRzKClcbiAgfSk7XG4gIGNvbnN0IGZvdXJXYWxsZXRzSXRlbSA9IGNyZWF0ZU1lbW8oKCkgPT4gd2FsbGV0c0xpc3QoKS5maWx0ZXIoKHdhbGxldCkgPT4gIXZpc2libGVXYWxsZXRzKCkuZmluZCgodykgPT4gdy5hcHBOYW1lID09PSB3YWxsZXQuYXBwTmFtZSkpLnNsaWNlKDAsIDQpLCBudWxsKTtcbiAgcmV0dXJuICgoKSA9PiB7XG4gICAgdmFyIF9lbCQgPSBfdG1wbCQyKCk7XG4gICAgaW5zZXJ0KF9lbCQsIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgcmV0dXJuIHNob3dRUigpO1xuICAgICAgfSxcbiAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoU3R5bGVkTGVmdEFjdGlvbkJ1dHRvbiwge1xuICAgICAgICAgIGljb246IFwiYXJyb3dcIixcbiAgICAgICAgICBvbkNsaWNrOiBvbkNsb3NlUVJcbiAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNb2JpbGVVbml2ZXJzYWxRUiwge1xuICAgICAgICAgIGdldCB1bml2ZXJzYWxMaW5rKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFVuaXZlcnNhbExpbmsoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBpc0NvcGllZFNob3duKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQ29waWVkU2hvd24oKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uT3Blbkxpbms6IG9uU2VsZWN0VW5pdmVyc2FsLFxuICAgICAgICAgIG9uQ29weVxuICAgICAgICB9KV07XG4gICAgICB9XG4gICAgfSksIG51bGwpO1xuICAgIGluc2VydChfZWwkLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgIHJldHVybiAhc2hvd1FSKCk7XG4gICAgICB9LFxuICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTdHlsZWRMZWZ0QWN0aW9uQnV0dG9uLCB7XG4gICAgICAgICAgZ2V0IGljb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFFSSWNvbiwge30pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25DbGljazogb25PcGVuUVJcbiAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChIMVN0eWxlZCQ0LCB7XG4gICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwubW9iaWxlVW5pdmVyc2FsTW9kYWwuY29ubmVjdFlvdXJXYWxsZXRcIixcbiAgICAgICAgICBjaGlsZHJlbjogXCJDb25uZWN0IHlvdXIgVE9OIHdhbGxldFwiXG4gICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgcmV0dXJuIGF0V2FsbGV0U3VwcG9ydEZlYXR1cmVzKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChIMlN0eWxlZCQyLCB7XG4gICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLm1vYmlsZVVuaXZlcnNhbE1vZGFsLm9wZW5XYWxsZXRPblRlbGVncmFtT3JTZWxlY3RcIixcbiAgICAgICAgICAgICAgbWF4V2lkdGg6IDMyMCxcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiVXNlIFdhbGxldCBpbiBUZWxlZ3JhbSBvciBjaG9vc2Ugb3RoZXIgYXBwbGljYXRpb25cIlxuICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChUZWxlZ3JhbUJ1dHRvblN0eWxlZCwge1xuICAgICAgICAgICAgICBnZXQgbGVmdEljb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChBdFdhbGxldEljb24sIHt9KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZ2V0IHJpZ2h0SWNvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRHSW1hZ2VTdHlsZWQsIHtcbiAgICAgICAgICAgICAgICAgIGdldCBzcmMoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTUcuVEc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9uQ2xpY2s6IG9uU2VsZWN0VGVsZWdyYW0sXG4gICAgICAgICAgICAgIHNjYWxlOiBcInNcIixcbiAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNsYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLm1vYmlsZVVuaXZlcnNhbE1vZGFsLm9wZW5XYWxsZXRPblRlbGVncmFtXCIsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJDb25uZWN0IFdhbGxldCBpbiBUZWxlZ3JhbVwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoSDJTdHlsZWQkMiwge1xuICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLm1vYmlsZVVuaXZlcnNhbE1vZGFsLmNob29zZU90aGVyQXBwbGljYXRpb25cIixcbiAgICAgICAgICBtYXhXaWR0aDogMzQyLFxuICAgICAgICAgIHBhZGRpbmc6IFwiMCAyNHB4IDhweCAyNHB4XCIsXG4gICAgICAgICAgbWFyZ2luOiBcIjBcIixcbiAgICAgICAgICBjaGlsZHJlbjogXCJDaG9vc2Ugb3RoZXIgYXBwbGljYXRpb25cIlxuICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFdhbGxldFVsQ29udGFpbmVyLCB7XG4gICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoRm9yLCB7XG4gICAgICAgICAgICAgIGdldCBlYWNoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZW1vKCgpID0+ICEhc2hvdWxkU2hvd01vcmVCdXR0b24oKSkoKSA/IHZpc2libGVXYWxsZXRzKCkgOiBzdXBwb3J0ZWRXYWxsZXRzKCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiAod2FsbGV0KSA9PiAoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfZWwkMyA9IF90bXBsJCQxKCk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0KF9lbCQzLCBjcmVhdGVDb21wb25lbnQoV2FsbGV0SXRlbSwge1xuICAgICAgICAgICAgICAgICAgZ2V0IGljb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3YWxsZXQuaW1hZ2VVcmw7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3YWxsZXQubmFtZTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBwcm9wcy5vblNlbGVjdCh3YWxsZXQpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfZWwkMztcbiAgICAgICAgICAgICAgfSkoKVxuICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaG91bGRTaG93TW9yZUJ1dHRvbigpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9lbCQyID0gX3RtcGwkJDEoKTtcbiAgICAgICAgICAgICAgICBpbnNlcnQoX2VsJDIsIGNyZWF0ZUNvbXBvbmVudChGb3VyV2FsbGV0c0l0ZW0sIHtcbiAgICAgICAgICAgICAgICAgIGxhYmVsTGluZTE6IFwiVmlldyBhbGxcIixcbiAgICAgICAgICAgICAgICAgIGxhYmVsTGluZTI6IFwid2FsbGV0c1wiLFxuICAgICAgICAgICAgICAgICAgZ2V0IGltYWdlcygpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdXJXYWxsZXRzSXRlbSgpLm1hcCgoaTIpID0+IGkyLmltYWdlVXJsKTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBwcm9wcy5vblNlbGVjdEFsbFdhbGxldHMoKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2VsJDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXTtcbiAgICAgIH1cbiAgICB9KSwgbnVsbCk7XG4gICAgcmV0dXJuIF9lbCQ7XG4gIH0pKCk7XG59O1xuY29uc3QgYm9yZGVycyQxID0ge1xuICBtOiBcIjE2cHhcIixcbiAgczogXCI4cHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCBob3ZlckJvcmRlcnMgPSB7XG4gIG06IFwiOHB4XCIsXG4gIHM6IFwiNHB4XCIsXG4gIG5vbmU6IFwiMFwiXG59O1xuY29uc3QgRGVza3RvcFVuaXZlcnNhbE1vZGFsU3R5bGVkID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBwYWRkaW5nLWJvdHRvbTogMTZweDtcbmA7XG5jb25zdCBIMlN0eWxlZCA9IHN0eWxlZChIMilgXG4gICAgbWF4LXdpZHRoOiAzMjBweDtcbiAgICBtYXJnaW4tdG9wOiAycHg7XG4gICAgbWFyZ2luLWJvdHRvbTogMjBweDtcbmA7XG5jb25zdCBIMkF2YWlsYWJsZVdhbGxldHNTdHlsZWQgPSBzdHlsZWQoSDIpYFxuICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XG5gO1xuY29uc3QgUVJDb2RlU3R5bGVkID0gc3R5bGVkKFFSQ29kZSlgXG4gICAgbWFyZ2luLWJvdHRvbTogMjRweDtcbmA7XG5jb25zdCBXYWxsZXRzQ29udGFpbmVyU3R5bGVkID0gc3R5bGVkLnVsYFxuICAgIGRpc3BsYXk6IGZsZXg7XG5gO1xuc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGdhcDogMTZweDtcbiAgICB3aWR0aDogMTAwJTtcbmA7XG5zdHlsZWQoQnV0dG9uKWBcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgZm9udC1zaXplOiAxNnB4O1xuICAgIGxpbmUtaGVpZ2h0OiAyMHB4O1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIHBhZGRpbmc6IDAgMTZweDtcbiAgICBoZWlnaHQ6IDU2cHg7XG4gICAgYm9yZGVyLXJhZGl1czogJHsocHJvcHMpID0+IGJvcmRlcnMkMVtwcm9wcy50aGVtZS5ib3JkZXJSYWRpdXNdfTtcblxuICAgICY6aG92ZXIge1xuICAgICAgICAkeyhwcm9wcykgPT4gcHJvcHMuZGlzYWJsZUV2ZW50c0FuaW1hdGlvbiA/IFwidHJhbnNmb3JtOiB1bnNldDtcIiA6IFwiXCJ9XG4gICAgfVxuXG4gICAgJjphY3RpdmUge1xuICAgICAgICAkeyhwcm9wcykgPT4gcHJvcHMuZGlzYWJsZUV2ZW50c0FuaW1hdGlvbiA/IFwidHJhbnNmb3JtOiB1bnNldDtcIiA6IFwiXCJ9XG4gICAgfVxuYDtcbnN0eWxlZC51bGBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYm90dG9tOiAxMDAlO1xuICAgIGxlZnQ6IDA7XG4gICAgbWFyZ2luOiAwO1xuICAgIHBhZGRpbmc6IDhweDtcbiAgICB3aWR0aDogMTg4cHg7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xNnB4KTtcblxuICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5wcmltYXJ5fTtcbiAgICBib3JkZXItcmFkaXVzOiAkeyhwcm9wcykgPT4gYm9yZGVycyQxW3Byb3BzLnRoZW1lLmJvcmRlclJhZGl1c119O1xuICAgIGJveC1zaGFkb3c6IDAgNHB4IDI0cHggcmdiYSgwLCAwLCAwLCAwLjE2KTtcbmA7XG5zdHlsZWQubGlgXG4gICAgcGFkZGluZzogOHB4O1xuXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGdhcDogOHB4O1xuXG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiBob3ZlckJvcmRlcnNbcHJvcHMudGhlbWUuYm9yZGVyUmFkaXVzXX07XG5cbiAgICB0cmFuc2l0aW9uOlxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yLFxuICAgICAgICB0cmFuc2Zvcm0gMC4xcyBlYXNlLWluLW91dDtcblxuICAgICY6aG92ZXIge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmJhY2tncm91bmQuc2Vjb25kYXJ5fTtcbiAgICB9XG5cbiAgICAmOmFjdGl2ZSB7XG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC45Nik7XG4gICAgfVxuYDtcbnN0eWxlZChJbWFnZSlgXG4gICAgd2lkdGg6IDI0cHg7XG4gICAgaGVpZ2h0OiAyNHB4O1xuXG4gICAgYm9yZGVyLXJhZGl1czogNnB4O1xuYDtcbnN0eWxlZC5kaXZgXG4gICAgbWFyZ2luLXRvcDogMjNweDtcbiAgICBtYXJnaW4tYm90dG9tOiAxcHg7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuYDtcbnN0eWxlZChUZXh0KWBcbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeX07XG4gICAgZm9udC1zaXplOiAxNnB4O1xuYDtcbnZhciBfdG1wbCQgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPGxpPmApO1xuY29uc3QgRGVza3RvcFVuaXZlcnNhbE1vZGFsID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IFtwb3B1cE9wZW5lZCwgc2V0UG9wdXBPcGVuZWRdID0gY3JlYXRlU2lnbmFsKGZhbHNlKTtcbiAgY29uc3QgY29ubmVjdG9yID0gYXBwU3RhdGUuY29ubmVjdG9yO1xuICBjb25zdCB3YWxsZXRzQnJpZGdlcyA9IGNyZWF0ZU1lbW8oKCkgPT4gZ2V0VW5pcXVlQnJpZGdlcyhwcm9wcy53YWxsZXRzTGlzdCksIG51bGwsIHtcbiAgICBlcXVhbHM6IGJyaWRnZXNJc0VxdWFsXG4gIH0pO1xuICBzZXRMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvKHtcbiAgICBvcGVuTWV0aG9kOiBcInFyY29kZVwiXG4gIH0pO1xuICBjb25zdCByZXF1ZXN0ID0gY3JlYXRlTWVtbygoKSA9PiBjb25uZWN0b3IuY29ubmVjdCh3YWxsZXRzQnJpZGdlcygpLCBwcm9wcy5hZGRpdGlvbmFsUmVxdWVzdCwge1xuICAgIHRyYWNlSWQ6IHByb3BzLndhbGxldE1vZGFsU3RhdGUudHJhY2VJZFxuICB9KSk7XG4gIGNvbnN0IHN1cHBvcnRlZFdhbGxldHMgPSBjcmVhdGVNZW1vKCgpID0+IHByb3BzLndhbGxldHNMaXN0LmZpbHRlcigod2FsbGV0KSA9PiB3YWxsZXQuaXNTdXBwb3J0UmVxdWlyZWRGZWF0dXJlcyksIG51bGwpO1xuICBjb25zdCB2aXNpYmxlV2FsbGV0cyA9IGNyZWF0ZU1lbW8oKCkgPT4gc3VwcG9ydGVkV2FsbGV0cygpLnNsaWNlKDAsIDMpLCBudWxsKTtcbiAgc2V0TGFzdFZpc2libGVXYWxsZXRzSW5mbyh7XG4gICAgd2FsbGV0c01lbnU6IFwibWFpbl9zY3JlZW5cIixcbiAgICB3YWxsZXRzOiB2aXNpYmxlV2FsbGV0cygpXG4gIH0pO1xuICBjb25zdCBmb3VyV2FsbGV0c0l0ZW0gPSBjcmVhdGVNZW1vKCgpID0+IHByb3BzLndhbGxldHNMaXN0LmZpbHRlcigod2FsbGV0KSA9PiAhdmlzaWJsZVdhbGxldHMoKS5maW5kKCh3KSA9PiB3LmFwcE5hbWUgPT09IHdhbGxldC5hcHBOYW1lKSkuc2xpY2UoMCwgNCksIG51bGwpO1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KERlc2t0b3BVbml2ZXJzYWxNb2RhbFN0eWxlZCwge1xuICAgIG9uQ2xpY2s6ICgpID0+IHNldFBvcHVwT3BlbmVkKGZhbHNlKSxcbiAgICBcImRhdGEtdGMtd2FsbGV0cy1tb2RhbC11bml2ZXJzYWwtZGVza3RvcFwiOiBcInRydWVcIixcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChIMSwge1xuICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5kZXNrdG9wVW5pdmVyc2FsTW9kYWwuY29ubmVjdFlvdXJXYWxsZXRcIixcbiAgICAgICAgY2hpbGRyZW46IFwiQ29ubmVjdCB5b3VyIHdhbGxldFwiXG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEgyU3R5bGVkLCB7XG4gICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmRlc2t0b3BVbml2ZXJzYWxNb2RhbC5zY2FuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIlNjYW4gd2l0aCB5b3VyIG1vYmlsZSB3YWxsZXRcIlxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChRUkNvZGVTdHlsZWQsIHtcbiAgICAgICAgZ2V0IHNvdXJjZVVybCgpIHtcbiAgICAgICAgICByZXR1cm4gYWRkUmV0dXJuU3RyYXRlZ3kocmVxdWVzdCgpLCBcIm5vbmVcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBkaXNhYmxlQ29weSgpIHtcbiAgICAgICAgICByZXR1cm4gcG9wdXBPcGVuZWQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGltYWdlVXJsKCkge1xuICAgICAgICAgIHJldHVybiBJTUcuVE9OO1xuICAgICAgICB9XG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEgyQXZhaWxhYmxlV2FsbGV0c1N0eWxlZCwge1xuICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5kZXNrdG9wVW5pdmVyc2FsTW9kYWwuYXZhaWxhYmxlV2FsbGV0c1wiLFxuICAgICAgICBjaGlsZHJlbjogXCJBdmFpbGFibGUgd2FsbGV0c1wiXG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFdhbGxldHNDb250YWluZXJTdHlsZWQsIHtcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KEZvciwge1xuICAgICAgICAgICAgZ2V0IGVhY2goKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2aXNpYmxlV2FsbGV0cygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiAod2FsbGV0KSA9PiAoKCkgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2VsJCA9IF90bXBsJCgpO1xuICAgICAgICAgICAgICBpbnNlcnQoX2VsJCwgY3JlYXRlQ29tcG9uZW50KFdhbGxldExhYmVsZWRJdGVtLCB7XG4gICAgICAgICAgICAgICAgd2FsbGV0LFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHByb3BzLm9uU2VsZWN0KHdhbGxldClcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICByZXR1cm4gX2VsJDtcbiAgICAgICAgICAgIH0pKClcbiAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEZvdXJXYWxsZXRzSXRlbSwge1xuICAgICAgICAgICAgbGFiZWxMaW5lMTogXCJWaWV3IGFsbFwiLFxuICAgICAgICAgICAgbGFiZWxMaW5lMjogXCJ3YWxsZXRzXCIsXG4gICAgICAgICAgICBnZXQgaW1hZ2VzKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZm91cldhbGxldHNJdGVtKCkubWFwKChpMikgPT4gaTIuaW1hZ2VVcmwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHByb3BzLm9uU2VsZWN0QWxsV2FsbGV0cygpXG4gICAgICAgICAgfSldO1xuICAgICAgICB9XG4gICAgICB9KV07XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBib3JkZXJzID0ge1xuICBtOiBcIjE2cHhcIixcbiAgczogXCI4cHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCBIMVN0eWxlZCQyID0gc3R5bGVkKEgxKWBcbiAgICBtYXgtd2lkdGg6IDI4OHB4O1xuICAgIG1hcmdpbjogMCBhdXRvIDM4cHg7XG5gO1xuY29uc3QgRGVza3RvcEZlYXR1cmVOb3RTdXBwb3J0TW9kYWxTdHlsZWQgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuYDtcbmNvbnN0IFN0eWxlZEljb25CdXR0b24kMSA9IHN0eWxlZChJY29uQnV0dG9uKWBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAxNnB4O1xuICAgIGxlZnQ6IDE2cHg7XG5gO1xuY29uc3QgVGl0bGVTdHlsZWQgPSBzdHlsZWQoSDEpYFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBmb250LXNpemU6IDIwcHg7XG4gICAgbGluZS1oZWlnaHQ6IDI4cHg7XG5gO1xuY29uc3QgRGVzY3JpcHRpb25TdHlsZWQgPSBzdHlsZWQoVGV4dClgXG4gICAgbWFyZ2luLXRvcDogMTJweDtcbiAgICBtYXJnaW4tYm90dG9tOiAyNHB4O1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBtYXgtd2lkdGg6IDM2MHB4O1xuICAgIGZvbnQtd2VpZ2h0OiA0MDA7XG4gICAgY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnl9O1xuYDtcbnN0eWxlZC5idXR0b25gXG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgYm9yZGVyOiBub25lO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgbWFyZ2luOiAwO1xuICAgIGNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmFjY2VudH07XG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGZvbnQ6IGluaGVyaXQ7XG5gO1xuY29uc3QgU3BhY2VyID0gc3R5bGVkLmRpdmBcbiAgICBtYXJnaW4tYm90dG9tOiA0NnB4O1xuYDtcbmNvbnN0IEVycm9ySWNvblN0eWxlZCA9IHN0eWxlZChFcnJvckljb24pYFxuICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XG5gO1xuc3R5bGVkLnVsYFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZ2FwOiA4cHg7XG4gICAgbWFyZ2luLWJvdHRvbTogMjRweDtcbiAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIHBhZGRpbmc6IDA7XG5gO1xuY29uc3QgRGlzY29ubmVjdEJ1dHRvblN0eWxlZCA9IHN0eWxlZChCdXR0b24pYFxuICAgIG1heC13aWR0aDogMzIwcHg7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiA0OHB4O1xuICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICBsaW5lLWhlaWdodDogMjBweDtcbiAgICBib3JkZXItcmFkaXVzOiAkeyhwcm9wcykgPT4gYm9yZGVyc1twcm9wcy50aGVtZS5ib3JkZXJSYWRpdXNdfTtcbiAgICBtYXJnaW4tYm90dG9tOiAyOHB4O1xuYDtcbmNvbnN0IEJvZHlUZXh0U3R5bGVkID0gc3R5bGVkKEgyKWBcbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeX07XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIG1hcmdpbi1ib3R0b206IDIwcHg7XG5gO1xuY29uc3QgQnV0dG9uc0NvbnRhaW5lclN0eWxlZCA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBnYXA6IDhweDtcbiAgICBwYWRkaW5nLWJvdHRvbTogMzFweDtcbmA7XG5jb25zdCBSZXN0b3JlSW5mb01vZGFsU3R5bGVkID0gc3R5bGVkLmRpdmBcbiAgICBtYXJnaW46IDAgOHB4IDE2cHggOHB4O1xuYDtcbmNvbnN0IFN0eWxlZEljb25CdXR0b24gPSBzdHlsZWQoSWNvbkJ1dHRvbilgXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMTZweDtcbiAgICBsZWZ0OiAxNnB4O1xuYDtcbmNvbnN0IEgxU3R5bGVkJDEgPSBzdHlsZWQoSDEpYFxuICAgIG1hcmdpbi1ib3R0b206IDE4cHg7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuYDtcbmNvbnN0IFN0ZXBCbG9jayA9IHN0eWxlZC5kaXZgXG4gICAgcGFkZGluZzogMTZweCAwO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuYDtcbnN0eWxlZC5kaXZgXG4gICAgbWFyZ2luLWJvdHRvbTogMTJweDtcbmA7XG5jb25zdCBIM1N0eWxlZCA9IHN0eWxlZChIMylgXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIG1hcmdpbi1ib3R0b206IDRweDtcbmA7XG5jb25zdCBUZXh0U3R5bGVkJDEgPSBzdHlsZWQoVGV4dClgXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIG1heC13aWR0aDogMzUycHg7XG4gICAgY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnl9O1xuYDtcbmNvbnN0IENpcmNsZU51bWJlciA9IHN0eWxlZC5kaXZgXG4gICAgd2lkdGg6IDQ0cHg7XG4gICAgaGVpZ2h0OiA0NHB4O1xuICAgIGJvcmRlci1yYWRpdXM6IDIwcHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHtcbiAgdmFyIF9hMjtcbiAgcmV0dXJuIChfYTIgPSBwcm9wcy50aGVtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jb2xvcnMuaWNvbi5zZWNvbmRhcnk7XG59fTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgbWFyZ2luLWJvdHRvbTogMTJweDtcbiAgICBmb250LXdlaWdodDogNzAwO1xuICAgIGZvbnQtc2l6ZTogMjJweDtcbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHtcbiAgdmFyIF9hMjtcbiAgcmV0dXJuIChfYTIgPSBwcm9wcy50aGVtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jb2xvcnMudGV4dC5wcmltYXJ5O1xufX07XG5gO1xuY29uc3QgUmVzdG9yZUluZm9Nb2RhbCA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFJlc3RvcmVJbmZvTW9kYWxTdHlsZWQsIHtcbiAgICBcImRhdGEtdGMtd2FsbGV0cy1tb2RhbC1yZXN0b3JlXCI6IFwidHJ1ZVwiLFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFN0eWxlZEljb25CdXR0b24sIHtcbiAgICAgICAgaWNvbjogXCJhcnJvd1wiLFxuICAgICAgICBnZXQgb25DbGljaygpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcHMub25CYWNrQ2xpY2s7XG4gICAgICAgIH1cbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoSDFTdHlsZWQkMSwge1xuICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5yZXN0b3JlSW5mb01vZGFsLnRpdGxlXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIlJlc3RvcmVcIlxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTY3JvbGxDb250YWluZXIsIHtcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFN0ZXBCbG9jaywge1xuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChDaXJjbGVOdW1iZXIsIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCIxXCJcbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChIM1N0eWxlZCwge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLnJlc3RvcmVNb2RhbC5zdGVwMS50aXRsZVwiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkZpbmQgeW91ciBjdXJyZW50IHJlY292ZXJ5IHBocmFzZVwiXG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoVGV4dFN0eWxlZCQxLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwucmVzdG9yZU1vZGFsLnN0ZXAxLnRleHRcIixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJPcGVuIHlvdXIgd2FsbGV0IHNldHRpbmdzIGFuZCBsb2NhdGUgdGhlwqByZWNvdmVyecKgcGhyYXNlXCJcbiAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU3RlcEJsb2NrLCB7XG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KENpcmNsZU51bWJlciwge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIjJcIlxuICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEgzU3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwucmVzdG9yZU1vZGFsLnN0ZXAyLnRpdGxlXCIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiQ29weSB5b3VyIHJlY292ZXJ5IHBocmFzZVwiXG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoVGV4dFN0eWxlZCQxLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwucmVzdG9yZU1vZGFsLnN0ZXAyLnRleHRcIixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJXcml0ZSBpdCBkb3duIG9yIGNvcHkgaXQgdG8gYSBzYWZlIHBsYWNlXCJcbiAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU3RlcEJsb2NrLCB7XG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KENpcmNsZU51bWJlciwge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIjNcIlxuICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEgzU3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwucmVzdG9yZU1vZGFsLnN0ZXAzLnRpdGxlXCIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiUmVzdG9yZSBpbiBhIHN1cHBvcnRlZCB3YWxsZXQgZnJvbcKgdGhlwqBsaXN0wqBiZWxvd1wiXG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoVGV4dFN0eWxlZCQxLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwucmVzdG9yZU1vZGFsLnN0ZXAzLnRleHRcIixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJFbnRlciB0aGUgcmVjb3ZlcnkgcGhyYXNlIHRvIGFjY2VzcyB5b3VyIHdhbGxldFwiXG4gICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KV07XG4gICAgICAgIH1cbiAgICAgIH0pXTtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IERlc2t0b3BGZWF0dXJlTm90U3VwcG9ydE1vZGFsID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IFtzZWxlY3RlZFdhbGxldCwgc2V0U2VsZWN0ZWRXYWxsZXRdID0gY3JlYXRlU2lnbmFsKG51bGwpO1xuICBjb25zdCBbaW5mb01vZGFsT3Blbiwgc2V0SW5mb01vZGFsT3Blbl0gPSBjcmVhdGVTaWduYWwoZmFsc2UpO1xuICBjb25zdCBjdXJyZW50V2FsbGV0VUkgPSBjcmVhdGVNZW1vKCgpID0+IHByb3BzLndhbGxldHNMaXN0LmZpbmQoKHdhbGxldCkgPT4gd2FsbGV0LmFwcE5hbWUgPT09IHByb3BzLmN1cnJlbnRXYWxsZXQuZGV2aWNlLmFwcE5hbWUgfHwgd2FsbGV0Lm5hbWUgPT09IHByb3BzLmN1cnJlbnRXYWxsZXQuZGV2aWNlLmFwcE5hbWUpKTtcbiAgY29uc3QgY3VycmVudFdhbGxldE5hbWUgPSBjcmVhdGVNZW1vKCgpID0+IHtcbiAgICB2YXIgX2EyLCBfYjIsIF9jMiwgX2QyO1xuICAgIGNvbnN0IGFwcE5hbWUgPSAoX2IyID0gKF9hMiA9IGN1cnJlbnRXYWxsZXRVSSgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmFwcE5hbWUpICE9IG51bGwgPyBfYjIgOiBwcm9wcy5jdXJyZW50V2FsbGV0LmRldmljZS5hcHBOYW1lO1xuICAgIGlmIChhcHBOYW1lID09PSBBVF9XQUxMRVRfQVBQX05BTUUpIHtcbiAgICAgIHJldHVybiBcIldhbGxldCBpbiBUZWxlZ3JhbVwiO1xuICAgIH1cbiAgICByZXR1cm4gKF9kMiA9IChfYzIgPSBjdXJyZW50V2FsbGV0VUkoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jMi5uYW1lKSAhPSBudWxsID8gX2QyIDogcHJvcHMuY3VycmVudFdhbGxldC5kZXZpY2UuYXBwTmFtZTtcbiAgfSk7XG4gIGNvbnN0IGN1cnJlbnRXYWxsZXRWZXJzaW9uTm90U3VwcG9ydGVkID0gY3JlYXRlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgY3VycmVudFdhbGxldFVJVmFyID0gY3VycmVudFdhbGxldFVJKCk7XG4gICAgaWYgKCEoY3VycmVudFdhbGxldFVJVmFyID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50V2FsbGV0VUlWYXIuZmVhdHVyZXMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVpcmVkRmVhdHVyZSA9IHByb3BzLndhbGxldHNNb2RhbFN0YXRlLnJlcXVpcmVkRmVhdHVyZTtcbiAgICBjb25zdCByZXF1aXJlZEZlYXR1cmVzID0gcmVxdWlyZWRGZWF0dXJlID8ge1xuICAgICAgW3JlcXVpcmVkRmVhdHVyZS5mZWF0dXJlTmFtZV06IHJlcXVpcmVkRmVhdHVyZS52YWx1ZVxuICAgIH0gOiB7fTtcbiAgICBjb25zdCB2YWxpZEluTGlzdCA9IGNoZWNrUmVxdWlyZWRXYWxsZXRGZWF0dXJlcyhjdXJyZW50V2FsbGV0VUlWYXIuZmVhdHVyZXMsIHJlcXVpcmVkRmVhdHVyZXMpO1xuICAgIGNvbnN0IHZhbGlkQ3VycmVudFdhbGxldCA9IGNoZWNrUmVxdWlyZWRXYWxsZXRGZWF0dXJlcyhwcm9wcy5jdXJyZW50V2FsbGV0LmRldmljZS5mZWF0dXJlcywgcmVxdWlyZWRGZWF0dXJlcyk7XG4gICAgcmV0dXJuIHZhbGlkSW5MaXN0ICYmICF2YWxpZEN1cnJlbnRXYWxsZXQ7XG4gIH0pO1xuICBjb25zdCBoYW5kbGVEaXNjb25uZWN0ID0gKCkgPT4gX19hc3luYyhudWxsLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIHlpZWxkIHByb3BzLm9uRGlzY29ubmVjdCgpO1xuICAgIHByb3BzLm9uU2VsZWN0KHNlbGVjdGVkV2FsbGV0KCkpO1xuICB9KTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChEZXNrdG9wRmVhdHVyZU5vdFN1cHBvcnRNb2RhbFN0eWxlZCwge1xuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoU3dpdGNoLCB7XG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbmZvTW9kYWxPcGVuKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFJlc3RvcmVJbmZvTW9kYWwsIHtcbiAgICAgICAgICAgICAgICBvbkJhY2tDbGljazogKCkgPT4gc2V0SW5mb01vZGFsT3BlbihmYWxzZSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZFdhbGxldCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoU3BhY2VyLCB7fSksIGNyZWF0ZUNvbXBvbmVudChEZXNrdG9wRmVhdHVyZU5vdFN1cHBvcnRNb2RhbFN0eWxlZCwge1xuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFN0eWxlZEljb25CdXR0b24kMSwge1xuICAgICAgICAgICAgICAgICAgICBpY29uOiBcImFycm93XCIsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHNldFNlbGVjdGVkV2FsbGV0KG51bGwpXG4gICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFRpdGxlU3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmZlYXR1cmVOb3RTdXBwb3J0ZWQuZGlzY29ubmVjdC50aXRsZVwiLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJDb25maXJtIERpc2Nvbm5lY3RcIlxuICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChEZXNjcmlwdGlvblN0eWxlZCwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5mZWF0dXJlTm90U3VwcG9ydGVkLmRpc2Nvbm5lY3QuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzZWxlY3RlZFdhbGxldCgpLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcIllvdSB3aWxsIGJlIGRpc2Nvbm5lY3RlZCBmcm9tIHlvdXIgY3VycmVudCB3YWxsZXQgYW5kIHJlZGlyZWN0ZWQgdG8gY29ubmVjdCBcIiwgbWVtbygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfYTIgPSBzZWxlY3RlZFdhbGxldCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgfSksIFwiLlwiXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChEaXNjb25uZWN0QnV0dG9uU3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IGhhbmRsZURpc2Nvbm5lY3QoKSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNsYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmZlYXR1cmVOb3RTdXBwb3J0ZWQuZGlzY29ubmVjdC5idXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkRpc2Nvbm5lY3RcIlxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjdXJyZW50V2FsbGV0VmVyc2lvbk5vdFN1cHBvcnRlZCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoSDFTdHlsZWQkMiwge1xuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50V2FsbGV0TmFtZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChFcnJvckljb25TdHlsZWQsIHtcbiAgICAgICAgICAgICAgICBzaXplOiBcInNcIlxuICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEJvZHlUZXh0U3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwuZmVhdHVyZU5vdFN1cHBvcnRlZC52ZXJzaW9uLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICAgICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogY3VycmVudFdhbGxldE5hbWUoKVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJZb3VyIGN1cnJlbnQgdmVyc2lvbiBvZiBcIiwgbWVtbygoKSA9PiBjdXJyZW50V2FsbGV0TmFtZSgpKSwgXCIgb3Igd2FsbGV0IGNvbnRyYWN0IHR5cGUgZG9lc24ndCBzdXBwb3J0IHRoZSByZXF1aXJlZCBmZWF0dXJlcy4gUGxlYXNlIHVwZGF0ZSBpdCB0byBjb250aW51ZS5cIl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEJ1dHRvbnNDb250YWluZXJTdHlsZWQsIHtcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChMaW5rLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCBocmVmKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50V2FsbGV0VUkoKS5hYm91dFVybDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYmxhbms6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGxlZnRJY29uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KExpbmtJY29uLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwuZmVhdHVyZU5vdFN1cHBvcnRlZC52ZXJzaW9uLnVwZGF0ZUJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGN1cnJlbnRXYWxsZXROYW1lKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiVXBkYXRlIFwiLCBtZW1vKCgpID0+IGN1cnJlbnRXYWxsZXROYW1lKCkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KExpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogXCJodHRwczovL3RvbmtlZXBlci5oZWxwc2NvdXRkb2NzLmNvbS9hcnRpY2xlLzEwMi13NVwiLFxuICAgICAgICAgICAgICAgICAgICBibGFuazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQnV0dG9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgbGVmdEljb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoTGlua0ljb24sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNsYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5mZWF0dXJlTm90U3VwcG9ydGVkLnZlcnNpb24uYWJvdXRXNVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkFib3V0IFc1XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICB3aGVuOiB0cnVlLFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTcGFjZXIsIHt9KSwgY3JlYXRlQ29tcG9uZW50KEVycm9ySWNvblN0eWxlZCwge1xuICAgICAgICAgICAgICAgIHNpemU6IFwic1wiXG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoVGl0bGVTdHlsZWQsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5mZWF0dXJlTm90U3VwcG9ydGVkLndhbGxldC50aXRsZVwiLFxuICAgICAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGN1cnJlbnRXYWxsZXROYW1lKClcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW21lbW8oKCkgPT4gY3VycmVudFdhbGxldE5hbWUoKSksIFwiIGRvZXNu4oCZdCBzdXBwb3J0IHRoZSByZXF1ZXN0ZWTCoGFjdGlvblwiXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU3BhY2VyLCB7fSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBXYWxsZXRzTW9kYWwgPSAoKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBsb2NhbGVcbiAgfSA9IHVzZUkxOG4oKVsxXTtcbiAgY3JlYXRlRWZmZWN0KCgpID0+IGxvY2FsZShhcHBTdGF0ZS5sYW5ndWFnZSkpO1xuICBjcmVhdGVFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChnZXRXYWxsZXRzTW9kYWxJc09wZW5lZCgpKSB7XG4gICAgICB1cGRhdGVJc01vYmlsZSgpO1xuICAgICAgcmVmZXRjaFdhbGxldHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0U2VsZWN0ZWRXYWxsZXRJbmZvKG51bGwpO1xuICAgICAgc2V0U2VsZWN0ZWRUYWIoXCJ1bml2ZXJzYWxcIik7XG4gICAgICBzZXRJbmZvVGFiKGZhbHNlKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBjb25uZWN0b3IgPSB1c2VDb250ZXh0KENvbm5lY3RvckNvbnRleHQpO1xuICBjb25zdCB0b25Db25uZWN0VUkgPSB1c2VDb250ZXh0KFRvbkNvbm5lY3RVaUNvbnRleHQpO1xuICBjb25zdCBbZmV0Y2hlZFdhbGxldHNMaXN0LCB7XG4gICAgcmVmZXRjaDogcmVmZXRjaFdhbGxldHNcbiAgfV0gPSBjcmVhdGVSZXNvdXJjZSgoKSA9PiB7XG4gICAgcmV0dXJuIHRvbkNvbm5lY3RVSS5nZXRXYWxsZXRzKCk7XG4gIH0pO1xuICBjb25zdCBbc2VsZWN0ZWRXYWxsZXRJbmZvLCBzZXRTZWxlY3RlZFdhbGxldEluZm9dID0gY3JlYXRlU2lnbmFsKG51bGwpO1xuICBjb25zdCBbc2VsZWN0ZWRXYWxsZXRFcnJvciwgc2V0U2VsZWN0ZWRXYWxsZXRFcnJvcl0gPSBjcmVhdGVTaWduYWwobnVsbCk7XG4gIGNvbnN0IFtzZWxlY3RlZFRhYiwgc2V0U2VsZWN0ZWRUYWJdID0gY3JlYXRlU2lnbmFsKFwidW5pdmVyc2FsXCIpO1xuICBjb25zdCBbaW5mb1RhYiwgc2V0SW5mb1RhYl0gPSBjcmVhdGVTaWduYWwoZmFsc2UpO1xuICBjb25zdCB3YWxsZXRzTW9kYWxJc1dhbGxldE5vdFN1cHBvcnRGZWF0dXJlID0gY3JlYXRlTWVtbygoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSB3YWxsZXRzTW9kYWxTdGF0ZSgpO1xuICAgIHJldHVybiBcInR5cGVcIiBpbiBzdGF0ZSAmJiBzdGF0ZS50eXBlID09PSBcIndhbGxldC1ub3Qtc3VwcG9ydC1mZWF0dXJlXCI7XG4gIH0pO1xuICBjb25zdCB3YWxsZXRzTGlzdCA9IGNyZWF0ZU1lbW8oKCkgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKGZldGNoZWRXYWxsZXRzTGlzdC5zdGF0ZSAhPT0gXCJyZWFkeVwiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IHdhbGxldHNMaXN0MiA9IGFwcGx5V2FsbGV0c0xpc3RDb25maWd1cmF0aW9uKGZldGNoZWRXYWxsZXRzTGlzdCgpLCBhcHBTdGF0ZS53YWxsZXRzTGlzdENvbmZpZ3VyYXRpb24pO1xuICAgIGNvbnN0IGluamVjdGVkV2FsbGV0cyA9IHdhbGxldHNMaXN0Mi5maWx0ZXIoaXNXYWxsZXRJbmZvQ3VycmVudGx5SW5qZWN0ZWQpO1xuICAgIGNvbnN0IG5vdEluamVjdGVkV2FsbGV0cyA9IHdhbGxldHNMaXN0Mi5maWx0ZXIoKHcpID0+ICFpc1dhbGxldEluZm9DdXJyZW50bHlJbmplY3RlZCh3KSk7XG4gICAgd2FsbGV0c0xpc3QyID0gKGluamVjdGVkV2FsbGV0cyB8fCBbXSkuY29uY2F0KG5vdEluamVjdGVkV2FsbGV0cyk7XG4gICAgY29uc3QgcHJlZmVycmVkV2FsbGV0QXBwTmFtZSA9IGFwcFN0YXRlLnByZWZlcnJlZFdhbGxldEFwcE5hbWU7XG4gICAgY29uc3QgcHJlZmVycmVkV2FsbGV0ID0gd2FsbGV0c0xpc3QyLmZpbmQoKGl0ZW0pID0+IGVxV2FsbGV0TmFtZShpdGVtLCBwcmVmZXJyZWRXYWxsZXRBcHBOYW1lKSk7XG4gICAgY29uc3Qgc29tZVdhbGxldHNXaXRoU2FtZU5hbWUgPSB3YWxsZXRzTGlzdDIuZmlsdGVyKChpdGVtKSA9PiBlcVdhbGxldE5hbWUoaXRlbSwgcHJlZmVycmVkV2FsbGV0QXBwTmFtZSkpLmxlbmd0aCA+PSAyO1xuICAgIGlmIChwcmVmZXJyZWRXYWxsZXRBcHBOYW1lICYmIHByZWZlcnJlZFdhbGxldCAmJiAhc29tZVdhbGxldHNXaXRoU2FtZU5hbWUpIHtcbiAgICAgIHdhbGxldHNMaXN0MiA9IFtfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcmVmZXJyZWRXYWxsZXQpLCB7XG4gICAgICAgIGlzUHJlZmVycmVkOiB0cnVlXG4gICAgICB9KV0uY29uY2F0KHdhbGxldHNMaXN0Mi5maWx0ZXIoKGl0ZW0pID0+ICFlcVdhbGxldE5hbWUoaXRlbSwgcHJlZmVycmVkV2FsbGV0QXBwTmFtZSkpKTtcbiAgICB9XG4gICAgY29uc3QgYXRXYWxsZXQgPSB3YWxsZXRzTGlzdDIuZmluZCgoaXRlbSkgPT4gZXFXYWxsZXROYW1lKGl0ZW0sIEFUX1dBTExFVF9BUFBfTkFNRSkpO1xuICAgIGlmIChhdFdhbGxldCkge1xuICAgICAgd2FsbGV0c0xpc3QyID0gW2F0V2FsbGV0XS5jb25jYXQod2FsbGV0c0xpc3QyLmZpbHRlcigoaXRlbSkgPT4gIWVxV2FsbGV0TmFtZShpdGVtLCBBVF9XQUxMRVRfQVBQX05BTUUpKSk7XG4gICAgfVxuICAgIGNvbnN0IHdhbGxldHNGZWF0dXJlc1JlcXVlc3RlZCA9IChfYTIgPSB0b25Db25uZWN0VUkgPT0gbnVsbCA/IHZvaWQgMCA6IHRvbkNvbm5lY3RVSS53YWxsZXRzUmVxdWlyZWRGZWF0dXJlcykgIT0gbnVsbCA/IF9hMiA6IHRvbkNvbm5lY3RVSSA9PSBudWxsID8gdm9pZCAwIDogdG9uQ29ubmVjdFVJLndhbGxldHNQcmVmZXJyZWRGZWF0dXJlcztcbiAgICBjb25zdCB1aVdhbGxldHMgPSB3YWxsZXRzTGlzdDIubWFwKCh3YWxsZXQpID0+IHtcbiAgICAgIHZhciBfYTM7XG4gICAgICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgd2FsbGV0KSwge1xuICAgICAgICBpc1N1cHBvcnRSZXF1aXJlZEZlYXR1cmVzOiB3YWxsZXRzRmVhdHVyZXNSZXF1ZXN0ZWQgPyBjaGVja1JlcXVpcmVkV2FsbGV0RmVhdHVyZXMoKF9hMyA9IHdhbGxldC5mZWF0dXJlcykgIT0gbnVsbCA/IF9hMyA6IFtdLCB3YWxsZXRzRmVhdHVyZXNSZXF1ZXN0ZWQpIDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHVpV2FsbGV0cztcbiAgfSk7XG4gIGNvbnN0IGFkZGl0aW9uYWxSZXF1ZXN0TG9hZGluZyA9ICgpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIHJldHVybiAoKF9hMiA9IGFwcFN0YXRlLmNvbm5lY3RSZXF1ZXN0UGFyYW1ldGVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5zdGF0ZSkgPT09IFwibG9hZGluZ1wiO1xuICB9O1xuICBjb25zdCBhZGRpdGlvbmFsUmVxdWVzdCA9IGNyZWF0ZU1lbW8oKCkgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKGFkZGl0aW9uYWxSZXF1ZXN0TG9hZGluZygpKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gKF9hMiA9IGFwcFN0YXRlLmNvbm5lY3RSZXF1ZXN0UGFyYW1ldGVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi52YWx1ZTtcbiAgfSk7XG4gIGNvbnN0IG9uQ2xvc2UgPSAoY2xvc2VSZWFzb24pID0+IHtcbiAgICB0b25Db25uZWN0VUkuY2xvc2VNb2RhbChjbG9zZVJlYXNvbik7XG4gIH07XG4gIGNvbnN0IHVuc3Vic2NyaWJlID0gY29ubmVjdG9yLm9uU3RhdHVzQ2hhbmdlKCh3YWxsZXQpID0+IHtcbiAgICBpZiAod2FsbGV0KSB7XG4gICAgICBvbkNsb3NlKFwid2FsbGV0LXNlbGVjdGVkXCIpO1xuICAgIH1cbiAgfSwgKGVycikgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIFdhbGxldE1pc3NpbmdSZXF1aXJlZEZlYXR1cmVzRXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yQXBwTmFtZSA9IGVyci5jYXVzZS5jb25uZWN0RXZlbnQuZGV2aWNlLmFwcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IHdhbGxldCA9IChfYTIgPSB3YWxsZXRzTGlzdCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmZpbmQoKHcpID0+IHcuYXBwTmFtZS50b0xvd2VyQ2FzZSgpID09PSBlcnJvckFwcE5hbWUpO1xuICAgICAgaWYgKCF3YWxsZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcihcIldhbGxldCBub3QgZm91bmRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCB3YWxsZXRFcnJvclR5cGUgPSB3YWxsZXQuaXNTdXBwb3J0UmVxdWlyZWRGZWF0dXJlcyA/IFwibWlzc2luZy1mZWF0dXJlc1wiIDogXCJub3Qtc3VwcG9ydGVkXCI7XG4gICAgICBzZXRTZWxlY3RlZFdhbGxldEVycm9yKHdhbGxldEVycm9yVHlwZSk7XG4gICAgICBzZXRTZWxlY3RlZFdhbGxldEluZm8od2FsbGV0KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBvblNlbGVjdEFsbFdhbGxldHMgPSAoKSA9PiB7XG4gICAgc2V0U2VsZWN0ZWRUYWIoXCJhbGwtd2FsbGV0c1wiKTtcbiAgfTtcbiAgY29uc3Qgb25TZWxlY3RVbml2ZXJzYWwgPSAoKSA9PiB7XG4gICAgc2V0U2VsZWN0ZWRUYWIoXCJ1bml2ZXJzYWxcIik7XG4gIH07XG4gIGNvbnN0IG9uU2VsZWN0V2FsbGV0ID0gKHdhbGxldCkgPT4ge1xuICAgIHNldFNlbGVjdGVkV2FsbGV0SW5mbyh3YWxsZXQpO1xuICAgIHdpZGdldENvbnRyb2xsZXIub3BlbldhbGxldHNNb2RhbCgpO1xuICB9O1xuICBjb25zdCBjbGVhclNlbGVjdGVkV2FsbGV0SW5mbyA9ICgpID0+IHtcbiAgICBzZXRTZWxlY3RlZFdhbGxldEluZm8obnVsbCk7XG4gICAgc2V0U2VsZWN0ZWRXYWxsZXRFcnJvcihudWxsKTtcbiAgfTtcbiAgb25DbGVhbnVwKCgpID0+IHtcbiAgICBzZXRTZWxlY3RlZFdhbGxldEluZm8obnVsbCk7XG4gICAgc2V0U2VsZWN0ZWRXYWxsZXRFcnJvcihudWxsKTtcbiAgICBzZXRJbmZvVGFiKGZhbHNlKTtcbiAgfSk7XG4gIG9uQ2xlYW51cCh1bnN1YnNjcmliZSk7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoU3R5bGVkTW9kYWwsIHtcbiAgICBnZXQgb3BlbmVkKCkge1xuICAgICAgcmV0dXJuIGdldFdhbGxldHNNb2RhbElzT3BlbmVkKCk7XG4gICAgfSxcbiAgICBnZXQgZW5hYmxlQW5kcm9pZEJhY2tIYW5kbGVyKCkge1xuICAgICAgcmV0dXJuIGFwcFN0YXRlLmVuYWJsZUFuZHJvaWRCYWNrSGFuZGxlcjtcbiAgICB9LFxuICAgIG9uQ2xvc2U6ICgpID0+IG9uQ2xvc2UoXCJhY3Rpb24tY2FuY2VsbGVkXCIpLFxuICAgIG9uQ2xpY2tRdWVzdGlvbjogKCkgPT4gc2V0SW5mb1RhYigodikgPT4gIXYpLFxuICAgIGdldCBzaG93Rm9vdGVyKCkge1xuICAgICAgcmV0dXJuICF3YWxsZXRzTW9kYWxJc1dhbGxldE5vdFN1cHBvcnRGZWF0dXJlKCk7XG4gICAgfSxcbiAgICBcImRhdGEtdGMtd2FsbGV0cy1tb2RhbC1jb250YWluZXJcIjogXCJ0cnVlXCIsXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICByZXR1cm4gaW5mb1RhYigpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChJbmZvTW9kYWwsIHtcbiAgICAgICAgICAgIG9uQmFja0NsaWNrOiAoKSA9PiBzZXRJbmZvVGFiKGZhbHNlKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgcmV0dXJuICFpbmZvVGFiKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFkZGl0aW9uYWxSZXF1ZXN0TG9hZGluZygpIHx8ICF3YWxsZXRzTGlzdCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoSDFTdHlsZWQkYSwge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmxvYWRpbmdcIixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJXYWxsZXRzIGxpc3QgaXMgbG9hZGluZ1wiXG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTG9hZGVyQ29udGFpbmVyU3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChMb2FkZXJJY29uLCB7XG4gICAgICAgICAgICAgICAgICAgIHNpemU6IFwibVwiXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gbWVtbygoKSA9PiAhISFhZGRpdGlvbmFsUmVxdWVzdExvYWRpbmcoKSkoKSAmJiB3YWxsZXRzTGlzdCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChTd2l0Y2gsIHtcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2FsbGV0c01vZGFsSXNXYWxsZXROb3RTdXBwb3J0RmVhdHVyZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChEZXNrdG9wRmVhdHVyZU5vdFN1cHBvcnRNb2RhbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHdhbGxldHNMaXN0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2FsbGV0c0xpc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgY3VycmVudFdhbGxldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvbkNvbm5lY3RVSSA9PSBudWxsID8gdm9pZCAwIDogdG9uQ29ubmVjdFVJLndhbGxldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvblNlbGVjdDogb25TZWxlY3RXYWxsZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvblNlbGVjdEFsbFdhbGxldHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkRpc2Nvbm5lY3Q6ICgpID0+IGNvbm5lY3Rvci5kaXNjb25uZWN0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2FsbGV0c01vZGFsU3RhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3YWxsZXRzTW9kYWxTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U6ICgpID0+IG9uQ2xvc2UoXCJhY3Rpb24tY2FuY2VsbGVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkV2FsbGV0SW5mbygpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChEeW5hbWljLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgY29tcG9uZW50KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNNb2JpbGUoKSA/IE1vYmlsZUNvbm5lY3Rpb25Nb2RhbCA6IERlc2t0b3BDb25uZWN0aW9uTW9kYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHdhbGxldHNNb2RhbFN0YXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2FsbGV0c01vZGFsU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2FsbGV0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWRXYWxsZXRJbmZvKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGFkZGl0aW9uYWxSZXF1ZXN0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkaXRpb25hbFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkJhY2tDbGljazogY2xlYXJTZWxlY3RlZFdhbGxldEluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgZGVmYXVsdEVycm9yKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWRXYWxsZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZFRhYigpID09PSBcInVuaXZlcnNhbFwiO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChEeW5hbWljLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgY29tcG9uZW50KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNNb2JpbGUoKSA/IE1vYmlsZVVuaXZlcnNhbE1vZGFsIDogRGVza3RvcFVuaXZlcnNhbE1vZGFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0OiBzZXRTZWxlY3RlZFdhbGxldEluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2FsbGV0TW9kYWxTdGF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGxldHNNb2RhbFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHdhbGxldHNMaXN0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2FsbGV0c0xpc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgYWRkaXRpb25hbFJlcXVlc3QoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRpdGlvbmFsUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0QWxsV2FsbGV0c1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZFRhYigpID09PSBcImFsbC13YWxsZXRzXCI7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEFsbFdhbGxldHNMaXN0TW9kYWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCB3YWxsZXRzTGlzdCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGxldHNMaXN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGZlYXR1cmVDaGVja01vZGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAodG9uQ29ubmVjdFVJID09IG51bGwgPyB2b2lkIDAgOiB0b25Db25uZWN0VUkud2FsbGV0c1JlcXVpcmVkRmVhdHVyZXMpID8gXCJzdHJpY3RcIiA6IFwic29mdFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQmFjazogb25TZWxlY3RVbml2ZXJzYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBvblNlbGVjdDogc2V0U2VsZWN0ZWRXYWxsZXRJbmZvXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXTtcbiAgICAgICAgfVxuICAgICAgfSldO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3QgQWN0aW9uTW9kYWxTdHlsZWQgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIHBhZGRpbmctYm90dG9tOiA4cHg7XG5gO1xuY29uc3QgSDFTdHlsZWQgPSBzdHlsZWQoSDEpYFxuICAgIG1hcmdpbi10b3A6IDE2cHg7XG5gO1xuY29uc3QgVGV4dFN0eWxlZCA9IHN0eWxlZChUZXh0KWBcbiAgICBmb250LXdlaWdodDogNTEwO1xuICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICBsaW5lLWhlaWdodDogMjBweDtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgbWF4LXdpZHRoOiAyNTBweDtcblxuICAgIGNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5fTtcbmA7XG5jb25zdCBMb2FkZXJCdXR0b25TdHlsZWQgPSBzdHlsZWQoQnV0dG9uKWBcbiAgICBtaW4td2lkdGg6IDExMnB4O1xuICAgIG1hcmdpbi10b3A6IDMycHg7XG5gO1xuY29uc3QgTG9hZGVySWNvblN0eWxlZCA9IHN0eWxlZChMb2FkZXJJY29uKWBcbiAgICBoZWlnaHQ6IDE2cHg7XG4gICAgd2lkdGg6IDE2cHg7XG5gO1xuY29uc3QgQnV0dG9uU3R5bGVkID0gc3R5bGVkKEJ1dHRvbilgXG4gICAgbWFyZ2luLXRvcDogMzJweDtcbmA7XG5jb25zdCBBY3Rpb25Nb2RhbCA9IChwcm9wcykgPT4ge1xuICBjb25zdCBkYXRhQXR0cnMgPSB1c2VEYXRhQXR0cmlidXRlcyhwcm9wcyk7XG4gIGNvbnN0IHRvbkNvbm5lY3RVSSA9IHVzZUNvbnRleHQoVG9uQ29ubmVjdFVpQ29udGV4dCk7XG4gIGNvbnN0IFtmaXJzdENsaWNrLCBzZXRGaXJzdENsaWNrXSA9IGNyZWF0ZVNpZ25hbCh0cnVlKTtcbiAgY29uc3QgW3NlbnQsIHNldFNlbnRdID0gY3JlYXRlU2lnbmFsKGZhbHNlKTtcbiAgY29uc3QgW3NpZ25lZCwgc2V0U2lnbmVkXSA9IGNyZWF0ZVNpZ25hbChmYWxzZSk7XG4gIGNvbnN0IFtjYW5jZWxlZCwgc2V0Q2FuY2VsZWRdID0gY3JlYXRlU2lnbmFsKGZhbHNlKTtcbiAgY3JlYXRlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50QWN0aW9uID0gYWN0aW9uKCk7XG4gICAgc2V0U2VudCghIWN1cnJlbnRBY3Rpb24gJiYgKFwic2VudFwiIGluIGN1cnJlbnRBY3Rpb24gJiYgY3VycmVudEFjdGlvbi5zZW50IHx8IGN1cnJlbnRBY3Rpb24ubmFtZSA9PT0gXCJ0cmFuc2FjdGlvbi1zZW50XCIpKTtcbiAgICBzZXRTaWduZWQoISFjdXJyZW50QWN0aW9uICYmIChcInNpZ25lZFwiIGluIGN1cnJlbnRBY3Rpb24gJiYgY3VycmVudEFjdGlvbi5zaWduZWQgfHwgY3VycmVudEFjdGlvbi5uYW1lID09PSBcImRhdGEtc2lnbmVkXCIpKTtcbiAgICBzZXRDYW5jZWxlZCghIWN1cnJlbnRBY3Rpb24gJiYgKGN1cnJlbnRBY3Rpb24ubmFtZSA9PT0gXCJ0cmFuc2FjdGlvbi1jYW5jZWxlZFwiIHx8IGN1cnJlbnRBY3Rpb24ubmFtZSA9PT0gXCJzaWduLWRhdGEtY2FuY2VsZWRcIikpO1xuICB9KTtcbiAgbGV0IHVuaXZlcnNhbExpbms7XG4gIGlmICgodG9uQ29ubmVjdFVJID09IG51bGwgPyB2b2lkIDAgOiB0b25Db25uZWN0VUkud2FsbGV0KSAmJiBcInVuaXZlcnNhbExpbmtcIiBpbiB0b25Db25uZWN0VUkud2FsbGV0ICYmICh0b25Db25uZWN0VUkud2FsbGV0Lm9wZW5NZXRob2QgPT09IFwidW5pdmVyc2FsLWxpbmtcIiB8fCBpc1RlbGVncmFtVXJsKHRvbkNvbm5lY3RVSS53YWxsZXQudW5pdmVyc2FsTGluaykgJiYgaXNJblRNQSgpKSkge1xuICAgIHVuaXZlcnNhbExpbmsgPSB0b25Db25uZWN0VUkud2FsbGV0LnVuaXZlcnNhbExpbms7XG4gIH1cbiAgbGV0IGRlZXBMaW5rO1xuICBpZiAoKHRvbkNvbm5lY3RVSSA9PSBudWxsID8gdm9pZCAwIDogdG9uQ29ubmVjdFVJLndhbGxldCkgJiYgXCJkZWVwTGlua1wiIGluIHRvbkNvbm5lY3RVSS53YWxsZXQgJiYgKHRvbkNvbm5lY3RVSS53YWxsZXQub3Blbk1ldGhvZCA9PT0gXCJjdXN0b20tZGVlcGxpbmtcIiB8fCBpc1RlbGVncmFtVXJsKHRvbkNvbm5lY3RVSS53YWxsZXQuZGVlcExpbmspICYmIGlzSW5UTUEoKSkpIHtcbiAgICBkZWVwTGluayA9IHRvbkNvbm5lY3RVSS53YWxsZXQuZGVlcExpbms7XG4gIH1cbiAgY29uc3Qgb25PcGVuV2FsbGV0ID0gKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRBY3Rpb24gPSBhY3Rpb24oKTtcbiAgICBjb25zdCByZXR1cm5TdHJhdGVneSA9IFwicmV0dXJuU3RyYXRlZ3lcIiBpbiBjdXJyZW50QWN0aW9uID8gY3VycmVudEFjdGlvbi5yZXR1cm5TdHJhdGVneSA6IGFwcFN0YXRlLnJldHVyblN0cmF0ZWd5O1xuICAgIGNvbnN0IGZvcmNlUmVkaXJlY3QgPSAhZmlyc3RDbGljaygpO1xuICAgIHNldEZpcnN0Q2xpY2soZmFsc2UpO1xuICAgIGNvbnN0IGxpbmtXaXRoU2Vzc2lvbklkID0gZW5yaWNoVW5pdmVyc2FsTGluayh1bml2ZXJzYWxMaW5rLCB7XG4gICAgICBzZXNzaW9uSWQ6IGN1cnJlbnRBY3Rpb24uc2Vzc2lvbklkLFxuICAgICAgdHJhY2VJZDogY3VycmVudEFjdGlvbi50cmFjZUlkXG4gICAgfSk7XG4gICAgaWYgKGlzVGVsZWdyYW1VcmwodW5pdmVyc2FsTGluaykpIHtcbiAgICAgIHJlZGlyZWN0VG9UZWxlZ3JhbShsaW5rV2l0aFNlc3Npb25JZCwge1xuICAgICAgICByZXR1cm5TdHJhdGVneSxcbiAgICAgICAgdHdhUmV0dXJuVXJsOiBcInR3YVJldHVyblVybFwiIGluIGN1cnJlbnRBY3Rpb24gPyBjdXJyZW50QWN0aW9uLnR3YVJldHVyblVybCA6IGFwcFN0YXRlLnR3YVJldHVyblVybCxcbiAgICAgICAgZm9yY2VSZWRpcmVjdFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZGlyZWN0VG9XYWxsZXQobGlua1dpdGhTZXNzaW9uSWQsIGRlZXBMaW5rLCB7XG4gICAgICAgIHJldHVyblN0cmF0ZWd5LFxuICAgICAgICBmb3JjZVJlZGlyZWN0XG4gICAgICB9LCAoKSA9PiB7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoQWN0aW9uTW9kYWxTdHlsZWQsIG1lcmdlUHJvcHMoZGF0YUF0dHJzLCB7XG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIFttZW1vKCgpID0+IHByb3BzLmljb24pLCBjcmVhdGVDb21wb25lbnQoSDFTdHlsZWQsIHtcbiAgICAgICAgZ2V0IHRyYW5zbGF0aW9uS2V5KCkge1xuICAgICAgICAgIHJldHVybiBwcm9wcy5oZWFkZXJUcmFuc2xhdGlvbktleTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wcy5oZWFkZXJUcmFuc2xhdGlvblZhbHVlcztcbiAgICAgICAgfVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChUZXh0U3R5bGVkLCB7XG4gICAgICAgIGdldCB0cmFuc2xhdGlvbktleSgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcHMudGV4dFRyYW5zbGF0aW9uS2V5O1xuICAgICAgICB9LFxuICAgICAgICBnZXQgdHJhbnNsYXRpb25WYWx1ZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLnRleHRUcmFuc2xhdGlvblZhbHVlcztcbiAgICAgICAgfVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgIHJldHVybiAhc2VudCgpICYmICFzaWduZWQoKSAmJiAhY2FuY2VsZWQoKSAmJiAocHJvcHMuc2hvd0J1dHRvbiA9PT0gXCJvcGVuLXdhbGxldFwiICYmIHVuaXZlcnNhbExpbmsgfHwgcHJvcHMuc2hvd0J1dHRvbiAhPT0gXCJvcGVuLXdhbGxldFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoTG9hZGVyQnV0dG9uU3R5bGVkLCB7XG4gICAgICAgICAgICBkaXNhYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIFwiZGF0YS10Yy1jb25uZWN0LWJ1dHRvbi1sb2FkaW5nXCI6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KExvYWRlckljb25TdHlsZWQsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgIHJldHVybiBzZW50KCkgfHwgc2lnbmVkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLnNob3dCdXR0b24gIT09IFwib3Blbi13YWxsZXRcIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQnV0dG9uU3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gcHJvcHMub25DbG9zZSgpLFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNsYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwiY29tbW9uLmNsb3NlXCIsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkNsb3NlXCJcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLnNob3dCdXR0b24gPT09IFwib3Blbi13YWxsZXRcIiAmJiB1bml2ZXJzYWxMaW5rO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChCdXR0b25TdHlsZWQsIHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiBvbk9wZW5XYWxsZXQsXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJjb21tb24ub3BlbldhbGxldFwiLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJPcGVuIHdhbGxldFwiXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXTtcbiAgICAgICAgfVxuICAgICAgfSldO1xuICAgIH1cbiAgfSkpO1xufTtcbmNvbnN0IENvbmZpcm1UcmFuc2FjdGlvbk1vZGFsID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRvbkNvbm5lY3RVSSA9IHVzZUNvbnRleHQoVG9uQ29ubmVjdFVpQ29udGV4dCk7XG4gIGNvbnN0IFt0Ml0gPSB1c2VJMThuKCk7XG4gIGNvbnN0IG5hbWUgPSAoKSA9PiB0b25Db25uZWN0VUkud2FsbGV0ICYmIFwibmFtZVwiIGluIHRvbkNvbm5lY3RVSS53YWxsZXQgPyB0b25Db25uZWN0VUkud2FsbGV0Lm5hbWUgOiB0MihcImNvbW1vbi55b3VyV2FsbGV0XCIsIHt9LCBcIllvdXIgd2FsbGV0XCIpO1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEFjdGlvbk1vZGFsLCB7XG4gICAgaGVhZGVyVHJhbnNsYXRpb25LZXk6IFwiYWN0aW9uTW9kYWwuY29uZmlybVRyYW5zYWN0aW9uLmhlYWRlclwiLFxuICAgIGdldCBoZWFkZXJUcmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUoKVxuICAgICAgfTtcbiAgICB9LFxuICAgIHRleHRUcmFuc2xhdGlvbktleTogXCJhY3Rpb25Nb2RhbC5jb25maXJtVHJhbnNhY3Rpb24udGV4dFwiLFxuICAgIGdldCBpY29uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChMb2FkZXJJY29uLCB7XG4gICAgICAgIHNpemU6IFwibVwiXG4gICAgICB9KTtcbiAgICB9LFxuICAgIG9uQ2xvc2U6ICgpID0+IHByb3BzLm9uQ2xvc2UoKSxcbiAgICBzaG93QnV0dG9uOiBcIm9wZW4td2FsbGV0XCIsXG4gICAgXCJkYXRhLXRjLWNvbmZpcm0tbW9kYWxcIjogXCJ0cnVlXCJcbiAgfSk7XG59O1xuY29uc3QgVHJhbnNhY3Rpb25DYW5jZWxlZE1vZGFsID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoQWN0aW9uTW9kYWwsIHtcbiAgICBoZWFkZXJUcmFuc2xhdGlvbktleTogXCJhY3Rpb25Nb2RhbC50cmFuc2FjdGlvbkNhbmNlbGVkLmhlYWRlclwiLFxuICAgIHRleHRUcmFuc2xhdGlvbktleTogXCJhY3Rpb25Nb2RhbC50cmFuc2FjdGlvbkNhbmNlbGVkLnRleHRcIixcbiAgICBnZXQgaWNvbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoRXJyb3JJY29uLCB7XG4gICAgICAgIHNpemU6IFwibVwiXG4gICAgICB9KTtcbiAgICB9LFxuICAgIG9uQ2xvc2U6ICgpID0+IHByb3BzLm9uQ2xvc2UoKSxcbiAgICBcImRhdGEtdGMtdHJhbnNhY3Rpb24tY2FuY2VsZWQtbW9kYWxcIjogXCJ0cnVlXCJcbiAgfSk7XG59O1xuY29uc3QgVHJhbnNhY3Rpb25TZW50TW9kYWwgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChBY3Rpb25Nb2RhbCwge1xuICAgIGhlYWRlclRyYW5zbGF0aW9uS2V5OiBcImFjdGlvbk1vZGFsLnRyYW5zYWN0aW9uU2VudC5oZWFkZXJcIixcbiAgICB0ZXh0VHJhbnNsYXRpb25LZXk6IFwiYWN0aW9uTW9kYWwudHJhbnNhY3Rpb25TZW50LnRleHRcIixcbiAgICBnZXQgaWNvbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoU3VjY2Vzc0ljb24sIHtcbiAgICAgICAgc2l6ZTogXCJtXCJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2hvd0J1dHRvbjogXCJvcGVuLXdhbGxldFwiLFxuICAgIG9uQ2xvc2U6ICgpID0+IHByb3BzLm9uQ2xvc2UoKSxcbiAgICBcImRhdGEtdGMtdHJhbnNhY3Rpb24tc2VudC1tb2RhbFwiOiBcInRydWVcIlxuICB9KTtcbn07XG5jb25zdCBDb25maXJtU2lnbkRhdGFNb2RhbCA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0b25Db25uZWN0VUkgPSB1c2VDb250ZXh0KFRvbkNvbm5lY3RVaUNvbnRleHQpO1xuICBjb25zdCBbdDJdID0gdXNlSTE4bigpO1xuICBjb25zdCBuYW1lID0gKCkgPT4gdG9uQ29ubmVjdFVJLndhbGxldCAmJiBcIm5hbWVcIiBpbiB0b25Db25uZWN0VUkud2FsbGV0ID8gdG9uQ29ubmVjdFVJLndhbGxldC5uYW1lIDogdDIoXCJjb21tb24ueW91cldhbGxldFwiLCB7fSwgXCJZb3VyIHdhbGxldFwiKTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChBY3Rpb25Nb2RhbCwge1xuICAgIGhlYWRlclRyYW5zbGF0aW9uS2V5OiBcImFjdGlvbk1vZGFsLnNpZ25EYXRhLmhlYWRlclwiLFxuICAgIGdldCBoZWFkZXJUcmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUoKVxuICAgICAgfTtcbiAgICB9LFxuICAgIHRleHRUcmFuc2xhdGlvbktleTogXCJhY3Rpb25Nb2RhbC5zaWduRGF0YS50ZXh0XCIsXG4gICAgZ2V0IGljb24oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KExvYWRlckljb24sIHtcbiAgICAgICAgc2l6ZTogXCJtXCJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgb25DbG9zZTogKCkgPT4gcHJvcHMub25DbG9zZSgpLFxuICAgIHNob3dCdXR0b246IFwib3Blbi13YWxsZXRcIixcbiAgICBcImRhdGEtdGMtc2lnbi1kYXRhLWNvbmZpcm0tbW9kYWxcIjogXCJ0cnVlXCJcbiAgfSk7XG59O1xuY29uc3QgU2lnbkRhdGFDYW5jZWxlZE1vZGFsID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoQWN0aW9uTW9kYWwsIHtcbiAgICBoZWFkZXJUcmFuc2xhdGlvbktleTogXCJhY3Rpb25Nb2RhbC5zaWduRGF0YUNhbmNlbGVkLmhlYWRlclwiLFxuICAgIGdldCBpY29uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChFcnJvckljb24sIHtcbiAgICAgICAgc2l6ZTogXCJtXCJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgb25DbG9zZTogKCkgPT4gcHJvcHMub25DbG9zZSgpLFxuICAgIFwiZGF0YS10Yy1zaWduLWRhdGEtY2FuY2VsZWQtbW9kYWxcIjogXCJ0cnVlXCJcbiAgfSk7XG59O1xuY29uc3QgRGF0YVNpZ25lZE1vZGFsID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoQWN0aW9uTW9kYWwsIHtcbiAgICBoZWFkZXJUcmFuc2xhdGlvbktleTogXCJhY3Rpb25Nb2RhbC5kYXRhU2lnbmVkLmhlYWRlclwiLFxuICAgIGdldCBpY29uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChTdWNjZXNzSWNvbiwge1xuICAgICAgICBzaXplOiBcIm1cIlxuICAgICAgfSk7XG4gICAgfSxcbiAgICBvbkNsb3NlOiAoKSA9PiBwcm9wcy5vbkNsb3NlKCksXG4gICAgXCJkYXRhLXRjLWRhdGEtc2lnbmVkLW1vZGFsXCI6IFwidHJ1ZVwiXG4gIH0pO1xufTtcbmNvbnN0IEFjdGlvbnNNb2RhbCA9ICgpID0+IHtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChNb2RhbCwge1xuICAgIGdldCBvcGVuZWQoKSB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgcmV0dXJuIG1lbW8oKCkgPT4gYWN0aW9uKCkgIT09IG51bGwpKCkgJiYgKChfYTIgPSBhY3Rpb24oKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5vcGVuTW9kYWwpID09PSB0cnVlO1xuICAgIH0sXG4gICAgZ2V0IGVuYWJsZUFuZHJvaWRCYWNrSGFuZGxlcigpIHtcbiAgICAgIHJldHVybiBhcHBTdGF0ZS5lbmFibGVBbmRyb2lkQmFja0hhbmRsZXI7XG4gICAgfSxcbiAgICBvbkNsb3NlOiAoKSA9PiBzZXRBY3Rpb24obnVsbCksXG4gICAgc2hvd0Zvb3RlcjogZmFsc2UsXG4gICAgXCJkYXRhLXRjLWFjdGlvbnMtbW9kYWwtY29udGFpbmVyXCI6IFwidHJ1ZVwiLFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoU3dpdGNoLCB7XG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhY3Rpb24oKS5uYW1lID09PSBcInRyYW5zYWN0aW9uLXNlbnRcIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNhY3Rpb25TZW50TW9kYWwsIHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlOiAoKSA9PiBzZXRBY3Rpb24obnVsbClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhY3Rpb24oKS5uYW1lID09PSBcInRyYW5zYWN0aW9uLWNhbmNlbGVkXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zYWN0aW9uQ2FuY2VsZWRNb2RhbCwge1xuICAgICAgICAgICAgICAgIG9uQ2xvc2U6ICgpID0+IHNldEFjdGlvbihudWxsKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbigpLm5hbWUgPT09IFwiY29uZmlybS10cmFuc2FjdGlvblwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChDb25maXJtVHJhbnNhY3Rpb25Nb2RhbCwge1xuICAgICAgICAgICAgICAgIG9uQ2xvc2U6ICgpID0+IHNldEFjdGlvbihudWxsKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbigpLm5hbWUgPT09IFwiZGF0YS1zaWduZWRcIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoRGF0YVNpZ25lZE1vZGFsLCB7XG4gICAgICAgICAgICAgICAgb25DbG9zZTogKCkgPT4gc2V0QWN0aW9uKG51bGwpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uKCkubmFtZSA9PT0gXCJzaWduLWRhdGEtY2FuY2VsZWRcIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoU2lnbkRhdGFDYW5jZWxlZE1vZGFsLCB7XG4gICAgICAgICAgICAgICAgb25DbG9zZTogKCkgPT4gc2V0QWN0aW9uKG51bGwpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uKCkubmFtZSA9PT0gXCJjb25maXJtLXNpZ24tZGF0YVwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChDb25maXJtU2lnbkRhdGFNb2RhbCwge1xuICAgICAgICAgICAgICAgIG9uQ2xvc2U6ICgpID0+IHNldEFjdGlvbihudWxsKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3QgU2luZ2xlV2FsbGV0TW9kYWwgPSAoKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBsb2NhbGVcbiAgfSA9IHVzZUkxOG4oKVsxXTtcbiAgY3JlYXRlRWZmZWN0KCgpID0+IGxvY2FsZShhcHBTdGF0ZS5sYW5ndWFnZSkpO1xuICBjcmVhdGVFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChnZXRTaW5nbGVXYWxsZXRNb2RhbElzT3BlbmVkKCkpIHtcbiAgICAgIHVwZGF0ZUlzTW9iaWxlKCk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgY29ubmVjdG9yID0gdXNlQ29udGV4dChDb25uZWN0b3JDb250ZXh0KTtcbiAgY29uc3QgdG9uQ29ubmVjdFVJID0gdXNlQ29udGV4dChUb25Db25uZWN0VWlDb250ZXh0KTtcbiAgY29uc3QgW2luZm9UYWIsIHNldEluZm9UYWJdID0gY3JlYXRlU2lnbmFsKGZhbHNlKTtcbiAgY29uc3QgYWRkaXRpb25hbFJlcXVlc3RMb2FkaW5nID0gKCkgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgcmV0dXJuICgoX2EyID0gYXBwU3RhdGUuY29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnN0YXRlKSA9PT0gXCJsb2FkaW5nXCI7XG4gIH07XG4gIGNvbnN0IGFkZGl0aW9uYWxSZXF1ZXN0ID0gY3JlYXRlTWVtbygoKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAoYWRkaXRpb25hbFJlcXVlc3RMb2FkaW5nKCkpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiAoX2EyID0gYXBwU3RhdGUuY29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnZhbHVlO1xuICB9KTtcbiAgY29uc3Qgb25DbG9zZSA9IChjbG9zZVJlYXNvbikgPT4ge1xuICAgIHRvbkNvbm5lY3RVSS5jbG9zZVNpbmdsZVdhbGxldE1vZGFsKGNsb3NlUmVhc29uKTtcbiAgfTtcbiAgY29uc3QgdW5zdWJzY3JpYmUgPSBjb25uZWN0b3Iub25TdGF0dXNDaGFuZ2UoKHdhbGxldCkgPT4ge1xuICAgIGlmICh3YWxsZXQpIHtcbiAgICAgIG9uQ2xvc2UoXCJ3YWxsZXQtc2VsZWN0ZWRcIik7XG4gICAgfVxuICB9KTtcbiAgb25DbGVhbnVwKHVuc3Vic2NyaWJlKTtcbiAgb25DbGVhbnVwKCgpID0+IHtcbiAgICBzZXRJbmZvVGFiKGZhbHNlKTtcbiAgfSk7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoU3R5bGVkTW9kYWwsIHtcbiAgICBnZXQgb3BlbmVkKCkge1xuICAgICAgcmV0dXJuIGdldFNpbmdsZVdhbGxldE1vZGFsSXNPcGVuZWQoKTtcbiAgICB9LFxuICAgIGdldCBlbmFibGVBbmRyb2lkQmFja0hhbmRsZXIoKSB7XG4gICAgICByZXR1cm4gYXBwU3RhdGUuZW5hYmxlQW5kcm9pZEJhY2tIYW5kbGVyO1xuICAgIH0sXG4gICAgb25DbG9zZTogKCkgPT4gb25DbG9zZShcImFjdGlvbi1jYW5jZWxsZWRcIiksXG4gICAgb25DbGlja1F1ZXN0aW9uOiAoKSA9PiBzZXRJbmZvVGFiKCh2KSA9PiAhdiksXG4gICAgc2hvd0Zvb3RlcjogdHJ1ZSxcbiAgICBcImRhdGEtdGMtd2FsbGV0cy1tb2RhbC1jb250YWluZXJcIjogXCJ0cnVlXCIsXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICByZXR1cm4gaW5mb1RhYigpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChJbmZvTW9kYWwsIHtcbiAgICAgICAgICAgIG9uQmFja0NsaWNrOiAoKSA9PiBzZXRJbmZvVGFiKGZhbHNlKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgcmV0dXJuICFpbmZvVGFiKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFkZGl0aW9uYWxSZXF1ZXN0TG9hZGluZygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoSDFTdHlsZWQkYSwge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmxvYWRpbmdcIixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJXYWxsZXRzIGxpc3QgaXMgbG9hZGluZ1wiXG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTG9hZGVyQ29udGFpbmVyU3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChMb2FkZXJJY29uLCB7XG4gICAgICAgICAgICAgICAgICAgIHNpemU6IFwibVwiXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gIWFkZGl0aW9uYWxSZXF1ZXN0TG9hZGluZygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChEeW5hbWljLCB7XG4gICAgICAgICAgICAgICAgZ2V0IGNvbXBvbmVudCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpc01vYmlsZSgpID8gTW9iaWxlQ29ubmVjdGlvbk1vZGFsIDogRGVza3RvcENvbm5lY3Rpb25Nb2RhbDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCB3YWxsZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U2luZ2xlV2FsbGV0TW9kYWxXYWxsZXRJbmZvKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQgYWRkaXRpb25hbFJlcXVlc3QoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYWRkaXRpb25hbFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uQmFja0NsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBiYWNrRGlzYWJsZWQ6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSldO1xuICAgICAgICB9XG4gICAgICB9KV07XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBBcHAgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdHJhbnNsYXRpb25zID0gY3JlYXRlSTE4bkNvbnRleHQoaTE4bkRpY3Rpb25hcnksIGFwcFN0YXRlLmxhbmd1YWdlKTtcbiAgZGVmaW5lU3R5bGVzUm9vdCgpO1xuICBmaXhNb2JpbGVTYWZhcmlBY3RpdmVUcmFuc2l0aW9uKCk7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoSTE4bkNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdHJhbnNsYXRpb25zLFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVG9uQ29ubmVjdFVpQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLnRvbkNvbm5lY3RVSTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQ29ubmVjdG9yQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICAgICAgICByZXR1cm4gYXBwU3RhdGUuY29ubmVjdG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoR2xvYmFsU3R5bGVzLCB7fSksIGNyZWF0ZUNvbXBvbmVudChUaGVtZVByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgdGhlbWU6IHRoZW1lU3RhdGUsXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBwU3RhdGUuYnV0dG9uUm9vdElkO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChQb3J0YWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBtb3VudCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGFwcFN0YXRlLmJ1dHRvblJvb3RJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEFjY291bnRCdXR0b24sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChEeW5hbWljLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogZ2xvYmFsU3R5bGVzVGFnLFxuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoV2FsbGV0c01vZGFsLCB7fSksIGNyZWF0ZUNvbXBvbmVudChTaW5nbGVXYWxsZXRNb2RhbCwge30pLCBjcmVhdGVDb21wb25lbnQoQWN0aW9uc01vZGFsLCB7fSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3Qgd2lkZ2V0Q29udHJvbGxlciA9IHtcbiAgb3BlbldhbGxldHNNb2RhbDogKG9wdGlvbnMpID0+IHZvaWQgc2V0VGltZW91dCgoKSA9PiBzZXRXYWxsZXRzTW9kYWxTdGF0ZSgocHJldikgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogXCJvcGVuZWRcIixcbiAgICAgIHRyYWNlSWQ6IChfYTIgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnRyYWNlSWQpICE9IG51bGwgPyBfYTIgOiBwcmV2ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2LnRyYWNlSWQsXG4gICAgICBjbG9zZVJlYXNvbjogbnVsbFxuICAgIH07XG4gIH0pKSxcbiAgY2xvc2VXYWxsZXRzTW9kYWw6IChyZWFzb24pID0+IHZvaWQgc2V0VGltZW91dCgoKSA9PiBzZXRXYWxsZXRzTW9kYWxTdGF0ZSh7XG4gICAgc3RhdHVzOiBcImNsb3NlZFwiLFxuICAgIGNsb3NlUmVhc29uOiByZWFzb25cbiAgfSkpLFxuICBvcGVuU2luZ2xlV2FsbGV0TW9kYWw6ICh3YWxsZXRJbmZvKSA9PiB7XG4gICAgdm9pZCBzZXRUaW1lb3V0KCgpID0+IHNldFNpbmdsZVdhbGxldE1vZGFsU3RhdGUoe1xuICAgICAgc3RhdHVzOiBcIm9wZW5lZFwiLFxuICAgICAgY2xvc2VSZWFzb246IG51bGwsXG4gICAgICB3YWxsZXRJbmZvXG4gICAgfSkpO1xuICB9LFxuICBjbG9zZVNpbmdsZVdhbGxldE1vZGFsOiAocmVhc29uKSA9PiB2b2lkIHNldFRpbWVvdXQoKCkgPT4gc2V0U2luZ2xlV2FsbGV0TW9kYWxTdGF0ZSh7XG4gICAgc3RhdHVzOiBcImNsb3NlZFwiLFxuICAgIGNsb3NlUmVhc29uOiByZWFzb25cbiAgfSkpLFxuICBvcGVuV2FsbGV0Tm90U3VwcG9ydEZlYXR1cmVNb2RhbDogKGNhdXNlLCBvcHRpb25zKSA9PiB2b2lkIHNldFRpbWVvdXQoKCkgPT4gc2V0V2FsbGV0c01vZGFsU3RhdGUoe1xuICAgIHN0YXR1czogXCJvcGVuZWRcIixcbiAgICB0cmFjZUlkOiBvcHRpb25zLnRyYWNlSWQsXG4gICAgY2xvc2VSZWFzb246IG51bGwsXG4gICAgdHlwZTogXCJ3YWxsZXQtbm90LXN1cHBvcnQtZmVhdHVyZVwiLFxuICAgIHJlcXVpcmVkRmVhdHVyZTogY2F1c2UucmVxdWlyZWRGZWF0dXJlXG4gIH0pKSxcbiAgc2V0QWN0aW9uOiAoYWN0aW9uMikgPT4gdm9pZCBzZXRUaW1lb3V0KCgpID0+IHNldEFjdGlvbihhY3Rpb24yKSksXG4gIGNsZWFyQWN0aW9uOiAoKSA9PiB2b2lkIHNldFRpbWVvdXQoKCkgPT4gc2V0QWN0aW9uKG51bGwpKSxcbiAgZ2V0U2VsZWN0ZWRXYWxsZXRJbmZvOiAoKSA9PiBsYXN0U2VsZWN0ZWRXYWxsZXRJbmZvKCksXG4gIGdldExhc3RWaXNpYmxlV2FsbGV0czogKCkgPT4gbGFzdFZpc2libGVXYWxsZXRzSW5mbygpLFxuICByZW1vdmVTZWxlY3RlZFdhbGxldEluZm86ICgpID0+IHNldExhc3RTZWxlY3RlZFdhbGxldEluZm8obnVsbCksXG4gIHJlbmRlckFwcDogKHJvb3QsIHRvbkNvbm5lY3RVSSkgPT4gcmVuZGVyKCgpID0+IGNyZWF0ZUNvbXBvbmVudChBcHAsIHtcbiAgICB0b25Db25uZWN0VUlcbiAgfSksIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHJvb3QpKVxufTtcbmNsYXNzIFdhbGxldHNNb2RhbE1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5jb25zdW1lcnMgPSBbXTtcbiAgICB0aGlzLnN0YXRlID0gd2FsbGV0c01vZGFsU3RhdGUoKTtcbiAgICB0aGlzLmNvbm5lY3RvciA9IG9wdGlvbnMuY29ubmVjdG9yO1xuICAgIHRoaXMudHJhY2tlciA9IG9wdGlvbnMudHJhY2tlcjtcbiAgICB0aGlzLnNldENvbm5lY3RSZXF1ZXN0UGFyYW1ldGVyc0NhbGxiYWNrID0gb3B0aW9ucy5zZXRDb25uZWN0UmVxdWVzdFBhcmFtZXRlcnNDYWxsYmFjaztcbiAgICBjcmVhdGVFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdGUgPSB3YWxsZXRzTW9kYWxTdGF0ZSgpO1xuICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgdGhpcy5jb25zdW1lcnMuZm9yRWFjaCgoY29uc3VtZXIpID0+IGNvbnN1bWVyKHN0YXRlKSk7XG4gICAgfSk7XG4gICAgY3JlYXRlRWZmZWN0KFxuICAgICAgb24obGFzdFNlbGVjdGVkV2FsbGV0SW5mbywgKHNlbGVjdGVkV2FsbGV0LCBwcmV2aW91c1dhbGxldCkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHsgd2FsbGV0cywgd2FsbGV0c01lbnUgfSA9IHdpZGdldENvbnRyb2xsZXIuZ2V0TGFzdFZpc2libGVXYWxsZXRzKCk7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkV2FsbGV0ICYmIFwiYXBwTmFtZVwiIGluIHNlbGVjdGVkV2FsbGV0KSB7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNXYWxsZXQgJiYgXCJhcHBOYW1lXCIgaW4gcHJldmlvdXNXYWxsZXQgJiYgcHJldmlvdXNXYWxsZXQuYXBwTmFtZSA9PT0gc2VsZWN0ZWRXYWxsZXQuYXBwTmFtZSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjbGllbnRJZCA9IHlpZWxkIHRoaXMuY29ubmVjdG9yLmdldFNlc3Npb25JZCgpO1xuICAgICAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrU2VsZWN0ZWRXYWxsZXQoXG4gICAgICAgICAgICAgIHdhbGxldHMubWFwKCh3YWxsZXQpID0+IHdhbGxldC5uYW1lKSxcbiAgICAgICAgICAgICAgc2VsZWN0ZWRXYWxsZXQsXG4gICAgICAgICAgICAgIHdhbGxldHNNZW51LFxuICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgIGNsaWVudElkLFxuICAgICAgICAgICAgICB0aGlzLnN0YXRlLnRyYWNlSWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxvZ0Vycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSkpXG4gICAgKTtcbiAgICBjcmVhdGVFZmZlY3QoXG4gICAgICBvbihsYXN0T3BlbmVkTGluaywgKG9wZW5lZExpbmspID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IHdhbGxldHMsIHdhbGxldHNNZW51IH0gPSB3aWRnZXRDb250cm9sbGVyLmdldExhc3RWaXNpYmxlV2FsbGV0cygpO1xuICAgICAgICAgIGlmIChpc0Nvbm5lY3RVcmwob3BlbmVkTGluay5saW5rKSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRXYWxsZXQgPSBsYXN0U2VsZWN0ZWRXYWxsZXRJbmZvKCk7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRJZCA9IHlpZWxkIHRoaXMuY29ubmVjdG9yLmdldFNlc3Npb25JZCgpO1xuICAgICAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrU2VsZWN0ZWRXYWxsZXQoXG4gICAgICAgICAgICAgIHdhbGxldHMubWFwKCh3YWxsZXQpID0+IHdhbGxldC5uYW1lKSxcbiAgICAgICAgICAgICAgc2VsZWN0ZWRXYWxsZXQgJiYgXCJhcHBOYW1lXCIgaW4gc2VsZWN0ZWRXYWxsZXQgPyBzZWxlY3RlZFdhbGxldCA6IG51bGwsXG4gICAgICAgICAgICAgIHdhbGxldHNNZW51LFxuICAgICAgICAgICAgICBvcGVuZWRMaW5rLmxpbmssXG4gICAgICAgICAgICAgIG9wZW5lZExpbmsudHlwZSxcbiAgICAgICAgICAgICAgY2xpZW50SWQsXG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUudHJhY2VJZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgbG9nRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBPcGVucyB0aGUgbW9kYWwgd2luZG93LlxuICAgKi9cbiAgb3BlbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBjb25zdCB0cmFjZUlkID0gKF9hMiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZCkgIT0gbnVsbCA/IF9hMiA6IFVVSUR2NygpO1xuICAgICAgdGhpcy50cmFja2VyLnRyYWNrQ29ubmVjdGlvblN0YXJ0ZWQoKTtcbiAgICAgIGNvbnN0IHdhbGxldHNMaXN0ID0geWllbGQgdGhpcy5jb25uZWN0b3IuZ2V0V2FsbGV0cygpO1xuICAgICAgY29uc3QgZW1iZWRkZWRXYWxsZXQgPSB3YWxsZXRzTGlzdC5maW5kKGlzV2FsbGV0SW5mb0N1cnJlbnRseUVtYmVkZGVkKTtcbiAgICAgIGlmIChlbWJlZGRlZFdhbGxldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0RW1iZWRkZWRXYWxsZXQoZW1iZWRkZWRXYWxsZXQsIHsgdHJhY2VJZCB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZW5XYWxsZXRzTW9kYWwoeyB0cmFjZUlkIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIG1vZGFsIHdpbmRvdy5cbiAgICogQGRlZmF1bHQgJ2FjdGlvbi1jYW5jZWxsZWQnXG4gICAqL1xuICBjbG9zZShyZWFzb24gPSBcImFjdGlvbi1jYW5jZWxsZWRcIikge1xuICAgIGlmIChyZWFzb24gPT09IFwiYWN0aW9uLWNhbmNlbGxlZFwiKSB7XG4gICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uRXJyb3IoXCJDb25uZWN0aW9uIHdhcyBjYW5jZWxsZWRcIik7XG4gICAgfVxuICAgIHdpZGdldENvbnRyb2xsZXIuY2xvc2VXYWxsZXRzTW9kYWwocmVhc29uKTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIHRoZSBtb2RhbCB3aW5kb3cgc3RhdGUgY2hhbmdlcywgcmV0dXJucyB1bnN1YnNjcmliZSBmdW5jdGlvbi5cbiAgICovXG4gIG9uU3RhdGVDaGFuZ2Uob25DaGFuZ2UpIHtcbiAgICB0aGlzLmNvbnN1bWVycy5wdXNoKG9uQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpcy5jb25zdW1lcnMgPSB0aGlzLmNvbnN1bWVycy5maWx0ZXIoKGNvbnN1bWVyKSA9PiBjb25zdW1lciAhPT0gb25DaGFuZ2UpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBhIGNvbm5lY3Rpb24gd2l0aCBhbiBlbWJlZGRlZCB3YWxsZXQuXG4gICAqIEBwYXJhbSBlbWJlZGRlZFdhbGxldCAtIEluZm9ybWF0aW9uIGFib3V0IHRoZSBlbWJlZGRlZCB3YWxsZXQgdG8gY29ubmVjdCB0by5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25uZWN0RW1iZWRkZWRXYWxsZXQoZW1iZWRkZWRXYWxsZXQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb25uZWN0ID0gKHBhcmFtZXRlcnMpID0+IHtcbiAgICAgIHNldExhc3RTZWxlY3RlZFdhbGxldEluZm8oZW1iZWRkZWRXYWxsZXQpO1xuICAgICAgdGhpcy5jb25uZWN0b3IuY29ubmVjdCh7IGpzQnJpZGdlS2V5OiBlbWJlZGRlZFdhbGxldC5qc0JyaWRnZUtleSB9LCBwYXJhbWV0ZXJzLCB7XG4gICAgICAgIHRyYWNlSWQ6IG9wdGlvbnMudHJhY2VJZFxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBhZGRpdGlvbmFsUmVxdWVzdCA9IGFwcFN0YXRlLmNvbm5lY3RSZXF1ZXN0UGFyYW1ldGVycztcbiAgICBpZiAoKGFkZGl0aW9uYWxSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBhZGRpdGlvbmFsUmVxdWVzdC5zdGF0ZSkgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICB0aGlzLnNldENvbm5lY3RSZXF1ZXN0UGFyYW1ldGVyc0NhbGxiYWNrKGNvbm5lY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25uZWN0KGFkZGl0aW9uYWxSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBhZGRpdGlvbmFsUmVxdWVzdC52YWx1ZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBPcGVucyB0aGUgbW9kYWwgd2luZG93IHRvIGNvbm5lY3QgdG8gYW4gZXh0ZXJuYWwgd2FsbGV0LCBhbmQgd2FpdHMgd2hlbiBtb2RhbCB3aW5kb3cgaXMgb3BlbmVkLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG9wZW5XYWxsZXRzTW9kYWwob3B0aW9ucykge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoaXNJblRNQSgpKSB7XG4gICAgICAgIHNlbmRFeHBhbmQoKTtcbiAgICAgIH1cbiAgICAgIHdpZGdldENvbnRyb2xsZXIub3BlbldhbGxldHNNb2RhbCh7IHRyYWNlSWQ6IG9wdGlvbnMudHJhY2VJZCB9KTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMub25TdGF0ZUNoYW5nZSgoc3RhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHN0YXR1cyB9ID0gc3RhdGU7XG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gXCJvcGVuZWRcIikge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFRyYW5zYWN0aW9uTW9kYWxNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuY29uc3VtZXJzID0gW107XG4gICAgdGhpcy5jb25uZWN0b3IgPSBvcHRpb25zLmNvbm5lY3RvcjtcbiAgICBjcmVhdGVFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudEFjdGlvbiA9IGFjdGlvbigpO1xuICAgICAgdGhpcy5jb25zdW1lcnMuZm9yRWFjaCgoY29uc3VtZXIpID0+IGNvbnN1bWVyKGN1cnJlbnRBY3Rpb24pKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIHRoZSBtb2RhbCB3aW5kb3cgc3RhdGUgY2hhbmdlcywgcmV0dXJucyB1bnN1YnNjcmliZSBmdW5jdGlvbi5cbiAgICovXG4gIG9uU3RhdGVDaGFuZ2UoY29uc3VtZXIpIHtcbiAgICB0aGlzLmNvbnN1bWVycy5wdXNoKGNvbnN1bWVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpcy5jb25zdW1lcnMgPSB0aGlzLmNvbnN1bWVycy5maWx0ZXIoKGMyKSA9PiBjMiAhPT0gY29uc3VtZXIpO1xuICAgIH07XG4gIH1cbn1cbmNsYXNzIFNpbmdsZVdhbGxldE1vZGFsTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbnN1bWVycyA9IFtdO1xuICAgIHRoaXMuc3RhdGUgPSBzaW5nbGVXYWxsZXRNb2RhbFN0YXRlKCk7XG4gICAgdGhpcy5jb25uZWN0b3IgPSBvcHRpb25zLmNvbm5lY3RvcjtcbiAgICB0aGlzLnRyYWNrZXIgPSBvcHRpb25zLnRyYWNrZXI7XG4gICAgdGhpcy5zZXRDb25uZWN0UmVxdWVzdFBhcmFtZXRlcnNDYWxsYmFjayA9IG9wdGlvbnMuc2V0Q29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzQ2FsbGJhY2s7XG4gICAgY3JlYXRlRWZmZWN0KCgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gc2luZ2xlV2FsbGV0TW9kYWxTdGF0ZSgpO1xuICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgdGhpcy5jb25zdW1lcnMuZm9yRWFjaCgoY29uc3VtZXIpID0+IGNvbnN1bWVyKHN0YXRlKSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBtb2RhbCB3aW5kb3cgd2l0aCB0aGUgc3BlY2lmaWVkIHdhbGxldC5cbiAgICogQHBhcmFtIHdhbGxldCAtIFdhbGxldCBhcHAgbmFtZS5cbiAgICogQHRocm93cyBUb25Db25uZWN0VUlFcnJvciBpZiB0aGUgc3BlY2lmaWVkIHdhbGxldCBpcyBub3QgZm91bmQuXG4gICAqL1xuICBvcGVuKHdhbGxldCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uU3RhcnRlZCgpO1xuICAgICAgY29uc3QgZmV0Y2hlZFdhbGxldHNMaXN0ID0geWllbGQgdGhpcy5jb25uZWN0b3IuZ2V0V2FsbGV0cygpO1xuICAgICAgY29uc3Qgd2FsbGV0c0xpc3QgPSBhcHBseVdhbGxldHNMaXN0Q29uZmlndXJhdGlvbihcbiAgICAgICAgZmV0Y2hlZFdhbGxldHNMaXN0LFxuICAgICAgICBhcHBTdGF0ZS53YWxsZXRzTGlzdENvbmZpZ3VyYXRpb25cbiAgICAgICk7XG4gICAgICBjb25zdCBlbWJlZGRlZFdhbGxldCA9IHdhbGxldHNMaXN0LmZpbmQoaXNXYWxsZXRJbmZvQ3VycmVudGx5RW1iZWRkZWQpO1xuICAgICAgY29uc3QgaXNFbWJlZGRlZFdhbGxldEV4aXN0ID0gISFlbWJlZGRlZFdhbGxldDtcbiAgICAgIGlmIChpc0VtYmVkZGVkV2FsbGV0RXhpc3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdEVtYmVkZGVkV2FsbGV0KGVtYmVkZGVkV2FsbGV0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGV4dGVybmFsV2FsbGV0cyA9IHdhbGxldHNMaXN0LmZpbHRlcihpc1dhbGxldEluZm9SZW1vdGUpO1xuICAgICAgY29uc3QgZXh0ZXJuYWxXYWxsZXQgPSBleHRlcm5hbFdhbGxldHMuZmluZCgod2FsbGV0SW5mbykgPT4gZXFXYWxsZXROYW1lKHdhbGxldEluZm8sIHdhbGxldCkpO1xuICAgICAgY29uc3QgaXNFeHRlcm5hbFdhbGxldEV4aXN0ID0gISFleHRlcm5hbFdhbGxldDtcbiAgICAgIGlmIChpc0V4dGVybmFsV2FsbGV0RXhpc3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlblNpbmdsZVdhbGxldE1vZGFsKGV4dGVybmFsV2FsbGV0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVycm9yID0gYFRyeWluZyB0byBvcGVuIG1vZGFsIHdpbmRvdyB3aXRoIHVua25vd24gd2FsbGV0IFwiJHt3YWxsZXR9XCIuYDtcbiAgICAgIHRoaXMudHJhY2tlci50cmFja0Nvbm5lY3Rpb25FcnJvcihlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdFVJRXJyb3IoZXJyb3IpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIG1vZGFsIHdpbmRvdy5cbiAgICogQGRlZmF1bHQgJ2FjdGlvbi1jYW5jZWxsZWQnXG4gICAqL1xuICBjbG9zZShyZWFzb24gPSBcImFjdGlvbi1jYW5jZWxsZWRcIikge1xuICAgIGlmIChyZWFzb24gPT09IFwiYWN0aW9uLWNhbmNlbGxlZFwiKSB7XG4gICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uRXJyb3IoXCJDb25uZWN0aW9uIHdhcyBjYW5jZWxsZWRcIik7XG4gICAgfVxuICAgIHdpZGdldENvbnRyb2xsZXIuY2xvc2VTaW5nbGVXYWxsZXRNb2RhbChcImFjdGlvbi1jYW5jZWxsZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byB0aGUgbW9kYWwgd2luZG93IHN0YXRlIGNoYW5nZXMsIHJldHVybnMgdW5zdWJzY3JpYmUgZnVuY3Rpb24uXG4gICAqL1xuICBvblN0YXRlQ2hhbmdlKG9uQ2hhbmdlKSB7XG4gICAgdGhpcy5jb25zdW1lcnMucHVzaChvbkNoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMuY29uc3VtZXJzID0gdGhpcy5jb25zdW1lcnMuZmlsdGVyKChjb25zdW1lcikgPT4gY29uc3VtZXIgIT09IG9uQ2hhbmdlKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWF0ZXMgYSBjb25uZWN0aW9uIHdpdGggYW4gZW1iZWRkZWQgd2FsbGV0LlxuICAgKiBAcGFyYW0gZW1iZWRkZWRXYWxsZXQgLSBJbmZvcm1hdGlvbiBhYm91dCB0aGUgZW1iZWRkZWQgd2FsbGV0IHRvIGNvbm5lY3QgdG8uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29ubmVjdEVtYmVkZGVkV2FsbGV0KGVtYmVkZGVkV2FsbGV0KSB7XG4gICAgY29uc3QgY29ubmVjdCA9IChwYXJhbWV0ZXJzKSA9PiB7XG4gICAgICBzZXRMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvKGVtYmVkZGVkV2FsbGV0KTtcbiAgICAgIHRoaXMuY29ubmVjdG9yLmNvbm5lY3QoeyBqc0JyaWRnZUtleTogZW1iZWRkZWRXYWxsZXQuanNCcmlkZ2VLZXkgfSwgcGFyYW1ldGVycyk7XG4gICAgfTtcbiAgICBjb25zdCBhZGRpdGlvbmFsUmVxdWVzdCA9IGFwcFN0YXRlLmNvbm5lY3RSZXF1ZXN0UGFyYW1ldGVycztcbiAgICBpZiAoKGFkZGl0aW9uYWxSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBhZGRpdGlvbmFsUmVxdWVzdC5zdGF0ZSkgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICB0aGlzLnNldENvbm5lY3RSZXF1ZXN0UGFyYW1ldGVyc0NhbGxiYWNrKGNvbm5lY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25uZWN0KGFkZGl0aW9uYWxSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBhZGRpdGlvbmFsUmVxdWVzdC52YWx1ZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBPcGVucyB0aGUgbW9kYWwgd2luZG93IHRvIGNvbm5lY3QgdG8gYSBzcGVjaWZpZWQgd2FsbGV0LCBhbmQgd2FpdHMgd2hlbiBtb2RhbCB3aW5kb3cgaXMgb3BlbmVkLlxuICAgKi9cbiAgb3BlblNpbmdsZVdhbGxldE1vZGFsKHdhbGxldCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoaXNJblRNQSgpKSB7XG4gICAgICAgIHNlbmRFeHBhbmQoKTtcbiAgICAgIH1cbiAgICAgIHdpZGdldENvbnRyb2xsZXIub3BlblNpbmdsZVdhbGxldE1vZGFsKHdhbGxldCk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSB0aGlzLm9uU3RhdGVDaGFuZ2UoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBzdGF0dXMgfSA9IHN0YXRlO1xuICAgICAgICAgIGlmIChzdGF0dXMgPT09IFwib3BlbmVkXCIpIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBUb25Db25uZWN0VUlUcmFja2VyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuZXZlbnRQcmVmaXggPSBcInRvbi1jb25uZWN0LXVpLVwiO1xuICAgIHRoaXMudG9uQ29ubmVjdFNka1ZlcnNpb24gPSBudWxsO1xuICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5ldmVudERpc3BhdGNoZXI7XG4gICAgdGhpcy50b25Db25uZWN0VWlWZXJzaW9uID0gb3B0aW9ucy50b25Db25uZWN0VWlWZXJzaW9uO1xuICAgIHRoaXMuaW5pdCgpLmNhdGNoKCk7XG4gIH1cbiAgLyoqXG4gICAqIFZlcnNpb24gb2YgdGhlIGxpYnJhcnkuXG4gICAqL1xuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gY3JlYXRlVmVyc2lvbkluZm8oe1xuICAgICAgdG9uX2Nvbm5lY3Rfc2RrX2xpYjogdGhpcy50b25Db25uZWN0U2RrVmVyc2lvbixcbiAgICAgIHRvbl9jb25uZWN0X3VpX2xpYjogdGhpcy50b25Db25uZWN0VWlWZXJzaW9uXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCBvbmNlIHdoZW4gdGhlIHRyYWNrZXIgaXMgY3JlYXRlZCBhbmQgcmVxdWVzdCB2ZXJzaW9uIG90aGVyIGxpYnJhcmllcy5cbiAgICovXG4gIGluaXQoKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkIHRoaXMuc2V0UmVxdWVzdFZlcnNpb25IYW5kbGVyKCk7XG4gICAgICAgIHRoaXMudG9uQ29ubmVjdFNka1ZlcnNpb24gPSB5aWVsZCB0aGlzLnJlcXVlc3RUb25Db25uZWN0U2RrVmVyc2lvbigpO1xuICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2V0IHJlcXVlc3QgdmVyc2lvbiBoYW5kbGVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0UmVxdWVzdFZlcnNpb25IYW5kbGVyKCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCB0aGlzLmV2ZW50RGlzcGF0Y2hlci5hZGRFdmVudExpc3RlbmVyKFwidG9uLWNvbm5lY3QtdWktcmVxdWVzdC12ZXJzaW9uXCIsICgpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgeWllbGQgdGhpcy5ldmVudERpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICBcInRvbi1jb25uZWN0LXVpLXJlc3BvbnNlLXZlcnNpb25cIixcbiAgICAgICAgICBjcmVhdGVSZXNwb25zZVZlcnNpb25FdmVudCh0aGlzLnRvbkNvbm5lY3RVaVZlcnNpb24pXG4gICAgICAgICk7XG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlcXVlc3QgVG9uQ29ubmVjdCBTREsgdmVyc2lvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlcXVlc3RUb25Db25uZWN0U2RrVmVyc2lvbigpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB5aWVsZCB0aGlzLmV2ZW50RGlzcGF0Y2hlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgXCJ0b24tY29ubmVjdC1yZXNwb25zZS12ZXJzaW9uXCIsXG4gICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShldmVudC5kZXRhaWwudmVyc2lvbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBvbmNlOiB0cnVlIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIHlpZWxkIHRoaXMuZXZlbnREaXNwYXRjaGVyLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICBcInRvbi1jb25uZWN0LXJlcXVlc3QtdmVyc2lvblwiLFxuICAgICAgICAgICAgY3JlYXRlUmVxdWVzdFZlcnNpb25FdmVudCgpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICByZWplY3QoZTIpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEVtaXQgdXNlciBhY3Rpb24gZXZlbnQgdG8gdGhlIHdpbmRvdy5cbiAgICogQHBhcmFtIGV2ZW50RGV0YWlsc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnREZXRhaWxzKSB7XG4gICAgdmFyIF9hMjtcbiAgICB0cnkge1xuICAgICAgKF9hMiA9IHRoaXMuZXZlbnREaXNwYXRjaGVyKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmRpc3BhdGNoRXZlbnQoYCR7dGhpcy5ldmVudFByZWZpeH0ke2V2ZW50RGV0YWlscy50eXBlfWAsIGV2ZW50RGV0YWlscykuY2F0Y2goKTtcbiAgICB9IGNhdGNoIChlMikge1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVHJhY2sgd2FsbGV0IG9wZW5lZCBldmVudC5cbiAgICogQHBhcmFtIGFyZ3NcbiAgICovXG4gIHRyYWNrV2FsbGV0TW9kYWxPcGVuZWQoLi4uYXJncykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBldmVudCA9IGNyZWF0ZVdhbGxldE1vZGFsT3BlbmVkRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUcmFjayB3YWxsZXQgc2VsZWN0ZWQgZXZlbnQuXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqL1xuICB0cmFja1NlbGVjdGVkV2FsbGV0KC4uLmFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVTZWxlY3RlZFdhbGxldEV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICB9IGNhdGNoIChlMikge1xuICAgICAgbG9nRXJyb3IoZTIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVHJhY2sgY29ubmVjdGlvbiBpbml0IGV2ZW50LlxuICAgKiBAcGFyYW0gYXJnc1xuICAgKi9cbiAgdHJhY2tDb25uZWN0aW9uU3RhcnRlZCguLi5hcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlQ29ubmVjdGlvblN0YXJ0ZWRFdmVudCh0aGlzLnZlcnNpb24sIC4uLmFyZ3MpO1xuICAgICAgdGhpcy5kaXNwYXRjaFVzZXJBY3Rpb25FdmVudChldmVudCk7XG4gICAgfSBjYXRjaCAoZTIpIHtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRyYWNrIGNvbm5lY3Rpb24gc3VjY2VzcyBldmVudC5cbiAgICogQHBhcmFtIGFyZ3NcbiAgICovXG4gIHRyYWNrQ29ubmVjdGlvbkNvbXBsZXRlZCguLi5hcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlQ29ubmVjdGlvbkNvbXBsZXRlZEV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICB9IGNhdGNoIChlMikge1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVHJhY2sgY29ubmVjdGlvbiBlcnJvciBldmVudC5cbiAgICogQHBhcmFtIGFyZ3NcbiAgICovXG4gIHRyYWNrQ29ubmVjdGlvbkVycm9yKC4uLmFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVDb25uZWN0aW9uRXJyb3JFdmVudCh0aGlzLnZlcnNpb24sIC4uLmFyZ3MpO1xuICAgICAgdGhpcy5kaXNwYXRjaFVzZXJBY3Rpb25FdmVudChldmVudCk7XG4gICAgfSBjYXRjaCAoZTIpIHtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRyYWNrIGNvbm5lY3Rpb24gcmVzdG9yaW5nIGluaXQgZXZlbnQuXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqL1xuICB0cmFja0Nvbm5lY3Rpb25SZXN0b3JpbmdTdGFydGVkKC4uLmFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVDb25uZWN0aW9uUmVzdG9yaW5nU3RhcnRlZEV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICB9IGNhdGNoIChlMikge1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVHJhY2sgY29ubmVjdGlvbiByZXN0b3Jpbmcgc3VjY2VzcyBldmVudC5cbiAgICogQHBhcmFtIGFyZ3NcbiAgICovXG4gIHRyYWNrQ29ubmVjdGlvblJlc3RvcmluZ0NvbXBsZXRlZCguLi5hcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlQ29ubmVjdGlvblJlc3RvcmluZ0NvbXBsZXRlZEV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICB9IGNhdGNoIChlMikge1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVHJhY2sgY29ubmVjdGlvbiByZXN0b3JpbmcgZXJyb3IgZXZlbnQuXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqL1xuICB0cmFja0Nvbm5lY3Rpb25SZXN0b3JpbmdFcnJvciguLi5hcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlQ29ubmVjdGlvblJlc3RvcmluZ0Vycm9yRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUcmFjayBkaXNjb25uZWN0IGV2ZW50LlxuICAgKiBAcGFyYW0gYXJnc1xuICAgKi9cbiAgdHJhY2tEaXNjb25uZWN0aW9uKC4uLmFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVEaXNjb25uZWN0aW9uRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUcmFjayB0cmFuc2FjdGlvbiBpbml0IGV2ZW50LlxuICAgKiBAcGFyYW0gYXJnc1xuICAgKi9cbiAgdHJhY2tUcmFuc2FjdGlvblNlbnRGb3JTaWduYXR1cmUoLi4uYXJncykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBldmVudCA9IGNyZWF0ZVRyYW5zYWN0aW9uU2VudEZvclNpZ25hdHVyZUV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICB9IGNhdGNoIChlMikge1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVHJhY2sgdHJhbnNhY3Rpb24gc2lnbmVkIGV2ZW50LlxuICAgKiBAcGFyYW0gYXJnc1xuICAgKi9cbiAgdHJhY2tUcmFuc2FjdGlvblNpZ25lZCguLi5hcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlVHJhbnNhY3Rpb25TaWduZWRFdmVudCh0aGlzLnZlcnNpb24sIC4uLmFyZ3MpO1xuICAgICAgdGhpcy5kaXNwYXRjaFVzZXJBY3Rpb25FdmVudChldmVudCk7XG4gICAgfSBjYXRjaCAoZTIpIHtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRyYWNrIHRyYW5zYWN0aW9uIGVycm9yIGV2ZW50LlxuICAgKiBAcGFyYW0gYXJnc1xuICAgKi9cbiAgdHJhY2tUcmFuc2FjdGlvblNpZ25pbmdGYWlsZWQoLi4uYXJncykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBldmVudCA9IGNyZWF0ZVRyYW5zYWN0aW9uU2lnbmluZ0ZhaWxlZEV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICB9IGNhdGNoIChlMikge1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVHJhY2sgZGF0YSBzZW50IGZvciBzaWduYXR1cmUgZXZlbnQuXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqL1xuICB0cmFja0RhdGFTZW50Rm9yU2lnbmF0dXJlKC4uLmFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVEYXRhU2VudEZvclNpZ25hdHVyZUV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICB9IGNhdGNoIChlMikge1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVHJhY2sgZGF0YSBzaWduZWQgZXZlbnQuXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqL1xuICB0cmFja0RhdGFTaWduZWQoLi4uYXJncykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBldmVudCA9IGNyZWF0ZURhdGFTaWduZWRFdmVudCh0aGlzLnZlcnNpb24sIC4uLmFyZ3MpO1xuICAgICAgdGhpcy5kaXNwYXRjaFVzZXJBY3Rpb25FdmVudChldmVudCk7XG4gICAgfSBjYXRjaCAoZTIpIHtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRyYWNrIGRhdGEgc2lnbmluZyBlcnJvciBldmVudC5cbiAgICogQHBhcmFtIGFyZ3NcbiAgICovXG4gIHRyYWNrRGF0YVNpZ25pbmdGYWlsZWQoLi4uYXJncykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBldmVudCA9IGNyZWF0ZURhdGFTaWduaW5nRmFpbGVkRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgfVxuICB9XG59XG5jb25zdCB0b25Db25uZWN0VWlWZXJzaW9uID0gXCIyLjQuMlwiO1xuY2xhc3MgVG9uQ29ubmVjdEVudmlyb25tZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy51c2VyQWdlbnQgPSBnZXRVc2VyQWdlbnQoKTtcbiAgfVxuICBnZXRMb2NhbGUoKSB7XG4gICAgdmFyIF9hMjtcbiAgICByZXR1cm4gKChfYTIgPSBuYXZpZ2F0b3IubGFuZ3VhZ2VzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyWzBdKSB8fCBuYXZpZ2F0b3IubGFuZ3VhZ2UgfHwgXCJcIjtcbiAgfVxuICBnZXRCcm93c2VyKCkge1xuICAgIHZhciBfYTI7XG4gICAgcmV0dXJuIChfYTIgPSB0aGlzLnVzZXJBZ2VudC5icm93c2VyKSAhPSBudWxsID8gX2EyIDogXCJcIjtcbiAgfVxuICBnZXRQbGF0Zm9ybSgpIHtcbiAgICB2YXIgX2EyO1xuICAgIHJldHVybiAoX2EyID0gdGhpcy51c2VyQWdlbnQub3MpICE9IG51bGwgPyBfYTIgOiBcIlwiO1xuICB9XG4gIGdldFRlbGVncmFtVXNlcigpIHtcbiAgICByZXR1cm4gZ2V0VGdVc2VyKCk7XG4gIH1cbiAgZ2V0Q2xpZW50RW52aXJvbm1lbnQoKSB7XG4gICAgcmV0dXJuIGlzSW5UTUEoKSA/IFwibWluaWFwcFwiIDogXCJ3ZWJcIjtcbiAgfVxufVxuY2xhc3MgVG9uQ29ubmVjdFVJIHtcbiAgLy8gVE9ETzogYGFjdGlvbnNDb25maWd1cmF0aW9uLnR3YVJldHVyblVybGAgaXMgdXNlZCBvbmx5IGluIGBjb25uZWN0V2FsbGV0YCBtZXRob2QsIGJ1dCBpdCdzIG5vdCB1c2VkIGluIGBzZW5kVHJhbnNhY3Rpb25gIG1ldGhvZCwgTkVFRCBUTyBGSVggSVRcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfYTI7XG4gICAgdGhpcy53YWxsZXRJbmZvU3RvcmFnZSA9IG5ldyBXYWxsZXRJbmZvU3RvcmFnZSgpO1xuICAgIHRoaXMucHJlZmVycmVkV2FsbGV0U3RvcmFnZSA9IG5ldyBQcmVmZXJyZWRXYWxsZXRTdG9yYWdlKCk7XG4gICAgdGhpcy53YWxsZXRJbmZvID0gbnVsbDtcbiAgICB0aGlzLnN5c3RlbVRoZW1lQ2hhbmdlVW5zdWJzY3JpYmUgPSBudWxsO1xuICAgIHRoaXMuY29ubmVjdGlvblJlc3RvcmVkID0gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICBsZXQgZXZlbnREaXNwYXRjaGVyID0gKF9hMiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZXZlbnREaXNwYXRjaGVyKSAhPSBudWxsID8gX2EyIDogbmV3IEJyb3dzZXJFdmVudERpc3BhdGNoZXIoKTtcbiAgICBpZiAob3B0aW9ucyAmJiBcImNvbm5lY3RvclwiIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5jb25uZWN0b3IpIHtcbiAgICAgIHRoaXMuY29ubmVjdG9yID0gb3B0aW9ucy5jb25uZWN0b3I7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zICYmIFwibWFuaWZlc3RVcmxcIiBpbiBvcHRpb25zICYmIG9wdGlvbnMubWFuaWZlc3RVcmwpIHtcbiAgICAgIHRoaXMuY29ubmVjdG9yID0gbmV3IFRvbkNvbm5lY3Qoe1xuICAgICAgICBtYW5pZmVzdFVybDogb3B0aW9ucy5tYW5pZmVzdFVybCxcbiAgICAgICAgZXZlbnREaXNwYXRjaGVyLFxuICAgICAgICB3YWxsZXRzUmVxdWlyZWRGZWF0dXJlczogb3B0aW9ucy53YWxsZXRzUmVxdWlyZWRGZWF0dXJlcyxcbiAgICAgICAgZW52aXJvbm1lbnQ6IG5ldyBUb25Db25uZWN0RW52aXJvbm1lbnQoKSxcbiAgICAgICAgYW5hbHl0aWNzOiBvcHRpb25zLmFuYWx5dGljc1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUb25Db25uZWN0VUlFcnJvcihcbiAgICAgICAgXCJZb3UgaGF2ZSB0byBzcGVjaWZ5IGEgYG1hbmlmZXN0VXJsYCBvciBhIGBjb25uZWN0b3JgIGluIHRoZSBvcHRpb25zLlwiXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnRyYWNrZXIgPSBuZXcgVG9uQ29ubmVjdFVJVHJhY2tlcih7XG4gICAgICBldmVudERpc3BhdGNoZXIsXG4gICAgICB0b25Db25uZWN0VWlWZXJzaW9uXG4gICAgfSk7XG4gICAgdGhpcy5tb2RhbCA9IG5ldyBXYWxsZXRzTW9kYWxNYW5hZ2VyKHtcbiAgICAgIGNvbm5lY3RvcjogdGhpcy5jb25uZWN0b3IsXG4gICAgICB0cmFja2VyOiB0aGlzLnRyYWNrZXIsXG4gICAgICBzZXRDb25uZWN0UmVxdWVzdFBhcmFtZXRlcnNDYWxsYmFjazogKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHRoaXMuY29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnNpbmdsZVdhbGxldE1vZGFsID0gbmV3IFNpbmdsZVdhbGxldE1vZGFsTWFuYWdlcih7XG4gICAgICBjb25uZWN0b3I6IHRoaXMuY29ubmVjdG9yLFxuICAgICAgdHJhY2tlcjogdGhpcy50cmFja2VyLFxuICAgICAgc2V0Q29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzQ2FsbGJhY2s6IChjYWxsYmFjaykgPT4ge1xuICAgICAgICB0aGlzLmNvbm5lY3RSZXF1ZXN0UGFyYW1ldGVyc0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy50cmFuc2FjdGlvbk1vZGFsID0gbmV3IFRyYW5zYWN0aW9uTW9kYWxNYW5hZ2VyKHtcbiAgICAgIGNvbm5lY3RvcjogdGhpcy5jb25uZWN0b3JcbiAgICB9KTtcbiAgICB0aGlzLl93YWxsZXRzUmVxdWlyZWRGZWF0dXJlcyA9IG9wdGlvbnMud2FsbGV0c1JlcXVpcmVkRmVhdHVyZXM7XG4gICAgdGhpcy5fd2FsbGV0c1ByZWZlcnJlZEZlYXR1cmVzID0gb3B0aW9ucy53YWxsZXRzUHJlZmVycmVkRmVhdHVyZXM7XG4gICAgdGhpcy53YWxsZXRzTGlzdCA9IHRoaXMuZ2V0V2FsbGV0cygpO1xuICAgIHRoaXMud2FsbGV0c0xpc3QudGhlbigobGlzdCkgPT4gcHJlbG9hZEltYWdlcyh1bmlxKGxpc3QubWFwKChpdGVtKSA9PiBpdGVtLmltYWdlVXJsKSkpKTtcbiAgICBjb25zdCByb290SWQgPSB0aGlzLm5vcm1hbGl6ZVdpZGdldFJvb3Qob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy53aWRnZXRSb290SWQpO1xuICAgIHRoaXMuc3Vic2NyaWJlVG9XYWxsZXRDaGFuZ2UoKTtcbiAgICBpZiAoKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucmVzdG9yZUNvbm5lY3Rpb24pICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5jb25uZWN0aW9uUmVzdG9yZWQgPSBjcmVhdGVNYWNyb3Rhc2tBc3luYygoKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHRoaXMudHJhY2tlci50cmFja0Nvbm5lY3Rpb25SZXN0b3JpbmdTdGFydGVkKCk7XG4gICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdG9yLnJlc3RvcmVDb25uZWN0aW9uKCk7XG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0b3IuY29ubmVjdGVkKSB7XG4gICAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrQ29ubmVjdGlvblJlc3RvcmluZ0Vycm9yKFwiQ29ubmVjdGlvbiB3YXMgbm90IHJlc3RvcmVkXCIpO1xuICAgICAgICAgIHRoaXMud2FsbGV0SW5mb1N0b3JhZ2UucmVtb3ZlV2FsbGV0SW5mbygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudHJhY2tlci50cmFja0Nvbm5lY3Rpb25SZXN0b3JpbmdDb21wbGV0ZWQodGhpcy53YWxsZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rvci5jb25uZWN0ZWQ7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIHRoaXMudWlPcHRpb25zID0gbWVyZ2VPcHRpb25zKG9wdGlvbnMsIHsgdWlQcmVmZXJlbmNlczogeyB0aGVtZTogXCJTWVNURU1cIiB9IH0pO1xuICAgIGNvbnN0IHByZWZlcnJlZFdhbGxldE5hbWUgPSB0aGlzLnByZWZlcnJlZFdhbGxldFN0b3JhZ2UuZ2V0UHJlZmVycmVkV2FsbGV0QXBwTmFtZSgpO1xuICAgIHNldEFwcFN0YXRlKHtcbiAgICAgIGNvbm5lY3RvcjogdGhpcy5jb25uZWN0b3IsXG4gICAgICBwcmVmZXJyZWRXYWxsZXRBcHBOYW1lOiBwcmVmZXJyZWRXYWxsZXROYW1lXG4gICAgfSk7XG4gICAgd2lkZ2V0Q29udHJvbGxlci5yZW5kZXJBcHAocm9vdElkLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZ2V0V2FsbGV0cygpIHtcbiAgICByZXR1cm4gVG9uQ29ubmVjdC5nZXRXYWxsZXRzKCk7XG4gIH1cbiAgZ2V0IHdhbGxldHNSZXF1aXJlZEZlYXR1cmVzKCkge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXRzUmVxdWlyZWRGZWF0dXJlcztcbiAgfVxuICBnZXQgd2FsbGV0c1ByZWZlcnJlZEZlYXR1cmVzKCkge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXRzUHJlZmVycmVkRmVhdHVyZXM7XG4gIH1cbiAgLyoqXG4gICAqIEN1cnJlbnQgY29ubmVjdGlvbiBzdGF0dXMuXG4gICAqL1xuICBnZXQgY29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rvci5jb25uZWN0ZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEN1cnJlbnQgY29ubmVjdGVkIGFjY291bnQgb3IgbnVsbC5cbiAgICovXG4gIGdldCBhY2NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rvci5hY2NvdW50O1xuICB9XG4gIC8qKlxuICAgKiBDdXJyZW4gY29ubmVjdGVkIHdhbGxldCBhcHAgYW5kIGl0cyBpbmZvIG9yIG51bGwuXG4gICAqL1xuICBnZXQgd2FsbGV0KCkge1xuICAgIGlmICghdGhpcy5jb25uZWN0b3Iud2FsbGV0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLmNvbm5lY3Rvci53YWxsZXQpLCB0aGlzLndhbGxldEluZm8pO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYW5kIGFwcGx5IG5ldyBVSSBvcHRpb25zLiBPYmplY3Qgd2l0aCBwYXJ0aWFsIG9wdGlvbnMgc2hvdWxkIGJlIHBhc3NlZC4gUGFzc2VkIG9wdGlvbnMgd2lsbCBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IG9wdGlvbnMuXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBzZXQgdWlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyLCBfYjIsIF9jMiwgX2QyLCBfZTI7XG4gICAgdGhpcy5jaGVja0J1dHRvblJvb3RFeGlzdChvcHRpb25zLmJ1dHRvblJvb3RJZCk7XG4gICAgdGhpcy5hY3Rpb25zQ29uZmlndXJhdGlvbiA9IG9wdGlvbnMuYWN0aW9uc0NvbmZpZ3VyYXRpb247XG4gICAgaWYgKFwid2FsbGV0c1JlcXVpcmVkRmVhdHVyZXNcIiBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzLl93YWxsZXRzUmVxdWlyZWRGZWF0dXJlcyA9IG9wdGlvbnMud2FsbGV0c1JlcXVpcmVkRmVhdHVyZXM7XG4gICAgfVxuICAgIGlmIChcIndhbGxldHNQcmVmZXJyZWRGZWF0dXJlc1wiIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX3dhbGxldHNQcmVmZXJyZWRGZWF0dXJlcyA9IG9wdGlvbnMud2FsbGV0c1ByZWZlcnJlZEZlYXR1cmVzO1xuICAgIH1cbiAgICBpZiAoKF9hMiA9IG9wdGlvbnMudWlQcmVmZXJlbmNlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi50aGVtZSkge1xuICAgICAgaWYgKCgoX2IyID0gb3B0aW9ucy51aVByZWZlcmVuY2VzKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLnRoZW1lKSAhPT0gXCJTWVNURU1cIikge1xuICAgICAgICAoX2MyID0gdGhpcy5zeXN0ZW1UaGVtZUNoYW5nZVVuc3Vic2NyaWJlKSA9PSBudWxsID8gdm9pZCAwIDogX2MyLmNhbGwodGhpcyk7XG4gICAgICAgIHNldFRoZW1lKG9wdGlvbnMudWlQcmVmZXJlbmNlcy50aGVtZSwgb3B0aW9ucy51aVByZWZlcmVuY2VzLmNvbG9yc1NldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaGVtZShnZXRTeXN0ZW1UaGVtZSgpLCBvcHRpb25zLnVpUHJlZmVyZW5jZXMuY29sb3JzU2V0KTtcbiAgICAgICAgaWYgKCF0aGlzLnN5c3RlbVRoZW1lQ2hhbmdlVW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICB0aGlzLnN5c3RlbVRoZW1lQ2hhbmdlVW5zdWJzY3JpYmUgPSBzdWJzY3JpYmVUb1RoZW1lQ2hhbmdlKHNldFRoZW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoKF9kMiA9IG9wdGlvbnMudWlQcmVmZXJlbmNlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kMi5jb2xvcnNTZXQpIHtcbiAgICAgICAgc2V0Q29sb3JzKG9wdGlvbnMudWlQcmVmZXJlbmNlcy5jb2xvcnNTZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKF9lMiA9IG9wdGlvbnMudWlQcmVmZXJlbmNlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lMi5ib3JkZXJSYWRpdXMpIHtcbiAgICAgIHNldEJvcmRlclJhZGl1cyhvcHRpb25zLnVpUHJlZmVyZW5jZXMuYm9yZGVyUmFkaXVzKTtcbiAgICB9XG4gICAgc2V0QXBwU3RhdGUoKHN0YXRlKSA9PiB7XG4gICAgICB2YXIgX2EzLCBfYjM7XG4gICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zLmxhbmd1YWdlICYmIHsgbGFuZ3VhZ2U6IG9wdGlvbnMubGFuZ3VhZ2UgfSksICEhKChfYTMgPSBvcHRpb25zLmFjdGlvbnNDb25maWd1cmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLnJldHVyblN0cmF0ZWd5KSAmJiB7XG4gICAgICAgICAgcmV0dXJuU3RyYXRlZ3k6IG9wdGlvbnMuYWN0aW9uc0NvbmZpZ3VyYXRpb24ucmV0dXJuU3RyYXRlZ3lcbiAgICAgICAgfSksICEhKChfYjMgPSBvcHRpb25zLmFjdGlvbnNDb25maWd1cmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2IzLnR3YVJldHVyblVybCkgJiYge1xuICAgICAgICAgIHR3YVJldHVyblVybDogb3B0aW9ucy5hY3Rpb25zQ29uZmlndXJhdGlvbi50d2FSZXR1cm5VcmxcbiAgICAgICAgfSksICEhb3B0aW9ucy53YWxsZXRzTGlzdENvbmZpZ3VyYXRpb24gJiYge1xuICAgICAgICAgIHdhbGxldHNMaXN0Q29uZmlndXJhdGlvbjogb3B0aW9ucy53YWxsZXRzTGlzdENvbmZpZ3VyYXRpb25cbiAgICAgICAgfSksXG4gICAgICAgIHVud3JhcChzdGF0ZSlcbiAgICAgICk7XG4gICAgICBpZiAob3B0aW9ucy5idXR0b25Sb290SWQgIT09IHZvaWQgMCkge1xuICAgICAgICBtZXJnZWQuYnV0dG9uUm9vdElkID0gb3B0aW9ucy5idXR0b25Sb290SWQ7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmFibGVBbmRyb2lkQmFja0hhbmRsZXIgIT09IHZvaWQgMCkge1xuICAgICAgICBtZXJnZWQuZW5hYmxlQW5kcm9pZEJhY2tIYW5kbGVyID0gb3B0aW9ucy5lbmFibGVBbmRyb2lkQmFja0hhbmRsZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBVc2UgaXQgdG8gY3VzdG9taXplIENvbm5lY3RSZXF1ZXN0IGFuZCBhZGQgYHRvblByb29mYCBwYXlsb2FkLlxuICAgKiBZb3UgY2FuIGNhbGwgaXQgbXVsdGlwbHkgdGltZXMgdG8gc2V0IHVwZGF0ZWQgdG9uUHJvb2YgcGF5bG9hZCBpZiBwcmV2aW91cyBvbmUgaXMgb3V0ZGF0ZWQuXG4gICAqIElmIGBjb25uZWN0UmVxdWVzdFBhcmFtZXRlcnMuc3RhdGUgPT09ICdsb2FkaW5nJ2AgbG9hZGVyIHdpbGwgYXBwZWFyIGluc3RlYWQgb2YgdGhlIHFyIGNvZGUgaW4gdGhlIHdhbGxldHMgbW9kYWwuXG4gICAqIElmIGBjb25uZWN0UmVxdWVzdFBhcmFtZXRlcnMuc3RhdGVgIHdhcyBjaGFuZ2VkIHRvICdyZWFkeScgb3IgaXQncyB2YWx1ZSBoYXMgYmVlbiBjaGFuZ2VkLCBRUiB3aWxsIGJlIHJlLXJlbmRlcmVkLlxuICAgKi9cbiAgc2V0Q29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzKGNvbm5lY3RSZXF1ZXN0UGFyYW1ldGVycykge1xuICAgIHZhciBfYTI7XG4gICAgc2V0QXBwU3RhdGUoeyBjb25uZWN0UmVxdWVzdFBhcmFtZXRlcnMgfSk7XG4gICAgaWYgKChjb25uZWN0UmVxdWVzdFBhcmFtZXRlcnMgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbm5lY3RSZXF1ZXN0UGFyYW1ldGVycy5zdGF0ZSkgPT09IFwicmVhZHlcIiB8fCAhY29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzKSB7XG4gICAgICAoX2EyID0gdGhpcy5jb25uZWN0UmVxdWVzdFBhcmFtZXRlcnNDYWxsYmFjaykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYWxsKHRoaXMsIGNvbm5lY3RSZXF1ZXN0UGFyYW1ldGVycyA9PSBudWxsID8gdm9pZCAwIDogY29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzLnZhbHVlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldCBkZXNpcmVkIG5ldHdvcmsgZm9yIHRoZSBjb25uZWN0aW9uLiBDYW4gb25seSBiZSBzZXQgYmVmb3JlIGNvbm5lY3RpbmcuXG4gICAqIElmIHdhbGxldCBjb25uZWN0cyB3aXRoIGEgZGlmZmVyZW50IGNoYWluLCB0aGUgU0RLIHdpbGwgdGhyb3cgYW4gZXJyb3IgYW5kIGFib3J0IGNvbm5lY3Rpb24uXG4gICAqIEBwYXJhbSBuZXR3b3JrIGRlc2lyZWQgbmV0d29yayBpZCAoZS5nLiwgJy0yMzknLCAnLTMnLCBvciBjdXN0b20pLiBQYXNzIHVuZGVmaW5lZCB0byBhbGxvdyBhbnkgbmV0d29yay5cbiAgICovXG4gIHNldENvbm5lY3Rpb25OZXR3b3JrKG5ldHdvcmspIHtcbiAgICB0aGlzLmNvbm5lY3Rvci5zZXRDb25uZWN0aW9uTmV0d29yayhuZXR3b3JrKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhdmFpbGFibGUgd2FsbGV0cyBsaXN0LlxuICAgKi9cbiAgZ2V0V2FsbGV0cygpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdG9yLmdldFdhbGxldHMoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIGNvbm5lY3Rpb24gc3RhdHVzIGNoYW5nZS5cbiAgICogQHJldHVybiBmdW5jdGlvbiB3aGljaCBoYXMgdG8gYmUgY2FsbGVkIHRvIHVuc3Vic2NyaWJlLlxuICAgKi9cbiAgb25TdGF0dXNDaGFuZ2UoY2FsbGJhY2ssIGVycm9yc0hhbmRsZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0b3Iub25TdGF0dXNDaGFuZ2UoKHdhbGxldCkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHdhbGxldCkge1xuICAgICAgICBjb25zdCBsYXN0U2VsZWN0ZWRXYWxsZXRJbmZvMiA9IHlpZWxkIHRoaXMuZ2V0U2VsZWN0ZWRXYWxsZXRJbmZvKHdhbGxldCk7XG4gICAgICAgIGNhbGxiYWNrKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB3YWxsZXQpLCBsYXN0U2VsZWN0ZWRXYWxsZXRJbmZvMiB8fCB0aGlzLndhbGxldEluZm9TdG9yYWdlLmdldFdhbGxldEluZm8oKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sod2FsbGV0KTtcbiAgICAgIH1cbiAgICB9KSwgZXJyb3JzSGFuZGxlcik7XG4gIH1cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBtb2RhbCB3aW5kb3csIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgdGhlIG1vZGFsIHdpbmRvdyBpcyBvcGVuZWQuXG4gICAqL1xuICBvcGVuTW9kYWwob3B0aW9ucykge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgY29uc3QgdHJhY2VJZCA9IChfYTIgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnRyYWNlSWQpICE9IG51bGwgPyBfYTIgOiBVVUlEdjcoKTtcbiAgICAgIHlpZWxkIHRoaXMubW9kYWwub3Blbih7IHRyYWNlSWQgfSk7XG4gICAgICBjb25zdCBzZXNzaW9uSWQgPSB5aWVsZCB0aGlzLmdldFNlc3Npb25JZCgpO1xuICAgICAgY29uc3QgdmlzaWJsZVdhbGxldHMgPSB3aWRnZXRDb250cm9sbGVyLmdldExhc3RWaXNpYmxlV2FsbGV0cygpO1xuICAgICAgdGhpcy50cmFja2VyLnRyYWNrV2FsbGV0TW9kYWxPcGVuZWQoXG4gICAgICAgIHZpc2libGVXYWxsZXRzLndhbGxldHMubWFwKCh3YWxsZXQpID0+IHdhbGxldC5uYW1lKSxcbiAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnRyYWNlSWRcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgbW9kYWwgd2luZG93LlxuICAgKi9cbiAgY2xvc2VNb2RhbChyZWFzb24pIHtcbiAgICB0aGlzLm1vZGFsLmNsb3NlKHJlYXNvbik7XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byB0aGUgbW9kYWwgd2luZG93IHN0YXRlIGNoYW5nZXMsIHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBoYXMgdG8gYmUgY2FsbGVkIHRvIHVuc3Vic2NyaWJlLlxuICAgKi9cbiAgb25Nb2RhbFN0YXRlQ2hhbmdlKG9uQ2hhbmdlKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kYWwub25TdGF0ZUNoYW5nZShvbkNoYW5nZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgY3VycmVudCBtb2RhbCB3aW5kb3cgc3RhdGUuXG4gICAqL1xuICBnZXQgbW9kYWxTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RhbC5zdGF0ZTtcbiAgfVxuICAvKipcbiAgICogT3BlbnMgdGhlIHNpbmdsZSB3YWxsZXQgbW9kYWwgd2luZG93LCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIHRoZSBtb2RhbCB3aW5kb3cgaXMgb3BlbmVkLlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBvcGVuU2luZ2xlV2FsbGV0TW9kYWwod2FsbGV0KSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpbmdsZVdhbGxldE1vZGFsLm9wZW4od2FsbGV0KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2UgdGhlIHNpbmdsZSB3YWxsZXQgbW9kYWwgd2luZG93LlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBjbG9zZVNpbmdsZVdhbGxldE1vZGFsKGNsb3NlUmVhc29uKSB7XG4gICAgdGhpcy5zaW5nbGVXYWxsZXRNb2RhbC5jbG9zZShjbG9zZVJlYXNvbik7XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byB0aGUgc2luZ2xlIHdhbGxldCBtb2RhbCB3aW5kb3cgc3RhdGUgY2hhbmdlcywgcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGhhcyB0byBiZSBjYWxsZWQgdG8gdW5zdWJzY3JpYmUuXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIG9uU2luZ2xlV2FsbGV0TW9kYWxTdGF0ZUNoYW5nZShvbkNoYW5nZSkge1xuICAgIHJldHVybiB0aGlzLnNpbmdsZVdhbGxldE1vZGFsLm9uU3RhdGVDaGFuZ2Uob25DaGFuZ2UpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGN1cnJlbnQgc2luZ2xlIHdhbGxldCBtb2RhbCB3aW5kb3cgc3RhdGUuXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIGdldCBzaW5nbGVXYWxsZXRNb2RhbFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnNpbmdsZVdhbGxldE1vZGFsLnN0YXRlO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYHRvbkNvbm5lY3RVSS5vcGVuTW9kYWwoKWAgaW5zdGVhZC4gV2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqIE9wZW5zIHRoZSBtb2RhbCB3aW5kb3cgYW5kIGhhbmRsZXMgYSB3YWxsZXQgY29ubmVjdGlvbi5cbiAgICogQHJldHVybiBDb25uZWN0ZWQgd2FsbGV0LlxuICAgKiBAdGhyb3dzIFRvbkNvbm5lY3RVSUVycm9yIGlmIGNvbm5lY3Rpb24gd2FzIGFib3J0ZWQuXG4gICAqL1xuICBjb25uZWN0V2FsbGV0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGNvbnN0IHRyYWNlSWQgPSAoX2EyID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50cmFjZUlkKSAhPSBudWxsID8gX2EyIDogVVVJRHY3KCk7XG4gICAgICBjb25zdCB3YWxsZXRzTGlzdCA9IHlpZWxkIHRoaXMuZ2V0V2FsbGV0cygpO1xuICAgICAgY29uc3QgZW1iZWRkZWRXYWxsZXQgPSB3YWxsZXRzTGlzdC5maW5kKGlzV2FsbGV0SW5mb0N1cnJlbnRseUVtYmVkZGVkKTtcbiAgICAgIGlmIChlbWJlZGRlZFdhbGxldCkge1xuICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jb25uZWN0RW1iZWRkZWRXYWxsZXQoZW1iZWRkZWRXYWxsZXQsIHsgdHJhY2VJZCB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNvbm5lY3RFeHRlcm5hbFdhbGxldCh7IHRyYWNlSWQgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3Qgd2FsbGV0IGFuZCBjbGVhbiBsb2NhbHN0b3JhZ2UuXG4gICAqL1xuICBkaXNjb25uZWN0KG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyO1xuICAgIGNvbnN0IHRyYWNlSWQgPSAoX2EyID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50cmFjZUlkKSAhPSBudWxsID8gX2EyIDogVVVJRHY3KCk7XG4gICAgdGhpcy50cmFja2VyLnRyYWNrRGlzY29ubmVjdGlvbih0aGlzLndhbGxldCwgXCJkYXBwXCIpO1xuICAgIHdpZGdldENvbnRyb2xsZXIuY2xlYXJBY3Rpb24oKTtcbiAgICB3aWRnZXRDb250cm9sbGVyLnJlbW92ZVNlbGVjdGVkV2FsbGV0SW5mbygpO1xuICAgIHRoaXMud2FsbGV0SW5mb1N0b3JhZ2UucmVtb3ZlV2FsbGV0SW5mbygpO1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rvci5kaXNjb25uZWN0KHsgdHJhY2VJZCB9KTtcbiAgfVxuICAvKipcbiAgICogT3BlbnMgdGhlIG1vZGFsIHdpbmRvdyBhbmQgaGFuZGxlcyB0aGUgdHJhbnNhY3Rpb24gc2VuZGluZy5cbiAgICogQHBhcmFtIHR4IHRyYW5zYWN0aW9uIHRvIHNlbmQuXG4gICAqIEBwYXJhbSBvcHRpb25zIG1vZGFsIGFuZCBub3RpZmljYXRpb25zIGJlaGF2aW91ciBzZXR0aW5ncy4gRGVmYXVsdCBpcyBzaG93IG9ubHkgJ2JlZm9yZScgbW9kYWwgYW5kIGFsbCBub3RpZmljYXRpb25zLlxuICAgKi9cbiAgc2VuZFRyYW5zYWN0aW9uKHR4LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBjb25zdCB0cmFjZUlkID0gKF9hMiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZCkgIT0gbnVsbCA/IF9hMiA6IFVVSUR2NygpO1xuICAgICAgdGhpcy50cmFja2VyLnRyYWNrVHJhbnNhY3Rpb25TZW50Rm9yU2lnbmF0dXJlKHRoaXMud2FsbGV0LCB0eCk7XG4gICAgICBpZiAoIXRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMudHJhY2tlci50cmFja1RyYW5zYWN0aW9uU2lnbmluZ0ZhaWxlZCh0aGlzLndhbGxldCwgdHgsIFwiV2FsbGV0IHdhcyBub3QgY29ubmVjdGVkXCIpO1xuICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdFVJRXJyb3IoXCJDb25uZWN0IHdhbGxldCB0byBzZW5kIGEgdHJhbnNhY3Rpb24uXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGlzSW5UTUEoKSkge1xuICAgICAgICBzZW5kRXhwYW5kKCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IG5vdGlmaWNhdGlvbnM6IG5vdGlmaWNhdGlvbnMyLCBtb2RhbHMsIHJldHVyblN0cmF0ZWd5LCB0d2FSZXR1cm5VcmwgfSA9IHRoaXMuZ2V0TW9kYWxzQW5kTm90aWZpY2F0aW9uc0NvbmZpZ3VyYXRpb24ob3B0aW9ucyk7XG4gICAgICBjb25zdCBzZXNzaW9uSWQgPSB5aWVsZCB0aGlzLmdldFNlc3Npb25JZCgpO1xuICAgICAgd2lkZ2V0Q29udHJvbGxlci5zZXRBY3Rpb24oe1xuICAgICAgICBuYW1lOiBcImNvbmZpcm0tdHJhbnNhY3Rpb25cIixcbiAgICAgICAgc2hvd05vdGlmaWNhdGlvbjogbm90aWZpY2F0aW9uczIuaW5jbHVkZXMoXCJiZWZvcmVcIiksXG4gICAgICAgIG9wZW5Nb2RhbDogbW9kYWxzLmluY2x1ZGVzKFwiYmVmb3JlXCIpLFxuICAgICAgICBzZW50OiBmYWxzZSxcbiAgICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWQgfHwgdm9pZCAwLFxuICAgICAgICB0cmFjZUlkXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IG9uUmVxdWVzdFNlbnQgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTM7XG4gICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2lkZ2V0Q29udHJvbGxlci5zZXRBY3Rpb24oe1xuICAgICAgICAgIG5hbWU6IFwiY29uZmlybS10cmFuc2FjdGlvblwiLFxuICAgICAgICAgIHNob3dOb3RpZmljYXRpb246IG5vdGlmaWNhdGlvbnMyLmluY2x1ZGVzKFwiYmVmb3JlXCIpLFxuICAgICAgICAgIG9wZW5Nb2RhbDogbW9kYWxzLmluY2x1ZGVzKFwiYmVmb3JlXCIpLFxuICAgICAgICAgIHNlbnQ6IHRydWUsXG4gICAgICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWQgfHwgdm9pZCAwLFxuICAgICAgICAgIHRyYWNlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVkaXJlY3RBZnRlclJlcXVlc3RTZW50KHtcbiAgICAgICAgICByZXR1cm5TdHJhdGVneSxcbiAgICAgICAgICB0d2FSZXR1cm5VcmwsXG4gICAgICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWQgfHwgdm9pZCAwLFxuICAgICAgICAgIHRyYWNlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBmaXJzdENsaWNrID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcmVkaXJlY3RUb1dhbGxldDIgPSAoKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmb3JjZVJlZGlyZWN0ID0gIWZpcnN0Q2xpY2s7XG4gICAgICAgICAgZmlyc3RDbGljayA9IGZhbHNlO1xuICAgICAgICAgIHlpZWxkIHRoaXMucmVkaXJlY3RBZnRlclJlcXVlc3RTZW50KHtcbiAgICAgICAgICAgIHJldHVyblN0cmF0ZWd5LFxuICAgICAgICAgICAgdHdhUmV0dXJuVXJsLFxuICAgICAgICAgICAgZm9yY2VSZWRpcmVjdCxcbiAgICAgICAgICAgIHNlc3Npb25JZDogc2Vzc2lvbklkIHx8IHZvaWQgMCxcbiAgICAgICAgICAgIHRyYWNlSWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIChfYTMgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9uUmVxdWVzdFNlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuY2FsbChvcHRpb25zLCByZWRpcmVjdFRvV2FsbGV0Mik7XG4gICAgICB9O1xuICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSB0aGlzLm9uVHJhbnNhY3Rpb25Nb2RhbFN0YXRlQ2hhbmdlKChhY3Rpb24yKSA9PiB7XG4gICAgICAgIGlmIChhY3Rpb24yID09IG51bGwgPyB2b2lkIDAgOiBhY3Rpb24yLm9wZW5Nb2RhbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICBpZiAoIWFjdGlvbjIpIHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLndhaXRGb3JTZW5kVHJhbnNhY3Rpb24oXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHR4LFxuICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgdHJhY2VJZFxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25SZXF1ZXN0U2VudFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tUcmFuc2FjdGlvblNpZ25lZCh0aGlzLndhbGxldCwgdHgsIHJlc3VsdCk7XG4gICAgICAgIHdpZGdldENvbnRyb2xsZXIuc2V0QWN0aW9uKHtcbiAgICAgICAgICBuYW1lOiBcInRyYW5zYWN0aW9uLXNlbnRcIixcbiAgICAgICAgICBzaG93Tm90aWZpY2F0aW9uOiBub3RpZmljYXRpb25zMi5pbmNsdWRlcyhcInN1Y2Nlc3NcIiksXG4gICAgICAgICAgb3Blbk1vZGFsOiBtb2RhbHMuaW5jbHVkZXMoXCJzdWNjZXNzXCIpLFxuICAgICAgICAgIHRyYWNlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICBpZiAoZTIgaW5zdGFuY2VvZiBXYWxsZXROb3RTdXBwb3J0RmVhdHVyZUVycm9yKSB7XG4gICAgICAgICAgd2lkZ2V0Q29udHJvbGxlci5jbGVhckFjdGlvbigpO1xuICAgICAgICAgIHdpZGdldENvbnRyb2xsZXIub3BlbldhbGxldE5vdFN1cHBvcnRGZWF0dXJlTW9kYWwoZTIuY2F1c2UsIHsgdHJhY2VJZCB9KTtcbiAgICAgICAgICB0aHJvdyBlMjtcbiAgICAgICAgfVxuICAgICAgICB3aWRnZXRDb250cm9sbGVyLnNldEFjdGlvbih7XG4gICAgICAgICAgbmFtZTogXCJ0cmFuc2FjdGlvbi1jYW5jZWxlZFwiLFxuICAgICAgICAgIHNob3dOb3RpZmljYXRpb246IG5vdGlmaWNhdGlvbnMyLmluY2x1ZGVzKFwiZXJyb3JcIiksXG4gICAgICAgICAgb3Blbk1vZGFsOiBtb2RhbHMuaW5jbHVkZXMoXCJlcnJvclwiKSxcbiAgICAgICAgICB0cmFjZUlkXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZTIgaW5zdGFuY2VvZiBUb25Db25uZWN0RXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBlMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUyKTtcbiAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdFVJRXJyb3IoXCJVbmhhbmRsZWQgZXJyb3I6XCIgKyBlMik7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNpZ25zIHRoZSBkYXRhIGFuZCByZXR1cm5zIHRoZSBzaWduYXR1cmUuXG4gICAqIEBwYXJhbSBkYXRhIGRhdGEgdG8gc2lnbi5cbiAgICovXG4gIHNpZ25EYXRhKGRhdGEsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGNvbnN0IHRyYWNlSWQgPSAoX2EyID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50cmFjZUlkKSAhPSBudWxsID8gX2EyIDogVVVJRHY3KCk7XG4gICAgICB0aGlzLnRyYWNrZXIudHJhY2tEYXRhU2VudEZvclNpZ25hdHVyZSh0aGlzLndhbGxldCwgZGF0YSk7XG4gICAgICBpZiAoIXRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMudHJhY2tlci50cmFja0RhdGFTaWduaW5nRmFpbGVkKHRoaXMud2FsbGV0LCBkYXRhLCBcIldhbGxldCB3YXMgbm90IGNvbm5lY3RlZFwiKTtcbiAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RVSUVycm9yKFwiQ29ubmVjdCB3YWxsZXQgdG8gc2VuZCBhIHRyYW5zYWN0aW9uLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0luVE1BKCkpIHtcbiAgICAgICAgc2VuZEV4cGFuZCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBub3RpZmljYXRpb25zOiBub3RpZmljYXRpb25zMiwgbW9kYWxzLCByZXR1cm5TdHJhdGVneSwgdHdhUmV0dXJuVXJsIH0gPSB0aGlzLmdldE1vZGFsc0FuZE5vdGlmaWNhdGlvbnNDb25maWd1cmF0aW9uKCk7XG4gICAgICBjb25zdCBzZXNzaW9uSWQgPSB5aWVsZCB0aGlzLmdldFNlc3Npb25JZCgpO1xuICAgICAgd2lkZ2V0Q29udHJvbGxlci5zZXRBY3Rpb24oe1xuICAgICAgICBuYW1lOiBcImNvbmZpcm0tc2lnbi1kYXRhXCIsXG4gICAgICAgIHNob3dOb3RpZmljYXRpb246IG5vdGlmaWNhdGlvbnMyLmluY2x1ZGVzKFwiYmVmb3JlXCIpLFxuICAgICAgICBvcGVuTW9kYWw6IG1vZGFscy5pbmNsdWRlcyhcImJlZm9yZVwiKSxcbiAgICAgICAgc2lnbmVkOiBmYWxzZSxcbiAgICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWQgfHwgdm9pZCAwLFxuICAgICAgICB0cmFjZUlkXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IG9uUmVxdWVzdFNlbnQgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTM7XG4gICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2lkZ2V0Q29udHJvbGxlci5zZXRBY3Rpb24oe1xuICAgICAgICAgIG5hbWU6IFwiY29uZmlybS1zaWduLWRhdGFcIixcbiAgICAgICAgICBzaG93Tm90aWZpY2F0aW9uOiBub3RpZmljYXRpb25zMi5pbmNsdWRlcyhcImJlZm9yZVwiKSxcbiAgICAgICAgICBvcGVuTW9kYWw6IG1vZGFscy5pbmNsdWRlcyhcImJlZm9yZVwiKSxcbiAgICAgICAgICBzaWduZWQ6IHRydWUsXG4gICAgICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWQgfHwgdm9pZCAwLFxuICAgICAgICAgIHRyYWNlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVkaXJlY3RBZnRlclJlcXVlc3RTZW50KHtcbiAgICAgICAgICByZXR1cm5TdHJhdGVneSxcbiAgICAgICAgICB0d2FSZXR1cm5VcmwsXG4gICAgICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWQgfHwgdm9pZCAwLFxuICAgICAgICAgIHRyYWNlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBmaXJzdENsaWNrID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcmVkaXJlY3RUb1dhbGxldDIgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmb3JjZVJlZGlyZWN0ID0gIWZpcnN0Q2xpY2s7XG4gICAgICAgICAgZmlyc3RDbGljayA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMucmVkaXJlY3RBZnRlclJlcXVlc3RTZW50KHtcbiAgICAgICAgICAgIHJldHVyblN0cmF0ZWd5LFxuICAgICAgICAgICAgdHdhUmV0dXJuVXJsLFxuICAgICAgICAgICAgZm9yY2VSZWRpcmVjdCxcbiAgICAgICAgICAgIHNlc3Npb25JZDogc2Vzc2lvbklkIHx8IHZvaWQgMCxcbiAgICAgICAgICAgIHRyYWNlSWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgKF9hMyA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMub25SZXF1ZXN0U2VudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jYWxsKG9wdGlvbnMsIHJlZGlyZWN0VG9XYWxsZXQyKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMub25UcmFuc2FjdGlvbk1vZGFsU3RhdGVDaGFuZ2UoKGFjdGlvbjIpID0+IHtcbiAgICAgICAgaWYgKGFjdGlvbjIgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGlvbjIub3Blbk1vZGFsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGlmICghYWN0aW9uMikge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMud2FpdEZvclNpZ25EYXRhKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBzaWduYWw6IG5ldyBBYm9ydENvbnRyb2xsZXIoKS5zaWduYWwsXG4gICAgICAgICAgICB0cmFjZUlkXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblJlcXVlc3RTZW50XG4gICAgICAgICk7XG4gICAgICAgIHRoaXMudHJhY2tlci50cmFja0RhdGFTaWduZWQodGhpcy53YWxsZXQsIGRhdGEsIHJlc3VsdCk7XG4gICAgICAgIHdpZGdldENvbnRyb2xsZXIuc2V0QWN0aW9uKHtcbiAgICAgICAgICBuYW1lOiBcImRhdGEtc2lnbmVkXCIsXG4gICAgICAgICAgc2hvd05vdGlmaWNhdGlvbjogbm90aWZpY2F0aW9uczIuaW5jbHVkZXMoXCJzdWNjZXNzXCIpLFxuICAgICAgICAgIG9wZW5Nb2RhbDogbW9kYWxzLmluY2x1ZGVzKFwic3VjY2Vzc1wiKSxcbiAgICAgICAgICB0cmFjZUlkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgaWYgKGUyIGluc3RhbmNlb2YgV2FsbGV0Tm90U3VwcG9ydEZlYXR1cmVFcnJvcikge1xuICAgICAgICAgIHdpZGdldENvbnRyb2xsZXIuY2xlYXJBY3Rpb24oKTtcbiAgICAgICAgICB3aWRnZXRDb250cm9sbGVyLm9wZW5XYWxsZXROb3RTdXBwb3J0RmVhdHVyZU1vZGFsKGUyLmNhdXNlLCB7IHRyYWNlSWQgfSk7XG4gICAgICAgICAgdGhyb3cgZTI7XG4gICAgICAgIH1cbiAgICAgICAgd2lkZ2V0Q29udHJvbGxlci5zZXRBY3Rpb24oe1xuICAgICAgICAgIG5hbWU6IFwic2lnbi1kYXRhLWNhbmNlbGVkXCIsXG4gICAgICAgICAgc2hvd05vdGlmaWNhdGlvbjogbm90aWZpY2F0aW9uczIuaW5jbHVkZXMoXCJlcnJvclwiKSxcbiAgICAgICAgICBvcGVuTW9kYWw6IG1vZGFscy5pbmNsdWRlcyhcImVycm9yXCIpLFxuICAgICAgICAgIHRyYWNlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlMiBpbnN0YW5jZW9mIFRvbkNvbm5lY3RFcnJvcikge1xuICAgICAgICAgIHRocm93IGUyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZTIpO1xuICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0VUlFcnJvcihcIlVuaGFuZGxlZCBlcnJvcjpcIiArIGUyKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBzZXNzaW9uIElEIGlmIGF2YWlsYWJsZS5cbiAgICogQHJldHVybnMgc2Vzc2lvbiBJRCBzdHJpbmcgb3IgbnVsbCBpZiBub3QgYXZhaWxhYmxlLlxuICAgKi9cbiAgZ2V0U2Vzc2lvbklkKCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EyLCBfYjI7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzdG9yYWdlID0gKF9hMiA9IHRoaXMuY29ubmVjdG9yLmRhcHBTZXR0aW5ncykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5zdG9yYWdlO1xuICAgICAgICBpZiAoc3RvcmFnZSkge1xuICAgICAgICAgIGNvbnN0IHN0b3JlZCA9IHlpZWxkIHN0b3JhZ2UuZ2V0SXRlbShcInRvbi1jb25uZWN0LXN0b3JhZ2VfYnJpZGdlLWNvbm5lY3Rpb25cIik7XG4gICAgICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLnR5cGUgPT09IFwiaHR0cFwiICYmIGNvbm5lY3Rpb24uc2Vzc2lvbkNyeXB0bykge1xuICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uQ3J5cHRvID0gbmV3IFNlc3Npb25DcnlwdG8oY29ubmVjdGlvbi5zZXNzaW9uQ3J5cHRvKTtcbiAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gc2Vzc2lvbkNyeXB0by5zZXNzaW9uSWQ7XG4gICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uSWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb24udHlwZSA9PT0gXCJodHRwXCIgJiYgKChfYjIgPSBjb25uZWN0aW9uLnNlc3Npb24pID09IG51bGwgPyB2b2lkIDAgOiBfYjIuc2Vzc2lvbktleVBhaXIpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25DcnlwdG8gPSBuZXcgU2Vzc2lvbkNyeXB0byhjb25uZWN0aW9uLnNlc3Npb24uc2Vzc2lvbktleVBhaXIpO1xuICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSBzZXNzaW9uQ3J5cHRvLnNlc3Npb25JZDtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25JZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgfVxuICByZWRpcmVjdEFmdGVyUmVxdWVzdFNlbnQoe1xuICAgIHJldHVyblN0cmF0ZWd5LFxuICAgIHR3YVJldHVyblVybCxcbiAgICBmb3JjZVJlZGlyZWN0LFxuICAgIHNlc3Npb25JZCxcbiAgICB0cmFjZUlkXG4gIH0pIHtcbiAgICBpZiAodGhpcy53YWxsZXRJbmZvICYmIFwidW5pdmVyc2FsTGlua1wiIGluIHRoaXMud2FsbGV0SW5mbyAmJiAodGhpcy53YWxsZXRJbmZvLm9wZW5NZXRob2QgPT09IFwidW5pdmVyc2FsLWxpbmtcIiB8fCB0aGlzLndhbGxldEluZm8ub3Blbk1ldGhvZCA9PT0gXCJjdXN0b20tZGVlcGxpbmtcIikpIHtcbiAgICAgIGNvbnN0IGxpbmtXaXRoU2Vzc2lvbklkID0gZW5yaWNoVW5pdmVyc2FsTGluayh0aGlzLndhbGxldEluZm8udW5pdmVyc2FsTGluaywge1xuICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgIHRyYWNlSWRcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzVGVsZWdyYW1VcmwodGhpcy53YWxsZXRJbmZvLnVuaXZlcnNhbExpbmspKSB7XG4gICAgICAgIHJlZGlyZWN0VG9UZWxlZ3JhbShsaW5rV2l0aFNlc3Npb25JZCwge1xuICAgICAgICAgIHJldHVyblN0cmF0ZWd5LFxuICAgICAgICAgIHR3YVJldHVyblVybDogdHdhUmV0dXJuVXJsIHx8IGFwcFN0YXRlLnR3YVJldHVyblVybCxcbiAgICAgICAgICBmb3JjZVJlZGlyZWN0OiBmb3JjZVJlZGlyZWN0IHx8IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVkaXJlY3RUb1dhbGxldChcbiAgICAgICAgICBsaW5rV2l0aFNlc3Npb25JZCxcbiAgICAgICAgICB0aGlzLndhbGxldEluZm8uZGVlcExpbmssXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuU3RyYXRlZ3ksXG4gICAgICAgICAgICBmb3JjZVJlZGlyZWN0OiBmb3JjZVJlZGlyZWN0IHx8IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogVE9ETzogcmVtb3ZlIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqIEluaXRpYXRlcyBhIGNvbm5lY3Rpb24gd2l0aCBhbiBlbWJlZGRlZCB3YWxsZXQsIGF3YWl0cyBpdHMgY29tcGxldGlvbiwgYW5kIHJldHVybnMgdGhlIGNvbm5lY3RlZCB3YWxsZXQgaW5mb3JtYXRpb24uXG4gICAqIEBwYXJhbSBlbWJlZGRlZFdhbGxldCAtIEluZm9ybWF0aW9uIGFib3V0IHRoZSBlbWJlZGRlZCB3YWxsZXQgdG8gY29ubmVjdCB0by5cbiAgICogQHRocm93cyBFcnJvciBpZiB0aGUgY29ubmVjdGlvbiBwcm9jZXNzIGZhaWxzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbm5lY3RFbWJlZGRlZFdhbGxldChlbWJlZGRlZFdhbGxldCwgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBjb25uZWN0ID0gKHBhcmFtZXRlcnMpID0+IHtcbiAgICAgICAgc2V0TGFzdFNlbGVjdGVkV2FsbGV0SW5mbyhlbWJlZGRlZFdhbGxldCk7XG4gICAgICAgIHRoaXMuY29ubmVjdG9yLmNvbm5lY3QoeyBqc0JyaWRnZUtleTogZW1iZWRkZWRXYWxsZXQuanNCcmlkZ2VLZXkgfSwgcGFyYW1ldGVycywge1xuICAgICAgICAgIHRyYWNlSWQ6IG9wdGlvbnMudHJhY2VJZFxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBhZGRpdGlvbmFsUmVxdWVzdCA9IGFwcFN0YXRlLmNvbm5lY3RSZXF1ZXN0UGFyYW1ldGVycztcbiAgICAgIGlmICgoYWRkaXRpb25hbFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IGFkZGl0aW9uYWxSZXF1ZXN0LnN0YXRlKSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0UmVxdWVzdFBhcmFtZXRlcnNDYWxsYmFjayA9IGNvbm5lY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25uZWN0KGFkZGl0aW9uYWxSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBhZGRpdGlvbmFsUmVxdWVzdC52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geWllbGQgdGhpcy53YWl0Rm9yV2FsbGV0Q29ubmVjdGlvbih7XG4gICAgICAgIGlnbm9yZUVycm9yczogZmFsc2UsXG4gICAgICAgIHRyYWNlSWQ6IG9wdGlvbnMudHJhY2VJZFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRPRE86IHJlbW92ZSBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKiBJbml0aWF0ZXMgdGhlIGNvbm5lY3Rpb24gcHJvY2VzcyBmb3IgYW4gZXh0ZXJuYWwgd2FsbGV0IGJ5IG9wZW5pbmcgdGhlIHdhbGxldCBtb2RhbFxuICAgKiBhbmQgcmV0dXJucyB0aGUgY29ubmVjdGVkIHdhbGxldCBpbmZvcm1hdGlvbiB1cG9uIHN1Y2Nlc3NmdWwgY29ubmVjdGlvbi5cbiAgICogQHRocm93cyBFcnJvciBpZiB0aGUgdXNlciBjYW5jZWxzIHRoZSBjb25uZWN0aW9uIHByb2Nlc3Mgb3IgaWYgdGhlIGNvbm5lY3Rpb24gcHJvY2VzcyBmYWlscy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25uZWN0RXh0ZXJuYWxXYWxsZXQob3B0aW9ucykge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICB3aWRnZXRDb250cm9sbGVyLm9wZW5XYWxsZXRzTW9kYWwoeyB0cmFjZUlkOiBvcHRpb25zLnRyYWNlSWQgfSk7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMub25Nb2RhbFN0YXRlQ2hhbmdlKChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY2xvc2VSZWFzb24gfSA9IHN0YXRlO1xuICAgICAgICBpZiAoc3RhdHVzID09PSBcIm9wZW5lZFwiKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGlmIChjbG9zZVJlYXNvbiA9PT0gXCJhY3Rpb24tY2FuY2VsbGVkXCIpIHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4geWllbGQgdGhpcy53YWl0Rm9yV2FsbGV0Q29ubmVjdGlvbih7XG4gICAgICAgIGlnbm9yZUVycm9yczogdHJ1ZSxcbiAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICB0cmFjZUlkOiBvcHRpb25zLnRyYWNlSWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUT0RPOiByZW1vdmUgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICogV2FpdHMgZm9yIGEgd2FsbGV0IGNvbm5lY3Rpb24gYmFzZWQgb24gcHJvdmlkZWQgb3B0aW9ucywgcmV0dXJuaW5nIGNvbm5lY3RlZCB3YWxsZXQgaW5mb3JtYXRpb24uXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbiBmb3IgY29ubmVjdGlvbiBzdGF0dXNlcyBhbmQgZXJyb3JzIGhhbmRsaW5nLlxuICAgKiBAb3B0aW9ucy5pZ25vcmVFcnJvcnMgLSBJZiB0cnVlLCBpZ25vcmVzIGVycm9ycyBkdXJpbmcgd2FpdGluZywgd2FpdGluZyBjb250aW51ZXMgdW50aWwgYSB2YWxpZCB3YWxsZXQgY29ubmVjdHMuIERlZmF1bHQgaXMgZmFsc2UuXG4gICAqIEBvcHRpb25zLmFib3J0U2lnbmFsIC0gT3B0aW9uYWwgQWJvcnRTaWduYWwgZm9yIGV4dGVybmFsIGNhbmNlbGxhdGlvbi4gVGhyb3dzIFRvbkNvbm5lY3RVSUVycm9yIGlmIGFib3J0ZWQuXG4gICAqIEB0aHJvd3MgVG9uQ29ubmVjdFVJRXJyb3IgaWYgd2FpdGluZyBpcyBhYm9ydGVkIG9yIG5vIHZhbGlkIHdhbGxldCBjb25uZWN0aW9uIGlzIHJlY2VpdmVkIGFuZCBpZ25vcmVFcnJvcnMgaXMgZmFsc2UuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgd2FpdEZvcldhbGxldENvbm5lY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uU3RhcnRlZCgpO1xuICAgICAgICBjb25zdCB7IGlnbm9yZUVycm9ycyA9IGZhbHNlLCBzaWduYWwgPSBudWxsIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrQ29ubmVjdGlvbkVycm9yKFwiQ29ubmVjdGlvbiB3YXMgY2FuY2VsbGVkXCIpO1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IFRvbkNvbm5lY3RVSUVycm9yKFwiV2FsbGV0IHdhcyBub3QgY29ubmVjdGVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvblN0YXR1c0NoYW5nZUhhbmRsZXIgPSAod2FsbGV0KSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgaWYgKCF3YWxsZXQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2tlci50cmFja0Nvbm5lY3Rpb25FcnJvcihcIkNvbm5lY3Rpb24gd2FzIGNhbmNlbGxlZFwiKTtcbiAgICAgICAgICAgIGlmIChpZ25vcmVFcnJvcnMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgVG9uQ29ubmVjdFVJRXJyb3IoXCJXYWxsZXQgd2FzIG5vdCBjb25uZWN0ZWRcIikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uQ29tcGxldGVkKHdhbGxldCk7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgcmVzb2x2ZSh3YWxsZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG9uRXJyb3JzSGFuZGxlciA9IChyZWFzb24pID0+IHtcbiAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uRXJyb3IocmVhc29uLm1lc3NhZ2UpO1xuICAgICAgICAgIGlmIChpZ25vcmVFcnJvcnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSB0aGlzLm9uU3RhdHVzQ2hhbmdlKFxuICAgICAgICAgICh3YWxsZXQpID0+IG9uU3RhdHVzQ2hhbmdlSGFuZGxlcih3YWxsZXQpLFxuICAgICAgICAgIChyZWFzb24pID0+IG9uRXJyb3JzSGFuZGxlcihyZWFzb24pXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgIFwiYWJvcnRcIixcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUb25Db25uZWN0VUlFcnJvcihcIldhbGxldCB3YXMgbm90IGNvbm5lY3RlZFwiKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBvbmNlOiB0cnVlIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogV2FpdHMgZm9yIGEgdHJhbnNhY3Rpb24gdG8gYmUgc2VudCBiYXNlZCBvbiBwcm92aWRlZCBvcHRpb25zLCByZXR1cm5pbmcgdGhlIHRyYW5zYWN0aW9uIHJlc3BvbnNlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gZm9yIHRyYW5zYWN0aW9uIHN0YXR1c2VzIGFuZCBlcnJvcnMgaGFuZGxpbmcuXG4gICAqIEBvcHRpb25zLnRyYW5zYWN0aW9uIC0gVHJhbnNhY3Rpb24gdG8gc2VuZC5cbiAgICogQG9wdGlvbnMuaWdub3JlRXJyb3JzIC0gSWYgdHJ1ZSwgaWdub3JlcyBlcnJvcnMgZHVyaW5nIHdhaXRpbmcsIHdhaXRpbmcgY29udGludWVzIHVudGlsIGEgdmFsaWQgdHJhbnNhY3Rpb24gaXMgc2VudC4gRGVmYXVsdCBpcyBmYWxzZS5cbiAgICogQG9wdGlvbnMuYWJvcnRTaWduYWwgLSBPcHRpb25hbCBBYm9ydFNpZ25hbCBmb3IgZXh0ZXJuYWwgY2FuY2VsbGF0aW9uLiBUaHJvd3MgVG9uQ29ubmVjdFVJRXJyb3IgaWYgYWJvcnRlZC5cbiAgICogQHBhcmFtIG9uUmVxdWVzdFNlbnQgKG9wdGlvbmFsKSB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgdHJhbnNhY3Rpb24gaXMgc2VudCB0byB0aGUgd2FsbGV0LlxuICAgKiBAdGhyb3dzIFRvbkNvbm5lY3RVSUVycm9yIGlmIHdhaXRpbmcgaXMgYWJvcnRlZCBvciBubyB2YWxpZCB0cmFuc2FjdGlvbiByZXNwb25zZSBpcyByZWNlaXZlZCBhbmQgaWdub3JlRXJyb3JzIGlzIGZhbHNlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHdhaXRGb3JTZW5kVHJhbnNhY3Rpb24ob3B0aW9ucywgb25SZXF1ZXN0U2VudCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9uLCBzaWduYWwgfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHRoaXMudHJhY2tlci50cmFja1RyYW5zYWN0aW9uU2lnbmluZ0ZhaWxlZChcbiAgICAgICAgICAgIHRoaXMud2FsbGV0LFxuICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBcIlRyYW5zYWN0aW9uIHdhcyBjYW5jZWxsZWRcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgVG9uQ29ubmVjdFVJRXJyb3IoXCJUcmFuc2FjdGlvbiB3YXMgbm90IHNlbnRcIikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uVHJhbnNhY3Rpb25IYW5kbGVyID0gKHRyYW5zYWN0aW9uMikgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIHJlc29sdmUodHJhbnNhY3Rpb24yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG9uRXJyb3JzSGFuZGxlciA9IChyZWFzb24pID0+IHtcbiAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25DYW5jZWxlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrVHJhbnNhY3Rpb25TaWduaW5nRmFpbGVkKFxuICAgICAgICAgICAgdGhpcy53YWxsZXQsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgIFwiVHJhbnNhY3Rpb24gd2FzIGNhbmNlbGxlZFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZWplY3QobmV3IFRvbkNvbm5lY3RVSUVycm9yKFwiVHJhbnNhY3Rpb24gd2FzIG5vdCBzZW50XCIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkNhbmNlbGVkSGFuZGxlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rvci5zZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHtcbiAgICAgICAgICBvblJlcXVlc3RTZW50LFxuICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICB0cmFjZUlkOiBvcHRpb25zLnRyYWNlSWRcbiAgICAgICAgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkNhbmNlbGVkSGFuZGxlcik7XG4gICAgICAgICAgcmV0dXJuIG9uVHJhbnNhY3Rpb25IYW5kbGVyKHJlc3VsdCk7XG4gICAgICAgIH0pLmNhdGNoKChyZWFzb24pID0+IHtcbiAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQ2FuY2VsZWRIYW5kbGVyKTtcbiAgICAgICAgICByZXR1cm4gb25FcnJvcnNIYW5kbGVyKHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFdhaXRzIGZvciBhIHRyYW5zYWN0aW9uIHRvIGJlIHNlbnQgYmFzZWQgb24gcHJvdmlkZWQgb3B0aW9ucywgcmV0dXJuaW5nIHRoZSB0cmFuc2FjdGlvbiByZXNwb25zZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIGZvciB0cmFuc2FjdGlvbiBzdGF0dXNlcyBhbmQgZXJyb3JzIGhhbmRsaW5nLlxuICAgKiBAb3B0aW9ucy50cmFuc2FjdGlvbiAtIFRyYW5zYWN0aW9uIHRvIHNlbmQuXG4gICAqIEBvcHRpb25zLmlnbm9yZUVycm9ycyAtIElmIHRydWUsIGlnbm9yZXMgZXJyb3JzIGR1cmluZyB3YWl0aW5nLCB3YWl0aW5nIGNvbnRpbnVlcyB1bnRpbCBhIHZhbGlkIHRyYW5zYWN0aW9uIGlzIHNlbnQuIERlZmF1bHQgaXMgZmFsc2UuXG4gICAqIEBvcHRpb25zLmFib3J0U2lnbmFsIC0gT3B0aW9uYWwgQWJvcnRTaWduYWwgZm9yIGV4dGVybmFsIGNhbmNlbGxhdGlvbi4gVGhyb3dzIFRvbkNvbm5lY3RVSUVycm9yIGlmIGFib3J0ZWQuXG4gICAqIEBwYXJhbSBvblJlcXVlc3RTZW50IChvcHRpb25hbCkgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHRyYW5zYWN0aW9uIGlzIHNlbnQgdG8gdGhlIHdhbGxldC5cbiAgICogQHRocm93cyBUb25Db25uZWN0VUlFcnJvciBpZiB3YWl0aW5nIGlzIGFib3J0ZWQgb3Igbm8gdmFsaWQgdHJhbnNhY3Rpb24gcmVzcG9uc2UgaXMgcmVjZWl2ZWQgYW5kIGlnbm9yZUVycm9ycyBpcyBmYWxzZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB3YWl0Rm9yU2lnbkRhdGEob3B0aW9ucywgb25SZXF1ZXN0U2VudCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB7IGRhdGEsIHNpZ25hbCB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrRGF0YVNpZ25pbmdGYWlsZWQodGhpcy53YWxsZXQsIGRhdGEsIFwiU2lnbkRhdGEgd2FzIGNhbmNlbGxlZFwiKTtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBUb25Db25uZWN0VUlFcnJvcihcIlNpZ25EYXRhIHdhcyBub3Qgc2VudFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb25TaWduSGFuZGxlciA9IChkYXRhMikgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIHJlc29sdmUoZGF0YTIpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb25FcnJvcnNIYW5kbGVyID0gKHJlYXNvbikgPT4ge1xuICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkNhbmNlbGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tEYXRhU2lnbmluZ0ZhaWxlZCh0aGlzLndhbGxldCwgZGF0YSwgXCJTaWduRGF0YSB3YXMgY2FuY2VsbGVkXCIpO1xuICAgICAgICAgIHJlamVjdChuZXcgVG9uQ29ubmVjdFVJRXJyb3IoXCJTaWduRGF0YSB3YXMgbm90IHNlbnRcIikpO1xuICAgICAgICB9O1xuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQ2FuY2VsZWRIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdG9yLnNpZ25EYXRhKGRhdGEsIHsgb25SZXF1ZXN0U2VudCwgc2lnbmFsIH0pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgIHJldHVybiBvblNpZ25IYW5kbGVyKHJlc3VsdCk7XG4gICAgICAgIH0pLmNhdGNoKChyZWFzb24pID0+IHtcbiAgICAgICAgICByZXR1cm4gb25FcnJvcnNIYW5kbGVyKHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byB0aGUgdHJhbnNhY3Rpb24gbW9kYWwgd2luZG93IHN0YXRlIGNoYW5nZXMsIHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBoYXMgdG8gYmUgY2FsbGVkIHRvIHVuc3Vic2NyaWJlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG9uVHJhbnNhY3Rpb25Nb2RhbFN0YXRlQ2hhbmdlKG9uQ2hhbmdlKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb25Nb2RhbC5vblN0YXRlQ2hhbmdlKG9uQ2hhbmdlKTtcbiAgfVxuICBzdWJzY3JpYmVUb1dhbGxldENoYW5nZSgpIHtcbiAgICB0aGlzLmNvbm5lY3Rvci5vblN0YXR1c0NoYW5nZSgod2FsbGV0KSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgaWYgKHdhbGxldCkge1xuICAgICAgICB5aWVsZCB0aGlzLnVwZGF0ZVdhbGxldEluZm8od2FsbGV0KTtcbiAgICAgICAgdGhpcy5zZXRQcmVmZXJyZWRXYWxsZXRBcHBOYW1lKCgoX2EyID0gdGhpcy53YWxsZXRJbmZvKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmFwcE5hbWUpIHx8IHdhbGxldC5kZXZpY2UuYXBwTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndhbGxldEluZm9TdG9yYWdlLnJlbW92ZVdhbGxldEluZm8oKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cbiAgc2V0UHJlZmVycmVkV2FsbGV0QXBwTmFtZSh2YWx1ZSkge1xuICAgIHRoaXMucHJlZmVycmVkV2FsbGV0U3RvcmFnZS5zZXRQcmVmZXJyZWRXYWxsZXRBcHBOYW1lKHZhbHVlKTtcbiAgICBzZXRBcHBTdGF0ZSh7IHByZWZlcnJlZFdhbGxldEFwcE5hbWU6IHZhbHVlIH0pO1xuICB9XG4gIGdldFNlbGVjdGVkV2FsbGV0SW5mbyh3YWxsZXQpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGV0IGxhc3RTZWxlY3RlZFdhbGxldEluZm8yID0gd2lkZ2V0Q29udHJvbGxlci5nZXRTZWxlY3RlZFdhbGxldEluZm8oKTtcbiAgICAgIGlmICghbGFzdFNlbGVjdGVkV2FsbGV0SW5mbzIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIShcIm5hbWVcIiBpbiBsYXN0U2VsZWN0ZWRXYWxsZXRJbmZvMikpIHtcbiAgICAgICAgaWYgKHdhbGxldC5kZXZpY2UuYXBwTmFtZSA9PT0gV0FMTEVUX0NPTk5FQ1RfQVBQX05BTUUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJ3YWxsZXQtY29ubmVjdFwiLFxuICAgICAgICAgICAgbmFtZTogV0FMTEVUX0NPTk5FQ1RfV0FMTEVUX05BTUUsXG4gICAgICAgICAgICBhcHBOYW1lOiBXQUxMRVRfQ09OTkVDVF9BUFBfTkFNRSxcbiAgICAgICAgICAgIGltYWdlVXJsOiBJTUcuV0FMTEVUX0NPTk5FQ1QsXG4gICAgICAgICAgICBhYm91dFVybDogV0FMTEVUX0NPTk5FQ1RfQUJPVVRfVVJMLFxuICAgICAgICAgICAgZmVhdHVyZXM6IHdhbGxldC5kZXZpY2UuZmVhdHVyZXMsXG4gICAgICAgICAgICBwbGF0Zm9ybXM6IFtdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YWxsZXRzTGlzdCA9IGFwcGx5V2FsbGV0c0xpc3RDb25maWd1cmF0aW9uKFxuICAgICAgICAgIHlpZWxkIHRoaXMud2FsbGV0c0xpc3QsXG4gICAgICAgICAgYXBwU3RhdGUud2FsbGV0c0xpc3RDb25maWd1cmF0aW9uXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHdhbGxldEluZm8gPSB3YWxsZXRzTGlzdC5maW5kKChpdGVtKSA9PiBlcVdhbGxldE5hbWUoaXRlbSwgd2FsbGV0LmRldmljZS5hcHBOYW1lKSk7XG4gICAgICAgIGlmICghd2FsbGV0SW5mbykge1xuICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0VUlFcnJvcihcbiAgICAgICAgICAgIGBDYW5ub3QgZmluZCBXYWxsZXRJbmZvIGZvciB0aGUgJyR7d2FsbGV0LmRldmljZS5hcHBOYW1lfScgd2FsbGV0YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB3YWxsZXRJbmZvKSwgbGFzdFNlbGVjdGVkV2FsbGV0SW5mbzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxhc3RTZWxlY3RlZFdhbGxldEluZm8yO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVdhbGxldEluZm8od2FsbGV0KSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkV2FsbGV0SW5mbyA9IHlpZWxkIHRoaXMuZ2V0U2VsZWN0ZWRXYWxsZXRJbmZvKHdhbGxldCk7XG4gICAgICBpZiAoc2VsZWN0ZWRXYWxsZXRJbmZvKSB7XG4gICAgICAgIHRoaXMud2FsbGV0SW5mbyA9IHNlbGVjdGVkV2FsbGV0SW5mbztcbiAgICAgICAgdGhpcy53YWxsZXRJbmZvU3RvcmFnZS5zZXRXYWxsZXRJbmZvKHNlbGVjdGVkV2FsbGV0SW5mbyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0b3JlZFdhbGxldEluZm8gPSB0aGlzLndhbGxldEluZm9TdG9yYWdlLmdldFdhbGxldEluZm8oKTtcbiAgICAgIGlmIChzdG9yZWRXYWxsZXRJbmZvKSB7XG4gICAgICAgIHRoaXMud2FsbGV0SW5mbyA9IHN0b3JlZFdhbGxldEluZm87XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMud2FsbGV0SW5mbyA9ICh5aWVsZCB0aGlzLndhbGxldHNMaXN0KS5maW5kKFxuICAgICAgICAod2FsbGV0SW5mbykgPT4gZXFXYWxsZXROYW1lKHdhbGxldEluZm8sIHdhbGxldC5kZXZpY2UuYXBwTmFtZSlcbiAgICAgICkgfHwgbnVsbDtcbiAgICB9KTtcbiAgfVxuICBub3JtYWxpemVXaWRnZXRSb290KHJvb3RJZCkge1xuICAgIGlmICghcm9vdElkIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyb290SWQpKSB7XG4gICAgICByb290SWQgPSBcInRjLXdpZGdldC1yb290XCI7XG4gICAgICBjb25zdCByb290RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICByb290RWxlbWVudC5pZCA9IHJvb3RJZDtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocm9vdEVsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gcm9vdElkO1xuICB9XG4gIGNoZWNrQnV0dG9uUm9vdEV4aXN0KGJ1dHRvblJvb3RJZCkge1xuICAgIGlmIChidXR0b25Sb290SWQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGJ1dHRvblJvb3RJZCkpIHtcbiAgICAgIHRocm93IG5ldyBUb25Db25uZWN0VUlFcnJvcihgJHtidXR0b25Sb290SWR9IGVsZW1lbnQgbm90IGZvdW5kIGluIHRoZSBkb2N1bWVudC5gKTtcbiAgICB9XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgZ2V0TW9kYWxzQW5kTm90aWZpY2F0aW9uc0NvbmZpZ3VyYXRpb24ob3B0aW9ucykge1xuICAgIHZhciBfYTIsIF9iMiwgX2MyLCBfZDIsIF9lMiwgX2YyO1xuICAgIGNvbnN0IGFsbEFjdGlvbnMgPSBbXG4gICAgICBcImJlZm9yZVwiLFxuICAgICAgXCJzdWNjZXNzXCIsXG4gICAgICBcImVycm9yXCJcbiAgICBdO1xuICAgIGxldCBub3RpZmljYXRpb25zMiA9IGFsbEFjdGlvbnM7XG4gICAgaWYgKCgoX2EyID0gdGhpcy5hY3Rpb25zQ29uZmlndXJhdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5ub3RpZmljYXRpb25zKSAmJiAoKF9iMiA9IHRoaXMuYWN0aW9uc0NvbmZpZ3VyYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYjIubm90aWZpY2F0aW9ucykgIT09IFwiYWxsXCIpIHtcbiAgICAgIG5vdGlmaWNhdGlvbnMyID0gdGhpcy5hY3Rpb25zQ29uZmlndXJhdGlvbi5ub3RpZmljYXRpb25zO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5ub3RpZmljYXRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy5ub3RpZmljYXRpb25zID09PSBcImFsbFwiKSB7XG4gICAgICAgIG5vdGlmaWNhdGlvbnMyID0gYWxsQWN0aW9ucztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vdGlmaWNhdGlvbnMyID0gb3B0aW9ucy5ub3RpZmljYXRpb25zO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbW9kYWxzID0gW1wiYmVmb3JlXCJdO1xuICAgIGlmICgoX2MyID0gdGhpcy5hY3Rpb25zQ29uZmlndXJhdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jMi5tb2RhbHMpIHtcbiAgICAgIGlmICh0aGlzLmFjdGlvbnNDb25maWd1cmF0aW9uLm1vZGFscyA9PT0gXCJhbGxcIikge1xuICAgICAgICBtb2RhbHMgPSBhbGxBY3Rpb25zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kYWxzID0gdGhpcy5hY3Rpb25zQ29uZmlndXJhdGlvbi5tb2RhbHM7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGFscykge1xuICAgICAgaWYgKG9wdGlvbnMubW9kYWxzID09PSBcImFsbFwiKSB7XG4gICAgICAgIG1vZGFscyA9IGFsbEFjdGlvbnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RhbHMgPSBvcHRpb25zLm1vZGFscztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmV0dXJuU3RyYXRlZ3kgPSAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5yZXR1cm5TdHJhdGVneSkgfHwgKChfZDIgPSB0aGlzLmFjdGlvbnNDb25maWd1cmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2QyLnJldHVyblN0cmF0ZWd5KSB8fCBcImJhY2tcIjtcbiAgICBjb25zdCB0d2FSZXR1cm5VcmwgPSAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50d2FSZXR1cm5VcmwpIHx8ICgoX2UyID0gdGhpcy5hY3Rpb25zQ29uZmlndXJhdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9lMi50d2FSZXR1cm5VcmwpO1xuICAgIGxldCBza2lwUmVkaXJlY3RUb1dhbGxldCA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnNraXBSZWRpcmVjdFRvV2FsbGV0KSB8fCAoKF9mMiA9IHRoaXMuYWN0aW9uc0NvbmZpZ3VyYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZjIuc2tpcFJlZGlyZWN0VG9XYWxsZXQpIHx8IFwiaW9zXCI7XG4gICAgaWYgKGlzSW5UTUEoKSkge1xuICAgICAgc2tpcFJlZGlyZWN0VG9XYWxsZXQgPSBcIm5ldmVyXCI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBub3RpZmljYXRpb25zOiBub3RpZmljYXRpb25zMixcbiAgICAgIG1vZGFscyxcbiAgICAgIHJldHVyblN0cmF0ZWd5LFxuICAgICAgdHdhUmV0dXJuVXJsLFxuICAgICAgc2tpcFJlZGlyZWN0VG9XYWxsZXRcbiAgICB9O1xuICB9XG59XG5leHBvcnQge1xuICBUSEVNRSxcbiAgVG9uQ29ubmVjdFVJLFxuICBUb25Db25uZWN0VUlFcnJvclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tonconnect/ui/lib/index.mjs\n");

/***/ })

};
;