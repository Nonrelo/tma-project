/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "?da34":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "?5ddf":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C123%5C%5CDesktop%5C%5Ctma-project%5C%5Cfrontend%5C%5Csrc%5C%5Capp%5C%5Clayout.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!***********************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C123%5C%5CDesktop%5C%5Ctma-project%5C%5Cfrontend%5C%5Csrc%5C%5Capp%5C%5Clayout.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \***********************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/layout.tsx */ \"(app-pages-browser)/./src/app/layout.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDMTIzJTVDJTVDRGVza3RvcCU1QyU1Q3RtYS1wcm9qZWN0JTVDJTVDZnJvbnRlbmQlNUMlNUNzcmMlNUMlNUNhcHAlNUMlNUNsYXlvdXQudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsa0tBQXlHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/ZDdlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkM6XFxcXFVzZXJzXFxcXDEyM1xcXFxEZXNrdG9wXFxcXHRtYS1wcm9qZWN0XFxcXGZyb250ZW5kXFxcXHNyY1xcXFxhcHBcXFxcbGF5b3V0LnRzeFwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C123%5C%5CDesktop%5C%5Ctma-project%5C%5Cfrontend%5C%5Csrc%5C%5Capp%5C%5Clayout.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tonconnect/isomorphic-eventsource/browser.js":
/*!********************************************************************!*\
  !*** ./node_modules/@tonconnect/isomorphic-eventsource/browser.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("{}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdG9uY29ubmVjdC9pc29tb3JwaGljLWV2ZW50c291cmNlL2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0b25jb25uZWN0L2lzb21vcnBoaWMtZXZlbnRzb3VyY2UvYnJvd3Nlci5qcz9mYzM4Il0sInNvdXJjZXNDb250ZW50IjpbInt9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tonconnect/isomorphic-eventsource/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tonconnect/isomorphic-fetch/browser.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tonconnect/isomorphic-fetch/browser.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("{}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdG9uY29ubmVjdC9pc29tb3JwaGljLWZldGNoL2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0b25jb25uZWN0L2lzb21vcnBoaWMtZmV0Y2gvYnJvd3Nlci5qcz82MzhiIl0sInNvdXJjZXNDb250ZW50IjpbInt9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tonconnect/isomorphic-fetch/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/deepmerge/dist/cjs.js":
/*!********************************************!*\
  !*** ./node_modules/deepmerge/dist/cjs.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kZWVwbWVyZ2UvZGlzdC9janMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2RlZXBtZXJnZS9kaXN0L2Nqcy5qcz9kN2U4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGlzTWVyZ2VhYmxlT2JqZWN0ID0gZnVuY3Rpb24gaXNNZXJnZWFibGVPYmplY3QodmFsdWUpIHtcblx0cmV0dXJuIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSlcblx0XHQmJiAhaXNTcGVjaWFsKHZhbHVlKVxufTtcblxuZnVuY3Rpb24gaXNOb25OdWxsT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbn1cblxuZnVuY3Rpb24gaXNTcGVjaWFsKHZhbHVlKSB7XG5cdHZhciBzdHJpbmdWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cblx0cmV0dXJuIHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBSZWdFeHBdJ1xuXHRcdHx8IHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBEYXRlXSdcblx0XHR8fCBpc1JlYWN0RWxlbWVudCh2YWx1ZSlcbn1cblxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2I1YWM5NjNmYjc5MWQxMjk4ZTdmMzk2MjM2MzgzYmM5NTVmOTE2YzEvc3JjL2lzb21vcnBoaWMvY2xhc3NpYy9lbGVtZW50L1JlYWN0RWxlbWVudC5qcyNMMjEtTDI1XG52YXIgY2FuVXNlU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGNhblVzZVN5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcblxuZnVuY3Rpb24gaXNSZWFjdEVsZW1lbnQodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbn1cblxuZnVuY3Rpb24gZW1wdHlUYXJnZXQodmFsKSB7XG5cdHJldHVybiBBcnJheS5pc0FycmF5KHZhbCkgPyBbXSA6IHt9XG59XG5cbmZ1bmN0aW9uIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHZhbHVlLCBvcHRpb25zKSB7XG5cdHJldHVybiAob3B0aW9ucy5jbG9uZSAhPT0gZmFsc2UgJiYgb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkpXG5cdFx0PyBkZWVwbWVyZ2UoZW1wdHlUYXJnZXQodmFsdWUpLCB2YWx1ZSwgb3B0aW9ucylcblx0XHQ6IHZhbHVlXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRBcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdHJldHVybiB0YXJnZXQuY29uY2F0KHNvdXJjZSkubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoZWxlbWVudCwgb3B0aW9ucylcblx0fSlcbn1cblxuZnVuY3Rpb24gZ2V0TWVyZ2VGdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcblx0aWYgKCFvcHRpb25zLmN1c3RvbU1lcmdlKSB7XG5cdFx0cmV0dXJuIGRlZXBtZXJnZVxuXHR9XG5cdHZhciBjdXN0b21NZXJnZSA9IG9wdGlvbnMuY3VzdG9tTWVyZ2Uoa2V5KTtcblx0cmV0dXJuIHR5cGVvZiBjdXN0b21NZXJnZSA9PT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbU1lcmdlIDogZGVlcG1lcmdlXG59XG5cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSB7XG5cdHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzXG5cdFx0PyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkuZmlsdGVyKGZ1bmN0aW9uKHN5bWJvbCkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRhcmdldCwgc3ltYm9sKVxuXHRcdH0pXG5cdFx0OiBbXVxufVxuXG5mdW5jdGlvbiBnZXRLZXlzKHRhcmdldCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXModGFyZ2V0KS5jb25jYXQoZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKVxufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUlzT25PYmplY3Qob2JqZWN0LCBwcm9wZXJ0eSkge1xuXHR0cnkge1xuXHRcdHJldHVybiBwcm9wZXJ0eSBpbiBvYmplY3Rcblx0fSBjYXRjaChfKSB7XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cbn1cblxuLy8gUHJvdGVjdHMgZnJvbSBwcm90b3R5cGUgcG9pc29uaW5nIGFuZCB1bmV4cGVjdGVkIG1lcmdpbmcgdXAgdGhlIHByb3RvdHlwZSBjaGFpbi5cbmZ1bmN0aW9uIHByb3BlcnR5SXNVbnNhZmUodGFyZ2V0LCBrZXkpIHtcblx0cmV0dXJuIHByb3BlcnR5SXNPbk9iamVjdCh0YXJnZXQsIGtleSkgLy8gUHJvcGVydGllcyBhcmUgc2FmZSB0byBtZXJnZSBpZiB0aGV5IGRvbid0IGV4aXN0IGluIHRoZSB0YXJnZXQgeWV0LFxuXHRcdCYmICEoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpIC8vIHVuc2FmZSBpZiB0aGV5IGV4aXN0IHVwIHRoZSBwcm90b3R5cGUgY2hhaW4sXG5cdFx0XHQmJiBPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0YXJnZXQsIGtleSkpIC8vIGFuZCBhbHNvIHVuc2FmZSBpZiB0aGV5J3JlIG5vbmVudW1lcmFibGUuXG59XG5cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdHZhciBkZXN0aW5hdGlvbiA9IHt9O1xuXHRpZiAob3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCh0YXJnZXQpKSB7XG5cdFx0Z2V0S2V5cyh0YXJnZXQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodGFyZ2V0W2tleV0sIG9wdGlvbnMpO1xuXHRcdH0pO1xuXHR9XG5cdGdldEtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdGlmIChwcm9wZXJ0eUlzVW5zYWZlKHRhcmdldCwga2V5KSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0aWYgKHByb3BlcnR5SXNPbk9iamVjdCh0YXJnZXQsIGtleSkgJiYgb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdChzb3VyY2Vba2V5XSkpIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBnZXRNZXJnZUZ1bmN0aW9uKGtleSwgb3B0aW9ucykodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBvcHRpb25zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHNvdXJjZVtrZXldLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZGVzdGluYXRpb25cbn1cblxuZnVuY3Rpb24gZGVlcG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRvcHRpb25zLmFycmF5TWVyZ2UgPSBvcHRpb25zLmFycmF5TWVyZ2UgfHwgZGVmYXVsdEFycmF5TWVyZ2U7XG5cdG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgPSBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0IHx8IGlzTWVyZ2VhYmxlT2JqZWN0O1xuXHQvLyBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCBpcyBhZGRlZCB0byBgb3B0aW9uc2Agc28gdGhhdCBjdXN0b20gYXJyYXlNZXJnZSgpXG5cdC8vIGltcGxlbWVudGF0aW9ucyBjYW4gdXNlIGl0LiBUaGUgY2FsbGVyIG1heSBub3QgcmVwbGFjZSBpdC5cblx0b3B0aW9ucy5jbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkO1xuXG5cdHZhciBzb3VyY2VJc0FycmF5ID0gQXJyYXkuaXNBcnJheShzb3VyY2UpO1xuXHR2YXIgdGFyZ2V0SXNBcnJheSA9IEFycmF5LmlzQXJyYXkodGFyZ2V0KTtcblx0dmFyIHNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2ggPSBzb3VyY2VJc0FycmF5ID09PSB0YXJnZXRJc0FycmF5O1xuXG5cdGlmICghc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCkge1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2UsIG9wdGlvbnMpXG5cdH0gZWxzZSBpZiAoc291cmNlSXNBcnJheSkge1xuXHRcdHJldHVybiBvcHRpb25zLmFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHR9XG59XG5cbmRlZXBtZXJnZS5hbGwgPSBmdW5jdGlvbiBkZWVwbWVyZ2VBbGwoYXJyYXksIG9wdGlvbnMpIHtcblx0aWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5Jylcblx0fVxuXG5cdHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgbmV4dCkge1xuXHRcdHJldHVybiBkZWVwbWVyZ2UocHJldiwgbmV4dCwgb3B0aW9ucylcblx0fSwge30pXG59O1xuXG52YXIgZGVlcG1lcmdlXzEgPSBkZWVwbWVyZ2U7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVlcG1lcmdlXzE7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/deepmerge/dist/cjs.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/script.js":
/*!**********************************************!*\
  !*** ./node_modules/next/dist/api/script.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport default from dynamic */ _client_script__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var _client_script__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/script */ \"(app-pages-browser)/./node_modules/next/dist/client/script.js\");\n/* harmony import */ var _client_script__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_script__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _client_script__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _client_script__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n//# sourceMappingURL=script.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL3NjcmlwdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMkM7QUFDVjs7QUFFakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9hcGkvc2NyaXB0LmpzP2QyZTkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCIuLi9jbGllbnQvc2NyaXB0XCI7XG5leHBvcnQgKiBmcm9tIFwiLi4vY2xpZW50L3NjcmlwdFwiO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY3JpcHQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/script.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLHFDQUFxQyxxQkFBTSxpRkFBaUYscUJBQU0sa0VBQWtFLHFCQUFNLFdBQVcsbUJBQU8sQ0FBQyw0R0FBNEI7O0FBRXpQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/ODAxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sZ0JBQWdCLG1CQUFtQixNQUFNLE1BQU0sNEJBQTRCLG1EQUFtRCwrQkFBK0IscURBQXFELFlBQVksSUFBSSxtQ0FBbUMsYUFBYSxLQUFLLG9CQUFvQixTQUFTLG1CQUFtQixJQUFJLHFDQUFxQyxlQUFlLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLElBQUksdUJBQXVCLG1CQUFtQix1QkFBdUIsMkNBQTJDLGFBQWEsdUJBQXVCLElBQUksY0FBYyxTQUFTLElBQUksd0JBQXdCLFNBQVMsMEJBQTBCLDRCQUE0QixxQkFBcUIsdUJBQXVCLGdEQUFnRCxlQUFlLHVCQUF1QixJQUFJLFlBQVksU0FBUyxJQUFJLHNCQUFzQixTQUFTLHdCQUF3QixTQUFTLFlBQVksTUFBTSxTQUFTLDJCQUEyQixXQUFXLE9BQU8sUUFBUSxhQUFhLGNBQWMsS0FBSyxLQUFLLGFBQWEsY0FBYyxzQkFBc0IsTUFBTSxPQUFPLGtDQUFrQyxPQUFPLGVBQWUsU0FBUyxJQUFJLEtBQUssYUFBYSxNQUFNLFlBQVksS0FBSyxXQUFXLE9BQU8sUUFBUSxtQkFBbUIsdUJBQXVCLG9DQUFvQyx1QkFBdUIsWUFBWSxtQkFBbUIsS0FBSyxxQkFBcUIsc0JBQXNCLHFCQUFxQix5QkFBeUIsbUJBQW1CLFdBQVcsYUFBYSw4QkFBOEIsaUNBQWlDLGtCQUFrQixlQUFlLFNBQVMsVUFBVSxhQUFhLGNBQWMsaUJBQWlCLFVBQVUsbUJBQW1CLFlBQVksV0FBVyxzQkFBc0IsMEJBQTBCLFlBQVksdUJBQXVCLDJCQUEyQix3QkFBd0IsVUFBVSxzQkFBc0IscURBQXFELGlCQUFpQixXQUFXLG9CQUFvQixtREFBbUQsbUJBQW1CLFlBQVksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcz8zZmNiIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tweetnacl-util/nacl-util.js":
/*!**************************************************!*\
  !*** ./node_modules/tweetnacl-util/nacl-util.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"?da34\")[\"Buffer\"];\n// Written in 2014-2016 by Dmitry Chestnykh and Devi Mandiri.\n// Public domain.\n(function(root, f) {\n  'use strict';\n  if ( true && module.exports) module.exports = f();\n  else if (root.nacl) root.nacl.util = f();\n  else {\n    root.nacl = {};\n    root.nacl.util = f();\n  }\n}(this, function() {\n  'use strict';\n\n  var util = {};\n\n  function validateBase64(s) {\n    if (!(/^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/.test(s))) {\n      throw new TypeError('invalid encoding');\n    }\n  }\n\n  util.decodeUTF8 = function(s) {\n    if (typeof s !== 'string') throw new TypeError('expected string');\n    var i, d = unescape(encodeURIComponent(s)), b = new Uint8Array(d.length);\n    for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);\n    return b;\n  };\n\n  util.encodeUTF8 = function(arr) {\n    var i, s = [];\n    for (i = 0; i < arr.length; i++) s.push(String.fromCharCode(arr[i]));\n    return decodeURIComponent(escape(s.join('')));\n  };\n\n  if (typeof atob === 'undefined') {\n    // Node.js\n\n    if (typeof Buffer.from !== 'undefined') {\n       // Node v6 and later\n      util.encodeBase64 = function (arr) { // v6 and later\n          return Buffer.from(arr).toString('base64');\n      };\n\n      util.decodeBase64 = function (s) {\n        validateBase64(s);\n        return new Uint8Array(Array.prototype.slice.call(Buffer.from(s, 'base64'), 0));\n      };\n\n    } else {\n      // Node earlier than v6\n      util.encodeBase64 = function (arr) { // v6 and later\n        return (new Buffer(arr)).toString('base64');\n      };\n\n      util.decodeBase64 = function(s) {\n        validateBase64(s);\n        return new Uint8Array(Array.prototype.slice.call(new Buffer(s, 'base64'), 0));\n      };\n    }\n\n  } else {\n    // Browsers\n\n    util.encodeBase64 = function(arr) {\n      var i, s = [], len = arr.length;\n      for (i = 0; i < len; i++) s.push(String.fromCharCode(arr[i]));\n      return btoa(s.join(''));\n    };\n\n    util.decodeBase64 = function(s) {\n      validateBase64(s);\n      var i, d = atob(s), b = new Uint8Array(d.length);\n      for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);\n      return b;\n    };\n\n  }\n\n  return util;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90d2VldG5hY2wtdXRpbC9uYWNsLXV0aWwuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUE2QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0EsOEJBQThCLEVBQUUsZUFBZSxFQUFFLG9CQUFvQixFQUFFLGtCQUFrQixFQUFFO0FBQzNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLE1BQU07QUFDckI7QUFDQSwyQ0FBMkM7QUFDM0MsaUJBQWlCLE1BQU07QUFDdkI7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RCxNQUFNO0FBQy9EOztBQUVBLE1BQU07QUFDTjtBQUNBLDJDQUEyQztBQUMzQyxvQkFBb0IsTUFBTTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZELE1BQU07QUFDbkU7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90d2VldG5hY2wtdXRpbC9uYWNsLXV0aWwuanM/NmZhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXcml0dGVuIGluIDIwMTQtMjAxNiBieSBEbWl0cnkgQ2hlc3RueWtoIGFuZCBEZXZpIE1hbmRpcmkuXG4vLyBQdWJsaWMgZG9tYWluLlxuKGZ1bmN0aW9uKHJvb3QsIGYpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIG1vZHVsZS5leHBvcnRzID0gZigpO1xuICBlbHNlIGlmIChyb290Lm5hY2wpIHJvb3QubmFjbC51dGlsID0gZigpO1xuICBlbHNlIHtcbiAgICByb290Lm5hY2wgPSB7fTtcbiAgICByb290Lm5hY2wudXRpbCA9IGYoKTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB1dGlsID0ge307XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVCYXNlNjQocykge1xuICAgIGlmICghKC9eKD86W0EtWmEtejAtOStcXC9dezJ9W0EtWmEtejAtOStcXC9dezJ9KSooPzpbQS1aYS16MC05K1xcL117Mn09PXxbQS1aYS16MC05K1xcL117M309KT8kLy50ZXN0KHMpKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBlbmNvZGluZycpO1xuICAgIH1cbiAgfVxuXG4gIHV0aWwuZGVjb2RlVVRGOCA9IGZ1bmN0aW9uKHMpIHtcbiAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBzdHJpbmcnKTtcbiAgICB2YXIgaSwgZCA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzKSksIGIgPSBuZXcgVWludDhBcnJheShkLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGQubGVuZ3RoOyBpKyspIGJbaV0gPSBkLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGI7XG4gIH07XG5cbiAgdXRpbC5lbmNvZGVVVEY4ID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgdmFyIGksIHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShhcnJbaV0pKTtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzLmpvaW4oJycpKSk7XG4gIH07XG5cbiAgaWYgKHR5cGVvZiBhdG9iID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5vZGUuanNcblxuICAgIGlmICh0eXBlb2YgQnVmZmVyLmZyb20gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgLy8gTm9kZSB2NiBhbmQgbGF0ZXJcbiAgICAgIHV0aWwuZW5jb2RlQmFzZTY0ID0gZnVuY3Rpb24gKGFycikgeyAvLyB2NiBhbmQgbGF0ZXJcbiAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJyKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICB9O1xuXG4gICAgICB1dGlsLmRlY29kZUJhc2U2NCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHZhbGlkYXRlQmFzZTY0KHMpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoQnVmZmVyLmZyb20ocywgJ2Jhc2U2NCcpLCAwKSk7XG4gICAgICB9O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vZGUgZWFybGllciB0aGFuIHY2XG4gICAgICB1dGlsLmVuY29kZUJhc2U2NCA9IGZ1bmN0aW9uIChhcnIpIHsgLy8gdjYgYW5kIGxhdGVyXG4gICAgICAgIHJldHVybiAobmV3IEJ1ZmZlcihhcnIpKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICB9O1xuXG4gICAgICB1dGlsLmRlY29kZUJhc2U2NCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFsaWRhdGVCYXNlNjQocyk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChuZXcgQnVmZmVyKHMsICdiYXNlNjQnKSwgMCkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2Vyc1xuXG4gICAgdXRpbC5lbmNvZGVCYXNlNjQgPSBmdW5jdGlvbihhcnIpIHtcbiAgICAgIHZhciBpLCBzID0gW10sIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGFycltpXSkpO1xuICAgICAgcmV0dXJuIGJ0b2Eocy5qb2luKCcnKSk7XG4gICAgfTtcblxuICAgIHV0aWwuZGVjb2RlQmFzZTY0ID0gZnVuY3Rpb24ocykge1xuICAgICAgdmFsaWRhdGVCYXNlNjQocyk7XG4gICAgICB2YXIgaSwgZCA9IGF0b2IocyksIGIgPSBuZXcgVWludDhBcnJheShkLmxlbmd0aCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZC5sZW5ndGg7IGkrKykgYltpXSA9IGQuY2hhckNvZGVBdChpKTtcbiAgICAgIHJldHVybiBiO1xuICAgIH07XG5cbiAgfVxuXG4gIHJldHVybiB1dGlsO1xuXG59KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tweetnacl-util/nacl-util.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tweetnacl/nacl-fast.js":
/*!*********************************************!*\
  !*** ./node_modules/tweetnacl/nacl-fast.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("(function(nacl) {\n'use strict';\n\n// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.\n// Public domain.\n//\n// Implementation derived from TweetNaCl version 20140427.\n// See for details: http://tweetnacl.cr.yp.to/\n\nvar gf = function(init) {\n  var i, r = new Float64Array(16);\n  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];\n  return r;\n};\n\n//  Pluggable, initialized in high-level API below.\nvar randombytes = function(/* x, n */) { throw new Error('no PRNG'); };\n\nvar _0 = new Uint8Array(16);\nvar _9 = new Uint8Array(32); _9[0] = 9;\n\nvar gf0 = gf(),\n    gf1 = gf([1]),\n    _121665 = gf([0xdb41, 1]),\n    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),\n    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),\n    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),\n    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),\n    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);\n\nfunction ts64(x, i, h, l) {\n  x[i]   = (h >> 24) & 0xff;\n  x[i+1] = (h >> 16) & 0xff;\n  x[i+2] = (h >>  8) & 0xff;\n  x[i+3] = h & 0xff;\n  x[i+4] = (l >> 24)  & 0xff;\n  x[i+5] = (l >> 16)  & 0xff;\n  x[i+6] = (l >>  8)  & 0xff;\n  x[i+7] = l & 0xff;\n}\n\nfunction vn(x, xi, y, yi, n) {\n  var i,d = 0;\n  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];\n  return (1 & ((d - 1) >>> 8)) - 1;\n}\n\nfunction crypto_verify_16(x, xi, y, yi) {\n  return vn(x,xi,y,yi,16);\n}\n\nfunction crypto_verify_32(x, xi, y, yi) {\n  return vn(x,xi,y,yi,32);\n}\n\nfunction core_salsa20(o, p, k, c) {\n  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,\n      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,\n      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,\n      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,\n      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,\n      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,\n      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,\n      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,\n      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,\n      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,\n      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,\n      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,\n      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,\n      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,\n      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,\n      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;\n\n  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,\n      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,\n      x15 = j15, u;\n\n  for (var i = 0; i < 20; i += 2) {\n    u = x0 + x12 | 0;\n    x4 ^= u<<7 | u>>>(32-7);\n    u = x4 + x0 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x4 | 0;\n    x12 ^= u<<13 | u>>>(32-13);\n    u = x12 + x8 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x1 | 0;\n    x9 ^= u<<7 | u>>>(32-7);\n    u = x9 + x5 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x9 | 0;\n    x1 ^= u<<13 | u>>>(32-13);\n    u = x1 + x13 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x6 | 0;\n    x14 ^= u<<7 | u>>>(32-7);\n    u = x14 + x10 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x14 | 0;\n    x6 ^= u<<13 | u>>>(32-13);\n    u = x6 + x2 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x11 | 0;\n    x3 ^= u<<7 | u>>>(32-7);\n    u = x3 + x15 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x3 | 0;\n    x11 ^= u<<13 | u>>>(32-13);\n    u = x11 + x7 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n\n    u = x0 + x3 | 0;\n    x1 ^= u<<7 | u>>>(32-7);\n    u = x1 + x0 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x1 | 0;\n    x3 ^= u<<13 | u>>>(32-13);\n    u = x3 + x2 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x4 | 0;\n    x6 ^= u<<7 | u>>>(32-7);\n    u = x6 + x5 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x6 | 0;\n    x4 ^= u<<13 | u>>>(32-13);\n    u = x4 + x7 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x9 | 0;\n    x11 ^= u<<7 | u>>>(32-7);\n    u = x11 + x10 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x11 | 0;\n    x9 ^= u<<13 | u>>>(32-13);\n    u = x9 + x8 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x14 | 0;\n    x12 ^= u<<7 | u>>>(32-7);\n    u = x12 + x15 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x12 | 0;\n    x14 ^= u<<13 | u>>>(32-13);\n    u = x14 + x13 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n  }\n   x0 =  x0 +  j0 | 0;\n   x1 =  x1 +  j1 | 0;\n   x2 =  x2 +  j2 | 0;\n   x3 =  x3 +  j3 | 0;\n   x4 =  x4 +  j4 | 0;\n   x5 =  x5 +  j5 | 0;\n   x6 =  x6 +  j6 | 0;\n   x7 =  x7 +  j7 | 0;\n   x8 =  x8 +  j8 | 0;\n   x9 =  x9 +  j9 | 0;\n  x10 = x10 + j10 | 0;\n  x11 = x11 + j11 | 0;\n  x12 = x12 + j12 | 0;\n  x13 = x13 + j13 | 0;\n  x14 = x14 + j14 | 0;\n  x15 = x15 + j15 | 0;\n\n  o[ 0] = x0 >>>  0 & 0xff;\n  o[ 1] = x0 >>>  8 & 0xff;\n  o[ 2] = x0 >>> 16 & 0xff;\n  o[ 3] = x0 >>> 24 & 0xff;\n\n  o[ 4] = x1 >>>  0 & 0xff;\n  o[ 5] = x1 >>>  8 & 0xff;\n  o[ 6] = x1 >>> 16 & 0xff;\n  o[ 7] = x1 >>> 24 & 0xff;\n\n  o[ 8] = x2 >>>  0 & 0xff;\n  o[ 9] = x2 >>>  8 & 0xff;\n  o[10] = x2 >>> 16 & 0xff;\n  o[11] = x2 >>> 24 & 0xff;\n\n  o[12] = x3 >>>  0 & 0xff;\n  o[13] = x3 >>>  8 & 0xff;\n  o[14] = x3 >>> 16 & 0xff;\n  o[15] = x3 >>> 24 & 0xff;\n\n  o[16] = x4 >>>  0 & 0xff;\n  o[17] = x4 >>>  8 & 0xff;\n  o[18] = x4 >>> 16 & 0xff;\n  o[19] = x4 >>> 24 & 0xff;\n\n  o[20] = x5 >>>  0 & 0xff;\n  o[21] = x5 >>>  8 & 0xff;\n  o[22] = x5 >>> 16 & 0xff;\n  o[23] = x5 >>> 24 & 0xff;\n\n  o[24] = x6 >>>  0 & 0xff;\n  o[25] = x6 >>>  8 & 0xff;\n  o[26] = x6 >>> 16 & 0xff;\n  o[27] = x6 >>> 24 & 0xff;\n\n  o[28] = x7 >>>  0 & 0xff;\n  o[29] = x7 >>>  8 & 0xff;\n  o[30] = x7 >>> 16 & 0xff;\n  o[31] = x7 >>> 24 & 0xff;\n\n  o[32] = x8 >>>  0 & 0xff;\n  o[33] = x8 >>>  8 & 0xff;\n  o[34] = x8 >>> 16 & 0xff;\n  o[35] = x8 >>> 24 & 0xff;\n\n  o[36] = x9 >>>  0 & 0xff;\n  o[37] = x9 >>>  8 & 0xff;\n  o[38] = x9 >>> 16 & 0xff;\n  o[39] = x9 >>> 24 & 0xff;\n\n  o[40] = x10 >>>  0 & 0xff;\n  o[41] = x10 >>>  8 & 0xff;\n  o[42] = x10 >>> 16 & 0xff;\n  o[43] = x10 >>> 24 & 0xff;\n\n  o[44] = x11 >>>  0 & 0xff;\n  o[45] = x11 >>>  8 & 0xff;\n  o[46] = x11 >>> 16 & 0xff;\n  o[47] = x11 >>> 24 & 0xff;\n\n  o[48] = x12 >>>  0 & 0xff;\n  o[49] = x12 >>>  8 & 0xff;\n  o[50] = x12 >>> 16 & 0xff;\n  o[51] = x12 >>> 24 & 0xff;\n\n  o[52] = x13 >>>  0 & 0xff;\n  o[53] = x13 >>>  8 & 0xff;\n  o[54] = x13 >>> 16 & 0xff;\n  o[55] = x13 >>> 24 & 0xff;\n\n  o[56] = x14 >>>  0 & 0xff;\n  o[57] = x14 >>>  8 & 0xff;\n  o[58] = x14 >>> 16 & 0xff;\n  o[59] = x14 >>> 24 & 0xff;\n\n  o[60] = x15 >>>  0 & 0xff;\n  o[61] = x15 >>>  8 & 0xff;\n  o[62] = x15 >>> 16 & 0xff;\n  o[63] = x15 >>> 24 & 0xff;\n}\n\nfunction core_hsalsa20(o,p,k,c) {\n  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,\n      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,\n      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,\n      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,\n      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,\n      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,\n      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,\n      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,\n      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,\n      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,\n      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,\n      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,\n      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,\n      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,\n      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,\n      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;\n\n  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,\n      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,\n      x15 = j15, u;\n\n  for (var i = 0; i < 20; i += 2) {\n    u = x0 + x12 | 0;\n    x4 ^= u<<7 | u>>>(32-7);\n    u = x4 + x0 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x4 | 0;\n    x12 ^= u<<13 | u>>>(32-13);\n    u = x12 + x8 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x1 | 0;\n    x9 ^= u<<7 | u>>>(32-7);\n    u = x9 + x5 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x9 | 0;\n    x1 ^= u<<13 | u>>>(32-13);\n    u = x1 + x13 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x6 | 0;\n    x14 ^= u<<7 | u>>>(32-7);\n    u = x14 + x10 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x14 | 0;\n    x6 ^= u<<13 | u>>>(32-13);\n    u = x6 + x2 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x11 | 0;\n    x3 ^= u<<7 | u>>>(32-7);\n    u = x3 + x15 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x3 | 0;\n    x11 ^= u<<13 | u>>>(32-13);\n    u = x11 + x7 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n\n    u = x0 + x3 | 0;\n    x1 ^= u<<7 | u>>>(32-7);\n    u = x1 + x0 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x1 | 0;\n    x3 ^= u<<13 | u>>>(32-13);\n    u = x3 + x2 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x4 | 0;\n    x6 ^= u<<7 | u>>>(32-7);\n    u = x6 + x5 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x6 | 0;\n    x4 ^= u<<13 | u>>>(32-13);\n    u = x4 + x7 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x9 | 0;\n    x11 ^= u<<7 | u>>>(32-7);\n    u = x11 + x10 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x11 | 0;\n    x9 ^= u<<13 | u>>>(32-13);\n    u = x9 + x8 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x14 | 0;\n    x12 ^= u<<7 | u>>>(32-7);\n    u = x12 + x15 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x12 | 0;\n    x14 ^= u<<13 | u>>>(32-13);\n    u = x14 + x13 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n  }\n\n  o[ 0] = x0 >>>  0 & 0xff;\n  o[ 1] = x0 >>>  8 & 0xff;\n  o[ 2] = x0 >>> 16 & 0xff;\n  o[ 3] = x0 >>> 24 & 0xff;\n\n  o[ 4] = x5 >>>  0 & 0xff;\n  o[ 5] = x5 >>>  8 & 0xff;\n  o[ 6] = x5 >>> 16 & 0xff;\n  o[ 7] = x5 >>> 24 & 0xff;\n\n  o[ 8] = x10 >>>  0 & 0xff;\n  o[ 9] = x10 >>>  8 & 0xff;\n  o[10] = x10 >>> 16 & 0xff;\n  o[11] = x10 >>> 24 & 0xff;\n\n  o[12] = x15 >>>  0 & 0xff;\n  o[13] = x15 >>>  8 & 0xff;\n  o[14] = x15 >>> 16 & 0xff;\n  o[15] = x15 >>> 24 & 0xff;\n\n  o[16] = x6 >>>  0 & 0xff;\n  o[17] = x6 >>>  8 & 0xff;\n  o[18] = x6 >>> 16 & 0xff;\n  o[19] = x6 >>> 24 & 0xff;\n\n  o[20] = x7 >>>  0 & 0xff;\n  o[21] = x7 >>>  8 & 0xff;\n  o[22] = x7 >>> 16 & 0xff;\n  o[23] = x7 >>> 24 & 0xff;\n\n  o[24] = x8 >>>  0 & 0xff;\n  o[25] = x8 >>>  8 & 0xff;\n  o[26] = x8 >>> 16 & 0xff;\n  o[27] = x8 >>> 24 & 0xff;\n\n  o[28] = x9 >>>  0 & 0xff;\n  o[29] = x9 >>>  8 & 0xff;\n  o[30] = x9 >>> 16 & 0xff;\n  o[31] = x9 >>> 24 & 0xff;\n}\n\nfunction crypto_core_salsa20(out,inp,k,c) {\n  core_salsa20(out,inp,k,c);\n}\n\nfunction crypto_core_hsalsa20(out,inp,k,c) {\n  core_hsalsa20(out,inp,k,c);\n}\n\nvar sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);\n            // \"expand 32-byte k\"\n\nfunction crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {\n  var z = new Uint8Array(16), x = new Uint8Array(64);\n  var u, i;\n  for (i = 0; i < 16; i++) z[i] = 0;\n  for (i = 0; i < 8; i++) z[i] = n[i];\n  while (b >= 64) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];\n    u = 1;\n    for (i = 8; i < 16; i++) {\n      u = u + (z[i] & 0xff) | 0;\n      z[i] = u & 0xff;\n      u >>>= 8;\n    }\n    b -= 64;\n    cpos += 64;\n    mpos += 64;\n  }\n  if (b > 0) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];\n  }\n  return 0;\n}\n\nfunction crypto_stream_salsa20(c,cpos,b,n,k) {\n  var z = new Uint8Array(16), x = new Uint8Array(64);\n  var u, i;\n  for (i = 0; i < 16; i++) z[i] = 0;\n  for (i = 0; i < 8; i++) z[i] = n[i];\n  while (b >= 64) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < 64; i++) c[cpos+i] = x[i];\n    u = 1;\n    for (i = 8; i < 16; i++) {\n      u = u + (z[i] & 0xff) | 0;\n      z[i] = u & 0xff;\n      u >>>= 8;\n    }\n    b -= 64;\n    cpos += 64;\n  }\n  if (b > 0) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < b; i++) c[cpos+i] = x[i];\n  }\n  return 0;\n}\n\nfunction crypto_stream(c,cpos,d,n,k) {\n  var s = new Uint8Array(32);\n  crypto_core_hsalsa20(s,n,k,sigma);\n  var sn = new Uint8Array(8);\n  for (var i = 0; i < 8; i++) sn[i] = n[i+16];\n  return crypto_stream_salsa20(c,cpos,d,sn,s);\n}\n\nfunction crypto_stream_xor(c,cpos,m,mpos,d,n,k) {\n  var s = new Uint8Array(32);\n  crypto_core_hsalsa20(s,n,k,sigma);\n  var sn = new Uint8Array(8);\n  for (var i = 0; i < 8; i++) sn[i] = n[i+16];\n  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);\n}\n\n/*\n* Port of Andrew Moon's Poly1305-donna-16. Public domain.\n* https://github.com/floodyberry/poly1305-donna\n*/\n\nvar poly1305 = function(key) {\n  this.buffer = new Uint8Array(16);\n  this.r = new Uint16Array(10);\n  this.h = new Uint16Array(10);\n  this.pad = new Uint16Array(8);\n  this.leftover = 0;\n  this.fin = 0;\n\n  var t0, t1, t2, t3, t4, t5, t6, t7;\n\n  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;\n  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;\n  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;\n  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;\n  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;\n  this.r[5] = ((t4 >>>  1)) & 0x1ffe;\n  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;\n  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;\n  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;\n  this.r[9] = ((t7 >>>  5)) & 0x007f;\n\n  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;\n  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;\n  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;\n  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;\n  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;\n  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;\n  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;\n  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;\n};\n\npoly1305.prototype.blocks = function(m, mpos, bytes) {\n  var hibit = this.fin ? 0 : (1 << 11);\n  var t0, t1, t2, t3, t4, t5, t6, t7, c;\n  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;\n\n  var h0 = this.h[0],\n      h1 = this.h[1],\n      h2 = this.h[2],\n      h3 = this.h[3],\n      h4 = this.h[4],\n      h5 = this.h[5],\n      h6 = this.h[6],\n      h7 = this.h[7],\n      h8 = this.h[8],\n      h9 = this.h[9];\n\n  var r0 = this.r[0],\n      r1 = this.r[1],\n      r2 = this.r[2],\n      r3 = this.r[3],\n      r4 = this.r[4],\n      r5 = this.r[5],\n      r6 = this.r[6],\n      r7 = this.r[7],\n      r8 = this.r[8],\n      r9 = this.r[9];\n\n  while (bytes >= 16) {\n    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;\n    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;\n    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;\n    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;\n    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;\n    h5 += ((t4 >>>  1)) & 0x1fff;\n    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;\n    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;\n    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;\n    h9 += ((t7 >>> 5)) | hibit;\n\n    c = 0;\n\n    d0 = c;\n    d0 += h0 * r0;\n    d0 += h1 * (5 * r9);\n    d0 += h2 * (5 * r8);\n    d0 += h3 * (5 * r7);\n    d0 += h4 * (5 * r6);\n    c = (d0 >>> 13); d0 &= 0x1fff;\n    d0 += h5 * (5 * r5);\n    d0 += h6 * (5 * r4);\n    d0 += h7 * (5 * r3);\n    d0 += h8 * (5 * r2);\n    d0 += h9 * (5 * r1);\n    c += (d0 >>> 13); d0 &= 0x1fff;\n\n    d1 = c;\n    d1 += h0 * r1;\n    d1 += h1 * r0;\n    d1 += h2 * (5 * r9);\n    d1 += h3 * (5 * r8);\n    d1 += h4 * (5 * r7);\n    c = (d1 >>> 13); d1 &= 0x1fff;\n    d1 += h5 * (5 * r6);\n    d1 += h6 * (5 * r5);\n    d1 += h7 * (5 * r4);\n    d1 += h8 * (5 * r3);\n    d1 += h9 * (5 * r2);\n    c += (d1 >>> 13); d1 &= 0x1fff;\n\n    d2 = c;\n    d2 += h0 * r2;\n    d2 += h1 * r1;\n    d2 += h2 * r0;\n    d2 += h3 * (5 * r9);\n    d2 += h4 * (5 * r8);\n    c = (d2 >>> 13); d2 &= 0x1fff;\n    d2 += h5 * (5 * r7);\n    d2 += h6 * (5 * r6);\n    d2 += h7 * (5 * r5);\n    d2 += h8 * (5 * r4);\n    d2 += h9 * (5 * r3);\n    c += (d2 >>> 13); d2 &= 0x1fff;\n\n    d3 = c;\n    d3 += h0 * r3;\n    d3 += h1 * r2;\n    d3 += h2 * r1;\n    d3 += h3 * r0;\n    d3 += h4 * (5 * r9);\n    c = (d3 >>> 13); d3 &= 0x1fff;\n    d3 += h5 * (5 * r8);\n    d3 += h6 * (5 * r7);\n    d3 += h7 * (5 * r6);\n    d3 += h8 * (5 * r5);\n    d3 += h9 * (5 * r4);\n    c += (d3 >>> 13); d3 &= 0x1fff;\n\n    d4 = c;\n    d4 += h0 * r4;\n    d4 += h1 * r3;\n    d4 += h2 * r2;\n    d4 += h3 * r1;\n    d4 += h4 * r0;\n    c = (d4 >>> 13); d4 &= 0x1fff;\n    d4 += h5 * (5 * r9);\n    d4 += h6 * (5 * r8);\n    d4 += h7 * (5 * r7);\n    d4 += h8 * (5 * r6);\n    d4 += h9 * (5 * r5);\n    c += (d4 >>> 13); d4 &= 0x1fff;\n\n    d5 = c;\n    d5 += h0 * r5;\n    d5 += h1 * r4;\n    d5 += h2 * r3;\n    d5 += h3 * r2;\n    d5 += h4 * r1;\n    c = (d5 >>> 13); d5 &= 0x1fff;\n    d5 += h5 * r0;\n    d5 += h6 * (5 * r9);\n    d5 += h7 * (5 * r8);\n    d5 += h8 * (5 * r7);\n    d5 += h9 * (5 * r6);\n    c += (d5 >>> 13); d5 &= 0x1fff;\n\n    d6 = c;\n    d6 += h0 * r6;\n    d6 += h1 * r5;\n    d6 += h2 * r4;\n    d6 += h3 * r3;\n    d6 += h4 * r2;\n    c = (d6 >>> 13); d6 &= 0x1fff;\n    d6 += h5 * r1;\n    d6 += h6 * r0;\n    d6 += h7 * (5 * r9);\n    d6 += h8 * (5 * r8);\n    d6 += h9 * (5 * r7);\n    c += (d6 >>> 13); d6 &= 0x1fff;\n\n    d7 = c;\n    d7 += h0 * r7;\n    d7 += h1 * r6;\n    d7 += h2 * r5;\n    d7 += h3 * r4;\n    d7 += h4 * r3;\n    c = (d7 >>> 13); d7 &= 0x1fff;\n    d7 += h5 * r2;\n    d7 += h6 * r1;\n    d7 += h7 * r0;\n    d7 += h8 * (5 * r9);\n    d7 += h9 * (5 * r8);\n    c += (d7 >>> 13); d7 &= 0x1fff;\n\n    d8 = c;\n    d8 += h0 * r8;\n    d8 += h1 * r7;\n    d8 += h2 * r6;\n    d8 += h3 * r5;\n    d8 += h4 * r4;\n    c = (d8 >>> 13); d8 &= 0x1fff;\n    d8 += h5 * r3;\n    d8 += h6 * r2;\n    d8 += h7 * r1;\n    d8 += h8 * r0;\n    d8 += h9 * (5 * r9);\n    c += (d8 >>> 13); d8 &= 0x1fff;\n\n    d9 = c;\n    d9 += h0 * r9;\n    d9 += h1 * r8;\n    d9 += h2 * r7;\n    d9 += h3 * r6;\n    d9 += h4 * r5;\n    c = (d9 >>> 13); d9 &= 0x1fff;\n    d9 += h5 * r4;\n    d9 += h6 * r3;\n    d9 += h7 * r2;\n    d9 += h8 * r1;\n    d9 += h9 * r0;\n    c += (d9 >>> 13); d9 &= 0x1fff;\n\n    c = (((c << 2) + c)) | 0;\n    c = (c + d0) | 0;\n    d0 = c & 0x1fff;\n    c = (c >>> 13);\n    d1 += c;\n\n    h0 = d0;\n    h1 = d1;\n    h2 = d2;\n    h3 = d3;\n    h4 = d4;\n    h5 = d5;\n    h6 = d6;\n    h7 = d7;\n    h8 = d8;\n    h9 = d9;\n\n    mpos += 16;\n    bytes -= 16;\n  }\n  this.h[0] = h0;\n  this.h[1] = h1;\n  this.h[2] = h2;\n  this.h[3] = h3;\n  this.h[4] = h4;\n  this.h[5] = h5;\n  this.h[6] = h6;\n  this.h[7] = h7;\n  this.h[8] = h8;\n  this.h[9] = h9;\n};\n\npoly1305.prototype.finish = function(mac, macpos) {\n  var g = new Uint16Array(10);\n  var c, mask, f, i;\n\n  if (this.leftover) {\n    i = this.leftover;\n    this.buffer[i++] = 1;\n    for (; i < 16; i++) this.buffer[i] = 0;\n    this.fin = 1;\n    this.blocks(this.buffer, 0, 16);\n  }\n\n  c = this.h[1] >>> 13;\n  this.h[1] &= 0x1fff;\n  for (i = 2; i < 10; i++) {\n    this.h[i] += c;\n    c = this.h[i] >>> 13;\n    this.h[i] &= 0x1fff;\n  }\n  this.h[0] += (c * 5);\n  c = this.h[0] >>> 13;\n  this.h[0] &= 0x1fff;\n  this.h[1] += c;\n  c = this.h[1] >>> 13;\n  this.h[1] &= 0x1fff;\n  this.h[2] += c;\n\n  g[0] = this.h[0] + 5;\n  c = g[0] >>> 13;\n  g[0] &= 0x1fff;\n  for (i = 1; i < 10; i++) {\n    g[i] = this.h[i] + c;\n    c = g[i] >>> 13;\n    g[i] &= 0x1fff;\n  }\n  g[9] -= (1 << 13);\n\n  mask = (c ^ 1) - 1;\n  for (i = 0; i < 10; i++) g[i] &= mask;\n  mask = ~mask;\n  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];\n\n  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;\n  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;\n  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;\n  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;\n  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;\n  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;\n  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;\n  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;\n\n  f = this.h[0] + this.pad[0];\n  this.h[0] = f & 0xffff;\n  for (i = 1; i < 8; i++) {\n    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;\n    this.h[i] = f & 0xffff;\n  }\n\n  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;\n  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;\n  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;\n  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;\n  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;\n  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;\n  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;\n  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;\n  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;\n  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;\n  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;\n  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;\n  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;\n  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;\n  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;\n  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;\n};\n\npoly1305.prototype.update = function(m, mpos, bytes) {\n  var i, want;\n\n  if (this.leftover) {\n    want = (16 - this.leftover);\n    if (want > bytes)\n      want = bytes;\n    for (i = 0; i < want; i++)\n      this.buffer[this.leftover + i] = m[mpos+i];\n    bytes -= want;\n    mpos += want;\n    this.leftover += want;\n    if (this.leftover < 16)\n      return;\n    this.blocks(this.buffer, 0, 16);\n    this.leftover = 0;\n  }\n\n  if (bytes >= 16) {\n    want = bytes - (bytes % 16);\n    this.blocks(m, mpos, want);\n    mpos += want;\n    bytes -= want;\n  }\n\n  if (bytes) {\n    for (i = 0; i < bytes; i++)\n      this.buffer[this.leftover + i] = m[mpos+i];\n    this.leftover += bytes;\n  }\n};\n\nfunction crypto_onetimeauth(out, outpos, m, mpos, n, k) {\n  var s = new poly1305(k);\n  s.update(m, mpos, n);\n  s.finish(out, outpos);\n  return 0;\n}\n\nfunction crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {\n  var x = new Uint8Array(16);\n  crypto_onetimeauth(x,0,m,mpos,n,k);\n  return crypto_verify_16(h,hpos,x,0);\n}\n\nfunction crypto_secretbox(c,m,d,n,k) {\n  var i;\n  if (d < 32) return -1;\n  crypto_stream_xor(c,0,m,0,d,n,k);\n  crypto_onetimeauth(c, 16, c, 32, d - 32, c);\n  for (i = 0; i < 16; i++) c[i] = 0;\n  return 0;\n}\n\nfunction crypto_secretbox_open(m,c,d,n,k) {\n  var i;\n  var x = new Uint8Array(32);\n  if (d < 32) return -1;\n  crypto_stream(x,0,32,n,k);\n  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;\n  crypto_stream_xor(m,0,c,0,d,n,k);\n  for (i = 0; i < 32; i++) m[i] = 0;\n  return 0;\n}\n\nfunction set25519(r, a) {\n  var i;\n  for (i = 0; i < 16; i++) r[i] = a[i]|0;\n}\n\nfunction car25519(o) {\n  var i, v, c = 1;\n  for (i = 0; i < 16; i++) {\n    v = o[i] + c + 65535;\n    c = Math.floor(v / 65536);\n    o[i] = v - c * 65536;\n  }\n  o[0] += c-1 + 37 * (c-1);\n}\n\nfunction sel25519(p, q, b) {\n  var t, c = ~(b-1);\n  for (var i = 0; i < 16; i++) {\n    t = c & (p[i] ^ q[i]);\n    p[i] ^= t;\n    q[i] ^= t;\n  }\n}\n\nfunction pack25519(o, n) {\n  var i, j, b;\n  var m = gf(), t = gf();\n  for (i = 0; i < 16; i++) t[i] = n[i];\n  car25519(t);\n  car25519(t);\n  car25519(t);\n  for (j = 0; j < 2; j++) {\n    m[0] = t[0] - 0xffed;\n    for (i = 1; i < 15; i++) {\n      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);\n      m[i-1] &= 0xffff;\n    }\n    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);\n    b = (m[15]>>16) & 1;\n    m[14] &= 0xffff;\n    sel25519(t, m, 1-b);\n  }\n  for (i = 0; i < 16; i++) {\n    o[2*i] = t[i] & 0xff;\n    o[2*i+1] = t[i]>>8;\n  }\n}\n\nfunction neq25519(a, b) {\n  var c = new Uint8Array(32), d = new Uint8Array(32);\n  pack25519(c, a);\n  pack25519(d, b);\n  return crypto_verify_32(c, 0, d, 0);\n}\n\nfunction par25519(a) {\n  var d = new Uint8Array(32);\n  pack25519(d, a);\n  return d[0] & 1;\n}\n\nfunction unpack25519(o, n) {\n  var i;\n  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);\n  o[15] &= 0x7fff;\n}\n\nfunction A(o, a, b) {\n  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];\n}\n\nfunction Z(o, a, b) {\n  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];\n}\n\nfunction M(o, a, b) {\n  var v, c,\n     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,\n     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,\n    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,\n    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,\n    b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3],\n    b4 = b[4],\n    b5 = b[5],\n    b6 = b[6],\n    b7 = b[7],\n    b8 = b[8],\n    b9 = b[9],\n    b10 = b[10],\n    b11 = b[11],\n    b12 = b[12],\n    b13 = b[13],\n    b14 = b[14],\n    b15 = b[15];\n\n  v = a[0];\n  t0 += v * b0;\n  t1 += v * b1;\n  t2 += v * b2;\n  t3 += v * b3;\n  t4 += v * b4;\n  t5 += v * b5;\n  t6 += v * b6;\n  t7 += v * b7;\n  t8 += v * b8;\n  t9 += v * b9;\n  t10 += v * b10;\n  t11 += v * b11;\n  t12 += v * b12;\n  t13 += v * b13;\n  t14 += v * b14;\n  t15 += v * b15;\n  v = a[1];\n  t1 += v * b0;\n  t2 += v * b1;\n  t3 += v * b2;\n  t4 += v * b3;\n  t5 += v * b4;\n  t6 += v * b5;\n  t7 += v * b6;\n  t8 += v * b7;\n  t9 += v * b8;\n  t10 += v * b9;\n  t11 += v * b10;\n  t12 += v * b11;\n  t13 += v * b12;\n  t14 += v * b13;\n  t15 += v * b14;\n  t16 += v * b15;\n  v = a[2];\n  t2 += v * b0;\n  t3 += v * b1;\n  t4 += v * b2;\n  t5 += v * b3;\n  t6 += v * b4;\n  t7 += v * b5;\n  t8 += v * b6;\n  t9 += v * b7;\n  t10 += v * b8;\n  t11 += v * b9;\n  t12 += v * b10;\n  t13 += v * b11;\n  t14 += v * b12;\n  t15 += v * b13;\n  t16 += v * b14;\n  t17 += v * b15;\n  v = a[3];\n  t3 += v * b0;\n  t4 += v * b1;\n  t5 += v * b2;\n  t6 += v * b3;\n  t7 += v * b4;\n  t8 += v * b5;\n  t9 += v * b6;\n  t10 += v * b7;\n  t11 += v * b8;\n  t12 += v * b9;\n  t13 += v * b10;\n  t14 += v * b11;\n  t15 += v * b12;\n  t16 += v * b13;\n  t17 += v * b14;\n  t18 += v * b15;\n  v = a[4];\n  t4 += v * b0;\n  t5 += v * b1;\n  t6 += v * b2;\n  t7 += v * b3;\n  t8 += v * b4;\n  t9 += v * b5;\n  t10 += v * b6;\n  t11 += v * b7;\n  t12 += v * b8;\n  t13 += v * b9;\n  t14 += v * b10;\n  t15 += v * b11;\n  t16 += v * b12;\n  t17 += v * b13;\n  t18 += v * b14;\n  t19 += v * b15;\n  v = a[5];\n  t5 += v * b0;\n  t6 += v * b1;\n  t7 += v * b2;\n  t8 += v * b3;\n  t9 += v * b4;\n  t10 += v * b5;\n  t11 += v * b6;\n  t12 += v * b7;\n  t13 += v * b8;\n  t14 += v * b9;\n  t15 += v * b10;\n  t16 += v * b11;\n  t17 += v * b12;\n  t18 += v * b13;\n  t19 += v * b14;\n  t20 += v * b15;\n  v = a[6];\n  t6 += v * b0;\n  t7 += v * b1;\n  t8 += v * b2;\n  t9 += v * b3;\n  t10 += v * b4;\n  t11 += v * b5;\n  t12 += v * b6;\n  t13 += v * b7;\n  t14 += v * b8;\n  t15 += v * b9;\n  t16 += v * b10;\n  t17 += v * b11;\n  t18 += v * b12;\n  t19 += v * b13;\n  t20 += v * b14;\n  t21 += v * b15;\n  v = a[7];\n  t7 += v * b0;\n  t8 += v * b1;\n  t9 += v * b2;\n  t10 += v * b3;\n  t11 += v * b4;\n  t12 += v * b5;\n  t13 += v * b6;\n  t14 += v * b7;\n  t15 += v * b8;\n  t16 += v * b9;\n  t17 += v * b10;\n  t18 += v * b11;\n  t19 += v * b12;\n  t20 += v * b13;\n  t21 += v * b14;\n  t22 += v * b15;\n  v = a[8];\n  t8 += v * b0;\n  t9 += v * b1;\n  t10 += v * b2;\n  t11 += v * b3;\n  t12 += v * b4;\n  t13 += v * b5;\n  t14 += v * b6;\n  t15 += v * b7;\n  t16 += v * b8;\n  t17 += v * b9;\n  t18 += v * b10;\n  t19 += v * b11;\n  t20 += v * b12;\n  t21 += v * b13;\n  t22 += v * b14;\n  t23 += v * b15;\n  v = a[9];\n  t9 += v * b0;\n  t10 += v * b1;\n  t11 += v * b2;\n  t12 += v * b3;\n  t13 += v * b4;\n  t14 += v * b5;\n  t15 += v * b6;\n  t16 += v * b7;\n  t17 += v * b8;\n  t18 += v * b9;\n  t19 += v * b10;\n  t20 += v * b11;\n  t21 += v * b12;\n  t22 += v * b13;\n  t23 += v * b14;\n  t24 += v * b15;\n  v = a[10];\n  t10 += v * b0;\n  t11 += v * b1;\n  t12 += v * b2;\n  t13 += v * b3;\n  t14 += v * b4;\n  t15 += v * b5;\n  t16 += v * b6;\n  t17 += v * b7;\n  t18 += v * b8;\n  t19 += v * b9;\n  t20 += v * b10;\n  t21 += v * b11;\n  t22 += v * b12;\n  t23 += v * b13;\n  t24 += v * b14;\n  t25 += v * b15;\n  v = a[11];\n  t11 += v * b0;\n  t12 += v * b1;\n  t13 += v * b2;\n  t14 += v * b3;\n  t15 += v * b4;\n  t16 += v * b5;\n  t17 += v * b6;\n  t18 += v * b7;\n  t19 += v * b8;\n  t20 += v * b9;\n  t21 += v * b10;\n  t22 += v * b11;\n  t23 += v * b12;\n  t24 += v * b13;\n  t25 += v * b14;\n  t26 += v * b15;\n  v = a[12];\n  t12 += v * b0;\n  t13 += v * b1;\n  t14 += v * b2;\n  t15 += v * b3;\n  t16 += v * b4;\n  t17 += v * b5;\n  t18 += v * b6;\n  t19 += v * b7;\n  t20 += v * b8;\n  t21 += v * b9;\n  t22 += v * b10;\n  t23 += v * b11;\n  t24 += v * b12;\n  t25 += v * b13;\n  t26 += v * b14;\n  t27 += v * b15;\n  v = a[13];\n  t13 += v * b0;\n  t14 += v * b1;\n  t15 += v * b2;\n  t16 += v * b3;\n  t17 += v * b4;\n  t18 += v * b5;\n  t19 += v * b6;\n  t20 += v * b7;\n  t21 += v * b8;\n  t22 += v * b9;\n  t23 += v * b10;\n  t24 += v * b11;\n  t25 += v * b12;\n  t26 += v * b13;\n  t27 += v * b14;\n  t28 += v * b15;\n  v = a[14];\n  t14 += v * b0;\n  t15 += v * b1;\n  t16 += v * b2;\n  t17 += v * b3;\n  t18 += v * b4;\n  t19 += v * b5;\n  t20 += v * b6;\n  t21 += v * b7;\n  t22 += v * b8;\n  t23 += v * b9;\n  t24 += v * b10;\n  t25 += v * b11;\n  t26 += v * b12;\n  t27 += v * b13;\n  t28 += v * b14;\n  t29 += v * b15;\n  v = a[15];\n  t15 += v * b0;\n  t16 += v * b1;\n  t17 += v * b2;\n  t18 += v * b3;\n  t19 += v * b4;\n  t20 += v * b5;\n  t21 += v * b6;\n  t22 += v * b7;\n  t23 += v * b8;\n  t24 += v * b9;\n  t25 += v * b10;\n  t26 += v * b11;\n  t27 += v * b12;\n  t28 += v * b13;\n  t29 += v * b14;\n  t30 += v * b15;\n\n  t0  += 38 * t16;\n  t1  += 38 * t17;\n  t2  += 38 * t18;\n  t3  += 38 * t19;\n  t4  += 38 * t20;\n  t5  += 38 * t21;\n  t6  += 38 * t22;\n  t7  += 38 * t23;\n  t8  += 38 * t24;\n  t9  += 38 * t25;\n  t10 += 38 * t26;\n  t11 += 38 * t27;\n  t12 += 38 * t28;\n  t13 += 38 * t29;\n  t14 += 38 * t30;\n  // t15 left as is\n\n  // first car\n  c = 1;\n  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;\n  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;\n  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;\n  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;\n  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;\n  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;\n  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;\n  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;\n  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;\n  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;\n  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;\n  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;\n  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;\n  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;\n  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;\n  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;\n  t0 += c-1 + 37 * (c-1);\n\n  // second car\n  c = 1;\n  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;\n  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;\n  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;\n  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;\n  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;\n  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;\n  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;\n  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;\n  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;\n  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;\n  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;\n  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;\n  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;\n  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;\n  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;\n  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;\n  t0 += c-1 + 37 * (c-1);\n\n  o[ 0] = t0;\n  o[ 1] = t1;\n  o[ 2] = t2;\n  o[ 3] = t3;\n  o[ 4] = t4;\n  o[ 5] = t5;\n  o[ 6] = t6;\n  o[ 7] = t7;\n  o[ 8] = t8;\n  o[ 9] = t9;\n  o[10] = t10;\n  o[11] = t11;\n  o[12] = t12;\n  o[13] = t13;\n  o[14] = t14;\n  o[15] = t15;\n}\n\nfunction S(o, a) {\n  M(o, a, a);\n}\n\nfunction inv25519(o, i) {\n  var c = gf();\n  var a;\n  for (a = 0; a < 16; a++) c[a] = i[a];\n  for (a = 253; a >= 0; a--) {\n    S(c, c);\n    if(a !== 2 && a !== 4) M(c, c, i);\n  }\n  for (a = 0; a < 16; a++) o[a] = c[a];\n}\n\nfunction pow2523(o, i) {\n  var c = gf();\n  var a;\n  for (a = 0; a < 16; a++) c[a] = i[a];\n  for (a = 250; a >= 0; a--) {\n      S(c, c);\n      if(a !== 1) M(c, c, i);\n  }\n  for (a = 0; a < 16; a++) o[a] = c[a];\n}\n\nfunction crypto_scalarmult(q, n, p) {\n  var z = new Uint8Array(32);\n  var x = new Float64Array(80), r, i;\n  var a = gf(), b = gf(), c = gf(),\n      d = gf(), e = gf(), f = gf();\n  for (i = 0; i < 31; i++) z[i] = n[i];\n  z[31]=(n[31]&127)|64;\n  z[0]&=248;\n  unpack25519(x,p);\n  for (i = 0; i < 16; i++) {\n    b[i]=x[i];\n    d[i]=a[i]=c[i]=0;\n  }\n  a[0]=d[0]=1;\n  for (i=254; i>=0; --i) {\n    r=(z[i>>>3]>>>(i&7))&1;\n    sel25519(a,b,r);\n    sel25519(c,d,r);\n    A(e,a,c);\n    Z(a,a,c);\n    A(c,b,d);\n    Z(b,b,d);\n    S(d,e);\n    S(f,a);\n    M(a,c,a);\n    M(c,b,e);\n    A(e,a,c);\n    Z(a,a,c);\n    S(b,a);\n    Z(c,d,f);\n    M(a,c,_121665);\n    A(a,a,d);\n    M(c,c,a);\n    M(a,d,f);\n    M(d,b,x);\n    S(b,e);\n    sel25519(a,b,r);\n    sel25519(c,d,r);\n  }\n  for (i = 0; i < 16; i++) {\n    x[i+16]=a[i];\n    x[i+32]=c[i];\n    x[i+48]=b[i];\n    x[i+64]=d[i];\n  }\n  var x32 = x.subarray(32);\n  var x16 = x.subarray(16);\n  inv25519(x32,x32);\n  M(x16,x16,x32);\n  pack25519(q,x16);\n  return 0;\n}\n\nfunction crypto_scalarmult_base(q, n) {\n  return crypto_scalarmult(q, n, _9);\n}\n\nfunction crypto_box_keypair(y, x) {\n  randombytes(x, 32);\n  return crypto_scalarmult_base(y, x);\n}\n\nfunction crypto_box_beforenm(k, y, x) {\n  var s = new Uint8Array(32);\n  crypto_scalarmult(s, x, y);\n  return crypto_core_hsalsa20(k, _0, s, sigma);\n}\n\nvar crypto_box_afternm = crypto_secretbox;\nvar crypto_box_open_afternm = crypto_secretbox_open;\n\nfunction crypto_box(c, m, d, n, y, x) {\n  var k = new Uint8Array(32);\n  crypto_box_beforenm(k, y, x);\n  return crypto_box_afternm(c, m, d, n, k);\n}\n\nfunction crypto_box_open(m, c, d, n, y, x) {\n  var k = new Uint8Array(32);\n  crypto_box_beforenm(k, y, x);\n  return crypto_box_open_afternm(m, c, d, n, k);\n}\n\nvar K = [\n  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\n  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\n  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\n  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\n  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\n  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\n  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\n  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\n  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\n  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\n  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\n  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\n  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\n  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\n];\n\nfunction crypto_hashblocks_hl(hh, hl, m, n) {\n  var wh = new Int32Array(16), wl = new Int32Array(16),\n      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,\n      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,\n      th, tl, i, j, h, l, a, b, c, d;\n\n  var ah0 = hh[0],\n      ah1 = hh[1],\n      ah2 = hh[2],\n      ah3 = hh[3],\n      ah4 = hh[4],\n      ah5 = hh[5],\n      ah6 = hh[6],\n      ah7 = hh[7],\n\n      al0 = hl[0],\n      al1 = hl[1],\n      al2 = hl[2],\n      al3 = hl[3],\n      al4 = hl[4],\n      al5 = hl[5],\n      al6 = hl[6],\n      al7 = hl[7];\n\n  var pos = 0;\n  while (n >= 128) {\n    for (i = 0; i < 16; i++) {\n      j = 8 * i + pos;\n      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];\n      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];\n    }\n    for (i = 0; i < 80; i++) {\n      bh0 = ah0;\n      bh1 = ah1;\n      bh2 = ah2;\n      bh3 = ah3;\n      bh4 = ah4;\n      bh5 = ah5;\n      bh6 = ah6;\n      bh7 = ah7;\n\n      bl0 = al0;\n      bl1 = al1;\n      bl2 = al2;\n      bl3 = al3;\n      bl4 = al4;\n      bl5 = al5;\n      bl6 = al6;\n      bl7 = al7;\n\n      // add\n      h = ah7;\n      l = al7;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      // Sigma1\n      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));\n      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // Ch\n      h = (ah4 & ah5) ^ (~ah4 & ah6);\n      l = (al4 & al5) ^ (~al4 & al6);\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // K\n      h = K[i*2];\n      l = K[i*2+1];\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // w\n      h = wh[i%16];\n      l = wl[i%16];\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      th = c & 0xffff | d << 16;\n      tl = a & 0xffff | b << 16;\n\n      // add\n      h = th;\n      l = tl;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      // Sigma0\n      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));\n      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // Maj\n      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);\n      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      bh7 = (c & 0xffff) | (d << 16);\n      bl7 = (a & 0xffff) | (b << 16);\n\n      // add\n      h = bh3;\n      l = bl3;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      h = th;\n      l = tl;\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      bh3 = (c & 0xffff) | (d << 16);\n      bl3 = (a & 0xffff) | (b << 16);\n\n      ah1 = bh0;\n      ah2 = bh1;\n      ah3 = bh2;\n      ah4 = bh3;\n      ah5 = bh4;\n      ah6 = bh5;\n      ah7 = bh6;\n      ah0 = bh7;\n\n      al1 = bl0;\n      al2 = bl1;\n      al3 = bl2;\n      al4 = bl3;\n      al5 = bl4;\n      al6 = bl5;\n      al7 = bl6;\n      al0 = bl7;\n\n      if (i%16 === 15) {\n        for (j = 0; j < 16; j++) {\n          // add\n          h = wh[j];\n          l = wl[j];\n\n          a = l & 0xffff; b = l >>> 16;\n          c = h & 0xffff; d = h >>> 16;\n\n          h = wh[(j+9)%16];\n          l = wl[(j+9)%16];\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          // sigma0\n          th = wh[(j+1)%16];\n          tl = wl[(j+1)%16];\n          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);\n          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          // sigma1\n          th = wh[(j+14)%16];\n          tl = wl[(j+14)%16];\n          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);\n          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          b += a >>> 16;\n          c += b >>> 16;\n          d += c >>> 16;\n\n          wh[j] = (c & 0xffff) | (d << 16);\n          wl[j] = (a & 0xffff) | (b << 16);\n        }\n      }\n    }\n\n    // add\n    h = ah0;\n    l = al0;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[0];\n    l = hl[0];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[0] = ah0 = (c & 0xffff) | (d << 16);\n    hl[0] = al0 = (a & 0xffff) | (b << 16);\n\n    h = ah1;\n    l = al1;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[1];\n    l = hl[1];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[1] = ah1 = (c & 0xffff) | (d << 16);\n    hl[1] = al1 = (a & 0xffff) | (b << 16);\n\n    h = ah2;\n    l = al2;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[2];\n    l = hl[2];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[2] = ah2 = (c & 0xffff) | (d << 16);\n    hl[2] = al2 = (a & 0xffff) | (b << 16);\n\n    h = ah3;\n    l = al3;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[3];\n    l = hl[3];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[3] = ah3 = (c & 0xffff) | (d << 16);\n    hl[3] = al3 = (a & 0xffff) | (b << 16);\n\n    h = ah4;\n    l = al4;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[4];\n    l = hl[4];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[4] = ah4 = (c & 0xffff) | (d << 16);\n    hl[4] = al4 = (a & 0xffff) | (b << 16);\n\n    h = ah5;\n    l = al5;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[5];\n    l = hl[5];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[5] = ah5 = (c & 0xffff) | (d << 16);\n    hl[5] = al5 = (a & 0xffff) | (b << 16);\n\n    h = ah6;\n    l = al6;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[6];\n    l = hl[6];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[6] = ah6 = (c & 0xffff) | (d << 16);\n    hl[6] = al6 = (a & 0xffff) | (b << 16);\n\n    h = ah7;\n    l = al7;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[7];\n    l = hl[7];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[7] = ah7 = (c & 0xffff) | (d << 16);\n    hl[7] = al7 = (a & 0xffff) | (b << 16);\n\n    pos += 128;\n    n -= 128;\n  }\n\n  return n;\n}\n\nfunction crypto_hash(out, m, n) {\n  var hh = new Int32Array(8),\n      hl = new Int32Array(8),\n      x = new Uint8Array(256),\n      i, b = n;\n\n  hh[0] = 0x6a09e667;\n  hh[1] = 0xbb67ae85;\n  hh[2] = 0x3c6ef372;\n  hh[3] = 0xa54ff53a;\n  hh[4] = 0x510e527f;\n  hh[5] = 0x9b05688c;\n  hh[6] = 0x1f83d9ab;\n  hh[7] = 0x5be0cd19;\n\n  hl[0] = 0xf3bcc908;\n  hl[1] = 0x84caa73b;\n  hl[2] = 0xfe94f82b;\n  hl[3] = 0x5f1d36f1;\n  hl[4] = 0xade682d1;\n  hl[5] = 0x2b3e6c1f;\n  hl[6] = 0xfb41bd6b;\n  hl[7] = 0x137e2179;\n\n  crypto_hashblocks_hl(hh, hl, m, n);\n  n %= 128;\n\n  for (i = 0; i < n; i++) x[i] = m[b-n+i];\n  x[n] = 128;\n\n  n = 256-128*(n<112?1:0);\n  x[n-9] = 0;\n  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);\n  crypto_hashblocks_hl(hh, hl, x, n);\n\n  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);\n\n  return 0;\n}\n\nfunction add(p, q) {\n  var a = gf(), b = gf(), c = gf(),\n      d = gf(), e = gf(), f = gf(),\n      g = gf(), h = gf(), t = gf();\n\n  Z(a, p[1], p[0]);\n  Z(t, q[1], q[0]);\n  M(a, a, t);\n  A(b, p[0], p[1]);\n  A(t, q[0], q[1]);\n  M(b, b, t);\n  M(c, p[3], q[3]);\n  M(c, c, D2);\n  M(d, p[2], q[2]);\n  A(d, d, d);\n  Z(e, b, a);\n  Z(f, d, c);\n  A(g, d, c);\n  A(h, b, a);\n\n  M(p[0], e, f);\n  M(p[1], h, g);\n  M(p[2], g, f);\n  M(p[3], e, h);\n}\n\nfunction cswap(p, q, b) {\n  var i;\n  for (i = 0; i < 4; i++) {\n    sel25519(p[i], q[i], b);\n  }\n}\n\nfunction pack(r, p) {\n  var tx = gf(), ty = gf(), zi = gf();\n  inv25519(zi, p[2]);\n  M(tx, p[0], zi);\n  M(ty, p[1], zi);\n  pack25519(r, ty);\n  r[31] ^= par25519(tx) << 7;\n}\n\nfunction scalarmult(p, q, s) {\n  var b, i;\n  set25519(p[0], gf0);\n  set25519(p[1], gf1);\n  set25519(p[2], gf1);\n  set25519(p[3], gf0);\n  for (i = 255; i >= 0; --i) {\n    b = (s[(i/8)|0] >> (i&7)) & 1;\n    cswap(p, q, b);\n    add(q, p);\n    add(p, p);\n    cswap(p, q, b);\n  }\n}\n\nfunction scalarbase(p, s) {\n  var q = [gf(), gf(), gf(), gf()];\n  set25519(q[0], X);\n  set25519(q[1], Y);\n  set25519(q[2], gf1);\n  M(q[3], X, Y);\n  scalarmult(p, q, s);\n}\n\nfunction crypto_sign_keypair(pk, sk, seeded) {\n  var d = new Uint8Array(64);\n  var p = [gf(), gf(), gf(), gf()];\n  var i;\n\n  if (!seeded) randombytes(sk, 32);\n  crypto_hash(d, sk, 32);\n  d[0] &= 248;\n  d[31] &= 127;\n  d[31] |= 64;\n\n  scalarbase(p, d);\n  pack(pk, p);\n\n  for (i = 0; i < 32; i++) sk[i+32] = pk[i];\n  return 0;\n}\n\nvar L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);\n\nfunction modL(r, x) {\n  var carry, i, j, k;\n  for (i = 63; i >= 32; --i) {\n    carry = 0;\n    for (j = i - 32, k = i - 12; j < k; ++j) {\n      x[j] += carry - 16 * x[i] * L[j - (i - 32)];\n      carry = Math.floor((x[j] + 128) / 256);\n      x[j] -= carry * 256;\n    }\n    x[j] += carry;\n    x[i] = 0;\n  }\n  carry = 0;\n  for (j = 0; j < 32; j++) {\n    x[j] += carry - (x[31] >> 4) * L[j];\n    carry = x[j] >> 8;\n    x[j] &= 255;\n  }\n  for (j = 0; j < 32; j++) x[j] -= carry * L[j];\n  for (i = 0; i < 32; i++) {\n    x[i+1] += x[i] >> 8;\n    r[i] = x[i] & 255;\n  }\n}\n\nfunction reduce(r) {\n  var x = new Float64Array(64), i;\n  for (i = 0; i < 64; i++) x[i] = r[i];\n  for (i = 0; i < 64; i++) r[i] = 0;\n  modL(r, x);\n}\n\n// Note: difference from C - smlen returned, not passed as argument.\nfunction crypto_sign(sm, m, n, sk) {\n  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);\n  var i, j, x = new Float64Array(64);\n  var p = [gf(), gf(), gf(), gf()];\n\n  crypto_hash(d, sk, 32);\n  d[0] &= 248;\n  d[31] &= 127;\n  d[31] |= 64;\n\n  var smlen = n + 64;\n  for (i = 0; i < n; i++) sm[64 + i] = m[i];\n  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];\n\n  crypto_hash(r, sm.subarray(32), n+32);\n  reduce(r);\n  scalarbase(p, r);\n  pack(sm, p);\n\n  for (i = 32; i < 64; i++) sm[i] = sk[i];\n  crypto_hash(h, sm, n + 64);\n  reduce(h);\n\n  for (i = 0; i < 64; i++) x[i] = 0;\n  for (i = 0; i < 32; i++) x[i] = r[i];\n  for (i = 0; i < 32; i++) {\n    for (j = 0; j < 32; j++) {\n      x[i+j] += h[i] * d[j];\n    }\n  }\n\n  modL(sm.subarray(32), x);\n  return smlen;\n}\n\nfunction unpackneg(r, p) {\n  var t = gf(), chk = gf(), num = gf(),\n      den = gf(), den2 = gf(), den4 = gf(),\n      den6 = gf();\n\n  set25519(r[2], gf1);\n  unpack25519(r[1], p);\n  S(num, r[1]);\n  M(den, num, D);\n  Z(num, num, r[2]);\n  A(den, r[2], den);\n\n  S(den2, den);\n  S(den4, den2);\n  M(den6, den4, den2);\n  M(t, den6, num);\n  M(t, t, den);\n\n  pow2523(t, t);\n  M(t, t, num);\n  M(t, t, den);\n  M(t, t, den);\n  M(r[0], t, den);\n\n  S(chk, r[0]);\n  M(chk, chk, den);\n  if (neq25519(chk, num)) M(r[0], r[0], I);\n\n  S(chk, r[0]);\n  M(chk, chk, den);\n  if (neq25519(chk, num)) return -1;\n\n  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);\n\n  M(r[3], r[0], r[1]);\n  return 0;\n}\n\nfunction crypto_sign_open(m, sm, n, pk) {\n  var i;\n  var t = new Uint8Array(32), h = new Uint8Array(64);\n  var p = [gf(), gf(), gf(), gf()],\n      q = [gf(), gf(), gf(), gf()];\n\n  if (n < 64) return -1;\n\n  if (unpackneg(q, pk)) return -1;\n\n  for (i = 0; i < n; i++) m[i] = sm[i];\n  for (i = 0; i < 32; i++) m[i+32] = pk[i];\n  crypto_hash(h, m, n);\n  reduce(h);\n  scalarmult(p, q, h);\n\n  scalarbase(q, sm.subarray(32));\n  add(p, q);\n  pack(t, p);\n\n  n -= 64;\n  if (crypto_verify_32(sm, 0, t, 0)) {\n    for (i = 0; i < n; i++) m[i] = 0;\n    return -1;\n  }\n\n  for (i = 0; i < n; i++) m[i] = sm[i + 64];\n  return n;\n}\n\nvar crypto_secretbox_KEYBYTES = 32,\n    crypto_secretbox_NONCEBYTES = 24,\n    crypto_secretbox_ZEROBYTES = 32,\n    crypto_secretbox_BOXZEROBYTES = 16,\n    crypto_scalarmult_BYTES = 32,\n    crypto_scalarmult_SCALARBYTES = 32,\n    crypto_box_PUBLICKEYBYTES = 32,\n    crypto_box_SECRETKEYBYTES = 32,\n    crypto_box_BEFORENMBYTES = 32,\n    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,\n    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,\n    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,\n    crypto_sign_BYTES = 64,\n    crypto_sign_PUBLICKEYBYTES = 32,\n    crypto_sign_SECRETKEYBYTES = 64,\n    crypto_sign_SEEDBYTES = 32,\n    crypto_hash_BYTES = 64;\n\nnacl.lowlevel = {\n  crypto_core_hsalsa20: crypto_core_hsalsa20,\n  crypto_stream_xor: crypto_stream_xor,\n  crypto_stream: crypto_stream,\n  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,\n  crypto_stream_salsa20: crypto_stream_salsa20,\n  crypto_onetimeauth: crypto_onetimeauth,\n  crypto_onetimeauth_verify: crypto_onetimeauth_verify,\n  crypto_verify_16: crypto_verify_16,\n  crypto_verify_32: crypto_verify_32,\n  crypto_secretbox: crypto_secretbox,\n  crypto_secretbox_open: crypto_secretbox_open,\n  crypto_scalarmult: crypto_scalarmult,\n  crypto_scalarmult_base: crypto_scalarmult_base,\n  crypto_box_beforenm: crypto_box_beforenm,\n  crypto_box_afternm: crypto_box_afternm,\n  crypto_box: crypto_box,\n  crypto_box_open: crypto_box_open,\n  crypto_box_keypair: crypto_box_keypair,\n  crypto_hash: crypto_hash,\n  crypto_sign: crypto_sign,\n  crypto_sign_keypair: crypto_sign_keypair,\n  crypto_sign_open: crypto_sign_open,\n\n  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,\n  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,\n  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,\n  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,\n  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,\n  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,\n  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,\n  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,\n  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,\n  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,\n  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,\n  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,\n  crypto_sign_BYTES: crypto_sign_BYTES,\n  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,\n  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,\n  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,\n  crypto_hash_BYTES: crypto_hash_BYTES,\n\n  gf: gf,\n  D: D,\n  L: L,\n  pack25519: pack25519,\n  unpack25519: unpack25519,\n  M: M,\n  A: A,\n  S: S,\n  Z: Z,\n  pow2523: pow2523,\n  add: add,\n  set25519: set25519,\n  modL: modL,\n  scalarmult: scalarmult,\n  scalarbase: scalarbase,\n};\n\n/* High-level API */\n\nfunction checkLengths(k, n) {\n  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');\n  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');\n}\n\nfunction checkBoxLengths(pk, sk) {\n  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');\n  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');\n}\n\nfunction checkArrayTypes() {\n  for (var i = 0; i < arguments.length; i++) {\n    if (!(arguments[i] instanceof Uint8Array))\n      throw new TypeError('unexpected type, use Uint8Array');\n  }\n}\n\nfunction cleanup(arr) {\n  for (var i = 0; i < arr.length; i++) arr[i] = 0;\n}\n\nnacl.randomBytes = function(n) {\n  var b = new Uint8Array(n);\n  randombytes(b, n);\n  return b;\n};\n\nnacl.secretbox = function(msg, nonce, key) {\n  checkArrayTypes(msg, nonce, key);\n  checkLengths(key, nonce);\n  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);\n  var c = new Uint8Array(m.length);\n  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];\n  crypto_secretbox(c, m, m.length, nonce, key);\n  return c.subarray(crypto_secretbox_BOXZEROBYTES);\n};\n\nnacl.secretbox.open = function(box, nonce, key) {\n  checkArrayTypes(box, nonce, key);\n  checkLengths(key, nonce);\n  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);\n  var m = new Uint8Array(c.length);\n  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];\n  if (c.length < 32) return null;\n  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;\n  return m.subarray(crypto_secretbox_ZEROBYTES);\n};\n\nnacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;\nnacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;\nnacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;\n\nnacl.scalarMult = function(n, p) {\n  checkArrayTypes(n, p);\n  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');\n  var q = new Uint8Array(crypto_scalarmult_BYTES);\n  crypto_scalarmult(q, n, p);\n  return q;\n};\n\nnacl.scalarMult.base = function(n) {\n  checkArrayTypes(n);\n  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n  var q = new Uint8Array(crypto_scalarmult_BYTES);\n  crypto_scalarmult_base(q, n);\n  return q;\n};\n\nnacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;\nnacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;\n\nnacl.box = function(msg, nonce, publicKey, secretKey) {\n  var k = nacl.box.before(publicKey, secretKey);\n  return nacl.secretbox(msg, nonce, k);\n};\n\nnacl.box.before = function(publicKey, secretKey) {\n  checkArrayTypes(publicKey, secretKey);\n  checkBoxLengths(publicKey, secretKey);\n  var k = new Uint8Array(crypto_box_BEFORENMBYTES);\n  crypto_box_beforenm(k, publicKey, secretKey);\n  return k;\n};\n\nnacl.box.after = nacl.secretbox;\n\nnacl.box.open = function(msg, nonce, publicKey, secretKey) {\n  var k = nacl.box.before(publicKey, secretKey);\n  return nacl.secretbox.open(msg, nonce, k);\n};\n\nnacl.box.open.after = nacl.secretbox.open;\n\nnacl.box.keyPair = function() {\n  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);\n  crypto_box_keypair(pk, sk);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.box.keyPair.fromSecretKey = function(secretKey) {\n  checkArrayTypes(secretKey);\n  if (secretKey.length !== crypto_box_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n  crypto_scalarmult_base(pk, secretKey);\n  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};\n};\n\nnacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;\nnacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;\nnacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;\nnacl.box.nonceLength = crypto_box_NONCEBYTES;\nnacl.box.overheadLength = nacl.secretbox.overheadLength;\n\nnacl.sign = function(msg, secretKey) {\n  checkArrayTypes(msg, secretKey);\n  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);\n  crypto_sign(signedMsg, msg, msg.length, secretKey);\n  return signedMsg;\n};\n\nnacl.sign.open = function(signedMsg, publicKey) {\n  checkArrayTypes(signedMsg, publicKey);\n  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)\n    throw new Error('bad public key size');\n  var tmp = new Uint8Array(signedMsg.length);\n  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);\n  if (mlen < 0) return null;\n  var m = new Uint8Array(mlen);\n  for (var i = 0; i < m.length; i++) m[i] = tmp[i];\n  return m;\n};\n\nnacl.sign.detached = function(msg, secretKey) {\n  var signedMsg = nacl.sign(msg, secretKey);\n  var sig = new Uint8Array(crypto_sign_BYTES);\n  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];\n  return sig;\n};\n\nnacl.sign.detached.verify = function(msg, sig, publicKey) {\n  checkArrayTypes(msg, sig, publicKey);\n  if (sig.length !== crypto_sign_BYTES)\n    throw new Error('bad signature size');\n  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)\n    throw new Error('bad public key size');\n  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);\n  var m = new Uint8Array(crypto_sign_BYTES + msg.length);\n  var i;\n  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];\n  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];\n  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);\n};\n\nnacl.sign.keyPair = function() {\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n  crypto_sign_keypair(pk, sk);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.sign.keyPair.fromSecretKey = function(secretKey) {\n  checkArrayTypes(secretKey);\n  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];\n  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};\n};\n\nnacl.sign.keyPair.fromSeed = function(seed) {\n  checkArrayTypes(seed);\n  if (seed.length !== crypto_sign_SEEDBYTES)\n    throw new Error('bad seed size');\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n  for (var i = 0; i < 32; i++) sk[i] = seed[i];\n  crypto_sign_keypair(pk, sk, true);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;\nnacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;\nnacl.sign.seedLength = crypto_sign_SEEDBYTES;\nnacl.sign.signatureLength = crypto_sign_BYTES;\n\nnacl.hash = function(msg) {\n  checkArrayTypes(msg);\n  var h = new Uint8Array(crypto_hash_BYTES);\n  crypto_hash(h, msg, msg.length);\n  return h;\n};\n\nnacl.hash.hashLength = crypto_hash_BYTES;\n\nnacl.verify = function(x, y) {\n  checkArrayTypes(x, y);\n  // Zero length arguments are considered not equal.\n  if (x.length === 0 || y.length === 0) return false;\n  if (x.length !== y.length) return false;\n  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;\n};\n\nnacl.setPRNG = function(fn) {\n  randombytes = fn;\n};\n\n(function() {\n  // Initialize PRNG if environment provides CSPRNG.\n  // If not, methods calling randombytes will throw.\n  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;\n  if (crypto && crypto.getRandomValues) {\n    // Browsers.\n    var QUOTA = 65536;\n    nacl.setPRNG(function(x, n) {\n      var i, v = new Uint8Array(n);\n      for (i = 0; i < n; i += QUOTA) {\n        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));\n      }\n      for (i = 0; i < n; i++) x[i] = v[i];\n      cleanup(v);\n    });\n  } else if (true) {\n    // Node.js.\n    crypto = __webpack_require__(/*! crypto */ \"?5ddf\");\n    if (crypto && crypto.randomBytes) {\n      nacl.setPRNG(function(x, n) {\n        var i, v = crypto.randomBytes(n);\n        for (i = 0; i < n; i++) x[i] = v[i];\n        cleanup(v);\n      });\n    }\n  }\n})();\n\n})( true && module.exports ? module.exports : (self.nacl = self.nacl || {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90d2VldG5hY2wvbmFjbC1mYXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBOztBQUVBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLCtDQUErQztBQUMvQywrQ0FBK0M7QUFDL0MsK0NBQStDO0FBQy9DLCtDQUErQztBQUMvQywrQ0FBK0M7QUFDL0M7QUFDQSwrQ0FBK0M7QUFDL0MsK0NBQStDO0FBQy9DLCtDQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RCx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZEO0FBQ0EsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RCx1REFBdUQ7QUFDdkQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLFFBQVE7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUE7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1QiwyQkFBMkI7QUFDbEQsdUJBQXVCLDJCQUEyQjtBQUNsRCx1QkFBdUIsMkJBQTJCO0FBQ2xELHVCQUF1QiwyQkFBMkI7QUFDbEQsdUJBQXVCLDJCQUEyQjtBQUNsRCx1QkFBdUIsMkJBQTJCO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1QiwyQkFBMkI7QUFDbEQsdUJBQXVCLDJCQUEyQjtBQUNsRCx1QkFBdUIsMkJBQTJCO0FBQ2xELHVCQUF1QiwyQkFBMkI7QUFDbEQsdUJBQXVCLDJCQUEyQjtBQUNsRCx1QkFBdUIsMkJBQTJCO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QixzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkIsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkIsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkIsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLHNCQUFzQjs7QUFFdEI7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkIsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0IsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQiwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEIsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEIsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEIsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxPQUFPO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsT0FBTzs7QUFFckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsUUFBUTs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUEsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBOztBQUVBLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQyxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQyxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQSxLQUFLO0FBQ0wsSUFBSSxTQUFTLElBQThCO0FBQzNDO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHFCQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVELENBQUMsRUFBRSxLQUE2QixrRUFBa0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3R3ZWV0bmFjbC9uYWNsLWZhc3QuanM/NGVmNiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24obmFjbCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBQb3J0ZWQgaW4gMjAxNCBieSBEbWl0cnkgQ2hlc3RueWtoIGFuZCBEZXZpIE1hbmRpcmkuXG4vLyBQdWJsaWMgZG9tYWluLlxuLy9cbi8vIEltcGxlbWVudGF0aW9uIGRlcml2ZWQgZnJvbSBUd2VldE5hQ2wgdmVyc2lvbiAyMDE0MDQyNy5cbi8vIFNlZSBmb3IgZGV0YWlsczogaHR0cDovL3R3ZWV0bmFjbC5jci55cC50by9cblxudmFyIGdmID0gZnVuY3Rpb24oaW5pdCkge1xuICB2YXIgaSwgciA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICBpZiAoaW5pdCkgZm9yIChpID0gMDsgaSA8IGluaXQubGVuZ3RoOyBpKyspIHJbaV0gPSBpbml0W2ldO1xuICByZXR1cm4gcjtcbn07XG5cbi8vICBQbHVnZ2FibGUsIGluaXRpYWxpemVkIGluIGhpZ2gtbGV2ZWwgQVBJIGJlbG93LlxudmFyIHJhbmRvbWJ5dGVzID0gZnVuY3Rpb24oLyogeCwgbiAqLykgeyB0aHJvdyBuZXcgRXJyb3IoJ25vIFBSTkcnKTsgfTtcblxudmFyIF8wID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xudmFyIF85ID0gbmV3IFVpbnQ4QXJyYXkoMzIpOyBfOVswXSA9IDk7XG5cbnZhciBnZjAgPSBnZigpLFxuICAgIGdmMSA9IGdmKFsxXSksXG4gICAgXzEyMTY2NSA9IGdmKFsweGRiNDEsIDFdKSxcbiAgICBEID0gZ2YoWzB4NzhhMywgMHgxMzU5LCAweDRkY2EsIDB4NzVlYiwgMHhkOGFiLCAweDQxNDEsIDB4MGE0ZCwgMHgwMDcwLCAweGU4OTgsIDB4Nzc3OSwgMHg0MDc5LCAweDhjYzcsIDB4ZmU3MywgMHgyYjZmLCAweDZjZWUsIDB4NTIwM10pLFxuICAgIEQyID0gZ2YoWzB4ZjE1OSwgMHgyNmIyLCAweDliOTQsIDB4ZWJkNiwgMHhiMTU2LCAweDgyODMsIDB4MTQ5YSwgMHgwMGUwLCAweGQxMzAsIDB4ZWVmMywgMHg4MGYyLCAweDE5OGUsIDB4ZmNlNywgMHg1NmRmLCAweGQ5ZGMsIDB4MjQwNl0pLFxuICAgIFggPSBnZihbMHhkNTFhLCAweDhmMjUsIDB4MmQ2MCwgMHhjOTU2LCAweGE3YjIsIDB4OTUyNSwgMHhjNzYwLCAweDY5MmMsIDB4ZGM1YywgMHhmZGQ2LCAweGUyMzEsIDB4YzBhNCwgMHg1M2ZlLCAweGNkNmUsIDB4MzZkMywgMHgyMTY5XSksXG4gICAgWSA9IGdmKFsweDY2NTgsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjZdKSxcbiAgICBJID0gZ2YoWzB4YTBiMCwgMHg0YTBlLCAweDFiMjcsIDB4YzRlZSwgMHhlNDc4LCAweGFkMmYsIDB4MTgwNiwgMHgyZjQzLCAweGQ3YTcsIDB4M2RmYiwgMHgwMDk5LCAweDJiNGQsIDB4ZGYwYiwgMHg0ZmMxLCAweDI0ODAsIDB4MmI4M10pO1xuXG5mdW5jdGlvbiB0czY0KHgsIGksIGgsIGwpIHtcbiAgeFtpXSAgID0gKGggPj4gMjQpICYgMHhmZjtcbiAgeFtpKzFdID0gKGggPj4gMTYpICYgMHhmZjtcbiAgeFtpKzJdID0gKGggPj4gIDgpICYgMHhmZjtcbiAgeFtpKzNdID0gaCAmIDB4ZmY7XG4gIHhbaSs0XSA9IChsID4+IDI0KSAgJiAweGZmO1xuICB4W2krNV0gPSAobCA+PiAxNikgICYgMHhmZjtcbiAgeFtpKzZdID0gKGwgPj4gIDgpICAmIDB4ZmY7XG4gIHhbaSs3XSA9IGwgJiAweGZmO1xufVxuXG5mdW5jdGlvbiB2bih4LCB4aSwgeSwgeWksIG4pIHtcbiAgdmFyIGksZCA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIGQgfD0geFt4aStpXV55W3lpK2ldO1xuICByZXR1cm4gKDEgJiAoKGQgLSAxKSA+Pj4gOCkpIC0gMTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3ZlcmlmeV8xNih4LCB4aSwgeSwgeWkpIHtcbiAgcmV0dXJuIHZuKHgseGkseSx5aSwxNik7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b192ZXJpZnlfMzIoeCwgeGksIHksIHlpKSB7XG4gIHJldHVybiB2bih4LHhpLHkseWksMzIpO1xufVxuXG5mdW5jdGlvbiBjb3JlX3NhbHNhMjAobywgcCwgaywgYykge1xuICB2YXIgajAgID0gY1sgMF0gJiAweGZmIHwgKGNbIDFdICYgMHhmZik8PDggfCAoY1sgMl0gJiAweGZmKTw8MTYgfCAoY1sgM10gJiAweGZmKTw8MjQsXG4gICAgICBqMSAgPSBrWyAwXSAmIDB4ZmYgfCAoa1sgMV0gJiAweGZmKTw8OCB8IChrWyAyXSAmIDB4ZmYpPDwxNiB8IChrWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoyICA9IGtbIDRdICYgMHhmZiB8IChrWyA1XSAmIDB4ZmYpPDw4IHwgKGtbIDZdICYgMHhmZik8PDE2IHwgKGtbIDddICYgMHhmZik8PDI0LFxuICAgICAgajMgID0ga1sgOF0gJiAweGZmIHwgKGtbIDldICYgMHhmZik8PDggfCAoa1sxMF0gJiAweGZmKTw8MTYgfCAoa1sxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqNCAgPSBrWzEyXSAmIDB4ZmYgfCAoa1sxM10gJiAweGZmKTw8OCB8IChrWzE0XSAmIDB4ZmYpPDwxNiB8IChrWzE1XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo1ICA9IGNbIDRdICYgMHhmZiB8IChjWyA1XSAmIDB4ZmYpPDw4IHwgKGNbIDZdICYgMHhmZik8PDE2IHwgKGNbIDddICYgMHhmZik8PDI0LFxuICAgICAgajYgID0gcFsgMF0gJiAweGZmIHwgKHBbIDFdICYgMHhmZik8PDggfCAocFsgMl0gJiAweGZmKTw8MTYgfCAocFsgM10gJiAweGZmKTw8MjQsXG4gICAgICBqNyAgPSBwWyA0XSAmIDB4ZmYgfCAocFsgNV0gJiAweGZmKTw8OCB8IChwWyA2XSAmIDB4ZmYpPDwxNiB8IChwWyA3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo4ICA9IHBbIDhdICYgMHhmZiB8IChwWyA5XSAmIDB4ZmYpPDw4IHwgKHBbMTBdICYgMHhmZik8PDE2IHwgKHBbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajkgID0gcFsxMl0gJiAweGZmIHwgKHBbMTNdICYgMHhmZik8PDggfCAocFsxNF0gJiAweGZmKTw8MTYgfCAocFsxNV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTAgPSBjWyA4XSAmIDB4ZmYgfCAoY1sgOV0gJiAweGZmKTw8OCB8IChjWzEwXSAmIDB4ZmYpPDwxNiB8IChjWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMSA9IGtbMTZdICYgMHhmZiB8IChrWzE3XSAmIDB4ZmYpPDw4IHwgKGtbMThdICYgMHhmZik8PDE2IHwgKGtbMTldICYgMHhmZik8PDI0LFxuICAgICAgajEyID0ga1syMF0gJiAweGZmIHwgKGtbMjFdICYgMHhmZik8PDggfCAoa1syMl0gJiAweGZmKTw8MTYgfCAoa1syM10gJiAweGZmKTw8MjQsXG4gICAgICBqMTMgPSBrWzI0XSAmIDB4ZmYgfCAoa1syNV0gJiAweGZmKTw8OCB8IChrWzI2XSAmIDB4ZmYpPDwxNiB8IChrWzI3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxNCA9IGtbMjhdICYgMHhmZiB8IChrWzI5XSAmIDB4ZmYpPDw4IHwgKGtbMzBdICYgMHhmZik8PDE2IHwgKGtbMzFdICYgMHhmZik8PDI0LFxuICAgICAgajE1ID0gY1sxMl0gJiAweGZmIHwgKGNbMTNdICYgMHhmZik8PDggfCAoY1sxNF0gJiAweGZmKTw8MTYgfCAoY1sxNV0gJiAweGZmKTw8MjQ7XG5cbiAgdmFyIHgwID0gajAsIHgxID0gajEsIHgyID0gajIsIHgzID0gajMsIHg0ID0gajQsIHg1ID0gajUsIHg2ID0gajYsIHg3ID0gajcsXG4gICAgICB4OCA9IGo4LCB4OSA9IGo5LCB4MTAgPSBqMTAsIHgxMSA9IGoxMSwgeDEyID0gajEyLCB4MTMgPSBqMTMsIHgxNCA9IGoxNCxcbiAgICAgIHgxNSA9IGoxNSwgdTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDIwOyBpICs9IDIpIHtcbiAgICB1ID0geDAgKyB4MTIgfCAwO1xuICAgIHg0IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4NCArIHgwIHwgMDtcbiAgICB4OCBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDggKyB4NCB8IDA7XG4gICAgeDEyIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxMiArIHg4IHwgMDtcbiAgICB4MCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHg1ICsgeDEgfCAwO1xuICAgIHg5IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4OSArIHg1IHwgMDtcbiAgICB4MTMgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgxMyArIHg5IHwgMDtcbiAgICB4MSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MSArIHgxMyB8IDA7XG4gICAgeDUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTAgKyB4NiB8IDA7XG4gICAgeDE0IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTQgKyB4MTAgfCAwO1xuICAgIHgyIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MiArIHgxNCB8IDA7XG4gICAgeDYgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDYgKyB4MiB8IDA7XG4gICAgeDEwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDE1ICsgeDExIHwgMDtcbiAgICB4MyBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDMgKyB4MTUgfCAwO1xuICAgIHg3IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4NyArIHgzIHwgMDtcbiAgICB4MTEgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDExICsgeDcgfCAwO1xuICAgIHgxNSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgwICsgeDMgfCAwO1xuICAgIHgxIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MSArIHgwIHwgMDtcbiAgICB4MiBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDIgKyB4MSB8IDA7XG4gICAgeDMgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDMgKyB4MiB8IDA7XG4gICAgeDAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4NSArIHg0IHwgMDtcbiAgICB4NiBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDYgKyB4NSB8IDA7XG4gICAgeDcgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg3ICsgeDYgfCAwO1xuICAgIHg0IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg0ICsgeDcgfCAwO1xuICAgIHg1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDEwICsgeDkgfCAwO1xuICAgIHgxMSBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDExICsgeDEwIHwgMDtcbiAgICB4OCBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDggKyB4MTEgfCAwO1xuICAgIHg5IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg5ICsgeDggfCAwO1xuICAgIHgxMCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxNSArIHgxNCB8IDA7XG4gICAgeDEyIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTIgKyB4MTUgfCAwO1xuICAgIHgxMyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDEzICsgeDEyIHwgMDtcbiAgICB4MTQgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDE0ICsgeDEzIHwgMDtcbiAgICB4MTUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcbiAgfVxuICAgeDAgPSAgeDAgKyAgajAgfCAwO1xuICAgeDEgPSAgeDEgKyAgajEgfCAwO1xuICAgeDIgPSAgeDIgKyAgajIgfCAwO1xuICAgeDMgPSAgeDMgKyAgajMgfCAwO1xuICAgeDQgPSAgeDQgKyAgajQgfCAwO1xuICAgeDUgPSAgeDUgKyAgajUgfCAwO1xuICAgeDYgPSAgeDYgKyAgajYgfCAwO1xuICAgeDcgPSAgeDcgKyAgajcgfCAwO1xuICAgeDggPSAgeDggKyAgajggfCAwO1xuICAgeDkgPSAgeDkgKyAgajkgfCAwO1xuICB4MTAgPSB4MTAgKyBqMTAgfCAwO1xuICB4MTEgPSB4MTEgKyBqMTEgfCAwO1xuICB4MTIgPSB4MTIgKyBqMTIgfCAwO1xuICB4MTMgPSB4MTMgKyBqMTMgfCAwO1xuICB4MTQgPSB4MTQgKyBqMTQgfCAwO1xuICB4MTUgPSB4MTUgKyBqMTUgfCAwO1xuXG4gIG9bIDBdID0geDAgPj4+ICAwICYgMHhmZjtcbiAgb1sgMV0gPSB4MCA+Pj4gIDggJiAweGZmO1xuICBvWyAyXSA9IHgwID4+PiAxNiAmIDB4ZmY7XG4gIG9bIDNdID0geDAgPj4+IDI0ICYgMHhmZjtcblxuICBvWyA0XSA9IHgxID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDVdID0geDEgPj4+ICA4ICYgMHhmZjtcbiAgb1sgNl0gPSB4MSA+Pj4gMTYgJiAweGZmO1xuICBvWyA3XSA9IHgxID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sgOF0gPSB4MiA+Pj4gIDAgJiAweGZmO1xuICBvWyA5XSA9IHgyID4+PiAgOCAmIDB4ZmY7XG4gIG9bMTBdID0geDIgPj4+IDE2ICYgMHhmZjtcbiAgb1sxMV0gPSB4MiA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMTJdID0geDMgPj4+ICAwICYgMHhmZjtcbiAgb1sxM10gPSB4MyA+Pj4gIDggJiAweGZmO1xuICBvWzE0XSA9IHgzID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTVdID0geDMgPj4+IDI0ICYgMHhmZjtcblxuICBvWzE2XSA9IHg0ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMTddID0geDQgPj4+ICA4ICYgMHhmZjtcbiAgb1sxOF0gPSB4NCA+Pj4gMTYgJiAweGZmO1xuICBvWzE5XSA9IHg0ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syMF0gPSB4NSA+Pj4gIDAgJiAweGZmO1xuICBvWzIxXSA9IHg1ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMjJdID0geDUgPj4+IDE2ICYgMHhmZjtcbiAgb1syM10gPSB4NSA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjRdID0geDYgPj4+ICAwICYgMHhmZjtcbiAgb1syNV0gPSB4NiA+Pj4gIDggJiAweGZmO1xuICBvWzI2XSA9IHg2ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMjddID0geDYgPj4+IDI0ICYgMHhmZjtcblxuICBvWzI4XSA9IHg3ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjldID0geDcgPj4+ICA4ICYgMHhmZjtcbiAgb1szMF0gPSB4NyA+Pj4gMTYgJiAweGZmO1xuICBvWzMxXSA9IHg3ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1szMl0gPSB4OCA+Pj4gIDAgJiAweGZmO1xuICBvWzMzXSA9IHg4ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMzRdID0geDggPj4+IDE2ICYgMHhmZjtcbiAgb1szNV0gPSB4OCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMzZdID0geDkgPj4+ICAwICYgMHhmZjtcbiAgb1szN10gPSB4OSA+Pj4gIDggJiAweGZmO1xuICBvWzM4XSA9IHg5ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMzldID0geDkgPj4+IDI0ICYgMHhmZjtcblxuICBvWzQwXSA9IHgxMCA+Pj4gIDAgJiAweGZmO1xuICBvWzQxXSA9IHgxMCA+Pj4gIDggJiAweGZmO1xuICBvWzQyXSA9IHgxMCA+Pj4gMTYgJiAweGZmO1xuICBvWzQzXSA9IHgxMCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNDRdID0geDExID4+PiAgMCAmIDB4ZmY7XG4gIG9bNDVdID0geDExID4+PiAgOCAmIDB4ZmY7XG4gIG9bNDZdID0geDExID4+PiAxNiAmIDB4ZmY7XG4gIG9bNDddID0geDExID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s0OF0gPSB4MTIgPj4+ICAwICYgMHhmZjtcbiAgb1s0OV0gPSB4MTIgPj4+ICA4ICYgMHhmZjtcbiAgb1s1MF0gPSB4MTIgPj4+IDE2ICYgMHhmZjtcbiAgb1s1MV0gPSB4MTIgPj4+IDI0ICYgMHhmZjtcblxuICBvWzUyXSA9IHgxMyA+Pj4gIDAgJiAweGZmO1xuICBvWzUzXSA9IHgxMyA+Pj4gIDggJiAweGZmO1xuICBvWzU0XSA9IHgxMyA+Pj4gMTYgJiAweGZmO1xuICBvWzU1XSA9IHgxMyA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNTZdID0geDE0ID4+PiAgMCAmIDB4ZmY7XG4gIG9bNTddID0geDE0ID4+PiAgOCAmIDB4ZmY7XG4gIG9bNThdID0geDE0ID4+PiAxNiAmIDB4ZmY7XG4gIG9bNTldID0geDE0ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s2MF0gPSB4MTUgPj4+ICAwICYgMHhmZjtcbiAgb1s2MV0gPSB4MTUgPj4+ICA4ICYgMHhmZjtcbiAgb1s2Ml0gPSB4MTUgPj4+IDE2ICYgMHhmZjtcbiAgb1s2M10gPSB4MTUgPj4+IDI0ICYgMHhmZjtcbn1cblxuZnVuY3Rpb24gY29yZV9oc2Fsc2EyMChvLHAsayxjKSB7XG4gIHZhciBqMCAgPSBjWyAwXSAmIDB4ZmYgfCAoY1sgMV0gJiAweGZmKTw8OCB8IChjWyAyXSAmIDB4ZmYpPDwxNiB8IChjWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxICA9IGtbIDBdICYgMHhmZiB8IChrWyAxXSAmIDB4ZmYpPDw4IHwgKGtbIDJdICYgMHhmZik8PDE2IHwgKGtbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajIgID0ga1sgNF0gJiAweGZmIHwgKGtbIDVdICYgMHhmZik8PDggfCAoa1sgNl0gJiAweGZmKTw8MTYgfCAoa1sgN10gJiAweGZmKTw8MjQsXG4gICAgICBqMyAgPSBrWyA4XSAmIDB4ZmYgfCAoa1sgOV0gJiAweGZmKTw8OCB8IChrWzEwXSAmIDB4ZmYpPDwxNiB8IChrWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo0ICA9IGtbMTJdICYgMHhmZiB8IChrWzEzXSAmIDB4ZmYpPDw4IHwgKGtbMTRdICYgMHhmZik8PDE2IHwgKGtbMTVdICYgMHhmZik8PDI0LFxuICAgICAgajUgID0gY1sgNF0gJiAweGZmIHwgKGNbIDVdICYgMHhmZik8PDggfCAoY1sgNl0gJiAweGZmKTw8MTYgfCAoY1sgN10gJiAweGZmKTw8MjQsXG4gICAgICBqNiAgPSBwWyAwXSAmIDB4ZmYgfCAocFsgMV0gJiAweGZmKTw8OCB8IChwWyAyXSAmIDB4ZmYpPDwxNiB8IChwWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo3ICA9IHBbIDRdICYgMHhmZiB8IChwWyA1XSAmIDB4ZmYpPDw4IHwgKHBbIDZdICYgMHhmZik8PDE2IHwgKHBbIDddICYgMHhmZik8PDI0LFxuICAgICAgajggID0gcFsgOF0gJiAweGZmIHwgKHBbIDldICYgMHhmZik8PDggfCAocFsxMF0gJiAweGZmKTw8MTYgfCAocFsxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqOSAgPSBwWzEyXSAmIDB4ZmYgfCAocFsxM10gJiAweGZmKTw8OCB8IChwWzE0XSAmIDB4ZmYpPDwxNiB8IChwWzE1XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMCA9IGNbIDhdICYgMHhmZiB8IChjWyA5XSAmIDB4ZmYpPDw4IHwgKGNbMTBdICYgMHhmZik8PDE2IHwgKGNbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajExID0ga1sxNl0gJiAweGZmIHwgKGtbMTddICYgMHhmZik8PDggfCAoa1sxOF0gJiAweGZmKTw8MTYgfCAoa1sxOV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTIgPSBrWzIwXSAmIDB4ZmYgfCAoa1syMV0gJiAweGZmKTw8OCB8IChrWzIyXSAmIDB4ZmYpPDwxNiB8IChrWzIzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMyA9IGtbMjRdICYgMHhmZiB8IChrWzI1XSAmIDB4ZmYpPDw4IHwgKGtbMjZdICYgMHhmZik8PDE2IHwgKGtbMjddICYgMHhmZik8PDI0LFxuICAgICAgajE0ID0ga1syOF0gJiAweGZmIHwgKGtbMjldICYgMHhmZik8PDggfCAoa1szMF0gJiAweGZmKTw8MTYgfCAoa1szMV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTUgPSBjWzEyXSAmIDB4ZmYgfCAoY1sxM10gJiAweGZmKTw8OCB8IChjWzE0XSAmIDB4ZmYpPDwxNiB8IChjWzE1XSAmIDB4ZmYpPDwyNDtcblxuICB2YXIgeDAgPSBqMCwgeDEgPSBqMSwgeDIgPSBqMiwgeDMgPSBqMywgeDQgPSBqNCwgeDUgPSBqNSwgeDYgPSBqNiwgeDcgPSBqNyxcbiAgICAgIHg4ID0gajgsIHg5ID0gajksIHgxMCA9IGoxMCwgeDExID0gajExLCB4MTIgPSBqMTIsIHgxMyA9IGoxMywgeDE0ID0gajE0LFxuICAgICAgeDE1ID0gajE1LCB1O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjA7IGkgKz0gMikge1xuICAgIHUgPSB4MCArIHgxMiB8IDA7XG4gICAgeDQgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg0ICsgeDAgfCAwO1xuICAgIHg4IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4OCArIHg0IHwgMDtcbiAgICB4MTIgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDEyICsgeDggfCAwO1xuICAgIHgwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDUgKyB4MSB8IDA7XG4gICAgeDkgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg5ICsgeDUgfCAwO1xuICAgIHgxMyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDEzICsgeDkgfCAwO1xuICAgIHgxIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxICsgeDEzIHwgMDtcbiAgICB4NSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxMCArIHg2IHwgMDtcbiAgICB4MTQgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxNCArIHgxMCB8IDA7XG4gICAgeDIgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgyICsgeDE0IHwgMDtcbiAgICB4NiBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4NiArIHgyIHwgMDtcbiAgICB4MTAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTUgKyB4MTEgfCAwO1xuICAgIHgzIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MyArIHgxNSB8IDA7XG4gICAgeDcgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg3ICsgeDMgfCAwO1xuICAgIHgxMSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTEgKyB4NyB8IDA7XG4gICAgeDE1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDAgKyB4MyB8IDA7XG4gICAgeDEgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxICsgeDAgfCAwO1xuICAgIHgyIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MiArIHgxIHwgMDtcbiAgICB4MyBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MyArIHgyIHwgMDtcbiAgICB4MCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHg1ICsgeDQgfCAwO1xuICAgIHg2IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4NiArIHg1IHwgMDtcbiAgICB4NyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDcgKyB4NiB8IDA7XG4gICAgeDQgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDQgKyB4NyB8IDA7XG4gICAgeDUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTAgKyB4OSB8IDA7XG4gICAgeDExIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTEgKyB4MTAgfCAwO1xuICAgIHg4IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4OCArIHgxMSB8IDA7XG4gICAgeDkgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDkgKyB4OCB8IDA7XG4gICAgeDEwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDE1ICsgeDE0IHwgMDtcbiAgICB4MTIgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxMiArIHgxNSB8IDA7XG4gICAgeDEzIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MTMgKyB4MTIgfCAwO1xuICAgIHgxNCBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTQgKyB4MTMgfCAwO1xuICAgIHgxNSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuICB9XG5cbiAgb1sgMF0gPSB4MCA+Pj4gIDAgJiAweGZmO1xuICBvWyAxXSA9IHgwID4+PiAgOCAmIDB4ZmY7XG4gIG9bIDJdID0geDAgPj4+IDE2ICYgMHhmZjtcbiAgb1sgM10gPSB4MCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bIDRdID0geDUgPj4+ICAwICYgMHhmZjtcbiAgb1sgNV0gPSB4NSA+Pj4gIDggJiAweGZmO1xuICBvWyA2XSA9IHg1ID4+PiAxNiAmIDB4ZmY7XG4gIG9bIDddID0geDUgPj4+IDI0ICYgMHhmZjtcblxuICBvWyA4XSA9IHgxMCA+Pj4gIDAgJiAweGZmO1xuICBvWyA5XSA9IHgxMCA+Pj4gIDggJiAweGZmO1xuICBvWzEwXSA9IHgxMCA+Pj4gMTYgJiAweGZmO1xuICBvWzExXSA9IHgxMCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMTJdID0geDE1ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMTNdID0geDE1ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMTRdID0geDE1ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTVdID0geDE1ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sxNl0gPSB4NiA+Pj4gIDAgJiAweGZmO1xuICBvWzE3XSA9IHg2ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMThdID0geDYgPj4+IDE2ICYgMHhmZjtcbiAgb1sxOV0gPSB4NiA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjBdID0geDcgPj4+ICAwICYgMHhmZjtcbiAgb1syMV0gPSB4NyA+Pj4gIDggJiAweGZmO1xuICBvWzIyXSA9IHg3ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMjNdID0geDcgPj4+IDI0ICYgMHhmZjtcblxuICBvWzI0XSA9IHg4ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjVdID0geDggPj4+ICA4ICYgMHhmZjtcbiAgb1syNl0gPSB4OCA+Pj4gMTYgJiAweGZmO1xuICBvWzI3XSA9IHg4ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syOF0gPSB4OSA+Pj4gIDAgJiAweGZmO1xuICBvWzI5XSA9IHg5ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMzBdID0geDkgPj4+IDE2ICYgMHhmZjtcbiAgb1szMV0gPSB4OSA+Pj4gMjQgJiAweGZmO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fY29yZV9zYWxzYTIwKG91dCxpbnAsayxjKSB7XG4gIGNvcmVfc2Fsc2EyMChvdXQsaW5wLGssYyk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19jb3JlX2hzYWxzYTIwKG91dCxpbnAsayxjKSB7XG4gIGNvcmVfaHNhbHNhMjAob3V0LGlucCxrLGMpO1xufVxuXG52YXIgc2lnbWEgPSBuZXcgVWludDhBcnJheShbMTAxLCAxMjAsIDExMiwgOTcsIDExMCwgMTAwLCAzMiwgNTEsIDUwLCA0NSwgOTgsIDEyMSwgMTE2LCAxMDEsIDMyLCAxMDddKTtcbiAgICAgICAgICAgIC8vIFwiZXhwYW5kIDMyLWJ5dGUga1wiXG5cbmZ1bmN0aW9uIGNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3IoYyxjcG9zLG0sbXBvcyxiLG4saykge1xuICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDE2KSwgeCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHUsIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB6W2ldID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykgeltpXSA9IG5baV07XG4gIHdoaWxlIChiID49IDY0KSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIGNbY3BvcytpXSA9IG1bbXBvcytpXSBeIHhbaV07XG4gICAgdSA9IDE7XG4gICAgZm9yIChpID0gODsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHUgPSB1ICsgKHpbaV0gJiAweGZmKSB8IDA7XG4gICAgICB6W2ldID0gdSAmIDB4ZmY7XG4gICAgICB1ID4+Pj0gODtcbiAgICB9XG4gICAgYiAtPSA2NDtcbiAgICBjcG9zICs9IDY0O1xuICAgIG1wb3MgKz0gNjQ7XG4gIH1cbiAgaWYgKGIgPiAwKSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGI7IGkrKykgY1tjcG9zK2ldID0gbVttcG9zK2ldIF4geFtpXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3N0cmVhbV9zYWxzYTIwKGMsY3BvcyxiLG4saykge1xuICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDE2KSwgeCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHUsIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB6W2ldID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykgeltpXSA9IG5baV07XG4gIHdoaWxlIChiID49IDY0KSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIGNbY3BvcytpXSA9IHhbaV07XG4gICAgdSA9IDE7XG4gICAgZm9yIChpID0gODsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHUgPSB1ICsgKHpbaV0gJiAweGZmKSB8IDA7XG4gICAgICB6W2ldID0gdSAmIDB4ZmY7XG4gICAgICB1ID4+Pj0gODtcbiAgICB9XG4gICAgYiAtPSA2NDtcbiAgICBjcG9zICs9IDY0O1xuICB9XG4gIGlmIChiID4gMCkge1xuICAgIGNyeXB0b19jb3JlX3NhbHNhMjAoeCx6LGssc2lnbWEpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBiOyBpKyspIGNbY3BvcytpXSA9IHhbaV07XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zdHJlYW0oYyxjcG9zLGQsbixrKSB7XG4gIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fY29yZV9oc2Fsc2EyMChzLG4sayxzaWdtYSk7XG4gIHZhciBzbiA9IG5ldyBVaW50OEFycmF5KDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgc25baV0gPSBuW2krMTZdO1xuICByZXR1cm4gY3J5cHRvX3N0cmVhbV9zYWxzYTIwKGMsY3BvcyxkLHNuLHMpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc3RyZWFtX3hvcihjLGNwb3MsbSxtcG9zLGQsbixrKSB7XG4gIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fY29yZV9oc2Fsc2EyMChzLG4sayxzaWdtYSk7XG4gIHZhciBzbiA9IG5ldyBVaW50OEFycmF5KDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgc25baV0gPSBuW2krMTZdO1xuICByZXR1cm4gY3J5cHRvX3N0cmVhbV9zYWxzYTIwX3hvcihjLGNwb3MsbSxtcG9zLGQsc24scyk7XG59XG5cbi8qXG4qIFBvcnQgb2YgQW5kcmV3IE1vb24ncyBQb2x5MTMwNS1kb25uYS0xNi4gUHVibGljIGRvbWFpbi5cbiogaHR0cHM6Ly9naXRodWIuY29tL2Zsb29keWJlcnJ5L3BvbHkxMzA1LWRvbm5hXG4qL1xuXG52YXIgcG9seTEzMDUgPSBmdW5jdGlvbihrZXkpIHtcbiAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIHRoaXMuciA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gIHRoaXMuaCA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gIHRoaXMucGFkID0gbmV3IFVpbnQxNkFycmF5KDgpO1xuICB0aGlzLmxlZnRvdmVyID0gMDtcbiAgdGhpcy5maW4gPSAwO1xuXG4gIHZhciB0MCwgdDEsIHQyLCB0MywgdDQsIHQ1LCB0NiwgdDc7XG5cbiAgdDAgPSBrZXlbIDBdICYgMHhmZiB8IChrZXlbIDFdICYgMHhmZikgPDwgODsgdGhpcy5yWzBdID0gKCB0MCAgICAgICAgICAgICAgICAgICAgICkgJiAweDFmZmY7XG4gIHQxID0ga2V5WyAyXSAmIDB4ZmYgfCAoa2V5WyAzXSAmIDB4ZmYpIDw8IDg7IHRoaXMuclsxXSA9ICgodDAgPj4+IDEzKSB8ICh0MSA8PCAgMykpICYgMHgxZmZmO1xuICB0MiA9IGtleVsgNF0gJiAweGZmIHwgKGtleVsgNV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbMl0gPSAoKHQxID4+PiAxMCkgfCAodDIgPDwgIDYpKSAmIDB4MWYwMztcbiAgdDMgPSBrZXlbIDZdICYgMHhmZiB8IChrZXlbIDddICYgMHhmZikgPDwgODsgdGhpcy5yWzNdID0gKCh0MiA+Pj4gIDcpIHwgKHQzIDw8ICA5KSkgJiAweDFmZmY7XG4gIHQ0ID0ga2V5WyA4XSAmIDB4ZmYgfCAoa2V5WyA5XSAmIDB4ZmYpIDw8IDg7IHRoaXMucls0XSA9ICgodDMgPj4+ICA0KSB8ICh0NCA8PCAxMikpICYgMHgwMGZmO1xuICB0aGlzLnJbNV0gPSAoKHQ0ID4+PiAgMSkpICYgMHgxZmZlO1xuICB0NSA9IGtleVsxMF0gJiAweGZmIHwgKGtleVsxMV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbNl0gPSAoKHQ0ID4+PiAxNCkgfCAodDUgPDwgIDIpKSAmIDB4MWZmZjtcbiAgdDYgPSBrZXlbMTJdICYgMHhmZiB8IChrZXlbMTNdICYgMHhmZikgPDwgODsgdGhpcy5yWzddID0gKCh0NSA+Pj4gMTEpIHwgKHQ2IDw8ICA1KSkgJiAweDFmODE7XG4gIHQ3ID0ga2V5WzE0XSAmIDB4ZmYgfCAoa2V5WzE1XSAmIDB4ZmYpIDw8IDg7IHRoaXMucls4XSA9ICgodDYgPj4+ICA4KSB8ICh0NyA8PCAgOCkpICYgMHgxZmZmO1xuICB0aGlzLnJbOV0gPSAoKHQ3ID4+PiAgNSkpICYgMHgwMDdmO1xuXG4gIHRoaXMucGFkWzBdID0ga2V5WzE2XSAmIDB4ZmYgfCAoa2V5WzE3XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzFdID0ga2V5WzE4XSAmIDB4ZmYgfCAoa2V5WzE5XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzJdID0ga2V5WzIwXSAmIDB4ZmYgfCAoa2V5WzIxXSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzNdID0ga2V5WzIyXSAmIDB4ZmYgfCAoa2V5WzIzXSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzRdID0ga2V5WzI0XSAmIDB4ZmYgfCAoa2V5WzI1XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzVdID0ga2V5WzI2XSAmIDB4ZmYgfCAoa2V5WzI3XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzZdID0ga2V5WzI4XSAmIDB4ZmYgfCAoa2V5WzI5XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzddID0ga2V5WzMwXSAmIDB4ZmYgfCAoa2V5WzMxXSAmIDB4ZmYpIDw8IDg7XG59O1xuXG5wb2x5MTMwNS5wcm90b3R5cGUuYmxvY2tzID0gZnVuY3Rpb24obSwgbXBvcywgYnl0ZXMpIHtcbiAgdmFyIGhpYml0ID0gdGhpcy5maW4gPyAwIDogKDEgPDwgMTEpO1xuICB2YXIgdDAsIHQxLCB0MiwgdDMsIHQ0LCB0NSwgdDYsIHQ3LCBjO1xuICB2YXIgZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDk7XG5cbiAgdmFyIGgwID0gdGhpcy5oWzBdLFxuICAgICAgaDEgPSB0aGlzLmhbMV0sXG4gICAgICBoMiA9IHRoaXMuaFsyXSxcbiAgICAgIGgzID0gdGhpcy5oWzNdLFxuICAgICAgaDQgPSB0aGlzLmhbNF0sXG4gICAgICBoNSA9IHRoaXMuaFs1XSxcbiAgICAgIGg2ID0gdGhpcy5oWzZdLFxuICAgICAgaDcgPSB0aGlzLmhbN10sXG4gICAgICBoOCA9IHRoaXMuaFs4XSxcbiAgICAgIGg5ID0gdGhpcy5oWzldO1xuXG4gIHZhciByMCA9IHRoaXMuclswXSxcbiAgICAgIHIxID0gdGhpcy5yWzFdLFxuICAgICAgcjIgPSB0aGlzLnJbMl0sXG4gICAgICByMyA9IHRoaXMuclszXSxcbiAgICAgIHI0ID0gdGhpcy5yWzRdLFxuICAgICAgcjUgPSB0aGlzLnJbNV0sXG4gICAgICByNiA9IHRoaXMucls2XSxcbiAgICAgIHI3ID0gdGhpcy5yWzddLFxuICAgICAgcjggPSB0aGlzLnJbOF0sXG4gICAgICByOSA9IHRoaXMucls5XTtcblxuICB3aGlsZSAoYnl0ZXMgPj0gMTYpIHtcbiAgICB0MCA9IG1bbXBvcysgMF0gJiAweGZmIHwgKG1bbXBvcysgMV0gJiAweGZmKSA8PCA4OyBoMCArPSAoIHQwICAgICAgICAgICAgICAgICAgICAgKSAmIDB4MWZmZjtcbiAgICB0MSA9IG1bbXBvcysgMl0gJiAweGZmIHwgKG1bbXBvcysgM10gJiAweGZmKSA8PCA4OyBoMSArPSAoKHQwID4+PiAxMykgfCAodDEgPDwgIDMpKSAmIDB4MWZmZjtcbiAgICB0MiA9IG1bbXBvcysgNF0gJiAweGZmIHwgKG1bbXBvcysgNV0gJiAweGZmKSA8PCA4OyBoMiArPSAoKHQxID4+PiAxMCkgfCAodDIgPDwgIDYpKSAmIDB4MWZmZjtcbiAgICB0MyA9IG1bbXBvcysgNl0gJiAweGZmIHwgKG1bbXBvcysgN10gJiAweGZmKSA8PCA4OyBoMyArPSAoKHQyID4+PiAgNykgfCAodDMgPDwgIDkpKSAmIDB4MWZmZjtcbiAgICB0NCA9IG1bbXBvcysgOF0gJiAweGZmIHwgKG1bbXBvcysgOV0gJiAweGZmKSA8PCA4OyBoNCArPSAoKHQzID4+PiAgNCkgfCAodDQgPDwgMTIpKSAmIDB4MWZmZjtcbiAgICBoNSArPSAoKHQ0ID4+PiAgMSkpICYgMHgxZmZmO1xuICAgIHQ1ID0gbVttcG9zKzEwXSAmIDB4ZmYgfCAobVttcG9zKzExXSAmIDB4ZmYpIDw8IDg7IGg2ICs9ICgodDQgPj4+IDE0KSB8ICh0NSA8PCAgMikpICYgMHgxZmZmO1xuICAgIHQ2ID0gbVttcG9zKzEyXSAmIDB4ZmYgfCAobVttcG9zKzEzXSAmIDB4ZmYpIDw8IDg7IGg3ICs9ICgodDUgPj4+IDExKSB8ICh0NiA8PCAgNSkpICYgMHgxZmZmO1xuICAgIHQ3ID0gbVttcG9zKzE0XSAmIDB4ZmYgfCAobVttcG9zKzE1XSAmIDB4ZmYpIDw8IDg7IGg4ICs9ICgodDYgPj4+ICA4KSB8ICh0NyA8PCAgOCkpICYgMHgxZmZmO1xuICAgIGg5ICs9ICgodDcgPj4+IDUpKSB8IGhpYml0O1xuXG4gICAgYyA9IDA7XG5cbiAgICBkMCA9IGM7XG4gICAgZDAgKz0gaDAgKiByMDtcbiAgICBkMCArPSBoMSAqICg1ICogcjkpO1xuICAgIGQwICs9IGgyICogKDUgKiByOCk7XG4gICAgZDAgKz0gaDMgKiAoNSAqIHI3KTtcbiAgICBkMCArPSBoNCAqICg1ICogcjYpO1xuICAgIGMgPSAoZDAgPj4+IDEzKTsgZDAgJj0gMHgxZmZmO1xuICAgIGQwICs9IGg1ICogKDUgKiByNSk7XG4gICAgZDAgKz0gaDYgKiAoNSAqIHI0KTtcbiAgICBkMCArPSBoNyAqICg1ICogcjMpO1xuICAgIGQwICs9IGg4ICogKDUgKiByMik7XG4gICAgZDAgKz0gaDkgKiAoNSAqIHIxKTtcbiAgICBjICs9IChkMCA+Pj4gMTMpOyBkMCAmPSAweDFmZmY7XG5cbiAgICBkMSA9IGM7XG4gICAgZDEgKz0gaDAgKiByMTtcbiAgICBkMSArPSBoMSAqIHIwO1xuICAgIGQxICs9IGgyICogKDUgKiByOSk7XG4gICAgZDEgKz0gaDMgKiAoNSAqIHI4KTtcbiAgICBkMSArPSBoNCAqICg1ICogcjcpO1xuICAgIGMgPSAoZDEgPj4+IDEzKTsgZDEgJj0gMHgxZmZmO1xuICAgIGQxICs9IGg1ICogKDUgKiByNik7XG4gICAgZDEgKz0gaDYgKiAoNSAqIHI1KTtcbiAgICBkMSArPSBoNyAqICg1ICogcjQpO1xuICAgIGQxICs9IGg4ICogKDUgKiByMyk7XG4gICAgZDEgKz0gaDkgKiAoNSAqIHIyKTtcbiAgICBjICs9IChkMSA+Pj4gMTMpOyBkMSAmPSAweDFmZmY7XG5cbiAgICBkMiA9IGM7XG4gICAgZDIgKz0gaDAgKiByMjtcbiAgICBkMiArPSBoMSAqIHIxO1xuICAgIGQyICs9IGgyICogcjA7XG4gICAgZDIgKz0gaDMgKiAoNSAqIHI5KTtcbiAgICBkMiArPSBoNCAqICg1ICogcjgpO1xuICAgIGMgPSAoZDIgPj4+IDEzKTsgZDIgJj0gMHgxZmZmO1xuICAgIGQyICs9IGg1ICogKDUgKiByNyk7XG4gICAgZDIgKz0gaDYgKiAoNSAqIHI2KTtcbiAgICBkMiArPSBoNyAqICg1ICogcjUpO1xuICAgIGQyICs9IGg4ICogKDUgKiByNCk7XG4gICAgZDIgKz0gaDkgKiAoNSAqIHIzKTtcbiAgICBjICs9IChkMiA+Pj4gMTMpOyBkMiAmPSAweDFmZmY7XG5cbiAgICBkMyA9IGM7XG4gICAgZDMgKz0gaDAgKiByMztcbiAgICBkMyArPSBoMSAqIHIyO1xuICAgIGQzICs9IGgyICogcjE7XG4gICAgZDMgKz0gaDMgKiByMDtcbiAgICBkMyArPSBoNCAqICg1ICogcjkpO1xuICAgIGMgPSAoZDMgPj4+IDEzKTsgZDMgJj0gMHgxZmZmO1xuICAgIGQzICs9IGg1ICogKDUgKiByOCk7XG4gICAgZDMgKz0gaDYgKiAoNSAqIHI3KTtcbiAgICBkMyArPSBoNyAqICg1ICogcjYpO1xuICAgIGQzICs9IGg4ICogKDUgKiByNSk7XG4gICAgZDMgKz0gaDkgKiAoNSAqIHI0KTtcbiAgICBjICs9IChkMyA+Pj4gMTMpOyBkMyAmPSAweDFmZmY7XG5cbiAgICBkNCA9IGM7XG4gICAgZDQgKz0gaDAgKiByNDtcbiAgICBkNCArPSBoMSAqIHIzO1xuICAgIGQ0ICs9IGgyICogcjI7XG4gICAgZDQgKz0gaDMgKiByMTtcbiAgICBkNCArPSBoNCAqIHIwO1xuICAgIGMgPSAoZDQgPj4+IDEzKTsgZDQgJj0gMHgxZmZmO1xuICAgIGQ0ICs9IGg1ICogKDUgKiByOSk7XG4gICAgZDQgKz0gaDYgKiAoNSAqIHI4KTtcbiAgICBkNCArPSBoNyAqICg1ICogcjcpO1xuICAgIGQ0ICs9IGg4ICogKDUgKiByNik7XG4gICAgZDQgKz0gaDkgKiAoNSAqIHI1KTtcbiAgICBjICs9IChkNCA+Pj4gMTMpOyBkNCAmPSAweDFmZmY7XG5cbiAgICBkNSA9IGM7XG4gICAgZDUgKz0gaDAgKiByNTtcbiAgICBkNSArPSBoMSAqIHI0O1xuICAgIGQ1ICs9IGgyICogcjM7XG4gICAgZDUgKz0gaDMgKiByMjtcbiAgICBkNSArPSBoNCAqIHIxO1xuICAgIGMgPSAoZDUgPj4+IDEzKTsgZDUgJj0gMHgxZmZmO1xuICAgIGQ1ICs9IGg1ICogcjA7XG4gICAgZDUgKz0gaDYgKiAoNSAqIHI5KTtcbiAgICBkNSArPSBoNyAqICg1ICogcjgpO1xuICAgIGQ1ICs9IGg4ICogKDUgKiByNyk7XG4gICAgZDUgKz0gaDkgKiAoNSAqIHI2KTtcbiAgICBjICs9IChkNSA+Pj4gMTMpOyBkNSAmPSAweDFmZmY7XG5cbiAgICBkNiA9IGM7XG4gICAgZDYgKz0gaDAgKiByNjtcbiAgICBkNiArPSBoMSAqIHI1O1xuICAgIGQ2ICs9IGgyICogcjQ7XG4gICAgZDYgKz0gaDMgKiByMztcbiAgICBkNiArPSBoNCAqIHIyO1xuICAgIGMgPSAoZDYgPj4+IDEzKTsgZDYgJj0gMHgxZmZmO1xuICAgIGQ2ICs9IGg1ICogcjE7XG4gICAgZDYgKz0gaDYgKiByMDtcbiAgICBkNiArPSBoNyAqICg1ICogcjkpO1xuICAgIGQ2ICs9IGg4ICogKDUgKiByOCk7XG4gICAgZDYgKz0gaDkgKiAoNSAqIHI3KTtcbiAgICBjICs9IChkNiA+Pj4gMTMpOyBkNiAmPSAweDFmZmY7XG5cbiAgICBkNyA9IGM7XG4gICAgZDcgKz0gaDAgKiByNztcbiAgICBkNyArPSBoMSAqIHI2O1xuICAgIGQ3ICs9IGgyICogcjU7XG4gICAgZDcgKz0gaDMgKiByNDtcbiAgICBkNyArPSBoNCAqIHIzO1xuICAgIGMgPSAoZDcgPj4+IDEzKTsgZDcgJj0gMHgxZmZmO1xuICAgIGQ3ICs9IGg1ICogcjI7XG4gICAgZDcgKz0gaDYgKiByMTtcbiAgICBkNyArPSBoNyAqIHIwO1xuICAgIGQ3ICs9IGg4ICogKDUgKiByOSk7XG4gICAgZDcgKz0gaDkgKiAoNSAqIHI4KTtcbiAgICBjICs9IChkNyA+Pj4gMTMpOyBkNyAmPSAweDFmZmY7XG5cbiAgICBkOCA9IGM7XG4gICAgZDggKz0gaDAgKiByODtcbiAgICBkOCArPSBoMSAqIHI3O1xuICAgIGQ4ICs9IGgyICogcjY7XG4gICAgZDggKz0gaDMgKiByNTtcbiAgICBkOCArPSBoNCAqIHI0O1xuICAgIGMgPSAoZDggPj4+IDEzKTsgZDggJj0gMHgxZmZmO1xuICAgIGQ4ICs9IGg1ICogcjM7XG4gICAgZDggKz0gaDYgKiByMjtcbiAgICBkOCArPSBoNyAqIHIxO1xuICAgIGQ4ICs9IGg4ICogcjA7XG4gICAgZDggKz0gaDkgKiAoNSAqIHI5KTtcbiAgICBjICs9IChkOCA+Pj4gMTMpOyBkOCAmPSAweDFmZmY7XG5cbiAgICBkOSA9IGM7XG4gICAgZDkgKz0gaDAgKiByOTtcbiAgICBkOSArPSBoMSAqIHI4O1xuICAgIGQ5ICs9IGgyICogcjc7XG4gICAgZDkgKz0gaDMgKiByNjtcbiAgICBkOSArPSBoNCAqIHI1O1xuICAgIGMgPSAoZDkgPj4+IDEzKTsgZDkgJj0gMHgxZmZmO1xuICAgIGQ5ICs9IGg1ICogcjQ7XG4gICAgZDkgKz0gaDYgKiByMztcbiAgICBkOSArPSBoNyAqIHIyO1xuICAgIGQ5ICs9IGg4ICogcjE7XG4gICAgZDkgKz0gaDkgKiByMDtcbiAgICBjICs9IChkOSA+Pj4gMTMpOyBkOSAmPSAweDFmZmY7XG5cbiAgICBjID0gKCgoYyA8PCAyKSArIGMpKSB8IDA7XG4gICAgYyA9IChjICsgZDApIHwgMDtcbiAgICBkMCA9IGMgJiAweDFmZmY7XG4gICAgYyA9IChjID4+PiAxMyk7XG4gICAgZDEgKz0gYztcblxuICAgIGgwID0gZDA7XG4gICAgaDEgPSBkMTtcbiAgICBoMiA9IGQyO1xuICAgIGgzID0gZDM7XG4gICAgaDQgPSBkNDtcbiAgICBoNSA9IGQ1O1xuICAgIGg2ID0gZDY7XG4gICAgaDcgPSBkNztcbiAgICBoOCA9IGQ4O1xuICAgIGg5ID0gZDk7XG5cbiAgICBtcG9zICs9IDE2O1xuICAgIGJ5dGVzIC09IDE2O1xuICB9XG4gIHRoaXMuaFswXSA9IGgwO1xuICB0aGlzLmhbMV0gPSBoMTtcbiAgdGhpcy5oWzJdID0gaDI7XG4gIHRoaXMuaFszXSA9IGgzO1xuICB0aGlzLmhbNF0gPSBoNDtcbiAgdGhpcy5oWzVdID0gaDU7XG4gIHRoaXMuaFs2XSA9IGg2O1xuICB0aGlzLmhbN10gPSBoNztcbiAgdGhpcy5oWzhdID0gaDg7XG4gIHRoaXMuaFs5XSA9IGg5O1xufTtcblxucG9seTEzMDUucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKG1hYywgbWFjcG9zKSB7XG4gIHZhciBnID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcbiAgdmFyIGMsIG1hc2ssIGYsIGk7XG5cbiAgaWYgKHRoaXMubGVmdG92ZXIpIHtcbiAgICBpID0gdGhpcy5sZWZ0b3ZlcjtcbiAgICB0aGlzLmJ1ZmZlcltpKytdID0gMTtcbiAgICBmb3IgKDsgaSA8IDE2OyBpKyspIHRoaXMuYnVmZmVyW2ldID0gMDtcbiAgICB0aGlzLmZpbiA9IDE7XG4gICAgdGhpcy5ibG9ja3ModGhpcy5idWZmZXIsIDAsIDE2KTtcbiAgfVxuXG4gIGMgPSB0aGlzLmhbMV0gPj4+IDEzO1xuICB0aGlzLmhbMV0gJj0gMHgxZmZmO1xuICBmb3IgKGkgPSAyOyBpIDwgMTA7IGkrKykge1xuICAgIHRoaXMuaFtpXSArPSBjO1xuICAgIGMgPSB0aGlzLmhbaV0gPj4+IDEzO1xuICAgIHRoaXMuaFtpXSAmPSAweDFmZmY7XG4gIH1cbiAgdGhpcy5oWzBdICs9IChjICogNSk7XG4gIGMgPSB0aGlzLmhbMF0gPj4+IDEzO1xuICB0aGlzLmhbMF0gJj0gMHgxZmZmO1xuICB0aGlzLmhbMV0gKz0gYztcbiAgYyA9IHRoaXMuaFsxXSA+Pj4gMTM7XG4gIHRoaXMuaFsxXSAmPSAweDFmZmY7XG4gIHRoaXMuaFsyXSArPSBjO1xuXG4gIGdbMF0gPSB0aGlzLmhbMF0gKyA1O1xuICBjID0gZ1swXSA+Pj4gMTM7XG4gIGdbMF0gJj0gMHgxZmZmO1xuICBmb3IgKGkgPSAxOyBpIDwgMTA7IGkrKykge1xuICAgIGdbaV0gPSB0aGlzLmhbaV0gKyBjO1xuICAgIGMgPSBnW2ldID4+PiAxMztcbiAgICBnW2ldICY9IDB4MWZmZjtcbiAgfVxuICBnWzldIC09ICgxIDw8IDEzKTtcblxuICBtYXNrID0gKGMgXiAxKSAtIDE7XG4gIGZvciAoaSA9IDA7IGkgPCAxMDsgaSsrKSBnW2ldICY9IG1hc2s7XG4gIG1hc2sgPSB+bWFzaztcbiAgZm9yIChpID0gMDsgaSA8IDEwOyBpKyspIHRoaXMuaFtpXSA9ICh0aGlzLmhbaV0gJiBtYXNrKSB8IGdbaV07XG5cbiAgdGhpcy5oWzBdID0gKCh0aGlzLmhbMF0gICAgICAgKSB8ICh0aGlzLmhbMV0gPDwgMTMpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbMV0gPSAoKHRoaXMuaFsxXSA+Pj4gIDMpIHwgKHRoaXMuaFsyXSA8PCAxMCkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFsyXSA9ICgodGhpcy5oWzJdID4+PiAgNikgfCAodGhpcy5oWzNdIDw8ICA3KSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzNdID0gKCh0aGlzLmhbM10gPj4+ICA5KSB8ICh0aGlzLmhbNF0gPDwgIDQpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbNF0gPSAoKHRoaXMuaFs0XSA+Pj4gMTIpIHwgKHRoaXMuaFs1XSA8PCAgMSkgfCAodGhpcy5oWzZdIDw8IDE0KSkgJiAweGZmZmY7XG4gIHRoaXMuaFs1XSA9ICgodGhpcy5oWzZdID4+PiAgMikgfCAodGhpcy5oWzddIDw8IDExKSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzZdID0gKCh0aGlzLmhbN10gPj4+ICA1KSB8ICh0aGlzLmhbOF0gPDwgIDgpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbN10gPSAoKHRoaXMuaFs4XSA+Pj4gIDgpIHwgKHRoaXMuaFs5XSA8PCAgNSkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG5cbiAgZiA9IHRoaXMuaFswXSArIHRoaXMucGFkWzBdO1xuICB0aGlzLmhbMF0gPSBmICYgMHhmZmZmO1xuICBmb3IgKGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgZiA9ICgoKHRoaXMuaFtpXSArIHRoaXMucGFkW2ldKSB8IDApICsgKGYgPj4+IDE2KSkgfCAwO1xuICAgIHRoaXMuaFtpXSA9IGYgJiAweGZmZmY7XG4gIH1cblxuICBtYWNbbWFjcG9zKyAwXSA9ICh0aGlzLmhbMF0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgMV0gPSAodGhpcy5oWzBdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDJdID0gKHRoaXMuaFsxXSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyAzXSA9ICh0aGlzLmhbMV0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysgNF0gPSAodGhpcy5oWzJdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDVdID0gKHRoaXMuaFsyXSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA2XSA9ICh0aGlzLmhbM10gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgN10gPSAodGhpcy5oWzNdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDhdID0gKHRoaXMuaFs0XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA5XSA9ICh0aGlzLmhbNF0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysxMF0gPSAodGhpcy5oWzVdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTFdID0gKHRoaXMuaFs1XSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzEyXSA9ICh0aGlzLmhbNl0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysxM10gPSAodGhpcy5oWzZdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTRdID0gKHRoaXMuaFs3XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzE1XSA9ICh0aGlzLmhbN10gPj4+IDgpICYgMHhmZjtcbn07XG5cbnBvbHkxMzA1LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihtLCBtcG9zLCBieXRlcykge1xuICB2YXIgaSwgd2FudDtcblxuICBpZiAodGhpcy5sZWZ0b3Zlcikge1xuICAgIHdhbnQgPSAoMTYgLSB0aGlzLmxlZnRvdmVyKTtcbiAgICBpZiAod2FudCA+IGJ5dGVzKVxuICAgICAgd2FudCA9IGJ5dGVzO1xuICAgIGZvciAoaSA9IDA7IGkgPCB3YW50OyBpKyspXG4gICAgICB0aGlzLmJ1ZmZlclt0aGlzLmxlZnRvdmVyICsgaV0gPSBtW21wb3MraV07XG4gICAgYnl0ZXMgLT0gd2FudDtcbiAgICBtcG9zICs9IHdhbnQ7XG4gICAgdGhpcy5sZWZ0b3ZlciArPSB3YW50O1xuICAgIGlmICh0aGlzLmxlZnRvdmVyIDwgMTYpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5ibG9ja3ModGhpcy5idWZmZXIsIDAsIDE2KTtcbiAgICB0aGlzLmxlZnRvdmVyID0gMDtcbiAgfVxuXG4gIGlmIChieXRlcyA+PSAxNikge1xuICAgIHdhbnQgPSBieXRlcyAtIChieXRlcyAlIDE2KTtcbiAgICB0aGlzLmJsb2NrcyhtLCBtcG9zLCB3YW50KTtcbiAgICBtcG9zICs9IHdhbnQ7XG4gICAgYnl0ZXMgLT0gd2FudDtcbiAgfVxuXG4gIGlmIChieXRlcykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBieXRlczsgaSsrKVxuICAgICAgdGhpcy5idWZmZXJbdGhpcy5sZWZ0b3ZlciArIGldID0gbVttcG9zK2ldO1xuICAgIHRoaXMubGVmdG92ZXIgKz0gYnl0ZXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyeXB0b19vbmV0aW1lYXV0aChvdXQsIG91dHBvcywgbSwgbXBvcywgbiwgaykge1xuICB2YXIgcyA9IG5ldyBwb2x5MTMwNShrKTtcbiAgcy51cGRhdGUobSwgbXBvcywgbik7XG4gIHMuZmluaXNoKG91dCwgb3V0cG9zKTtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnkoaCwgaHBvcywgbSwgbXBvcywgbiwgaykge1xuICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgY3J5cHRvX29uZXRpbWVhdXRoKHgsMCxtLG1wb3MsbixrKTtcbiAgcmV0dXJuIGNyeXB0b192ZXJpZnlfMTYoaCxocG9zLHgsMCk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zZWNyZXRib3goYyxtLGQsbixrKSB7XG4gIHZhciBpO1xuICBpZiAoZCA8IDMyKSByZXR1cm4gLTE7XG4gIGNyeXB0b19zdHJlYW1feG9yKGMsMCxtLDAsZCxuLGspO1xuICBjcnlwdG9fb25ldGltZWF1dGgoYywgMTYsIGMsIDMyLCBkIC0gMzIsIGMpO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgY1tpXSA9IDA7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2VjcmV0Ym94X29wZW4obSxjLGQsbixrKSB7XG4gIHZhciBpO1xuICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgaWYgKGQgPCAzMikgcmV0dXJuIC0xO1xuICBjcnlwdG9fc3RyZWFtKHgsMCwzMixuLGspO1xuICBpZiAoY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeShjLCAxNixjLCAzMixkIC0gMzIseCkgIT09IDApIHJldHVybiAtMTtcbiAgY3J5cHRvX3N0cmVhbV94b3IobSwwLGMsMCxkLG4sayk7XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBtW2ldID0gMDtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIHNldDI1NTE5KHIsIGEpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSByW2ldID0gYVtpXXwwO1xufVxuXG5mdW5jdGlvbiBjYXIyNTUxOShvKSB7XG4gIHZhciBpLCB2LCBjID0gMTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB2ID0gb1tpXSArIGMgKyA2NTUzNTtcbiAgICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpO1xuICAgIG9baV0gPSB2IC0gYyAqIDY1NTM2O1xuICB9XG4gIG9bMF0gKz0gYy0xICsgMzcgKiAoYy0xKTtcbn1cblxuZnVuY3Rpb24gc2VsMjU1MTkocCwgcSwgYikge1xuICB2YXIgdCwgYyA9IH4oYi0xKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgdCA9IGMgJiAocFtpXSBeIHFbaV0pO1xuICAgIHBbaV0gXj0gdDtcbiAgICBxW2ldIF49IHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFjazI1NTE5KG8sIG4pIHtcbiAgdmFyIGksIGosIGI7XG4gIHZhciBtID0gZ2YoKSwgdCA9IGdmKCk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB0W2ldID0gbltpXTtcbiAgY2FyMjU1MTkodCk7XG4gIGNhcjI1NTE5KHQpO1xuICBjYXIyNTUxOSh0KTtcbiAgZm9yIChqID0gMDsgaiA8IDI7IGorKykge1xuICAgIG1bMF0gPSB0WzBdIC0gMHhmZmVkO1xuICAgIGZvciAoaSA9IDE7IGkgPCAxNTsgaSsrKSB7XG4gICAgICBtW2ldID0gdFtpXSAtIDB4ZmZmZiAtICgobVtpLTFdPj4xNikgJiAxKTtcbiAgICAgIG1baS0xXSAmPSAweGZmZmY7XG4gICAgfVxuICAgIG1bMTVdID0gdFsxNV0gLSAweDdmZmYgLSAoKG1bMTRdPj4xNikgJiAxKTtcbiAgICBiID0gKG1bMTVdPj4xNikgJiAxO1xuICAgIG1bMTRdICY9IDB4ZmZmZjtcbiAgICBzZWwyNTUxOSh0LCBtLCAxLWIpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgb1syKmldID0gdFtpXSAmIDB4ZmY7XG4gICAgb1syKmkrMV0gPSB0W2ldPj44O1xuICB9XG59XG5cbmZ1bmN0aW9uIG5lcTI1NTE5KGEsIGIpIHtcbiAgdmFyIGMgPSBuZXcgVWludDhBcnJheSgzMiksIGQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIHBhY2syNTUxOShjLCBhKTtcbiAgcGFjazI1NTE5KGQsIGIpO1xuICByZXR1cm4gY3J5cHRvX3ZlcmlmeV8zMihjLCAwLCBkLCAwKTtcbn1cblxuZnVuY3Rpb24gcGFyMjU1MTkoYSkge1xuICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgcGFjazI1NTE5KGQsIGEpO1xuICByZXR1cm4gZFswXSAmIDE7XG59XG5cbmZ1bmN0aW9uIHVucGFjazI1NTE5KG8sIG4pIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSBvW2ldID0gblsyKmldICsgKG5bMippKzFdIDw8IDgpO1xuICBvWzE1XSAmPSAweDdmZmY7XG59XG5cbmZ1bmN0aW9uIEEobywgYSwgYikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIG9baV0gPSBhW2ldICsgYltpXTtcbn1cblxuZnVuY3Rpb24gWihvLCBhLCBiKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykgb1tpXSA9IGFbaV0gLSBiW2ldO1xufVxuXG5mdW5jdGlvbiBNKG8sIGEsIGIpIHtcbiAgdmFyIHYsIGMsXG4gICAgIHQwID0gMCwgIHQxID0gMCwgIHQyID0gMCwgIHQzID0gMCwgIHQ0ID0gMCwgIHQ1ID0gMCwgIHQ2ID0gMCwgIHQ3ID0gMCxcbiAgICAgdDggPSAwLCAgdDkgPSAwLCB0MTAgPSAwLCB0MTEgPSAwLCB0MTIgPSAwLCB0MTMgPSAwLCB0MTQgPSAwLCB0MTUgPSAwLFxuICAgIHQxNiA9IDAsIHQxNyA9IDAsIHQxOCA9IDAsIHQxOSA9IDAsIHQyMCA9IDAsIHQyMSA9IDAsIHQyMiA9IDAsIHQyMyA9IDAsXG4gICAgdDI0ID0gMCwgdDI1ID0gMCwgdDI2ID0gMCwgdDI3ID0gMCwgdDI4ID0gMCwgdDI5ID0gMCwgdDMwID0gMCxcbiAgICBiMCA9IGJbMF0sXG4gICAgYjEgPSBiWzFdLFxuICAgIGIyID0gYlsyXSxcbiAgICBiMyA9IGJbM10sXG4gICAgYjQgPSBiWzRdLFxuICAgIGI1ID0gYls1XSxcbiAgICBiNiA9IGJbNl0sXG4gICAgYjcgPSBiWzddLFxuICAgIGI4ID0gYls4XSxcbiAgICBiOSA9IGJbOV0sXG4gICAgYjEwID0gYlsxMF0sXG4gICAgYjExID0gYlsxMV0sXG4gICAgYjEyID0gYlsxMl0sXG4gICAgYjEzID0gYlsxM10sXG4gICAgYjE0ID0gYlsxNF0sXG4gICAgYjE1ID0gYlsxNV07XG5cbiAgdiA9IGFbMF07XG4gIHQwICs9IHYgKiBiMDtcbiAgdDEgKz0gdiAqIGIxO1xuICB0MiArPSB2ICogYjI7XG4gIHQzICs9IHYgKiBiMztcbiAgdDQgKz0gdiAqIGI0O1xuICB0NSArPSB2ICogYjU7XG4gIHQ2ICs9IHYgKiBiNjtcbiAgdDcgKz0gdiAqIGI3O1xuICB0OCArPSB2ICogYjg7XG4gIHQ5ICs9IHYgKiBiOTtcbiAgdDEwICs9IHYgKiBiMTA7XG4gIHQxMSArPSB2ICogYjExO1xuICB0MTIgKz0gdiAqIGIxMjtcbiAgdDEzICs9IHYgKiBiMTM7XG4gIHQxNCArPSB2ICogYjE0O1xuICB0MTUgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMV07XG4gIHQxICs9IHYgKiBiMDtcbiAgdDIgKz0gdiAqIGIxO1xuICB0MyArPSB2ICogYjI7XG4gIHQ0ICs9IHYgKiBiMztcbiAgdDUgKz0gdiAqIGI0O1xuICB0NiArPSB2ICogYjU7XG4gIHQ3ICs9IHYgKiBiNjtcbiAgdDggKz0gdiAqIGI3O1xuICB0OSArPSB2ICogYjg7XG4gIHQxMCArPSB2ICogYjk7XG4gIHQxMSArPSB2ICogYjEwO1xuICB0MTIgKz0gdiAqIGIxMTtcbiAgdDEzICs9IHYgKiBiMTI7XG4gIHQxNCArPSB2ICogYjEzO1xuICB0MTUgKz0gdiAqIGIxNDtcbiAgdDE2ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzJdO1xuICB0MiArPSB2ICogYjA7XG4gIHQzICs9IHYgKiBiMTtcbiAgdDQgKz0gdiAqIGIyO1xuICB0NSArPSB2ICogYjM7XG4gIHQ2ICs9IHYgKiBiNDtcbiAgdDcgKz0gdiAqIGI1O1xuICB0OCArPSB2ICogYjY7XG4gIHQ5ICs9IHYgKiBiNztcbiAgdDEwICs9IHYgKiBiODtcbiAgdDExICs9IHYgKiBiOTtcbiAgdDEyICs9IHYgKiBiMTA7XG4gIHQxMyArPSB2ICogYjExO1xuICB0MTQgKz0gdiAqIGIxMjtcbiAgdDE1ICs9IHYgKiBiMTM7XG4gIHQxNiArPSB2ICogYjE0O1xuICB0MTcgKz0gdiAqIGIxNTtcbiAgdiA9IGFbM107XG4gIHQzICs9IHYgKiBiMDtcbiAgdDQgKz0gdiAqIGIxO1xuICB0NSArPSB2ICogYjI7XG4gIHQ2ICs9IHYgKiBiMztcbiAgdDcgKz0gdiAqIGI0O1xuICB0OCArPSB2ICogYjU7XG4gIHQ5ICs9IHYgKiBiNjtcbiAgdDEwICs9IHYgKiBiNztcbiAgdDExICs9IHYgKiBiODtcbiAgdDEyICs9IHYgKiBiOTtcbiAgdDEzICs9IHYgKiBiMTA7XG4gIHQxNCArPSB2ICogYjExO1xuICB0MTUgKz0gdiAqIGIxMjtcbiAgdDE2ICs9IHYgKiBiMTM7XG4gIHQxNyArPSB2ICogYjE0O1xuICB0MTggKz0gdiAqIGIxNTtcbiAgdiA9IGFbNF07XG4gIHQ0ICs9IHYgKiBiMDtcbiAgdDUgKz0gdiAqIGIxO1xuICB0NiArPSB2ICogYjI7XG4gIHQ3ICs9IHYgKiBiMztcbiAgdDggKz0gdiAqIGI0O1xuICB0OSArPSB2ICogYjU7XG4gIHQxMCArPSB2ICogYjY7XG4gIHQxMSArPSB2ICogYjc7XG4gIHQxMiArPSB2ICogYjg7XG4gIHQxMyArPSB2ICogYjk7XG4gIHQxNCArPSB2ICogYjEwO1xuICB0MTUgKz0gdiAqIGIxMTtcbiAgdDE2ICs9IHYgKiBiMTI7XG4gIHQxNyArPSB2ICogYjEzO1xuICB0MTggKz0gdiAqIGIxNDtcbiAgdDE5ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzVdO1xuICB0NSArPSB2ICogYjA7XG4gIHQ2ICs9IHYgKiBiMTtcbiAgdDcgKz0gdiAqIGIyO1xuICB0OCArPSB2ICogYjM7XG4gIHQ5ICs9IHYgKiBiNDtcbiAgdDEwICs9IHYgKiBiNTtcbiAgdDExICs9IHYgKiBiNjtcbiAgdDEyICs9IHYgKiBiNztcbiAgdDEzICs9IHYgKiBiODtcbiAgdDE0ICs9IHYgKiBiOTtcbiAgdDE1ICs9IHYgKiBiMTA7XG4gIHQxNiArPSB2ICogYjExO1xuICB0MTcgKz0gdiAqIGIxMjtcbiAgdDE4ICs9IHYgKiBiMTM7XG4gIHQxOSArPSB2ICogYjE0O1xuICB0MjAgKz0gdiAqIGIxNTtcbiAgdiA9IGFbNl07XG4gIHQ2ICs9IHYgKiBiMDtcbiAgdDcgKz0gdiAqIGIxO1xuICB0OCArPSB2ICogYjI7XG4gIHQ5ICs9IHYgKiBiMztcbiAgdDEwICs9IHYgKiBiNDtcbiAgdDExICs9IHYgKiBiNTtcbiAgdDEyICs9IHYgKiBiNjtcbiAgdDEzICs9IHYgKiBiNztcbiAgdDE0ICs9IHYgKiBiODtcbiAgdDE1ICs9IHYgKiBiOTtcbiAgdDE2ICs9IHYgKiBiMTA7XG4gIHQxNyArPSB2ICogYjExO1xuICB0MTggKz0gdiAqIGIxMjtcbiAgdDE5ICs9IHYgKiBiMTM7XG4gIHQyMCArPSB2ICogYjE0O1xuICB0MjEgKz0gdiAqIGIxNTtcbiAgdiA9IGFbN107XG4gIHQ3ICs9IHYgKiBiMDtcbiAgdDggKz0gdiAqIGIxO1xuICB0OSArPSB2ICogYjI7XG4gIHQxMCArPSB2ICogYjM7XG4gIHQxMSArPSB2ICogYjQ7XG4gIHQxMiArPSB2ICogYjU7XG4gIHQxMyArPSB2ICogYjY7XG4gIHQxNCArPSB2ICogYjc7XG4gIHQxNSArPSB2ICogYjg7XG4gIHQxNiArPSB2ICogYjk7XG4gIHQxNyArPSB2ICogYjEwO1xuICB0MTggKz0gdiAqIGIxMTtcbiAgdDE5ICs9IHYgKiBiMTI7XG4gIHQyMCArPSB2ICogYjEzO1xuICB0MjEgKz0gdiAqIGIxNDtcbiAgdDIyICs9IHYgKiBiMTU7XG4gIHYgPSBhWzhdO1xuICB0OCArPSB2ICogYjA7XG4gIHQ5ICs9IHYgKiBiMTtcbiAgdDEwICs9IHYgKiBiMjtcbiAgdDExICs9IHYgKiBiMztcbiAgdDEyICs9IHYgKiBiNDtcbiAgdDEzICs9IHYgKiBiNTtcbiAgdDE0ICs9IHYgKiBiNjtcbiAgdDE1ICs9IHYgKiBiNztcbiAgdDE2ICs9IHYgKiBiODtcbiAgdDE3ICs9IHYgKiBiOTtcbiAgdDE4ICs9IHYgKiBiMTA7XG4gIHQxOSArPSB2ICogYjExO1xuICB0MjAgKz0gdiAqIGIxMjtcbiAgdDIxICs9IHYgKiBiMTM7XG4gIHQyMiArPSB2ICogYjE0O1xuICB0MjMgKz0gdiAqIGIxNTtcbiAgdiA9IGFbOV07XG4gIHQ5ICs9IHYgKiBiMDtcbiAgdDEwICs9IHYgKiBiMTtcbiAgdDExICs9IHYgKiBiMjtcbiAgdDEyICs9IHYgKiBiMztcbiAgdDEzICs9IHYgKiBiNDtcbiAgdDE0ICs9IHYgKiBiNTtcbiAgdDE1ICs9IHYgKiBiNjtcbiAgdDE2ICs9IHYgKiBiNztcbiAgdDE3ICs9IHYgKiBiODtcbiAgdDE4ICs9IHYgKiBiOTtcbiAgdDE5ICs9IHYgKiBiMTA7XG4gIHQyMCArPSB2ICogYjExO1xuICB0MjEgKz0gdiAqIGIxMjtcbiAgdDIyICs9IHYgKiBiMTM7XG4gIHQyMyArPSB2ICogYjE0O1xuICB0MjQgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTBdO1xuICB0MTAgKz0gdiAqIGIwO1xuICB0MTEgKz0gdiAqIGIxO1xuICB0MTIgKz0gdiAqIGIyO1xuICB0MTMgKz0gdiAqIGIzO1xuICB0MTQgKz0gdiAqIGI0O1xuICB0MTUgKz0gdiAqIGI1O1xuICB0MTYgKz0gdiAqIGI2O1xuICB0MTcgKz0gdiAqIGI3O1xuICB0MTggKz0gdiAqIGI4O1xuICB0MTkgKz0gdiAqIGI5O1xuICB0MjAgKz0gdiAqIGIxMDtcbiAgdDIxICs9IHYgKiBiMTE7XG4gIHQyMiArPSB2ICogYjEyO1xuICB0MjMgKz0gdiAqIGIxMztcbiAgdDI0ICs9IHYgKiBiMTQ7XG4gIHQyNSArPSB2ICogYjE1O1xuICB2ID0gYVsxMV07XG4gIHQxMSArPSB2ICogYjA7XG4gIHQxMiArPSB2ICogYjE7XG4gIHQxMyArPSB2ICogYjI7XG4gIHQxNCArPSB2ICogYjM7XG4gIHQxNSArPSB2ICogYjQ7XG4gIHQxNiArPSB2ICogYjU7XG4gIHQxNyArPSB2ICogYjY7XG4gIHQxOCArPSB2ICogYjc7XG4gIHQxOSArPSB2ICogYjg7XG4gIHQyMCArPSB2ICogYjk7XG4gIHQyMSArPSB2ICogYjEwO1xuICB0MjIgKz0gdiAqIGIxMTtcbiAgdDIzICs9IHYgKiBiMTI7XG4gIHQyNCArPSB2ICogYjEzO1xuICB0MjUgKz0gdiAqIGIxNDtcbiAgdDI2ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzEyXTtcbiAgdDEyICs9IHYgKiBiMDtcbiAgdDEzICs9IHYgKiBiMTtcbiAgdDE0ICs9IHYgKiBiMjtcbiAgdDE1ICs9IHYgKiBiMztcbiAgdDE2ICs9IHYgKiBiNDtcbiAgdDE3ICs9IHYgKiBiNTtcbiAgdDE4ICs9IHYgKiBiNjtcbiAgdDE5ICs9IHYgKiBiNztcbiAgdDIwICs9IHYgKiBiODtcbiAgdDIxICs9IHYgKiBiOTtcbiAgdDIyICs9IHYgKiBiMTA7XG4gIHQyMyArPSB2ICogYjExO1xuICB0MjQgKz0gdiAqIGIxMjtcbiAgdDI1ICs9IHYgKiBiMTM7XG4gIHQyNiArPSB2ICogYjE0O1xuICB0MjcgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTNdO1xuICB0MTMgKz0gdiAqIGIwO1xuICB0MTQgKz0gdiAqIGIxO1xuICB0MTUgKz0gdiAqIGIyO1xuICB0MTYgKz0gdiAqIGIzO1xuICB0MTcgKz0gdiAqIGI0O1xuICB0MTggKz0gdiAqIGI1O1xuICB0MTkgKz0gdiAqIGI2O1xuICB0MjAgKz0gdiAqIGI3O1xuICB0MjEgKz0gdiAqIGI4O1xuICB0MjIgKz0gdiAqIGI5O1xuICB0MjMgKz0gdiAqIGIxMDtcbiAgdDI0ICs9IHYgKiBiMTE7XG4gIHQyNSArPSB2ICogYjEyO1xuICB0MjYgKz0gdiAqIGIxMztcbiAgdDI3ICs9IHYgKiBiMTQ7XG4gIHQyOCArPSB2ICogYjE1O1xuICB2ID0gYVsxNF07XG4gIHQxNCArPSB2ICogYjA7XG4gIHQxNSArPSB2ICogYjE7XG4gIHQxNiArPSB2ICogYjI7XG4gIHQxNyArPSB2ICogYjM7XG4gIHQxOCArPSB2ICogYjQ7XG4gIHQxOSArPSB2ICogYjU7XG4gIHQyMCArPSB2ICogYjY7XG4gIHQyMSArPSB2ICogYjc7XG4gIHQyMiArPSB2ICogYjg7XG4gIHQyMyArPSB2ICogYjk7XG4gIHQyNCArPSB2ICogYjEwO1xuICB0MjUgKz0gdiAqIGIxMTtcbiAgdDI2ICs9IHYgKiBiMTI7XG4gIHQyNyArPSB2ICogYjEzO1xuICB0MjggKz0gdiAqIGIxNDtcbiAgdDI5ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzE1XTtcbiAgdDE1ICs9IHYgKiBiMDtcbiAgdDE2ICs9IHYgKiBiMTtcbiAgdDE3ICs9IHYgKiBiMjtcbiAgdDE4ICs9IHYgKiBiMztcbiAgdDE5ICs9IHYgKiBiNDtcbiAgdDIwICs9IHYgKiBiNTtcbiAgdDIxICs9IHYgKiBiNjtcbiAgdDIyICs9IHYgKiBiNztcbiAgdDIzICs9IHYgKiBiODtcbiAgdDI0ICs9IHYgKiBiOTtcbiAgdDI1ICs9IHYgKiBiMTA7XG4gIHQyNiArPSB2ICogYjExO1xuICB0MjcgKz0gdiAqIGIxMjtcbiAgdDI4ICs9IHYgKiBiMTM7XG4gIHQyOSArPSB2ICogYjE0O1xuICB0MzAgKz0gdiAqIGIxNTtcblxuICB0MCAgKz0gMzggKiB0MTY7XG4gIHQxICArPSAzOCAqIHQxNztcbiAgdDIgICs9IDM4ICogdDE4O1xuICB0MyAgKz0gMzggKiB0MTk7XG4gIHQ0ICArPSAzOCAqIHQyMDtcbiAgdDUgICs9IDM4ICogdDIxO1xuICB0NiAgKz0gMzggKiB0MjI7XG4gIHQ3ICArPSAzOCAqIHQyMztcbiAgdDggICs9IDM4ICogdDI0O1xuICB0OSAgKz0gMzggKiB0MjU7XG4gIHQxMCArPSAzOCAqIHQyNjtcbiAgdDExICs9IDM4ICogdDI3O1xuICB0MTIgKz0gMzggKiB0Mjg7XG4gIHQxMyArPSAzOCAqIHQyOTtcbiAgdDE0ICs9IDM4ICogdDMwO1xuICAvLyB0MTUgbGVmdCBhcyBpc1xuXG4gIC8vIGZpcnN0IGNhclxuICBjID0gMTtcbiAgdiA9ICB0MCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQxID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ2ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ3ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ4ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ5ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDExID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdDAgKz0gYy0xICsgMzcgKiAoYy0xKTtcblxuICAvLyBzZWNvbmQgY2FyXG4gIGMgPSAxO1xuICB2ID0gIHQwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQxICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDUgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ2ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDYgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ3ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDcgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ4ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDggPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ5ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDkgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDExICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTUgPSB2IC0gYyAqIDY1NTM2O1xuICB0MCArPSBjLTEgKyAzNyAqIChjLTEpO1xuXG4gIG9bIDBdID0gdDA7XG4gIG9bIDFdID0gdDE7XG4gIG9bIDJdID0gdDI7XG4gIG9bIDNdID0gdDM7XG4gIG9bIDRdID0gdDQ7XG4gIG9bIDVdID0gdDU7XG4gIG9bIDZdID0gdDY7XG4gIG9bIDddID0gdDc7XG4gIG9bIDhdID0gdDg7XG4gIG9bIDldID0gdDk7XG4gIG9bMTBdID0gdDEwO1xuICBvWzExXSA9IHQxMTtcbiAgb1sxMl0gPSB0MTI7XG4gIG9bMTNdID0gdDEzO1xuICBvWzE0XSA9IHQxNDtcbiAgb1sxNV0gPSB0MTU7XG59XG5cbmZ1bmN0aW9uIFMobywgYSkge1xuICBNKG8sIGEsIGEpO1xufVxuXG5mdW5jdGlvbiBpbnYyNTUxOShvLCBpKSB7XG4gIHZhciBjID0gZ2YoKTtcbiAgdmFyIGE7XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBjW2FdID0gaVthXTtcbiAgZm9yIChhID0gMjUzOyBhID49IDA7IGEtLSkge1xuICAgIFMoYywgYyk7XG4gICAgaWYoYSAhPT0gMiAmJiBhICE9PSA0KSBNKGMsIGMsIGkpO1xuICB9XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBvW2FdID0gY1thXTtcbn1cblxuZnVuY3Rpb24gcG93MjUyMyhvLCBpKSB7XG4gIHZhciBjID0gZ2YoKTtcbiAgdmFyIGE7XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBjW2FdID0gaVthXTtcbiAgZm9yIChhID0gMjUwOyBhID49IDA7IGEtLSkge1xuICAgICAgUyhjLCBjKTtcbiAgICAgIGlmKGEgIT09IDEpIE0oYywgYywgaSk7XG4gIH1cbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIG9bYV0gPSBjW2FdO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2NhbGFybXVsdChxLCBuLCBwKSB7XG4gIHZhciB6ID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICB2YXIgeCA9IG5ldyBGbG9hdDY0QXJyYXkoODApLCByLCBpO1xuICB2YXIgYSA9IGdmKCksIGIgPSBnZigpLCBjID0gZ2YoKSxcbiAgICAgIGQgPSBnZigpLCBlID0gZ2YoKSwgZiA9IGdmKCk7XG4gIGZvciAoaSA9IDA7IGkgPCAzMTsgaSsrKSB6W2ldID0gbltpXTtcbiAgelszMV09KG5bMzFdJjEyNyl8NjQ7XG4gIHpbMF0mPTI0ODtcbiAgdW5wYWNrMjU1MTkoeCxwKTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBiW2ldPXhbaV07XG4gICAgZFtpXT1hW2ldPWNbaV09MDtcbiAgfVxuICBhWzBdPWRbMF09MTtcbiAgZm9yIChpPTI1NDsgaT49MDsgLS1pKSB7XG4gICAgcj0oeltpPj4+M10+Pj4oaSY3KSkmMTtcbiAgICBzZWwyNTUxOShhLGIscik7XG4gICAgc2VsMjU1MTkoYyxkLHIpO1xuICAgIEEoZSxhLGMpO1xuICAgIFooYSxhLGMpO1xuICAgIEEoYyxiLGQpO1xuICAgIFooYixiLGQpO1xuICAgIFMoZCxlKTtcbiAgICBTKGYsYSk7XG4gICAgTShhLGMsYSk7XG4gICAgTShjLGIsZSk7XG4gICAgQShlLGEsYyk7XG4gICAgWihhLGEsYyk7XG4gICAgUyhiLGEpO1xuICAgIFooYyxkLGYpO1xuICAgIE0oYSxjLF8xMjE2NjUpO1xuICAgIEEoYSxhLGQpO1xuICAgIE0oYyxjLGEpO1xuICAgIE0oYSxkLGYpO1xuICAgIE0oZCxiLHgpO1xuICAgIFMoYixlKTtcbiAgICBzZWwyNTUxOShhLGIscik7XG4gICAgc2VsMjU1MTkoYyxkLHIpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgeFtpKzE2XT1hW2ldO1xuICAgIHhbaSszMl09Y1tpXTtcbiAgICB4W2krNDhdPWJbaV07XG4gICAgeFtpKzY0XT1kW2ldO1xuICB9XG4gIHZhciB4MzIgPSB4LnN1YmFycmF5KDMyKTtcbiAgdmFyIHgxNiA9IHguc3ViYXJyYXkoMTYpO1xuICBpbnYyNTUxOSh4MzIseDMyKTtcbiAgTSh4MTYseDE2LHgzMik7XG4gIHBhY2syNTUxOShxLHgxNik7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHEsIG4pIHtcbiAgcmV0dXJuIGNyeXB0b19zY2FsYXJtdWx0KHEsIG4sIF85KTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2JveF9rZXlwYWlyKHksIHgpIHtcbiAgcmFuZG9tYnl0ZXMoeCwgMzIpO1xuICByZXR1cm4gY3J5cHRvX3NjYWxhcm11bHRfYmFzZSh5LCB4KTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2JveF9iZWZvcmVubShrLCB5LCB4KSB7XG4gIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fc2NhbGFybXVsdChzLCB4LCB5KTtcbiAgcmV0dXJuIGNyeXB0b19jb3JlX2hzYWxzYTIwKGssIF8wLCBzLCBzaWdtYSk7XG59XG5cbnZhciBjcnlwdG9fYm94X2FmdGVybm0gPSBjcnlwdG9fc2VjcmV0Ym94O1xudmFyIGNyeXB0b19ib3hfb3Blbl9hZnRlcm5tID0gY3J5cHRvX3NlY3JldGJveF9vcGVuO1xuXG5mdW5jdGlvbiBjcnlwdG9fYm94KGMsIG0sIGQsIG4sIHksIHgpIHtcbiAgdmFyIGsgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19ib3hfYmVmb3Jlbm0oaywgeSwgeCk7XG4gIHJldHVybiBjcnlwdG9fYm94X2FmdGVybm0oYywgbSwgZCwgbiwgayk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19ib3hfb3BlbihtLCBjLCBkLCBuLCB5LCB4KSB7XG4gIHZhciBrID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fYm94X2JlZm9yZW5tKGssIHksIHgpO1xuICByZXR1cm4gY3J5cHRvX2JveF9vcGVuX2FmdGVybm0obSwgYywgZCwgbiwgayk7XG59XG5cbnZhciBLID0gW1xuICAweDQyOGEyZjk4LCAweGQ3MjhhZTIyLCAweDcxMzc0NDkxLCAweDIzZWY2NWNkLFxuICAweGI1YzBmYmNmLCAweGVjNGQzYjJmLCAweGU5YjVkYmE1LCAweDgxODlkYmJjLFxuICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuICAweDkyM2Y4MmE0LCAweGFmMTk0ZjliLCAweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4LFxuICAweGQ4MDdhYTk4LCAweGEzMDMwMjQyLCAweDEyODM1YjAxLCAweDQ1NzA2ZmJlLFxuICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuICAweDcyYmU1ZDc0LCAweGYyN2I4OTZmLCAweDgwZGViMWZlLCAweDNiMTY5NmIxLFxuICAweDliZGMwNmE3LCAweDI1YzcxMjM1LCAweGMxOWJmMTc0LCAweGNmNjkyNjk0LFxuICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuICAweDBmYzE5ZGM2LCAweDhiOGNkNWI1LCAweDI0MGNhMWNjLCAweDc3YWM5YzY1LFxuICAweDJkZTkyYzZmLCAweDU5MmIwMjc1LCAweDRhNzQ4NGFhLCAweDZlYTZlNDgzLFxuICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuICAweDk4M2U1MTUyLCAweGVlNjZkZmFiLCAweGE4MzFjNjZkLCAweDJkYjQzMjEwLFxuICAweGIwMDMyN2M4LCAweDk4ZmIyMTNmLCAweGJmNTk3ZmM3LCAweGJlZWYwZWU0LFxuICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuICAweDA2Y2E2MzUxLCAweGUwMDM4MjZmLCAweDE0MjkyOTY3LCAweDBhMGU2ZTcwLFxuICAweDI3YjcwYTg1LCAweDQ2ZDIyZmZjLCAweDJlMWIyMTM4LCAweDVjMjZjOTI2LFxuICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuICAweDY1MGE3MzU0LCAweDhiYWY2M2RlLCAweDc2NmEwYWJiLCAweDNjNzdiMmE4LFxuICAweDgxYzJjOTJlLCAweDQ3ZWRhZWU2LCAweDkyNzIyYzg1LCAweDE0ODIzNTNiLFxuICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuICAweGMyNGI4YjcwLCAweGQwZjg5NzkxLCAweGM3NmM1MWEzLCAweDA2NTRiZTMwLFxuICAweGQxOTJlODE5LCAweGQ2ZWY1MjE4LCAweGQ2OTkwNjI0LCAweDU1NjVhOTEwLFxuICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuICAweDE5YTRjMTE2LCAweGI4ZDJkMGM4LCAweDFlMzc2YzA4LCAweDUxNDFhYjUzLFxuICAweDI3NDg3NzRjLCAweGRmOGVlYjk5LCAweDM0YjBiY2I1LCAweGUxOWI0OGE4LFxuICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuICAweDViOWNjYTRmLCAweDc3NjNlMzczLCAweDY4MmU2ZmYzLCAweGQ2YjJiOGEzLFxuICAweDc0OGY4MmVlLCAweDVkZWZiMmZjLCAweDc4YTU2MzZmLCAweDQzMTcyZjYwLFxuICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuICAweDkwYmVmZmZhLCAweDIzNjMxZTI4LCAweGE0NTA2Y2ViLCAweGRlODJiZGU5LFxuICAweGJlZjlhM2Y3LCAweGIyYzY3OTE1LCAweGM2NzE3OGYyLCAweGUzNzI1MzJiLFxuICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuICAweGVhZGE3ZGQ2LCAweGNkZTBlYjFlLCAweGY1N2Q0ZjdmLCAweGVlNmVkMTc4LFxuICAweDA2ZjA2N2FhLCAweDcyMTc2ZmJhLCAweDBhNjM3ZGM1LCAweGEyYzg5OGE2LFxuICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuICAweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0LCAweDMyY2FhYjdiLCAweDQwYzcyNDkzLFxuICAweDNjOWViZTBhLCAweDE1YzliZWJjLCAweDQzMWQ2N2M0LCAweDljMTAwZDRjLFxuICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuICAweDVmY2I2ZmFiLCAweDNhZDZmYWVjLCAweDZjNDQxOThjLCAweDRhNDc1ODE3XG5dO1xuXG5mdW5jdGlvbiBjcnlwdG9faGFzaGJsb2Nrc19obChoaCwgaGwsIG0sIG4pIHtcbiAgdmFyIHdoID0gbmV3IEludDMyQXJyYXkoMTYpLCB3bCA9IG5ldyBJbnQzMkFycmF5KDE2KSxcbiAgICAgIGJoMCwgYmgxLCBiaDIsIGJoMywgYmg0LCBiaDUsIGJoNiwgYmg3LFxuICAgICAgYmwwLCBibDEsIGJsMiwgYmwzLCBibDQsIGJsNSwgYmw2LCBibDcsXG4gICAgICB0aCwgdGwsIGksIGosIGgsIGwsIGEsIGIsIGMsIGQ7XG5cbiAgdmFyIGFoMCA9IGhoWzBdLFxuICAgICAgYWgxID0gaGhbMV0sXG4gICAgICBhaDIgPSBoaFsyXSxcbiAgICAgIGFoMyA9IGhoWzNdLFxuICAgICAgYWg0ID0gaGhbNF0sXG4gICAgICBhaDUgPSBoaFs1XSxcbiAgICAgIGFoNiA9IGhoWzZdLFxuICAgICAgYWg3ID0gaGhbN10sXG5cbiAgICAgIGFsMCA9IGhsWzBdLFxuICAgICAgYWwxID0gaGxbMV0sXG4gICAgICBhbDIgPSBobFsyXSxcbiAgICAgIGFsMyA9IGhsWzNdLFxuICAgICAgYWw0ID0gaGxbNF0sXG4gICAgICBhbDUgPSBobFs1XSxcbiAgICAgIGFsNiA9IGhsWzZdLFxuICAgICAgYWw3ID0gaGxbN107XG5cbiAgdmFyIHBvcyA9IDA7XG4gIHdoaWxlIChuID49IDEyOCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBqID0gOCAqIGkgKyBwb3M7XG4gICAgICB3aFtpXSA9IChtW2orMF0gPDwgMjQpIHwgKG1baisxXSA8PCAxNikgfCAobVtqKzJdIDw8IDgpIHwgbVtqKzNdO1xuICAgICAgd2xbaV0gPSAobVtqKzRdIDw8IDI0KSB8IChtW2orNV0gPDwgMTYpIHwgKG1bais2XSA8PCA4KSB8IG1bais3XTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgIGJoMCA9IGFoMDtcbiAgICAgIGJoMSA9IGFoMTtcbiAgICAgIGJoMiA9IGFoMjtcbiAgICAgIGJoMyA9IGFoMztcbiAgICAgIGJoNCA9IGFoNDtcbiAgICAgIGJoNSA9IGFoNTtcbiAgICAgIGJoNiA9IGFoNjtcbiAgICAgIGJoNyA9IGFoNztcblxuICAgICAgYmwwID0gYWwwO1xuICAgICAgYmwxID0gYWwxO1xuICAgICAgYmwyID0gYWwyO1xuICAgICAgYmwzID0gYWwzO1xuICAgICAgYmw0ID0gYWw0O1xuICAgICAgYmw1ID0gYWw1O1xuICAgICAgYmw2ID0gYWw2O1xuICAgICAgYmw3ID0gYWw3O1xuXG4gICAgICAvLyBhZGRcbiAgICAgIGggPSBhaDc7XG4gICAgICBsID0gYWw3O1xuXG4gICAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgLy8gU2lnbWExXG4gICAgICBoID0gKChhaDQgPj4+IDE0KSB8IChhbDQgPDwgKDMyLTE0KSkpIF4gKChhaDQgPj4+IDE4KSB8IChhbDQgPDwgKDMyLTE4KSkpIF4gKChhbDQgPj4+ICg0MS0zMikpIHwgKGFoNCA8PCAoMzItKDQxLTMyKSkpKTtcbiAgICAgIGwgPSAoKGFsNCA+Pj4gMTQpIHwgKGFoNCA8PCAoMzItMTQpKSkgXiAoKGFsNCA+Pj4gMTgpIHwgKGFoNCA8PCAoMzItMTgpKSkgXiAoKGFoNCA+Pj4gKDQxLTMyKSkgfCAoYWw0IDw8ICgzMi0oNDEtMzIpKSkpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIENoXG4gICAgICBoID0gKGFoNCAmIGFoNSkgXiAofmFoNCAmIGFoNik7XG4gICAgICBsID0gKGFsNCAmIGFsNSkgXiAofmFsNCAmIGFsNik7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgLy8gS1xuICAgICAgaCA9IEtbaSoyXTtcbiAgICAgIGwgPSBLW2kqMisxXTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyB3XG4gICAgICBoID0gd2hbaSUxNl07XG4gICAgICBsID0gd2xbaSUxNl07XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgYiArPSBhID4+PiAxNjtcbiAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICB0aCA9IGMgJiAweGZmZmYgfCBkIDw8IDE2O1xuICAgICAgdGwgPSBhICYgMHhmZmZmIHwgYiA8PCAxNjtcblxuICAgICAgLy8gYWRkXG4gICAgICBoID0gdGg7XG4gICAgICBsID0gdGw7XG5cbiAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICAvLyBTaWdtYTBcbiAgICAgIGggPSAoKGFoMCA+Pj4gMjgpIHwgKGFsMCA8PCAoMzItMjgpKSkgXiAoKGFsMCA+Pj4gKDM0LTMyKSkgfCAoYWgwIDw8ICgzMi0oMzQtMzIpKSkpIF4gKChhbDAgPj4+ICgzOS0zMikpIHwgKGFoMCA8PCAoMzItKDM5LTMyKSkpKTtcbiAgICAgIGwgPSAoKGFsMCA+Pj4gMjgpIHwgKGFoMCA8PCAoMzItMjgpKSkgXiAoKGFoMCA+Pj4gKDM0LTMyKSkgfCAoYWwwIDw8ICgzMi0oMzQtMzIpKSkpIF4gKChhaDAgPj4+ICgzOS0zMikpIHwgKGFsMCA8PCAoMzItKDM5LTMyKSkpKTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyBNYWpcbiAgICAgIGggPSAoYWgwICYgYWgxKSBeIChhaDAgJiBhaDIpIF4gKGFoMSAmIGFoMik7XG4gICAgICBsID0gKGFsMCAmIGFsMSkgXiAoYWwwICYgYWwyKSBeIChhbDEgJiBhbDIpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgYmg3ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgYmw3ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgICAvLyBhZGRcbiAgICAgIGggPSBiaDM7XG4gICAgICBsID0gYmwzO1xuXG4gICAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgaCA9IHRoO1xuICAgICAgbCA9IHRsO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgYmgzID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgYmwzID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgICBhaDEgPSBiaDA7XG4gICAgICBhaDIgPSBiaDE7XG4gICAgICBhaDMgPSBiaDI7XG4gICAgICBhaDQgPSBiaDM7XG4gICAgICBhaDUgPSBiaDQ7XG4gICAgICBhaDYgPSBiaDU7XG4gICAgICBhaDcgPSBiaDY7XG4gICAgICBhaDAgPSBiaDc7XG5cbiAgICAgIGFsMSA9IGJsMDtcbiAgICAgIGFsMiA9IGJsMTtcbiAgICAgIGFsMyA9IGJsMjtcbiAgICAgIGFsNCA9IGJsMztcbiAgICAgIGFsNSA9IGJsNDtcbiAgICAgIGFsNiA9IGJsNTtcbiAgICAgIGFsNyA9IGJsNjtcbiAgICAgIGFsMCA9IGJsNztcblxuICAgICAgaWYgKGklMTYgPT09IDE1KSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICAgICAgLy8gYWRkXG4gICAgICAgICAgaCA9IHdoW2pdO1xuICAgICAgICAgIGwgPSB3bFtqXTtcblxuICAgICAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgICAgIGggPSB3aFsoais5KSUxNl07XG4gICAgICAgICAgbCA9IHdsWyhqKzkpJTE2XTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICAvLyBzaWdtYTBcbiAgICAgICAgICB0aCA9IHdoWyhqKzEpJTE2XTtcbiAgICAgICAgICB0bCA9IHdsWyhqKzEpJTE2XTtcbiAgICAgICAgICBoID0gKCh0aCA+Pj4gMSkgfCAodGwgPDwgKDMyLTEpKSkgXiAoKHRoID4+PiA4KSB8ICh0bCA8PCAoMzItOCkpKSBeICh0aCA+Pj4gNyk7XG4gICAgICAgICAgbCA9ICgodGwgPj4+IDEpIHwgKHRoIDw8ICgzMi0xKSkpIF4gKCh0bCA+Pj4gOCkgfCAodGggPDwgKDMyLTgpKSkgXiAoKHRsID4+PiA3KSB8ICh0aCA8PCAoMzItNykpKTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICAvLyBzaWdtYTFcbiAgICAgICAgICB0aCA9IHdoWyhqKzE0KSUxNl07XG4gICAgICAgICAgdGwgPSB3bFsoaisxNCklMTZdO1xuICAgICAgICAgIGggPSAoKHRoID4+PiAxOSkgfCAodGwgPDwgKDMyLTE5KSkpIF4gKCh0bCA+Pj4gKDYxLTMyKSkgfCAodGggPDwgKDMyLSg2MS0zMikpKSkgXiAodGggPj4+IDYpO1xuICAgICAgICAgIGwgPSAoKHRsID4+PiAxOSkgfCAodGggPDwgKDMyLTE5KSkpIF4gKCh0aCA+Pj4gKDYxLTMyKSkgfCAodGwgPDwgKDMyLSg2MS0zMikpKSkgXiAoKHRsID4+PiA2KSB8ICh0aCA8PCAoMzItNikpKTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICBiICs9IGEgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgICAgIHdoW2pdID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgICAgIHdsW2pdID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkXG4gICAgaCA9IGFoMDtcbiAgICBsID0gYWwwO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzBdO1xuICAgIGwgPSBobFswXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzBdID0gYWgwID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzBdID0gYWwwID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMTtcbiAgICBsID0gYWwxO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzFdO1xuICAgIGwgPSBobFsxXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzFdID0gYWgxID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzFdID0gYWwxID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMjtcbiAgICBsID0gYWwyO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzJdO1xuICAgIGwgPSBobFsyXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzJdID0gYWgyID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzJdID0gYWwyID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMztcbiAgICBsID0gYWwzO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzNdO1xuICAgIGwgPSBobFszXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzNdID0gYWgzID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzNdID0gYWwzID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNDtcbiAgICBsID0gYWw0O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzRdO1xuICAgIGwgPSBobFs0XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzRdID0gYWg0ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzRdID0gYWw0ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNTtcbiAgICBsID0gYWw1O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzVdO1xuICAgIGwgPSBobFs1XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzVdID0gYWg1ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzVdID0gYWw1ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNjtcbiAgICBsID0gYWw2O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzZdO1xuICAgIGwgPSBobFs2XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzZdID0gYWg2ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzZdID0gYWw2ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNztcbiAgICBsID0gYWw3O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzddO1xuICAgIGwgPSBobFs3XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzddID0gYWg3ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzddID0gYWw3ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgcG9zICs9IDEyODtcbiAgICBuIC09IDEyODtcbiAgfVxuXG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9faGFzaChvdXQsIG0sIG4pIHtcbiAgdmFyIGhoID0gbmV3IEludDMyQXJyYXkoOCksXG4gICAgICBobCA9IG5ldyBJbnQzMkFycmF5KDgpLFxuICAgICAgeCA9IG5ldyBVaW50OEFycmF5KDI1NiksXG4gICAgICBpLCBiID0gbjtcblxuICBoaFswXSA9IDB4NmEwOWU2Njc7XG4gIGhoWzFdID0gMHhiYjY3YWU4NTtcbiAgaGhbMl0gPSAweDNjNmVmMzcyO1xuICBoaFszXSA9IDB4YTU0ZmY1M2E7XG4gIGhoWzRdID0gMHg1MTBlNTI3ZjtcbiAgaGhbNV0gPSAweDliMDU2ODhjO1xuICBoaFs2XSA9IDB4MWY4M2Q5YWI7XG4gIGhoWzddID0gMHg1YmUwY2QxOTtcblxuICBobFswXSA9IDB4ZjNiY2M5MDg7XG4gIGhsWzFdID0gMHg4NGNhYTczYjtcbiAgaGxbMl0gPSAweGZlOTRmODJiO1xuICBobFszXSA9IDB4NWYxZDM2ZjE7XG4gIGhsWzRdID0gMHhhZGU2ODJkMTtcbiAgaGxbNV0gPSAweDJiM2U2YzFmO1xuICBobFs2XSA9IDB4ZmI0MWJkNmI7XG4gIGhsWzddID0gMHgxMzdlMjE3OTtcblxuICBjcnlwdG9faGFzaGJsb2Nrc19obChoaCwgaGwsIG0sIG4pO1xuICBuICU9IDEyODtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB4W2ldID0gbVtiLW4raV07XG4gIHhbbl0gPSAxMjg7XG5cbiAgbiA9IDI1Ni0xMjgqKG48MTEyPzE6MCk7XG4gIHhbbi05XSA9IDA7XG4gIHRzNjQoeCwgbi04LCAgKGIgLyAweDIwMDAwMDAwKSB8IDAsIGIgPDwgMyk7XG4gIGNyeXB0b19oYXNoYmxvY2tzX2hsKGhoLCBobCwgeCwgbik7XG5cbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykgdHM2NChvdXQsIDgqaSwgaGhbaV0sIGhsW2ldKTtcblxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gYWRkKHAsIHEpIHtcbiAgdmFyIGEgPSBnZigpLCBiID0gZ2YoKSwgYyA9IGdmKCksXG4gICAgICBkID0gZ2YoKSwgZSA9IGdmKCksIGYgPSBnZigpLFxuICAgICAgZyA9IGdmKCksIGggPSBnZigpLCB0ID0gZ2YoKTtcblxuICBaKGEsIHBbMV0sIHBbMF0pO1xuICBaKHQsIHFbMV0sIHFbMF0pO1xuICBNKGEsIGEsIHQpO1xuICBBKGIsIHBbMF0sIHBbMV0pO1xuICBBKHQsIHFbMF0sIHFbMV0pO1xuICBNKGIsIGIsIHQpO1xuICBNKGMsIHBbM10sIHFbM10pO1xuICBNKGMsIGMsIEQyKTtcbiAgTShkLCBwWzJdLCBxWzJdKTtcbiAgQShkLCBkLCBkKTtcbiAgWihlLCBiLCBhKTtcbiAgWihmLCBkLCBjKTtcbiAgQShnLCBkLCBjKTtcbiAgQShoLCBiLCBhKTtcblxuICBNKHBbMF0sIGUsIGYpO1xuICBNKHBbMV0sIGgsIGcpO1xuICBNKHBbMl0sIGcsIGYpO1xuICBNKHBbM10sIGUsIGgpO1xufVxuXG5mdW5jdGlvbiBjc3dhcChwLCBxLCBiKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgc2VsMjU1MTkocFtpXSwgcVtpXSwgYik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFjayhyLCBwKSB7XG4gIHZhciB0eCA9IGdmKCksIHR5ID0gZ2YoKSwgemkgPSBnZigpO1xuICBpbnYyNTUxOSh6aSwgcFsyXSk7XG4gIE0odHgsIHBbMF0sIHppKTtcbiAgTSh0eSwgcFsxXSwgemkpO1xuICBwYWNrMjU1MTkociwgdHkpO1xuICByWzMxXSBePSBwYXIyNTUxOSh0eCkgPDwgNztcbn1cblxuZnVuY3Rpb24gc2NhbGFybXVsdChwLCBxLCBzKSB7XG4gIHZhciBiLCBpO1xuICBzZXQyNTUxOShwWzBdLCBnZjApO1xuICBzZXQyNTUxOShwWzFdLCBnZjEpO1xuICBzZXQyNTUxOShwWzJdLCBnZjEpO1xuICBzZXQyNTUxOShwWzNdLCBnZjApO1xuICBmb3IgKGkgPSAyNTU7IGkgPj0gMDsgLS1pKSB7XG4gICAgYiA9IChzWyhpLzgpfDBdID4+IChpJjcpKSAmIDE7XG4gICAgY3N3YXAocCwgcSwgYik7XG4gICAgYWRkKHEsIHApO1xuICAgIGFkZChwLCBwKTtcbiAgICBjc3dhcChwLCBxLCBiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2FsYXJiYXNlKHAsIHMpIHtcbiAgdmFyIHEgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG4gIHNldDI1NTE5KHFbMF0sIFgpO1xuICBzZXQyNTUxOShxWzFdLCBZKTtcbiAgc2V0MjU1MTkocVsyXSwgZ2YxKTtcbiAgTShxWzNdLCBYLCBZKTtcbiAgc2NhbGFybXVsdChwLCBxLCBzKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NpZ25fa2V5cGFpcihwaywgc2ssIHNlZWRlZCkge1xuICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHAgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG4gIHZhciBpO1xuXG4gIGlmICghc2VlZGVkKSByYW5kb21ieXRlcyhzaywgMzIpO1xuICBjcnlwdG9faGFzaChkLCBzaywgMzIpO1xuICBkWzBdICY9IDI0ODtcbiAgZFszMV0gJj0gMTI3O1xuICBkWzMxXSB8PSA2NDtcblxuICBzY2FsYXJiYXNlKHAsIGQpO1xuICBwYWNrKHBrLCBwKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgc2tbaSszMl0gPSBwa1tpXTtcbiAgcmV0dXJuIDA7XG59XG5cbnZhciBMID0gbmV3IEZsb2F0NjRBcnJheShbMHhlZCwgMHhkMywgMHhmNSwgMHg1YywgMHgxYSwgMHg2MywgMHgxMiwgMHg1OCwgMHhkNiwgMHg5YywgMHhmNywgMHhhMiwgMHhkZSwgMHhmOSwgMHhkZSwgMHgxNCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgxMF0pO1xuXG5mdW5jdGlvbiBtb2RMKHIsIHgpIHtcbiAgdmFyIGNhcnJ5LCBpLCBqLCBrO1xuICBmb3IgKGkgPSA2MzsgaSA+PSAzMjsgLS1pKSB7XG4gICAgY2FycnkgPSAwO1xuICAgIGZvciAoaiA9IGkgLSAzMiwgayA9IGkgLSAxMjsgaiA8IGs7ICsraikge1xuICAgICAgeFtqXSArPSBjYXJyeSAtIDE2ICogeFtpXSAqIExbaiAtIChpIC0gMzIpXTtcbiAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcigoeFtqXSArIDEyOCkgLyAyNTYpO1xuICAgICAgeFtqXSAtPSBjYXJyeSAqIDI1NjtcbiAgICB9XG4gICAgeFtqXSArPSBjYXJyeTtcbiAgICB4W2ldID0gMDtcbiAgfVxuICBjYXJyeSA9IDA7XG4gIGZvciAoaiA9IDA7IGogPCAzMjsgaisrKSB7XG4gICAgeFtqXSArPSBjYXJyeSAtICh4WzMxXSA+PiA0KSAqIExbal07XG4gICAgY2FycnkgPSB4W2pdID4+IDg7XG4gICAgeFtqXSAmPSAyNTU7XG4gIH1cbiAgZm9yIChqID0gMDsgaiA8IDMyOyBqKyspIHhbal0gLT0gY2FycnkgKiBMW2pdO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIHhbaSsxXSArPSB4W2ldID4+IDg7XG4gICAgcltpXSA9IHhbaV0gJiAyNTU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlKHIpIHtcbiAgdmFyIHggPSBuZXcgRmxvYXQ2NEFycmF5KDY0KSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHhbaV0gPSByW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgcltpXSA9IDA7XG4gIG1vZEwociwgeCk7XG59XG5cbi8vIE5vdGU6IGRpZmZlcmVuY2UgZnJvbSBDIC0gc21sZW4gcmV0dXJuZWQsIG5vdCBwYXNzZWQgYXMgYXJndW1lbnQuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbihzbSwgbSwgbiwgc2spIHtcbiAgdmFyIGQgPSBuZXcgVWludDhBcnJheSg2NCksIGggPSBuZXcgVWludDhBcnJheSg2NCksIHIgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHZhciBpLCBqLCB4ID0gbmV3IEZsb2F0NjRBcnJheSg2NCk7XG4gIHZhciBwID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldO1xuXG4gIGNyeXB0b19oYXNoKGQsIHNrLCAzMik7XG4gIGRbMF0gJj0gMjQ4O1xuICBkWzMxXSAmPSAxMjc7XG4gIGRbMzFdIHw9IDY0O1xuXG4gIHZhciBzbWxlbiA9IG4gKyA2NDtcbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgc21bNjQgKyBpXSA9IG1baV07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBzbVszMiArIGldID0gZFszMiArIGldO1xuXG4gIGNyeXB0b19oYXNoKHIsIHNtLnN1YmFycmF5KDMyKSwgbiszMik7XG4gIHJlZHVjZShyKTtcbiAgc2NhbGFyYmFzZShwLCByKTtcbiAgcGFjayhzbSwgcCk7XG5cbiAgZm9yIChpID0gMzI7IGkgPCA2NDsgaSsrKSBzbVtpXSA9IHNrW2ldO1xuICBjcnlwdG9faGFzaChoLCBzbSwgbiArIDY0KTtcbiAgcmVkdWNlKGgpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB4W2ldID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHhbaV0gPSByW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIGZvciAoaiA9IDA7IGogPCAzMjsgaisrKSB7XG4gICAgICB4W2kral0gKz0gaFtpXSAqIGRbal07XG4gICAgfVxuICB9XG5cbiAgbW9kTChzbS5zdWJhcnJheSgzMiksIHgpO1xuICByZXR1cm4gc21sZW47XG59XG5cbmZ1bmN0aW9uIHVucGFja25lZyhyLCBwKSB7XG4gIHZhciB0ID0gZ2YoKSwgY2hrID0gZ2YoKSwgbnVtID0gZ2YoKSxcbiAgICAgIGRlbiA9IGdmKCksIGRlbjIgPSBnZigpLCBkZW40ID0gZ2YoKSxcbiAgICAgIGRlbjYgPSBnZigpO1xuXG4gIHNldDI1NTE5KHJbMl0sIGdmMSk7XG4gIHVucGFjazI1NTE5KHJbMV0sIHApO1xuICBTKG51bSwgclsxXSk7XG4gIE0oZGVuLCBudW0sIEQpO1xuICBaKG51bSwgbnVtLCByWzJdKTtcbiAgQShkZW4sIHJbMl0sIGRlbik7XG5cbiAgUyhkZW4yLCBkZW4pO1xuICBTKGRlbjQsIGRlbjIpO1xuICBNKGRlbjYsIGRlbjQsIGRlbjIpO1xuICBNKHQsIGRlbjYsIG51bSk7XG4gIE0odCwgdCwgZGVuKTtcblxuICBwb3cyNTIzKHQsIHQpO1xuICBNKHQsIHQsIG51bSk7XG4gIE0odCwgdCwgZGVuKTtcbiAgTSh0LCB0LCBkZW4pO1xuICBNKHJbMF0sIHQsIGRlbik7XG5cbiAgUyhjaGssIHJbMF0pO1xuICBNKGNoaywgY2hrLCBkZW4pO1xuICBpZiAobmVxMjU1MTkoY2hrLCBudW0pKSBNKHJbMF0sIHJbMF0sIEkpO1xuXG4gIFMoY2hrLCByWzBdKTtcbiAgTShjaGssIGNoaywgZGVuKTtcbiAgaWYgKG5lcTI1NTE5KGNoaywgbnVtKSkgcmV0dXJuIC0xO1xuXG4gIGlmIChwYXIyNTUxOShyWzBdKSA9PT0gKHBbMzFdPj43KSkgWihyWzBdLCBnZjAsIHJbMF0pO1xuXG4gIE0oclszXSwgclswXSwgclsxXSk7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbl9vcGVuKG0sIHNtLCBuLCBwaykge1xuICB2YXIgaTtcbiAgdmFyIHQgPSBuZXcgVWludDhBcnJheSgzMiksIGggPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHZhciBwID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldLFxuICAgICAgcSA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXTtcblxuICBpZiAobiA8IDY0KSByZXR1cm4gLTE7XG5cbiAgaWYgKHVucGFja25lZyhxLCBwaykpIHJldHVybiAtMTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBtW2ldID0gc21baV07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBtW2krMzJdID0gcGtbaV07XG4gIGNyeXB0b19oYXNoKGgsIG0sIG4pO1xuICByZWR1Y2UoaCk7XG4gIHNjYWxhcm11bHQocCwgcSwgaCk7XG5cbiAgc2NhbGFyYmFzZShxLCBzbS5zdWJhcnJheSgzMikpO1xuICBhZGQocCwgcSk7XG4gIHBhY2sodCwgcCk7XG5cbiAgbiAtPSA2NDtcbiAgaWYgKGNyeXB0b192ZXJpZnlfMzIoc20sIDAsIHQsIDApKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgbVtpXSA9IDA7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgbVtpXSA9IHNtW2kgKyA2NF07XG4gIHJldHVybiBuO1xufVxuXG52YXIgY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUyA9IDI0LFxuICAgIGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTID0gMzIsXG4gICAgY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMgPSAxNixcbiAgICBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X0JFRk9SRU5NQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X05PTkNFQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMsXG4gICAgY3J5cHRvX2JveF9aRVJPQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyxcbiAgICBjcnlwdG9fYm94X0JPWFpFUk9CWVRFUyA9IGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTLFxuICAgIGNyeXB0b19zaWduX0JZVEVTID0gNjQsXG4gICAgY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUyA9IDY0LFxuICAgIGNyeXB0b19zaWduX1NFRURCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19oYXNoX0JZVEVTID0gNjQ7XG5cbm5hY2wubG93bGV2ZWwgPSB7XG4gIGNyeXB0b19jb3JlX2hzYWxzYTIwOiBjcnlwdG9fY29yZV9oc2Fsc2EyMCxcbiAgY3J5cHRvX3N0cmVhbV94b3I6IGNyeXB0b19zdHJlYW1feG9yLFxuICBjcnlwdG9fc3RyZWFtOiBjcnlwdG9fc3RyZWFtLFxuICBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yOiBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yLFxuICBjcnlwdG9fc3RyZWFtX3NhbHNhMjA6IGNyeXB0b19zdHJlYW1fc2Fsc2EyMCxcbiAgY3J5cHRvX29uZXRpbWVhdXRoOiBjcnlwdG9fb25ldGltZWF1dGgsXG4gIGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnk6IGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnksXG4gIGNyeXB0b192ZXJpZnlfMTY6IGNyeXB0b192ZXJpZnlfMTYsXG4gIGNyeXB0b192ZXJpZnlfMzI6IGNyeXB0b192ZXJpZnlfMzIsXG4gIGNyeXB0b19zZWNyZXRib3g6IGNyeXB0b19zZWNyZXRib3gsXG4gIGNyeXB0b19zZWNyZXRib3hfb3BlbjogY3J5cHRvX3NlY3JldGJveF9vcGVuLFxuICBjcnlwdG9fc2NhbGFybXVsdDogY3J5cHRvX3NjYWxhcm11bHQsXG4gIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2U6IGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UsXG4gIGNyeXB0b19ib3hfYmVmb3Jlbm06IGNyeXB0b19ib3hfYmVmb3Jlbm0sXG4gIGNyeXB0b19ib3hfYWZ0ZXJubTogY3J5cHRvX2JveF9hZnRlcm5tLFxuICBjcnlwdG9fYm94OiBjcnlwdG9fYm94LFxuICBjcnlwdG9fYm94X29wZW46IGNyeXB0b19ib3hfb3BlbixcbiAgY3J5cHRvX2JveF9rZXlwYWlyOiBjcnlwdG9fYm94X2tleXBhaXIsXG4gIGNyeXB0b19oYXNoOiBjcnlwdG9faGFzaCxcbiAgY3J5cHRvX3NpZ246IGNyeXB0b19zaWduLFxuICBjcnlwdG9fc2lnbl9rZXlwYWlyOiBjcnlwdG9fc2lnbl9rZXlwYWlyLFxuICBjcnlwdG9fc2lnbl9vcGVuOiBjcnlwdG9fc2lnbl9vcGVuLFxuXG4gIGNyeXB0b19zZWNyZXRib3hfS0VZQllURVM6IGNyeXB0b19zZWNyZXRib3hfS0VZQllURVMsXG4gIGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUzogY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTLFxuICBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUzogY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMsXG4gIGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTOiBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyxcbiAgY3J5cHRvX3NjYWxhcm11bHRfQllURVM6IGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTLFxuICBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUzogY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMsXG4gIGNyeXB0b19ib3hfUFVCTElDS0VZQllURVM6IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMsXG4gIGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVM6IGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMsXG4gIGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUzogY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTLFxuICBjcnlwdG9fYm94X05PTkNFQllURVM6IGNyeXB0b19ib3hfTk9OQ0VCWVRFUyxcbiAgY3J5cHRvX2JveF9aRVJPQllURVM6IGNyeXB0b19ib3hfWkVST0JZVEVTLFxuICBjcnlwdG9fYm94X0JPWFpFUk9CWVRFUzogY3J5cHRvX2JveF9CT1haRVJPQllURVMsXG4gIGNyeXB0b19zaWduX0JZVEVTOiBjcnlwdG9fc2lnbl9CWVRFUyxcbiAgY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVM6IGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTLFxuICBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUzogY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMsXG4gIGNyeXB0b19zaWduX1NFRURCWVRFUzogY3J5cHRvX3NpZ25fU0VFREJZVEVTLFxuICBjcnlwdG9faGFzaF9CWVRFUzogY3J5cHRvX2hhc2hfQllURVMsXG5cbiAgZ2Y6IGdmLFxuICBEOiBELFxuICBMOiBMLFxuICBwYWNrMjU1MTk6IHBhY2syNTUxOSxcbiAgdW5wYWNrMjU1MTk6IHVucGFjazI1NTE5LFxuICBNOiBNLFxuICBBOiBBLFxuICBTOiBTLFxuICBaOiBaLFxuICBwb3cyNTIzOiBwb3cyNTIzLFxuICBhZGQ6IGFkZCxcbiAgc2V0MjU1MTk6IHNldDI1NTE5LFxuICBtb2RMOiBtb2RMLFxuICBzY2FsYXJtdWx0OiBzY2FsYXJtdWx0LFxuICBzY2FsYXJiYXNlOiBzY2FsYXJiYXNlLFxufTtcblxuLyogSGlnaC1sZXZlbCBBUEkgKi9cblxuZnVuY3Rpb24gY2hlY2tMZW5ndGhzKGssIG4pIHtcbiAgaWYgKGsubGVuZ3RoICE9PSBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBrZXkgc2l6ZScpO1xuICBpZiAobi5sZW5ndGggIT09IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgbm9uY2Ugc2l6ZScpO1xufVxuXG5mdW5jdGlvbiBjaGVja0JveExlbmd0aHMocGssIHNrKSB7XG4gIGlmIChway5sZW5ndGggIT09IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHB1YmxpYyBrZXkgc2l6ZScpO1xuICBpZiAoc2subGVuZ3RoICE9PSBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tBcnJheVR5cGVzKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghKGFyZ3VtZW50c1tpXSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5leHBlY3RlZCB0eXBlLCB1c2UgVWludDhBcnJheScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFudXAoYXJyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnJbaV0gPSAwO1xufVxuXG5uYWNsLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24obikge1xuICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KG4pO1xuICByYW5kb21ieXRlcyhiLCBuKTtcbiAgcmV0dXJuIGI7XG59O1xuXG5uYWNsLnNlY3JldGJveCA9IGZ1bmN0aW9uKG1zZywgbm9uY2UsIGtleSkge1xuICBjaGVja0FycmF5VHlwZXMobXNnLCBub25jZSwga2V5KTtcbiAgY2hlY2tMZW5ndGhzKGtleSwgbm9uY2UpO1xuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTICsgbXNnLmxlbmd0aCk7XG4gIHZhciBjID0gbmV3IFVpbnQ4QXJyYXkobS5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykgbVtpK2NyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTXSA9IG1zZ1tpXTtcbiAgY3J5cHRvX3NlY3JldGJveChjLCBtLCBtLmxlbmd0aCwgbm9uY2UsIGtleSk7XG4gIHJldHVybiBjLnN1YmFycmF5KGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTKTtcbn07XG5cbm5hY2wuc2VjcmV0Ym94Lm9wZW4gPSBmdW5jdGlvbihib3gsIG5vbmNlLCBrZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKGJveCwgbm9uY2UsIGtleSk7XG4gIGNoZWNrTGVuZ3RocyhrZXksIG5vbmNlKTtcbiAgdmFyIGMgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyArIGJveC5sZW5ndGgpO1xuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGMubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3gubGVuZ3RoOyBpKyspIGNbaStjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFU10gPSBib3hbaV07XG4gIGlmIChjLmxlbmd0aCA8IDMyKSByZXR1cm4gbnVsbDtcbiAgaWYgKGNyeXB0b19zZWNyZXRib3hfb3BlbihtLCBjLCBjLmxlbmd0aCwgbm9uY2UsIGtleSkgIT09IDApIHJldHVybiBudWxsO1xuICByZXR1cm4gbS5zdWJhcnJheShjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyk7XG59O1xuXG5uYWNsLnNlY3JldGJveC5rZXlMZW5ndGggPSBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTO1xubmFjbC5zZWNyZXRib3gubm9uY2VMZW5ndGggPSBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVM7XG5uYWNsLnNlY3JldGJveC5vdmVyaGVhZExlbmd0aCA9IGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTO1xuXG5uYWNsLnNjYWxhck11bHQgPSBmdW5jdGlvbihuLCBwKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhuLCBwKTtcbiAgaWYgKG4ubGVuZ3RoICE9PSBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgbiBzaXplJyk7XG4gIGlmIChwLmxlbmd0aCAhPT0gY3J5cHRvX3NjYWxhcm11bHRfQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHAgc2l6ZScpO1xuICB2YXIgcSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTKTtcbiAgY3J5cHRvX3NjYWxhcm11bHQocSwgbiwgcCk7XG4gIHJldHVybiBxO1xufTtcblxubmFjbC5zY2FsYXJNdWx0LmJhc2UgPSBmdW5jdGlvbihuKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhuKTtcbiAgaWYgKG4ubGVuZ3RoICE9PSBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgbiBzaXplJyk7XG4gIHZhciBxID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NjYWxhcm11bHRfQllURVMpO1xuICBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHEsIG4pO1xuICByZXR1cm4gcTtcbn07XG5cbm5hY2wuc2NhbGFyTXVsdC5zY2FsYXJMZW5ndGggPSBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUztcbm5hY2wuc2NhbGFyTXVsdC5ncm91cEVsZW1lbnRMZW5ndGggPSBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUztcblxubmFjbC5ib3ggPSBmdW5jdGlvbihtc2csIG5vbmNlLCBwdWJsaWNLZXksIHNlY3JldEtleSkge1xuICB2YXIgayA9IG5hY2wuYm94LmJlZm9yZShwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIHJldHVybiBuYWNsLnNlY3JldGJveChtc2csIG5vbmNlLCBrKTtcbn07XG5cbm5hY2wuYm94LmJlZm9yZSA9IGZ1bmN0aW9uKHB1YmxpY0tleSwgc2VjcmV0S2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIGNoZWNrQm94TGVuZ3RocyhwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIHZhciBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTKTtcbiAgY3J5cHRvX2JveF9iZWZvcmVubShrLCBwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIHJldHVybiBrO1xufTtcblxubmFjbC5ib3guYWZ0ZXIgPSBuYWNsLnNlY3JldGJveDtcblxubmFjbC5ib3gub3BlbiA9IGZ1bmN0aW9uKG1zZywgbm9uY2UsIHB1YmxpY0tleSwgc2VjcmV0S2V5KSB7XG4gIHZhciBrID0gbmFjbC5ib3guYmVmb3JlKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgcmV0dXJuIG5hY2wuc2VjcmV0Ym94Lm9wZW4obXNnLCBub25jZSwgayk7XG59O1xuXG5uYWNsLmJveC5vcGVuLmFmdGVyID0gbmFjbC5zZWNyZXRib3gub3BlbjtcblxubmFjbC5ib3gua2V5UGFpciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTKTtcbiAgdmFyIHNrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUyk7XG4gIGNyeXB0b19ib3hfa2V5cGFpcihwaywgc2spO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogc2t9O1xufTtcblxubmFjbC5ib3gua2V5UGFpci5mcm9tU2VjcmV0S2V5ID0gZnVuY3Rpb24oc2VjcmV0S2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhzZWNyZXRLZXkpO1xuICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbiAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUyk7XG4gIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UocGssIHNlY3JldEtleSk7XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBuZXcgVWludDhBcnJheShzZWNyZXRLZXkpfTtcbn07XG5cbm5hY2wuYm94LnB1YmxpY0tleUxlbmd0aCA9IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVM7XG5uYWNsLmJveC5zZWNyZXRLZXlMZW5ndGggPSBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTO1xubmFjbC5ib3guc2hhcmVkS2V5TGVuZ3RoID0gY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTO1xubmFjbC5ib3gubm9uY2VMZW5ndGggPSBjcnlwdG9fYm94X05PTkNFQllURVM7XG5uYWNsLmJveC5vdmVyaGVhZExlbmd0aCA9IG5hY2wuc2VjcmV0Ym94Lm92ZXJoZWFkTGVuZ3RoO1xuXG5uYWNsLnNpZ24gPSBmdW5jdGlvbihtc2csIHNlY3JldEtleSkge1xuICBjaGVja0FycmF5VHlwZXMobXNnLCBzZWNyZXRLZXkpO1xuICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gIHZhciBzaWduZWRNc2cgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyttc2cubGVuZ3RoKTtcbiAgY3J5cHRvX3NpZ24oc2lnbmVkTXNnLCBtc2csIG1zZy5sZW5ndGgsIHNlY3JldEtleSk7XG4gIHJldHVybiBzaWduZWRNc2c7XG59O1xuXG5uYWNsLnNpZ24ub3BlbiA9IGZ1bmN0aW9uKHNpZ25lZE1zZywgcHVibGljS2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhzaWduZWRNc2csIHB1YmxpY0tleSk7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwdWJsaWMga2V5IHNpemUnKTtcbiAgdmFyIHRtcCA9IG5ldyBVaW50OEFycmF5KHNpZ25lZE1zZy5sZW5ndGgpO1xuICB2YXIgbWxlbiA9IGNyeXB0b19zaWduX29wZW4odG1wLCBzaWduZWRNc2csIHNpZ25lZE1zZy5sZW5ndGgsIHB1YmxpY0tleSk7XG4gIGlmIChtbGVuIDwgMCkgcmV0dXJuIG51bGw7XG4gIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkobWxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykgbVtpXSA9IHRtcFtpXTtcbiAgcmV0dXJuIG07XG59O1xuXG5uYWNsLnNpZ24uZGV0YWNoZWQgPSBmdW5jdGlvbihtc2csIHNlY3JldEtleSkge1xuICB2YXIgc2lnbmVkTXNnID0gbmFjbC5zaWduKG1zZywgc2VjcmV0S2V5KTtcbiAgdmFyIHNpZyA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX0JZVEVTKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWcubGVuZ3RoOyBpKyspIHNpZ1tpXSA9IHNpZ25lZE1zZ1tpXTtcbiAgcmV0dXJuIHNpZztcbn07XG5cbm5hY2wuc2lnbi5kZXRhY2hlZC52ZXJpZnkgPSBmdW5jdGlvbihtc2csIHNpZywgcHVibGljS2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2csIHNpZywgcHVibGljS2V5KTtcbiAgaWYgKHNpZy5sZW5ndGggIT09IGNyeXB0b19zaWduX0JZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNpZ25hdHVyZSBzaXplJyk7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwdWJsaWMga2V5IHNpemUnKTtcbiAgdmFyIHNtID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fQllURVMgKyBtc2cubGVuZ3RoKTtcbiAgdmFyIG0gPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyArIG1zZy5sZW5ndGgpO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IGNyeXB0b19zaWduX0JZVEVTOyBpKyspIHNtW2ldID0gc2lnW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSBzbVtpK2NyeXB0b19zaWduX0JZVEVTXSA9IG1zZ1tpXTtcbiAgcmV0dXJuIChjcnlwdG9fc2lnbl9vcGVuKG0sIHNtLCBzbS5sZW5ndGgsIHB1YmxpY0tleSkgPj0gMCk7XG59O1xuXG5uYWNsLnNpZ24ua2V5UGFpciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gIHZhciBzayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKTtcbiAgY3J5cHRvX3NpZ25fa2V5cGFpcihwaywgc2spO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogc2t9O1xufTtcblxubmFjbC5zaWduLmtleVBhaXIuZnJvbVNlY3JldEtleSA9IGZ1bmN0aW9uKHNlY3JldEtleSkge1xuICBjaGVja0FycmF5VHlwZXMoc2VjcmV0S2V5KTtcbiAgaWYgKHNlY3JldEtleS5sZW5ndGggIT09IGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGsubGVuZ3RoOyBpKyspIHBrW2ldID0gc2VjcmV0S2V5WzMyK2ldO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogbmV3IFVpbnQ4QXJyYXkoc2VjcmV0S2V5KX07XG59O1xuXG5uYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VlZCA9IGZ1bmN0aW9uKHNlZWQpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHNlZWQpO1xuICBpZiAoc2VlZC5sZW5ndGggIT09IGNyeXB0b19zaWduX1NFRURCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWVkIHNpemUnKTtcbiAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMpO1xuICB2YXIgc2sgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykgc2tbaV0gPSBzZWVkW2ldO1xuICBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzaywgdHJ1ZSk7XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBza307XG59O1xuXG5uYWNsLnNpZ24ucHVibGljS2V5TGVuZ3RoID0gY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVM7XG5uYWNsLnNpZ24uc2VjcmV0S2V5TGVuZ3RoID0gY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVM7XG5uYWNsLnNpZ24uc2VlZExlbmd0aCA9IGNyeXB0b19zaWduX1NFRURCWVRFUztcbm5hY2wuc2lnbi5zaWduYXR1cmVMZW5ndGggPSBjcnlwdG9fc2lnbl9CWVRFUztcblxubmFjbC5oYXNoID0gZnVuY3Rpb24obXNnKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2cpO1xuICB2YXIgaCA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19oYXNoX0JZVEVTKTtcbiAgY3J5cHRvX2hhc2goaCwgbXNnLCBtc2cubGVuZ3RoKTtcbiAgcmV0dXJuIGg7XG59O1xuXG5uYWNsLmhhc2guaGFzaExlbmd0aCA9IGNyeXB0b19oYXNoX0JZVEVTO1xuXG5uYWNsLnZlcmlmeSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHgsIHkpO1xuICAvLyBaZXJvIGxlbmd0aCBhcmd1bWVudHMgYXJlIGNvbnNpZGVyZWQgbm90IGVxdWFsLlxuICBpZiAoeC5sZW5ndGggPT09IDAgfHwgeS5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcbiAgaWYgKHgubGVuZ3RoICE9PSB5Lmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gKHZuKHgsIDAsIHksIDAsIHgubGVuZ3RoKSA9PT0gMCkgPyB0cnVlIDogZmFsc2U7XG59O1xuXG5uYWNsLnNldFBSTkcgPSBmdW5jdGlvbihmbikge1xuICByYW5kb21ieXRlcyA9IGZuO1xufTtcblxuKGZ1bmN0aW9uKCkge1xuICAvLyBJbml0aWFsaXplIFBSTkcgaWYgZW52aXJvbm1lbnQgcHJvdmlkZXMgQ1NQUk5HLlxuICAvLyBJZiBub3QsIG1ldGhvZHMgY2FsbGluZyByYW5kb21ieXRlcyB3aWxsIHRocm93LlxuICB2YXIgY3J5cHRvID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gKHNlbGYuY3J5cHRvIHx8IHNlbGYubXNDcnlwdG8pIDogbnVsbDtcbiAgaWYgKGNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gQnJvd3NlcnMuXG4gICAgdmFyIFFVT1RBID0gNjU1MzY7XG4gICAgbmFjbC5zZXRQUk5HKGZ1bmN0aW9uKHgsIG4pIHtcbiAgICAgIHZhciBpLCB2ID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSArPSBRVU9UQSkge1xuICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHYuc3ViYXJyYXkoaSwgaSArIE1hdGgubWluKG4gLSBpLCBRVU9UQSkpKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHhbaV0gPSB2W2ldO1xuICAgICAgY2xlYW51cCh2KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBOb2RlLmpzLlxuICAgIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuICAgIGlmIChjcnlwdG8gJiYgY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XG4gICAgICBuYWNsLnNldFBSTkcoZnVuY3Rpb24oeCwgbikge1xuICAgICAgICB2YXIgaSwgdiA9IGNyeXB0by5yYW5kb21CeXRlcyhuKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgeFtpXSA9IHZbaV07XG4gICAgICAgIGNsZWFudXAodik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pKCk7XG5cbn0pKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzID8gbW9kdWxlLmV4cG9ydHMgOiAoc2VsZi5uYWNsID0gc2VsZi5uYWNsIHx8IHt9KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tweetnacl/nacl-fast.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ua-parser-js/src/ua-parser.js":
/*!****************************************************!*\
  !*** ./node_modules/ua-parser-js/src/ua-parser.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_RESULT__;/////////////////////////////////////////////////////////////////////////////////\n/* UAParser.js v1.0.41\n   Copyright  2012-2025 Faisal Salman <f@faisalman.com>\n   MIT License *//*\n   Detect Browser, Engine, OS, CPU, and Device type/model from User-Agent data.\n   Supports browser & node.js environment. \n   Demo   : https://faisalman.github.io/ua-parser-js\n   Source : https://github.com/faisalman/ua-parser-js */\n/////////////////////////////////////////////////////////////////////////////////\n\n(function (window, undefined) {\n\n    'use strict';\n\n    //////////////\n    // Constants\n    /////////////\n\n\n    var LIBVERSION  = '1.0.41',\n        EMPTY       = '',\n        UNKNOWN     = '?',\n        FUNC_TYPE   = 'function',\n        UNDEF_TYPE  = 'undefined',\n        OBJ_TYPE    = 'object',\n        STR_TYPE    = 'string',\n        MAJOR       = 'major',\n        MODEL       = 'model',\n        NAME        = 'name',\n        TYPE        = 'type',\n        VENDOR      = 'vendor',\n        VERSION     = 'version',\n        ARCHITECTURE= 'architecture',\n        CONSOLE     = 'console',\n        MOBILE      = 'mobile',\n        TABLET      = 'tablet',\n        SMARTTV     = 'smarttv',\n        WEARABLE    = 'wearable',\n        EMBEDDED    = 'embedded',\n        UA_MAX_LENGTH = 500;\n\n    var AMAZON  = 'Amazon',\n        APPLE   = 'Apple',\n        ASUS    = 'ASUS',\n        BLACKBERRY = 'BlackBerry',\n        BROWSER = 'Browser',\n        CHROME  = 'Chrome',\n        EDGE    = 'Edge',\n        FIREFOX = 'Firefox',\n        GOOGLE  = 'Google',\n        HONOR   = 'Honor',\n        HUAWEI  = 'Huawei',\n        LENOVO  = 'Lenovo',\n        LG      = 'LG',\n        MICROSOFT = 'Microsoft',\n        MOTOROLA  = 'Motorola',\n        NVIDIA  = 'Nvidia',\n        ONEPLUS = 'OnePlus',\n        OPERA   = 'Opera',\n        OPPO    = 'OPPO',\n        SAMSUNG = 'Samsung',\n        SHARP   = 'Sharp',\n        SONY    = 'Sony',\n        XIAOMI  = 'Xiaomi',\n        ZEBRA   = 'Zebra',\n        FACEBOOK    = 'Facebook',\n        CHROMIUM_OS = 'Chromium OS',\n        MAC_OS  = 'Mac OS',\n        SUFFIX_BROWSER = ' Browser';\n\n    ///////////\n    // Helper\n    //////////\n\n    var extend = function (regexes, extensions) {\n            var mergedRegexes = {};\n            for (var i in regexes) {\n                if (extensions[i] && extensions[i].length % 2 === 0) {\n                    mergedRegexes[i] = extensions[i].concat(regexes[i]);\n                } else {\n                    mergedRegexes[i] = regexes[i];\n                }\n            }\n            return mergedRegexes;\n        },\n        enumerize = function (arr) {\n            var enums = {};\n            for (var i=0; i<arr.length; i++) {\n                enums[arr[i].toUpperCase()] = arr[i];\n            }\n            return enums;\n        },\n        has = function (str1, str2) {\n            return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;\n        },\n        lowerize = function (str) {\n            return str.toLowerCase();\n        },\n        majorize = function (version) {\n            return typeof(version) === STR_TYPE ? version.replace(/[^\\d\\.]/g, EMPTY).split('.')[0] : undefined;\n        },\n        trim = function (str, len) {\n            if (typeof(str) === STR_TYPE) {\n                str = str.replace(/^\\s\\s*/, EMPTY);\n                return typeof(len) === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);\n            }\n    };\n\n    ///////////////\n    // Map helper\n    //////////////\n\n    var rgxMapper = function (ua, arrays) {\n\n            var i = 0, j, k, p, q, matches, match;\n\n            // loop through all regexes maps\n            while (i < arrays.length && !matches) {\n\n                var regex = arrays[i],       // even sequence (0,2,4,..)\n                    props = arrays[i + 1];   // odd sequence (1,3,5,..)\n                j = k = 0;\n\n                // try matching uastring with regexes\n                while (j < regex.length && !matches) {\n\n                    if (!regex[j]) { break; }\n                    matches = regex[j++].exec(ua);\n\n                    if (!!matches) {\n                        for (p = 0; p < props.length; p++) {\n                            match = matches[++k];\n                            q = props[p];\n                            // check if given property is actually array\n                            if (typeof q === OBJ_TYPE && q.length > 0) {\n                                if (q.length === 2) {\n                                    if (typeof q[1] == FUNC_TYPE) {\n                                        // assign modified match\n                                        this[q[0]] = q[1].call(this, match);\n                                    } else {\n                                        // assign given value, ignore regex match\n                                        this[q[0]] = q[1];\n                                    }\n                                } else if (q.length === 3) {\n                                    // check whether function or regex\n                                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {\n                                        // call function (usually string mapper)\n                                        this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;\n                                    } else {\n                                        // sanitize match using given regex\n                                        this[q[0]] = match ? match.replace(q[1], q[2]) : undefined;\n                                    }\n                                } else if (q.length === 4) {\n                                        this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;\n                                }\n                            } else {\n                                this[q] = match ? match : undefined;\n                            }\n                        }\n                    }\n                }\n                i += 2;\n            }\n        },\n\n        strMapper = function (str, map) {\n\n            for (var i in map) {\n                // check if current value is array\n                if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {\n                    for (var j = 0; j < map[i].length; j++) {\n                        if (has(map[i][j], str)) {\n                            return (i === UNKNOWN) ? undefined : i;\n                        }\n                    }\n                } else if (has(map[i], str)) {\n                    return (i === UNKNOWN) ? undefined : i;\n                }\n            }\n            return map.hasOwnProperty('*') ? map['*'] : str;\n    };\n\n    ///////////////\n    // String map\n    //////////////\n\n    // Safari < 3.0\n    var oldSafariMap = {\n            '1.0'   : '/8',\n            '1.2'   : '/1',\n            '1.3'   : '/3',\n            '2.0'   : '/412',\n            '2.0.2' : '/416',\n            '2.0.3' : '/417',\n            '2.0.4' : '/419',\n            '?'     : '/'\n        },\n        windowsVersionMap = {\n            'ME'        : '4.90',\n            'NT 3.11'   : 'NT3.51',\n            'NT 4.0'    : 'NT4.0',\n            '2000'      : 'NT 5.0',\n            'XP'        : ['NT 5.1', 'NT 5.2'],\n            'Vista'     : 'NT 6.0',\n            '7'         : 'NT 6.1',\n            '8'         : 'NT 6.2',\n            '8.1'       : 'NT 6.3',\n            '10'        : ['NT 6.4', 'NT 10.0'],\n            'RT'        : 'ARM'\n    };\n\n    //////////////\n    // Regex map\n    /////////////\n\n    var regexes = {\n\n        browser : [[\n\n            /\\b(?:crmo|crios)\\/([\\w\\.]+)/i                                      // Chrome for Android/iOS\n            ], [VERSION, [NAME, 'Chrome']], [\n            /edg(?:e|ios|a)?\\/([\\w\\.]+)/i                                       // Microsoft Edge\n            ], [VERSION, [NAME, 'Edge']], [\n\n            // Presto based\n            /(opera mini)\\/([-\\w\\.]+)/i,                                        // Opera Mini\n            /(opera [mobiletab]{3,6})\\b.+version\\/([-\\w\\.]+)/i,                 // Opera Mobi/Tablet\n            /(opera)(?:.+version\\/|[\\/ ]+)([\\w\\.]+)/i                           // Opera\n            ], [NAME, VERSION], [\n            /opios[\\/ ]+([\\w\\.]+)/i                                             // Opera mini on iphone >= 8.0\n            ], [VERSION, [NAME, OPERA+' Mini']], [\n            /\\bop(?:rg)?x\\/([\\w\\.]+)/i                                          // Opera GX\n            ], [VERSION, [NAME, OPERA+' GX']], [\n            /\\bopr\\/([\\w\\.]+)/i                                                 // Opera Webkit\n            ], [VERSION, [NAME, OPERA]], [\n\n            // Mixed\n            /\\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\\/ ]?([\\w\\.]+)/i            // Baidu\n            ], [VERSION, [NAME, 'Baidu']], [\n            /\\b(?:mxbrowser|mxios|myie2)\\/?([-\\w\\.]*)\\b/i                       // Maxthon\n            ], [VERSION, [NAME, 'Maxthon']], [\n            /(kindle)\\/([\\w\\.]+)/i,                                             // Kindle\n            /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\\/ ]?([\\w\\.]*)/i,      \n                                                                                // Lunascape/Maxthon/Netfront/Jasmine/Blazer/Sleipnir\n            // Trident based\n            /(avant|iemobile|slim(?:browser|boat|jet))[\\/ ]?([\\d\\.]*)/i,        // Avant/IEMobile/SlimBrowser/SlimBoat/Slimjet\n            /(?:ms|\\()(ie) ([\\w\\.]+)/i,                                         // Internet Explorer\n\n            // Blink/Webkit/KHTML based                                         // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon\n            /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon)\\/([-\\w\\.]+)/i,\n                                                                                // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ//Vivaldi/DuckDuckGo/Klar/Helio/Dragon\n            /(heytap|ovi|115)browser\\/([\\d\\.]+)/i,                              // HeyTap/Ovi/115\n            /(weibo)__([\\d\\.]+)/i                                               // Weibo\n            ], [NAME, VERSION], [\n            /quark(?:pc)?\\/([-\\w\\.]+)/i                                         // Quark\n            ], [VERSION, [NAME, 'Quark']], [\n            /\\bddg\\/([\\w\\.]+)/i                                                 // DuckDuckGo\n            ], [VERSION, [NAME, 'DuckDuckGo']], [\n            /(?:\\buc? ?browser|(?:juc.+)ucweb)[\\/ ]?([\\w\\.]+)/i                 // UCBrowser\n            ], [VERSION, [NAME, 'UC'+BROWSER]], [\n            /microm.+\\bqbcore\\/([\\w\\.]+)/i,                                     // WeChat Desktop for Windows Built-in Browser\n            /\\bqbcore\\/([\\w\\.]+).+microm/i,\n            /micromessenger\\/([\\w\\.]+)/i                                        // WeChat\n            ], [VERSION, [NAME, 'WeChat']], [\n            /konqueror\\/([\\w\\.]+)/i                                             // Konqueror\n            ], [VERSION, [NAME, 'Konqueror']], [\n            /trident.+rv[: ]([\\w\\.]{1,9})\\b.+like gecko/i                       // IE11\n            ], [VERSION, [NAME, 'IE']], [\n            /ya(?:search)?browser\\/([\\w\\.]+)/i                                  // Yandex\n            ], [VERSION, [NAME, 'Yandex']], [\n            /slbrowser\\/([\\w\\.]+)/i                                             // Smart Lenovo Browser\n            ], [VERSION, [NAME, 'Smart Lenovo '+BROWSER]], [\n            /(avast|avg)\\/([\\w\\.]+)/i                                           // Avast/AVG Secure Browser\n            ], [[NAME, /(.+)/, '$1 Secure '+BROWSER], VERSION], [\n            /\\bfocus\\/([\\w\\.]+)/i                                               // Firefox Focus\n            ], [VERSION, [NAME, FIREFOX+' Focus']], [\n            /\\bopt\\/([\\w\\.]+)/i                                                 // Opera Touch\n            ], [VERSION, [NAME, OPERA+' Touch']], [\n            /coc_coc\\w+\\/([\\w\\.]+)/i                                            // Coc Coc Browser\n            ], [VERSION, [NAME, 'Coc Coc']], [\n            /dolfin\\/([\\w\\.]+)/i                                                // Dolphin\n            ], [VERSION, [NAME, 'Dolphin']], [\n            /coast\\/([\\w\\.]+)/i                                                 // Opera Coast\n            ], [VERSION, [NAME, OPERA+' Coast']], [\n            /miuibrowser\\/([\\w\\.]+)/i                                           // MIUI Browser\n            ], [VERSION, [NAME, 'MIUI' + SUFFIX_BROWSER]], [\n            /fxios\\/([\\w\\.-]+)/i                                                // Firefox for iOS\n            ], [VERSION, [NAME, FIREFOX]], [\n            /\\bqihoobrowser\\/?([\\w\\.]*)/i                                       // 360\n            ], [VERSION, [NAME, '360']], [\n            /\\b(qq)\\/([\\w\\.]+)/i                                                // QQ\n            ], [[NAME, /(.+)/, '$1Browser'], VERSION], [\n            /(oculus|sailfish|huawei|vivo|pico)browser\\/([\\w\\.]+)/i\n            ], [[NAME, /(.+)/, '$1' + SUFFIX_BROWSER], VERSION], [              // Oculus/Sailfish/HuaweiBrowser/VivoBrowser/PicoBrowser\n            /samsungbrowser\\/([\\w\\.]+)/i                                        // Samsung Internet\n            ], [VERSION, [NAME, SAMSUNG + ' Internet']], [\n            /metasr[\\/ ]?([\\d\\.]+)/i                                            // Sogou Explorer\n            ], [VERSION, [NAME, 'Sogou Explorer']], [\n            /(sogou)mo\\w+\\/([\\d\\.]+)/i                                          // Sogou Mobile\n            ], [[NAME, 'Sogou Mobile'], VERSION], [\n            /(electron)\\/([\\w\\.]+) safari/i,                                    // Electron-based App\n            /(tesla)(?: qtcarbrowser|\\/(20\\d\\d\\.[-\\w\\.]+))/i,                   // Tesla\n            /m?(qqbrowser|2345(?=browser|chrome|explorer))\\w*[\\/ ]?v?([\\w\\.]+)/i   // QQ/2345\n            ], [NAME, VERSION], [\n            /(lbbrowser|rekonq)/i,                                              // LieBao Browser/Rekonq\n            /\\[(linkedin)app\\]/i                                                // LinkedIn App for iOS & Android\n            ], [NAME], [\n            /ome\\/([\\w\\.]+) \\w* ?(iron) saf/i,                                  // Iron\n            /ome\\/([\\w\\.]+).+qihu (360)[es]e/i                                  // 360\n            ], [VERSION, NAME], [\n\n            // WebView\n            /((?:fban\\/fbios|fb_iab\\/fb4a)(?!.+fbav)|;fbav\\/([\\w\\.]+);)/i       // Facebook App for iOS & Android\n            ], [[NAME, FACEBOOK], VERSION], [\n            /(Klarna)\\/([\\w\\.]+)/i,                                             // Klarna Shopping Browser for iOS & Android\n            /(kakao(?:talk|story))[\\/ ]([\\w\\.]+)/i,                             // Kakao App\n            /(naver)\\(.*?(\\d+\\.[\\w\\.]+).*\\)/i,                                  // Naver InApp\n            /(daum)apps[\\/ ]([\\w\\.]+)/i,                                        // Daum App\n            /safari (line)\\/([\\w\\.]+)/i,                                        // Line App for iOS\n            /\\b(line)\\/([\\w\\.]+)\\/iab/i,                                        // Line App for Android\n            /(alipay)client\\/([\\w\\.]+)/i,                                       // Alipay\n            /(twitter)(?:and| f.+e\\/([\\w\\.]+))/i,                               // Twitter\n            /(chromium|instagram|snapchat)[\\/ ]([-\\w\\.]+)/i                     // Chromium/Instagram/Snapchat\n            ], [NAME, VERSION], [\n            /\\bgsa\\/([\\w\\.]+) .*safari\\//i                                      // Google Search Appliance on iOS\n            ], [VERSION, [NAME, 'GSA']], [\n            /musical_ly(?:.+app_?version\\/|_)([\\w\\.]+)/i                        // TikTok\n            ], [VERSION, [NAME, 'TikTok']], [\n\n            /headlesschrome(?:\\/([\\w\\.]+)| )/i                                  // Chrome Headless\n            ], [VERSION, [NAME, CHROME+' Headless']], [\n\n            / wv\\).+(chrome)\\/([\\w\\.]+)/i                                       // Chrome WebView\n            ], [[NAME, CHROME+' WebView'], VERSION], [\n\n            /droid.+ version\\/([\\w\\.]+)\\b.+(?:mobile safari|safari)/i           // Android Browser\n            ], [VERSION, [NAME, 'Android '+BROWSER]], [\n\n            /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\\/v?([\\w\\.]+)/i       // Chrome/OmniWeb/Arora/Tizen/Nokia\n            ], [NAME, VERSION], [\n\n            /version\\/([\\w\\.\\,]+) .*mobile\\/\\w+ (safari)/i                      // Mobile Safari\n            ], [VERSION, [NAME, 'Mobile Safari']], [\n            /version\\/([\\w(\\.|\\,)]+) .*(mobile ?safari|safari)/i                // Safari & Safari Mobile\n            ], [VERSION, NAME], [\n            /webkit.+?(mobile ?safari|safari)(\\/[\\w\\.]+)/i                      // Safari < 3.0\n            ], [NAME, [VERSION, strMapper, oldSafariMap]], [\n\n            /(webkit|khtml)\\/([\\w\\.]+)/i\n            ], [NAME, VERSION], [\n\n            // Gecko based\n            /(navigator|netscape\\d?)\\/([-\\w\\.]+)/i                              // Netscape\n            ], [[NAME, 'Netscape'], VERSION], [\n            /(wolvic|librewolf)\\/([\\w\\.]+)/i                                    // Wolvic/LibreWolf\n            ], [NAME, VERSION], [\n            /mobile vr; rv:([\\w\\.]+)\\).+firefox/i                               // Firefox Reality\n            ], [VERSION, [NAME, FIREFOX+' Reality']], [\n            /ekiohf.+(flow)\\/([\\w\\.]+)/i,                                       // Flow\n            /(swiftfox)/i,                                                      // Swiftfox\n            /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\\/ ]?([\\w\\.\\+]+)/i,\n                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror\n            /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\\/([-\\w\\.]+)$/i,\n                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix\n            /(firefox)\\/([\\w\\.]+)/i,                                            // Other Firefox-based\n            /(mozilla)\\/([\\w\\.]+) .+rv\\:.+gecko\\/\\d+/i,                         // Mozilla\n\n            // Other\n            /(amaya|dillo|doris|icab|ladybird|lynx|mosaic|netsurf|obigo|polaris|w3m|(?:go|ice|up)[\\. ]?browser)[-\\/ ]?v?([\\w\\.]+)/i,\n                                                                                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Obigo/Mosaic/Go/ICE/UP.Browser/Ladybird\n            /\\b(links) \\(([\\w\\.]+)/i                                            // Links\n            ], [NAME, [VERSION, /_/g, '.']], [\n            \n            /(cobalt)\\/([\\w\\.]+)/i                                              // Cobalt\n            ], [NAME, [VERSION, /master.|lts./, \"\"]]\n        ],\n\n        cpu : [[\n\n            /\\b((amd|x|x86[-_]?|wow|win)64)\\b/i                                 // AMD64 (x64)\n            ], [[ARCHITECTURE, 'amd64']], [\n\n            /(ia32(?=;))/i,                                                     // IA32 (quicktime)\n            /\\b((i[346]|x)86)(pc)?\\b/i                                          // IA32 (x86)\n            ], [[ARCHITECTURE, 'ia32']], [\n\n            /\\b(aarch64|arm(v?[89]e?l?|_?64))\\b/i                               // ARM64\n            ], [[ARCHITECTURE, 'arm64']], [\n\n            /\\b(arm(v[67])?ht?n?[fl]p?)\\b/i                                     // ARMHF\n            ], [[ARCHITECTURE, 'armhf']], [\n\n            // PocketPC mistakenly identified as PowerPC\n            /( (ce|mobile); ppc;|\\/[\\w\\.]+arm\\b)/i\n            ], [[ARCHITECTURE, 'arm']], [\n\n            /((ppc|powerpc)(64)?)( mac|;|\\))/i                                  // PowerPC\n            ], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [\n\n            / sun4\\w[;\\)]/i                                                     // SPARC\n            ], [[ARCHITECTURE, 'sparc']], [\n\n            /\\b(avr32|ia64(?=;)|68k(?=\\))|\\barm(?=v([1-7]|[5-7]1)l?|;|eabi)|(irix|mips|sparc)(64)?\\b|pa-risc)/i\n                                                                                // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC\n            ], [[ARCHITECTURE, lowerize]]\n        ],\n\n        device : [[\n\n            //////////////////////////\n            // MOBILES & TABLETS\n            /////////////////////////\n\n            // Samsung\n            /\\b(sch-i[89]0\\d|shw-m380s|sm-[ptx]\\w{2,4}|gt-[pn]\\d{2,4}|sgh-t8[56]9|nexus 10)/i\n            ], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [\n            /\\b((?:s[cgp]h|gt|sm)-(?![lr])\\w+|sc[g-]?[\\d]+a?|galaxy nexus)/i,\n            /samsung[- ]((?!sm-[lr])[-\\w]+)/i,\n            /sec-(sgh\\w+)/i\n            ], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [\n\n            // Apple\n            /(?:\\/|\\()(ip(?:hone|od)[\\w, ]*)(?:\\/|;)/i                          // iPod/iPhone\n            ], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [\n            /\\((ipad);[-\\w\\),; ]+apple/i,                                       // iPad\n            /applecoremedia\\/[\\w\\.]+ \\((ipad)/i,\n            /\\b(ipad)\\d\\d?,\\d\\d?[;\\]].+ios/i\n            ], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [\n            /(macintosh);/i\n            ], [MODEL, [VENDOR, APPLE]], [\n\n            // Sharp\n            /\\b(sh-?[altvz]?\\d\\d[a-ekm]?)/i\n            ], [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]], [\n\n            // Honor\n            /\\b((?:brt|eln|hey2?|gdi|jdn)-a?[lnw]09|(?:ag[rm]3?|jdn2|kob2)-a?[lw]0[09]hn)(?: bui|\\)|;)/i\n            ], [MODEL, [VENDOR, HONOR], [TYPE, TABLET]], [\n            /honor([-\\w ]+)[;\\)]/i\n            ], [MODEL, [VENDOR, HONOR], [TYPE, MOBILE]], [\n\n            // Huawei\n            /\\b((?:ag[rs][2356]?k?|bah[234]?|bg[2o]|bt[kv]|cmr|cpn|db[ry]2?|jdn2|got|kob2?k?|mon|pce|scm|sht?|[tw]gr|vrd)-[ad]?[lw][0125][09]b?|605hw|bg2-u03|(?:gem|fdr|m2|ple|t1)-[7a]0[1-4][lu]|t1-a2[13][lw]|mediapad[\\w\\. ]*(?= bui|\\)))\\b(?!.+d\\/s)/i\n            ], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [\n            /(?:huawei)([-\\w ]+)[;\\)]/i,\n            /\\b(nexus 6p|\\w{2,4}e?-[atu]?[ln][\\dx][012359c][adn]?)\\b(?!.+d\\/s)/i\n            ], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [\n\n            // Xiaomi\n            /oid[^\\)]+; (2[\\dbc]{4}(182|283|rp\\w{2})[cgl]|m2105k81a?c)(?: bui|\\))/i,\n            /\\b((?:red)?mi[-_ ]?pad[\\w- ]*)(?: bui|\\))/i                                // Mi Pad tablets\n            ],[[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, TABLET]], [\n\n            /\\b(poco[\\w ]+|m2\\d{3}j\\d\\d[a-z]{2})(?: bui|\\))/i,                  // Xiaomi POCO\n            /\\b; (\\w+) build\\/hm\\1/i,                                           // Xiaomi Hongmi 'numeric' models\n            /\\b(hm[-_ ]?note?[_ ]?(?:\\d\\w)?) bui/i,                             // Xiaomi Hongmi\n            /\\b(redmi[\\-_ ]?(?:note|k)?[\\w_ ]+)(?: bui|\\))/i,                   // Xiaomi Redmi\n            /oid[^\\)]+; (m?[12][0-389][01]\\w{3,6}[c-y])( bui|; wv|\\))/i,        // Xiaomi Redmi 'numeric' models\n            /\\b(mi[-_ ]?(?:a\\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\\d?\\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\\))/i, // Xiaomi Mi\n            / ([\\w ]+) miui\\/v?\\d/i\n            ], [[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, MOBILE]], [\n\n            // OPPO\n            /; (\\w+) bui.+ oppo/i,\n            /\\b(cph[12]\\d{3}|p(?:af|c[al]|d\\w|e[ar])[mt]\\d0|x9007|a101op)\\b/i\n            ], [MODEL, [VENDOR, OPPO], [TYPE, MOBILE]], [\n            /\\b(opd2(\\d{3}a?))(?: bui|\\))/i\n            ], [MODEL, [VENDOR, strMapper, { 'OnePlus' : ['304', '403', '203'], '*' : OPPO }], [TYPE, TABLET]], [\n\n            // Vivo\n            /vivo (\\w+)(?: bui|\\))/i,\n            /\\b(v[12]\\d{3}\\w?[at])(?: bui|;)/i\n            ], [MODEL, [VENDOR, 'Vivo'], [TYPE, MOBILE]], [\n\n            // Realme\n            /\\b(rmx[1-3]\\d{3})(?: bui|;|\\))/i\n            ], [MODEL, [VENDOR, 'Realme'], [TYPE, MOBILE]], [\n\n            // Motorola\n            /\\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\\b[\\w ]+build\\//i,\n            /\\bmot(?:orola)?[- ](\\w*)/i,\n            /((?:moto(?! 360)[\\w\\(\\) ]+|xt\\d{3,4}|nexus 6)(?= bui|\\)))/i\n            ], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [\n            /\\b(mz60\\d|xoom[2 ]{0,2}) build\\//i\n            ], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [\n\n            // LG\n            /((?=lg)?[vl]k\\-?\\d{3}) bui| 3\\.[-\\w; ]{10}lg?-([06cv9]{3,4})/i\n            ], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [\n            /(lm(?:-?f100[nv]?|-[\\w\\.]+)(?= bui|\\))|nexus [45])/i,\n            /\\blg[-e;\\/ ]+((?!browser|netcast|android tv|watch)\\w+)/i,\n            /\\blg-?([\\d\\w]+) bui/i\n            ], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [\n\n            // Lenovo\n            /(ideatab[-\\w ]+|602lv|d-42a|a101lv|a2109a|a3500-hv|s[56]000|pb-6505[my]|tb-?x?\\d{3,4}(?:f[cu]|xu|[av])|yt\\d?-[jx]?\\d+[lfmx])( bui|;|\\)|\\/)/i,\n            /lenovo ?(b[68]0[08]0-?[hf]?|tab(?:[\\w- ]+?)|tb[\\w-]{6,7})( bui|;|\\)|\\/)/i\n            ], [MODEL, [VENDOR, LENOVO], [TYPE, TABLET]], [\n\n            // Nokia\n            /(nokia) (t[12][01])/i\n            ], [VENDOR, MODEL, [TYPE, TABLET]], [\n            /(?:maemo|nokia).*(n900|lumia \\d+|rm-\\d+)/i,\n            /nokia[-_ ]?(([-\\w\\. ]*))/i\n            ], [[MODEL, /_/g, ' '], [TYPE, MOBILE], [VENDOR, 'Nokia']], [\n\n            // Google\n            /(pixel (c|tablet))\\b/i                                             // Google Pixel C/Tablet\n            ], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [\n            /droid.+; (pixel[\\daxl ]{0,6})(?: bui|\\))/i                         // Google Pixel\n            ], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [\n\n            // Sony\n            /droid.+; (a?\\d[0-2]{2}so|[c-g]\\d{4}|so[-gl]\\w+|xq-a\\w[4-7][12])(?= bui|\\).+chrome\\/(?![1-6]{0,1}\\d\\.))/i\n            ], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [\n            /sony tablet [ps]/i,\n            /\\b(?:sony)?sgp\\w+(?: bui|\\))/i\n            ], [[MODEL, 'Xperia Tablet'], [VENDOR, SONY], [TYPE, TABLET]], [\n\n            // OnePlus\n            / (kb2005|in20[12]5|be20[12][59])\\b/i,\n            /(?:one)?(?:plus)? (a\\d0\\d\\d)(?: b|\\))/i\n            ], [MODEL, [VENDOR, ONEPLUS], [TYPE, MOBILE]], [\n\n            // Amazon\n            /(alexa)webm/i,\n            /(kf[a-z]{2}wi|aeo(?!bc)\\w\\w)( bui|\\))/i,                           // Kindle Fire without Silk / Echo Show\n            /(kf[a-z]+)( bui|\\)).+silk\\//i                                      // Kindle Fire HD\n            ], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [\n            /((?:sd|kf)[0349hijorstuw]+)( bui|\\)).+silk\\//i                     // Fire Phone\n            ], [[MODEL, /(.+)/g, 'Fire Phone $1'], [VENDOR, AMAZON], [TYPE, MOBILE]], [\n\n            // BlackBerry\n            /(playbook);[-\\w\\),; ]+(rim)/i                                      // BlackBerry PlayBook\n            ], [MODEL, VENDOR, [TYPE, TABLET]], [\n            /\\b((?:bb[a-f]|st[hv])100-\\d)/i,\n            /\\(bb10; (\\w+)/i                                                    // BlackBerry 10\n            ], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [\n\n            // Asus\n            /(?:\\b|asus_)(transfo[prime ]{4,10} \\w+|eeepc|slider \\w+|nexus 7|padfone|p00[cj])/i\n            ], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [\n            / (z[bes]6[027][012][km][ls]|zenfone \\d\\w?)\\b/i\n            ], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [\n\n            // HTC\n            /(nexus 9)/i                                                        // HTC Nexus 9\n            ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [\n            /(htc)[-;_ ]{1,2}([\\w ]+(?=\\)| bui)|\\w+)/i,                         // HTC\n\n            // ZTE\n            /(zte)[- ]([\\w ]+?)(?: bui|\\/|\\))/i,\n            /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\\.))|sony(?!-bra))[-_ ]?([-\\w]*)/i         // Alcatel/GeeksPhone/Nexian/Panasonic/Sony\n            ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [\n\n            // TCL\n            /droid [\\w\\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])\\w*(\\)| bui)/i\n            ], [MODEL, [VENDOR, 'TCL'], [TYPE, TABLET]], [\n\n            // itel\n            /(itel) ((\\w+))/i\n            ], [[VENDOR, lowerize], MODEL, [TYPE, strMapper, { 'tablet' : ['p10001l', 'w7001'], '*' : 'mobile' }]], [\n\n            // Acer\n            /droid.+; ([ab][1-7]-?[0178a]\\d\\d?)/i\n            ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [\n\n            // Meizu\n            /droid.+; (m[1-5] note) bui/i,\n            /\\bmz-([-\\w]{2,})/i\n            ], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [\n                \n            // Ulefone\n            /; ((?:power )?armor(?:[\\w ]{0,8}))(?: bui|\\))/i\n            ], [MODEL, [VENDOR, 'Ulefone'], [TYPE, MOBILE]], [\n\n            // Energizer\n            /; (energy ?\\w+)(?: bui|\\))/i,\n            /; energizer ([\\w ]+)(?: bui|\\))/i\n            ], [MODEL, [VENDOR, 'Energizer'], [TYPE, MOBILE]], [\n\n            // Cat\n            /; cat (b35);/i,\n            /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\\))/i\n            ], [MODEL, [VENDOR, 'Cat'], [TYPE, MOBILE]], [\n\n            // Smartfren\n            /((?:new )?andromax[\\w- ]+)(?: bui|\\))/i\n            ], [MODEL, [VENDOR, 'Smartfren'], [TYPE, MOBILE]], [\n\n            // Nothing\n            /droid.+; (a(?:015|06[35]|142p?))/i\n            ], [MODEL, [VENDOR, 'Nothing'], [TYPE, MOBILE]], [\n\n            // Archos\n            /; (x67 5g|tikeasy \\w+|ac[1789]\\d\\w+)( b|\\))/i,\n            /archos ?(5|gamepad2?|([\\w ]*[t1789]|hello) ?\\d+[\\w ]*)( b|\\))/i\n            ], [MODEL, [VENDOR, 'Archos'], [TYPE, TABLET]], [\n            /archos ([\\w ]+)( b|\\))/i,\n            /; (ac[3-6]\\d\\w{2,8})( b|\\))/i \n            ], [MODEL, [VENDOR, 'Archos'], [TYPE, MOBILE]], [\n\n            // MIXED\n            /(imo) (tab \\w+)/i,                                                 // IMO\n            /(infinix) (x1101b?)/i                                              // Infinix XPad\n            ], [VENDOR, MODEL, [TYPE, TABLET]], [\n\n            /(blackberry|benq|palm(?=\\-)|sonyericsson|acer|asus(?! zenw)|dell|jolla|meizu|motorola|polytron|infinix|tecno|micromax|advan)[-_ ]?([-\\w]*)/i,\n                                                                                // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron/Infinix/Tecno/Micromax/Advan\n            /; (hmd|imo) ([\\w ]+?)(?: bui|\\))/i,                                // HMD/IMO\n            /(hp) ([\\w ]+\\w)/i,                                                 // HP iPAQ\n            /(microsoft); (lumia[\\w ]+)/i,                                      // Microsoft Lumia\n            /(lenovo)[-_ ]?([-\\w ]+?)(?: bui|\\)|\\/)/i,                          // Lenovo\n            /(oppo) ?([\\w ]+) bui/i                                             // OPPO\n            ], [VENDOR, MODEL, [TYPE, MOBILE]], [\n\n            /(kobo)\\s(ereader|touch)/i,                                         // Kobo\n            /(hp).+(touchpad(?!.+tablet)|tablet)/i,                             // HP TouchPad\n            /(kindle)\\/([\\w\\.]+)/i,                                             // Kindle\n            /(nook)[\\w ]+build\\/(\\w+)/i,                                        // Nook\n            /(dell) (strea[kpr\\d ]*[\\dko])/i,                                   // Dell Streak\n            /(le[- ]+pan)[- ]+(\\w{1,9}) bui/i,                                  // Le Pan Tablets\n            /(trinity)[- ]*(t\\d{3}) bui/i,                                      // Trinity Tablets\n            /(gigaset)[- ]+(q\\w{1,9}) bui/i,                                    // Gigaset Tablets\n            /(vodafone) ([\\w ]+)(?:\\)| bui)/i                                   // Vodafone\n            ], [VENDOR, MODEL, [TYPE, TABLET]], [\n\n            /(surface duo)/i                                                    // Surface Duo\n            ], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [\n            /droid [\\d\\.]+; (fp\\du?)(?: b|\\))/i                                 // Fairphone\n            ], [MODEL, [VENDOR, 'Fairphone'], [TYPE, MOBILE]], [\n            /(u304aa)/i                                                         // AT&T\n            ], [MODEL, [VENDOR, 'AT&T'], [TYPE, MOBILE]], [\n            /\\bsie-(\\w*)/i                                                      // Siemens\n            ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [\n            /\\b(rct\\w+) b/i                                                     // RCA Tablets\n            ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [\n            /\\b(venue[\\d ]{2,7}) b/i                                            // Dell Venue Tablets\n            ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [\n            /\\b(q(?:mv|ta)\\w+) b/i                                              // Verizon Tablet\n            ], [MODEL, [VENDOR, 'Verizon'], [TYPE, TABLET]], [\n            /\\b(?:barnes[& ]+noble |bn[rt])([\\w\\+ ]*) b/i                       // Barnes & Noble Tablet\n            ], [MODEL, [VENDOR, 'Barnes & Noble'], [TYPE, TABLET]], [\n            /\\b(tm\\d{3}\\w+) b/i\n            ], [MODEL, [VENDOR, 'NuVision'], [TYPE, TABLET]], [\n            /\\b(k88) b/i                                                        // ZTE K Series Tablet\n            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, TABLET]], [\n            /\\b(nx\\d{3}j) b/i                                                   // ZTE Nubia\n            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, MOBILE]], [\n            /\\b(gen\\d{3}) b.+49h/i                                              // Swiss GEN Mobile\n            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, MOBILE]], [\n            /\\b(zur\\d{3}) b/i                                                   // Swiss ZUR Tablet\n            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, TABLET]], [\n            /\\b((zeki)?tb.*\\b) b/i                                              // Zeki Tablets\n            ], [MODEL, [VENDOR, 'Zeki'], [TYPE, TABLET]], [\n            /\\b([yr]\\d{2}) b/i,\n            /\\b(dragon[- ]+touch |dt)(\\w{5}) b/i                                // Dragon Touch Tablet\n            ], [[VENDOR, 'Dragon Touch'], MODEL, [TYPE, TABLET]], [\n            /\\b(ns-?\\w{0,9}) b/i                                                // Insignia Tablets\n            ], [MODEL, [VENDOR, 'Insignia'], [TYPE, TABLET]], [\n            /\\b((nxa|next)-?\\w{0,9}) b/i                                        // NextBook Tablets\n            ], [MODEL, [VENDOR, 'NextBook'], [TYPE, TABLET]], [\n            /\\b(xtreme\\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i                  // Voice Xtreme Phones\n            ], [[VENDOR, 'Voice'], MODEL, [TYPE, MOBILE]], [\n            /\\b(lvtel\\-)?(v1[12]) b/i                                           // LvTel Phones\n            ], [[VENDOR, 'LvTel'], MODEL, [TYPE, MOBILE]], [\n            /\\b(ph-1) /i                                                        // Essential PH-1\n            ], [MODEL, [VENDOR, 'Essential'], [TYPE, MOBILE]], [\n            /\\b(v(100md|700na|7011|917g).*\\b) b/i                               // Envizen Tablets\n            ], [MODEL, [VENDOR, 'Envizen'], [TYPE, TABLET]], [\n            /\\b(trio[-\\w\\. ]+) b/i                                              // MachSpeed Tablets\n            ], [MODEL, [VENDOR, 'MachSpeed'], [TYPE, TABLET]], [\n            /\\btu_(1491) b/i                                                    // Rotor Tablets\n            ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [\n            /((?:tegranote|shield t(?!.+d tv))[\\w- ]*?)(?: b|\\))/i              // Nvidia Tablets\n            ], [MODEL, [VENDOR, NVIDIA], [TYPE, TABLET]], [\n            /(sprint) (\\w+)/i                                                   // Sprint Phones\n            ], [VENDOR, MODEL, [TYPE, MOBILE]], [\n            /(kin\\.[onetw]{3})/i                                                // Microsoft Kin\n            ], [[MODEL, /\\./g, ' '], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [\n            /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\\)/i             // Zebra\n            ], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [\n            /droid.+; (ec30|ps20|tc[2-8]\\d[kx])\\)/i\n            ], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [\n\n            ///////////////////\n            // SMARTTVS\n            ///////////////////\n\n            /smart-tv.+(samsung)/i                                              // Samsung\n            ], [VENDOR, [TYPE, SMARTTV]], [\n            /hbbtv.+maple;(\\d+)/i\n            ], [[MODEL, /^/, 'SmartTV'], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [\n            /(nux; netcast.+smarttv|lg (netcast\\.tv-201\\d|android tv))/i        // LG SmartTV\n            ], [[VENDOR, LG], [TYPE, SMARTTV]], [\n            /(apple) ?tv/i                                                      // Apple TV\n            ], [VENDOR, [MODEL, APPLE+' TV'], [TYPE, SMARTTV]], [\n            /crkey/i                                                            // Google Chromecast\n            ], [[MODEL, CHROME+'cast'], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [\n            /droid.+aft(\\w+)( bui|\\))/i                                         // Fire TV\n            ], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [\n            /(shield \\w+ tv)/i                                                  // Nvidia Shield TV\n            ], [MODEL, [VENDOR, NVIDIA], [TYPE, SMARTTV]], [\n            /\\(dtv[\\);].+(aquos)/i,\n            /(aquos-tv[\\w ]+)\\)/i                                               // Sharp\n            ], [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],[\n            /(bravia[\\w ]+)( bui|\\))/i                                              // Sony\n            ], [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]], [\n            /(mi(tv|box)-?\\w+) bui/i                                            // Xiaomi\n            ], [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]], [\n            /Hbbtv.*(technisat) (.*);/i                                         // TechniSAT\n            ], [VENDOR, MODEL, [TYPE, SMARTTV]], [\n            /\\b(roku)[\\dx]*[\\)\\/]((?:dvp-)?[\\d\\.]*)/i,                          // Roku\n            /hbbtv\\/\\d+\\.\\d+\\.\\d+ +\\([\\w\\+ ]*; *([\\w\\d][^;]*);([^;]*)/i         // HbbTV devices\n            ], [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]], [\n                                                                                // SmartTV from Unidentified Vendors\n            /droid.+; ([\\w- ]+) (?:android tv|smart[- ]?tv)/i\n            ], [MODEL, [TYPE, SMARTTV]], [\n            /\\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\\b/i\n            ], [[TYPE, SMARTTV]], [\n\n            ///////////////////\n            // CONSOLES\n            ///////////////////\n\n            /(ouya)/i,                                                          // Ouya\n            /(nintendo) ([wids3utch]+)/i                                        // Nintendo\n            ], [VENDOR, MODEL, [TYPE, CONSOLE]], [\n            /droid.+; (shield)( bui|\\))/i                                       // Nvidia Portable\n            ], [MODEL, [VENDOR, NVIDIA], [TYPE, CONSOLE]], [\n            /(playstation \\w+)/i                                                // Playstation\n            ], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [\n            /\\b(xbox(?: one)?(?!; xbox))[\\); ]/i                                // Microsoft Xbox\n            ], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [\n\n            ///////////////////\n            // WEARABLES\n            ///////////////////\n\n            /\\b(sm-[lr]\\d\\d[0156][fnuw]?s?|gear live)\\b/i                       // Samsung Galaxy Watch\n            ], [MODEL, [VENDOR, SAMSUNG], [TYPE, WEARABLE]], [\n            /((pebble))app/i,                                                   // Pebble\n            /(asus|google|lg|oppo) ((pixel |zen)?watch[\\w ]*)( bui|\\))/i        // Asus ZenWatch / LG Watch / Pixel Watch\n            ], [VENDOR, MODEL, [TYPE, WEARABLE]], [\n            /(ow(?:19|20)?we?[1-3]{1,3})/i                                      // Oppo Watch\n            ], [MODEL, [VENDOR, OPPO], [TYPE, WEARABLE]], [\n            /(watch)(?: ?os[,\\/]|\\d,\\d\\/)[\\d\\.]+/i                              // Apple Watch\n            ], [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]], [\n            /(opwwe\\d{3})/i                                                     // OnePlus Watch\n            ], [MODEL, [VENDOR, ONEPLUS], [TYPE, WEARABLE]], [\n            /(moto 360)/i                                                       // Motorola 360\n            ], [MODEL, [VENDOR, MOTOROLA], [TYPE, WEARABLE]], [\n            /(smartwatch 3)/i                                                   // Sony SmartWatch\n            ], [MODEL, [VENDOR, SONY], [TYPE, WEARABLE]], [\n            /(g watch r)/i                                                      // LG G Watch R\n            ], [MODEL, [VENDOR, LG], [TYPE, WEARABLE]], [\n            /droid.+; (wt63?0{2,3})\\)/i\n            ], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [\n\n            ///////////////////\n            // XR\n            ///////////////////\n\n            /droid.+; (glass) \\d/i                                              // Google Glass\n            ], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [\n            /(pico) (4|neo3(?: link|pro)?)/i                                    // Pico\n            ], [VENDOR, MODEL, [TYPE, WEARABLE]], [\n            /; (quest( \\d| pro)?)/i                                             // Oculus Quest\n            ], [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]], [\n\n            ///////////////////\n            // EMBEDDED\n            ///////////////////\n\n            /(tesla)(?: qtcarbrowser|\\/[-\\w\\.]+)/i                              // Tesla\n            ], [VENDOR, [TYPE, EMBEDDED]], [\n            /(aeobc)\\b/i                                                        // Echo Dot\n            ], [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]], [\n            /(homepod).+mac os/i                                                // Apple HomePod\n            ], [MODEL, [VENDOR, APPLE], [TYPE, EMBEDDED]], [\n            /windows iot/i\n            ], [[TYPE, EMBEDDED]], [\n\n            ////////////////////\n            // MIXED (GENERIC)\n            ///////////////////\n\n            /droid .+?; ([^;]+?)(?: bui|; wv\\)|\\) applew).+? mobile safari/i    // Android Phones from Unidentified Vendors\n            ], [MODEL, [TYPE, MOBILE]], [\n            /droid .+?; ([^;]+?)(?: bui|\\) applew).+?(?! mobile) safari/i       // Android Tablets from Unidentified Vendors\n            ], [MODEL, [TYPE, TABLET]], [\n            /\\b((tablet|tab)[;\\/]|focus\\/\\d(?!.+mobile))/i                      // Unidentifiable Tablet\n            ], [[TYPE, TABLET]], [\n            /(phone|mobile(?:[;\\/]| [ \\w\\/\\.]*safari)|pda(?=.+windows ce))/i    // Unidentifiable Mobile\n            ], [[TYPE, MOBILE]], [\n            /droid .+?; ([\\w\\. -]+)( bui|\\))/i                                  // Generic Android Device\n            ], [MODEL, [VENDOR, 'Generic']]\n        ],\n\n        engine : [[\n\n            /windows.+ edge\\/([\\w\\.]+)/i                                       // EdgeHTML\n            ], [VERSION, [NAME, EDGE+'HTML']], [\n\n            /(arkweb)\\/([\\w\\.]+)/i                                              // ArkWeb\n            ], [NAME, VERSION], [\n\n            /webkit\\/537\\.36.+chrome\\/(?!27)([\\w\\.]+)/i                         // Blink\n            ], [VERSION, [NAME, 'Blink']], [\n\n            /(presto)\\/([\\w\\.]+)/i,                                             // Presto\n            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\\/([\\w\\.]+)/i, // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna/Servo\n            /ekioh(flow)\\/([\\w\\.]+)/i,                                          // Flow\n            /(khtml|tasman|links)[\\/ ]\\(?([\\w\\.]+)/i,                           // KHTML/Tasman/Links\n            /(icab)[\\/ ]([23]\\.[\\d\\.]+)/i,                                      // iCab\n\n            /\\b(libweb)/i                                                       // LibWeb\n            ], [NAME, VERSION], [\n            /ladybird\\//i\n            ], [[NAME, 'LibWeb']], [\n\n            /rv\\:([\\w\\.]{1,9})\\b.+(gecko)/i                                     // Gecko\n            ], [VERSION, NAME]\n        ],\n\n        os : [[\n\n            // Windows\n            /microsoft (windows) (vista|xp)/i                                   // Windows (iTunes)\n            ], [NAME, VERSION], [\n            /(windows (?:phone(?: os)?|mobile|iot))[\\/ ]?([\\d\\.\\w ]*)/i         // Windows Phone\n            ], [NAME, [VERSION, strMapper, windowsVersionMap]], [\n            /windows nt 6\\.2; (arm)/i,                                          // Windows RT\n            /windows[\\/ ]([ntce\\d\\. ]+\\w)(?!.+xbox)/i,\n            /(?:win(?=3|9|n)|win 9x )([nt\\d\\.]+)/i\n            ], [[VERSION, strMapper, windowsVersionMap], [NAME, 'Windows']], [\n\n            // iOS/macOS\n            /[adehimnop]{4,7}\\b(?:.*os ([\\w]+) like mac|; opera)/i,             // iOS\n            /(?:ios;fbsv\\/|iphone.+ios[\\/ ])([\\d\\.]+)/i,\n            /cfnetwork\\/.+darwin/i\n            ], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [\n            /(mac os x) ?([\\w\\. ]*)/i,\n            /(macintosh|mac_powerpc\\b)(?!.+haiku)/i                             // Mac OS\n            ], [[NAME, MAC_OS], [VERSION, /_/g, '.']], [\n\n            // Mobile OSes\n            /droid ([\\w\\.]+)\\b.+(android[- ]x86|harmonyos)/i                    // Android-x86/HarmonyOS\n            ], [VERSION, NAME], [                                               \n            /(ubuntu) ([\\w\\.]+) like android/i                                  // Ubuntu Touch\n            ], [[NAME, /(.+)/, '$1 Touch'], VERSION], [\n                                                                                // Android/Blackberry/WebOS/QNX/Bada/RIM/KaiOS/Maemo/MeeGo/S40/Sailfish OS/OpenHarmony/Tizen\n            /(android|bada|blackberry|kaios|maemo|meego|openharmony|qnx|rim tablet os|sailfish|series40|symbian|tizen|webos)\\w*[-\\/; ]?([\\d\\.]*)/i\n            ], [NAME, VERSION], [\n            /\\(bb(10);/i                                                        // BlackBerry 10\n            ], [VERSION, [NAME, BLACKBERRY]], [\n            /(?:symbian ?os|symbos|s60(?=;)|series ?60)[-\\/ ]?([\\w\\.]*)/i       // Symbian\n            ], [VERSION, [NAME, 'Symbian']], [\n            /mozilla\\/[\\d\\.]+ \\((?:mobile|tablet|tv|mobile; [\\w ]+); rv:.+ gecko\\/([\\w\\.]+)/i // Firefox OS\n            ], [VERSION, [NAME, FIREFOX+' OS']], [\n            /web0s;.+rt(tv)/i,\n            /\\b(?:hp)?wos(?:browser)?\\/([\\w\\.]+)/i                              // WebOS\n            ], [VERSION, [NAME, 'webOS']], [\n            /watch(?: ?os[,\\/]|\\d,\\d\\/)([\\d\\.]+)/i                              // watchOS\n            ], [VERSION, [NAME, 'watchOS']], [\n\n            // Google Chromecast\n            /crkey\\/([\\d\\.]+)/i                                                 // Google Chromecast\n            ], [VERSION, [NAME, CHROME+'cast']], [\n            /(cros) [\\w]+(?:\\)| ([\\w\\.]+)\\b)/i                                  // Chromium OS\n            ], [[NAME, CHROMIUM_OS], VERSION],[\n\n            // Smart TVs\n            /panasonic;(viera)/i,                                               // Panasonic Viera\n            /(netrange)mmh/i,                                                   // Netrange\n            /(nettv)\\/(\\d+\\.[\\w\\.]+)/i,                                         // NetTV\n\n            // Console\n            /(nintendo|playstation) ([wids345portablevuch]+)/i,                 // Nintendo/Playstation\n            /(xbox); +xbox ([^\\);]+)/i,                                         // Microsoft Xbox (360, One, X, S, Series X, Series S)\n\n            // Other\n            /\\b(joli|palm)\\b ?(?:os)?\\/?([\\w\\.]*)/i,                            // Joli/Palm\n            /(mint)[\\/\\(\\) ]?(\\w*)/i,                                           // Mint\n            /(mageia|vectorlinux)[; ]/i,                                        // Mageia/VectorLinux\n            /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\\/ ]?(?!chrom|package)([-\\w\\.]*)/i,\n                                                                                // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire\n            /(hurd|linux)(?: arm\\w*| x86\\w*| ?)([\\w\\.]*)/i,                     // Hurd/Linux\n            /(gnu) ?([\\w\\.]*)/i,                                                // GNU\n            /\\b([-frentopcghs]{0,5}bsd|dragonfly)[\\/ ]?(?!amd|[ix346]{1,2}86)([\\w\\.]*)/i, // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly\n            /(haiku) (\\w+)/i                                                    // Haiku\n            ], [NAME, VERSION], [\n            /(sunos) ?([\\w\\.\\d]*)/i                                             // Solaris\n            ], [[NAME, 'Solaris'], VERSION], [\n            /((?:open)?solaris)[-\\/ ]?([\\w\\.]*)/i,                              // Solaris\n            /(aix) ((\\d)(?=\\.|\\)| )[\\w\\.])*/i,                                  // AIX\n            /\\b(beos|os\\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS\n            /(unix) ?([\\w\\.]*)/i                                                // UNIX\n            ], [NAME, VERSION]\n        ]\n    };\n\n    /////////////////\n    // Constructor\n    ////////////////\n\n    var UAParser = function (ua, extensions) {\n\n        if (typeof ua === OBJ_TYPE) {\n            extensions = ua;\n            ua = undefined;\n        }\n\n        if (!(this instanceof UAParser)) {\n            return new UAParser(ua, extensions).getResult();\n        }\n\n        var _navigator = (typeof window !== UNDEF_TYPE && window.navigator) ? window.navigator : undefined;\n        var _ua = ua || ((_navigator && _navigator.userAgent) ? _navigator.userAgent : EMPTY);\n        var _uach = (_navigator && _navigator.userAgentData) ? _navigator.userAgentData : undefined;\n        var _rgxmap = extensions ? extend(regexes, extensions) : regexes;\n        var _isSelfNav = _navigator && _navigator.userAgent == _ua;\n\n        this.getBrowser = function () {\n            var _browser = {};\n            _browser[NAME] = undefined;\n            _browser[VERSION] = undefined;\n            rgxMapper.call(_browser, _ua, _rgxmap.browser);\n            _browser[MAJOR] = majorize(_browser[VERSION]);\n            // Brave-specific detection\n            if (_isSelfNav && _navigator && _navigator.brave && typeof _navigator.brave.isBrave == FUNC_TYPE) {\n                _browser[NAME] = 'Brave';\n            }\n            return _browser;\n        };\n        this.getCPU = function () {\n            var _cpu = {};\n            _cpu[ARCHITECTURE] = undefined;\n            rgxMapper.call(_cpu, _ua, _rgxmap.cpu);\n            return _cpu;\n        };\n        this.getDevice = function () {\n            var _device = {};\n            _device[VENDOR] = undefined;\n            _device[MODEL] = undefined;\n            _device[TYPE] = undefined;\n            rgxMapper.call(_device, _ua, _rgxmap.device);\n            if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {\n                _device[TYPE] = MOBILE;\n            }\n            // iPadOS-specific detection: identified as Mac, but has some iOS-only properties\n            if (_isSelfNav && _device[MODEL] == 'Macintosh' && _navigator && typeof _navigator.standalone !== UNDEF_TYPE && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2) {\n                _device[MODEL] = 'iPad';\n                _device[TYPE] = TABLET;\n            }\n            return _device;\n        };\n        this.getEngine = function () {\n            var _engine = {};\n            _engine[NAME] = undefined;\n            _engine[VERSION] = undefined;\n            rgxMapper.call(_engine, _ua, _rgxmap.engine);\n            return _engine;\n        };\n        this.getOS = function () {\n            var _os = {};\n            _os[NAME] = undefined;\n            _os[VERSION] = undefined;\n            rgxMapper.call(_os, _ua, _rgxmap.os);\n            if (_isSelfNav && !_os[NAME] && _uach && _uach.platform && _uach.platform != 'Unknown') {\n                _os[NAME] = _uach.platform  \n                                    .replace(/chrome os/i, CHROMIUM_OS)\n                                    .replace(/macos/i, MAC_OS);           // backward compatibility\n            }\n            return _os;\n        };\n        this.getResult = function () {\n            return {\n                ua      : this.getUA(),\n                browser : this.getBrowser(),\n                engine  : this.getEngine(),\n                os      : this.getOS(),\n                device  : this.getDevice(),\n                cpu     : this.getCPU()\n            };\n        };\n        this.getUA = function () {\n            return _ua;\n        };\n        this.setUA = function (ua) {\n            _ua = (typeof ua === STR_TYPE && ua.length > UA_MAX_LENGTH) ? trim(ua, UA_MAX_LENGTH) : ua;\n            return this;\n        };\n        this.setUA(_ua);\n        return this;\n    };\n\n    UAParser.VERSION = LIBVERSION;\n    UAParser.BROWSER =  enumerize([NAME, VERSION, MAJOR]);\n    UAParser.CPU = enumerize([ARCHITECTURE]);\n    UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);\n    UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);\n\n    ///////////\n    // Export\n    //////////\n\n    // check js environment\n    if (typeof(exports) !== UNDEF_TYPE) {\n        // nodejs env\n        if (\"object\" !== UNDEF_TYPE && module.exports) {\n            exports = module.exports = UAParser;\n        }\n        exports.UAParser = UAParser;\n    } else {\n        // requirejs env (optional)\n        if (\"function\" === FUNC_TYPE && __webpack_require__.amdO) {\n            !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n                return UAParser;\n            }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n        } else if (typeof window !== UNDEF_TYPE) {\n            // browser env\n            window.UAParser = UAParser;\n        }\n    }\n\n    // jQuery/Zepto specific (optional)\n    // Note:\n    //   In AMD env the global scope should be kept clean, but jQuery is an exception.\n    //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,\n    //   and we should catch that.\n    var $ = typeof window !== UNDEF_TYPE && (window.jQuery || window.Zepto);\n    if ($ && !$.ua) {\n        var parser = new UAParser();\n        $.ua = parser.getResult();\n        $.ua.get = function () {\n            return parser.getUA();\n        };\n        $.ua.set = function (ua) {\n            parser.setUA(ua);\n            var result = parser.getResult();\n            for (var prop in result) {\n                $.ua[prop] = result[prop];\n            }\n        };\n    }\n\n})(typeof window === 'object' ? window : this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91YS1wYXJzZXItanMvc3JjL3VhLXBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VhLXBhcnNlci1qcy9zcmMvdWEtcGFyc2VyLmpzP2E3NDkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vKiBVQVBhcnNlci5qcyB2MS4wLjQxXG4gICBDb3B5cmlnaHQgwqkgMjAxMi0yMDI1IEZhaXNhbCBTYWxtYW4gPGZAZmFpc2FsbWFuLmNvbT5cbiAgIE1JVCBMaWNlbnNlICovLypcbiAgIERldGVjdCBCcm93c2VyLCBFbmdpbmUsIE9TLCBDUFUsIGFuZCBEZXZpY2UgdHlwZS9tb2RlbCBmcm9tIFVzZXItQWdlbnQgZGF0YS5cbiAgIFN1cHBvcnRzIGJyb3dzZXIgJiBub2RlLmpzIGVudmlyb25tZW50LiBcbiAgIERlbW8gICA6IGh0dHBzOi8vZmFpc2FsbWFuLmdpdGh1Yi5pby91YS1wYXJzZXItanNcbiAgIFNvdXJjZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWlzYWxtYW4vdWEtcGFyc2VyLWpzICovXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuKGZ1bmN0aW9uICh3aW5kb3csIHVuZGVmaW5lZCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBDb25zdGFudHNcbiAgICAvLy8vLy8vLy8vLy8vXG5cblxuICAgIHZhciBMSUJWRVJTSU9OICA9ICcxLjAuNDEnLFxuICAgICAgICBFTVBUWSAgICAgICA9ICcnLFxuICAgICAgICBVTktOT1dOICAgICA9ICc/JyxcbiAgICAgICAgRlVOQ19UWVBFICAgPSAnZnVuY3Rpb24nLFxuICAgICAgICBVTkRFRl9UWVBFICA9ICd1bmRlZmluZWQnLFxuICAgICAgICBPQkpfVFlQRSAgICA9ICdvYmplY3QnLFxuICAgICAgICBTVFJfVFlQRSAgICA9ICdzdHJpbmcnLFxuICAgICAgICBNQUpPUiAgICAgICA9ICdtYWpvcicsXG4gICAgICAgIE1PREVMICAgICAgID0gJ21vZGVsJyxcbiAgICAgICAgTkFNRSAgICAgICAgPSAnbmFtZScsXG4gICAgICAgIFRZUEUgICAgICAgID0gJ3R5cGUnLFxuICAgICAgICBWRU5ET1IgICAgICA9ICd2ZW5kb3InLFxuICAgICAgICBWRVJTSU9OICAgICA9ICd2ZXJzaW9uJyxcbiAgICAgICAgQVJDSElURUNUVVJFPSAnYXJjaGl0ZWN0dXJlJyxcbiAgICAgICAgQ09OU09MRSAgICAgPSAnY29uc29sZScsXG4gICAgICAgIE1PQklMRSAgICAgID0gJ21vYmlsZScsXG4gICAgICAgIFRBQkxFVCAgICAgID0gJ3RhYmxldCcsXG4gICAgICAgIFNNQVJUVFYgICAgID0gJ3NtYXJ0dHYnLFxuICAgICAgICBXRUFSQUJMRSAgICA9ICd3ZWFyYWJsZScsXG4gICAgICAgIEVNQkVEREVEICAgID0gJ2VtYmVkZGVkJyxcbiAgICAgICAgVUFfTUFYX0xFTkdUSCA9IDUwMDtcblxuICAgIHZhciBBTUFaT04gID0gJ0FtYXpvbicsXG4gICAgICAgIEFQUExFICAgPSAnQXBwbGUnLFxuICAgICAgICBBU1VTICAgID0gJ0FTVVMnLFxuICAgICAgICBCTEFDS0JFUlJZID0gJ0JsYWNrQmVycnknLFxuICAgICAgICBCUk9XU0VSID0gJ0Jyb3dzZXInLFxuICAgICAgICBDSFJPTUUgID0gJ0Nocm9tZScsXG4gICAgICAgIEVER0UgICAgPSAnRWRnZScsXG4gICAgICAgIEZJUkVGT1ggPSAnRmlyZWZveCcsXG4gICAgICAgIEdPT0dMRSAgPSAnR29vZ2xlJyxcbiAgICAgICAgSE9OT1IgICA9ICdIb25vcicsXG4gICAgICAgIEhVQVdFSSAgPSAnSHVhd2VpJyxcbiAgICAgICAgTEVOT1ZPICA9ICdMZW5vdm8nLFxuICAgICAgICBMRyAgICAgID0gJ0xHJyxcbiAgICAgICAgTUlDUk9TT0ZUID0gJ01pY3Jvc29mdCcsXG4gICAgICAgIE1PVE9ST0xBICA9ICdNb3Rvcm9sYScsXG4gICAgICAgIE5WSURJQSAgPSAnTnZpZGlhJyxcbiAgICAgICAgT05FUExVUyA9ICdPbmVQbHVzJyxcbiAgICAgICAgT1BFUkEgICA9ICdPcGVyYScsXG4gICAgICAgIE9QUE8gICAgPSAnT1BQTycsXG4gICAgICAgIFNBTVNVTkcgPSAnU2Ftc3VuZycsXG4gICAgICAgIFNIQVJQICAgPSAnU2hhcnAnLFxuICAgICAgICBTT05ZICAgID0gJ1NvbnknLFxuICAgICAgICBYSUFPTUkgID0gJ1hpYW9taScsXG4gICAgICAgIFpFQlJBICAgPSAnWmVicmEnLFxuICAgICAgICBGQUNFQk9PSyAgICA9ICdGYWNlYm9vaycsXG4gICAgICAgIENIUk9NSVVNX09TID0gJ0Nocm9taXVtIE9TJyxcbiAgICAgICAgTUFDX09TICA9ICdNYWMgT1MnLFxuICAgICAgICBTVUZGSVhfQlJPV1NFUiA9ICcgQnJvd3Nlcic7XG5cbiAgICAvLy8vLy8vLy8vL1xuICAgIC8vIEhlbHBlclxuICAgIC8vLy8vLy8vLy9cblxuICAgIHZhciBleHRlbmQgPSBmdW5jdGlvbiAocmVnZXhlcywgZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgdmFyIG1lcmdlZFJlZ2V4ZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gcmVnZXhlcykge1xuICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb25zW2ldICYmIGV4dGVuc2lvbnNbaV0ubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRSZWdleGVzW2ldID0gZXh0ZW5zaW9uc1tpXS5jb25jYXQocmVnZXhlc1tpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkUmVnZXhlc1tpXSA9IHJlZ2V4ZXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlZFJlZ2V4ZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcml6ZSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgICAgICAgIHZhciBlbnVtcyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGVudW1zW2FycltpXS50b1VwcGVyQ2FzZSgpXSA9IGFycltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbnVtcztcbiAgICAgICAgfSxcbiAgICAgICAgaGFzID0gZnVuY3Rpb24gKHN0cjEsIHN0cjIpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygc3RyMSA9PT0gU1RSX1RZUEUgPyBsb3dlcml6ZShzdHIyKS5pbmRleE9mKGxvd2VyaXplKHN0cjEpKSAhPT0gLTEgOiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgbG93ZXJpemUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1ham9yaXplID0gZnVuY3Rpb24gKHZlcnNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YodmVyc2lvbikgPT09IFNUUl9UWVBFID8gdmVyc2lvbi5yZXBsYWNlKC9bXlxcZFxcLl0vZywgRU1QVFkpLnNwbGl0KCcuJylbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHRyaW0gPSBmdW5jdGlvbiAoc3RyLCBsZW4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yoc3RyKSA9PT0gU1RSX1RZUEUpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXlxcc1xccyovLCBFTVBUWSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZihsZW4pID09PSBVTkRFRl9UWVBFID8gc3RyIDogc3RyLnN1YnN0cmluZygwLCBVQV9NQVhfTEVOR1RIKTtcbiAgICAgICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gTWFwIGhlbHBlclxuICAgIC8vLy8vLy8vLy8vLy8vXG5cbiAgICB2YXIgcmd4TWFwcGVyID0gZnVuY3Rpb24gKHVhLCBhcnJheXMpIHtcblxuICAgICAgICAgICAgdmFyIGkgPSAwLCBqLCBrLCBwLCBxLCBtYXRjaGVzLCBtYXRjaDtcblxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGFsbCByZWdleGVzIG1hcHNcbiAgICAgICAgICAgIHdoaWxlIChpIDwgYXJyYXlzLmxlbmd0aCAmJiAhbWF0Y2hlcykge1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlZ2V4ID0gYXJyYXlzW2ldLCAgICAgICAvLyBldmVuIHNlcXVlbmNlICgwLDIsNCwuLilcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMgPSBhcnJheXNbaSArIDFdOyAgIC8vIG9kZCBzZXF1ZW5jZSAoMSwzLDUsLi4pXG4gICAgICAgICAgICAgICAgaiA9IGsgPSAwO1xuXG4gICAgICAgICAgICAgICAgLy8gdHJ5IG1hdGNoaW5nIHVhc3RyaW5nIHdpdGggcmVnZXhlc1xuICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgcmVnZXgubGVuZ3RoICYmICFtYXRjaGVzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWdleFtqXSkgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gcmVnZXhbaisrXS5leGVjKHVhKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoISFtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHAgPSAwOyBwIDwgcHJvcHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoZXNbKytrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gcHJvcHNbcF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZ2l2ZW4gcHJvcGVydHkgaXMgYWN0dWFsbHkgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHEgPT09IE9CSl9UWVBFICYmIHEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcVsxXSA9PSBGVU5DX1RZUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhc3NpZ24gbW9kaWZpZWQgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FbMF1dID0gcVsxXS5jYWxsKHRoaXMsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNzaWduIGdpdmVuIHZhbHVlLCBpZ25vcmUgcmVnZXggbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FbMF1dID0gcVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgd2hldGhlciBmdW5jdGlvbiBvciByZWdleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBxWzFdID09PSBGVU5DX1RZUEUgJiYgIShxWzFdLmV4ZWMgJiYgcVsxXS50ZXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgZnVuY3Rpb24gKHVzdWFsbHkgc3RyaW5nIG1hcHBlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FbMF1dID0gbWF0Y2ggPyBxWzFdLmNhbGwodGhpcywgbWF0Y2gsIHFbMl0pIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzYW5pdGl6ZSBtYXRjaCB1c2luZyBnaXZlbiByZWdleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcVswXV0gPSBtYXRjaCA/IG1hdGNoLnJlcGxhY2UocVsxXSwgcVsyXSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FbMF1dID0gbWF0Y2ggPyBxWzNdLmNhbGwodGhpcywgbWF0Y2gucmVwbGFjZShxWzFdLCBxWzJdKSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FdID0gbWF0Y2ggPyBtYXRjaCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHN0ck1hcHBlciA9IGZ1bmN0aW9uIChzdHIsIG1hcCkge1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIG1hcCkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGN1cnJlbnQgdmFsdWUgaXMgYXJyYXlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1hcFtpXSA9PT0gT0JKX1RZUEUgJiYgbWFwW2ldLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXBbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXMobWFwW2ldW2pdLCBzdHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpID09PSBVTktOT1dOKSA/IHVuZGVmaW5lZCA6IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhcyhtYXBbaV0sIHN0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpID09PSBVTktOT1dOKSA/IHVuZGVmaW5lZCA6IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hcC5oYXNPd25Qcm9wZXJ0eSgnKicpID8gbWFwWycqJ10gOiBzdHI7XG4gICAgfTtcblxuICAgIC8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFN0cmluZyBtYXBcbiAgICAvLy8vLy8vLy8vLy8vL1xuXG4gICAgLy8gU2FmYXJpIDwgMy4wXG4gICAgdmFyIG9sZFNhZmFyaU1hcCA9IHtcbiAgICAgICAgICAgICcxLjAnICAgOiAnLzgnLFxuICAgICAgICAgICAgJzEuMicgICA6ICcvMScsXG4gICAgICAgICAgICAnMS4zJyAgIDogJy8zJyxcbiAgICAgICAgICAgICcyLjAnICAgOiAnLzQxMicsXG4gICAgICAgICAgICAnMi4wLjInIDogJy80MTYnLFxuICAgICAgICAgICAgJzIuMC4zJyA6ICcvNDE3JyxcbiAgICAgICAgICAgICcyLjAuNCcgOiAnLzQxOScsXG4gICAgICAgICAgICAnPycgICAgIDogJy8nXG4gICAgICAgIH0sXG4gICAgICAgIHdpbmRvd3NWZXJzaW9uTWFwID0ge1xuICAgICAgICAgICAgJ01FJyAgICAgICAgOiAnNC45MCcsXG4gICAgICAgICAgICAnTlQgMy4xMScgICA6ICdOVDMuNTEnLFxuICAgICAgICAgICAgJ05UIDQuMCcgICAgOiAnTlQ0LjAnLFxuICAgICAgICAgICAgJzIwMDAnICAgICAgOiAnTlQgNS4wJyxcbiAgICAgICAgICAgICdYUCcgICAgICAgIDogWydOVCA1LjEnLCAnTlQgNS4yJ10sXG4gICAgICAgICAgICAnVmlzdGEnICAgICA6ICdOVCA2LjAnLFxuICAgICAgICAgICAgJzcnICAgICAgICAgOiAnTlQgNi4xJyxcbiAgICAgICAgICAgICc4JyAgICAgICAgIDogJ05UIDYuMicsXG4gICAgICAgICAgICAnOC4xJyAgICAgICA6ICdOVCA2LjMnLFxuICAgICAgICAgICAgJzEwJyAgICAgICAgOiBbJ05UIDYuNCcsICdOVCAxMC4wJ10sXG4gICAgICAgICAgICAnUlQnICAgICAgICA6ICdBUk0nXG4gICAgfTtcblxuICAgIC8vLy8vLy8vLy8vLy8vXG4gICAgLy8gUmVnZXggbWFwXG4gICAgLy8vLy8vLy8vLy8vL1xuXG4gICAgdmFyIHJlZ2V4ZXMgPSB7XG5cbiAgICAgICAgYnJvd3NlciA6IFtbXG5cbiAgICAgICAgICAgIC9cXGIoPzpjcm1vfGNyaW9zKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENocm9tZSBmb3IgQW5kcm9pZC9pT1NcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0Nocm9tZSddXSwgW1xuICAgICAgICAgICAgL2VkZyg/OmV8aW9zfGEpP1xcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaWNyb3NvZnQgRWRnZVxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnRWRnZSddXSwgW1xuXG4gICAgICAgICAgICAvLyBQcmVzdG8gYmFzZWRcbiAgICAgICAgICAgIC8ob3BlcmEgbWluaSlcXC8oWy1cXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgTWluaVxuICAgICAgICAgICAgLyhvcGVyYSBbbW9iaWxldGFiXXszLDZ9KVxcYi4rdmVyc2lvblxcLyhbLVxcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgLy8gT3BlcmEgTW9iaS9UYWJsZXRcbiAgICAgICAgICAgIC8ob3BlcmEpKD86Lit2ZXJzaW9uXFwvfFtcXC8gXSspKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC9vcGlvc1tcXC8gXSsoW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgbWluaSBvbiBpcGhvbmUgPj0gOC4wXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsIE9QRVJBKycgTWluaSddXSwgW1xuICAgICAgICAgICAgL1xcYm9wKD86cmcpP3hcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgR1hcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgT1BFUkErJyBHWCddXSwgW1xuICAgICAgICAgICAgL1xcYm9wclxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgV2Via2l0XG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsIE9QRVJBXV0sIFtcblxuICAgICAgICAgICAgLy8gTWl4ZWRcbiAgICAgICAgICAgIC9cXGJiW2FpXSpkKD86dWhkfFt1Yl0qW2Fla29wcnN3eF17NSw2fSlbXFwvIF0/KFtcXHdcXC5dKykvaSAgICAgICAgICAgIC8vIEJhaWR1XG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdCYWlkdSddXSwgW1xuICAgICAgICAgICAgL1xcYig/Om14YnJvd3NlcnxteGlvc3xteWllMilcXC8/KFstXFx3XFwuXSopXFxiL2kgICAgICAgICAgICAgICAgICAgICAgIC8vIE1heHRob25cbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ01heHRob24nXV0sIFtcbiAgICAgICAgICAgIC8oa2luZGxlKVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2luZGxlXG4gICAgICAgICAgICAvKGx1bmFzY2FwZXxtYXh0aG9ufG5ldGZyb250fGphc21pbmV8YmxhemVyfHNsZWlwbmlyKVtcXC8gXT8oW1xcd1xcLl0qKS9pLCAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMdW5hc2NhcGUvTWF4dGhvbi9OZXRmcm9udC9KYXNtaW5lL0JsYXplci9TbGVpcG5pclxuICAgICAgICAgICAgLy8gVHJpZGVudCBiYXNlZFxuICAgICAgICAgICAgLyhhdmFudHxpZW1vYmlsZXxzbGltKD86YnJvd3Nlcnxib2F0fGpldCkpW1xcLyBdPyhbXFxkXFwuXSopL2ksICAgICAgICAvLyBBdmFudC9JRU1vYmlsZS9TbGltQnJvd3Nlci9TbGltQm9hdC9TbGltamV0XG4gICAgICAgICAgICAvKD86bXN8XFwoKShpZSkgKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyXG5cbiAgICAgICAgICAgIC8vIEJsaW5rL1dlYmtpdC9LSFRNTCBiYXNlZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmxvY2svUm9ja01lbHQvTWlkb3JpL0VwaXBoYW55L1NpbGsvU2t5ZmlyZS9Cb2x0L0lyb24vSXJpZGl1bS9QaGFudG9tSlMvQm93c2VyL1F1cFppbGxhL0ZhbGtvblxuICAgICAgICAgICAgLyhmbG9ja3xyb2NrbWVsdHxtaWRvcml8ZXBpcGhhbnl8c2lsa3xza3lmaXJlfG92aWJyb3dzZXJ8Ym9sdHxpcm9ufHZpdmFsZGl8aXJpZGl1bXxwaGFudG9tanN8Ym93c2VyfHF1cHppbGxhfGZhbGtvbnxyZWtvbnF8cHVmZmlufGJyYXZlfHdoYWxlKD8hLituYXZlcil8cXFicm93c2VybGl0ZXxkdWNrZHVja2dvfGtsYXJ8aGVsaW98KD89Y29tb2RvXyk/ZHJhZ29uKVxcLyhbLVxcd1xcLl0rKS9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWtvbnEvUHVmZmluL0JyYXZlL1doYWxlL1FRQnJvd3NlckxpdGUvUVEvL1ZpdmFsZGkvRHVja0R1Y2tHby9LbGFyL0hlbGlvL0RyYWdvblxuICAgICAgICAgICAgLyhoZXl0YXB8b3ZpfDExNSlicm93c2VyXFwvKFtcXGRcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIZXlUYXAvT3ZpLzExNVxuICAgICAgICAgICAgLyh3ZWlibylfXyhbXFxkXFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlaWJvXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC9xdWFyayg/OnBjKT9cXC8oWy1cXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUXVhcmtcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ1F1YXJrJ11dLCBbXG4gICAgICAgICAgICAvXFxiZGRnXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEdWNrRHVja0dvXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdEdWNrRHVja0dvJ11dLCBbXG4gICAgICAgICAgICAvKD86XFxidWM/ID9icm93c2VyfCg/Omp1Yy4rKXVjd2ViKVtcXC8gXT8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAvLyBVQ0Jyb3dzZXJcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ1VDJytCUk9XU0VSXV0sIFtcbiAgICAgICAgICAgIC9taWNyb20uK1xcYnFiY29yZVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlQ2hhdCBEZXNrdG9wIGZvciBXaW5kb3dzIEJ1aWx0LWluIEJyb3dzZXJcbiAgICAgICAgICAgIC9cXGJxYmNvcmVcXC8oW1xcd1xcLl0rKS4rbWljcm9tL2ksXG4gICAgICAgICAgICAvbWljcm9tZXNzZW5nZXJcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlQ2hhdFxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnV2VDaGF0J11dLCBbXG4gICAgICAgICAgICAva29ucXVlcm9yXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtvbnF1ZXJvclxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnS29ucXVlcm9yJ11dLCBbXG4gICAgICAgICAgICAvdHJpZGVudC4rcnZbOiBdKFtcXHdcXC5dezEsOX0pXFxiLitsaWtlIGdlY2tvL2kgICAgICAgICAgICAgICAgICAgICAgIC8vIElFMTFcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0lFJ11dLCBbXG4gICAgICAgICAgICAveWEoPzpzZWFyY2gpP2Jyb3dzZXJcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFlhbmRleFxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnWWFuZGV4J11dLCBbXG4gICAgICAgICAgICAvc2xicm93c2VyXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNtYXJ0IExlbm92byBCcm93c2VyXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdTbWFydCBMZW5vdm8gJytCUk9XU0VSXV0sIFtcbiAgICAgICAgICAgIC8oYXZhc3R8YXZnKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZhc3QvQVZHIFNlY3VyZSBCcm93c2VyXG4gICAgICAgICAgICBdLCBbW05BTUUsIC8oLispLywgJyQxIFNlY3VyZSAnK0JST1dTRVJdLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgL1xcYmZvY3VzXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCBGb2N1c1xuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCBGSVJFRk9YKycgRm9jdXMnXV0sIFtcbiAgICAgICAgICAgIC9cXGJvcHRcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIFRvdWNoXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsIE9QRVJBKycgVG91Y2gnXV0sIFtcbiAgICAgICAgICAgIC9jb2NfY29jXFx3K1xcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvYyBDb2MgQnJvd3NlclxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnQ29jIENvYyddXSwgW1xuICAgICAgICAgICAgL2RvbGZpblxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb2xwaGluXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdEb2xwaGluJ11dLCBbXG4gICAgICAgICAgICAvY29hc3RcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIENvYXN0XG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsIE9QRVJBKycgQ29hc3QnXV0sIFtcbiAgICAgICAgICAgIC9taXVpYnJvd3NlclxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTUlVSSBCcm93c2VyXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdNSVVJJyArIFNVRkZJWF9CUk9XU0VSXV0sIFtcbiAgICAgICAgICAgIC9meGlvc1xcLyhbXFx3XFwuLV0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCBmb3IgaU9TXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsIEZJUkVGT1hdXSwgW1xuICAgICAgICAgICAgL1xcYnFpaG9vYnJvd3NlclxcLz8oW1xcd1xcLl0qKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMzYwXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICczNjAnXV0sIFtcbiAgICAgICAgICAgIC9cXGIocXEpXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFFRXG4gICAgICAgICAgICBdLCBbW05BTUUsIC8oLispLywgJyQxQnJvd3NlciddLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgLyhvY3VsdXN8c2FpbGZpc2h8aHVhd2VpfHZpdm98cGljbylicm93c2VyXFwvKFtcXHdcXC5dKykvaVxuICAgICAgICAgICAgXSwgW1tOQU1FLCAvKC4rKS8sICckMScgKyBTVUZGSVhfQlJPV1NFUl0sIFZFUlNJT05dLCBbICAgICAgICAgICAgICAvLyBPY3VsdXMvU2FpbGZpc2gvSHVhd2VpQnJvd3Nlci9WaXZvQnJvd3Nlci9QaWNvQnJvd3NlclxuICAgICAgICAgICAgL3NhbXN1bmdicm93c2VyXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYW1zdW5nIEludGVybmV0XG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsIFNBTVNVTkcgKyAnIEludGVybmV0J11dLCBbXG4gICAgICAgICAgICAvbWV0YXNyW1xcLyBdPyhbXFxkXFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvZ291IEV4cGxvcmVyXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdTb2dvdSBFeHBsb3JlciddXSwgW1xuICAgICAgICAgICAgLyhzb2dvdSltb1xcdytcXC8oW1xcZFxcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29nb3UgTW9iaWxlXG4gICAgICAgICAgICBdLCBbW05BTUUsICdTb2dvdSBNb2JpbGUnXSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC8oZWxlY3Ryb24pXFwvKFtcXHdcXC5dKykgc2FmYXJpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWxlY3Ryb24tYmFzZWQgQXBwXG4gICAgICAgICAgICAvKHRlc2xhKSg/OiBxdGNhcmJyb3dzZXJ8XFwvKDIwXFxkXFxkXFwuWy1cXHdcXC5dKykpL2ksICAgICAgICAgICAgICAgICAgIC8vIFRlc2xhXG4gICAgICAgICAgICAvbT8ocXFicm93c2VyfDIzNDUoPz1icm93c2VyfGNocm9tZXxleHBsb3JlcikpXFx3KltcXC8gXT92PyhbXFx3XFwuXSspL2kgICAvLyBRUS8yMzQ1XG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC8obGJicm93c2VyfHJla29ucSkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGllQmFvIEJyb3dzZXIvUmVrb25xXG4gICAgICAgICAgICAvXFxbKGxpbmtlZGluKWFwcFxcXS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGlua2VkSW4gQXBwIGZvciBpT1MgJiBBbmRyb2lkXG4gICAgICAgICAgICBdLCBbTkFNRV0sIFtcbiAgICAgICAgICAgIC9vbWVcXC8oW1xcd1xcLl0rKSBcXHcqID8oaXJvbikgc2FmL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElyb25cbiAgICAgICAgICAgIC9vbWVcXC8oW1xcd1xcLl0rKS4rcWlodSAoMzYwKVtlc11lL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMzYwXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgTkFNRV0sIFtcblxuICAgICAgICAgICAgLy8gV2ViVmlld1xuICAgICAgICAgICAgLygoPzpmYmFuXFwvZmJpb3N8ZmJfaWFiXFwvZmI0YSkoPyEuK2ZiYXYpfDtmYmF2XFwvKFtcXHdcXC5dKyk7KS9pICAgICAgIC8vIEZhY2Vib29rIEFwcCBmb3IgaU9TICYgQW5kcm9pZFxuICAgICAgICAgICAgXSwgW1tOQU1FLCBGQUNFQk9PS10sIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvKEtsYXJuYSlcXC8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtsYXJuYSBTaG9wcGluZyBCcm93c2VyIGZvciBpT1MgJiBBbmRyb2lkXG4gICAgICAgICAgICAvKGtha2FvKD86dGFsa3xzdG9yeSkpW1xcLyBdKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtha2FvIEFwcFxuICAgICAgICAgICAgLyhuYXZlcilcXCguKj8oXFxkK1xcLltcXHdcXC5dKykuKlxcKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOYXZlciBJbkFwcFxuICAgICAgICAgICAgLyhkYXVtKWFwcHNbXFwvIF0oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEYXVtIEFwcFxuICAgICAgICAgICAgL3NhZmFyaSAobGluZSlcXC8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMaW5lIEFwcCBmb3IgaU9TXG4gICAgICAgICAgICAvXFxiKGxpbmUpXFwvKFtcXHdcXC5dKylcXC9pYWIvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGluZSBBcHAgZm9yIEFuZHJvaWRcbiAgICAgICAgICAgIC8oYWxpcGF5KWNsaWVudFxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxpcGF5XG4gICAgICAgICAgICAvKHR3aXR0ZXIpKD86YW5kfCBmLitlXFwvKFtcXHdcXC5dKykpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFR3aXR0ZXJcbiAgICAgICAgICAgIC8oY2hyb21pdW18aW5zdGFncmFtfHNuYXBjaGF0KVtcXC8gXShbLVxcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21pdW0vSW5zdGFncmFtL1NuYXBjaGF0XG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC9cXGJnc2FcXC8oW1xcd1xcLl0rKSAuKnNhZmFyaVxcLy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHb29nbGUgU2VhcmNoIEFwcGxpYW5jZSBvbiBpT1NcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0dTQSddXSwgW1xuICAgICAgICAgICAgL211c2ljYWxfbHkoPzouK2FwcF8/dmVyc2lvblxcL3xfKShbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaWtUb2tcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ1Rpa1RvayddXSwgW1xuXG4gICAgICAgICAgICAvaGVhZGxlc3NjaHJvbWUoPzpcXC8oW1xcd1xcLl0rKXwgKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENocm9tZSBIZWFkbGVzc1xuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCBDSFJPTUUrJyBIZWFkbGVzcyddXSwgW1xuXG4gICAgICAgICAgICAvIHd2XFwpLisoY2hyb21lKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWUgV2ViVmlld1xuICAgICAgICAgICAgXSwgW1tOQU1FLCBDSFJPTUUrJyBXZWJWaWV3J10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC9kcm9pZC4rIHZlcnNpb25cXC8oW1xcd1xcLl0rKVxcYi4rKD86bW9iaWxlIHNhZmFyaXxzYWZhcmkpL2kgICAgICAgICAgIC8vIEFuZHJvaWQgQnJvd3NlclxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnQW5kcm9pZCAnK0JST1dTRVJdXSwgW1xuXG4gICAgICAgICAgICAvKGNocm9tZXxvbW5pd2VifGFyb3JhfFt0aXplbm9rYV17NX0gP2Jyb3dzZXIpXFwvdj8oW1xcd1xcLl0rKS9pICAgICAgIC8vIENocm9tZS9PbW5pV2ViL0Fyb3JhL1RpemVuL05va2lhXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgL3ZlcnNpb25cXC8oW1xcd1xcLlxcLF0rKSAuKm1vYmlsZVxcL1xcdysgKHNhZmFyaSkvaSAgICAgICAgICAgICAgICAgICAgICAvLyBNb2JpbGUgU2FmYXJpXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdNb2JpbGUgU2FmYXJpJ11dLCBbXG4gICAgICAgICAgICAvdmVyc2lvblxcLyhbXFx3KFxcLnxcXCwpXSspIC4qKG1vYmlsZSA/c2FmYXJpfHNhZmFyaSkvaSAgICAgICAgICAgICAgICAvLyBTYWZhcmkgJiBTYWZhcmkgTW9iaWxlXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgTkFNRV0sIFtcbiAgICAgICAgICAgIC93ZWJraXQuKz8obW9iaWxlID9zYWZhcml8c2FmYXJpKShcXC9bXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDwgMy4wXG4gICAgICAgICAgICBdLCBbTkFNRSwgW1ZFUlNJT04sIHN0ck1hcHBlciwgb2xkU2FmYXJpTWFwXV0sIFtcblxuICAgICAgICAgICAgLyh3ZWJraXR8a2h0bWwpXFwvKFtcXHdcXC5dKykvaVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8vIEdlY2tvIGJhc2VkXG4gICAgICAgICAgICAvKG5hdmlnYXRvcnxuZXRzY2FwZVxcZD8pXFwvKFstXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXRzY2FwZVxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnTmV0c2NhcGUnXSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC8od29sdmljfGxpYnJld29sZilcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV29sdmljL0xpYnJlV29sZlxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvbW9iaWxlIHZyOyBydjooW1xcd1xcLl0rKVxcKS4rZmlyZWZveC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggUmVhbGl0eVxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCBGSVJFRk9YKycgUmVhbGl0eSddXSwgW1xuICAgICAgICAgICAgL2VraW9oZi4rKGZsb3cpXFwvKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGbG93XG4gICAgICAgICAgICAvKHN3aWZ0Zm94KS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN3aWZ0Zm94XG4gICAgICAgICAgICAvKGljZWRyYWdvbnxpY2V3ZWFzZWx8Y2FtaW5vfGNoaW1lcmF8ZmVubmVjfG1hZW1vIGJyb3dzZXJ8bWluaW1vfGNvbmtlcm9yKVtcXC8gXT8oW1xcd1xcLlxcK10rKS9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJY2VEcmFnb24vSWNld2Vhc2VsL0NhbWluby9DaGltZXJhL0Zlbm5lYy9NYWVtby9NaW5pbW8vQ29ua2Vyb3JcbiAgICAgICAgICAgIC8oc2VhbW9ua2V5fGstbWVsZW9ufGljZWNhdHxpY2VhcGV8ZmlyZWJpcmR8cGhvZW5peHxwYWxlbW9vbnxiYXNpbGlza3x3YXRlcmZveClcXC8oWy1cXHdcXC5dKykkL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3gvU2VhTW9ua2V5L0stTWVsZW9uL0ljZUNhdC9JY2VBcGUvRmlyZWJpcmQvUGhvZW5peFxuICAgICAgICAgICAgLyhmaXJlZm94KVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlciBGaXJlZm94LWJhc2VkXG4gICAgICAgICAgICAvKG1vemlsbGEpXFwvKFtcXHdcXC5dKykgLitydlxcOi4rZ2Vja29cXC9cXGQrL2ksICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vemlsbGFcblxuICAgICAgICAgICAgLy8gT3RoZXJcbiAgICAgICAgICAgIC8oYW1heWF8ZGlsbG98ZG9yaXN8aWNhYnxsYWR5YmlyZHxseW54fG1vc2FpY3xuZXRzdXJmfG9iaWdvfHBvbGFyaXN8dzNtfCg/OmdvfGljZXx1cClbXFwuIF0/YnJvd3NlcilbLVxcLyBdP3Y/KFtcXHdcXC5dKykvaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9sYXJpcy9MeW54L0RpbGxvL2lDYWIvRG9yaXMvQW1heWEvdzNtL05ldFN1cmYvT2JpZ28vTW9zYWljL0dvL0lDRS9VUC5Ccm93c2VyL0xhZHliaXJkXG4gICAgICAgICAgICAvXFxiKGxpbmtzKSBcXCgoW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMaW5rc1xuICAgICAgICAgICAgXSwgW05BTUUsIFtWRVJTSU9OLCAvXy9nLCAnLiddXSwgW1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvKGNvYmFsdClcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvYmFsdFxuICAgICAgICAgICAgXSwgW05BTUUsIFtWRVJTSU9OLCAvbWFzdGVyLnxsdHMuLywgXCJcIl1dXG4gICAgICAgIF0sXG5cbiAgICAgICAgY3B1IDogW1tcblxuICAgICAgICAgICAgL1xcYigoYW1kfHh8eDg2Wy1fXT98d293fHdpbik2NClcXGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFNRDY0ICh4NjQpXG4gICAgICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgJ2FtZDY0J11dLCBbXG5cbiAgICAgICAgICAgIC8oaWEzMig/PTspKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUEzMiAocXVpY2t0aW1lKVxuICAgICAgICAgICAgL1xcYigoaVszNDZdfHgpODYpKHBjKT9cXGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElBMzIgKHg4NilcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCAnaWEzMiddXSwgW1xuXG4gICAgICAgICAgICAvXFxiKGFhcmNoNjR8YXJtKHY/Wzg5XWU/bD98Xz82NCkpXFxiL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQVJNNjRcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCAnYXJtNjQnXV0sIFtcblxuICAgICAgICAgICAgL1xcYihhcm0odls2N10pP2h0P24/W2ZsXXA/KVxcYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFSTUhGXG4gICAgICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgJ2FybWhmJ11dLCBbXG5cbiAgICAgICAgICAgIC8vIFBvY2tldFBDIG1pc3Rha2VubHkgaWRlbnRpZmllZCBhcyBQb3dlclBDXG4gICAgICAgICAgICAvKCAoY2V8bW9iaWxlKTsgcHBjO3xcXC9bXFx3XFwuXSthcm1cXGIpL2lcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCAnYXJtJ11dLCBbXG5cbiAgICAgICAgICAgIC8oKHBwY3xwb3dlcnBjKSg2NCk/KSggbWFjfDt8XFwpKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvd2VyUENcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCAvb3dlci8sIEVNUFRZLCBsb3dlcml6ZV1dLCBbXG5cbiAgICAgICAgICAgIC8gc3VuNFxcd1s7XFwpXS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTUEFSQ1xuICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsICdzcGFyYyddXSwgW1xuXG4gICAgICAgICAgICAvXFxiKGF2cjMyfGlhNjQoPz07KXw2OGsoPz1cXCkpfFxcYmFybSg/PXYoWzEtN118WzUtN10xKWw/fDt8ZWFiaSl8KGlyaXh8bWlwc3xzcGFyYykoNjQpP1xcYnxwYS1yaXNjKS9pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElBNjQsIDY4SywgQVJNLzY0LCBBVlIvMzIsIElSSVgvNjQsIE1JUFMvNjQsIFNQQVJDLzY0LCBQQS1SSVNDXG4gICAgICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgbG93ZXJpemVdXVxuICAgICAgICBdLFxuXG4gICAgICAgIGRldmljZSA6IFtbXG5cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAvLyBNT0JJTEVTICYgVEFCTEVUU1xuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgICAvLyBTYW1zdW5nXG4gICAgICAgICAgICAvXFxiKHNjaC1pWzg5XTBcXGR8c2h3LW0zODBzfHNtLVtwdHhdXFx3ezIsNH18Z3QtW3BuXVxcZHsyLDR9fHNnaC10OFs1Nl05fG5leHVzIDEwKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIFNBTVNVTkddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9cXGIoKD86c1tjZ3BdaHxndHxzbSktKD8hW2xyXSlcXHcrfHNjW2ctXT9bXFxkXSthP3xnYWxheHkgbmV4dXMpL2ksXG4gICAgICAgICAgICAvc2Ftc3VuZ1stIF0oKD8hc20tW2xyXSlbLVxcd10rKS9pLFxuICAgICAgICAgICAgL3NlYy0oc2doXFx3KykvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBTQU1TVU5HXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vIEFwcGxlXG4gICAgICAgICAgICAvKD86XFwvfFxcKCkoaXAoPzpob25lfG9kKVtcXHcsIF0qKSg/OlxcL3w7KS9pICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpUG9kL2lQaG9uZVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBBUFBMRV0sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL1xcKChpcGFkKTtbLVxcd1xcKSw7IF0rYXBwbGUvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpUGFkXG4gICAgICAgICAgICAvYXBwbGVjb3JlbWVkaWFcXC9bXFx3XFwuXSsgXFwoKGlwYWQpL2ksXG4gICAgICAgICAgICAvXFxiKGlwYWQpXFxkXFxkPyxcXGRcXGQ/WztcXF1dLitpb3MvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBBUFBMRV0sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgLyhtYWNpbnRvc2gpOy9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIEFQUExFXV0sIFtcblxuICAgICAgICAgICAgLy8gU2hhcnBcbiAgICAgICAgICAgIC9cXGIoc2gtP1thbHR2el0/XFxkXFxkW2EtZWttXT8pL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgU0hBUlBdLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8gSG9ub3JcbiAgICAgICAgICAgIC9cXGIoKD86YnJ0fGVsbnxoZXkyP3xnZGl8amRuKS1hP1tsbnddMDl8KD86YWdbcm1dMz98amRuMnxrb2IyKS1hP1tsd10wWzA5XWhuKSg/OiBidWl8XFwpfDspL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgSE9OT1JdLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9ob25vcihbLVxcdyBdKylbO1xcKV0vaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBIT05PUl0sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBIdWF3ZWlcbiAgICAgICAgICAgIC9cXGIoKD86YWdbcnNdWzIzNTZdP2s/fGJhaFsyMzRdP3xiZ1syb118YnRba3ZdfGNtcnxjcG58ZGJbcnldMj98amRuMnxnb3R8a29iMj9rP3xtb258cGNlfHNjbXxzaHQ/fFt0d11ncnx2cmQpLVthZF0/W2x3XVswMTI1XVswOV1iP3w2MDVod3xiZzItdTAzfCg/OmdlbXxmZHJ8bTJ8cGxlfHQxKS1bN2FdMFsxLTRdW2x1XXx0MS1hMlsxM11bbHddfG1lZGlhcGFkW1xcd1xcLiBdKig/PSBidWl8XFwpKSlcXGIoPyEuK2RcXC9zKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIEhVQVdFSV0sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgLyg/Omh1YXdlaSkoWy1cXHcgXSspWztcXCldL2ksXG4gICAgICAgICAgICAvXFxiKG5leHVzIDZwfFxcd3syLDR9ZT8tW2F0dV0/W2xuXVtcXGR4XVswMTIzNTljXVthZG5dPylcXGIoPyEuK2RcXC9zKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIEhVQVdFSV0sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBYaWFvbWlcbiAgICAgICAgICAgIC9vaWRbXlxcKV0rOyAoMltcXGRiY117NH0oMTgyfDI4M3xycFxcd3syfSlbY2dsXXxtMjEwNWs4MWE/YykoPzogYnVpfFxcKSkvaSxcbiAgICAgICAgICAgIC9cXGIoKD86cmVkKT9taVstXyBdP3BhZFtcXHctIF0qKSg/OiBidWl8XFwpKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaSBQYWQgdGFibGV0c1xuICAgICAgICAgICAgXSxbW01PREVMLCAvXy9nLCAnICddLCBbVkVORE9SLCBYSUFPTUldLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL1xcYihwb2NvW1xcdyBdK3xtMlxcZHszfWpcXGRcXGRbYS16XXsyfSkoPzogYnVpfFxcKSkvaSwgICAgICAgICAgICAgICAgICAvLyBYaWFvbWkgUE9DT1xuICAgICAgICAgICAgL1xcYjsgKFxcdyspIGJ1aWxkXFwvaG1cXDEvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWGlhb21pIEhvbmdtaSAnbnVtZXJpYycgbW9kZWxzXG4gICAgICAgICAgICAvXFxiKGhtWy1fIF0/bm90ZT9bXyBdPyg/OlxcZFxcdyk/KSBidWkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFhpYW9taSBIb25nbWlcbiAgICAgICAgICAgIC9cXGIocmVkbWlbXFwtXyBdPyg/Om5vdGV8ayk/W1xcd18gXSspKD86IGJ1aXxcXCkpL2ksICAgICAgICAgICAgICAgICAgIC8vIFhpYW9taSBSZWRtaVxuICAgICAgICAgICAgL29pZFteXFwpXSs7IChtP1sxMl1bMC0zODldWzAxXVxcd3szLDZ9W2MteV0pKCBidWl8OyB3dnxcXCkpL2ksICAgICAgICAvLyBYaWFvbWkgUmVkbWkgJ251bWVyaWMnIG1vZGVsc1xuICAgICAgICAgICAgL1xcYihtaVstXyBdPyg/OmFcXGR8b25lfG9uZVtfIF1wbHVzfG5vdGUgbHRlfG1heHxjYyk/W18gXT8oPzpcXGQ/XFx3PylbXyBdPyg/OnBsdXN8c2V8bGl0ZXxwcm8pPykoPzogYnVpfFxcKSkvaSwgLy8gWGlhb21pIE1pXG4gICAgICAgICAgICAvIChbXFx3IF0rKSBtaXVpXFwvdj9cXGQvaVxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgL18vZywgJyAnXSwgW1ZFTkRPUiwgWElBT01JXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vIE9QUE9cbiAgICAgICAgICAgIC87IChcXHcrKSBidWkuKyBvcHBvL2ksXG4gICAgICAgICAgICAvXFxiKGNwaFsxMl1cXGR7M318cCg/OmFmfGNbYWxdfGRcXHd8ZVthcl0pW210XVxcZDB8eDkwMDd8YTEwMW9wKVxcYi9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIE9QUE9dLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9cXGIob3BkMihcXGR7M31hPykpKD86IGJ1aXxcXCkpL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgc3RyTWFwcGVyLCB7ICdPbmVQbHVzJyA6IFsnMzA0JywgJzQwMycsICcyMDMnXSwgJyonIDogT1BQTyB9XSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC8vIFZpdm9cbiAgICAgICAgICAgIC92aXZvIChcXHcrKSg/OiBidWl8XFwpKS9pLFxuICAgICAgICAgICAgL1xcYih2WzEyXVxcZHszfVxcdz9bYXRdKSg/OiBidWl8OykvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnVml2byddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8gUmVhbG1lXG4gICAgICAgICAgICAvXFxiKHJteFsxLTNdXFxkezN9KSg/OiBidWl8O3xcXCkpL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1JlYWxtZSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8gTW90b3JvbGFcbiAgICAgICAgICAgIC9cXGIobWlsZXN0b25lfGRyb2lkKD86WzItNHhdfCAoPzpiaW9uaWN8eDJ8cHJvfHJhenIpKT86PyggNGcpPylcXGJbXFx3IF0rYnVpbGRcXC8vaSxcbiAgICAgICAgICAgIC9cXGJtb3QoPzpvcm9sYSk/Wy0gXShcXHcqKS9pLFxuICAgICAgICAgICAgLygoPzptb3RvKD8hIDM2MClbXFx3XFwoXFwpIF0rfHh0XFxkezMsNH18bmV4dXMgNikoPz0gYnVpfFxcKSkpL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgTU9UT1JPTEFdLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9cXGIobXo2MFxcZHx4b29tWzIgXXswLDJ9KSBidWlsZFxcLy9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIE1PVE9ST0xBXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC8vIExHXG4gICAgICAgICAgICAvKCg/PWxnKT9bdmxda1xcLT9cXGR7M30pIGJ1aXwgM1xcLlstXFx3OyBdezEwfWxnPy0oWzA2Y3Y5XXszLDR9KS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIExHXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvKGxtKD86LT9mMTAwW252XT98LVtcXHdcXC5dKykoPz0gYnVpfFxcKSl8bmV4dXMgWzQ1XSkvaSxcbiAgICAgICAgICAgIC9cXGJsZ1stZTtcXC8gXSsoKD8hYnJvd3NlcnxuZXRjYXN0fGFuZHJvaWQgdHZ8d2F0Y2gpXFx3KykvaSxcbiAgICAgICAgICAgIC9cXGJsZy0/KFtcXGRcXHddKykgYnVpL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgTEddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8gTGVub3ZvXG4gICAgICAgICAgICAvKGlkZWF0YWJbLVxcdyBdK3w2MDJsdnxkLTQyYXxhMTAxbHZ8YTIxMDlhfGEzNTAwLWh2fHNbNTZdMDAwfHBiLTY1MDVbbXldfHRiLT94P1xcZHszLDR9KD86ZltjdV18eHV8W2F2XSl8eXRcXGQ/LVtqeF0/XFxkK1tsZm14XSkoIGJ1aXw7fFxcKXxcXC8pL2ksXG4gICAgICAgICAgICAvbGVub3ZvID8oYls2OF0wWzA4XTAtP1toZl0/fHRhYig/OltcXHctIF0rPyl8dGJbXFx3LV17Niw3fSkoIGJ1aXw7fFxcKXxcXC8pL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgTEVOT1ZPXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC8vIE5va2lhXG4gICAgICAgICAgICAvKG5va2lhKSAodFsxMl1bMDFdKS9pXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvKD86bWFlbW98bm9raWEpLioobjkwMHxsdW1pYSBcXGQrfHJtLVxcZCspL2ksXG4gICAgICAgICAgICAvbm9raWFbLV8gXT8oKFstXFx3XFwuIF0qKSkvaVxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgL18vZywgJyAnXSwgW1RZUEUsIE1PQklMRV0sIFtWRU5ET1IsICdOb2tpYSddXSwgW1xuXG4gICAgICAgICAgICAvLyBHb29nbGVcbiAgICAgICAgICAgIC8ocGl4ZWwgKGN8dGFibGV0KSlcXGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvb2dsZSBQaXhlbCBDL1RhYmxldFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBHT09HTEVdLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9kcm9pZC4rOyAocGl4ZWxbXFxkYXhsIF17MCw2fSkoPzogYnVpfFxcKSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHb29nbGUgUGl4ZWxcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgR09PR0xFXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vIFNvbnlcbiAgICAgICAgICAgIC9kcm9pZC4rOyAoYT9cXGRbMC0yXXsyfXNvfFtjLWddXFxkezR9fHNvWy1nbF1cXHcrfHhxLWFcXHdbNC03XVsxMl0pKD89IGJ1aXxcXCkuK2Nocm9tZVxcLyg/IVsxLTZdezAsMX1cXGRcXC4pKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIFNPTlldLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9zb255IHRhYmxldCBbcHNdL2ksXG4gICAgICAgICAgICAvXFxiKD86c29ueSk/c2dwXFx3Kyg/OiBidWl8XFwpKS9pXG4gICAgICAgICAgICBdLCBbW01PREVMLCAnWHBlcmlhIFRhYmxldCddLCBbVkVORE9SLCBTT05ZXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC8vIE9uZVBsdXNcbiAgICAgICAgICAgIC8gKGtiMjAwNXxpbjIwWzEyXTV8YmUyMFsxMl1bNTldKVxcYi9pLFxuICAgICAgICAgICAgLyg/Om9uZSk/KD86cGx1cyk/IChhXFxkMFxcZFxcZCkoPzogYnxcXCkpL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgT05FUExVU10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBBbWF6b25cbiAgICAgICAgICAgIC8oYWxleGEpd2VibS9pLFxuICAgICAgICAgICAgLyhrZlthLXpdezJ9d2l8YWVvKD8hYmMpXFx3XFx3KSggYnVpfFxcKSkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLaW5kbGUgRmlyZSB3aXRob3V0IFNpbGsgLyBFY2hvIFNob3dcbiAgICAgICAgICAgIC8oa2ZbYS16XSspKCBidWl8XFwpKS4rc2lsa1xcLy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLaW5kbGUgRmlyZSBIRFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBBTUFaT05dLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC8oKD86c2R8a2YpWzAzNDloaWpvcnN0dXddKykoIGJ1aXxcXCkpLitzaWxrXFwvL2kgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlIFBob25lXG4gICAgICAgICAgICBdLCBbW01PREVMLCAvKC4rKS9nLCAnRmlyZSBQaG9uZSAkMSddLCBbVkVORE9SLCBBTUFaT05dLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8gQmxhY2tCZXJyeVxuICAgICAgICAgICAgLyhwbGF5Ym9vayk7Wy1cXHdcXCksOyBdKyhyaW0pL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrQmVycnkgUGxheUJvb2tcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgVkVORE9SLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9cXGIoKD86YmJbYS1mXXxzdFtodl0pMTAwLVxcZCkvaSxcbiAgICAgICAgICAgIC9cXChiYjEwOyAoXFx3KykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCbGFja0JlcnJ5IDEwXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIEJMQUNLQkVSUlldLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8gQXN1c1xuICAgICAgICAgICAgLyg/OlxcYnxhc3VzXykodHJhbnNmb1twcmltZSBdezQsMTB9IFxcdyt8ZWVlcGN8c2xpZGVyIFxcdyt8bmV4dXMgN3xwYWRmb25lfHAwMFtjal0pL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgQVNVU10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgLyAoeltiZXNdNlswMjddWzAxMl1ba21dW2xzXXx6ZW5mb25lIFxcZFxcdz8pXFxiL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgQVNVU10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBIVENcbiAgICAgICAgICAgIC8obmV4dXMgOSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSFRDIE5leHVzIDlcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0hUQyddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC8oaHRjKVstO18gXXsxLDJ9KFtcXHcgXSsoPz1cXCl8IGJ1aSl8XFx3KykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSFRDXG5cbiAgICAgICAgICAgIC8vIFpURVxuICAgICAgICAgICAgLyh6dGUpWy0gXShbXFx3IF0rPykoPzogYnVpfFxcL3xcXCkpL2ksXG4gICAgICAgICAgICAvKGFsY2F0ZWx8Z2Vla3NwaG9uZXxuZXhpYW58cGFuYXNvbmljKD8hKD86O3xcXC4pKXxzb255KD8hLWJyYSkpWy1fIF0/KFstXFx3XSopL2kgICAgICAgICAvLyBBbGNhdGVsL0dlZWtzUGhvbmUvTmV4aWFuL1BhbmFzb25pYy9Tb255XG4gICAgICAgICAgICBdLCBbVkVORE9SLCBbTU9ERUwsIC9fL2csICcgJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBUQ0xcbiAgICAgICAgICAgIC9kcm9pZCBbXFx3XFwuXSs7ICgoPzo4WzE0XTlbMTZdfDkoPzowKD86NDh8NjB8OFswMV0pfDEoPzozWzI3XXw2Nil8Mig/OjZbNjldfDlbNTZdKXw0NjYpKVtncXN3eF0pXFx3KihcXCl8IGJ1aSkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnVENMJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvLyBpdGVsXG4gICAgICAgICAgICAvKGl0ZWwpICgoXFx3KykpL2lcbiAgICAgICAgICAgIF0sIFtbVkVORE9SLCBsb3dlcml6ZV0sIE1PREVMLCBbVFlQRSwgc3RyTWFwcGVyLCB7ICd0YWJsZXQnIDogWydwMTAwMDFsJywgJ3c3MDAxJ10sICcqJyA6ICdtb2JpbGUnIH1dXSwgW1xuXG4gICAgICAgICAgICAvLyBBY2VyXG4gICAgICAgICAgICAvZHJvaWQuKzsgKFthYl1bMS03XS0/WzAxNzhhXVxcZFxcZD8pL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0FjZXInXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC8vIE1laXp1XG4gICAgICAgICAgICAvZHJvaWQuKzsgKG1bMS01XSBub3RlKSBidWkvaSxcbiAgICAgICAgICAgIC9cXGJtei0oWy1cXHddezIsfSkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTWVpenUnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVbGVmb25lXG4gICAgICAgICAgICAvOyAoKD86cG93ZXIgKT9hcm1vcig/OltcXHcgXXswLDh9KSkoPzogYnVpfFxcKSkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnVWxlZm9uZSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8gRW5lcmdpemVyXG4gICAgICAgICAgICAvOyAoZW5lcmd5ID9cXHcrKSg/OiBidWl8XFwpKS9pLFxuICAgICAgICAgICAgLzsgZW5lcmdpemVyIChbXFx3IF0rKSg/OiBidWl8XFwpKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdFbmVyZ2l6ZXInXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vIENhdFxuICAgICAgICAgICAgLzsgY2F0IChiMzUpOy9pLFxuICAgICAgICAgICAgLzsgKGIxNXE/fHMyMiBmbGlwfHM0OGN8czYyIHBybykoPzogYnVpfFxcKSkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnQ2F0J10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBTbWFydGZyZW5cbiAgICAgICAgICAgIC8oKD86bmV3ICk/YW5kcm9tYXhbXFx3LSBdKykoPzogYnVpfFxcKSkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnU21hcnRmcmVuJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBOb3RoaW5nXG4gICAgICAgICAgICAvZHJvaWQuKzsgKGEoPzowMTV8MDZbMzVdfDE0MnA/KSkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTm90aGluZyddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8gQXJjaG9zXG4gICAgICAgICAgICAvOyAoeDY3IDVnfHRpa2Vhc3kgXFx3K3xhY1sxNzg5XVxcZFxcdyspKCBifFxcKSkvaSxcbiAgICAgICAgICAgIC9hcmNob3MgPyg1fGdhbWVwYWQyP3woW1xcdyBdKlt0MTc4OV18aGVsbG8pID9cXGQrW1xcdyBdKikoIGJ8XFwpKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdBcmNob3MnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvYXJjaG9zIChbXFx3IF0rKSggYnxcXCkpL2ksXG4gICAgICAgICAgICAvOyAoYWNbMy02XVxcZFxcd3syLDh9KSggYnxcXCkpL2kgXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdBcmNob3MnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vIE1JWEVEXG4gICAgICAgICAgICAvKGltbykgKHRhYiBcXHcrKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJTU9cbiAgICAgICAgICAgIC8oaW5maW5peCkgKHgxMTAxYj8pL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5maW5peCBYUGFkXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC8oYmxhY2tiZXJyeXxiZW5xfHBhbG0oPz1cXC0pfHNvbnllcmljc3NvbnxhY2VyfGFzdXMoPyEgemVudyl8ZGVsbHxqb2xsYXxtZWl6dXxtb3Rvcm9sYXxwb2x5dHJvbnxpbmZpbml4fHRlY25vfG1pY3JvbWF4fGFkdmFuKVstXyBdPyhbLVxcd10qKS9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCbGFja0JlcnJ5L0JlblEvUGFsbS9Tb255LUVyaWNzc29uL0FjZXIvQXN1cy9EZWxsL01laXp1L01vdG9yb2xhL1BvbHl0cm9uL0luZmluaXgvVGVjbm8vTWljcm9tYXgvQWR2YW5cbiAgICAgICAgICAgIC87IChobWR8aW1vKSAoW1xcdyBdKz8pKD86IGJ1aXxcXCkpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBITUQvSU1PXG4gICAgICAgICAgICAvKGhwKSAoW1xcdyBdK1xcdykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSFAgaVBBUVxuICAgICAgICAgICAgLyhtaWNyb3NvZnQpOyAobHVtaWFbXFx3IF0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWljcm9zb2Z0IEx1bWlhXG4gICAgICAgICAgICAvKGxlbm92bylbLV8gXT8oWy1cXHcgXSs/KSg/OiBidWl8XFwpfFxcLykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlbm92b1xuICAgICAgICAgICAgLyhvcHBvKSA/KFtcXHcgXSspIGJ1aS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT1BQT1xuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvKGtvYm8pXFxzKGVyZWFkZXJ8dG91Y2gpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLb2JvXG4gICAgICAgICAgICAvKGhwKS4rKHRvdWNocGFkKD8hLit0YWJsZXQpfHRhYmxldCkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhQIFRvdWNoUGFkXG4gICAgICAgICAgICAvKGtpbmRsZSlcXC8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtpbmRsZVxuICAgICAgICAgICAgLyhub29rKVtcXHcgXStidWlsZFxcLyhcXHcrKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb29rXG4gICAgICAgICAgICAvKGRlbGwpIChzdHJlYVtrcHJcXGQgXSpbXFxka29dKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsbCBTdHJlYWtcbiAgICAgICAgICAgIC8obGVbLSBdK3BhbilbLSBdKyhcXHd7MSw5fSkgYnVpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlIFBhbiBUYWJsZXRzXG4gICAgICAgICAgICAvKHRyaW5pdHkpWy0gXSoodFxcZHszfSkgYnVpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmluaXR5IFRhYmxldHNcbiAgICAgICAgICAgIC8oZ2lnYXNldClbLSBdKyhxXFx3ezEsOX0pIGJ1aS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdpZ2FzZXQgVGFibGV0c1xuICAgICAgICAgICAgLyh2b2RhZm9uZSkgKFtcXHcgXSspKD86XFwpfCBidWkpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZvZGFmb25lXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC8oc3VyZmFjZSBkdW8pL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VyZmFjZSBEdW9cbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgTUlDUk9TT0ZUXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvZHJvaWQgW1xcZFxcLl0rOyAoZnBcXGR1PykoPzogYnxcXCkpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWlycGhvbmVcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0ZhaXJwaG9uZSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC8odTMwNGFhKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQVQmVFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnQVQmVCddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9cXGJzaWUtKFxcdyopL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaWVtZW5zXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdTaWVtZW5zJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL1xcYihyY3RcXHcrKSBiL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJDQSBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdSQ0EnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvXFxiKHZlbnVlW1xcZCBdezIsN30pIGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsbCBWZW51ZSBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdEZWxsJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL1xcYihxKD86bXZ8dGEpXFx3KykgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZlcml6b24gVGFibGV0XG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdWZXJpem9uJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL1xcYig/OmJhcm5lc1smIF0rbm9ibGUgfGJuW3J0XSkoW1xcd1xcKyBdKikgYi9pICAgICAgICAgICAgICAgICAgICAgICAvLyBCYXJuZXMgJiBOb2JsZSBUYWJsZXRcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0Jhcm5lcyAmIE5vYmxlJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL1xcYih0bVxcZHszfVxcdyspIGIvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTnVWaXNpb24nXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvXFxiKGs4OCkgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBaVEUgSyBTZXJpZXMgVGFibGV0XG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdaVEUnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvXFxiKG54XFxkezN9aikgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWlRFIE51YmlhXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdaVEUnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvXFxiKGdlblxcZHszfSkgYi4rNDloL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3dpc3MgR0VOIE1vYmlsZVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnU3dpc3MnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvXFxiKHp1clxcZHszfSkgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3dpc3MgWlVSIFRhYmxldFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnU3dpc3MnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvXFxiKCh6ZWtpKT90Yi4qXFxiKSBiL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWmVraSBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdaZWtpJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL1xcYihbeXJdXFxkezJ9KSBiL2ksXG4gICAgICAgICAgICAvXFxiKGRyYWdvblstIF0rdG91Y2ggfGR0KShcXHd7NX0pIGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRHJhZ29uIFRvdWNoIFRhYmxldFxuICAgICAgICAgICAgXSwgW1tWRU5ET1IsICdEcmFnb24gVG91Y2gnXSwgTU9ERUwsIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL1xcYihucy0/XFx3ezAsOX0pIGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc2lnbmlhIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0luc2lnbmlhJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL1xcYigobnhhfG5leHQpLT9cXHd7MCw5fSkgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5leHRCb29rIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ05leHRCb29rJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL1xcYih4dHJlbWVcXF8pPyh2KDFbMDQ1XXwyWzAxNV18WzM0NjldMHw3WzA1XSkpIGIvaSAgICAgICAgICAgICAgICAgIC8vIFZvaWNlIFh0cmVtZSBQaG9uZXNcbiAgICAgICAgICAgIF0sIFtbVkVORE9SLCAnVm9pY2UnXSwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL1xcYihsdnRlbFxcLSk/KHYxWzEyXSkgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEx2VGVsIFBob25lc1xuICAgICAgICAgICAgXSwgW1tWRU5ET1IsICdMdlRlbCddLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvXFxiKHBoLTEpIC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFc3NlbnRpYWwgUEgtMVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnRXNzZW50aWFsJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL1xcYih2KDEwMG1kfDcwMG5hfDcwMTF8OTE3ZykuKlxcYikgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVudml6ZW4gVGFibGV0c1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnRW52aXplbiddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9cXGIodHJpb1stXFx3XFwuIF0rKSBiL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFjaFNwZWVkIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ01hY2hTcGVlZCddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9cXGJ0dV8oMTQ5MSkgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJvdG9yIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1JvdG9yJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgLygoPzp0ZWdyYW5vdGV8c2hpZWxkIHQoPyEuK2QgdHYpKVtcXHctIF0qPykoPzogYnxcXCkpL2kgICAgICAgICAgICAgIC8vIE52aWRpYSBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIE5WSURJQV0sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgLyhzcHJpbnQpIChcXHcrKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3ByaW50IFBob25lc1xuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgLyhraW5cXC5bb25ldHddezN9KS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWljcm9zb2Z0IEtpblxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgL1xcLi9nLCAnICddLCBbVkVORE9SLCBNSUNST1NPRlRdLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9kcm9pZC4rOyAoY2M2NjY2P3xldDVbMTZdfG1jWzIzOV1bMjNdeD98dmM4WzAzXXg/KVxcKS9pICAgICAgICAgICAgIC8vIFplYnJhXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIFpFQlJBXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvZHJvaWQuKzsgKGVjMzB8cHMyMHx0Y1syLThdXFxkW2t4XSlcXCkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBaRUJSQV0sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAvLyBTTUFSVFRWU1xuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgICAvc21hcnQtdHYuKyhzYW1zdW5nKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhbXN1bmdcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIFtUWVBFLCBTTUFSVFRWXV0sIFtcbiAgICAgICAgICAgIC9oYmJ0di4rbWFwbGU7KFxcZCspL2lcbiAgICAgICAgICAgIF0sIFtbTU9ERUwsIC9eLywgJ1NtYXJ0VFYnXSwgW1ZFTkRPUiwgU0FNU1VOR10sIFtUWVBFLCBTTUFSVFRWXV0sIFtcbiAgICAgICAgICAgIC8obnV4OyBuZXRjYXN0LitzbWFydHR2fGxnIChuZXRjYXN0XFwudHYtMjAxXFxkfGFuZHJvaWQgdHYpKS9pICAgICAgICAvLyBMRyBTbWFydFRWXG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgTEddLCBbVFlQRSwgU01BUlRUVl1dLCBbXG4gICAgICAgICAgICAvKGFwcGxlKSA/dHYvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGxlIFRWXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBbTU9ERUwsIEFQUExFKycgVFYnXSwgW1RZUEUsIFNNQVJUVFZdXSwgW1xuICAgICAgICAgICAgL2Nya2V5L2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHb29nbGUgQ2hyb21lY2FzdFxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgQ0hST01FKydjYXN0J10sIFtWRU5ET1IsIEdPT0dMRV0sIFtUWVBFLCBTTUFSVFRWXV0sIFtcbiAgICAgICAgICAgIC9kcm9pZC4rYWZ0KFxcdyspKCBidWl8XFwpKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlIFRWXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIEFNQVpPTl0sIFtUWVBFLCBTTUFSVFRWXV0sIFtcbiAgICAgICAgICAgIC8oc2hpZWxkIFxcdysgdHYpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE52aWRpYSBTaGllbGQgVFZcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgTlZJRElBXSwgW1RZUEUsIFNNQVJUVFZdXSwgW1xuICAgICAgICAgICAgL1xcKGR0dltcXCk7XS4rKGFxdW9zKS9pLFxuICAgICAgICAgICAgLyhhcXVvcy10dltcXHcgXSspXFwpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoYXJwXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIFNIQVJQXSwgW1RZUEUsIFNNQVJUVFZdXSxbXG4gICAgICAgICAgICAvKGJyYXZpYVtcXHcgXSspKCBidWl8XFwpKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbnlcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgU09OWV0sIFtUWVBFLCBTTUFSVFRWXV0sIFtcbiAgICAgICAgICAgIC8obWkodHZ8Ym94KS0/XFx3KykgYnVpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFhpYW9taVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBYSUFPTUldLCBbVFlQRSwgU01BUlRUVl1dLCBbXG4gICAgICAgICAgICAvSGJidHYuKih0ZWNobmlzYXQpICguKik7L2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRlY2huaVNBVFxuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBTTUFSVFRWXV0sIFtcbiAgICAgICAgICAgIC9cXGIocm9rdSlbXFxkeF0qW1xcKVxcL10oKD86ZHZwLSk/W1xcZFxcLl0qKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUm9rdVxuICAgICAgICAgICAgL2hiYnR2XFwvXFxkK1xcLlxcZCtcXC5cXGQrICtcXChbXFx3XFwrIF0qOyAqKFtcXHdcXGRdW147XSopOyhbXjtdKikvaSAgICAgICAgIC8vIEhiYlRWIGRldmljZXNcbiAgICAgICAgICAgIF0sIFtbVkVORE9SLCB0cmltXSwgW01PREVMLCB0cmltXSwgW1RZUEUsIFNNQVJUVFZdXSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTbWFydFRWIGZyb20gVW5pZGVudGlmaWVkIFZlbmRvcnNcbiAgICAgICAgICAgIC9kcm9pZC4rOyAoW1xcdy0gXSspICg/OmFuZHJvaWQgdHZ8c21hcnRbLSBdP3R2KS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtUWVBFLCBTTUFSVFRWXV0sIFtcbiAgICAgICAgICAgIC9cXGIoYW5kcm9pZCB0dnxzbWFydFstIF0/dHZ8b3BlcmEgdHZ8dHY7IHJ2OilcXGIvaVxuICAgICAgICAgICAgXSwgW1tUWVBFLCBTTUFSVFRWXV0sIFtcblxuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgLy8gQ09OU09MRVNcbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAgICAgLyhvdXlhKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdXlhXG4gICAgICAgICAgICAvKG5pbnRlbmRvKSAoW3dpZHMzdXRjaF0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5pbnRlbmRvXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIENPTlNPTEVdXSwgW1xuICAgICAgICAgICAgL2Ryb2lkLis7IChzaGllbGQpKCBidWl8XFwpKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTnZpZGlhIFBvcnRhYmxlXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIE5WSURJQV0sIFtUWVBFLCBDT05TT0xFXV0sIFtcbiAgICAgICAgICAgIC8ocGxheXN0YXRpb24gXFx3KykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBsYXlzdGF0aW9uXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIFNPTlldLCBbVFlQRSwgQ09OU09MRV1dLCBbXG4gICAgICAgICAgICAvXFxiKHhib3goPzogb25lKT8oPyE7IHhib3gpKVtcXCk7IF0vaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWljcm9zb2Z0IFhib3hcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgTUlDUk9TT0ZUXSwgW1RZUEUsIENPTlNPTEVdXSwgW1xuXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAvLyBXRUFSQUJMRVNcbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAgICAgL1xcYihzbS1bbHJdXFxkXFxkWzAxNTZdW2ZudXddP3M/fGdlYXIgbGl2ZSlcXGIvaSAgICAgICAgICAgICAgICAgICAgICAgLy8gU2Ftc3VuZyBHYWxheHkgV2F0Y2hcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgU0FNU1VOR10sIFtUWVBFLCBXRUFSQUJMRV1dLCBbXG4gICAgICAgICAgICAvKChwZWJibGUpKWFwcC9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBlYmJsZVxuICAgICAgICAgICAgLyhhc3VzfGdvb2dsZXxsZ3xvcHBvKSAoKHBpeGVsIHx6ZW4pP3dhdGNoW1xcdyBdKikoIGJ1aXxcXCkpL2kgICAgICAgIC8vIEFzdXMgWmVuV2F0Y2ggLyBMRyBXYXRjaCAvIFBpeGVsIFdhdGNoXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIFdFQVJBQkxFXV0sIFtcbiAgICAgICAgICAgIC8ob3coPzoxOXwyMCk/d2U/WzEtM117MSwzfSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BwbyBXYXRjaFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBPUFBPXSwgW1RZUEUsIFdFQVJBQkxFXV0sIFtcbiAgICAgICAgICAgIC8od2F0Y2gpKD86ID9vc1ssXFwvXXxcXGQsXFxkXFwvKVtcXGRcXC5dKy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbGUgV2F0Y2hcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgQVBQTEVdLCBbVFlQRSwgV0VBUkFCTEVdXSwgW1xuICAgICAgICAgICAgLyhvcHd3ZVxcZHszfSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25lUGx1cyBXYXRjaFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBPTkVQTFVTXSwgW1RZUEUsIFdFQVJBQkxFXV0sIFtcbiAgICAgICAgICAgIC8obW90byAzNjApL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW90b3JvbGEgMzYwXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIE1PVE9ST0xBXSwgW1RZUEUsIFdFQVJBQkxFXV0sIFtcbiAgICAgICAgICAgIC8oc21hcnR3YXRjaCAzKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29ueSBTbWFydFdhdGNoXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIFNPTlldLCBbVFlQRSwgV0VBUkFCTEVdXSwgW1xuICAgICAgICAgICAgLyhnIHdhdGNoIHIpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMRyBHIFdhdGNoIFJcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgTEddLCBbVFlQRSwgV0VBUkFCTEVdXSwgW1xuICAgICAgICAgICAgL2Ryb2lkLis7ICh3dDYzPzB7MiwzfSlcXCkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBaRUJSQV0sIFtUWVBFLCBXRUFSQUJMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgIC8vIFhSXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgICAgIC9kcm9pZC4rOyAoZ2xhc3MpIFxcZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvb2dsZSBHbGFzc1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBHT09HTEVdLCBbVFlQRSwgV0VBUkFCTEVdXSwgW1xuICAgICAgICAgICAgLyhwaWNvKSAoNHxuZW8zKD86IGxpbmt8cHJvKT8pL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQaWNvXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIFdFQVJBQkxFXV0sIFtcbiAgICAgICAgICAgIC87IChxdWVzdCggXFxkfCBwcm8pPykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9jdWx1cyBRdWVzdFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBGQUNFQk9PS10sIFtUWVBFLCBXRUFSQUJMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgIC8vIEVNQkVEREVEXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgICAgIC8odGVzbGEpKD86IHF0Y2FyYnJvd3NlcnxcXC9bLVxcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGVzbGFcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIFtUWVBFLCBFTUJFRERFRF1dLCBbXG4gICAgICAgICAgICAvKGFlb2JjKVxcYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFY2hvIERvdFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBBTUFaT05dLCBbVFlQRSwgRU1CRURERURdXSwgW1xuICAgICAgICAgICAgLyhob21lcG9kKS4rbWFjIG9zL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBsZSBIb21lUG9kXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIEFQUExFXSwgW1RZUEUsIEVNQkVEREVEXV0sIFtcbiAgICAgICAgICAgIC93aW5kb3dzIGlvdC9pXG4gICAgICAgICAgICBdLCBbW1RZUEUsIEVNQkVEREVEXV0sIFtcblxuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgIC8vIE1JWEVEIChHRU5FUklDKVxuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgICAvZHJvaWQgLis/OyAoW147XSs/KSg/OiBidWl8OyB3dlxcKXxcXCkgYXBwbGV3KS4rPyBtb2JpbGUgc2FmYXJpL2kgICAgLy8gQW5kcm9pZCBQaG9uZXMgZnJvbSBVbmlkZW50aWZpZWQgVmVuZG9yc1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9kcm9pZCAuKz87IChbXjtdKz8pKD86IGJ1aXxcXCkgYXBwbGV3KS4rPyg/ISBtb2JpbGUpIHNhZmFyaS9pICAgICAgIC8vIEFuZHJvaWQgVGFibGV0cyBmcm9tIFVuaWRlbnRpZmllZCBWZW5kb3JzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL1xcYigodGFibGV0fHRhYilbO1xcL118Zm9jdXNcXC9cXGQoPyEuK21vYmlsZSkpL2kgICAgICAgICAgICAgICAgICAgICAgLy8gVW5pZGVudGlmaWFibGUgVGFibGV0XG4gICAgICAgICAgICBdLCBbW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvKHBob25lfG1vYmlsZSg/Ols7XFwvXXwgWyBcXHdcXC9cXC5dKnNhZmFyaSl8cGRhKD89Lit3aW5kb3dzIGNlKSkvaSAgICAvLyBVbmlkZW50aWZpYWJsZSBNb2JpbGVcbiAgICAgICAgICAgIF0sIFtbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9kcm9pZCAuKz87IChbXFx3XFwuIC1dKykoIGJ1aXxcXCkpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJpYyBBbmRyb2lkIERldmljZVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnR2VuZXJpYyddXVxuICAgICAgICBdLFxuXG4gICAgICAgIGVuZ2luZSA6IFtbXG5cbiAgICAgICAgICAgIC93aW5kb3dzLisgZWRnZVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFZGdlSFRNTFxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCBFREdFKydIVE1MJ11dLCBbXG5cbiAgICAgICAgICAgIC8oYXJrd2ViKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXJrV2ViXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgL3dlYmtpdFxcLzUzN1xcLjM2LitjaHJvbWVcXC8oPyEyNykoW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsaW5rXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdCbGluayddXSwgW1xuXG4gICAgICAgICAgICAvKHByZXN0bylcXC8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXN0b1xuICAgICAgICAgICAgLyh3ZWJraXR8dHJpZGVudHxuZXRmcm9udHxuZXRzdXJmfGFtYXlhfGx5bnh8dzNtfGdvYW5uYXxzZXJ2bylcXC8oW1xcd1xcLl0rKS9pLCAvLyBXZWJLaXQvVHJpZGVudC9OZXRGcm9udC9OZXRTdXJmL0FtYXlhL0x5bngvdzNtL0dvYW5uYS9TZXJ2b1xuICAgICAgICAgICAgL2VraW9oKGZsb3cpXFwvKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGbG93XG4gICAgICAgICAgICAvKGtodG1sfHRhc21hbnxsaW5rcylbXFwvIF1cXCg/KFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLSFRNTC9UYXNtYW4vTGlua3NcbiAgICAgICAgICAgIC8oaWNhYilbXFwvIF0oWzIzXVxcLltcXGRcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlDYWJcblxuICAgICAgICAgICAgL1xcYihsaWJ3ZWIpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGliV2ViXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC9sYWR5YmlyZFxcLy9pXG4gICAgICAgICAgICBdLCBbW05BTUUsICdMaWJXZWInXV0sIFtcblxuICAgICAgICAgICAgL3J2XFw6KFtcXHdcXC5dezEsOX0pXFxiLisoZ2Vja28pL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2Vja29cbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBOQU1FXVxuICAgICAgICBdLFxuXG4gICAgICAgIG9zIDogW1tcblxuICAgICAgICAgICAgLy8gV2luZG93c1xuICAgICAgICAgICAgL21pY3Jvc29mdCAod2luZG93cykgKHZpc3RhfHhwKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaW5kb3dzIChpVHVuZXMpXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC8od2luZG93cyAoPzpwaG9uZSg/OiBvcyk/fG1vYmlsZXxpb3QpKVtcXC8gXT8oW1xcZFxcLlxcdyBdKikvaSAgICAgICAgIC8vIFdpbmRvd3MgUGhvbmVcbiAgICAgICAgICAgIF0sIFtOQU1FLCBbVkVSU0lPTiwgc3RyTWFwcGVyLCB3aW5kb3dzVmVyc2lvbk1hcF1dLCBbXG4gICAgICAgICAgICAvd2luZG93cyBudCA2XFwuMjsgKGFybSkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaW5kb3dzIFJUXG4gICAgICAgICAgICAvd2luZG93c1tcXC8gXShbbnRjZVxcZFxcLiBdK1xcdykoPyEuK3hib3gpL2ksXG4gICAgICAgICAgICAvKD86d2luKD89M3w5fG4pfHdpbiA5eCApKFtudFxcZFxcLl0rKS9pXG4gICAgICAgICAgICBdLCBbW1ZFUlNJT04sIHN0ck1hcHBlciwgd2luZG93c1ZlcnNpb25NYXBdLCBbTkFNRSwgJ1dpbmRvd3MnXV0sIFtcblxuICAgICAgICAgICAgLy8gaU9TL21hY09TXG4gICAgICAgICAgICAvW2FkZWhpbW5vcF17NCw3fVxcYig/Oi4qb3MgKFtcXHddKykgbGlrZSBtYWN8OyBvcGVyYSkvaSwgICAgICAgICAgICAgLy8gaU9TXG4gICAgICAgICAgICAvKD86aW9zO2Zic3ZcXC98aXBob25lLitpb3NbXFwvIF0pKFtcXGRcXC5dKykvaSxcbiAgICAgICAgICAgIC9jZm5ldHdvcmtcXC8uK2Rhcndpbi9pXG4gICAgICAgICAgICBdLCBbW1ZFUlNJT04sIC9fL2csICcuJ10sIFtOQU1FLCAnaU9TJ11dLCBbXG4gICAgICAgICAgICAvKG1hYyBvcyB4KSA/KFtcXHdcXC4gXSopL2ksXG4gICAgICAgICAgICAvKG1hY2ludG9zaHxtYWNfcG93ZXJwY1xcYikoPyEuK2hhaWt1KS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWMgT1NcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgTUFDX09TXSwgW1ZFUlNJT04sIC9fL2csICcuJ11dLCBbXG5cbiAgICAgICAgICAgIC8vIE1vYmlsZSBPU2VzXG4gICAgICAgICAgICAvZHJvaWQgKFtcXHdcXC5dKylcXGIuKyhhbmRyb2lkWy0gXXg4NnxoYXJtb255b3MpL2kgICAgICAgICAgICAgICAgICAgIC8vIEFuZHJvaWQteDg2L0hhcm1vbnlPU1xuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIE5BTUVdLCBbICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8odWJ1bnR1KSAoW1xcd1xcLl0rKSBsaWtlIGFuZHJvaWQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVYnVudHUgVG91Y2hcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgLyguKykvLCAnJDEgVG91Y2gnXSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW5kcm9pZC9CbGFja2JlcnJ5L1dlYk9TL1FOWC9CYWRhL1JJTS9LYWlPUy9NYWVtby9NZWVHby9TNDAvU2FpbGZpc2ggT1MvT3Blbkhhcm1vbnkvVGl6ZW5cbiAgICAgICAgICAgIC8oYW5kcm9pZHxiYWRhfGJsYWNrYmVycnl8a2Fpb3N8bWFlbW98bWVlZ298b3Blbmhhcm1vbnl8cW54fHJpbSB0YWJsZXQgb3N8c2FpbGZpc2h8c2VyaWVzNDB8c3ltYmlhbnx0aXplbnx3ZWJvcylcXHcqWy1cXC87IF0/KFtcXGRcXC5dKikvaVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvXFwoYmIoMTApOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCbGFja0JlcnJ5IDEwXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsIEJMQUNLQkVSUlldXSwgW1xuICAgICAgICAgICAgLyg/OnN5bWJpYW4gP29zfHN5bWJvc3xzNjAoPz07KXxzZXJpZXMgPzYwKVstXFwvIF0/KFtcXHdcXC5dKikvaSAgICAgICAvLyBTeW1iaWFuXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdTeW1iaWFuJ11dLCBbXG4gICAgICAgICAgICAvbW96aWxsYVxcL1tcXGRcXC5dKyBcXCgoPzptb2JpbGV8dGFibGV0fHR2fG1vYmlsZTsgW1xcdyBdKyk7IHJ2Oi4rIGdlY2tvXFwvKFtcXHdcXC5dKykvaSAvLyBGaXJlZm94IE9TXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsIEZJUkVGT1grJyBPUyddXSwgW1xuICAgICAgICAgICAgL3dlYjBzOy4rcnQodHYpL2ksXG4gICAgICAgICAgICAvXFxiKD86aHApP3dvcyg/OmJyb3dzZXIpP1xcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZWJPU1xuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnd2ViT1MnXV0sIFtcbiAgICAgICAgICAgIC93YXRjaCg/OiA/b3NbLFxcL118XFxkLFxcZFxcLykoW1xcZFxcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2F0Y2hPU1xuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnd2F0Y2hPUyddXSwgW1xuXG4gICAgICAgICAgICAvLyBHb29nbGUgQ2hyb21lY2FzdFxuICAgICAgICAgICAgL2Nya2V5XFwvKFtcXGRcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHb29nbGUgQ2hyb21lY2FzdFxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCBDSFJPTUUrJ2Nhc3QnXV0sIFtcbiAgICAgICAgICAgIC8oY3JvcykgW1xcd10rKD86XFwpfCAoW1xcd1xcLl0rKVxcYikvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWl1bSBPU1xuICAgICAgICAgICAgXSwgW1tOQU1FLCBDSFJPTUlVTV9PU10sIFZFUlNJT05dLFtcblxuICAgICAgICAgICAgLy8gU21hcnQgVFZzXG4gICAgICAgICAgICAvcGFuYXNvbmljOyh2aWVyYSkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhbmFzb25pYyBWaWVyYVxuICAgICAgICAgICAgLyhuZXRyYW5nZSltbWgvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXRyYW5nZVxuICAgICAgICAgICAgLyhuZXR0dilcXC8oXFxkK1xcLltcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldFRWXG5cbiAgICAgICAgICAgIC8vIENvbnNvbGVcbiAgICAgICAgICAgIC8obmludGVuZG98cGxheXN0YXRpb24pIChbd2lkczM0NXBvcnRhYmxldnVjaF0rKS9pLCAgICAgICAgICAgICAgICAgLy8gTmludGVuZG8vUGxheXN0YXRpb25cbiAgICAgICAgICAgIC8oeGJveCk7ICt4Ym94IChbXlxcKTtdKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pY3Jvc29mdCBYYm94ICgzNjAsIE9uZSwgWCwgUywgU2VyaWVzIFgsIFNlcmllcyBTKVxuXG4gICAgICAgICAgICAvLyBPdGhlclxuICAgICAgICAgICAgL1xcYihqb2xpfHBhbG0pXFxiID8oPzpvcyk/XFwvPyhbXFx3XFwuXSopL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEpvbGkvUGFsbVxuICAgICAgICAgICAgLyhtaW50KVtcXC9cXChcXCkgXT8oXFx3KikvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWludFxuICAgICAgICAgICAgLyhtYWdlaWF8dmVjdG9ybGludXgpWzsgXS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWdlaWEvVmVjdG9yTGludXhcbiAgICAgICAgICAgIC8oW2t4bG5dP3VidW50dXxkZWJpYW58c3VzZXxvcGVuc3VzZXxnZW50b298YXJjaCg/PSBsaW51eCl8c2xhY2t3YXJlfGZlZG9yYXxtYW5kcml2YXxjZW50b3N8cGNsaW51eG9zfHJlZCA/aGF0fHplbndhbGt8bGlucHVzfHJhc3BiaWFufHBsYW4gOXxtaW5peHxyaXNjIG9zfGNvbnRpa2l8ZGVlcGlufG1hbmphcm98ZWxlbWVudGFyeSBvc3xzYWJheW9ufGxpbnNwaXJlKSg/OiBnbnVcXC9saW51eCk/KD86IGVudGVycHJpc2UpPyg/OlstIF1saW51eCk/KD86LWdudSk/Wy1cXC8gXT8oPyFjaHJvbXxwYWNrYWdlKShbLVxcd1xcLl0qKS9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVYnVudHUvRGViaWFuL1NVU0UvR2VudG9vL0FyY2gvU2xhY2t3YXJlL0ZlZG9yYS9NYW5kcml2YS9DZW50T1MvUENMaW51eE9TL1JlZEhhdC9aZW53YWxrL0xpbnB1cy9SYXNwYmlhbi9QbGFuOS9NaW5peC9SSVNDT1MvQ29udGlraS9EZWVwaW4vTWFuamFyby9lbGVtZW50YXJ5L1NhYmF5b24vTGluc3BpcmVcbiAgICAgICAgICAgIC8oaHVyZHxsaW51eCkoPzogYXJtXFx3KnwgeDg2XFx3KnwgPykoW1xcd1xcLl0qKS9pLCAgICAgICAgICAgICAgICAgICAgIC8vIEh1cmQvTGludXhcbiAgICAgICAgICAgIC8oZ251KSA/KFtcXHdcXC5dKikvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHTlVcbiAgICAgICAgICAgIC9cXGIoWy1mcmVudG9wY2doc117MCw1fWJzZHxkcmFnb25mbHkpW1xcLyBdPyg/IWFtZHxbaXgzNDZdezEsMn04NikoW1xcd1xcLl0qKS9pLCAvLyBGcmVlQlNEL05ldEJTRC9PcGVuQlNEL1BDLUJTRC9HaG9zdEJTRC9EcmFnb25GbHlcbiAgICAgICAgICAgIC8oaGFpa3UpIChcXHcrKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhaWt1XG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC8oc3Vub3MpID8oW1xcd1xcLlxcZF0qKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29sYXJpc1xuICAgICAgICAgICAgXSwgW1tOQU1FLCAnU29sYXJpcyddLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgLygoPzpvcGVuKT9zb2xhcmlzKVstXFwvIF0/KFtcXHdcXC5dKikvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTb2xhcmlzXG4gICAgICAgICAgICAvKGFpeCkgKChcXGQpKD89XFwufFxcKXwgKVtcXHdcXC5dKSovaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQUlYXG4gICAgICAgICAgICAvXFxiKGJlb3N8b3NcXC8yfGFtaWdhb3N8bW9ycGhvc3xvcGVudm1zfGZ1Y2hzaWF8aHAtdXh8c2VyZW5pdHlvcykvaSwgLy8gQmVPUy9PUzIvQW1pZ2FPUy9Nb3JwaE9TL09wZW5WTVMvRnVjaHNpYS9IUC1VWC9TZXJlbml0eU9TXG4gICAgICAgICAgICAvKHVuaXgpID8oW1xcd1xcLl0qKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVU5JWFxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dXG4gICAgICAgIF1cbiAgICB9O1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBDb25zdHJ1Y3RvclxuICAgIC8vLy8vLy8vLy8vLy8vLy9cblxuICAgIHZhciBVQVBhcnNlciA9IGZ1bmN0aW9uICh1YSwgZXh0ZW5zaW9ucykge1xuXG4gICAgICAgIGlmICh0eXBlb2YgdWEgPT09IE9CSl9UWVBFKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zID0gdWE7XG4gICAgICAgICAgICB1YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVQVBhcnNlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVUFQYXJzZXIodWEsIGV4dGVuc2lvbnMpLmdldFJlc3VsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9uYXZpZ2F0b3IgPSAodHlwZW9mIHdpbmRvdyAhPT0gVU5ERUZfVFlQRSAmJiB3aW5kb3cubmF2aWdhdG9yKSA/IHdpbmRvdy5uYXZpZ2F0b3IgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBfdWEgPSB1YSB8fCAoKF9uYXZpZ2F0b3IgJiYgX25hdmlnYXRvci51c2VyQWdlbnQpID8gX25hdmlnYXRvci51c2VyQWdlbnQgOiBFTVBUWSk7XG4gICAgICAgIHZhciBfdWFjaCA9IChfbmF2aWdhdG9yICYmIF9uYXZpZ2F0b3IudXNlckFnZW50RGF0YSkgPyBfbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBfcmd4bWFwID0gZXh0ZW5zaW9ucyA/IGV4dGVuZChyZWdleGVzLCBleHRlbnNpb25zKSA6IHJlZ2V4ZXM7XG4gICAgICAgIHZhciBfaXNTZWxmTmF2ID0gX25hdmlnYXRvciAmJiBfbmF2aWdhdG9yLnVzZXJBZ2VudCA9PSBfdWE7XG5cbiAgICAgICAgdGhpcy5nZXRCcm93c2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9icm93c2VyID0ge307XG4gICAgICAgICAgICBfYnJvd3NlcltOQU1FXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIF9icm93c2VyW1ZFUlNJT05dID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmd4TWFwcGVyLmNhbGwoX2Jyb3dzZXIsIF91YSwgX3JneG1hcC5icm93c2VyKTtcbiAgICAgICAgICAgIF9icm93c2VyW01BSk9SXSA9IG1ham9yaXplKF9icm93c2VyW1ZFUlNJT05dKTtcbiAgICAgICAgICAgIC8vIEJyYXZlLXNwZWNpZmljIGRldGVjdGlvblxuICAgICAgICAgICAgaWYgKF9pc1NlbGZOYXYgJiYgX25hdmlnYXRvciAmJiBfbmF2aWdhdG9yLmJyYXZlICYmIHR5cGVvZiBfbmF2aWdhdG9yLmJyYXZlLmlzQnJhdmUgPT0gRlVOQ19UWVBFKSB7XG4gICAgICAgICAgICAgICAgX2Jyb3dzZXJbTkFNRV0gPSAnQnJhdmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9icm93c2VyO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldENQVSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfY3B1ID0ge307XG4gICAgICAgICAgICBfY3B1W0FSQ0hJVEVDVFVSRV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZ3hNYXBwZXIuY2FsbChfY3B1LCBfdWEsIF9yZ3htYXAuY3B1KTtcbiAgICAgICAgICAgIHJldHVybiBfY3B1O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldERldmljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfZGV2aWNlID0ge307XG4gICAgICAgICAgICBfZGV2aWNlW1ZFTkRPUl0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBfZGV2aWNlW01PREVMXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIF9kZXZpY2VbVFlQRV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZ3hNYXBwZXIuY2FsbChfZGV2aWNlLCBfdWEsIF9yZ3htYXAuZGV2aWNlKTtcbiAgICAgICAgICAgIGlmIChfaXNTZWxmTmF2ICYmICFfZGV2aWNlW1RZUEVdICYmIF91YWNoICYmIF91YWNoLm1vYmlsZSkge1xuICAgICAgICAgICAgICAgIF9kZXZpY2VbVFlQRV0gPSBNT0JJTEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpUGFkT1Mtc3BlY2lmaWMgZGV0ZWN0aW9uOiBpZGVudGlmaWVkIGFzIE1hYywgYnV0IGhhcyBzb21lIGlPUy1vbmx5IHByb3BlcnRpZXNcbiAgICAgICAgICAgIGlmIChfaXNTZWxmTmF2ICYmIF9kZXZpY2VbTU9ERUxdID09ICdNYWNpbnRvc2gnICYmIF9uYXZpZ2F0b3IgJiYgdHlwZW9mIF9uYXZpZ2F0b3Iuc3RhbmRhbG9uZSAhPT0gVU5ERUZfVFlQRSAmJiBfbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzICYmIF9uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAyKSB7XG4gICAgICAgICAgICAgICAgX2RldmljZVtNT0RFTF0gPSAnaVBhZCc7XG4gICAgICAgICAgICAgICAgX2RldmljZVtUWVBFXSA9IFRBQkxFVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfZGV2aWNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldEVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfZW5naW5lID0ge307XG4gICAgICAgICAgICBfZW5naW5lW05BTUVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgX2VuZ2luZVtWRVJTSU9OXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJneE1hcHBlci5jYWxsKF9lbmdpbmUsIF91YSwgX3JneG1hcC5lbmdpbmUpO1xuICAgICAgICAgICAgcmV0dXJuIF9lbmdpbmU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0T1MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX29zID0ge307XG4gICAgICAgICAgICBfb3NbTkFNRV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBfb3NbVkVSU0lPTl0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZ3hNYXBwZXIuY2FsbChfb3MsIF91YSwgX3JneG1hcC5vcyk7XG4gICAgICAgICAgICBpZiAoX2lzU2VsZk5hdiAmJiAhX29zW05BTUVdICYmIF91YWNoICYmIF91YWNoLnBsYXRmb3JtICYmIF91YWNoLnBsYXRmb3JtICE9ICdVbmtub3duJykge1xuICAgICAgICAgICAgICAgIF9vc1tOQU1FXSA9IF91YWNoLnBsYXRmb3JtICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9jaHJvbWUgb3MvaSwgQ0hST01JVU1fT1MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvbWFjb3MvaSwgTUFDX09TKTsgICAgICAgICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfb3M7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0UmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1YSAgICAgIDogdGhpcy5nZXRVQSgpLFxuICAgICAgICAgICAgICAgIGJyb3dzZXIgOiB0aGlzLmdldEJyb3dzZXIoKSxcbiAgICAgICAgICAgICAgICBlbmdpbmUgIDogdGhpcy5nZXRFbmdpbmUoKSxcbiAgICAgICAgICAgICAgICBvcyAgICAgIDogdGhpcy5nZXRPUygpLFxuICAgICAgICAgICAgICAgIGRldmljZSAgOiB0aGlzLmdldERldmljZSgpLFxuICAgICAgICAgICAgICAgIGNwdSAgICAgOiB0aGlzLmdldENQVSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFVBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF91YTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRVQSA9IGZ1bmN0aW9uICh1YSkge1xuICAgICAgICAgICAgX3VhID0gKHR5cGVvZiB1YSA9PT0gU1RSX1RZUEUgJiYgdWEubGVuZ3RoID4gVUFfTUFYX0xFTkdUSCkgPyB0cmltKHVhLCBVQV9NQVhfTEVOR1RIKSA6IHVhO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0VUEoX3VhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFVBUGFyc2VyLlZFUlNJT04gPSBMSUJWRVJTSU9OO1xuICAgIFVBUGFyc2VyLkJST1dTRVIgPSAgZW51bWVyaXplKFtOQU1FLCBWRVJTSU9OLCBNQUpPUl0pO1xuICAgIFVBUGFyc2VyLkNQVSA9IGVudW1lcml6ZShbQVJDSElURUNUVVJFXSk7XG4gICAgVUFQYXJzZXIuREVWSUNFID0gZW51bWVyaXplKFtNT0RFTCwgVkVORE9SLCBUWVBFLCBDT05TT0xFLCBNT0JJTEUsIFNNQVJUVFYsIFRBQkxFVCwgV0VBUkFCTEUsIEVNQkVEREVEXSk7XG4gICAgVUFQYXJzZXIuRU5HSU5FID0gVUFQYXJzZXIuT1MgPSBlbnVtZXJpemUoW05BTUUsIFZFUlNJT05dKTtcblxuICAgIC8vLy8vLy8vLy8vXG4gICAgLy8gRXhwb3J0XG4gICAgLy8vLy8vLy8vL1xuXG4gICAgLy8gY2hlY2sganMgZW52aXJvbm1lbnRcbiAgICBpZiAodHlwZW9mKGV4cG9ydHMpICE9PSBVTkRFRl9UWVBFKSB7XG4gICAgICAgIC8vIG5vZGVqcyBlbnZcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09IFVOREVGX1RZUEUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFVBUGFyc2VyO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydHMuVUFQYXJzZXIgPSBVQVBhcnNlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXF1aXJlanMgZW52IChvcHRpb25hbClcbiAgICAgICAgaWYgKHR5cGVvZihkZWZpbmUpID09PSBGVU5DX1RZUEUgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVUFQYXJzZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBVTkRFRl9UWVBFKSB7XG4gICAgICAgICAgICAvLyBicm93c2VyIGVudlxuICAgICAgICAgICAgd2luZG93LlVBUGFyc2VyID0gVUFQYXJzZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBqUXVlcnkvWmVwdG8gc3BlY2lmaWMgKG9wdGlvbmFsKVxuICAgIC8vIE5vdGU6XG4gICAgLy8gICBJbiBBTUQgZW52IHRoZSBnbG9iYWwgc2NvcGUgc2hvdWxkIGJlIGtlcHQgY2xlYW4sIGJ1dCBqUXVlcnkgaXMgYW4gZXhjZXB0aW9uLlxuICAgIC8vICAgalF1ZXJ5IGFsd2F5cyBleHBvcnRzIHRvIGdsb2JhbCBzY29wZSwgdW5sZXNzIGpRdWVyeS5ub0NvbmZsaWN0KHRydWUpIGlzIHVzZWQsXG4gICAgLy8gICBhbmQgd2Ugc2hvdWxkIGNhdGNoIHRoYXQuXG4gICAgdmFyICQgPSB0eXBlb2Ygd2luZG93ICE9PSBVTkRFRl9UWVBFICYmICh3aW5kb3cualF1ZXJ5IHx8IHdpbmRvdy5aZXB0byk7XG4gICAgaWYgKCQgJiYgISQudWEpIHtcbiAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBVQVBhcnNlcigpO1xuICAgICAgICAkLnVhID0gcGFyc2VyLmdldFJlc3VsdCgpO1xuICAgICAgICAkLnVhLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZXIuZ2V0VUEoKTtcbiAgICAgICAgfTtcbiAgICAgICAgJC51YS5zZXQgPSBmdW5jdGlvbiAodWEpIHtcbiAgICAgICAgICAgIHBhcnNlci5zZXRVQSh1YSk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VyLmdldFJlc3VsdCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAkLnVhW3Byb3BdID0gcmVzdWx0W3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxufSkodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgPyB3aW5kb3cgOiB0aGlzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ua-parser-js/src/ua-parser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"2f0e5bee585a\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvZ2xvYmFscy5jc3M/ZDVlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjJmMGU1YmVlNTg1YVwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/head-manager.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/head-manager.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DOMAttributeNames: function() {\n        return DOMAttributeNames;\n    },\n    default: function() {\n        return initHeadManager;\n    },\n    isEqualNode: function() {\n        return isEqualNode;\n    }\n});\nconst DOMAttributeNames = {\n    acceptCharset: \"accept-charset\",\n    className: \"class\",\n    htmlFor: \"for\",\n    httpEquiv: \"http-equiv\",\n    noModule: \"noModule\"\n};\nfunction reactElementToDOM(param) {\n    let { type, props } = param;\n    const el = document.createElement(type);\n    for(const p in props){\n        if (!props.hasOwnProperty(p)) continue;\n        if (p === \"children\" || p === \"dangerouslySetInnerHTML\") continue;\n        // we don't render undefined props to the DOM\n        if (props[p] === undefined) continue;\n        const attr = DOMAttributeNames[p] || p.toLowerCase();\n        if (type === \"script\" && (attr === \"async\" || attr === \"defer\" || attr === \"noModule\")) {\n            el[attr] = !!props[p];\n        } else {\n            el.setAttribute(attr, props[p]);\n        }\n    }\n    const { children, dangerouslySetInnerHTML } = props;\n    if (dangerouslySetInnerHTML) {\n        el.innerHTML = dangerouslySetInnerHTML.__html || \"\";\n    } else if (children) {\n        el.textContent = typeof children === \"string\" ? children : Array.isArray(children) ? children.join(\"\") : \"\";\n    }\n    return el;\n}\nfunction isEqualNode(oldTag, newTag) {\n    if (oldTag instanceof HTMLElement && newTag instanceof HTMLElement) {\n        const nonce = newTag.getAttribute(\"nonce\");\n        // Only strip the nonce if `oldTag` has had it stripped. An element's nonce attribute will not\n        // be stripped if there is no content security policy response header that includes a nonce.\n        if (nonce && !oldTag.getAttribute(\"nonce\")) {\n            const cloneTag = newTag.cloneNode(true);\n            cloneTag.setAttribute(\"nonce\", \"\");\n            cloneTag.nonce = nonce;\n            return nonce === oldTag.nonce && oldTag.isEqualNode(cloneTag);\n        }\n    }\n    return oldTag.isEqualNode(newTag);\n}\nlet updateElements;\nif (false) {} else {\n    updateElements = (type, components)=>{\n        const headEl = document.getElementsByTagName(\"head\")[0];\n        const headCountEl = headEl.querySelector(\"meta[name=next-head-count]\");\n        if (true) {\n            if (!headCountEl) {\n                console.error(\"Warning: next-head-count is missing. https://nextjs.org/docs/messages/next-head-count-missing\");\n                return;\n            }\n        }\n        const headCount = Number(headCountEl.content);\n        const oldTags = [];\n        for(let i = 0, j = headCountEl.previousElementSibling; i < headCount; i++, j = (j == null ? void 0 : j.previousElementSibling) || null){\n            var _j_tagName;\n            if ((j == null ? void 0 : (_j_tagName = j.tagName) == null ? void 0 : _j_tagName.toLowerCase()) === type) {\n                oldTags.push(j);\n            }\n        }\n        const newTags = components.map(reactElementToDOM).filter((newTag)=>{\n            for(let k = 0, len = oldTags.length; k < len; k++){\n                const oldTag = oldTags[k];\n                if (isEqualNode(oldTag, newTag)) {\n                    oldTags.splice(k, 1);\n                    return false;\n                }\n            }\n            return true;\n        });\n        oldTags.forEach((t)=>{\n            var _t_parentNode;\n            return (_t_parentNode = t.parentNode) == null ? void 0 : _t_parentNode.removeChild(t);\n        });\n        newTags.forEach((t)=>headEl.insertBefore(t, headCountEl));\n        headCountEl.content = (headCount - oldTags.length + newTags.length).toString();\n    };\n}\nfunction initHeadManager() {\n    return {\n        mountedInstances: new Set(),\n        updateHead: (head)=>{\n            const tags = {};\n            head.forEach((h)=>{\n                if (// it won't be inlined. In this case revert to the original behavior\n                h.type === \"link\" && h.props[\"data-optimized-fonts\"]) {\n                    if (document.querySelector('style[data-href=\"' + h.props[\"data-href\"] + '\"]')) {\n                        return;\n                    } else {\n                        h.props.href = h.props[\"data-href\"];\n                        h.props[\"data-href\"] = undefined;\n                    }\n                }\n                const components = tags[h.type] || [];\n                components.push(h);\n                tags[h.type] = components;\n            });\n            const titleComponent = tags.title ? tags.title[0] : null;\n            let title = \"\";\n            if (titleComponent) {\n                const { children } = titleComponent.props;\n                title = typeof children === \"string\" ? children : Array.isArray(children) ? children.join(\"\") : \"\";\n            }\n            if (title !== document.title) document.title = title;\n            [\n                \"meta\",\n                \"base\",\n                \"link\",\n                \"style\",\n                \"script\"\n            ].forEach((type)=>{\n                updateElements(type, tags[type] || []);\n            });\n        }\n    };\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=head-manager.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2hlYWQtbWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFBYUEsbUJBQWlCO2VBQWpCQTs7SUFtTGJDLFNBZ0RDO2VBaER1QkM7O0lBM0hSQyxhQUFXO2VBQVhBOzs7QUF4RFQsTUFBTUgsb0JBQTRDO0lBQ3ZESSxlQUFlO0lBQ2ZDLFdBQVc7SUFDWEMsU0FBUztJQUNUQyxXQUFXO0lBQ1hDLFVBQVU7QUFDWjtBQUVBLFNBQVNDLGtCQUFrQkMsS0FBNEI7SUFBNUIsTUFBRUMsSUFBSSxFQUFFQyxLQUFLLEVBQWUsR0FBNUJGO0lBQ3pCLE1BQU1HLEtBQWtCQyxTQUFTQyxhQUFhLENBQUNKO0lBQy9DLElBQUssTUFBTUssS0FBS0osTUFBTztRQUNyQixJQUFJLENBQUNBLE1BQU1LLGNBQWMsQ0FBQ0QsSUFBSTtRQUM5QixJQUFJQSxNQUFNLGNBQWNBLE1BQU0sMkJBQTJCO1FBRXpELDZDQUE2QztRQUM3QyxJQUFJSixLQUFLLENBQUNJLEVBQUUsS0FBS0UsV0FBVztRQUU1QixNQUFNQyxPQUFPbkIsaUJBQWlCLENBQUNnQixFQUFFLElBQUlBLEVBQUVJLFdBQVc7UUFDbEQsSUFDRVQsU0FBUyxZQUNSUSxDQUFBQSxTQUFTLFdBQVdBLFNBQVMsV0FBV0EsU0FBUyxhQUNsRDtZQUNFTixFQUF3QixDQUFDTSxLQUFLLEdBQUcsQ0FBQyxDQUFDUCxLQUFLLENBQUNJLEVBQUU7UUFDL0MsT0FBTztZQUNMSCxHQUFHUSxZQUFZLENBQUNGLE1BQU1QLEtBQUssQ0FBQ0ksRUFBRTtRQUNoQztJQUNGO0lBRUEsTUFBTSxFQUFFTSxRQUFRLEVBQUVDLHVCQUF1QixFQUFFLEdBQUdYO0lBQzlDLElBQUlXLHlCQUF5QjtRQUMzQlYsR0FBR1csU0FBUyxHQUFHRCx3QkFBd0JFLE1BQU0sSUFBSTtJQUNuRCxPQUFPLElBQUlILFVBQVU7UUFDbkJULEdBQUdhLFdBQVcsR0FD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R0FBQyxPQUNoRTt3QkFDQTtvQkFDRixPQUFPO3dCQUNMeUUsRUFBRXpFLEtBQUssQ0FBQzBFLElBQUksR0FBR0QsRUFBRXpFLEtBQUssQ0FBQyxZQUFZO3dCQUNuQ3lFLEVBQUV6RSxLQUFLLENBQUMsWUFBWSxHQUFHTTtvQkFDekI7Z0JBQ0Y7Z0JBRUEsTUFBTXVCLGFBQWEyQyxJQUFJLENBQUNDLEVBQUUxRSxJQUFJLENBQUMsSUFBSSxFQUFFO2dCQUNyQzhCLFdBQVdPLElBQUksQ0FBQ3FDO2dCQUNoQkQsSUFBSSxDQUFDQyxFQUFFMUUsSUFBSSxDQUFDLEdBQUc4QjtZQUNqQjtZQUVBLE1BQU04QyxpQkFBaUJILEtBQUtJLEtBQUssR0FBR0osS0FBS0ksS0FBSyxDQUFDLEVBQUUsR0FBRztZQUNwRCxJQUFJQSxRQUFRO1lBQ1osSUFBSUQsZ0JBQWdCO2dCQUNsQixNQUFNLEVBQUVqRSxRQUFRLEVBQUUsR0FBR2lFLGVBQWUzRSxLQUFLO2dCQUN6QzRFLFFBQ0UsT0FBT2xFLGFBQWEsV0FDaEJBLFdBQ0FLLE1BQU1DLE9BQU8sQ0FBQ04sWUFDZEEsU0FBU08sSUFBSSxDQUFDLE1BQ2Q7WUFDUjtZQUNBLElBQUkyRCxVQUFVMUUsU0FBUzBFLEtBQUssRUFBRTFFLFNBQVMwRSxLQUFLLEdBQUdBO1lBQzlDO2dCQUFDO2dCQUFRO2dCQUFRO2dCQUFRO2dCQUFTO2FBQVMsQ0FBQzNCLE9BQU8sQ0FBQyxDQUFDbEQ7Z0JBQ3BEMEIsZUFBZTFCLE1BQU15RSxJQUFJLENBQUN6RSxLQUFLLElBQUksRUFBRTtZQUN2QztRQUNGO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2NsaWVudC9oZWFkLW1hbmFnZXIudHM/NzEwOSJdLCJuYW1lcyI6WyJET01BdHRyaWJ1dGVOYW1lcyIsImRlZmF1bHQiLCJpbml0SGVhZE1hbmFnZXIiLCJpc0VxdWFsTm9kZSIsImFjY2VwdENoYXJzZXQiLCJjbGFzc05hbWUiLCJodG1sRm9yIiwiaHR0cEVxdWl2Iiwibm9Nb2R1bGUiLCJyZWFjdEVsZW1lbnRUb0RPTSIsInBhcmFtIiwidHlwZSIsInByb3BzIiwiZWwiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJwIiwiaGFzT3duUHJvcGVydHkiLCJ1bmRlZmluZWQiLCJhdHRyIiwidG9Mb3dlckNhc2UiLCJzZXRBdHRyaWJ1dGUiLCJjaGlsZHJlbiIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiaW5uZXJIVE1MIiwiX19odG1sIiwidGV4dENvbnRlbnQiLCJBcnJheSIsImlzQXJyYXkiLCJqb2luIiwib2xkVGFnIiwibmV3VGFnIiwiSFRNTEVsZW1lbnQiLCJub25jZSIsImdldEF0dHJpYnV0ZSIsImNsb25lVGFnIiwiY2xvbmVOb2RlIiwidXBkYXRlRWxlbWVudHMiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1NUUklDVF9ORVhUX0hFQUQiLCJjb21wb25lbnRzIiwiaGVhZEVsIiwicXVlcnlTZWxlY3RvciIsImhlYWRNZXRhVGFncyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJvbGRUYWdzIiwibWV0YUNoYXJzZXQiLCJwdXNoIiwiaSIsImxlbmd0aCIsImhlYWRUYWciLCJtZXRhVGFnIiwibmV4dFNpYmxpbmciLCJ0YWdOYW1lIiwibmV3VGFncyIsIm1hcCIsImZpbHRlciIsImsiLCJsZW4iLCJzcGxpY2UiLCJmb3JFYWNoIiwidCIsInByZXZpb3VzU2libGluZyIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsIm1ldGEiLCJuYW1lIiwiY29udGVudCIsImFwcGVuZENoaWxkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJoZWFkQ291bnRFbCIsImNvbnNvbGUiLCJlcnJvciIsImhlYWRDb3VudCIsIk51bWJlciIsImoiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwiaW5zZXJ0QmVmb3JlIiwidG9TdHJpbmciLCJtb3VudGVkSW5zdGFuY2VzIiwiU2V0IiwidXBkYXRlSGVhZCIsImhlYWQiLCJ0YWdzIiwiaCIsImhyZWYiLCJ0aXRsZUNvbXBvbmVudCIsInRpdGxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/head-manager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    cancelIdleCallback: function() {\n        return cancelIdleCallback;\n    },\n    requestIdleCallback: function() {\n        return requestIdleCallback;\n    }\n});\nconst requestIdleCallback = typeof self !== \"undefined\" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n    let start = Date.now();\n    return self.setTimeout(function() {\n        cb({\n            didTimeout: false,\n            timeRemaining: function() {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n};\nconst cancelIdleCallback = typeof self !== \"undefined\" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n    return clearTimeout(id);\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=request-idle-callback.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFnQmFBLG9CQUFrQjtlQUFsQkE7O0lBaEJBQyxxQkFBbUI7ZUFBbkJBOzs7QUFBTixNQUFNQSxzQkFDWCxPQUFRQyxTQUFTLGVBQ2ZBLEtBQUtELG1CQUFtQixJQUN4QkMsS0FBS0QsbUJBQW1CLENBQUNFLElBQUksQ0FBQ0MsV0FDaEMsU0FBVUMsRUFBdUI7SUFDL0IsSUFBSUMsUUFBUUMsS0FBS0MsR0FBRztJQUNwQixPQUFPTixLQUFLTyxVQUFVLENBQUM7UUFDckJKLEdBQUc7WUFDREssWUFBWTtZQUNaQyxlQUFlO2dCQUNiLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLEtBQU1OLENBQUFBLEtBQUtDLEdBQUcsS0FBS0YsS0FBQUE7WUFDeEM7UUFDRjtJQUNGLEdBQUc7QUFDTDtBQUVLLE1BQU1OLHFCQUNYLE9BQVFFLFNBQVMsZUFDZkEsS0FBS0Ysa0JBQWtCLElBQ3ZCRSxLQUFLRixrQkFBa0IsQ0FBQ0csSUFBSSxDQUFDQyxXQUMvQixTQUFVVSxFQUFVO0lBQ2xCLE9BQU9DLGFBQWFEO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay50cz8wNWY0Il0sIm5hbWVzIjpbImNhbmNlbElkbGVDYWxsYmFjayIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJzZWxmIiwiYmluZCIsIndpbmRvdyIsImNiIiwic3RhcnQiLCJEYXRlIiwibm93Iiwic2V0VGltZW91dCIsImRpZFRpbWVvdXQiLCJ0aW1lUmVtYWluaW5nIiwiTWF0aCIsIm1heCIsImlkIiwiY2xlYXJUaW1lb3V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/script.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/script.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return _default;\n    },\n    handleClientScriptLoad: function() {\n        return handleClientScriptLoad;\n    },\n    initScriptLoader: function() {\n        return initScriptLoader;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"));\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ../shared/lib/head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _headmanager = __webpack_require__(/*! ./head-manager */ \"(app-pages-browser)/./node_modules/next/dist/client/head-manager.js\");\nconst _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\");\nconst ScriptCache = new Map();\nconst LoadCache = new Set();\nconst ignoreProps = [\n    \"onLoad\",\n    \"onReady\",\n    \"dangerouslySetInnerHTML\",\n    \"children\",\n    \"onError\",\n    \"strategy\",\n    \"stylesheets\"\n];\nconst insertStylesheets = (stylesheets)=>{\n    // Case 1: Styles for afterInteractive/lazyOnload with appDir injected via handleClientScriptLoad\n    //\n    // Using ReactDOM.preinit to feature detect appDir and inject styles\n    // Stylesheets might have already been loaded if initialized with Script component\n    // Re-inject styles here to handle scripts loaded via handleClientScriptLoad\n    // ReactDOM.preinit handles dedup and ensures the styles are loaded only once\n    if (_reactdom.default.preinit) {\n        stylesheets.forEach((stylesheet)=>{\n            _reactdom.default.preinit(stylesheet, {\n                as: \"style\"\n            });\n        });\n        return;\n    }\n    // Case 2: Styles for afterInteractive/lazyOnload with pages injected via handleClientScriptLoad\n    //\n    // We use this function to load styles when appdir is not detected\n    // TODO: Use React float APIs to load styles once available for pages dir\n    if (typeof window !== \"undefined\") {\n        let head = document.head;\n        stylesheets.forEach((stylesheet)=>{\n            let link = document.createElement(\"link\");\n            link.type = \"text/css\";\n            link.rel = \"stylesheet\";\n            link.href = stylesheet;\n            head.appendChild(link);\n        });\n    }\n};\nconst loadScript = (props)=>{\n    const { src, id, onLoad = ()=>{}, onReady = null, dangerouslySetInnerHTML, children = \"\", strategy = \"afterInteractive\", onError, stylesheets } = props;\n    const cacheKey = id || src;\n    // Script has already loaded\n    if (cacheKey && LoadCache.has(cacheKey)) {\n        return;\n    }\n    // Contents of this script are already loading/loaded\n    if (ScriptCache.has(src)) {\n        LoadCache.add(cacheKey);\n        // It is possible that multiple `next/script` components all have same \"src\", but has different \"onLoad\"\n        // This is to make sure the same remote script will only load once, but \"onLoad\" are executed in order\n        ScriptCache.get(src).then(onLoad, onError);\n        return;\n    }\n    /** Execute after the script first loaded */ const afterLoad = ()=>{\n        // Run onReady for the first time after load event\n        if (onReady) {\n            onReady();\n        }\n        // add cacheKey to LoadCache when load successfully\n        LoadCache.add(cacheKey);\n    };\n    const el = document.createElement(\"script\");\n    const loadPromise = new Promise((resolve, reject)=>{\n        el.addEventListener(\"load\", function(e) {\n            resolve();\n            if (onLoad) {\n                onLoad.call(this, e);\n            }\n            afterLoad();\n        });\n        el.addEventListener(\"error\", function(e) {\n            reject(e);\n        });\n    }).catch(function(e) {\n        if (onError) {\n            onError(e);\n        }\n    });\n    if (dangerouslySetInnerHTML) {\n        // Casting since lib.dom.d.ts doesn't have TrustedHTML yet.\n        el.innerHTML = dangerouslySetInnerHTML.__html || \"\";\n        afterLoad();\n    } else if (children) {\n        el.textContent = typeof children === \"string\" ? children : Array.isArray(children) ? children.join(\"\") : \"\";\n        afterLoad();\n    } else if (src) {\n        el.src = src;\n        // do not add cacheKey into LoadCache for remote script here\n        // cacheKey will be added to LoadCache when it is actually loaded (see loadPromise above)\n        ScriptCache.set(src, loadPromise);\n    }\n    for (const [k, value] of Object.entries(props)){\n        if (value === undefined || ignoreProps.includes(k)) {\n            continue;\n        }\n        const attr = _headmanager.DOMAttributeNames[k] || k.toLowerCase();\n        el.setAttribute(attr, value);\n    }\n    if (strategy === \"worker\") {\n        el.setAttribute(\"type\", \"text/partytown\");\n    }\n    el.setAttribute(\"data-nscript\", strategy);\n    // Load styles associated with this script\n    if (stylesheets) {\n        insertStylesheets(stylesheets);\n    }\n    document.body.appendChild(el);\n};\nfunction handleClientScriptLoad(props) {\n    const { strategy = \"afterInteractive\" } = props;\n    if (strategy === \"lazyOnload\") {\n        window.addEventListener(\"load\", ()=>{\n            (0, _requestidlecallback.requestIdleCallback)(()=>loadScript(props));\n        });\n    } else {\n        loadScript(props);\n    }\n}\nfunction loadLazyScript(props) {\n    if (document.readyState === \"complete\") {\n        (0, _requestidlecallback.requestIdleCallback)(()=>loadScript(props));\n    } else {\n        window.addEventListener(\"load\", ()=>{\n            (0, _requestidlecallback.requestIdleCallback)(()=>loadScript(props));\n        });\n    }\n}\nfunction addBeforeInteractiveToCache() {\n    const scripts = [\n        ...document.querySelectorAll('[data-nscript=\"beforeInteractive\"]'),\n        ...document.querySelectorAll('[data-nscript=\"beforePageRender\"]')\n    ];\n    scripts.forEach((script)=>{\n        const cacheKey = script.id || script.getAttribute(\"src\");\n        LoadCache.add(cacheKey);\n    });\n}\nfunction initScriptLoader(scriptLoaderItems) {\n    scriptLoaderItems.forEach(handleClientScriptLoad);\n    addBeforeInteractiveToCache();\n}\n/**\n * Load a third-party scripts in an optimized way.\n *\n * Read more: [Next.js Docs: `next/script`](https://nextjs.org/docs/app/api-reference/components/script)\n */ function Script(props) {\n    const { id, src = \"\", onLoad = ()=>{}, onReady = null, strategy = \"afterInteractive\", onError, stylesheets, ...restProps } = props;\n    // Context is available only during SSR\n    const { updateScripts, scripts, getIsSsr, appDir, nonce } = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);\n    /**\n   * - First mount:\n   *   1. The useEffect for onReady executes\n   *   2. hasOnReadyEffectCalled.current is false, but the script hasn't loaded yet (not in LoadCache)\n   *      onReady is skipped, set hasOnReadyEffectCalled.current to true\n   *   3. The useEffect for loadScript executes\n   *   4. hasLoadScriptEffectCalled.current is false, loadScript executes\n   *      Once the script is loaded, the onLoad and onReady will be called by then\n   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n   *   5. The useEffect for onReady executes again\n   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n   *   7. The useEffect for loadScript executes again\n   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n   *\n   * - Second mount:\n   *   1. The useEffect for onReady executes\n   *   2. hasOnReadyEffectCalled.current is false, but the script has already loaded (found in LoadCache)\n   *      onReady is called, set hasOnReadyEffectCalled.current to true\n   *   3. The useEffect for loadScript executes\n   *   4. The script is already loaded, loadScript bails out\n   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n   *   5. The useEffect for onReady executes again\n   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n   *   7. The useEffect for loadScript executes again\n   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n   */ const hasOnReadyEffectCalled = (0, _react.useRef)(false);\n    (0, _react.useEffect)(()=>{\n        const cacheKey = id || src;\n        if (!hasOnReadyEffectCalled.current) {\n            // Run onReady if script has loaded before but component is re-mounted\n            if (onReady && cacheKey && LoadCache.has(cacheKey)) {\n                onReady();\n            }\n            hasOnReadyEffectCalled.current = true;\n        }\n    }, [\n        onReady,\n        id,\n        src\n    ]);\n    const hasLoadScriptEffectCalled = (0, _react.useRef)(false);\n    (0, _react.useEffect)(()=>{\n        if (!hasLoadScriptEffectCalled.current) {\n            if (strategy === \"afterInteractive\") {\n                loadScript(props);\n            } else if (strategy === \"lazyOnload\") {\n                loadLazyScript(props);\n            }\n            hasLoadScriptEffectCalled.current = true;\n        }\n    }, [\n        props,\n        strategy\n    ]);\n    if (strategy === \"beforeInteractive\" || strategy === \"worker\") {\n        if (updateScripts) {\n            scripts[strategy] = (scripts[strategy] || []).concat([\n                {\n                    id,\n                    src,\n                    onLoad,\n                    onReady,\n                    onError,\n                    ...restProps\n                }\n            ]);\n            updateScripts(scripts);\n        } else if (getIsSsr && getIsSsr()) {\n            // Script has already loaded during SSR\n            LoadCache.add(id || src);\n        } else if (getIsSsr && !getIsSsr()) {\n            loadScript(props);\n        }\n    }\n    // For the app directory, we need React Float to preload these scripts.\n    if (appDir) {\n        // Injecting stylesheets here handles beforeInteractive and worker scripts correctly\n        // For other strategies injecting here ensures correct stylesheet order\n        // ReactDOM.preinit handles loading the styles in the correct order,\n        // also ensures the stylesheet is loaded only once and in a consistent manner\n        //\n        // Case 1: Styles for beforeInteractive/worker with appDir - handled here\n        // Case 2: Styles for beforeInteractive/worker with pages dir - Not handled yet\n        // Case 3: Styles for afterInteractive/lazyOnload with appDir - handled here\n        // Case 4: Styles for afterInteractive/lazyOnload with pages dir - handled in insertStylesheets function\n        if (stylesheets) {\n            stylesheets.forEach((styleSrc)=>{\n                _reactdom.default.preinit(styleSrc, {\n                    as: \"style\"\n                });\n            });\n        }\n        // Before interactive scripts need to be loaded by Next.js' runtime instead\n        // of native <script> tags, because they no longer have `defer`.\n        if (strategy === \"beforeInteractive\") {\n            if (!src) {\n                // For inlined scripts, we put the content in `children`.\n                if (restProps.dangerouslySetInnerHTML) {\n                    // Casting since lib.dom.d.ts doesn't have TrustedHTML yet.\n                    restProps.children = restProps.dangerouslySetInnerHTML.__html;\n                    delete restProps.dangerouslySetInnerHTML;\n                }\n                return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"script\", {\n                    nonce: nonce,\n                    dangerouslySetInnerHTML: {\n                        __html: \"(self.__next_s=self.__next_s||[]).push(\" + JSON.stringify([\n                            0,\n                            {\n                                ...restProps,\n                                id\n                            }\n                        ]) + \")\"\n                    }\n                });\n            } else {\n                // @ts-ignore\n                _reactdom.default.preload(src, restProps.integrity ? {\n                    as: \"script\",\n                    integrity: restProps.integrity,\n                    nonce\n                } : {\n                    as: \"script\",\n                    nonce\n                });\n                return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"script\", {\n                    nonce: nonce,\n                    dangerouslySetInnerHTML: {\n                        __html: \"(self.__next_s=self.__next_s||[]).push(\" + JSON.stringify([\n                            src,\n                            {\n                                ...restProps,\n                                id\n                            }\n                        ]) + \")\"\n                    }\n                });\n            }\n        } else if (strategy === \"afterInteractive\") {\n            if (src) {\n                // @ts-ignore\n                _reactdom.default.preload(src, restProps.integrity ? {\n                    as: \"script\",\n                    integrity: restProps.integrity,\n                    nonce\n                } : {\n                    as: \"script\",\n                    nonce\n                });\n            }\n        }\n    }\n    return null;\n}\n_c = Script;\nObject.defineProperty(Script, \"__nextScript\", {\n    value: true\n});\nconst _default = Script;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=script.js.map\nvar _c;\n$RefreshReg$(_c, \"Script\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3NjcmlwdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztRQWdZQUEsU0FBcUI7OztJQW5OTEM7NEJBQUFBOztJQWdDQUM7c0JBQUFBOzs7Ozs7OytFQTFNcUM7dURBRWxCQyxDQUFBLENBQUFDLG1CQUFBQSxDQUFBO3lDQUNEQSxtQkFBQUEsQ0FBQTs7QUFHbEMsTUFBTUMsdUJBQWtCQyxtQkFBQUEsQ0FBQUEsNkdBQUFBO0FBQ3hCLE1BQU1DLGNBQVksSUFBSUM7QUFpQnRCLE1BQU1DLFlBQUFBLElBQWNEO01BQ2xCQyxjQUFBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0Q7Q0FFRDtNQUNFQyxvQkFBQSxDQUFBQztJQUNBLGlHQUFFO0lBQ0Y7SUFDQTtJQUNBLGtGQUE0RTtJQUM1RTtJQUNBLDZFQUFzQjtRQUNwQkEsVUFBQUEsT0FBWUMsQ0FBQUEsT0FBU0MsRUFBQUE7b0JBQ25CQyxPQUFBQSxDQUFBQSxDQUFRRDtzQkFBMkJFLE9BQUEsQ0FBQUMsT0FBQSxDQUFBSCxZQUFBO2dCQUFRSSxJQUFBO1lBQzdDO1FBRUE7UUFDRjtJQUVBO0lBQ0EsZ0dBQUU7SUFDRjtJQUNBO0lBQ0EseUVBQW1DO1FBQ2pDLE9BQUlDLFdBQU9DLGFBQWE7UUFDeEJSLElBQUFBLE9BQUFBLFNBQW9CTyxJQUFDTDtvQkFDZk8sT0FBT0QsQ0FBQUEsQ0FBQUE7WUFFWEMsSUFBQUEsT0FBU0QsU0FBR0UsYUFBQTtZQUNaRCxLQUFLRSxJQUFHLEdBQUc7WUFDWEYsS0FBS0csR0FBQUEsR0FBSTtZQUVUTCxLQUFLTSxJQUFBQSxHQUFBQTtZQUNQTixLQUFBTSxXQUFBLENBQUFKO1FBQ0Y7SUFDRjtBQUVBO01BQ0VLLGFBRUksQ0FBQUM7SUFVSixNQUFNQyxFQUFBQSxHQUFBQSxFQUFBQSxFQUFBQSxFQUFXQyxTQUFNQyxLQUFBQSxDQUFBQSxFQUFBQSxVQUFBQSxJQUFBQSxF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V0FBQUEsVUFBQUEsU0FBQUE7b0JBQ2hEQTtvQkFBRXJEO29CQUFjcUQsSUFBQUE7b0JBQU1BO2dCQUU1Qjt1QkFFV0EsV0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsWUFBQUEsR0FBQUEsRUFBQUEsVUFBQUE7b0JBQ1B2QixPQUFBQTs2Q0FDVztnQ0FDUGxCLDRDQUFBQSxLQUFBQSxTQUFBQSxDQUFBQTs0QkFDQUE7O2dDQUFnQkQsR0FBQUEsU0FBQUE7Z0NBQUdBOzRCQUNwQjt5QkFDSDs7Z0JBR047WUFDRjtlQUNFLElBQUlDLGFBQUs7Z0JBQ1BBLEtBQUE7Z0JBQ0FmLGFBQUFBOzBCQUdZQyxPQUFBLENBQUF1RSxPQUFBLENBQUF6RCxLQUFBcUMsVUFBQXFCLFNBQUE7b0JBQVVBLElBQUFBO29CQUFnQ2pCLFdBQUFBLFVBQUFBLFNBQUFBO29CQUNoREE7b0JBQUVyRDtvQkFBY3FELElBQUFBO29CQUFNQTtnQkFFOUI7WUFDRjtRQUNGO0lBRUE7SUFDRjtBQUVBa0I7S0FyS0k1RDtPQXFLNENzQixjQUFPLENBQUF1QyxRQUFBO0lBQUt2QyxPQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L3NjcmlwdC50c3g/NGEzNiJdLCJuYW1lcyI6WyJleHBvcnRzIiwiaGFuZGxlQ2xpZW50U2NyaXB0TG9hZCIsImluaXRTY3JpcHRMb2FkZXIiLCJfIiwicmVxdWlyZSIsIlNjcmlwdENhY2hlIiwiTWFwIiwiTG9hZENhY2hlIiwiU2V0IiwiaWdub3JlUHJvcHMiLCJpbnNlcnRTdHlsZXNoZWV0cyIsInN0eWxlc2hlZXRzIiwiZm9yRWFjaCIsInN0eWxlc2hlZXQiLCJSZWFjdERPTSIsImRlZmF1bHQiLCJwcmVpbml0IiwiYXMiLCJoZWFkIiwiZG9jdW1lbnQiLCJsaW5rIiwiY3JlYXRlRWxlbWVudCIsInJlbCIsImhyZWYiLCJhcHBlbmRDaGlsZCIsImxvYWRTY3JpcHQiLCJwcm9wcyIsImNhY2hlS2V5IiwiaWQiLCJzcmMiLCJoYXMiLCJhZGQiLCJvbkVycm9yIiwiZ2V0IiwidGhlbiIsIm9uTG9hZCIsImFmdGVyTG9hZCIsIm9uUmVhZHkiLCJsb2FkUHJvbWlzZSIsInJlc29sdmUiLCJlbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJQcm9taXNlIiwicmVqZWN0IiwiY2FsbCIsImUiLCJjYXRjaCIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwidGV4dENvbnRlbnQiLCJzZXQiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsImluY2x1ZGVzIiwiayIsInNldEF0dHJpYnV0ZSIsImF0dHIiLCJzdHJhdGVneSIsImJvZHkiLCJ3aW5kb3ciLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiX3JlcXVlc3RpZGxlY2FsbGJhY2siLCJyZWFkeVN0YXRlIiwiYWRkQmVmb3JlSW50ZXJhY3RpdmVUb0NhY2hlIiwicXVlcnlTZWxlY3RvckFsbCIsInNjcmlwdHMiLCJzY3JpcHRMb2FkZXJJdGVtcyIsInJlc3RQcm9wcyIsImdldElzU3NyIiwidXBkYXRlU2NyaXB0cyIsImFwcERpciIsIm5vbmNlIiwiX3JlYWN0IiwidXNlQ29udGV4dCIsIl9oZWFkbWFuYWdlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwiaGFzT25SZWFkeUVmZmVjdENhbGxlZCIsImN1cnJlbnQiLCJoYXNMb2FkU2NyaXB0RWZmZWN0Q2FsbGVkIiwibG9hZExhenlTY3JpcHQiLCJjb25jYXQiLCJzdHlsZVNyYyIsIl9faHRtbCIsIkpTT04iLCJzdHJpbmdpZnkiLCJwcmVsb2FkIiwiaW50ZWdyaXR5IiwiT2JqZWN0IiwiU2NyaXB0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/script.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/layout.tsx":
/*!****************************!*\
  !*** ./src/app/layout.tsx ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ RootLayout; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _globals_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals.css */ \"(app-pages-browser)/./src/app/globals.css\");\n/* harmony import */ var _tonconnect_ui_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tonconnect/ui-react */ \"(app-pages-browser)/./node_modules/@tonconnect/ui-react/lib/index.mjs\");\n/* harmony import */ var next_script__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/script */ \"(app-pages-browser)/./node_modules/next/dist/api/script.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nfunction RootLayout(param) {\n    let { children } = param;\n    _s();\n    (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(()=>{\n        var // Initialize Telegram WebApp\n        _window_Telegram_WebApp, _window_Telegram, _window_Telegram_WebApp1, _window_Telegram1;\n        (_window_Telegram = window.Telegram) === null || _window_Telegram === void 0 ? void 0 : (_window_Telegram_WebApp = _window_Telegram.WebApp) === null || _window_Telegram_WebApp === void 0 ? void 0 : _window_Telegram_WebApp.ready();\n        (_window_Telegram1 = window.Telegram) === null || _window_Telegram1 === void 0 ? void 0 : (_window_Telegram_WebApp1 = _window_Telegram1.WebApp) === null || _window_Telegram_WebApp1 === void 0 ? void 0 : _window_Telegram_WebApp1.expand();\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"html\", {\n        lang: \"en\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"head\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"viewport\",\n                        content: \"width=device-width, initial-scale=1, maximum-scale=1\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\123\\\\Desktop\\\\tma-project\\\\frontend\\\\src\\\\app\\\\layout.tsx\",\n                        lineNumber: 18,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                        children: \"Static Shop\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\123\\\\Desktop\\\\tma-project\\\\frontend\\\\src\\\\app\\\\layout.tsx\",\n                        lineNumber: 19,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\123\\\\Desktop\\\\tma-project\\\\frontend\\\\src\\\\app\\\\layout.tsx\",\n                lineNumber: 17,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"body\", {\n                className: \"bg-black text-white min-h-dvh\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_script__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                        src: \"https://telegram.org/js/telegram-web-app.js\",\n                        strategy: \"beforeInteractive\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\123\\\\Desktop\\\\tma-project\\\\frontend\\\\src\\\\app\\\\layout.tsx\",\n                        lineNumber: 22,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_tonconnect_ui_react__WEBPACK_IMPORTED_MODULE_2__.TonConnectUIProvider, {\n                        manifestUrl: \"\".concat(\"http://localhost:3000\", \"/tonconnect-manifest.json\"),\n                        children: children\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\123\\\\Desktop\\\\tma-project\\\\frontend\\\\src\\\\app\\\\layout.tsx\",\n                        lineNumber: 26,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\123\\\\Desktop\\\\tma-project\\\\frontend\\\\src\\\\app\\\\layout.tsx\",\n                lineNumber: 21,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\123\\\\Desktop\\\\tma-project\\\\frontend\\\\src\\\\app\\\\layout.tsx\",\n        lineNumber: 16,\n        columnNumber: 5\n    }, this);\n}\n_s(RootLayout, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = RootLayout;\nvar _c;\n$RefreshReg$(_c, \"RootLayout\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvbGF5b3V0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFFdUI7QUFDcUM7QUFDM0I7QUFDQztBQUVuQixTQUFTRyxXQUFXLEtBQTJDO1FBQTNDLEVBQUVDLFFBQVEsRUFBaUMsR0FBM0M7O0lBQ2pDRixnREFBU0EsQ0FBQztZQUNSLDZCQUE2QjtRQUM3QkcseUJBQUFBLGtCQUNBQSwwQkFBQUE7U0FEQUEsbUJBQUFBLE9BQU9DLFFBQVEsY0FBZkQsd0NBQUFBLDBCQUFBQSxpQkFBaUJFLE1BQU0sY0FBdkJGLDhDQUFBQSx3QkFBeUJHLEtBQUs7U0FDOUJILG9CQUFBQSxPQUFPQyxRQUFRLGNBQWZELHlDQUFBQSwyQkFBQUEsa0JBQWlCRSxNQUFNLGNBQXZCRiwrQ0FBQUEseUJBQXlCSSxNQUFNO0lBQ2pDLEdBQUcsRUFBRTtJQUVMLHFCQUNFLDhEQUFDQztRQUFLQyxNQUFLOzswQkFDVCw4REFBQ0M7O2tDQUNDLDhEQUFDQzt3QkFBS0MsTUFBSzt3QkFBV0MsU0FBUTs7Ozs7O2tDQUM5Qiw4REFBQ0M7a0NBQU07Ozs7Ozs7Ozs7OzswQkFFVCw4REFBQ0M7Z0JBQUtDLFdBQVU7O2tDQUNkLDhEQUFDakIsbURBQU1BO3dCQUNMa0IsS0FBSTt3QkFDSkMsVUFBUzs7Ozs7O2tDQUVYLDhEQUFDcEIsc0VBQW9CQTt3QkFDbkJxQixhQUFhLEdBQW1DLE9BQWhDQyx1QkFBK0IsRUFBQztrQ0FFL0NsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS1g7R0ExQndCRDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL2xheW91dC50c3g/NTdhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCAnLi9nbG9iYWxzLmNzcyc7XG5pbXBvcnQgeyBUb25Db25uZWN0VUlQcm92aWRlciB9IGZyb20gJ0B0b25jb25uZWN0L3VpLXJlYWN0JztcbmltcG9ydCBTY3JpcHQgZnJvbSAnbmV4dC9zY3JpcHQnO1xuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSb290TGF5b3V0KHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0pIHtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBJbml0aWFsaXplIFRlbGVncmFtIFdlYkFwcFxuICAgIHdpbmRvdy5UZWxlZ3JhbT8uV2ViQXBwPy5yZWFkeSgpO1xuICAgIHdpbmRvdy5UZWxlZ3JhbT8uV2ViQXBwPy5leHBhbmQoKTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiAoXG4gICAgPGh0bWwgbGFuZz1cImVuXCI+XG4gICAgICA8aGVhZD5cbiAgICAgICAgPG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xLCBtYXhpbXVtLXNjYWxlPTFcIiAvPlxuICAgICAgICA8dGl0bGU+U3RhdGljIFNob3A8L3RpdGxlPlxuICAgICAgPC9oZWFkPlxuICAgICAgPGJvZHkgY2xhc3NOYW1lPVwiYmctYmxhY2sgdGV4dC13aGl0ZSBtaW4taC1kdmhcIj5cbiAgICAgICAgPFNjcmlwdFxuICAgICAgICAgIHNyYz1cImh0dHBzOi8vdGVsZWdyYW0ub3JnL2pzL3RlbGVncmFtLXdlYi1hcHAuanNcIlxuICAgICAgICAgIHN0cmF0ZWd5PVwiYmVmb3JlSW50ZXJhY3RpdmVcIlxuICAgICAgICAvPlxuICAgICAgICA8VG9uQ29ubmVjdFVJUHJvdmlkZXJcbiAgICAgICAgICBtYW5pZmVzdFVybD17YCR7cHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBQX1VSTH0vdG9uY29ubmVjdC1tYW5pZmVzdC5qc29uYH1cbiAgICAgICAgPlxuICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9Ub25Db25uZWN0VUlQcm92aWRlcj5cbiAgICAgIDwvYm9keT5cbiAgICA8L2h0bWw+XG4gICk7XG59XG4iXSwibmFtZXMiOlsiVG9uQ29ubmVjdFVJUHJvdmlkZXIiLCJTY3JpcHQiLCJ1c2VFZmZlY3QiLCJSb290TGF5b3V0IiwiY2hpbGRyZW4iLCJ3aW5kb3ciLCJUZWxlZ3JhbSIsIldlYkFwcCIsInJlYWR5IiwiZXhwYW5kIiwiaHRtbCIsImxhbmciLCJoZWFkIiwibWV0YSIsIm5hbWUiLCJjb250ZW50IiwidGl0bGUiLCJib2R5IiwiY2xhc3NOYW1lIiwic3JjIiwic3RyYXRlZ3kiLCJtYW5pZmVzdFVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUFBfVVJMIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/layout.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz82YjRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/MmIzYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/classnames/index.js":
/*!******************************************!*\
  !*** ./node_modules/classnames/index.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = '';\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (arg) {\n\t\t\t\tclasses = appendClass(classes, parseValue(arg));\n\t\t\t}\n\t\t}\n\n\t\treturn classes;\n\t}\n\n\tfunction parseValue (arg) {\n\t\tif (typeof arg === 'string' || typeof arg === 'number') {\n\t\t\treturn arg;\n\t\t}\n\n\t\tif (typeof arg !== 'object') {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (Array.isArray(arg)) {\n\t\t\treturn classNames.apply(null, arg);\n\t\t}\n\n\t\tif (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {\n\t\t\treturn arg.toString();\n\t\t}\n\n\t\tvar classes = '';\n\n\t\tfor (var key in arg) {\n\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\tclasses = appendClass(classes, key);\n\t\t\t}\n\t\t}\n\n\t\treturn classes;\n\t}\n\n\tfunction appendClass (value, newClass) {\n\t\tif (!newClass) {\n\t\t\treturn value;\n\t\t}\n\t\n\t\tif (value) {\n\t\t\treturn value + ' ' + newClass;\n\t\t}\n\t\n\t\treturn value + newClass;\n\t}\n\n\tif ( true && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (true) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn classNames;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQjs7QUFFaEI7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLEtBQTZCO0FBQ2xDO0FBQ0E7QUFDQSxHQUFHLFNBQVMsSUFBNEU7QUFDeEY7QUFDQSxFQUFFLGlDQUFxQixFQUFFLG1DQUFFO0FBQzNCO0FBQ0EsR0FBRztBQUFBLGtHQUFDO0FBQ0osR0FBRyxLQUFLLEVBRU47QUFDRixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzPzIxZjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG5cdENvcHlyaWdodCAoYykgMjAxOCBKZWQgV2F0c29uLlxuXHRMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuXHRodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMgKCkge1xuXHRcdHZhciBjbGFzc2VzID0gJyc7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmIChhcmcpIHtcblx0XHRcdFx0Y2xhc3NlcyA9IGFwcGVuZENsYXNzKGNsYXNzZXMsIHBhcnNlVmFsdWUoYXJnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXM7XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZVZhbHVlIChhcmcpIHtcblx0XHRpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcblx0XHRcdHJldHVybiBhcmc7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiBhcmcgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKTtcblx0XHR9XG5cblx0XHRpZiAoYXJnLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nICYmICFhcmcudG9TdHJpbmcudG9TdHJpbmcoKS5pbmNsdWRlcygnW25hdGl2ZSBjb2RlXScpKSB7XG5cdFx0XHRyZXR1cm4gYXJnLnRvU3RyaW5nKCk7XG5cdFx0fVxuXG5cdFx0dmFyIGNsYXNzZXMgPSAnJztcblxuXHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0Y2xhc3NlcyA9IGFwcGVuZENsYXNzKGNsYXNzZXMsIGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXM7XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBlbmRDbGFzcyAodmFsdWUsIG5ld0NsYXNzKSB7XG5cdFx0aWYgKCFuZXdDbGFzcykge1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0XG5cdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgKyAnICcgKyBuZXdDbGFzcztcblx0XHR9XG5cdFxuXHRcdHJldHVybiB2YWx1ZSArIG5ld0NsYXNzO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Y2xhc3NOYW1lcy5kZWZhdWx0ID0gY2xhc3NOYW1lcztcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/classnames/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tonconnect/protocol/lib/esm/index.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@tonconnect/protocol/lib/esm/index.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Base64: function() { return /* binding */ Base64; },\n/* harmony export */   CHAIN: function() { return /* binding */ CHAIN; },\n/* harmony export */   CONNECT_EVENT_ERROR_CODES: function() { return /* binding */ CONNECT_EVENT_ERROR_CODES; },\n/* harmony export */   CONNECT_ITEM_ERROR_CODES: function() { return /* binding */ CONNECT_ITEM_ERROR_CODES; },\n/* harmony export */   DISCONNECT_ERROR_CODES: function() { return /* binding */ DISCONNECT_ERROR_CODES; },\n/* harmony export */   SEND_TRANSACTION_ERROR_CODES: function() { return /* binding */ SEND_TRANSACTION_ERROR_CODES; },\n/* harmony export */   SIGN_DATA_ERROR_CODES: function() { return /* binding */ SIGN_DATA_ERROR_CODES; },\n/* harmony export */   SessionCrypto: function() { return /* binding */ SessionCrypto; },\n/* harmony export */   concatUint8Arrays: function() { return /* binding */ concatUint8Arrays; },\n/* harmony export */   hexToByteArray: function() { return /* binding */ hexToByteArray; },\n/* harmony export */   isNode: function() { return /* binding */ isNode; },\n/* harmony export */   splitToUint8Arrays: function() { return /* binding */ splitToUint8Arrays; },\n/* harmony export */   toHexString: function() { return /* binding */ toHexString; }\n/* harmony export */ });\n/* harmony import */ var tweetnacl_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tweetnacl-util */ \"(app-pages-browser)/./node_modules/tweetnacl-util/nacl-util.js\");\n/* harmony import */ var tweetnacl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tweetnacl */ \"(app-pages-browser)/./node_modules/tweetnacl/nacl-fast.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\n\nvar CONNECT_EVENT_ERROR_CODES;\n(function (CONNECT_EVENT_ERROR_CODES) {\n    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"UNKNOWN_ERROR\"] = 0] = \"UNKNOWN_ERROR\";\n    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"BAD_REQUEST_ERROR\"] = 1] = \"BAD_REQUEST_ERROR\";\n    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"MANIFEST_NOT_FOUND_ERROR\"] = 2] = \"MANIFEST_NOT_FOUND_ERROR\";\n    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"MANIFEST_CONTENT_ERROR\"] = 3] = \"MANIFEST_CONTENT_ERROR\";\n    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"UNKNOWN_APP_ERROR\"] = 100] = \"UNKNOWN_APP_ERROR\";\n    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"USER_REJECTS_ERROR\"] = 300] = \"USER_REJECTS_ERROR\";\n    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"METHOD_NOT_SUPPORTED\"] = 400] = \"METHOD_NOT_SUPPORTED\";\n})(CONNECT_EVENT_ERROR_CODES || (CONNECT_EVENT_ERROR_CODES = {}));\nvar CONNECT_ITEM_ERROR_CODES;\n(function (CONNECT_ITEM_ERROR_CODES) {\n    CONNECT_ITEM_ERROR_CODES[CONNECT_ITEM_ERROR_CODES[\"UNKNOWN_ERROR\"] = 0] = \"UNKNOWN_ERROR\";\n    CONNECT_ITEM_ERROR_CODES[CONNECT_ITEM_ERROR_CODES[\"METHOD_NOT_SUPPORTED\"] = 400] = \"METHOD_NOT_SUPPORTED\";\n})(CONNECT_ITEM_ERROR_CODES || (CONNECT_ITEM_ERROR_CODES = {}));\n\nvar SEND_TRANSACTION_ERROR_CODES;\n(function (SEND_TRANSACTION_ERROR_CODES) {\n    SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES[\"UNKNOWN_ERROR\"] = 0] = \"UNKNOWN_ERROR\";\n    SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES[\"BAD_REQUEST_ERROR\"] = 1] = \"BAD_REQUEST_ERROR\";\n    SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES[\"UNKNOWN_APP_ERROR\"] = 100] = \"UNKNOWN_APP_ERROR\";\n    SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES[\"USER_REJECTS_ERROR\"] = 300] = \"USER_REJECTS_ERROR\";\n    SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES[\"METHOD_NOT_SUPPORTED\"] = 400] = \"METHOD_NOT_SUPPORTED\";\n})(SEND_TRANSACTION_ERROR_CODES || (SEND_TRANSACTION_ERROR_CODES = {}));\n\nvar SIGN_DATA_ERROR_CODES;\n(function (SIGN_DATA_ERROR_CODES) {\n    SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES[\"UNKNOWN_ERROR\"] = 0] = \"UNKNOWN_ERROR\";\n    SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES[\"BAD_REQUEST_ERROR\"] = 1] = \"BAD_REQUEST_ERROR\";\n    SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES[\"UNKNOWN_APP_ERROR\"] = 100] = \"UNKNOWN_APP_ERROR\";\n    SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES[\"USER_REJECTS_ERROR\"] = 300] = \"USER_REJECTS_ERROR\";\n    SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES[\"METHOD_NOT_SUPPORTED\"] = 400] = \"METHOD_NOT_SUPPORTED\";\n})(SIGN_DATA_ERROR_CODES || (SIGN_DATA_ERROR_CODES = {}));\n\nvar DISCONNECT_ERROR_CODES;\n(function (DISCONNECT_ERROR_CODES) {\n    DISCONNECT_ERROR_CODES[DISCONNECT_ERROR_CODES[\"UNKNOWN_ERROR\"] = 0] = \"UNKNOWN_ERROR\";\n    DISCONNECT_ERROR_CODES[DISCONNECT_ERROR_CODES[\"BAD_REQUEST_ERROR\"] = 1] = \"BAD_REQUEST_ERROR\";\n    DISCONNECT_ERROR_CODES[DISCONNECT_ERROR_CODES[\"UNKNOWN_APP_ERROR\"] = 100] = \"UNKNOWN_APP_ERROR\";\n    DISCONNECT_ERROR_CODES[DISCONNECT_ERROR_CODES[\"METHOD_NOT_SUPPORTED\"] = 400] = \"METHOD_NOT_SUPPORTED\";\n})(DISCONNECT_ERROR_CODES || (DISCONNECT_ERROR_CODES = {}));\n\nvar CHAIN;\n(function (CHAIN) {\n    CHAIN[\"MAINNET\"] = \"-239\";\n    CHAIN[\"TESTNET\"] = \"-3\";\n})(CHAIN || (CHAIN = {}));\n\nfunction encodeUint8Array(value, urlSafe) {\n    const encoded = tweetnacl_util__WEBPACK_IMPORTED_MODULE_0__.encodeBase64(value);\n    if (!urlSafe) {\n        return encoded;\n    }\n    return encodeURIComponent(encoded);\n}\nfunction decodeToUint8Array(value, urlSafe) {\n    if (urlSafe) {\n        value = decodeURIComponent(value);\n    }\n    return tweetnacl_util__WEBPACK_IMPORTED_MODULE_0__.decodeBase64(value);\n}\nfunction encode(value, urlSafe = false) {\n    let uint8Array;\n    if (value instanceof Uint8Array) {\n        uint8Array = value;\n    }\n    else {\n        if (typeof value !== 'string') {\n            value = JSON.stringify(value);\n        }\n        uint8Array = tweetnacl_util__WEBPACK_IMPORTED_MODULE_0__.decodeUTF8(value);\n    }\n    return encodeUint8Array(uint8Array, urlSafe);\n}\nfunction decode(value, urlSafe = false) {\n    const decodedUint8Array = decodeToUint8Array(value, urlSafe);\n    return {\n        toString() {\n            return tweetnacl_util__WEBPACK_IMPORTED_MODULE_0__.encodeUTF8(decodedUint8Array);\n        },\n        toObject() {\n            try {\n                return JSON.parse(tweetnacl_util__WEBPACK_IMPORTED_MODULE_0__.encodeUTF8(decodedUint8Array));\n            }\n            catch (e) {\n                return null;\n            }\n        },\n        toUint8Array() {\n            return decodedUint8Array;\n        }\n    };\n}\nconst Base64 = {\n    encode,\n    decode\n};\n\nfunction concatUint8Arrays(buffer1, buffer2) {\n    const mergedArray = new Uint8Array(buffer1.length + buffer2.length);\n    mergedArray.set(buffer1);\n    mergedArray.set(buffer2, buffer1.length);\n    return mergedArray;\n}\nfunction splitToUint8Arrays(array, index) {\n    if (index >= array.length) {\n        throw new Error('Index is out of buffer');\n    }\n    const subArray1 = array.slice(0, index);\n    const subArray2 = array.slice(index);\n    return [subArray1, subArray2];\n}\nfunction toHexString(byteArray) {\n    let hexString = '';\n    byteArray.forEach(byte => {\n        hexString += ('0' + (byte & 0xff).toString(16)).slice(-2);\n    });\n    return hexString;\n}\nfunction hexToByteArray(hexString) {\n    if (hexString.length % 2 !== 0) {\n        throw new Error(`Cannot convert ${hexString} to bytesArray`);\n    }\n    const result = new Uint8Array(hexString.length / 2);\n    for (let i = 0; i < hexString.length; i += 2) {\n        result[i / 2] = parseInt(hexString.slice(i, i + 2), 16);\n    }\n    return result;\n}\n\nfunction isNode() {\n    return (typeof process !== 'undefined' && process.versions != null && process.versions.node != null);\n}\n\nclass SessionCrypto {\n    constructor(keyPair) {\n        this.nonceLength = 24;\n        this.keyPair = keyPair ? this.createKeypairFromString(keyPair) : this.createKeypair();\n        this.sessionId = toHexString(this.keyPair.publicKey);\n    }\n    createKeypair() {\n        return tweetnacl__WEBPACK_IMPORTED_MODULE_1__.box.keyPair();\n    }\n    createKeypairFromString(keyPair) {\n        return {\n            publicKey: hexToByteArray(keyPair.publicKey),\n            secretKey: hexToByteArray(keyPair.secretKey)\n        };\n    }\n    createNonce() {\n        return tweetnacl__WEBPACK_IMPORTED_MODULE_1__.randomBytes(this.nonceLength);\n    }\n    encrypt(message, receiverPublicKey) {\n        const encodedMessage = new TextEncoder().encode(message);\n        const nonce = this.createNonce();\n        const encrypted = tweetnacl__WEBPACK_IMPORTED_MODULE_1__.box(encodedMessage, nonce, receiverPublicKey, this.keyPair.secretKey);\n        return concatUint8Arrays(nonce, encrypted);\n    }\n    decrypt(message, senderPublicKey) {\n        const [nonce, internalMessage] = splitToUint8Arrays(message, this.nonceLength);\n        const decrypted = tweetnacl__WEBPACK_IMPORTED_MODULE_1__.box.open(internalMessage, nonce, senderPublicKey, this.keyPair.secretKey);\n        if (!decrypted) {\n            throw new Error(`Decryption error: \\n message: ${message.toString()} \\n sender pubkey: ${senderPublicKey.toString()} \\n keypair pubkey: ${this.keyPair.publicKey.toString()} \\n keypair secretkey: ${this.keyPair.secretKey.toString()}`);\n        }\n        return new TextDecoder().decode(decrypted);\n    }\n    stringifyKeypair() {\n        return {\n            publicKey: toHexString(this.keyPair.publicKey),\n            secretKey: toHexString(this.keyPair.secretKey)\n        };\n    }\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdG9uY29ubmVjdC9wcm90b2NvbC9saWIvZXNtL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ0g7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOERBQThEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0REFBNEQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvRUFBb0U7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0Q7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0RBQXdEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCOztBQUV2QjtBQUNBLG9CQUFvQix3REFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3REFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0RBQWU7QUFDbEMsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQ0FBa0Msc0RBQWU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLE9BQU8sb0JBQW9CLE9BQU8scUJBQXFCLE9BQU87QUFDakY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBDQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtEQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQ0FBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQ0FBVTtBQUNwQztBQUNBLDZEQUE2RCxvQkFBb0Isb0JBQW9CLDRCQUE0QixxQkFBcUIsbUNBQW1DLHdCQUF3QixrQ0FBa0M7QUFDblA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXNQO0FBQ3RQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdG9uY29ubmVjdC9wcm90b2NvbC9saWIvZXNtL2luZGV4Lm1qcz9jZWIzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBuYWNsIGZyb20gJ3R3ZWV0bmFjbC11dGlsJztcbmltcG9ydCBuYWNsJDEgZnJvbSAndHdlZXRuYWNsJztcblxudmFyIENPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVM7XG4oZnVuY3Rpb24gKENPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVMpIHtcbiAgICBDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTW0NPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVNbXCJVTktOT1dOX0VSUk9SXCJdID0gMF0gPSBcIlVOS05PV05fRVJST1JcIjtcbiAgICBDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTW0NPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVNbXCJCQURfUkVRVUVTVF9FUlJPUlwiXSA9IDFdID0gXCJCQURfUkVRVUVTVF9FUlJPUlwiO1xuICAgIENPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVNbQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFU1tcIk1BTklGRVNUX05PVF9GT1VORF9FUlJPUlwiXSA9IDJdID0gXCJNQU5JRkVTVF9OT1RfRk9VTkRfRVJST1JcIjtcbiAgICBDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTW0NPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVNbXCJNQU5JRkVTVF9DT05URU5UX0VSUk9SXCJdID0gM10gPSBcIk1BTklGRVNUX0NPTlRFTlRfRVJST1JcIjtcbiAgICBDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTW0NPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVNbXCJVTktOT1dOX0FQUF9FUlJPUlwiXSA9IDEwMF0gPSBcIlVOS05PV05fQVBQX0VSUk9SXCI7XG4gICAgQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFU1tDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTW1wiVVNFUl9SRUpFQ1RTX0VSUk9SXCJdID0gMzAwXSA9IFwiVVNFUl9SRUpFQ1RTX0VSUk9SXCI7XG4gICAgQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFU1tDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTW1wiTUVUSE9EX05PVF9TVVBQT1JURURcIl0gPSA0MDBdID0gXCJNRVRIT0RfTk9UX1NVUFBPUlRFRFwiO1xufSkoQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFUyB8fCAoQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFUyA9IHt9KSk7XG52YXIgQ09OTkVDVF9JVEVNX0VSUk9SX0NPREVTO1xuKGZ1bmN0aW9uIChDT05ORUNUX0lURU1fRVJST1JfQ09ERVMpIHtcbiAgICBDT05ORUNUX0lURU1fRVJST1JfQ09ERVNbQ09OTkVDVF9JVEVNX0VSUk9SX0NPREVTW1wiVU5LTk9XTl9FUlJPUlwiXSA9IDBdID0gXCJVTktOT1dOX0VSUk9SXCI7XG4gICAgQ09OTkVDVF9JVEVNX0VSUk9SX0NPREVTW0NPTk5FQ1RfSVRFTV9FUlJPUl9DT0RFU1tcIk1FVEhPRF9OT1RfU1VQUE9SVEVEXCJdID0gNDAwXSA9IFwiTUVUSE9EX05PVF9TVVBQT1JURURcIjtcbn0pKENPTk5FQ1RfSVRFTV9FUlJPUl9DT0RFUyB8fCAoQ09OTkVDVF9JVEVNX0VSUk9SX0NPREVTID0ge30pKTtcblxudmFyIFNFTkRfVFJBTlNBQ1RJT05fRVJST1JfQ09ERVM7XG4oZnVuY3Rpb24gKFNFTkRfVFJBTlNBQ1RJT05fRVJST1JfQ09ERVMpIHtcbiAgICBTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTW1NFTkRfVFJBTlNBQ1RJT05fRVJST1JfQ09ERVNbXCJVTktOT1dOX0VSUk9SXCJdID0gMF0gPSBcIlVOS05PV05fRVJST1JcIjtcbiAgICBTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTW1NFTkRfVFJBTlNBQ1RJT05fRVJST1JfQ09ERVNbXCJCQURfUkVRVUVTVF9FUlJPUlwiXSA9IDFdID0gXCJCQURfUkVRVUVTVF9FUlJPUlwiO1xuICAgIFNFTkRfVFJBTlNBQ1RJT05fRVJST1JfQ09ERVNbU0VORF9UUkFOU0FDVElPTl9FUlJPUl9DT0RFU1tcIlVOS05PV05fQVBQX0VSUk9SXCJdID0gMTAwXSA9IFwiVU5LTk9XTl9BUFBfRVJST1JcIjtcbiAgICBTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTW1NFTkRfVFJBTlNBQ1RJT05fRVJST1JfQ09ERVNbXCJVU0VSX1JFSkVDVFNfRVJST1JcIl0gPSAzMDBdID0gXCJVU0VSX1JFSkVDVFNfRVJST1JcIjtcbiAgICBTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTW1NFTkRfVFJBTlNBQ1RJT05fRVJST1JfQ09ERVNbXCJNRVRIT0RfTk9UX1NVUFBPUlRFRFwiXSA9IDQwMF0gPSBcIk1FVEhPRF9OT1RfU1VQUE9SVEVEXCI7XG59KShTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTIHx8IChTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTID0ge30pKTtcblxudmFyIFNJR05fREFUQV9FUlJPUl9DT0RFUztcbihmdW5jdGlvbiAoU0lHTl9EQVRBX0VSUk9SX0NPREVTKSB7XG4gICAgU0lHTl9EQVRBX0VSUk9SX0NPREVTW1NJR05fREFUQV9FUlJPUl9DT0RFU1tcIlVOS05PV05fRVJST1JcIl0gPSAwXSA9IFwiVU5LTk9XTl9FUlJPUlwiO1xuICAgIFNJR05fREFUQV9FUlJPUl9DT0RFU1tTSUdOX0RBVEFfRVJST1JfQ09ERVNbXCJCQURfUkVRVUVTVF9FUlJPUlwiXSA9IDFdID0gXCJCQURfUkVRVUVTVF9FUlJPUlwiO1xuICAgIFNJR05fREFUQV9FUlJPUl9DT0RFU1tTSUdOX0RBVEFfRVJST1JfQ09ERVNbXCJVTktOT1dOX0FQUF9FUlJPUlwiXSA9IDEwMF0gPSBcIlVOS05PV05fQVBQX0VSUk9SXCI7XG4gICAgU0lHTl9EQVRBX0VSUk9SX0NPREVTW1NJR05fREFUQV9FUlJPUl9DT0RFU1tcIlVTRVJfUkVKRUNUU19FUlJPUlwiXSA9IDMwMF0gPSBcIlVTRVJfUkVKRUNUU19FUlJPUlwiO1xuICAgIFNJR05fREFUQV9FUlJPUl9DT0RFU1tTSUdOX0RBVEFfRVJST1JfQ09ERVNbXCJNRVRIT0RfTk9UX1NVUFBPUlRFRFwiXSA9IDQwMF0gPSBcIk1FVEhPRF9OT1RfU1VQUE9SVEVEXCI7XG59KShTSUdOX0RBVEFfRVJST1JfQ09ERVMgfHwgKFNJR05fREFUQV9FUlJPUl9DT0RFUyA9IHt9KSk7XG5cbnZhciBESVNDT05ORUNUX0VSUk9SX0NPREVTO1xuKGZ1bmN0aW9uIChESVNDT05ORUNUX0VSUk9SX0NPREVTKSB7XG4gICAgRElTQ09OTkVDVF9FUlJPUl9DT0RFU1tESVNDT05ORUNUX0VSUk9SX0NPREVTW1wiVU5LTk9XTl9FUlJPUlwiXSA9IDBdID0gXCJVTktOT1dOX0VSUk9SXCI7XG4gICAgRElTQ09OTkVDVF9FUlJPUl9DT0RFU1tESVNDT05ORUNUX0VSUk9SX0NPREVTW1wiQkFEX1JFUVVFU1RfRVJST1JcIl0gPSAxXSA9IFwiQkFEX1JFUVVFU1RfRVJST1JcIjtcbiAgICBESVNDT05ORUNUX0VSUk9SX0NPREVTW0RJU0NPTk5FQ1RfRVJST1JfQ09ERVNbXCJVTktOT1dOX0FQUF9FUlJPUlwiXSA9IDEwMF0gPSBcIlVOS05PV05fQVBQX0VSUk9SXCI7XG4gICAgRElTQ09OTkVDVF9FUlJPUl9DT0RFU1tESVNDT05ORUNUX0VSUk9SX0NPREVTW1wiTUVUSE9EX05PVF9TVVBQT1JURURcIl0gPSA0MDBdID0gXCJNRVRIT0RfTk9UX1NVUFBPUlRFRFwiO1xufSkoRElTQ09OTkVDVF9FUlJPUl9DT0RFUyB8fCAoRElTQ09OTkVDVF9FUlJPUl9DT0RFUyA9IHt9KSk7XG5cbnZhciBDSEFJTjtcbihmdW5jdGlvbiAoQ0hBSU4pIHtcbiAgICBDSEFJTltcIk1BSU5ORVRcIl0gPSBcIi0yMzlcIjtcbiAgICBDSEFJTltcIlRFU1RORVRcIl0gPSBcIi0zXCI7XG59KShDSEFJTiB8fCAoQ0hBSU4gPSB7fSkpO1xuXG5mdW5jdGlvbiBlbmNvZGVVaW50OEFycmF5KHZhbHVlLCB1cmxTYWZlKSB7XG4gICAgY29uc3QgZW5jb2RlZCA9IG5hY2wuZW5jb2RlQmFzZTY0KHZhbHVlKTtcbiAgICBpZiAoIXVybFNhZmUpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZWQ7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoZW5jb2RlZCk7XG59XG5mdW5jdGlvbiBkZWNvZGVUb1VpbnQ4QXJyYXkodmFsdWUsIHVybFNhZmUpIHtcbiAgICBpZiAodXJsU2FmZSkge1xuICAgICAgICB2YWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBuYWNsLmRlY29kZUJhc2U2NCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBlbmNvZGUodmFsdWUsIHVybFNhZmUgPSBmYWxzZSkge1xuICAgIGxldCB1aW50OEFycmF5O1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgdWludDhBcnJheSA9IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHVpbnQ4QXJyYXkgPSBuYWNsLmRlY29kZVVURjgodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlVWludDhBcnJheSh1aW50OEFycmF5LCB1cmxTYWZlKTtcbn1cbmZ1bmN0aW9uIGRlY29kZSh2YWx1ZSwgdXJsU2FmZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgZGVjb2RlZFVpbnQ4QXJyYXkgPSBkZWNvZGVUb1VpbnQ4QXJyYXkodmFsdWUsIHVybFNhZmUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5hY2wuZW5jb2RlVVRGOChkZWNvZGVkVWludDhBcnJheSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvT2JqZWN0KCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShuYWNsLmVuY29kZVVURjgoZGVjb2RlZFVpbnQ4QXJyYXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvVWludDhBcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVkVWludDhBcnJheTtcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCBCYXNlNjQgPSB7XG4gICAgZW5jb2RlLFxuICAgIGRlY29kZVxufTtcblxuZnVuY3Rpb24gY29uY2F0VWludDhBcnJheXMoYnVmZmVyMSwgYnVmZmVyMikge1xuICAgIGNvbnN0IG1lcmdlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyMS5sZW5ndGggKyBidWZmZXIyLmxlbmd0aCk7XG4gICAgbWVyZ2VkQXJyYXkuc2V0KGJ1ZmZlcjEpO1xuICAgIG1lcmdlZEFycmF5LnNldChidWZmZXIyLCBidWZmZXIxLmxlbmd0aCk7XG4gICAgcmV0dXJuIG1lcmdlZEFycmF5O1xufVxuZnVuY3Rpb24gc3BsaXRUb1VpbnQ4QXJyYXlzKGFycmF5LCBpbmRleCkge1xuICAgIGlmIChpbmRleCA+PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmRleCBpcyBvdXQgb2YgYnVmZmVyJyk7XG4gICAgfVxuICAgIGNvbnN0IHN1YkFycmF5MSA9IGFycmF5LnNsaWNlKDAsIGluZGV4KTtcbiAgICBjb25zdCBzdWJBcnJheTIgPSBhcnJheS5zbGljZShpbmRleCk7XG4gICAgcmV0dXJuIFtzdWJBcnJheTEsIHN1YkFycmF5Ml07XG59XG5mdW5jdGlvbiB0b0hleFN0cmluZyhieXRlQXJyYXkpIHtcbiAgICBsZXQgaGV4U3RyaW5nID0gJyc7XG4gICAgYnl0ZUFycmF5LmZvckVhY2goYnl0ZSA9PiB7XG4gICAgICAgIGhleFN0cmluZyArPSAoJzAnICsgKGJ5dGUgJiAweGZmKS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGV4U3RyaW5nO1xufVxuZnVuY3Rpb24gaGV4VG9CeXRlQXJyYXkoaGV4U3RyaW5nKSB7XG4gICAgaWYgKGhleFN0cmluZy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbnZlcnQgJHtoZXhTdHJpbmd9IHRvIGJ5dGVzQXJyYXlgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoaGV4U3RyaW5nLmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGV4U3RyaW5nLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHJlc3VsdFtpIC8gMl0gPSBwYXJzZUludChoZXhTdHJpbmcuc2xpY2UoaSwgaSArIDIpLCAxNik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZSgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb25zICE9IG51bGwgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9IG51bGwpO1xufVxuXG5jbGFzcyBTZXNzaW9uQ3J5cHRvIHtcbiAgICBjb25zdHJ1Y3RvcihrZXlQYWlyKSB7XG4gICAgICAgIHRoaXMubm9uY2VMZW5ndGggPSAyNDtcbiAgICAgICAgdGhpcy5rZXlQYWlyID0ga2V5UGFpciA/IHRoaXMuY3JlYXRlS2V5cGFpckZyb21TdHJpbmcoa2V5UGFpcikgOiB0aGlzLmNyZWF0ZUtleXBhaXIoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uSWQgPSB0b0hleFN0cmluZyh0aGlzLmtleVBhaXIucHVibGljS2V5KTtcbiAgICB9XG4gICAgY3JlYXRlS2V5cGFpcigpIHtcbiAgICAgICAgcmV0dXJuIG5hY2wkMS5ib3gua2V5UGFpcigpO1xuICAgIH1cbiAgICBjcmVhdGVLZXlwYWlyRnJvbVN0cmluZyhrZXlQYWlyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwdWJsaWNLZXk6IGhleFRvQnl0ZUFycmF5KGtleVBhaXIucHVibGljS2V5KSxcbiAgICAgICAgICAgIHNlY3JldEtleTogaGV4VG9CeXRlQXJyYXkoa2V5UGFpci5zZWNyZXRLZXkpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNyZWF0ZU5vbmNlKCkge1xuICAgICAgICByZXR1cm4gbmFjbCQxLnJhbmRvbUJ5dGVzKHRoaXMubm9uY2VMZW5ndGgpO1xuICAgIH1cbiAgICBlbmNyeXB0KG1lc3NhZ2UsIHJlY2VpdmVyUHVibGljS2V5KSB7XG4gICAgICAgIGNvbnN0IGVuY29kZWRNZXNzYWdlID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKG1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBub25jZSA9IHRoaXMuY3JlYXRlTm9uY2UoKTtcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkID0gbmFjbCQxLmJveChlbmNvZGVkTWVzc2FnZSwgbm9uY2UsIHJlY2VpdmVyUHVibGljS2V5LCB0aGlzLmtleVBhaXIuc2VjcmV0S2V5KTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdFVpbnQ4QXJyYXlzKG5vbmNlLCBlbmNyeXB0ZWQpO1xuICAgIH1cbiAgICBkZWNyeXB0KG1lc3NhZ2UsIHNlbmRlclB1YmxpY0tleSkge1xuICAgICAgICBjb25zdCBbbm9uY2UsIGludGVybmFsTWVzc2FnZV0gPSBzcGxpdFRvVWludDhBcnJheXMobWVzc2FnZSwgdGhpcy5ub25jZUxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IG5hY2wkMS5ib3gub3BlbihpbnRlcm5hbE1lc3NhZ2UsIG5vbmNlLCBzZW5kZXJQdWJsaWNLZXksIHRoaXMua2V5UGFpci5zZWNyZXRLZXkpO1xuICAgICAgICBpZiAoIWRlY3J5cHRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZWNyeXB0aW9uIGVycm9yOiBcXG4gbWVzc2FnZTogJHttZXNzYWdlLnRvU3RyaW5nKCl9IFxcbiBzZW5kZXIgcHVia2V5OiAke3NlbmRlclB1YmxpY0tleS50b1N0cmluZygpfSBcXG4ga2V5cGFpciBwdWJrZXk6ICR7dGhpcy5rZXlQYWlyLnB1YmxpY0tleS50b1N0cmluZygpfSBcXG4ga2V5cGFpciBzZWNyZXRrZXk6ICR7dGhpcy5rZXlQYWlyLnNlY3JldEtleS50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGVjcnlwdGVkKTtcbiAgICB9XG4gICAgc3RyaW5naWZ5S2V5cGFpcigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHB1YmxpY0tleTogdG9IZXhTdHJpbmcodGhpcy5rZXlQYWlyLnB1YmxpY0tleSksXG4gICAgICAgICAgICBzZWNyZXRLZXk6IHRvSGV4U3RyaW5nKHRoaXMua2V5UGFpci5zZWNyZXRLZXkpXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgeyBCYXNlNjQsIENIQUlOLCBDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTLCBDT05ORUNUX0lURU1fRVJST1JfQ09ERVMsIERJU0NPTk5FQ1RfRVJST1JfQ09ERVMsIFNFTkRfVFJBTlNBQ1RJT05fRVJST1JfQ09ERVMsIFNJR05fREFUQV9FUlJPUl9DT0RFUywgU2Vzc2lvbkNyeXB0bywgY29uY2F0VWludDhBcnJheXMsIGhleFRvQnl0ZUFycmF5LCBpc05vZGUsIHNwbGl0VG9VaW50OEFycmF5cywgdG9IZXhTdHJpbmcgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tonconnect/protocol/lib/esm/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tonconnect/sdk/lib/esm/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@tonconnect/sdk/lib/esm/index.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BadRequestError: function() { return /* binding */ BadRequestError; },\n/* harmony export */   BrowserEventDispatcher: function() { return /* binding */ BrowserEventDispatcher; },\n/* harmony export */   CHAIN: function() { return /* reexport safe */ _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CHAIN; },\n/* harmony export */   CONNECT_EVENT_ERROR_CODES: function() { return /* reexport safe */ _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES; },\n/* harmony export */   CONNECT_ITEM_ERROR_CODES: function() { return /* reexport safe */ _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_ITEM_ERROR_CODES; },\n/* harmony export */   FetchWalletsError: function() { return /* binding */ FetchWalletsError; },\n/* harmony export */   LocalstorageNotFoundError: function() { return /* binding */ LocalstorageNotFoundError; },\n/* harmony export */   ParseHexError: function() { return /* binding */ ParseHexError; },\n/* harmony export */   SEND_TRANSACTION_ERROR_CODES: function() { return /* reexport safe */ _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES; },\n/* harmony export */   SIGN_DATA_ERROR_CODES: function() { return /* reexport safe */ _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SIGN_DATA_ERROR_CODES; },\n/* harmony export */   SessionCrypto: function() { return /* reexport safe */ _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SessionCrypto; },\n/* harmony export */   TonConnect: function() { return /* binding */ TonConnect; },\n/* harmony export */   TonConnectError: function() { return /* binding */ TonConnectError; },\n/* harmony export */   UUIDv7: function() { return /* binding */ UUIDv7; },\n/* harmony export */   UnknownAppError: function() { return /* binding */ UnknownAppError; },\n/* harmony export */   UnknownError: function() { return /* binding */ UnknownError; },\n/* harmony export */   UserRejectsError: function() { return /* binding */ UserRejectsError; },\n/* harmony export */   WalletAlreadyConnectedError: function() { return /* binding */ WalletAlreadyConnectedError; },\n/* harmony export */   WalletMissingRequiredFeaturesError: function() { return /* binding */ WalletMissingRequiredFeaturesError; },\n/* harmony export */   WalletNotConnectedError: function() { return /* binding */ WalletNotConnectedError; },\n/* harmony export */   WalletNotInjectedError: function() { return /* binding */ WalletNotInjectedError; },\n/* harmony export */   WalletNotSupportFeatureError: function() { return /* binding */ WalletNotSupportFeatureError; },\n/* harmony export */   WalletWrongNetworkError: function() { return /* binding */ WalletWrongNetworkError; },\n/* harmony export */   WalletsListManager: function() { return /* binding */ WalletsListManager; },\n/* harmony export */   WrongAddressError: function() { return /* binding */ WrongAddressError; },\n/* harmony export */   checkRequiredWalletFeatures: function() { return /* binding */ checkRequiredWalletFeatures; },\n/* harmony export */   createConnectionCompletedEvent: function() { return /* binding */ createConnectionCompletedEvent; },\n/* harmony export */   createConnectionErrorEvent: function() { return /* binding */ createConnectionErrorEvent; },\n/* harmony export */   createConnectionRestoringCompletedEvent: function() { return /* binding */ createConnectionRestoringCompletedEvent; },\n/* harmony export */   createConnectionRestoringErrorEvent: function() { return /* binding */ createConnectionRestoringErrorEvent; },\n/* harmony export */   createConnectionRestoringStartedEvent: function() { return /* binding */ createConnectionRestoringStartedEvent; },\n/* harmony export */   createConnectionStartedEvent: function() { return /* binding */ createConnectionStartedEvent; },\n/* harmony export */   createDataSentForSignatureEvent: function() { return /* binding */ createDataSentForSignatureEvent; },\n/* harmony export */   createDataSignedEvent: function() { return /* binding */ createDataSignedEvent; },\n/* harmony export */   createDataSigningFailedEvent: function() { return /* binding */ createDataSigningFailedEvent; },\n/* harmony export */   createDisconnectionEvent: function() { return /* binding */ createDisconnectionEvent; },\n/* harmony export */   createRequestVersionEvent: function() { return /* binding */ createRequestVersionEvent; },\n/* harmony export */   createResponseVersionEvent: function() { return /* binding */ createResponseVersionEvent; },\n/* harmony export */   createSelectedWalletEvent: function() { return /* binding */ createSelectedWalletEvent; },\n/* harmony export */   createTransactionSentForSignatureEvent: function() { return /* binding */ createTransactionSentForSignatureEvent; },\n/* harmony export */   createTransactionSignedEvent: function() { return /* binding */ createTransactionSignedEvent; },\n/* harmony export */   createTransactionSigningFailedEvent: function() { return /* binding */ createTransactionSigningFailedEvent; },\n/* harmony export */   createVersionInfo: function() { return /* binding */ createVersionInfo; },\n/* harmony export */   createWalletModalOpenedEvent: function() { return /* binding */ createWalletModalOpenedEvent; },\n/* harmony export */   decodeTelegramUrlParameters: function() { return /* binding */ decodeTelegramUrlParameters; },\n/* harmony export */   \"default\": function() { return /* binding */ TonConnect; },\n/* harmony export */   enableQaMode: function() { return /* binding */ enableQaMode; },\n/* harmony export */   encodeTelegramUrlParameters: function() { return /* binding */ encodeTelegramUrlParameters; },\n/* harmony export */   initializeWalletConnect: function() { return /* binding */ initializeWalletConnect; },\n/* harmony export */   isConnectUrl: function() { return /* binding */ isConnectUrl; },\n/* harmony export */   isQaModeEnabled: function() { return /* binding */ isQaModeEnabled; },\n/* harmony export */   isTelegramUrl: function() { return /* binding */ isTelegramUrl; },\n/* harmony export */   isWalletConnectInitialized: function() { return /* binding */ isWalletConnectInitialized; },\n/* harmony export */   isWalletInfoCurrentlyEmbedded: function() { return /* binding */ isWalletInfoCurrentlyEmbedded; },\n/* harmony export */   isWalletInfoCurrentlyInjected: function() { return /* binding */ isWalletInfoCurrentlyInjected; },\n/* harmony export */   isWalletInfoInjectable: function() { return /* binding */ isWalletInfoInjectable; },\n/* harmony export */   isWalletInfoInjected: function() { return /* binding */ isWalletInfoInjected; },\n/* harmony export */   isWalletInfoRemote: function() { return /* binding */ isWalletInfoRemote; },\n/* harmony export */   toUserFriendlyAddress: function() { return /* binding */ toUserFriendlyAddress; }\n/* harmony export */ });\n/* harmony import */ var _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tonconnect/protocol */ \"(app-pages-browser)/./node_modules/@tonconnect/protocol/lib/esm/index.mjs\");\n/* harmony import */ var _tonconnect_isomorphic_eventsource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tonconnect/isomorphic-eventsource */ \"(app-pages-browser)/./node_modules/@tonconnect/isomorphic-eventsource/browser.js\");\n/* harmony import */ var _tonconnect_isomorphic_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tonconnect/isomorphic-fetch */ \"(app-pages-browser)/./node_modules/@tonconnect/isomorphic-fetch/browser.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\n/**\n * Base class for TonConnect errors. You can check if the error was triggered by the @tonconnect/sdk using `err instanceof TonConnectError`.\n */\nclass TonConnectError extends Error {\n    get info() {\n        return '';\n    }\n    constructor(message, options) {\n        super(message, options);\n        this.message = `${TonConnectError.prefix} ${this.constructor.name}${this.info ? ': ' + this.info : ''}${message ? '\\n' + message : ''}`;\n        Object.setPrototypeOf(this, TonConnectError.prototype);\n    }\n}\nTonConnectError.prefix = '[TON_CONNECT_SDK_ERROR]';\n\n/**\n * Thrown when passed DappMetadata is in incorrect format.\n */\nclass DappMetadataError extends TonConnectError {\n    get info() {\n        return 'Passed DappMetadata is in incorrect format.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, DappMetadataError.prototype);\n    }\n}\n\n/**\n * Thrown when passed manifest contains errors.\n */\nclass ManifestContentErrorError extends TonConnectError {\n    get info() {\n        return 'Passed `tonconnect-manifest.json` contains errors. Check format of your manifest. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, ManifestContentErrorError.prototype);\n    }\n}\n\n/**\n * Thrown when wallet can't get manifest by passed manifestUrl.\n */\nclass ManifestNotFoundError extends TonConnectError {\n    get info() {\n        return 'Manifest not found. Make sure you added `tonconnect-manifest.json` to the root of your app or passed correct manifestUrl. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, ManifestNotFoundError.prototype);\n    }\n}\n\n/**\n * Thrown when wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection.\n */\nclass WalletAlreadyConnectedError extends TonConnectError {\n    get info() {\n        return 'Wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, WalletAlreadyConnectedError.prototype);\n    }\n}\n\n/**\n * Thrown when send transaction or other protocol methods called while wallet is not connected.\n */\nclass WalletNotConnectedError extends TonConnectError {\n    get info() {\n        return 'Send transaction or other protocol methods called while wallet is not connected.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, WalletNotConnectedError.prototype);\n    }\n}\n\n/**\n * Thrown when there is an attempt to connect to the injected wallet while it is not exists in the webpage.\n */\nclass WalletNotInjectedError extends TonConnectError {\n    get info() {\n        return 'There is an attempt to connect to the injected wallet while it is not exists in the webpage.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, WalletNotInjectedError.prototype);\n    }\n}\n\n/**\n * Thrown when wallet doesn't support requested feature method.\n */\nclass WalletNotSupportFeatureError extends TonConnectError {\n    get info() {\n        return \"Wallet doesn't support requested feature method.\";\n    }\n    constructor(message, options) {\n        super(message, options);\n        Object.setPrototypeOf(this, WalletNotSupportFeatureError.prototype);\n    }\n}\n\n/**\n * Thrown when wallet can't get manifest by passed manifestUrl.\n */\nclass WalletMissingRequiredFeaturesError extends TonConnectError {\n    get info() {\n        return 'Missing required features. You need to update your wallet.';\n    }\n    constructor(message, options) {\n        super(message, options);\n        Object.setPrototypeOf(this, WalletMissingRequiredFeaturesError.prototype);\n    }\n}\n\nclass WalletWrongNetworkError extends TonConnectError {\n    constructor(message, options) {\n        super(message, options);\n        this.name = 'WalletWrongNetworkError';\n        Object.setPrototypeOf(this, WalletWrongNetworkError.prototype);\n    }\n}\n\nfunction isWalletConnectionSourceJS(value) {\n    return 'jsBridgeKey' in value;\n}\nfunction isWalletConnectionSourceWalletConnect(value) {\n    return 'type' in value && value.type === 'wallet-connect';\n}\n\n/**\n * Thrown when user rejects the action in the wallet.\n */\nclass UserRejectsError extends TonConnectError {\n    get info() {\n        return 'User rejects the action in the wallet.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, UserRejectsError.prototype);\n    }\n}\n\n/**\n * Thrown when request to the wallet contains errors.\n */\nclass BadRequestError extends TonConnectError {\n    get info() {\n        return 'Request to the wallet contains errors.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, BadRequestError.prototype);\n    }\n}\n\n/**\n * Thrown when app tries to send rpc request to the injected wallet while not connected.\n */\nclass UnknownAppError extends TonConnectError {\n    get info() {\n        return 'App tries to send rpc request to the injected wallet while not connected.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, UnknownAppError.prototype);\n    }\n}\n\n/**\n * Thrown when `Storage` was not specified in the `DappMetadata` and default `localStorage` was not detected in the Node.js environment.\n */\nclass LocalstorageNotFoundError extends TonConnectError {\n    get info() {\n        return 'Storage was not specified in the `DappMetadata` and default `localStorage` was not detected in the environment.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, LocalstorageNotFoundError.prototype);\n    }\n}\n\n/**\n * Thrown when an error occurred while fetching the wallets list.\n */\nclass FetchWalletsError extends TonConnectError {\n    get info() {\n        return 'An error occurred while fetching the wallets list.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, FetchWalletsError.prototype);\n    }\n}\n\n/**\n * Thrown when passed address is in incorrect format.\n */\nclass WrongAddressError extends TonConnectError {\n    get info() {\n        return 'Passed address is in incorrect format.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, WrongAddressError.prototype);\n    }\n}\n\n/**\n * Thrown when passed hex is in incorrect format.\n */\nclass ParseHexError extends TonConnectError {\n    get info() {\n        return 'Passed hex is in incorrect format.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, ParseHexError.prototype);\n    }\n}\n\n/**\n * Unhanded unknown error.\n */\nclass UnknownError extends TonConnectError {\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, UnknownError.prototype);\n    }\n}\n\nconst connectEventErrorsCodes = {\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.MANIFEST_NOT_FOUND_ERROR]: ManifestNotFoundError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR]: ManifestContentErrorError\n};\nclass ConnectErrorsParser {\n    parseError(error) {\n        let ErrorConstructor = UnknownError;\n        if (error.code in connectEventErrorsCodes) {\n            ErrorConstructor = connectEventErrorsCodes[error.code] || UnknownError;\n        }\n        return new ErrorConstructor(error.message);\n    }\n}\nconst connectErrorsParser = new ConnectErrorsParser();\n\nclass RpcParser {\n    isError(response) {\n        return 'error' in response;\n    }\n}\n\nconst sendTransactionErrors = {\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError\n};\nclass SendTransactionParser extends RpcParser {\n    convertToRpcRequest(request) {\n        return {\n            method: 'sendTransaction',\n            params: [JSON.stringify(request)]\n        };\n    }\n    parseAndThrowError(response) {\n        let ErrorConstructor = UnknownError;\n        if (response.error.code in sendTransactionErrors) {\n            ErrorConstructor = sendTransactionErrors[response.error.code] || UnknownError;\n        }\n        throw new ErrorConstructor(response.error.message);\n    }\n    convertFromRpcResponse(rpcResponse) {\n        return {\n            boc: rpcResponse.result\n        };\n    }\n}\nconst sendTransactionParser = new SendTransactionParser();\n\nconst signDataErrors = {\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SIGN_DATA_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SIGN_DATA_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SIGN_DATA_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SIGN_DATA_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError\n};\nclass SignDataParser extends RpcParser {\n    convertToRpcRequest(payload) {\n        return {\n            method: 'signData',\n            params: [JSON.stringify(payload)]\n        };\n    }\n    parseAndThrowError(response) {\n        let ErrorConstructor = UnknownError;\n        if (response.error.code in signDataErrors) {\n            ErrorConstructor = signDataErrors[response.error.code] || UnknownError;\n        }\n        throw new ErrorConstructor(response.error.message);\n    }\n    convertFromRpcResponse(rpcResponse) {\n        return rpcResponse.result;\n    }\n}\nconst signDataParser = new SignDataParser();\n\nclass HttpBridgeGatewayStorage {\n    constructor(storage, bridgeUrl) {\n        this.storage = storage;\n        this.storeKey = 'ton-connect-storage_http-bridge-gateway::' + bridgeUrl;\n    }\n    storeLastEventId(lastEventId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.storage.setItem(this.storeKey, lastEventId);\n        });\n    }\n    removeLastEventId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.storage.removeItem(this.storeKey);\n        });\n    }\n    getLastEventId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const stored = yield this.storage.getItem(this.storeKey);\n            if (!stored) {\n                return null;\n            }\n            return stored;\n        });\n    }\n}\n\nfunction removeUrlLastSlash(url) {\n    if (url.slice(-1) === '/') {\n        return url.slice(0, -1);\n    }\n    return url;\n}\nfunction addPathToUrl(url, path) {\n    return removeUrlLastSlash(url) + '/' + path;\n}\nfunction isTelegramUrl(link) {\n    if (!link) {\n        return false;\n    }\n    const url = new URL(link);\n    return url.protocol === 'tg:' || url.hostname === 't.me';\n}\nfunction isConnectUrl(link) {\n    if (!link) {\n        return false;\n    }\n    return link.includes('ton_addr') || link.includes('ton--5Faddr');\n}\nfunction encodeTelegramUrlParameters(parameters) {\n    return parameters\n        .replaceAll('.', '%2E')\n        .replaceAll('-', '%2D')\n        .replaceAll('_', '%5F')\n        .replaceAll('&', '-')\n        .replaceAll('=', '__')\n        .replaceAll('%', '--');\n}\nfunction decodeTelegramUrlParameters(parameters) {\n    return parameters\n        .replaceAll('--', '%')\n        .replaceAll('__', '=')\n        .replaceAll('-', '&')\n        .replaceAll('%5F', '_')\n        .replaceAll('%2D', '-')\n        .replaceAll('%2E', '.');\n}\n\n/**\n * Delays the execution of code for a specified number of milliseconds.\n * @param {number} timeout - The number of milliseconds to delay the execution.\n * @param {DelayOptions} [options] - Optional configuration options for the delay.\n * @return {Promise<void>} - A promise that resolves after the specified delay, or rejects if the delay is aborted.\n */\nfunction delay(timeout, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            var _a, _b;\n            if ((_a = void 0 ) === null || _a === void 0 ? void 0 : _a.aborted) {\n                reject(new TonConnectError('Delay aborted'));\n                return;\n            }\n            const timeoutId = setTimeout(() => resolve(), timeout);\n            (_b = void 0 ) === null || _b === void 0 ? void 0 : _b.addEventListener('abort', () => {\n                clearTimeout(timeoutId);\n                reject(new TonConnectError('Delay aborted'));\n            });\n        });\n    });\n}\n\n/**\n * Creates an AbortController instance with an optional AbortSignal.\n *\n * @param {AbortSignal} [signal] - An optional AbortSignal to use for aborting the controller.\n * @returns {AbortController} - An instance of AbortController.\n */\nfunction createAbortController(signal) {\n    const abortController = new AbortController();\n    if (signal === null || signal === void 0 ? void 0 : signal.aborted) {\n        abortController.abort();\n    }\n    else {\n        signal === null || signal === void 0 ? void 0 : signal.addEventListener('abort', () => abortController.abort(), { once: true });\n    }\n    return abortController;\n}\n\n/**\n * Function to call ton api until we get response.\n * Because ton network is pretty unstable we need to make sure response is final.\n * @param {T} fn - function to call\n * @param {CallForSuccessOptions} [options] - optional configuration options\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction callForSuccess(fn, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        const attempts = (_a = options === null || options === void 0 ? void 0 : options.attempts) !== null && _a !== void 0 ? _a : 10;\n        const delayMs = (_b = options === null || options === void 0 ? void 0 : options.delayMs) !== null && _b !== void 0 ? _b : 200;\n        const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n        if (typeof fn !== 'function') {\n            throw new TonConnectError(`Expected a function, got ${typeof fn}`);\n        }\n        let i = 0;\n        let lastError;\n        while (i < attempts) {\n            if (abortController.signal.aborted) {\n                throw new TonConnectError(`Aborted after attempts ${i}`);\n            }\n            try {\n                return yield fn({ signal: abortController.signal });\n            }\n            catch (err) {\n                lastError = err;\n                i++;\n                if (i < attempts) {\n                    yield delay(delayMs);\n                }\n            }\n        }\n        throw lastError;\n    });\n}\n\nfunction logDebug(...args) {\n    {\n        try {\n            console.debug('[TON_CONNECT_SDK]', ...args);\n        }\n        catch (_a) { }\n    }\n}\nfunction logError(...args) {\n    {\n        try {\n            console.error('[TON_CONNECT_SDK]', ...args);\n        }\n        catch (_a) { }\n    }\n}\nfunction logWarning(...args) {\n    {\n        try {\n            console.warn('[TON_CONNECT_SDK]', ...args);\n        }\n        catch (_a) { }\n    }\n}\n\n/**\n * Create a resource.\n *\n * @template T - The type of the resource.\n * @template Args - The type of the arguments for creating the resource.\n *\n * @param {(...args: Args) => Promise<T>} createFn - A function that creates the resource.\n * @param {(resource: T) => Promise<void>} [disposeFn] - An optional function that disposes the resource.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction createResource(createFn, disposeFn) {\n    let currentResource = null;\n    let currentArgs = null;\n    let currentPromise = null;\n    let currentSignal = null;\n    let abortController = null;\n    // create a new resource\n    const create = (signal, ...args) => __awaiter(this, void 0, void 0, function* () {\n        currentSignal = signal !== null && signal !== void 0 ? signal : null;\n        abortController === null || abortController === void 0 ? void 0 : abortController.abort();\n        abortController = createAbortController(signal);\n        if (abortController.signal.aborted) {\n            throw new TonConnectError('Resource creation was aborted');\n        }\n        currentArgs = args !== null && args !== void 0 ? args : null;\n        const promise = createFn(abortController.signal, ...args);\n        currentPromise = promise;\n        const resource = yield promise;\n        if (currentPromise !== promise && resource !== currentResource) {\n            yield disposeFn(resource);\n            throw new TonConnectError('Resource creation was aborted by a new resource creation');\n        }\n        currentResource = resource;\n        return currentResource;\n    });\n    // get the current resource\n    const current = () => {\n        return currentResource !== null && currentResource !== void 0 ? currentResource : null;\n    };\n    // dispose the current resource\n    const dispose = () => __awaiter(this, void 0, void 0, function* () {\n        try {\n            const resource = currentResource;\n            currentResource = null;\n            const promise = currentPromise;\n            currentPromise = null;\n            try {\n                abortController === null || abortController === void 0 ? void 0 : abortController.abort();\n            }\n            catch (e) { }\n            yield Promise.allSettled([\n                resource ? disposeFn(resource) : Promise.resolve(),\n                promise ? disposeFn(yield promise) : Promise.resolve()\n            ]);\n        }\n        catch (e) { }\n    });\n    // recreate the current resource\n    const recreate = (delayMs) => __awaiter(this, void 0, void 0, function* () {\n        const resource = currentResource;\n        const promise = currentPromise;\n        const args = currentArgs;\n        const signal = currentSignal;\n        yield delay(delayMs);\n        if (resource === currentResource &&\n            promise === currentPromise &&\n            args === currentArgs &&\n            signal === currentSignal) {\n            return yield create(currentSignal, ...(args !== null && args !== void 0 ? args : []));\n        }\n        throw new TonConnectError('Resource recreation was aborted by a new resource creation');\n    });\n    return {\n        create,\n        current,\n        dispose,\n        recreate\n    };\n}\n\n/**\n * Executes a function and provides deferred behavior, allowing for a timeout and abort functionality.\n *\n * @param {Deferrable<T>} fn - The function to execute. It should return a promise that resolves with the desired result.\n * @param {DeferOptions} options - Optional configuration options for the defer behavior.\n * @returns {Promise<T>} - A promise that resolves with the result of the executed function, or rejects with an error if it times out or is aborted.\n */\nfunction timeout(fn, options) {\n    const timeout = options === null || options === void 0 ? void 0 : options.timeout;\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    const abortController = createAbortController(signal);\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n        if (abortController.signal.aborted) {\n            reject(new TonConnectError('Operation aborted'));\n            return;\n        }\n        let timeoutId;\n        if (typeof timeout !== 'undefined') {\n            timeoutId = setTimeout(() => {\n                abortController.abort();\n                reject(new TonConnectError(`Timeout after ${timeout}ms`));\n            }, timeout);\n        }\n        abortController.signal.addEventListener('abort', () => {\n            clearTimeout(timeoutId);\n            reject(new TonConnectError('Operation aborted'));\n        }, { once: true });\n        const deferOptions = { timeout, abort: abortController.signal };\n        yield fn((...args) => {\n            clearTimeout(timeoutId);\n            resolve(...args);\n        }, () => {\n            clearTimeout(timeoutId);\n            reject();\n        }, deferOptions);\n    }));\n}\n\nclass BridgeGateway {\n    get isReady() {\n        const eventSource = this.eventSource.current();\n        return (eventSource === null || eventSource === void 0 ? void 0 : eventSource.readyState) === EventSource.OPEN;\n    }\n    get isClosed() {\n        const eventSource = this.eventSource.current();\n        return (eventSource === null || eventSource === void 0 ? void 0 : eventSource.readyState) !== EventSource.OPEN;\n    }\n    get isConnecting() {\n        const eventSource = this.eventSource.current();\n        return (eventSource === null || eventSource === void 0 ? void 0 : eventSource.readyState) === EventSource.CONNECTING;\n    }\n    constructor(storage, bridgeUrl, sessionId, listener, errorsListener, analyticsManager) {\n        this.bridgeUrl = bridgeUrl;\n        this.sessionId = sessionId;\n        this.listener = listener;\n        this.errorsListener = errorsListener;\n        this.ssePath = 'events';\n        this.postPath = 'message';\n        this.heartbeatMessage = 'heartbeat';\n        this.defaultTtl = 300;\n        this.defaultReconnectDelay = 2000;\n        this.defaultResendDelay = 5000;\n        this.eventSource = createResource((signal, openingDeadlineMS, traceId) => __awaiter(this, void 0, void 0, function* () {\n            const eventSourceConfig = {\n                bridgeUrl: this.bridgeUrl,\n                ssePath: this.ssePath,\n                sessionId: this.sessionId,\n                bridgeGatewayStorage: this.bridgeGatewayStorage,\n                errorHandler: this.errorsHandler.bind(this),\n                messageHandler: this.messagesHandler.bind(this),\n                signal: signal,\n                openingDeadlineMS: openingDeadlineMS,\n                traceId\n            };\n            return yield createEventSource(eventSourceConfig);\n        }), (resource) => __awaiter(this, void 0, void 0, function* () {\n            resource.close();\n        }));\n        this.bridgeGatewayStorage = new HttpBridgeGatewayStorage(storage, bridgeUrl);\n        this.analytics = analyticsManager === null || analyticsManager === void 0 ? void 0 : analyticsManager.scoped({\n            bridge_url: bridgeUrl,\n            client_id: sessionId\n        });\n    }\n    registerSession(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            try {\n                (_a = this.analytics) === null || _a === void 0 ? void 0 : _a.emitBridgeClientConnectStarted({\n                    trace_id: options === null || options === void 0 ? void 0 : options.traceId\n                });\n                const connectionStarted = Date.now();\n                yield this.eventSource.create(options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.openingDeadlineMS, options === null || options === void 0 ? void 0 : options.traceId);\n                const bridgeConnectDuration = Date.now() - connectionStarted;\n                (_b = this.analytics) === null || _b === void 0 ? void 0 : _b.emitBridgeClientConnectEstablished({\n                    bridge_connect_duration: bridgeConnectDuration,\n                    trace_id: options === null || options === void 0 ? void 0 : options.traceId\n                });\n            }\n            catch (error) {\n                (_c = this.analytics) === null || _c === void 0 ? void 0 : _c.emitBridgeClientConnectError({\n                    trace_id: options === null || options === void 0 ? void 0 : options.traceId,\n                    error_message: String(error)\n                });\n                throw error;\n            }\n        });\n    }\n    send(message, receiver, topic, ttlOrOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            // TODO: remove deprecated method\n            const options = {};\n            if (typeof ttlOrOptions === 'number') {\n                options.ttl = ttlOrOptions;\n            }\n            else {\n                options.ttl = ttlOrOptions === null || ttlOrOptions === void 0 ? void 0 : ttlOrOptions.ttl;\n                options.signal = ttlOrOptions === null || ttlOrOptions === void 0 ? void 0 : ttlOrOptions.signal;\n                options.attempts = ttlOrOptions === null || ttlOrOptions === void 0 ? void 0 : ttlOrOptions.attempts;\n                options.traceId = ttlOrOptions === null || ttlOrOptions === void 0 ? void 0 : ttlOrOptions.traceId;\n            }\n            const url = new URL(addPathToUrl(this.bridgeUrl, this.postPath));\n            url.searchParams.append('client_id', this.sessionId);\n            url.searchParams.append('to', receiver);\n            url.searchParams.append('ttl', ((options === null || options === void 0 ? void 0 : options.ttl) || this.defaultTtl).toString());\n            url.searchParams.append('topic', topic);\n            if (options === null || options === void 0 ? void 0 : options.traceId) {\n                url.searchParams.append('trace_id', options.traceId);\n            }\n            const body = _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.Base64.encode(message);\n            yield callForSuccess((options) => __awaiter(this, void 0, void 0, function* () {\n                const response = yield this.post(url, body, options.signal);\n                if (!response.ok) {\n                    throw new TonConnectError(`Bridge send failed, status ${response.status}`);\n                }\n            }), {\n                attempts: (_a = options === null || options === void 0 ? void 0 : options.attempts) !== null && _a !== void 0 ? _a : Number.MAX_SAFE_INTEGER,\n                delayMs: this.defaultResendDelay,\n                signal: options === null || options === void 0 ? void 0 : options.signal\n            });\n        });\n    }\n    pause() {\n        this.eventSource.dispose().catch(e => logError(`Bridge pause failed, ${e}`));\n    }\n    unPause() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const RECREATE_WITHOUT_DELAY = 0;\n            yield this.eventSource.recreate(RECREATE_WITHOUT_DELAY);\n        });\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.eventSource.dispose().catch(e => logError(`Bridge close failed, ${e}`));\n        });\n    }\n    setListener(listener) {\n        this.listener = listener;\n    }\n    setErrorsListener(errorsListener) {\n        this.errorsListener = errorsListener;\n    }\n    post(url, body, signal) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(url, {\n                method: 'post',\n                body: body,\n                signal: signal\n            });\n            if (!response.ok) {\n                throw new TonConnectError(`Bridge send failed, status ${response.status}`);\n            }\n            return response;\n        });\n    }\n    errorsHandler(eventSource, e) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.isConnecting) {\n                eventSource.close();\n                throw new TonConnectError('Bridge error, failed to connect');\n            }\n            if (this.isReady) {\n                try {\n                    this.errorsListener(e);\n                }\n                catch (e) { }\n                return;\n            }\n            if (this.isClosed) {\n                eventSource.close();\n                logDebug(`Bridge reconnecting, ${this.defaultReconnectDelay}ms delay`);\n                return yield this.eventSource.recreate(this.defaultReconnectDelay);\n            }\n            throw new TonConnectError('Bridge error, unknown state');\n        });\n    }\n    messagesHandler(e) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (e.data === this.heartbeatMessage) {\n                return;\n            }\n            yield this.bridgeGatewayStorage.storeLastEventId(e.lastEventId);\n            if (this.isClosed) {\n                return;\n            }\n            let bridgeIncomingMessage;\n            try {\n                const bridgeIncomingMessageRaw = JSON.parse(e.data);\n                bridgeIncomingMessage = {\n                    message: bridgeIncomingMessageRaw.message,\n                    from: bridgeIncomingMessageRaw.from,\n                    traceId: bridgeIncomingMessageRaw.trace_id\n                };\n            }\n            catch (_) {\n                throw new TonConnectError(`Bridge message parse failed, message ${e.data}`);\n            }\n            this.listener(bridgeIncomingMessage);\n        });\n    }\n}\n/**\n * Creates an event source.\n * @param {CreateEventSourceConfig} config - Configuration for creating an event source.\n */\nfunction createEventSource(config) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield timeout((resolve, reject, deferOptions) => __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const abortController = createAbortController(deferOptions.signal);\n            const signal = abortController.signal;\n            if (signal.aborted) {\n                reject(new TonConnectError('Bridge connection aborted'));\n                return;\n            }\n            const url = new URL(addPathToUrl(config.bridgeUrl, config.ssePath));\n            url.searchParams.append('client_id', config.sessionId);\n            const lastEventId = yield config.bridgeGatewayStorage.getLastEventId();\n            if (lastEventId) {\n                url.searchParams.append('last_event_id', lastEventId);\n            }\n            if (config.traceId) {\n                url.searchParams.append('trace_id', config.traceId);\n            }\n            if (signal.aborted) {\n                reject(new TonConnectError('Bridge connection aborted'));\n                return;\n            }\n            const eventSource = new EventSource(url.toString());\n            eventSource.onerror = (reason) => __awaiter(this, void 0, void 0, function* () {\n                if (signal.aborted) {\n                    eventSource.close();\n                    reject(new TonConnectError('Bridge connection aborted'));\n                    return;\n                }\n                try {\n                    const newInstance = yield config.errorHandler(eventSource, reason);\n                    if (newInstance !== eventSource) {\n                        eventSource.close();\n                    }\n                    if (newInstance && newInstance !== eventSource) {\n                        resolve(newInstance);\n                    }\n                }\n                catch (e) {\n                    eventSource.close();\n                    reject(e);\n                }\n            });\n            eventSource.onopen = () => {\n                if (signal.aborted) {\n                    eventSource.close();\n                    reject(new TonConnectError('Bridge connection aborted'));\n                    return;\n                }\n                resolve(eventSource);\n            };\n            eventSource.onmessage = (event) => {\n                if (signal.aborted) {\n                    eventSource.close();\n                    reject(new TonConnectError('Bridge connection aborted'));\n                    return;\n                }\n                config.messageHandler(event);\n            };\n            (_a = config.signal) === null || _a === void 0 ? void 0 : _a.addEventListener('abort', () => {\n                eventSource.close();\n                reject(new TonConnectError('Bridge connection aborted'));\n            });\n        }), { timeout: config.openingDeadlineMS, signal: config.signal });\n    });\n}\n\nconst CONNECTION_HTTP_EXPIRATION_TIME = 5 * 60 * 1000;\nfunction isPendingConnectionHttp(connection) {\n    return !('connectEvent' in connection);\n}\nfunction isPendingConnectionHttpRaw(connection) {\n    return !('connectEvent' in connection);\n}\nfunction isExpiredPendingConnectionHttpRaw(connection) {\n    var _a;\n    return Date.now() - ((_a = connection.createdAt) !== null && _a !== void 0 ? _a : 0) > CONNECTION_HTTP_EXPIRATION_TIME;\n}\n\nconst PROTOCOL_VERSION = 2;\n\n/**\n * The MIT License (MIT)\n *\n * Copyright (c) 2010-2020 Robert Kieffer and other contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nfunction rng() {\n    // lazy load so that environments that need to polyfill have a chance to do so\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n\n/**\n * The MIT License (MIT)\n *\n * Copyright (c) 2010-2020 Robert Kieffer and other contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n    // Note: Be careful editing this code!  It's been tuned for performance\n    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n    //\n    // Note to future-self: No, you can't remove the `toLowerCase()` call.\n    // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\n\n/**\n * The MIT License (MIT)\n *\n * Copyright (c) 2010-2020 Robert Kieffer and other contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nconst _state = {};\nfunction UUIDv7(options, buf, offset) {\n    var _a, _b, _c;\n    let bytes;\n    if (options) {\n        // With options: Make UUID independent of internal state\n        bytes = v7Bytes((_c = (_a = options.random) !== null && _a !== void 0 ? _a : (_b = options.rng) === null || _b === void 0 ? void 0 : _b.call(options)) !== null && _c !== void 0 ? _c : rng(), options.msecs, options.seq, buf, offset);\n    }\n    else {\n        // No options: Use internal state\n        const now = Date.now();\n        const rnds = rng();\n        updateV7State(_state, now, rnds);\n        bytes = v7Bytes(rnds, _state.msecs, _state.seq, buf, offset);\n    }\n    return buf !== null && buf !== void 0 ? buf : unsafeStringify(bytes);\n}\n// (Private!)  Do not use.  This method is only exported for testing purposes\n// and may change without notice.\nfunction updateV7State(state, now, rnds) {\n    var _a, _b;\n    (_a = state.msecs) !== null && _a !== void 0 ? _a : (state.msecs = -Infinity);\n    (_b = state.seq) !== null && _b !== void 0 ? _b : (state.seq = 0);\n    if (now > state.msecs) {\n        // Time has moved on! Pick a new random sequence number\n        state.seq = (rnds[6] << 23) | (rnds[7] << 16) | (rnds[8] << 8) | rnds[9];\n        state.msecs = now;\n    }\n    else {\n        // Bump sequence counter w/ 32-bit rollover\n        state.seq = (state.seq + 1) | 0;\n        // In case of rollover, bump timestamp to preserve monotonicity. This is\n        // allowed by the RFC and should self-correct as the system clock catches\n        // up. See https://www.rfc-editor.org/rfc/rfc9562.html#section-6.2-9.4\n        if (state.seq === 0) {\n            state.msecs++;\n        }\n    }\n    return state;\n}\nfunction v7Bytes(rnds, msecs, seq, buf, offset = 0) {\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    if (!buf) {\n        buf = new Uint8Array(16);\n        offset = 0;\n    }\n    else {\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n    }\n    // Defaults\n    msecs !== null && msecs !== void 0 ? msecs : (msecs = Date.now());\n    seq !== null && seq !== void 0 ? seq : (seq = ((rnds[6] * 0x7f) << 24) | (rnds[7] << 16) | (rnds[8] << 8) | rnds[9]);\n    // byte 0-5: timestamp (48 bits)\n    buf[offset++] = (msecs / 0x10000000000) & 0xff;\n    buf[offset++] = (msecs / 0x100000000) & 0xff;\n    buf[offset++] = (msecs / 0x1000000) & 0xff;\n    buf[offset++] = (msecs / 0x10000) & 0xff;\n    buf[offset++] = (msecs / 0x100) & 0xff;\n    buf[offset++] = msecs & 0xff;\n    // byte 6: `version` (4 bits) | sequence bits 28-31 (4 bits)\n    buf[offset++] = 0x70 | ((seq >>> 28) & 0x0f);\n    // byte 7: sequence bits 20-27 (8 bits)\n    buf[offset++] = (seq >>> 20) & 0xff;\n    // byte 8: `variant` (2 bits) | sequence bits 14-19 (6 bits)\n    buf[offset++] = 0x80 | ((seq >>> 14) & 0x3f);\n    // byte 9: sequence bits 6-13 (8 bits)\n    buf[offset++] = (seq >>> 6) & 0xff;\n    // byte 10: sequence bits 0-5 (6 bits) | random (2 bits)\n    buf[offset++] = ((seq << 2) & 0xff) | (rnds[10] & 0x03);\n    // bytes 11-15: random (40 bits)\n    buf[offset++] = rnds[11];\n    buf[offset++] = rnds[12];\n    buf[offset++] = rnds[13];\n    buf[offset++] = rnds[14];\n    buf[offset++] = rnds[15];\n    return buf;\n}\n\nfunction waitForSome(promises, count) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (count <= 0)\n            return [];\n        if (count > promises.length) {\n            throw new RangeError('count cannot be greater than the number of promises');\n        }\n        const results = new Array(promises.length);\n        let settledCount = 0;\n        return new Promise(resolve => {\n            promises.forEach((p, index) => {\n                Promise.resolve(p)\n                    .then(value => ({ status: 'fulfilled', value }))\n                    .catch(reason => ({ status: 'rejected', reason }))\n                    .then(result => {\n                    results[index] = result;\n                    settledCount++;\n                    if (settledCount === count) {\n                        resolve(results);\n                    }\n                });\n            });\n        });\n    });\n}\n\nclass BridgeProvider {\n    static fromStorage(storage, analyticsManager) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield storage.getHttpConnection();\n            if (isPendingConnectionHttp(connection)) {\n                return new BridgeProvider(storage, connection.connectionSource, analyticsManager);\n            }\n            return new BridgeProvider(storage, { bridgeUrl: connection.session.bridgeUrl }, analyticsManager);\n        });\n    }\n    constructor(connectionStorage, walletConnectionSource, analyticsManager) {\n        var _a;\n        this.connectionStorage = connectionStorage;\n        this.walletConnectionSource = walletConnectionSource;\n        this.analyticsManager = analyticsManager;\n        this.type = 'http';\n        this.standardUniversalLink = 'tc://';\n        this.pendingRequests = new Map();\n        this.session = null;\n        this.gateway = null;\n        this.pendingGateways = [];\n        this.listeners = [];\n        this.defaultOpeningDeadlineMS = 12000;\n        this.defaultRetryTimeoutMS = 2000;\n        this.optionalOpenGateways = 3;\n        this.analytics = (_a = this.analyticsManager) === null || _a === void 0 ? void 0 : _a.scoped();\n    }\n    connect(message, options) {\n        var _a, _b;\n        const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n        const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n        (_b = this.abortController) === null || _b === void 0 ? void 0 : _b.abort();\n        this.abortController = abortController;\n        this.closeGateways();\n        const sessionCrypto = new _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SessionCrypto();\n        this.session = {\n            sessionCrypto,\n            bridgeUrl: 'bridgeUrl' in this.walletConnectionSource\n                ? this.walletConnectionSource.bridgeUrl\n                : ''\n        };\n        this.connectionStorage\n            .storeConnection({\n            type: 'http',\n            connectionSource: this.walletConnectionSource,\n            sessionCrypto\n        })\n            .then(() => __awaiter(this, void 0, void 0, function* () {\n            if (abortController.signal.aborted) {\n                return;\n            }\n            yield callForSuccess(_options => {\n                var _a;\n                return this.openGateways(sessionCrypto, {\n                    openingDeadlineMS: (_a = options === null || options === void 0 ? void 0 : options.openingDeadlineMS) !== null && _a !== void 0 ? _a : this.defaultOpeningDeadlineMS,\n                    signal: _options === null || _options === void 0 ? void 0 : _options.signal,\n                    traceId\n                });\n            }, {\n                attempts: Number.MAX_SAFE_INTEGER,\n                delayMs: this.defaultRetryTimeoutMS,\n                signal: abortController.signal\n            });\n        }));\n        const universalLink = 'universalLink' in this.walletConnectionSource &&\n            this.walletConnectionSource.universalLink\n            ? this.walletConnectionSource.universalLink\n            : this.standardUniversalLink;\n        return this.generateUniversalLink(universalLink, message, { traceId });\n    }\n    restoreConnection(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n            (_b = this.abortController) === null || _b === void 0 ? void 0 : _b.abort();\n            this.abortController = abortController;\n            if (abortController.signal.aborted) {\n                return;\n            }\n            this.closeGateways();\n            const storedConnection = yield this.connectionStorage.getHttpConnection();\n            if (!storedConnection) {\n                return;\n            }\n            if (abortController.signal.aborted) {\n                return;\n            }\n            const openingDeadlineMS = (_c = options === null || options === void 0 ? void 0 : options.openingDeadlineMS) !== null && _c !== void 0 ? _c : this.defaultOpeningDeadlineMS;\n            if (isPendingConnectionHttp(storedConnection)) {\n                this.session = {\n                    sessionCrypto: storedConnection.sessionCrypto,\n                    bridgeUrl: 'bridgeUrl' in this.walletConnectionSource\n                        ? this.walletConnectionSource.bridgeUrl\n                        : ''\n                };\n                return yield this.openGateways(storedConnection.sessionCrypto, {\n                    openingDeadlineMS: openingDeadlineMS,\n                    signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal,\n                    traceId: options === null || options === void 0 ? void 0 : options.traceId\n                });\n            }\n            if (Array.isArray(this.walletConnectionSource)) {\n                throw new TonConnectError('Internal error. Connection source is array while WalletConnectionSourceHTTP was expected.');\n            }\n            this.session = storedConnection.session;\n            if (this.gateway) {\n                logDebug('Gateway is already opened, closing previous gateway');\n                yield this.gateway.close();\n            }\n            this.gateway = new BridgeGateway(this.connectionStorage.storage, this.walletConnectionSource.bridgeUrl, storedConnection.session.sessionCrypto.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this), this.analyticsManager);\n            if (abortController.signal.aborted) {\n                return;\n            }\n            // notify listeners about stored connection\n            this.listeners.forEach(listener => listener(Object.assign(Object.assign({}, storedConnection.connectEvent), { traceId })));\n            // wait for the connection to be opened\n            try {\n                yield callForSuccess(options => this.gateway.registerSession({\n                    openingDeadlineMS: openingDeadlineMS,\n                    signal: options.signal,\n                    traceId\n                }), {\n                    attempts: Number.MAX_SAFE_INTEGER,\n                    delayMs: this.defaultRetryTimeoutMS,\n                    signal: abortController.signal\n                });\n            }\n            catch (e) {\n                yield this.disconnect({ signal: abortController.signal, traceId });\n                return;\n            }\n        });\n    }\n    sendRequest(request, optionsOrOnRequestSent) {\n        var _a;\n        // TODO: remove deprecated method\n        const options = {};\n        if (typeof optionsOrOnRequestSent === 'function') {\n            options.onRequestSent = optionsOrOnRequestSent;\n        }\n        else {\n            options.onRequestSent = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.onRequestSent;\n            options.signal = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.signal;\n            options.attempts = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.attempts;\n            options.traceId = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.traceId;\n        }\n        (_a = options.traceId) !== null && _a !== void 0 ? _a : (options.traceId = UUIDv7());\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            if (!this.gateway || !this.session || !('walletPublicKey' in this.session)) {\n                throw new TonConnectError('Trying to send bridge request without session');\n            }\n            const id = (yield this.connectionStorage.getNextRpcRequestId()).toString();\n            yield this.connectionStorage.increaseNextRpcRequestId();\n            logDebug('Send http-bridge request:', Object.assign(Object.assign({}, request), { id }));\n            const encodedRequest = this.session.sessionCrypto.encrypt(JSON.stringify(Object.assign(Object.assign({}, request), { id })), (0,_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.hexToByteArray)(this.session.walletPublicKey));\n            try {\n                (_a = this.analytics) === null || _a === void 0 ? void 0 : _a.emitBridgeClientMessageSent({\n                    bridge_url: this.gateway.bridgeUrl,\n                    client_id: this.session.sessionCrypto.sessionId,\n                    wallet_id: this.session.walletPublicKey,\n                    message_id: id,\n                    request_type: request.method,\n                    trace_id: options.traceId\n                });\n                yield this.gateway.send(encodedRequest, this.session.walletPublicKey, request.method, {\n                    attempts: options === null || options === void 0 ? void 0 : options.attempts,\n                    signal: options === null || options === void 0 ? void 0 : options.signal,\n                    traceId: options.traceId\n                });\n                (_b = options === null || options === void 0 ? void 0 : options.onRequestSent) === null || _b === void 0 ? void 0 : _b.call(options);\n                this.pendingRequests.set(id.toString(), resolve);\n            }\n            catch (e) {\n                reject(e);\n            }\n        }));\n    }\n    closeConnection() {\n        this.closeGateways();\n        this.listeners = [];\n        this.session = null;\n        this.gateway = null;\n    }\n    disconnect(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                let called = false;\n                let timeoutId = null;\n                const onRequestSent = () => {\n                    if (!called) {\n                        called = true;\n                        this.removeBridgeAndSession().then(resolve);\n                    }\n                };\n                try {\n                    this.closeGateways();\n                    const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n                    timeoutId = setTimeout(() => {\n                        abortController.abort();\n                    }, this.defaultOpeningDeadlineMS);\n                    yield this.sendRequest({ method: 'disconnect', params: [] }, {\n                        onRequestSent: onRequestSent,\n                        signal: abortController.signal,\n                        attempts: 1,\n                        traceId\n                    });\n                }\n                catch (e) {\n                    logDebug('Disconnect error:', e);\n                    if (!called) {\n                        this.removeBridgeAndSession().then(resolve);\n                    }\n                }\n                finally {\n                    if (timeoutId) {\n                        clearTimeout(timeoutId);\n                    }\n                    onRequestSent();\n                }\n            }));\n        });\n    }\n    listen(callback) {\n        this.listeners.push(callback);\n        return () => (this.listeners = this.listeners.filter(listener => listener !== callback));\n    }\n    pause() {\n        var _a;\n        (_a = this.gateway) === null || _a === void 0 ? void 0 : _a.pause();\n        this.pendingGateways.forEach(bridge => bridge.pause());\n    }\n    unPause() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const promises = this.pendingGateways.map(bridge => bridge.unPause());\n            if (this.gateway) {\n                promises.push(this.gateway.unPause());\n            }\n            yield Promise.all(promises);\n        });\n    }\n    pendingGatewaysListener(gateway, bridgeUrl, bridgeIncomingMessage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.pendingGateways.includes(gateway)) {\n                yield gateway.close();\n                return;\n            }\n            this.closeGateways({ except: gateway });\n            if (this.gateway) {\n                logDebug('Gateway is already opened, closing previous gateway');\n                yield this.gateway.close();\n            }\n            this.session.bridgeUrl = bridgeUrl;\n            this.gateway = gateway;\n            this.gateway.setErrorsListener(this.gatewayErrorsListener.bind(this));\n            this.gateway.setListener(this.gatewayListener.bind(this));\n            return this.gatewayListener(bridgeIncomingMessage);\n        });\n    }\n    gatewayListener(bridgeIncomingMessage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            const traceId = (_a = bridgeIncomingMessage.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            let walletMessage;\n            try {\n                walletMessage = JSON.parse(this.session.sessionCrypto.decrypt(_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.Base64.decode(bridgeIncomingMessage.message).toUint8Array(), (0,_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.hexToByteArray)(bridgeIncomingMessage.from)));\n            }\n            catch (err) {\n                (_b = this.analytics) === null || _b === void 0 ? void 0 : _b.emitBridgeClientMessageDecodeError({\n                    bridge_url: this.session.bridgeUrl,\n                    client_id: this.session.sessionCrypto.sessionId,\n                    wallet_id: bridgeIncomingMessage.from,\n                    error_message: String(err),\n                    trace_id: bridgeIncomingMessage === null || bridgeIncomingMessage === void 0 ? void 0 : bridgeIncomingMessage.traceId\n                });\n                throw err;\n            }\n            logDebug('Wallet message received:', walletMessage);\n            const requestType = 'event' in walletMessage ? walletMessage.event : '';\n            (_c = this.analytics) === null || _c === void 0 ? void 0 : _c.emitBridgeClientMessageReceived({\n                bridge_url: this.session.bridgeUrl,\n                client_id: this.session.sessionCrypto.sessionId,\n                wallet_id: bridgeIncomingMessage.from,\n                message_id: String(walletMessage.id),\n                request_type: requestType,\n                trace_id: bridgeIncomingMessage === null || bridgeIncomingMessage === void 0 ? void 0 : bridgeIncomingMessage.traceId\n            });\n            if (!('event' in walletMessage)) {\n                const id = walletMessage.id.toString();\n                const resolve = this.pendingRequests.get(id);\n                if (!resolve) {\n                    logDebug(`Response id ${id} doesn't match any request's id`);\n                    return;\n                }\n                resolve(Object.assign(Object.assign({}, walletMessage), { traceId }));\n                this.pendingRequests.delete(id);\n                return;\n            }\n            if (walletMessage.id !== undefined) {\n                const lastId = yield this.connectionStorage.getLastWalletEventId();\n                if (lastId !== undefined && walletMessage.id <= lastId) {\n                    logError(`Received event id (=${walletMessage.id}) must be greater than stored last wallet event id (=${lastId}) `);\n                    return;\n                }\n                if (walletMessage.event !== 'connect') {\n                    yield this.connectionStorage.storeLastWalletEventId(walletMessage.id);\n                }\n            }\n            // `this.listeners` might be modified in the event handler\n            const listeners = this.listeners;\n            if (walletMessage.event === 'connect') {\n                yield this.updateSession(walletMessage, bridgeIncomingMessage.from);\n            }\n            if (walletMessage.event === 'disconnect') {\n                logDebug(`Removing bridge and session: received disconnect event`);\n                yield this.removeBridgeAndSession();\n            }\n            listeners.forEach(listener => listener(Object.assign(Object.assign({}, walletMessage), { traceId })));\n        });\n    }\n    gatewayErrorsListener(e) {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new TonConnectError(`Bridge error ${JSON.stringify(e)}`);\n        });\n    }\n    updateSession(connectEvent, walletPublicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.session = Object.assign(Object.assign({}, this.session), { walletPublicKey });\n            const tonAddrItem = connectEvent.payload.items.find(item => item.name === 'ton_addr');\n            const connectEventToSave = Object.assign(Object.assign({}, connectEvent), { payload: Object.assign(Object.assign({}, connectEvent.payload), { items: [tonAddrItem] }) });\n            yield this.connectionStorage.storeConnection({\n                type: 'http',\n                session: this.session,\n                lastWalletEventId: connectEvent.id,\n                connectEvent: connectEventToSave,\n                nextRpcRequestId: 0\n            });\n        });\n    }\n    removeBridgeAndSession() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.closeConnection();\n            yield this.connectionStorage.removeConnection();\n        });\n    }\n    generateUniversalLink(universalLink, message, options) {\n        if (isTelegramUrl(universalLink)) {\n            return this.generateTGUniversalLink(universalLink, message, options);\n        }\n        return this.generateRegularUniversalLink(universalLink, message, options);\n    }\n    generateRegularUniversalLink(universalLink, message, options) {\n        const url = new URL(universalLink);\n        url.searchParams.append('v', PROTOCOL_VERSION.toString());\n        url.searchParams.append('id', this.session.sessionCrypto.sessionId);\n        url.searchParams.append('trace_id', options.traceId);\n        url.searchParams.append('r', JSON.stringify(message));\n        return url.toString();\n    }\n    generateTGUniversalLink(universalLink, message, options) {\n        const urlToWrap = this.generateRegularUniversalLink('about:blank', message, options);\n        const linkParams = urlToWrap.split('?')[1];\n        const startapp = 'tonconnect-' + encodeTelegramUrlParameters(linkParams);\n        // TODO: Remove this line after all dApps and the wallets-list.json have been updated\n        const updatedUniversalLink = this.convertToDirectLink(universalLink);\n        const url = new URL(updatedUniversalLink);\n        url.searchParams.append('startapp', startapp);\n        return url.toString();\n    }\n    // TODO: Remove this method after all dApps and the wallets-list.json have been updated\n    convertToDirectLink(universalLink) {\n        const url = new URL(universalLink);\n        if (url.searchParams.has('attach')) {\n            url.searchParams.delete('attach');\n            url.pathname += '/start';\n        }\n        return url.toString();\n    }\n    openGateways(sessionCrypto, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            if (Array.isArray(this.walletConnectionSource)) {\n                // close all gateways before opening new ones\n                this.pendingGateways.map(bridge => bridge.close().catch());\n                // open new gateways\n                this.pendingGateways = this.walletConnectionSource.map(source => {\n                    const gateway = new BridgeGateway(this.connectionStorage.storage, source.bridgeUrl, sessionCrypto.sessionId, () => { }, () => { }, this.analyticsManager);\n                    gateway.setListener(message => this.pendingGatewaysListener(gateway, source.bridgeUrl, message));\n                    return gateway;\n                });\n                // Wait until the specified optional gateways are opened, not necessarily all gateways\n                const gatewaysToWaitFor = Math.max(this.pendingGateways.length - this.optionalOpenGateways, 1);\n                yield waitForSome(this.pendingGateways.map(bridge => callForSuccess((_options) => {\n                    var _a;\n                    if (!this.pendingGateways.some(item => item === bridge)) {\n                        return bridge.close();\n                    }\n                    return bridge.registerSession({\n                        openingDeadlineMS: (_a = options === null || options === void 0 ? void 0 : options.openingDeadlineMS) !== null && _a !== void 0 ? _a : this.defaultOpeningDeadlineMS,\n                        signal: _options.signal,\n                        traceId\n                    });\n                }, {\n                    attempts: Number.MAX_SAFE_INTEGER,\n                    delayMs: this.defaultRetryTimeoutMS,\n                    signal: options === null || options === void 0 ? void 0 : options.signal\n                })), gatewaysToWaitFor);\n                return;\n            }\n            else {\n                if (this.gateway) {\n                    logDebug(`Gateway is already opened, closing previous gateway`);\n                    yield this.gateway.close();\n                }\n                this.gateway = new BridgeGateway(this.connectionStorage.storage, this.walletConnectionSource.bridgeUrl, sessionCrypto.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this), this.analyticsManager);\n                return yield this.gateway.registerSession({\n                    openingDeadlineMS: options === null || options === void 0 ? void 0 : options.openingDeadlineMS,\n                    signal: options === null || options === void 0 ? void 0 : options.signal,\n                    traceId\n                });\n            }\n        });\n    }\n    closeGateways(options) {\n        var _a;\n        (_a = this.gateway) === null || _a === void 0 ? void 0 : _a.close();\n        this.pendingGateways\n            .filter(item => item !== (options === null || options === void 0 ? void 0 : options.except))\n            .forEach(bridge => bridge.close());\n        this.pendingGateways = [];\n    }\n}\n\nfunction hasProperty(value, propertyKey) {\n    return hasProperties(value, [propertyKey]);\n}\nfunction hasProperties(value, propertyKeys) {\n    if (!value || typeof value !== 'object') {\n        return false;\n    }\n    return propertyKeys.every(propertyKey => propertyKey in value);\n}\n\nfunction isJSBridgeWithMetadata(value) {\n    try {\n        if (!hasProperty(value, 'tonconnect') || !hasProperty(value.tonconnect, 'walletInfo')) {\n            return false;\n        }\n        return hasProperties(value.tonconnect.walletInfo, [\n            'name',\n            'app_name',\n            'image',\n            'about_url',\n            'platforms'\n        ]);\n    }\n    catch (_a) {\n        return false;\n    }\n}\n\n/**\n * In memory storage like localStorage, but without persistence.\n * Uses as a fallback for localStorage in Safari's private mode.\n */\nclass InMemoryStorage {\n    static getInstance() {\n        if (!InMemoryStorage.instance) {\n            InMemoryStorage.instance = new InMemoryStorage();\n        }\n        return InMemoryStorage.instance;\n    }\n    constructor() {\n        this.storage = {};\n    }\n    get length() {\n        return Object.keys(this.storage).length;\n    }\n    clear() {\n        this.storage = {};\n    }\n    getItem(key) {\n        var _a;\n        return (_a = this.storage[key]) !== null && _a !== void 0 ? _a : null;\n    }\n    key(index) {\n        var _a;\n        const keys = Object.keys(this.storage);\n        if (index < 0 || index >= keys.length) {\n            return null;\n        }\n        return (_a = keys[index]) !== null && _a !== void 0 ? _a : null;\n    }\n    removeItem(key) {\n        delete this.storage[key];\n    }\n    setItem(key, value) {\n        this.storage[key] = value;\n    }\n}\n\nfunction getWindow() {\n    if (typeof window === 'undefined') {\n        return undefined;\n    }\n    return window;\n}\nfunction getDocument() {\n    if (typeof document === 'undefined') {\n        return undefined;\n    }\n    return document;\n}\nfunction getWebPageManifest() {\n    var _a;\n    const origin = (_a = getWindow()) === null || _a === void 0 ? void 0 : _a.location.origin;\n    if (origin) {\n        return origin + '/tonconnect-manifest.json';\n    }\n    return '';\n}\nfunction getOriginWithPath() {\n    var _a, _b, _c, _d;\n    const origin = (_b = (_a = getWindow()) === null || _a === void 0 ? void 0 : _a.location) === null || _b === void 0 ? void 0 : _b.origin;\n    const path = (_d = (_c = getWindow()) === null || _c === void 0 ? void 0 : _c.location) === null || _d === void 0 ? void 0 : _d.pathname;\n    if (origin && path) {\n        return origin + path;\n    }\n    return '';\n}\n/**\n * Returns `localStorage` if it is available. In Safari's private mode, it returns `InMemoryStorage`. In Node.js, it throws an error.\n */\nfunction tryGetLocalStorage() {\n    if (isLocalStorageAvailable()) {\n        return localStorage;\n    }\n    if (isNodeJs()) {\n        throw new TonConnectError('`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector');\n    }\n    return InMemoryStorage.getInstance();\n}\n/**\n * Checks if `localStorage` is available.\n */\nfunction isLocalStorageAvailable() {\n    // We use a try/catch block because Safari's private mode throws an error when attempting to access localStorage.\n    try {\n        return typeof localStorage !== 'undefined';\n    }\n    catch (_a) {\n        return false;\n    }\n}\n/**\n * Checks if the environment is Node.js.\n */\nfunction isNodeJs() {\n    return (typeof process !== 'undefined' && process.versions != null && process.versions.node != null);\n}\n/**\n * Returns the current domain (hostname) if available.\n * In browser environment, returns window.location.hostname.\n * In Node.js environment or when window is not available, returns null.\n */\nfunction getDomain() {\n    try {\n        // In browser environment\n        if (typeof window !== 'undefined' && window.location) {\n            return window.location.hostname;\n        }\n        else {\n            // In Node.js environment, skip domain validation\n            return null;\n        }\n    }\n    catch (_a) {\n        return null;\n    }\n}\n/**\n * Returns an array of [key, value] pairs from window object if available.\n * In browser environment, returns Object.entries(window).\n * In Node.js environment or when window is not available, returns empty array.\n */\nfunction getWindowEntries() {\n    const window = getWindow();\n    if (!window) {\n        return [];\n    }\n    try {\n        return Object.entries(window);\n    }\n    catch (_a) {\n        return [];\n    }\n}\n\nclass InjectedProvider {\n    static fromStorage(storage, analyticsManager) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield storage.getInjectedConnection();\n            return new InjectedProvider(storage, connection.jsBridgeKey, analyticsManager);\n        });\n    }\n    static isWalletInjected(injectedWalletKey) {\n        return InjectedProvider.isWindowContainsWallet(this.window, injectedWalletKey);\n    }\n    static isInsideWalletBrowser(injectedWalletKey) {\n        if (InjectedProvider.isWindowContainsWallet(this.window, injectedWalletKey)) {\n            return this.window[injectedWalletKey].tonconnect.isWalletBrowser;\n        }\n        return false;\n    }\n    static getCurrentlyInjectedWallets() {\n        if (!this.window) {\n            return [];\n        }\n        const windowEntries = getWindowEntries();\n        const wallets = windowEntries.filter(([_key, value]) => isJSBridgeWithMetadata(value));\n        return wallets.map(([jsBridgeKey, wallet]) => ({\n            name: wallet.tonconnect.walletInfo.name,\n            appName: wallet.tonconnect.walletInfo.app_name,\n            aboutUrl: wallet.tonconnect.walletInfo.about_url,\n            imageUrl: wallet.tonconnect.walletInfo.image,\n            tondns: wallet.tonconnect.walletInfo.tondns,\n            jsBridgeKey,\n            injected: true,\n            embedded: wallet.tonconnect.isWalletBrowser,\n            platforms: wallet.tonconnect.walletInfo.platforms,\n            features: wallet.tonconnect.walletInfo.features\n        }));\n    }\n    static isWindowContainsWallet(window, injectedWalletKey) {\n        return (!!window &&\n            injectedWalletKey in window &&\n            typeof window[injectedWalletKey] === 'object' &&\n            'tonconnect' in window[injectedWalletKey]);\n    }\n    constructor(connectionStorage, injectedWalletKey, analyticsManager) {\n        this.connectionStorage = connectionStorage;\n        this.injectedWalletKey = injectedWalletKey;\n        this.type = 'injected';\n        this.unsubscribeCallback = null;\n        this.listenSubscriptions = false;\n        this.listeners = [];\n        const window = InjectedProvider.window;\n        if (!InjectedProvider.isWindowContainsWallet(window, injectedWalletKey)) {\n            throw new WalletNotInjectedError();\n        }\n        this.injectedWallet = window[injectedWalletKey].tonconnect;\n        if (analyticsManager) {\n            this.analytics = analyticsManager.scoped({\n                bridge_key: injectedWalletKey,\n                wallet_app_name: this.injectedWallet.deviceInfo.appName,\n                wallet_app_version: this.injectedWallet.deviceInfo.appVersion\n            });\n        }\n    }\n    connect(message, options) {\n        this._connect(PROTOCOL_VERSION, message, options);\n    }\n    restoreConnection(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d;\n            const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            try {\n                logDebug(`Injected Provider restoring connection...`);\n                (_b = this.analytics) === null || _b === void 0 ? void 0 : _b.emitJsBridgeCall({\n                    js_bridge_method: 'restoreConnection',\n                    trace_id: traceId\n                });\n                const connectEvent = yield this.injectedWallet.restoreConnection();\n                (_c = this.analytics) === null || _c === void 0 ? void 0 : _c.emitJsBridgeResponse({\n                    js_bridge_method: 'restoreConnection',\n                    trace_id: traceId\n                });\n                logDebug('Injected Provider restoring connection response', connectEvent);\n                if (connectEvent.event === 'connect') {\n                    this.makeSubscriptions({ traceId });\n                    this.listeners.forEach(listener => listener(Object.assign(Object.assign({}, connectEvent), { traceId })));\n                }\n                else {\n                    yield this.connectionStorage.removeConnection();\n                }\n            }\n            catch (e) {\n                (_d = this.analytics) === null || _d === void 0 ? void 0 : _d.emitJsBridgeError({\n                    js_bridge_method: 'restoreConnection',\n                    error_message: String(e),\n                    trace_id: traceId\n                });\n                yield this.connectionStorage.removeConnection();\n                console.error(e);\n            }\n        });\n    }\n    closeConnection() {\n        if (this.listenSubscriptions) {\n            this.injectedWallet.disconnect();\n        }\n        this.closeAllListeners();\n    }\n    disconnect(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            return new Promise(resolve => {\n                const onRequestSent = () => {\n                    this.closeAllListeners();\n                    this.connectionStorage.removeConnection().then(resolve);\n                };\n                try {\n                    this.injectedWallet.disconnect();\n                    onRequestSent();\n                }\n                catch (e) {\n                    logDebug(e);\n                    this.sendRequest({\n                        method: 'disconnect',\n                        params: []\n                    }, { onRequestSent, traceId });\n                }\n            });\n        });\n    }\n    closeAllListeners() {\n        var _a;\n        this.listenSubscriptions = false;\n        this.listeners = [];\n        (_a = this.unsubscribeCallback) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    listen(eventsCallback) {\n        this.listeners.push(eventsCallback);\n        return () => (this.listeners = this.listeners.filter(listener => listener !== eventsCallback));\n    }\n    sendRequest(request, optionsOrOnRequestSent) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            // TODO: remove deprecated method\n            const options = {};\n            if (typeof optionsOrOnRequestSent === 'function') {\n                options.onRequestSent = optionsOrOnRequestSent;\n                options.traceId = UUIDv7();\n            }\n            else {\n                options.onRequestSent = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.onRequestSent;\n                options.signal = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.signal;\n                options.attempts = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.attempts;\n                options.traceId = (_a = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            }\n            const id = (yield this.connectionStorage.getNextRpcRequestId()).toString();\n            yield this.connectionStorage.increaseNextRpcRequestId();\n            logDebug('Send injected-bridge request:', Object.assign(Object.assign({}, request), { id }));\n            (_b = this.analytics) === null || _b === void 0 ? void 0 : _b.emitJsBridgeCall({\n                js_bridge_method: 'send'\n            });\n            const result = this.injectedWallet.send(Object.assign(Object.assign({}, request), { id }));\n            result\n                .then(response => {\n                var _a;\n                (_a = this.analytics) === null || _a === void 0 ? void 0 : _a.emitJsBridgeResponse({\n                    js_bridge_method: 'send'\n                });\n                logDebug('Wallet message received:', response);\n            })\n                .catch(error => {\n                var _a;\n                (_a = this.analytics) === null || _a === void 0 ? void 0 : _a.emitJsBridgeError({\n                    js_bridge_method: 'send',\n                    error_message: String(error)\n                });\n            });\n            (_c = options === null || options === void 0 ? void 0 : options.onRequestSent) === null || _c === void 0 ? void 0 : _c.call(options);\n            return result;\n        });\n    }\n    _connect(protocolVersion, message, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d;\n            const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            try {\n                logDebug(`Injected Provider connect request: protocolVersion: ${protocolVersion}, message:`, message);\n                (_b = this.analytics) === null || _b === void 0 ? void 0 : _b.emitJsBridgeCall({\n                    js_bridge_method: 'connect',\n                    trace_id: traceId\n                });\n                const connectEvent = yield this.injectedWallet.connect(protocolVersion, message);\n                (_c = this.analytics) === null || _c === void 0 ? void 0 : _c.emitJsBridgeResponse({\n                    js_bridge_method: 'connect'\n                });\n                logDebug('Injected Provider connect response:', connectEvent);\n                if (connectEvent.event === 'connect') {\n                    yield this.updateSession();\n                    this.makeSubscriptions({ traceId });\n                }\n                this.listeners.forEach(listener => listener(Object.assign(Object.assign({}, connectEvent), { traceId })));\n            }\n            catch (e) {\n                (_d = this.analytics) === null || _d === void 0 ? void 0 : _d.emitJsBridgeError({\n                    js_bridge_method: 'connect',\n                    error_message: String(e),\n                    trace_id: traceId\n                });\n                logDebug('Injected Provider connect error:', e);\n                const connectEventError = {\n                    event: 'connect_error',\n                    payload: {\n                        code: 0,\n                        message: e === null || e === void 0 ? void 0 : e.toString()\n                    }\n                };\n                this.listeners.forEach(listener => listener(Object.assign(Object.assign({}, connectEventError), { traceId })));\n            }\n        });\n    }\n    makeSubscriptions(options) {\n        var _a, _b, _c;\n        this.listenSubscriptions = true;\n        (_a = this.analytics) === null || _a === void 0 ? void 0 : _a.emitJsBridgeCall({\n            js_bridge_method: 'listen',\n            trace_id: options.traceId\n        });\n        try {\n            this.unsubscribeCallback = this.injectedWallet.listen(e => {\n                var _a;\n                const traceId = (_a = e.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n                logDebug('Wallet message received:', e);\n                if (this.listenSubscriptions) {\n                    this.listeners.forEach(listener => listener(Object.assign(Object.assign({}, e), { traceId })));\n                }\n                if (e.event === 'disconnect') {\n                    this.disconnect({ traceId });\n                }\n            });\n            (_b = this.analytics) === null || _b === void 0 ? void 0 : _b.emitJsBridgeResponse({\n                js_bridge_method: 'listen',\n                trace_id: options.traceId\n            });\n        }\n        catch (err) {\n            (_c = this.analytics) === null || _c === void 0 ? void 0 : _c.emitJsBridgeError({\n                js_bridge_method: 'listen',\n                error_message: String(err),\n                trace_id: options.traceId\n            });\n            throw err;\n        }\n    }\n    updateSession() {\n        return this.connectionStorage.storeConnection({\n            type: 'injected',\n            jsBridgeKey: this.injectedWalletKey,\n            nextRpcRequestId: 0\n        });\n    }\n}\nInjectedProvider.window = getWindow();\n\nclass BridgeConnectionStorage {\n    constructor(storage, walletsListManager) {\n        this.storage = storage;\n        this.walletsListManager = walletsListManager;\n        this.storeKey = 'ton-connect-storage_bridge-connection';\n    }\n    storeConnection(connection) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (connection.type === 'injected' || connection.type === 'wallet-connect') {\n                return this.storage.setItem(this.storeKey, JSON.stringify(connection));\n            }\n            if (!isPendingConnectionHttp(connection)) {\n                const rawSession = {\n                    sessionKeyPair: connection.session.sessionCrypto.stringifyKeypair(),\n                    walletPublicKey: connection.session.walletPublicKey,\n                    bridgeUrl: connection.session.bridgeUrl\n                };\n                const rawConnection = {\n                    type: 'http',\n                    connectEvent: connection.connectEvent,\n                    session: rawSession,\n                    lastWalletEventId: connection.lastWalletEventId,\n                    nextRpcRequestId: connection.nextRpcRequestId\n                };\n                return this.storage.setItem(this.storeKey, JSON.stringify(rawConnection));\n            }\n            const rawConnection = {\n                type: 'http',\n                connectionSource: connection.connectionSource,\n                sessionCrypto: connection.sessionCrypto.stringifyKeypair(),\n                createdAt: Date.now()\n            };\n            return this.storage.setItem(this.storeKey, JSON.stringify(rawConnection));\n        });\n    }\n    removeConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.storage.removeItem(this.storeKey);\n        });\n    }\n    getConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const stored = yield this.storage.getItem(this.storeKey);\n                if (!stored) {\n                    return null;\n                }\n                const connection = JSON.parse(stored);\n                if (connection.type === 'injected' || connection.type === 'wallet-connect') {\n                    return connection;\n                }\n                if (!isPendingConnectionHttpRaw(connection)) {\n                    const sessionCrypto = new _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SessionCrypto(connection.session.sessionKeyPair);\n                    return yield this.actualizeBridgeConnection({\n                        type: 'http',\n                        connectEvent: connection.connectEvent,\n                        lastWalletEventId: connection.lastWalletEventId,\n                        nextRpcRequestId: connection.nextRpcRequestId,\n                        session: {\n                            sessionCrypto,\n                            bridgeUrl: connection.session.bridgeUrl,\n                            walletPublicKey: connection.session.walletPublicKey\n                        }\n                    });\n                }\n                if (isExpiredPendingConnectionHttpRaw(connection)) {\n                    yield this.removeConnection();\n                    return null;\n                }\n                return {\n                    type: 'http',\n                    sessionCrypto: new _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SessionCrypto(connection.sessionCrypto),\n                    connectionSource: connection.connectionSource\n                };\n            }\n            catch (err) {\n                logDebug('Error retrieving connection', err);\n                return null;\n            }\n        });\n    }\n    getHttpConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (!connection) {\n                throw new TonConnectError('Trying to read HTTP connection source while nothing is stored');\n            }\n            if (connection.type !== 'http') {\n                throw new TonConnectError(`Trying to read HTTP connection source while ${connection.type} connection is stored`);\n            }\n            return connection;\n        });\n    }\n    getHttpPendingConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (!connection) {\n                throw new TonConnectError('Trying to read HTTP connection source while nothing is stored');\n            }\n            if (connection.type !== 'http') {\n                throw new TonConnectError(`Trying to read HTTP connection source while ${connection.type} connection is stored`);\n            }\n            if (!isPendingConnectionHttp(connection)) {\n                throw new TonConnectError('Trying to read HTTP-pending connection while http connection is stored');\n            }\n            return connection;\n        });\n    }\n    getInjectedConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (!connection) {\n                throw new TonConnectError('Trying to read Injected bridge connection source while nothing is stored');\n            }\n            if ((connection === null || connection === void 0 ? void 0 : connection.type) !== 'injected') {\n                throw new TonConnectError(`Trying to read Injected bridge connection source while ${connection.type} connection is stored`);\n            }\n            return connection;\n        });\n    }\n    getWalletConnectConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (!connection) {\n                throw new TonConnectError('Trying to read wallet connect bridge connection source while nothing is stored');\n            }\n            if ((connection === null || connection === void 0 ? void 0 : connection.type) !== 'wallet-connect') {\n                throw new TonConnectError(`Trying to read wallet connect bridge connection source while ${connection.type} connection is stored`);\n            }\n            return connection;\n        });\n    }\n    storedConnectionType() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const stored = yield this.storage.getItem(this.storeKey);\n            if (!stored) {\n                return null;\n            }\n            const connection = JSON.parse(stored);\n            return connection.type;\n        });\n    }\n    storeLastWalletEventId(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (connection && connection.type === 'http' && !isPendingConnectionHttp(connection)) {\n                connection.lastWalletEventId = id;\n                return this.storeConnection(connection);\n            }\n        });\n    }\n    getLastWalletEventId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (connection && 'lastWalletEventId' in connection) {\n                return connection.lastWalletEventId;\n            }\n            return undefined;\n        });\n    }\n    increaseNextRpcRequestId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (connection && 'nextRpcRequestId' in connection) {\n                const lastId = connection.nextRpcRequestId || 0;\n                connection.nextRpcRequestId = lastId + 1;\n                return this.storeConnection(connection);\n            }\n        });\n    }\n    getNextRpcRequestId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (connection && 'nextRpcRequestId' in connection) {\n                return connection.nextRpcRequestId || 0;\n            }\n            return 0;\n        });\n    }\n    actualizeBridgeConnection(connection) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const appName = connection.connectEvent.payload.device.appName;\n                const wallet = yield this.walletsListManager.getRemoteWallet(appName);\n                if (wallet.bridgeUrl === connection.session.bridgeUrl) {\n                    return connection;\n                }\n                const actualizedConnection = Object.assign(Object.assign({}, connection), { session: Object.assign(Object.assign({}, connection.session), { bridgeUrl: wallet.bridgeUrl }) });\n                yield this.storeConnection(actualizedConnection);\n                return actualizedConnection;\n            }\n            catch (error) {\n                logDebug('Failed to actualize bridge connection', error);\n                return connection;\n            }\n        });\n    }\n}\n\n/**\n * Default storage to save protocol data, uses `localStorage` if it is available. In Safari's private mode, it uses `InMemoryStorage`. In Node.js, it throws an error.\n */\nclass DefaultStorage {\n    constructor() {\n        this.localStorage = tryGetLocalStorage();\n    }\n    getItem(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.localStorage.getItem(key);\n        });\n    }\n    removeItem(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.localStorage.removeItem(key);\n        });\n    }\n    setItem(key, value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.localStorage.setItem(key, value);\n        });\n    }\n}\n\n/**\n * Checks if `WalletInfo` is `WalletInfoInjectable` and `WalletInfo` is injected to the current webpage (`walletInfo.injected === true`).\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoCurrentlyInjected(value) {\n    return isWalletInfoInjectable(value) && value.injected;\n}\n/**\n * Checks if `WalletInfo` is `WalletInfoInjectable` and dApp is opened inside this wallet's browser.\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoCurrentlyEmbedded(value) {\n    return isWalletInfoCurrentlyInjected(value) && value.embedded;\n}\n/**\n * Checks if `WalletInfo` is `WalletInfoInjected`, but doesn't check if it is injected to the page or not.\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoInjectable(value) {\n    return 'jsBridgeKey' in value;\n}\n/**\n * Checks if `WalletInfo` is `WalletInfoRemote`.\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoRemote(value) {\n    return 'bridgeUrl' in value;\n}\n/**\n * @deprecated use `isWalletInfoInjectable` or `isWalletInfoCurrentlyInjected` instead.\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoInjected(value) {\n    return 'jsBridgeKey' in value;\n}\n\nconst FALLBACK_WALLETS_LIST = [\n    {\n        app_name: 'telegram-wallet',\n        name: 'Wallet',\n        image: 'https://wallet.tg/images/logo-288.png',\n        about_url: 'https://wallet.tg/',\n        universal_url: 'https://t.me/wallet?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://walletbot.me/tonconnect-bridge/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: true\n            },\n            {\n                name: 'SignData',\n                types: ['text', 'binary', 'cell']\n            }\n        ]\n    },\n    {\n        app_name: 'tonkeeper',\n        name: 'Tonkeeper',\n        image: 'https://tonkeeper.com/assets/tonconnect-icon.png',\n        tondns: 'tonkeeper.ton',\n        about_url: 'https://tonkeeper.com',\n        universal_url: 'https://app.tonkeeper.com/ton-connect',\n        deepLink: 'tonkeeper-tc://',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://bridge.tonapi.io/bridge'\n            },\n            {\n                type: 'js',\n                key: 'tonkeeper'\n            }\n        ],\n        platforms: ['ios', 'android', 'chrome', 'firefox', 'macos'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: true\n            },\n            {\n                name: 'SignData',\n                types: ['text', 'binary', 'cell']\n            }\n        ]\n    },\n    {\n        app_name: 'mytonwallet',\n        name: 'MyTonWallet',\n        image: 'https://static.mytonwallet.io/icon-256.png',\n        about_url: 'https://mytonwallet.io',\n        universal_url: 'https://connect.mytonwallet.org',\n        deepLink: 'mytonwallet-tc://',\n        bridge: [\n            {\n                type: 'js',\n                key: 'mytonwallet'\n            },\n            {\n                type: 'sse',\n                url: 'https://tonconnectbridge.mytonwallet.org/bridge/'\n            }\n        ],\n        platforms: ['chrome', 'windows', 'macos', 'linux', 'ios', 'android', 'firefox'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: false\n            },\n            {\n                name: 'SignData',\n                types: ['text', 'binary', 'cell']\n            }\n        ]\n    },\n    {\n        app_name: 'tonhub',\n        name: 'Tonhub',\n        image: 'https://tonhub.com/tonconnect_logo.png',\n        about_url: 'https://tonhub.com',\n        universal_url: 'https://tonhub.com/ton-connect',\n        bridge: [\n            {\n                type: 'js',\n                key: 'tonhub'\n            },\n            {\n                type: 'sse',\n                url: 'https://connect.tonhubapi.com/tonconnect'\n            }\n        ],\n        platforms: ['ios', 'android'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: true\n            },\n            {\n                name: 'SignData',\n                types: ['text', 'binary', 'cell']\n            }\n        ]\n    },\n    {\n        app_name: 'bitgetTonWallet',\n        name: 'Bitget Wallet',\n        image: 'https://raw.githubusercontent.com/bitgetwallet/download/refs/heads/main/logo/png/bitget_wallet_logo_288_mini.png',\n        about_url: 'https://web3.bitget.com',\n        deepLink: 'bitkeep://',\n        bridge: [\n            {\n                type: 'js',\n                key: 'bitgetTonWallet'\n            },\n            {\n                type: 'sse',\n                url: 'https://ton-connect-bridge.bgwapi.io/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'chrome'],\n        universal_url: 'https://bkcode.vip/ton-connect',\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'okxMiniWallet',\n        name: 'OKX Mini Wallet',\n        image: 'https://static.okx.com/cdn/assets/imgs/2411/8BE1A4A434D8F58A.png',\n        about_url: 'https://www.okx.com/web3',\n        universal_url: 'https://t.me/OKX_WALLET_BOT?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://www.okx.com/tonbridge/discover/rpc/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'binanceWeb3TonWallet',\n        name: 'Binance Wallet',\n        image: 'https://public.bnbstatic.com/static/binance-w3w/ton-provider/binancew3w.png',\n        about_url: 'https://www.binance.com/en/web3wallet',\n        deepLink: 'bnc://app.binance.com/cedefi/ton-connect',\n        bridge: [\n            {\n                type: 'js',\n                key: 'binancew3w'\n            },\n            {\n                type: 'sse',\n                url: 'https://wallet.binance.com/tonbridge/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        universal_url: 'https://app.binance.com/cedefi/ton-connect',\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'fintopio-tg',\n        name: 'Fintopio',\n        image: 'https://raw.githubusercontent.com/fintopio/ton-pub/refs/heads/main/logos/tonconnect-icon.png',\n        about_url: 'https://fintopio.com',\n        universal_url: 'https://t.me/fintopio?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://wallet-bridge.fintopio.com/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'okxTonWallet',\n        name: 'OKX Wallet',\n        image: 'https://static.okx.com/cdn/assets/imgs/247/58E63FEA47A2B7D7.png',\n        about_url: 'https://www.okx.com/web3',\n        universal_url: 'https://www.okx.com/download?appendQuery=true&deeplink=okx://web3/wallet/tonconnect',\n        bridge: [\n            {\n                type: 'js',\n                key: 'okxTonWallet'\n            },\n            {\n                type: 'sse',\n                url: 'https://www.okx.com/tonbridge/discover/rpc/bridge'\n            }\n        ],\n        platforms: ['chrome', 'safari', 'firefox', 'ios', 'android'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'hot',\n        name: 'HOT',\n        image: 'https://raw.githubusercontent.com/hot-dao/media/main/logo.png',\n        about_url: 'https://hot-labs.org/',\n        universal_url: 'https://t.me/herewalletbot?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://sse-bridge.hot-labs.org'\n            },\n            {\n                type: 'js',\n                key: 'hotWallet'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'bybitTonWallet',\n        name: 'Bybit Wallet',\n        image: 'https://raw.githubusercontent.com/bybit-web3/bybit-web3.github.io/main/docs/images/bybit-logo.png',\n        about_url: 'https://www.bybit.com/web3',\n        universal_url: 'https://app.bybit.com/ton-connect',\n        deepLink: 'bybitapp://',\n        bridge: [\n            {\n                type: 'js',\n                key: 'bybitTonWallet'\n            },\n            {\n                type: 'sse',\n                url: 'https://api-node.bybit.com/spot/api/web3/bridge/ton/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'chrome'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'dewallet',\n        name: 'DeWallet',\n        image: 'https://raw.githubusercontent.com/delab-team/manifests-images/main/WalletAvatar.png',\n        about_url: 'https://delabwallet.com',\n        universal_url: 'https://t.me/dewallet?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://bridge.dewallet.pro/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'safepalwallet',\n        name: 'SafePal',\n        image: 'https://s.pvcliping.com/web/public_image/SafePal_x288.png',\n        tondns: '',\n        about_url: 'https://www.safepal.com',\n        universal_url: 'https://link.safepal.io/ton-connect',\n        deepLink: 'safepal-tc://',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://ton-bridge.safepal.com/tonbridge/v1/bridge'\n            },\n            {\n                type: 'js',\n                key: 'safepalwallet'\n            }\n        ],\n        platforms: ['ios', 'android', 'chrome', 'firefox'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 1,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'GateWallet',\n        name: 'GateWallet',\n        image: 'https://img.gatedataimg.com/prd-ordinal-imgs/036f07bb8730716e/gateio-0925.png',\n        about_url: 'https://www.gate.io/',\n        bridge: [\n            {\n                type: 'js',\n                key: 'gatetonwallet'\n            },\n            {\n                type: 'sse',\n                url: 'https://dapp.gateio.services/tonbridge_api/bridge/v1'\n            }\n        ],\n        platforms: ['ios', 'android'],\n        universal_url: 'https://gate.onelink.me/Hls0/web3?gate_web3_wallet_universal_type=ton_connect',\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'openmask',\n        name: 'OpenMask',\n        image: 'https://raw.githubusercontent.com/OpenProduct/openmask-extension/main/public/openmask-logo-288.png',\n        about_url: 'https://www.openmask.app/',\n        bridge: [\n            {\n                type: 'js',\n                key: 'openmask'\n            }\n        ],\n        platforms: ['chrome'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'BitgetWeb3',\n        name: 'BitgetWeb3',\n        image: 'https://img.bitgetimg.com/image/third/1731638059795.png',\n        about_url: 'https://www.bitget.com',\n        universal_url: 'https://t.me/BitgetOfficialBot?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://ton-connect-bridge.bgwapi.io/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'windows', 'macos', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'xtonwallet',\n        name: 'XTONWallet',\n        image: 'https://xtonwallet.com/assets/img/icon-256-back.png',\n        about_url: 'https://xtonwallet.com',\n        bridge: [\n            {\n                type: 'js',\n                key: 'xtonwallet'\n            }\n        ],\n        platforms: ['chrome', 'firefox'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 1,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'tonwallet',\n        name: 'TON Wallet',\n        image: 'https://wallet.ton.org/assets/ui/qr-logo.png',\n        about_url: 'https://chrome.google.com/webstore/detail/ton-wallet/nphplpgoakhhjchkkhmiggakijnkhfnd',\n        bridge: [\n            {\n                type: 'js',\n                key: 'tonwallet'\n            }\n        ],\n        platforms: ['chrome'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'bitgetWalletLite',\n        name: 'Bitget Wallet Lite',\n        image: 'https://raw.githubusercontent.com/bitgetwallet/download/refs/heads/main/logo/png/bitget_wallet_lite_logo_288.png',\n        about_url: 'https://web3.bitget.com',\n        universal_url: 'https://t.me/BitgetWallet_TGBot?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://ton-connect-bridge.bgwapi.io/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'tomoWallet',\n        name: 'Tomo Wallet',\n        image: 'https://pub.tomo.inc/logo.png',\n        about_url: 'https://www.tomo.inc/',\n        universal_url: 'https://t.me/tomowalletbot?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://go-bridge.tomo.inc/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'miraiapp-tg',\n        name: 'Mirai Mini App',\n        image: 'https://cdn.mirailabs.co/miraihub/miraiapp-tg-icon-288.png',\n        about_url: 'https://mirai.app',\n        universal_url: 'https://t.me/MiraiAppBot?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://bridge.mirai.app'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: false\n            },\n            {\n                name: 'SignData',\n                types: ['text', 'binary', 'cell']\n            }\n        ]\n    },\n    {\n        app_name: 'Architec.ton',\n        name: 'Architec.ton',\n        image: 'https://raw.githubusercontent.com/Architec-Ton/wallet-tma/refs/heads/dev/public/images/arcwallet_logo.png',\n        about_url: 'https://architecton.tech',\n        universal_url: 'https://t.me/architec_ton_bot?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://tc.architecton.su/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'tokenpocket',\n        name: 'TokenPocket',\n        image: 'https://hk.tpstatic.net/logo/tokenpocket.png',\n        about_url: 'https://www.tokenpocket.pro',\n        universal_url: 'https://tp-lab.tptool.pro/ton-connect/',\n        bridge: [\n            {\n                type: 'js',\n                key: 'tokenpocket'\n            },\n            {\n                type: 'sse',\n                url: 'https://ton-connect.mytokenpocket.vip/bridge'\n            }\n        ],\n        platforms: ['ios', 'android'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'uxuyWallet',\n        name: 'UXUY Wallet',\n        image: 'https://chain-cdn.uxuy.com/logo/square_288.png',\n        about_url: 'https://docs.uxuy.com',\n        universal_url: 'https://t.me/UXUYbot?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://bridge.uxuy.me/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'tonkeeper-pro',\n        name: 'Tonkeeper Pro',\n        image: 'https://tonkeeper.com/assets/tonconnect-icon-pro.png',\n        tondns: 'tonkeeper.ton',\n        about_url: 'https://tonkeeper.com/pro',\n        universal_url: 'https://app.tonkeeper.com/pro/ton-connect',\n        deepLink: 'tonkeeper-pro-tc://',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://bridge.tonapi.io/bridge'\n            }\n        ],\n        platforms: ['ios', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: true\n            },\n            {\n                name: 'SignData',\n                types: ['text', 'binary', 'cell']\n            }\n        ]\n    },\n    {\n        app_name: 'nicegramWallet',\n        name: 'Nicegram Wallet',\n        image: 'https://static.nicegram.app/icon.png',\n        about_url: 'https://nicegram.app',\n        universal_url: 'https://nicegram.app/tc',\n        deepLink: 'nicegram-tc://',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://tc.nicegram.app/bridge'\n            },\n            {\n                type: 'js',\n                key: 'nicegramWallet'\n            }\n        ],\n        platforms: ['ios', 'android'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'echoooTonWallet',\n        name: 'EchoooWallet',\n        image: 'https://cdn.echooo.xyz/front-end/source/images/logo/echooo-ton.png',\n        about_url: 'https://www.echooo.xyz',\n        universal_url: 'https://www.echooo.xyz/ton-connect',\n        deepLink: 'echooo://',\n        bridge: [\n            {\n                type: 'js',\n                key: 'echoooTonWallet'\n            },\n            {\n                type: 'sse',\n                url: 'https://ton-connect-bridge.echooo.link/bridge'\n            }\n        ],\n        platforms: ['ios', 'android'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'blitzwallet',\n        name: 'BLITZ wallet',\n        image: 'https://blitzwallet.cfd/wallet/public/logo.png',\n        about_url: 'https://blitzwallet.cfd',\n        universal_url: 'https://t.me/blitz_wallet_bot?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://blitzwallet.cfd/bridge/'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'koloWeb3Wallet',\n        name: 'Kolo',\n        image: 'https://raw.githubusercontent.com/onidev1/tc-assets/refs/heads/main/kolo_logo_288.png',\n        about_url: 'https://kolo.xyz',\n        universal_url: 'https://t.me/kolo?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://web3-bridge.kolo.in/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'imToken',\n        name: 'imToken',\n        image: 'https://aws-v2-cdn.token.im/orbit/token-v2/icons/logo-ton-connect.png',\n        about_url: 'https://token.im',\n        universal_url: 'https://connect.token.im/link/ton-connect',\n        deepLink: 'imtokenv2://link/ton-connect',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://connect.token.im/tonbridge'\n            },\n            {\n                type: 'js',\n                key: 'imToken'\n            }\n        ],\n        platforms: ['ios', 'android'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 255,\n                extraCurrencySupported: false\n            }\n        ]\n    },\n    {\n        app_name: 'cactuslink',\n        name: 'Cactus Link',\n        image: 'https://downloads.mycactus.com/288_cactus_link.png',\n        about_url: 'https://www.mycactus.com/defi-connector',\n        bridge: [\n            {\n                type: 'js',\n                key: 'cactuslink_ton'\n            }\n        ],\n        platforms: ['chrome'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            },\n            {\n                name: 'SignData',\n                types: ['text', 'binary']\n            }\n        ]\n    },\n    {\n        app_name: 'onekey',\n        name: 'OneKey',\n        image: 'https://uni.onekey-asset.com/static/logo/onekey-x288.png',\n        about_url: 'https://onekey.so',\n        bridge: [\n            {\n                type: 'js',\n                key: 'onekeyTonWallet'\n            }\n        ],\n        platforms: ['chrome'],\n        features: [\n            {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            }\n        ]\n    }\n];\n\nlet qaModeEnabled = false;\nlet bannerObserver = null;\nfunction enableQaMode() {\n    qaModeEnabled = true;\n    console.warn(' QA Mode enabled - validation is disabled. This is unsafe for production!');\n    showQaModeBanner();\n    startBannerObserver();\n    addQaModeStyles();\n}\nfunction isQaModeEnabled() {\n    return qaModeEnabled;\n}\nfunction showQaModeBanner() {\n    if (typeof window === 'undefined')\n        return;\n    const existingBanner = document.getElementById('ton-connect-qa-banner');\n    if (existingBanner)\n        return;\n    const banner = document.createElement('div');\n    banner.id = 'ton-connect-qa-banner';\n    banner.style.cssText = `\n        position: fixed;\n        top: 0;\n        left: 0;\n        right: 0;\n        background: linear-gradient(90deg, #ff6b6b, #ff8e8e);\n        color: white;\n        padding: 12px 20px;\n        text-align: center;\n        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n        font-weight: 600;\n        font-size: 14px;\n        z-index: 999999;\n        box-shadow: 0 2px 8px rgba(0,0,0,0.2);\n        animation: slideDown 0.3s ease-out;\n        user-select: none;\n        pointer-events: none;\n    `;\n    banner.innerHTML = `\n         QA Mode Active - Validation Disabled (Unsafe for Production)\n    `;\n    // Add CSS animation\n    const style = document.createElement('style');\n    style.textContent = `\n        @keyframes slideDown {\n            from { transform: translateY(-100%); }\n            to { transform: translateY(0); }\n        }\n    `;\n    document.head.appendChild(style);\n    document.body.appendChild(banner);\n    addQaModeStyles();\n}\nfunction addQaModeStyles() {\n    if (typeof window === 'undefined')\n        return;\n    const existingStyle = document.getElementById('ton-connect-qa-mode-styles');\n    if (existingStyle)\n        return;\n    const style = document.createElement('style');\n    style.id = 'ton-connect-qa-mode-styles';\n    style.textContent = `\n        body.qa-mode-active {\n            padding-top: 48px !important;\n        }\n        \n        body.qa-mode-active header {\n            margin-top: 48px !important;\n        }\n        \n        body.qa-mode-active .qa-mode-control {\n            top: 128px !important;\n        }\n    `;\n    document.head.appendChild(style);\n    document.body.classList.add('qa-mode-active');\n}\nfunction startBannerObserver() {\n    if (typeof window === 'undefined' || bannerObserver)\n        return;\n    bannerObserver = new MutationObserver(mutations => {\n        mutations.forEach(mutation => {\n            if (mutation.type === 'childList') {\n                mutation.removedNodes.forEach(node => {\n                    if (node.nodeType === Node.ELEMENT_NODE) {\n                        const element = node;\n                        if (element.id === 'ton-connect-qa-banner' && qaModeEnabled) {\n                            console.warn('QA Mode banner was removed, restoring...');\n                            setTimeout(() => showQaModeBanner(), 100);\n                        }\n                        else if (element.id === 'ton-connect-qa-mode-styles' && qaModeEnabled) {\n                            console.warn('QA Mode styles were removed, restoring...');\n                            setTimeout(() => addQaModeStyles(), 100);\n                        }\n                    }\n                });\n            }\n        });\n    });\n    bannerObserver.observe(document.body, {\n        childList: true,\n        subtree: false\n    });\n    bannerObserver.observe(document.head, {\n        childList: true,\n        subtree: false\n    });\n}\n\nclass WalletsListManager {\n    constructor(options) {\n        var _a;\n        this.walletsListDTOCache = null;\n        this.walletsListDTOCacheCreationTimestamp = null;\n        if (isQaModeEnabled()) {\n            this.walletsListSource =\n                'https://raw.githubusercontent.com/ton-connect/wallets-list-staging/refs/heads/main/wallets-v2.json';\n        }\n        else {\n            this.walletsListSource =\n                (_a = options === null || options === void 0 ? void 0 : options.walletsListSource) !== null && _a !== void 0 ? _a : 'https://config.ton.org/wallets-v2.json';\n        }\n        this.cacheTTLMs = options === null || options === void 0 ? void 0 : options.cacheTTLMs;\n        this.onDownloadDurationMeasured = options === null || options === void 0 ? void 0 : options.onDownloadDurationMeasured;\n    }\n    getWallets() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const [walletsListDTO, currentlyInjectedWallets] = yield Promise.all([\n                this.fetchWalletsListDTO(),\n                this.getCurrentlyInjectedWallets()\n            ]);\n            return this.mergeWalletsLists(this.walletConfigDTOListToWalletConfigList(walletsListDTO), currentlyInjectedWallets);\n        });\n    }\n    getEmbeddedWallet() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const walletsList = yield this.getWallets();\n            const embeddedWallets = walletsList.filter(isWalletInfoCurrentlyEmbedded);\n            return embeddedWallets.length === 1 ? embeddedWallets[0] : null;\n        });\n    }\n    fetchWalletsListDTO() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.cacheTTLMs &&\n                this.walletsListDTOCacheCreationTimestamp &&\n                Date.now() > this.walletsListDTOCacheCreationTimestamp + this.cacheTTLMs) {\n                this.walletsListDTOCache = null;\n            }\n            if (!this.walletsListDTOCache) {\n                this.walletsListDTOCache = this.fetchWalletsListFromSource();\n                this.walletsListDTOCache\n                    .then(() => {\n                    this.walletsListDTOCacheCreationTimestamp = Date.now();\n                })\n                    .catch(() => {\n                    this.walletsListDTOCache = null;\n                    this.walletsListDTOCacheCreationTimestamp = null;\n                });\n            }\n            return this.walletsListDTOCache;\n        });\n    }\n    getRemoteWallet(appName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const walletsList = yield this.getWallets();\n            const wallet = walletsList.find(wallet => wallet.appName === appName);\n            if (!wallet) {\n                throw new TonConnectError(`Wallet info not found for appName: \"${appName}\"`);\n            }\n            if (!isWalletInfoRemote(wallet)) {\n                throw new TonConnectError(`Wallet \"${appName}\" is not remote`);\n            }\n            return wallet;\n        });\n    }\n    fetchWalletsListFromSource() {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            let walletsList = [];\n            const startTime = performance.now();\n            try {\n                const walletsResponse = yield fetch(this.walletsListSource);\n                walletsList = yield walletsResponse.json();\n                if (!Array.isArray(walletsList)) {\n                    throw new FetchWalletsError('Wrong wallets list format, wallets list must be an array.');\n                }\n                const wrongFormatWallets = walletsList.filter(wallet => !this.isCorrectWalletConfigDTO(wallet));\n                if (wrongFormatWallets.length) {\n                    logError(`Wallet(s) ${wrongFormatWallets\n                        .map(wallet => (wallet === null || wallet === void 0 ? void 0 : wallet.name) || 'unknown')\n                        .join(', ')} config format is wrong. They were removed from the wallets list.`);\n                    walletsList = walletsList.filter(wallet => this.isCorrectWalletConfigDTO(wallet));\n                }\n                const endTime = performance.now();\n                const duration = Math.round(endTime - startTime);\n                (_a = this.onDownloadDurationMeasured) === null || _a === void 0 ? void 0 : _a.call(this, duration);\n            }\n            catch (e) {\n                logError(e);\n                walletsList = FALLBACK_WALLETS_LIST;\n                (_b = this.onDownloadDurationMeasured) === null || _b === void 0 ? void 0 : _b.call(this, undefined);\n            }\n            return walletsList;\n        });\n    }\n    getCurrentlyInjectedWallets() {\n        if (!isQaModeEnabled()) {\n            return [];\n        }\n        try {\n            return InjectedProvider.getCurrentlyInjectedWallets();\n        }\n        catch (e) {\n            logError(e);\n            return [];\n        }\n    }\n    walletConfigDTOListToWalletConfigList(walletConfigDTO) {\n        return walletConfigDTO.map(walletConfigDTO => {\n            const walletConfig = {\n                name: walletConfigDTO.name,\n                appName: walletConfigDTO.app_name,\n                imageUrl: walletConfigDTO.image,\n                aboutUrl: walletConfigDTO.about_url,\n                tondns: walletConfigDTO.tondns,\n                platforms: walletConfigDTO.platforms,\n                features: walletConfigDTO.features\n            };\n            walletConfigDTO.bridge.forEach(bridge => {\n                if (bridge.type === 'sse') {\n                    walletConfig.bridgeUrl = bridge.url;\n                    walletConfig.universalLink =\n                        walletConfigDTO.universal_url;\n                    walletConfig.deepLink = walletConfigDTO.deepLink;\n                }\n                if (bridge.type === 'js') {\n                    const jsBridgeKey = bridge.key;\n                    walletConfig.jsBridgeKey = jsBridgeKey;\n                    walletConfig.injected =\n                        InjectedProvider.isWalletInjected(jsBridgeKey);\n                    walletConfig.embedded =\n                        InjectedProvider.isInsideWalletBrowser(jsBridgeKey);\n                }\n            });\n            return walletConfig;\n        });\n    }\n    mergeWalletsLists(list1, list2) {\n        const names = new Set(list1.concat(list2).map(item => item.name));\n        return [...names.values()].map(name => {\n            const list1Item = list1.find(item => item.name === name);\n            const list2Item = list2.find(item => item.name === name);\n            return Object.assign(Object.assign({}, (list1Item && Object.assign({}, list1Item))), (list2Item && Object.assign({}, list2Item)));\n        });\n    }\n    // eslint-disable-next-line complexity\n    isCorrectWalletConfigDTO(value) {\n        if (!value || !(typeof value === 'object')) {\n            return false;\n        }\n        const containsName = 'name' in value;\n        const containsAppName = 'app_name' in value;\n        const containsImage = 'image' in value;\n        const containsAbout = 'about_url' in value;\n        const containsPlatforms = 'platforms' in value;\n        if (!containsName ||\n            !containsImage ||\n            !containsAbout ||\n            !containsPlatforms ||\n            !containsAppName) {\n            return false;\n        }\n        if (!value.platforms ||\n            !Array.isArray(value.platforms) ||\n            !value.platforms.length) {\n            return false;\n        }\n        if (!('bridge' in value) ||\n            !Array.isArray(value.bridge) ||\n            !value.bridge.length) {\n            return false;\n        }\n        const bridge = value.bridge;\n        if (bridge.some(item => !item || typeof item !== 'object' || !('type' in item))) {\n            return false;\n        }\n        const sseBridge = bridge.find(item => item.type === 'sse');\n        if (sseBridge) {\n            if (!(typeof sseBridge === 'object' && 'url' in sseBridge) ||\n                !sseBridge.url ||\n                !value.universal_url) {\n                return false;\n            }\n        }\n        const jsBridge = bridge.find(item => item.type === 'js');\n        if (jsBridge) {\n            if (typeof jsBridge !== 'object' ||\n                !('key' in jsBridge) ||\n                !jsBridge.key) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\nfunction checkSendTransactionSupport(features, options) {\n    const supportsDeprecatedSendTransactionFeature = features.includes('SendTransaction');\n    const sendTransactionFeature = findFeature(features, 'SendTransaction');\n    const requiredFeature = {\n        minMessages: options.requiredMessagesNumber,\n        extraCurrencyRequired: options.requireExtraCurrencies\n    };\n    if (!supportsDeprecatedSendTransactionFeature && !sendTransactionFeature) {\n        throw new WalletNotSupportFeatureError(\"Wallet doesn't support SendTransaction feature.\", {\n            cause: { requiredFeature: { featureName: 'SendTransaction', value: requiredFeature } }\n        });\n    }\n    if (options.requireExtraCurrencies) {\n        if (!sendTransactionFeature || !sendTransactionFeature.extraCurrencySupported) {\n            throw new WalletNotSupportFeatureError(`Wallet is not able to handle such SendTransaction request. Extra currencies support is required.`, {\n                cause: {\n                    requiredFeature: { featureName: 'SendTransaction', value: requiredFeature }\n                }\n            });\n        }\n    }\n    if (sendTransactionFeature && sendTransactionFeature.maxMessages !== undefined) {\n        if (sendTransactionFeature.maxMessages < options.requiredMessagesNumber) {\n            throw new WalletNotSupportFeatureError(`Wallet is not able to handle such SendTransaction request. Max support messages number is ${sendTransactionFeature.maxMessages}, but ${options.requiredMessagesNumber} is required.`, {\n                cause: {\n                    requiredFeature: { featureName: 'SendTransaction', value: requiredFeature }\n                }\n            });\n        }\n        return;\n    }\n    logWarning(\"Connected wallet didn't provide information about max allowed messages in the SendTransaction request. Request may be rejected by the wallet.\");\n}\nfunction checkSignDataSupport(features, options) {\n    const signDataFeature = features.find(feature => feature && typeof feature === 'object' && feature.name === 'SignData');\n    if (!signDataFeature) {\n        throw new WalletNotSupportFeatureError(\"Wallet doesn't support SignData feature.\", {\n            cause: {\n                requiredFeature: {\n                    featureName: 'SignData',\n                    value: { types: options.requiredTypes }\n                }\n            }\n        });\n    }\n    const unsupportedTypes = options.requiredTypes.filter(requiredType => !signDataFeature.types.includes(requiredType));\n    if (unsupportedTypes.length) {\n        throw new WalletNotSupportFeatureError(`Wallet doesn't support required SignData types: ${unsupportedTypes.join(', ')}.`, {\n            cause: {\n                requiredFeature: { featureName: 'SignData', value: { types: unsupportedTypes } }\n            }\n        });\n    }\n}\nfunction checkRequiredWalletFeatures(features, walletsRequiredFeatures) {\n    if (typeof walletsRequiredFeatures !== 'object') {\n        return true;\n    }\n    const { sendTransaction, signData } = walletsRequiredFeatures;\n    if (sendTransaction) {\n        const feature = findFeature(features, 'SendTransaction');\n        if (!feature) {\n            return false;\n        }\n        if (!checkSendTransaction(feature, sendTransaction)) {\n            return false;\n        }\n    }\n    if (signData) {\n        const feature = findFeature(features, 'SignData');\n        if (!feature) {\n            return false;\n        }\n        if (!checkSignData(feature, signData)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction findFeature(features, requiredFeatureName) {\n    return features.find(f => f && typeof f === 'object' && f.name === requiredFeatureName);\n}\nfunction checkSendTransaction(feature, requiredFeature) {\n    const correctMessagesNumber = requiredFeature.minMessages === undefined ||\n        requiredFeature.minMessages <= feature.maxMessages;\n    const correctExtraCurrency = !requiredFeature.extraCurrencyRequired || feature.extraCurrencySupported;\n    return !!(correctMessagesNumber && correctExtraCurrency);\n}\nfunction checkSignData(feature, requiredFeature) {\n    return requiredFeature.types.every(requiredType => feature.types.includes(requiredType));\n}\n\n/**\n * Create a request version event.\n */\nfunction createRequestVersionEvent() {\n    return {\n        type: 'request-version'\n    };\n}\n/**\n * Create a response version event.\n * @param version\n */\nfunction createResponseVersionEvent(version) {\n    return {\n        type: 'response-version',\n        version: version\n    };\n}\n/**\n * Create a version info.\n * @param version\n */\nfunction createVersionInfo(version) {\n    return {\n        ton_connect_sdk_lib: version.ton_connect_sdk_lib,\n        ton_connect_ui_lib: version.ton_connect_ui_lib\n    };\n}\n// eslint-disable-next-line complexity\nfunction createConnectionInfo(version, wallet, sessionInfo) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n    const isTonProof = ((_a = wallet === null || wallet === void 0 ? void 0 : wallet.connectItems) === null || _a === void 0 ? void 0 : _a.tonProof) && 'proof' in wallet.connectItems.tonProof;\n    const authType = isTonProof ? 'ton_proof' : 'ton_addr';\n    return {\n        wallet_address: (_c = (_b = wallet === null || wallet === void 0 ? void 0 : wallet.account) === null || _b === void 0 ? void 0 : _b.address) !== null && _c !== void 0 ? _c : null,\n        wallet_state_init: (_d = wallet === null || wallet === void 0 ? void 0 : wallet.account.walletStateInit) !== null && _d !== void 0 ? _d : null,\n        wallet_type: (_e = wallet === null || wallet === void 0 ? void 0 : wallet.device.appName) !== null && _e !== void 0 ? _e : null,\n        wallet_version: (_f = wallet === null || wallet === void 0 ? void 0 : wallet.device.appVersion) !== null && _f !== void 0 ? _f : null,\n        auth_type: authType,\n        custom_data: Object.assign({ client_id: (_g = sessionInfo === null || sessionInfo === void 0 ? void 0 : sessionInfo.clientId) !== null && _g !== void 0 ? _g : null, wallet_id: (_h = sessionInfo === null || sessionInfo === void 0 ? void 0 : sessionInfo.walletId) !== null && _h !== void 0 ? _h : null, chain_id: (_k = (_j = wallet === null || wallet === void 0 ? void 0 : wallet.account) === null || _j === void 0 ? void 0 : _j.chain) !== null && _k !== void 0 ? _k : null, provider: (_l = wallet === null || wallet === void 0 ? void 0 : wallet.provider) !== null && _l !== void 0 ? _l : null }, createVersionInfo(version))\n    };\n}\n/**\n * Create a connection init event.\n */\nfunction createConnectionStartedEvent(version, traceId) {\n    return {\n        type: 'connection-started',\n        custom_data: createVersionInfo(version),\n        trace_id: traceId !== null && traceId !== void 0 ? traceId : null\n    };\n}\n/**\n * Create a connection completed event.\n * @param version\n * @param wallet\n * @param sessionInfo\n * @param traceId\n */\nfunction createConnectionCompletedEvent(version, wallet, sessionInfo, traceId) {\n    return Object.assign({ type: 'connection-completed', is_success: true, trace_id: traceId !== null && traceId !== void 0 ? traceId : null }, createConnectionInfo(version, wallet, sessionInfo));\n}\n/**\n * Create a connection error event.\n * @param version\n * @param error_message\n * @param errorCode\n * @param sessionInfo\n * @param traceId\n */\nfunction createConnectionErrorEvent(version, error_message, errorCode, sessionInfo, traceId) {\n    var _a, _b;\n    return {\n        type: 'connection-error',\n        is_success: false,\n        error_message: error_message,\n        error_code: errorCode !== null && errorCode !== void 0 ? errorCode : null,\n        trace_id: traceId !== null && traceId !== void 0 ? traceId : null,\n        custom_data: Object.assign({ client_id: (_a = sessionInfo === null || sessionInfo === void 0 ? void 0 : sessionInfo.clientId) !== null && _a !== void 0 ? _a : null, wallet_id: (_b = sessionInfo === null || sessionInfo === void 0 ? void 0 : sessionInfo.walletId) !== null && _b !== void 0 ? _b : null }, createVersionInfo(version))\n    };\n}\n/**\n * Create a connection restoring started event.\n */\nfunction createConnectionRestoringStartedEvent(version, traceId) {\n    return {\n        type: 'connection-restoring-started',\n        custom_data: createVersionInfo(version),\n        trace_id: traceId !== null && traceId !== void 0 ? traceId : null\n    };\n}\n/**\n * Create a connection restoring completed event.\n * @param version\n * @param wallet\n * @param sessionInfo\n * @param traceId\n */\nfunction createConnectionRestoringCompletedEvent(version, wallet, sessionInfo, traceId) {\n    return Object.assign({ type: 'connection-restoring-completed', is_success: true, trace_id: traceId !== null && traceId !== void 0 ? traceId : null }, createConnectionInfo(version, wallet, sessionInfo));\n}\n/**\n * Create a connection restoring error event.\n * @param version\n * @param errorMessage\n * @param traceId\n */\nfunction createConnectionRestoringErrorEvent(version, errorMessage, traceId) {\n    return {\n        type: 'connection-restoring-error',\n        is_success: false,\n        error_message: errorMessage,\n        trace_id: traceId !== null && traceId !== void 0 ? traceId : null,\n        custom_data: createVersionInfo(version)\n    };\n}\nfunction createTransactionInfo(wallet, transaction) {\n    var _a, _b, _c, _d;\n    return {\n        valid_until: (_a = String(transaction.validUntil)) !== null && _a !== void 0 ? _a : null,\n        from: (_d = (_b = transaction.from) !== null && _b !== void 0 ? _b : (_c = wallet === null || wallet === void 0 ? void 0 : wallet.account) === null || _c === void 0 ? void 0 : _c.address) !== null && _d !== void 0 ? _d : null,\n        messages: transaction.messages.map(message => {\n            var _a, _b;\n            return ({\n                address: (_a = message.address) !== null && _a !== void 0 ? _a : null,\n                amount: (_b = message.amount) !== null && _b !== void 0 ? _b : null\n            });\n        })\n    };\n}\nfunction createTransactionFullInfo(wallet, transaction) {\n    var _a, _b, _c, _d;\n    return {\n        valid_until: (_a = String(transaction.validUntil)) !== null && _a !== void 0 ? _a : null,\n        from: (_d = (_b = transaction.from) !== null && _b !== void 0 ? _b : (_c = wallet === null || wallet === void 0 ? void 0 : wallet.account) === null || _c === void 0 ? void 0 : _c.address) !== null && _d !== void 0 ? _d : null,\n        messages: transaction.messages.map(message => {\n            var _a, _b, _c, _d;\n            return ({\n                address: (_a = message.address) !== null && _a !== void 0 ? _a : null,\n                amount: (_b = message.amount) !== null && _b !== void 0 ? _b : null,\n                payload: (_c = message.payload) !== null && _c !== void 0 ? _c : null,\n                state_init: (_d = message.stateInit) !== null && _d !== void 0 ? _d : null\n            });\n        })\n    };\n}\n/**\n * Create a transaction init event.\n * @param version\n * @param wallet\n * @param transaction\n * @param sessionInfo\n * @param traceId\n */\nfunction createTransactionSentForSignatureEvent(version, wallet, transaction, sessionInfo, traceId) {\n    return Object.assign(Object.assign({ type: 'transaction-sent-for-signature', trace_id: traceId !== null && traceId !== void 0 ? traceId : null }, createConnectionInfo(version, wallet, sessionInfo)), createTransactionInfo(wallet, transaction));\n}\n/**\n * Create a transaction signed event.\n * @param version\n * @param wallet\n * @param transaction\n * @param signedTransaction\n * @param sessionInfo\n * @param traceId\n */\nfunction createTransactionSignedEvent(version, wallet, transaction, signedTransaction, sessionInfo, traceId) {\n    return Object.assign(Object.assign({ type: 'transaction-signed', is_success: true, signed_transaction: signedTransaction.boc, trace_id: traceId !== null && traceId !== void 0 ? traceId : null }, createConnectionInfo(version, wallet, sessionInfo)), createTransactionInfo(wallet, transaction));\n}\n/**\n * Create a transaction error event.\n * @param version\n * @param wallet\n * @param transaction\n * @param errorMessage\n * @param errorCode\n * @param sessionInfo\n * @param traceId\n */\nfunction createTransactionSigningFailedEvent(version, wallet, transaction, errorMessage, errorCode, sessionInfo, traceId) {\n    return Object.assign(Object.assign({ type: 'transaction-signing-failed', is_success: false, error_message: errorMessage, error_code: errorCode !== null && errorCode !== void 0 ? errorCode : null, trace_id: traceId !== null && traceId !== void 0 ? traceId : null }, createConnectionInfo(version, wallet, sessionInfo)), createTransactionFullInfo(wallet, transaction));\n}\nfunction createDataSentForSignatureEvent(version, wallet, data, sessionInfo, traceId) {\n    return Object.assign({ type: 'sign-data-request-initiated', data, trace_id: traceId !== null && traceId !== void 0 ? traceId : null }, createConnectionInfo(version, wallet, sessionInfo));\n}\nfunction createDataSignedEvent(version, wallet, data, signedData, sessionInfo, traceId) {\n    return Object.assign({ type: 'sign-data-request-completed', is_success: true, data, signed_data: signedData, trace_id: traceId !== null && traceId !== void 0 ? traceId : null }, createConnectionInfo(version, wallet, sessionInfo));\n}\nfunction createDataSigningFailedEvent(version, wallet, data, errorMessage, errorCode, sessionInfo, traceId) {\n    return Object.assign({ type: 'sign-data-request-failed', is_success: false, data, error_message: errorMessage, error_code: errorCode !== null && errorCode !== void 0 ? errorCode : null, trace_id: traceId !== null && traceId !== void 0 ? traceId : null }, createConnectionInfo(version, wallet, sessionInfo));\n}\nfunction createDisconnectionEvent(version, wallet, scope, sessionInfo, traceId) {\n    return Object.assign({ type: 'disconnection', scope: scope, trace_id: traceId !== null && traceId !== void 0 ? traceId : null }, createConnectionInfo(version, wallet, sessionInfo));\n}\nfunction createWalletModalOpenedEvent(version, visibleWallets, clientId, traceId) {\n    return {\n        type: 'wallet-modal-opened',\n        visible_wallets: visibleWallets,\n        client_id: clientId !== null && clientId !== void 0 ? clientId : null,\n        custom_data: version,\n        trace_id: traceId !== null && traceId !== void 0 ? traceId : null\n    };\n}\nfunction createSelectedWalletEvent(version, visibleWallets, lastSelectedWallet, walletsMenu, redirectLink, redirectLinkType, clientId, traceId) {\n    var _a;\n    let walletRedirectMethod = redirectLinkType;\n    if (!walletRedirectMethod && redirectLink) {\n        walletRedirectMethod = isTelegramUrl(redirectLink) ? 'tg_link' : 'external_link';\n    }\n    return {\n        type: 'selected-wallet',\n        wallets_menu: walletsMenu,\n        visible_wallets: visibleWallets,\n        client_id: clientId !== null && clientId !== void 0 ? clientId : null,\n        custom_data: version,\n        trace_id: traceId !== null && traceId !== void 0 ? traceId : null,\n        wallet_redirect_method: walletRedirectMethod,\n        wallet_redirect_link: redirectLink || undefined,\n        wallet_type: (_a = lastSelectedWallet === null || lastSelectedWallet === void 0 ? void 0 : lastSelectedWallet.appName) !== null && _a !== void 0 ? _a : null\n    };\n}\n\n/**\n * Tracker for TonConnect user actions, such as transaction signing, connection, etc.\n *\n * List of events:\n *  * `connection-started`: when a user starts connecting a wallet.\n *  * `connection-completed`: when a user successfully connected a wallet.\n *  * `connection-error`: when a user cancels a connection or there is an error during the connection process.\n *  * `connection-restoring-started`: when the dApp starts restoring a connection.\n *  * `connection-restoring-completed`: when the dApp successfully restores a connection.\n *  * `connection-restoring-error`: when the dApp fails to restore a connection.\n *  * `disconnection`: when a user starts disconnecting a wallet.\n *  * `transaction-sent-for-signature`: when a user sends a transaction for signature.\n *  * `transaction-signed`: when a user successfully signs a transaction.\n *  * `transaction-signing-failed`: when a user cancels transaction signing or there is an error during the signing process.\n *  * `sign-data-request-initiated`: when a user sends data for signature.\n *  * `sign-data-request-completed`: when a user successfully signs data.\n *  * `sign-data-request-failed`: when a user cancels data signing or there is an error during the signing process.\n *\n * If you want to track user actions, you can subscribe to the window events with prefix `ton-connect-`:\n *\n * @example\n * window.addEventListener('ton-connect-transaction-sent-for-signature', (event) => {\n *    console.log('Transaction init', event.detail);\n * });\n *\n * @internal\n */\nclass TonConnectTracker {\n    /**\n     * Version of the library.\n     */\n    get version() {\n        return createVersionInfo({\n            ton_connect_sdk_lib: this.tonConnectSdkVersion,\n            ton_connect_ui_lib: this.tonConnectUiVersion\n        });\n    }\n    constructor(options) {\n        /**\n         * Event prefix for user actions.\n         * @private\n         */\n        this.eventPrefix = 'ton-connect-';\n        /**\n         * TonConnect UI version.\n         */\n        this.tonConnectUiVersion = null;\n        this.eventDispatcher = options === null || options === void 0 ? void 0 : options.eventDispatcher;\n        this.tonConnectSdkVersion = options.tonConnectSdkVersion;\n        this.init().catch();\n    }\n    /**\n     * Called once when the tracker is created and request version other libraries.\n     */\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this.setRequestVersionHandler();\n                this.tonConnectUiVersion = yield this.requestTonConnectUiVersion();\n            }\n            catch (e) { }\n        });\n    }\n    /**\n     * Set request version handler.\n     * @private\n     */\n    setRequestVersionHandler() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.eventDispatcher.addEventListener('ton-connect-request-version', () => __awaiter(this, void 0, void 0, function* () {\n                yield this.eventDispatcher.dispatchEvent('ton-connect-response-version', createResponseVersionEvent(this.tonConnectSdkVersion));\n            }));\n        });\n    }\n    /**\n     * Request TonConnect UI version.\n     * @private\n     */\n    requestTonConnectUiVersion() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    yield this.eventDispatcher.addEventListener('ton-connect-ui-response-version', (event) => {\n                        resolve(event.detail.version);\n                    }, { once: true });\n                    yield this.eventDispatcher.dispatchEvent('ton-connect-ui-request-version', createRequestVersionEvent());\n                }\n                catch (e) {\n                    reject(e);\n                }\n            }));\n        });\n    }\n    /**\n     * Emit user action event to the window.\n     * @param eventDetails\n     * @private\n     */\n    dispatchUserActionEvent(eventDetails) {\n        try {\n            this.eventDispatcher\n                .dispatchEvent(`${this.eventPrefix}${eventDetails.type}`, eventDetails)\n                .catch();\n        }\n        catch (e) { }\n    }\n    /**\n     * Track connection init event.\n     * @param args\n     */\n    trackConnectionStarted(...args) {\n        try {\n            const event = createConnectionStartedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track connection success event.\n     * @param args\n     */\n    trackConnectionCompleted(...args) {\n        try {\n            const event = createConnectionCompletedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track connection error event.\n     * @param args\n     */\n    trackConnectionError(...args) {\n        try {\n            const event = createConnectionErrorEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track connection restoring init event.\n     * @param args\n     */\n    trackConnectionRestoringStarted(...args) {\n        try {\n            const event = createConnectionRestoringStartedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track connection restoring success event.\n     * @param args\n     */\n    trackConnectionRestoringCompleted(...args) {\n        try {\n            const event = createConnectionRestoringCompletedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track connection restoring error event.\n     * @param args\n     */\n    trackConnectionRestoringError(...args) {\n        try {\n            const event = createConnectionRestoringErrorEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track disconnect event.\n     * @param args\n     */\n    trackDisconnection(...args) {\n        try {\n            const event = createDisconnectionEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track transaction init event.\n     * @param args\n     */\n    trackTransactionSentForSignature(...args) {\n        try {\n            const event = createTransactionSentForSignatureEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track transaction signed event.\n     * @param args\n     */\n    trackTransactionSigned(...args) {\n        try {\n            const event = createTransactionSignedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track transaction error event.\n     * @param args\n     */\n    trackTransactionSigningFailed(...args) {\n        try {\n            const event = createTransactionSigningFailedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track sign data init event.\n     * @param args\n     */\n    trackDataSentForSignature(...args) {\n        try {\n            const event = createDataSentForSignatureEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track sign data success event.\n     * @param args\n     */\n    trackDataSigned(...args) {\n        try {\n            const event = createDataSignedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track sign data error event.\n     * @param args\n     */\n    trackDataSigningFailed(...args) {\n        try {\n            const event = createDataSigningFailedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n}\n\nconst tonConnectSdkVersion = \"3.4.1\";\n\nconst bounceableTag = 0x11;\nconst noBounceableTag = 0x51;\nconst testOnlyTag = 0x80;\n/**\n * Converts raw TON address to no-bounceable user-friendly format. [See details]{@link https://ton.org/docs/learn/overviews/addresses#user-friendly-address}\n * @param hexAddress raw TON address formatted as \"0:<hex string without 0x>\".\n * @param [testOnly=false] convert address to test-only form. [See details]{@link https://ton.org/docs/learn/overviews/addresses#user-friendly-address}\n */\nfunction toUserFriendlyAddress(hexAddress, testOnly = false) {\n    const { wc, hex } = parseHexAddress(hexAddress);\n    let tag = noBounceableTag;\n    if (testOnly) {\n        tag |= testOnlyTag;\n    }\n    const addr = new Int8Array(34);\n    addr[0] = tag;\n    addr[1] = wc;\n    addr.set(hex, 2);\n    const addressWithChecksum = new Uint8Array(36);\n    addressWithChecksum.set(addr);\n    addressWithChecksum.set(crc16(addr), 34);\n    let addressBase64 = _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.Base64.encode(addressWithChecksum);\n    return addressBase64.replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n/**\n * Validates if the address is in user-friendly format by attempting to parse it.\n * @param address address to validate\n * @returns true if the address is valid user-friendly format, false otherwise\n */\nfunction isValidUserFriendlyAddress(address) {\n    try {\n        parseUserFriendlyAddress(address);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n/**\n * Validates if the address is in raw hex format (e.g., \"0:1234...\" or \"-1:1234...\").\n * @param address address to validate\n * @returns true if the address is valid raw format, false otherwise\n */\nfunction isValidRawAddress(address) {\n    try {\n        parseHexAddress(address);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction toRawAddress({ wc, hex }) {\n    return `${wc}:${hex}`;\n}\n/**\n * Parses user-friendly address and returns its components.\n * @param address user-friendly address\n * @returns parsed address components\n */\nfunction parseUserFriendlyAddress(address) {\n    const base64 = address.replace(/-/g, '+').replace(/_/g, '/');\n    let decoded;\n    try {\n        decoded = _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.Base64.decode(base64).toUint8Array();\n    }\n    catch (_a) {\n        throw new WrongAddressError(`Invalid base64 encoding in address: ${address}`);\n    }\n    if (decoded.length !== 36) {\n        throw new WrongAddressError(`Invalid address length: ${address}`);\n    }\n    const addr = decoded.slice(0, 34);\n    const checksum = decoded.slice(34, 36);\n    const calculatedChecksum = crc16(addr);\n    if (!checksum.every((byte, i) => byte === calculatedChecksum[i])) {\n        throw new WrongAddressError(`Invalid checksum in address: ${address}`);\n    }\n    let tag = addr[0];\n    let isTestOnly = false;\n    let isBounceable = false;\n    if (tag & testOnlyTag) {\n        isTestOnly = true;\n        tag = tag ^ testOnlyTag;\n    }\n    if (tag !== bounceableTag && tag !== noBounceableTag) {\n        throw new WrongAddressError(`Unknown address tag: ${tag}`);\n    }\n    isBounceable = tag === bounceableTag;\n    let wc = null;\n    if (addr[1] === 0xff) {\n        // TODO we should read signed integer here\n        wc = -1;\n    }\n    else {\n        wc = addr[1];\n    }\n    const hex = addr.slice(2);\n    if (wc !== 0 && wc !== -1) {\n        throw new WrongAddressError(`Invalid workchain: ${wc}`);\n    }\n    return {\n        wc,\n        hex: Array.from(hex)\n            .map(b => b.toString(16).padStart(2, '0'))\n            .join(''),\n        testOnly: isTestOnly,\n        isBounceable\n    };\n}\nfunction parseHexAddress(hexAddress) {\n    if (!hexAddress.includes(':')) {\n        throw new WrongAddressError(`Wrong address ${hexAddress}. Address must include \":\".`);\n    }\n    const parts = hexAddress.split(':');\n    if (parts.length !== 2) {\n        throw new WrongAddressError(`Wrong address ${hexAddress}. Address must include \":\" only once.`);\n    }\n    const wc = parseInt(parts[0]);\n    if (wc !== 0 && wc !== -1) {\n        throw new WrongAddressError(`Wrong address ${hexAddress}. WC must be eq 0 or -1, but ${wc} received.`);\n    }\n    const hex = parts[1];\n    if ((hex === null || hex === void 0 ? void 0 : hex.length) !== 64) {\n        throw new WrongAddressError(`Wrong address ${hexAddress}. Hex part must be 64bytes length, but ${hex === null || hex === void 0 ? void 0 : hex.length} received.`);\n    }\n    return {\n        wc,\n        hex: hexToBytes(hex)\n    };\n}\nfunction crc16(data) {\n    const poly = 0x1021;\n    let reg = 0;\n    const message = new Uint8Array(data.length + 2);\n    message.set(data);\n    for (let byte of message) {\n        let mask = 0x80;\n        while (mask > 0) {\n            reg <<= 1;\n            if (byte & mask) {\n                reg += 1;\n            }\n            mask >>= 1;\n            if (reg > 0xffff) {\n                reg &= 0xffff;\n                reg ^= poly;\n            }\n        }\n    }\n    return new Uint8Array([Math.floor(reg / 256), reg % 256]);\n}\nconst toByteMap = {};\nfor (let ord = 0; ord <= 0xff; ord++) {\n    let s = ord.toString(16);\n    if (s.length < 2) {\n        s = '0' + s;\n    }\n    toByteMap[s] = ord;\n}\nfunction hexToBytes(hex) {\n    hex = hex.toLowerCase();\n    const length2 = hex.length;\n    if (length2 % 2 !== 0) {\n        throw new ParseHexError('Hex string must have length a multiple of 2: ' + hex);\n    }\n    const length = length2 / 2;\n    const result = new Uint8Array(length);\n    for (let i = 0; i < length; i++) {\n        const doubled = i * 2;\n        const hexSubstring = hex.substring(doubled, doubled + 2);\n        if (!toByteMap.hasOwnProperty(hexSubstring)) {\n            throw new ParseHexError('Invalid hex character: ' + hexSubstring);\n        }\n        result[i] = toByteMap[hexSubstring];\n    }\n    return result;\n}\n\nconst BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;\nconst BASE64URL_REGEX = /^[A-Za-z0-9\\-_]+$/;\nconst BOC_PREFIX = 'te6cc';\nconst INTEGER_REGEX = /^-?\\d+$/;\nconst POSITIVE_INTEGER_REGEX = /^\\d+$/;\nconst MAX_DOMAIN_BYTES = 128;\nconst MAX_PAYLOAD_BYTES = 128;\nconst MAX_TOTAL_BYTES = 222;\nfunction isValidNumber(value) {\n    return typeof value === 'number' && !isNaN(value);\n}\nfunction isValidString(value) {\n    return typeof value === 'string' && value.length > 0;\n}\nfunction isValidAddress(value) {\n    return isValidString(value) && (isValidRawAddress(value) || isValidUserFriendlyAddress(value));\n}\nfunction isValidNetwork(value) {\n    return isValidString(value) && /^-?\\d+$/.test(value);\n}\nfunction isValidBoc(value) {\n    return (typeof value === 'string' &&\n        (BASE64_REGEX.test(value) || BASE64URL_REGEX.test(value)) &&\n        value.startsWith(BOC_PREFIX));\n}\nfunction isValidObject(value) {\n    return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\nfunction isValidArray(value) {\n    return Array.isArray(value);\n}\nfunction hasExtraProperties(obj, allowedKeys) {\n    return Object.keys(obj).some(key => !allowedKeys.includes(key));\n}\nfunction validateSendTransactionRequest(data) {\n    if (!isValidObject(data)) {\n        return 'Request must be an object';\n    }\n    const allowedKeys = ['validUntil', 'network', 'from', 'messages'];\n    if (hasExtraProperties(data, allowedKeys)) {\n        return 'Request contains extra properties';\n    }\n    if (data.validUntil) {\n        if (!isValidNumber(data.validUntil)) {\n            return \"Incorrect 'validUntil'\";\n        }\n        const now = Math.floor(Date.now() / 1000);\n        const fiveMinutesFromNow = now + 300;\n        if (data.validUntil > fiveMinutesFromNow) {\n            console.warn(`validUntil (${data.validUntil}) is more than 5 minutes from now (${now})`);\n        }\n    }\n    if (data.network !== undefined) {\n        if (!isValidNetwork(data.network)) {\n            return \"Invalid 'network' format\";\n        }\n    }\n    if (data.from !== undefined && !isValidAddress(data.from)) {\n        return \"Invalid 'from' address format\";\n    }\n    if (!isValidArray(data.messages) || data.messages.length === 0) {\n        return \"'messages' is required\";\n    }\n    for (let i = 0; i < data.messages.length; i++) {\n        const message = data.messages[i];\n        const messageError = validateTransactionMessage(message, i);\n        if (messageError) {\n            return messageError;\n        }\n    }\n    return null;\n}\nfunction validateTransactionMessage(message, index) {\n    if (!isValidObject(message)) {\n        return `Message at index ${index} must be an object`;\n    }\n    const allowedKeys = ['address', 'amount', 'stateInit', 'payload', 'extraCurrency'];\n    if (hasExtraProperties(message, allowedKeys)) {\n        return `Message at index ${index} contains extra properties`;\n    }\n    if (!isValidString(message.address)) {\n        return `'address' is required in message at index ${index}`;\n    }\n    if (!isValidUserFriendlyAddress(message.address)) {\n        return `Wrong 'address' format in message at index ${index}`;\n    }\n    if (!isValidString(message.amount)) {\n        return `'amount' is required in message at index ${index}`;\n    }\n    if (!/^[0-9]+$/.test(message.amount)) {\n        return `Incorrect 'amount' in message at index ${index}`;\n    }\n    if (message.stateInit !== undefined) {\n        if (!isValidString(message.stateInit) || !isValidBoc(message.stateInit)) {\n            return `Invalid 'stateInit' in message at index ${index}`;\n        }\n    }\n    if (message.payload !== undefined) {\n        if (!isValidString(message.payload) || !isValidBoc(message.payload)) {\n            return `Invalid 'payload' in message at index ${index}`;\n        }\n    }\n    if (message.extraCurrency !== undefined) {\n        if (!isValidObject(message.extraCurrency)) {\n            return `Invalid 'extraCurrency' in message at index ${index}`;\n        }\n        for (const [key, value] of Object.entries(message.extraCurrency)) {\n            if (!INTEGER_REGEX.test(key) ||\n                typeof value !== 'string' ||\n                !POSITIVE_INTEGER_REGEX.test(value)) {\n                return `Invalid 'extraCurrency' format in message at index ${index}`;\n            }\n        }\n    }\n    return null;\n}\nfunction validateConnectAdditionalRequest(data) {\n    if (!isValidObject(data)) {\n        return 'Request must be an object';\n    }\n    const allowedKeys = ['tonProof'];\n    if (hasExtraProperties(data, allowedKeys)) {\n        return 'Request contains extra properties';\n    }\n    if (data.tonProof !== undefined) {\n        if (typeof data.tonProof !== 'string') {\n            return \"Invalid 'tonProof'\";\n        }\n        const payload = data.tonProof;\n        if (payload.length === 0) {\n            return \"Empty 'tonProof' payload\";\n        }\n        // Get current domain for validation first\n        const domain = getDomain();\n        if (!domain) {\n            // In Node.js environment, skip domain validation\n            return null;\n        }\n        // Validate domain size (max 128 bytes)\n        const domainBytes = new TextEncoder().encode(domain).length;\n        if (domainBytes > MAX_DOMAIN_BYTES) {\n            return 'Current domain exceeds 128 bytes limit';\n        }\n        // Validate payload size (max 128 bytes)\n        const payloadBytes = new TextEncoder().encode(payload).length;\n        if (payloadBytes > MAX_PAYLOAD_BYTES) {\n            return \"'tonProof' payload exceeds 128 bytes limit\";\n        }\n        // Validate total size (domain + payload <= 222 bytes)\n        if (domainBytes + payloadBytes > MAX_TOTAL_BYTES) {\n            return \"'tonProof' domain + payload exceeds 222 bytes limit\";\n        }\n    }\n    return null;\n}\nfunction validateSignDataPayload(data) {\n    if (!isValidObject(data)) {\n        return 'Payload must be an object';\n    }\n    if (!isValidString(data.type)) {\n        return \"'type' is required\";\n    }\n    switch (data.type) {\n        case 'text':\n            return validateSignDataPayloadText(data);\n        case 'binary':\n            return validateSignDataPayloadBinary(data);\n        case 'cell':\n            return validateSignDataPayloadCell(data);\n        default:\n            return \"Invalid 'type' value\";\n    }\n}\nfunction validateSignDataPayloadText(data) {\n    const allowedKeys = ['type', 'text', 'network', 'from'];\n    if (hasExtraProperties(data, allowedKeys)) {\n        return 'Text payload contains extra properties';\n    }\n    if (!isValidString(data.text)) {\n        return \"'text' is required\";\n    }\n    if (data.network !== undefined) {\n        if (!isValidNetwork(data.network)) {\n            return \"Invalid 'network' format\";\n        }\n    }\n    if (data.from !== undefined && !isValidAddress(data.from)) {\n        return \"Invalid 'from'\";\n    }\n    return null;\n}\nfunction validateSignDataPayloadBinary(data) {\n    const allowedKeys = ['type', 'bytes', 'network', 'from'];\n    if (hasExtraProperties(data, allowedKeys)) {\n        return 'Binary payload contains extra properties';\n    }\n    if (!isValidString(data.bytes)) {\n        return \"'bytes' is required\";\n    }\n    if (data.network !== undefined) {\n        if (!isValidNetwork(data.network)) {\n            return \"Invalid 'network' format\";\n        }\n    }\n    if (data.from !== undefined && !isValidAddress(data.from)) {\n        return \"Invalid 'from'\";\n    }\n    return null;\n}\nfunction validateSignDataPayloadCell(data) {\n    const allowedKeys = ['type', 'schema', 'cell', 'network', 'from'];\n    if (hasExtraProperties(data, allowedKeys)) {\n        return 'Cell payload contains extra properties';\n    }\n    if (!isValidString(data.schema)) {\n        return \"'schema' is required\";\n    }\n    if (!isValidString(data.cell)) {\n        return \"'cell' is required\";\n    }\n    if (!isValidBoc(data.cell)) {\n        return \"Invalid 'cell' format (must be valid base64)\";\n    }\n    if (data.network !== undefined) {\n        if (!isValidNetwork(data.network)) {\n            return \"Invalid 'network' format\";\n        }\n    }\n    if (data.from !== undefined && !isValidAddress(data.from)) {\n        return \"Invalid 'from'\";\n    }\n    return null;\n}\n/**\n * Validates ton_proof item received from wallet in connect event.\n */\n// eslint-disable-next-line complexity\nfunction validateTonProofItemReply(data) {\n    if (!isValidObject(data)) {\n        return 'ton_proof item must be an object';\n    }\n    const allowedKeys = ['error', 'proof', 'name'];\n    if (hasExtraProperties(data, allowedKeys)) {\n        return 'ton_proof item contains extra properties';\n    }\n    const hasProof = Object.prototype.hasOwnProperty.call(data, 'proof');\n    const hasError = Object.prototype.hasOwnProperty.call(data, 'error');\n    if (!hasProof && !hasError) {\n        return \"'ton_proof' item must contain either 'proof' or 'error'\";\n    }\n    if (hasProof && hasError) {\n        return \"'ton_proof' item must contain either 'proof' or 'error', not both\";\n    }\n    if (hasProof) {\n        const proof = data.proof;\n        if (!isValidObject(proof)) {\n            return \"Invalid 'proof' object\";\n        }\n        if (!isValidNumber(proof.timestamp)) {\n            return \"Invalid 'proof.timestamp'\";\n        }\n        const domain = proof.domain;\n        if (!isValidObject(domain)) {\n            return \"Invalid 'proof.domain'\";\n        }\n        if (!isValidNumber(domain.lengthBytes)) {\n            return \"Invalid 'proof.domain.lengthBytes'\";\n        }\n        if (!isValidString(domain.value)) {\n            return \"Invalid 'proof.domain.value'\";\n        }\n        // Try to verify that provided byte length matches actual byte length of value\n        try {\n            const encoderAvailable = typeof TextEncoder !== 'undefined';\n            const actualLength = encoderAvailable\n                ? new TextEncoder().encode(domain.value).length\n                : domain.value.length;\n            if (actualLength !== domain.lengthBytes) {\n                return \"'proof.domain.lengthBytes' does not match 'proof.domain.value'\";\n            }\n        }\n        catch (_a) {\n            // Ignore environment issues; best-effort validation\n        }\n        if (!isValidString(proof.payload)) {\n            return \"Invalid 'proof.payload'\";\n        }\n        if (!isValidString(proof.signature) || !BASE64_REGEX.test(proof.signature)) {\n            return \"Invalid 'proof.signature' format\";\n        }\n    }\n    if (hasError) {\n        const error = data.error;\n        if (!isValidObject(error)) {\n            return \"Invalid 'error' object\";\n        }\n        const allowedErrorKeys = ['code', 'message'];\n        if (hasExtraProperties(error, allowedErrorKeys)) {\n            return 'ton_proof error contains extra properties';\n        }\n        if (!isValidNumber(error.code)) {\n            return \"Invalid 'error.code'\";\n        }\n        if (!isValidString(error.message)) {\n            return \"Invalid 'error.message'\";\n        }\n    }\n    return null;\n}\n\nfunction normalizeBase64(data) {\n    if (typeof data !== 'string')\n        return undefined;\n    const paddedLength = data.length + ((4 - (data.length % 4)) % 4);\n    return data.replace(/-/g, '+').replace(/_/g, '/').padEnd(paddedLength, '=');\n}\n\n/**\n * Converts a PascalCase (or camelCase) string to kebab-case.\n *\n * For example:\n * - \"PascalCase\"  \"pascal-case\"\n * - \"camelCaseExample\"  \"camel-case-example\"\n *\n * @param value - The input string in PascalCase or camelCase format.\n * @returns The converted kebab-case string.\n */\nfunction pascalToKebab(value) {\n    return value.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();\n}\n/**\n * Collects static connection metrics from the browser's Performance API.\n * TTFB is measured once at page load and doesn't change.\n * @returns An object containing static connection metrics (TTFB) or empty object if not available.\n */\nfunction getStaticConnectionMetrics() {\n    const metrics = {};\n    // Get TTFB from Navigation Timing API (static, measured once at page load)\n    try {\n        const navEntries = performance.getEntriesByType('navigation');\n        if (navEntries.length > 0) {\n            const nav = navEntries[0];\n            if (nav.responseStart && nav.requestStart) {\n                metrics.conn_ttfb = Math.round(nav.responseStart - nav.requestStart);\n            }\n        }\n    }\n    catch (e) {\n        // Performance API not available or error occurred\n    }\n    return metrics;\n}\n/**\n * Collects dynamic connection metrics from the browser's Network Information API.\n * @returns An object containing dynamic connection metrics (RTT, network type) or empty object if not available.\n */\nfunction getDynamicConnectionMetrics() {\n    const metrics = {};\n    // Get RTT and network type from Network Information API (dynamic, can change)\n    try {\n        const navigatorWithConnection = navigator;\n        const connection = navigatorWithConnection.connection ||\n            navigatorWithConnection.mozConnection ||\n            navigatorWithConnection.webkitConnection;\n        if (connection) {\n            if (connection.rtt !== undefined) {\n                metrics.conn_rtt = connection.rtt;\n            }\n            if (connection.effectiveType) {\n                metrics.conn_network_type = connection.effectiveType;\n            }\n            else if (connection.type) {\n                metrics.conn_network_type = connection.type;\n            }\n        }\n    }\n    catch (e) {\n        // Network Information API not available or error occurred\n    }\n    return metrics;\n}\n\nclass AnalyticsManager {\n    constructor(options = {}) {\n        var _a, _b, _c, _d, _e, _f;\n        this.events = [];\n        this.timeoutId = null;\n        this.isProcessing = false;\n        this.backoff = 1;\n        this.shouldSend = true;\n        this.batchTimeoutMs = (_a = options.batchTimeoutMs) !== null && _a !== void 0 ? _a : 2000;\n        this.currentBatchTimeoutMs = this.batchTimeoutMs;\n        this.maxBatchSize = (_b = options.maxBatchSize) !== null && _b !== void 0 ? _b : 100;\n        this.analyticsUrl = (_c = options.analyticsUrl) !== null && _c !== void 0 ? _c : 'https://analytics.ton.org/events';\n        this.mode = (_d = options.mode) !== null && _d !== void 0 ? _d : 'telemetry';\n        this.baseEvent = Object.assign({ subsystem: 'dapp-sdk', version: tonConnectSdkVersion, client_environment: (_f = (_e = options.environment) === null || _e === void 0 ? void 0 : _e.getClientEnvironment) === null || _f === void 0 ? void 0 : _f.call(_e) }, getStaticConnectionMetrics());\n        this.addWindowFocusAndBlurSubscriptions();\n    }\n    scoped(sharedData) {\n        return new Proxy(this, {\n            get(target, prop) {\n                const propName = prop.toString();\n                if (propName.startsWith('emit')) {\n                    const eventNamePascal = propName.replace('emit', '');\n                    const eventNameKebab = pascalToKebab(eventNamePascal);\n                    return function (event) {\n                        const executedData = Object.fromEntries(Object.entries(sharedData !== null && sharedData !== void 0 ? sharedData : {}).map(([key, value]) => [\n                            key,\n                            typeof value === 'function' ? value() : value\n                        ]));\n                        return target.emit(Object.assign(Object.assign({ event_name: eventNameKebab }, executedData), event));\n                    };\n                }\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                return target[prop];\n            }\n        });\n    }\n    emit(event) {\n        var _a;\n        if (this.mode === 'off') {\n            return;\n        }\n        const traceId = (_a = event.trace_id) !== null && _a !== void 0 ? _a : UUIDv7();\n        const dynamicMetrics = getDynamicConnectionMetrics();\n        const enhancedEvent = Object.assign(Object.assign(Object.assign(Object.assign({}, this.baseEvent), dynamicMetrics), event), { event_id: UUIDv7(), client_timestamp: Math.floor(Date.now() / 1000), trace_id: traceId });\n        const filteredEvent = this.mode === 'telemetry' ? this.filterFullModeFields(enhancedEvent) : enhancedEvent;\n        if (isQaModeEnabled()) {\n            logDebug(filteredEvent);\n        }\n        this.events.push(filteredEvent);\n        if (this.events.length >= this.maxBatchSize) {\n            void this.flush();\n            return;\n        }\n        this.startTimeout();\n    }\n    startTimeout() {\n        if (this.timeoutId || this.isProcessing) {\n            return;\n        }\n        this.timeoutId = setTimeout(() => {\n            void this.flush();\n        }, this.currentBatchTimeoutMs);\n    }\n    flush() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.isProcessing || this.events.length === 0 || !this.shouldSend) {\n                return;\n            }\n            this.clearTimeout();\n            this.isProcessing = true;\n            const eventsToSend = this.extractEventsToSend();\n            try {\n                yield this.processEventsBatch(eventsToSend);\n                logDebug('Analytics events sent successfully');\n            }\n            catch (error) {\n                this.restoreEvents(eventsToSend);\n                logError('Failed to send analytics events:', error);\n            }\n            finally {\n                this.isProcessing = false;\n                this.scheduleNextFlushIfNeeded();\n            }\n        });\n    }\n    clearTimeout() {\n        if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n            this.timeoutId = null;\n        }\n    }\n    extractEventsToSend() {\n        const eventsToSend = this.events.slice(0, this.maxBatchSize);\n        this.events = this.events.slice(this.maxBatchSize);\n        return eventsToSend;\n    }\n    processEventsBatch(eventsToSend) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logDebug('Sending analytics events...', eventsToSend.length);\n            try {\n                const response = yield this.sendEvents(eventsToSend);\n                this.handleResponse(response);\n            }\n            catch (err) {\n                this.handleUnknownError(err);\n            }\n        });\n    }\n    handleResponse(response) {\n        const { status, statusText } = response;\n        if (this.isTooManyRequests(status)) {\n            this.handleTooManyRequests(status, statusText);\n        }\n        else if (this.isClientError(status)) {\n            this.handleClientError(status, statusText);\n        }\n        else if (this.isServerError(status)) {\n            this.handleUnknownError({ status, statusText });\n        }\n    }\n    restoreEvents(eventsToSend) {\n        this.events.unshift(...eventsToSend);\n    }\n    scheduleNextFlushIfNeeded() {\n        if (this.events.length > 0) {\n            this.startTimeout();\n        }\n    }\n    sendEvents(events) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield fetch(this.analyticsUrl, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Client-Timestamp': Math.floor(Date.now() / 1000).toString()\n                },\n                body: JSON.stringify(events)\n            });\n        });\n    }\n    isClientError(status) {\n        return (status >= AnalyticsManager.HTTP_STATUS.CLIENT_ERROR_START &&\n            status < AnalyticsManager.HTTP_STATUS.SERVER_ERROR_START);\n    }\n    isServerError(status) {\n        return status >= AnalyticsManager.HTTP_STATUS.SERVER_ERROR_START;\n    }\n    isTooManyRequests(status) {\n        return status === AnalyticsManager.HTTP_STATUS.TOO_MANY_REQUESTS;\n    }\n    handleClientError(status, statusText) {\n        // Don't retry\n        logError('Failed to send analytics events:', new TonConnectError(`Analytics API error: ${status} ${statusText}`));\n    }\n    handleUnknownError(error) {\n        if (this.backoff < AnalyticsManager.MAX_BACKOFF_ATTEMPTS) {\n            this.backoff++;\n            this.currentBatchTimeoutMs *= AnalyticsManager.BACKOFF_MULTIPLIER;\n            throw new TonConnectError(`Unknown analytics API error: ${error}`);\n        }\n        else {\n            this.currentBatchTimeoutMs = this.batchTimeoutMs;\n            this.backoff = 1;\n            return; // Don't retry\n        }\n    }\n    handleTooManyRequests(status, statusText) {\n        throw new TonConnectError(`Analytics API error: ${status} ${statusText}`);\n    }\n    addWindowFocusAndBlurSubscriptions() {\n        const document = getDocument();\n        if (!document) {\n            return;\n        }\n        try {\n            document.addEventListener('visibilitychange', () => {\n                if (document.hidden) {\n                    this.clearTimeout();\n                    this.shouldSend = false;\n                }\n                else {\n                    this.shouldSend = true;\n                    this.scheduleNextFlushIfNeeded();\n                }\n            });\n        }\n        catch (e) {\n            logError('Cannot subscribe to the document.visibilitychange: ', e);\n        }\n    }\n    getMode() {\n        return this.mode;\n    }\n    getPendingEventsCount() {\n        return this.events.length;\n    }\n    filterFullModeFields(event) {\n        const filtered = Object.assign({}, event);\n        for (const field of AnalyticsManager.FULL_MODE_FIELDS) {\n            delete filtered[field];\n        }\n        // wallet_address is kept for error events, removed for non-error events\n        const eventName = 'event_name' in event ? String(event.event_name) : '';\n        const isErrorEvent = 'error_code' in event ||\n            'error_message' in event ||\n            eventName.includes('error') ||\n            eventName === 'connection-error' ||\n            eventName === 'transaction-signing-failed' ||\n            eventName === 'sign-data-request-failed';\n        if (!isErrorEvent && 'wallet_address' in filtered) {\n            delete filtered.wallet_address;\n        }\n        return filtered;\n    }\n    setWalletListDownloadDuration(duration) {\n        this.baseEvent = Object.assign(Object.assign({}, this.baseEvent), { wallet_list_download_duration: duration });\n    }\n}\nAnalyticsManager.HTTP_STATUS = {\n    TOO_MANY_REQUESTS: 429,\n    CLIENT_ERROR_START: 400,\n    SERVER_ERROR_START: 500\n};\nAnalyticsManager.MAX_BACKOFF_ATTEMPTS = 5;\nAnalyticsManager.BACKOFF_MULTIPLIER = 2;\nAnalyticsManager.FULL_MODE_FIELDS = [\n    'user_id',\n    'tg_id',\n    'locale',\n    'tma_is_premium'\n];\n\n/**\n * A concrete implementation of EventDispatcher that dispatches events to the browser window.\n */\nclass BrowserEventDispatcher {\n    constructor() {\n        /**\n         * The window object, possibly undefined in a server environment.\n         * @private\n         */\n        this.window = getWindow();\n    }\n    /**\n     * Dispatches an event with the given name and details to the browser window.\n     * @param eventName - The name of the event to dispatch.\n     * @param eventDetails - The details of the event to dispatch.\n     * @returns A promise that resolves when the event has been dispatched.\n     */\n    dispatchEvent(eventName, eventDetails) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const event = new CustomEvent(eventName, { detail: eventDetails });\n            (_a = this.window) === null || _a === void 0 ? void 0 : _a.dispatchEvent(event);\n        });\n    }\n    /**\n     * Adds an event listener to the browser window.\n     * @param eventName - The name of the event to listen for.\n     * @param listener - The listener to add.\n     * @param options - The options for the listener.\n     * @returns A function that removes the listener.\n     */\n    addEventListener(eventName, listener, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            (_a = this.window) === null || _a === void 0 ? void 0 : _a.addEventListener(eventName, listener, options);\n            return () => {\n                var _a;\n                return (_a = this.window) === null || _a === void 0 ? void 0 : _a.removeEventListener(eventName, listener);\n            };\n        });\n    }\n}\n\nfunction buildVersionInfo(version) {\n    return {\n        '@tonconnect/sdk': version.ton_connect_sdk_lib || '',\n        '@tonconnect/ui': version.ton_connect_ui_lib || ''\n    };\n}\nfunction buildTonConnectEvent(detail) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    return {\n        versions: buildVersionInfo(detail.custom_data),\n        network_id: (_a = detail.custom_data.chain_id) !== null && _a !== void 0 ? _a : '',\n        client_id: (_b = detail.custom_data.client_id) !== null && _b !== void 0 ? _b : '',\n        wallet_id: (_c = detail.custom_data.wallet_id) !== null && _c !== void 0 ? _c : '',\n        wallet_address: (_d = detail.wallet_address) !== null && _d !== void 0 ? _d : '',\n        wallet_app_name: (_e = detail.wallet_type) !== null && _e !== void 0 ? _e : '',\n        wallet_app_version: (_f = detail.wallet_version) !== null && _f !== void 0 ? _f : '',\n        wallet_state_init: (_g = detail.wallet_state_init) !== null && _g !== void 0 ? _g : '',\n        trace_id: (_h = detail.trace_id) !== null && _h !== void 0 ? _h : undefined\n    };\n}\nfunction bindEventsTo(eventDispatcher, analytics) {\n    eventDispatcher.addEventListener('ton-connect-ui-wallet-modal-opened', event => {\n        var _a;\n        const { detail } = event;\n        analytics.emitConnectionStarted({\n            client_id: detail.client_id || '',\n            versions: buildVersionInfo(detail.custom_data),\n            main_screen: detail.visible_wallets,\n            trace_id: (_a = detail.trace_id) !== null && _a !== void 0 ? _a : undefined\n        });\n    });\n    eventDispatcher.addEventListener('ton-connect-ui-selected-wallet', event => {\n        var _a, _b;\n        const { detail } = event;\n        analytics.emitConnectionSelectedWallet({\n            client_id: detail.client_id || '',\n            versions: buildVersionInfo(detail.custom_data),\n            main_screen: detail.visible_wallets,\n            wallets_menu: detail.wallets_menu,\n            trace_id: (_a = detail.trace_id) !== null && _a !== void 0 ? _a : undefined,\n            wallet_app_name: (_b = detail.wallet_type) !== null && _b !== void 0 ? _b : '',\n            wallet_redirect_method: detail.wallet_redirect_method,\n            wallet_redirect_link: detail.wallet_redirect_link\n        });\n    });\n    eventDispatcher.addEventListener('ton-connect-connection-completed', event => {\n        const { detail } = event;\n        analytics.emitConnectionCompleted(buildTonConnectEvent(detail));\n    });\n    eventDispatcher.addEventListener('ton-connect-connection-error', event => {\n        var _a, _b;\n        const { detail } = event;\n        analytics.emitConnectionError({\n            client_id: detail.custom_data.client_id || '',\n            wallet_id: detail.custom_data.wallet_id || '',\n            error_code: (_a = detail.error_code) !== null && _a !== void 0 ? _a : 0,\n            error_message: detail.error_message,\n            trace_id: (_b = detail.trace_id) !== null && _b !== void 0 ? _b : undefined\n        });\n    });\n    eventDispatcher.addEventListener('ton-connect-disconnection', event => {\n        const { detail } = event;\n        analytics.emitDisconnection(buildTonConnectEvent(detail));\n    });\n    eventDispatcher.addEventListener('ton-connect-transaction-sent-for-signature', event => {\n        const { detail } = event;\n        analytics.emitTransactionSent(buildTonConnectEvent(detail));\n    });\n    eventDispatcher.addEventListener('ton-connect-transaction-signed', event => {\n        const { detail } = event;\n        analytics.emitTransactionSigned(Object.assign(Object.assign({}, buildTonConnectEvent(detail)), { signed_boc: event.detail.signed_transaction }));\n    });\n    eventDispatcher.addEventListener('ton-connect-transaction-signing-failed', event => {\n        var _a;\n        const { detail } = event;\n        analytics.emitTransactionSigningFailed(Object.assign(Object.assign({}, buildTonConnectEvent(detail)), { valid_until: Number(detail.valid_until), messages: detail.messages.map(message => {\n                var _a, _b, _c, _d;\n                return ({\n                    address: (_a = message.address) !== null && _a !== void 0 ? _a : '',\n                    amount: (_b = message.amount) !== null && _b !== void 0 ? _b : '',\n                    payload: (_c = message.payload) !== null && _c !== void 0 ? _c : '',\n                    state_init: (_d = message.state_init) !== null && _d !== void 0 ? _d : ''\n                });\n            }), error_message: detail.error_message, error_code: (_a = detail.error_code) !== null && _a !== void 0 ? _a : 0 }));\n    });\n    eventDispatcher.addEventListener('ton-connect-sign-data-request-initiated', event => {\n        const { detail } = event;\n        analytics === null || analytics === void 0 ? void 0 : analytics.emitSignDataRequestInitiated(buildTonConnectEvent(detail));\n    });\n    eventDispatcher.addEventListener('ton-connect-sign-data-request-completed', event => {\n        const { detail } = event;\n        analytics === null || analytics === void 0 ? void 0 : analytics.emitSignDataRequestCompleted(buildTonConnectEvent(detail));\n    });\n    eventDispatcher.addEventListener('ton-connect-sign-data-request-failed', event => {\n        var _a;\n        const { detail } = event;\n        let signDataValue = '';\n        let signDataSchema = undefined;\n        if (detail.data.type === 'text') {\n            signDataValue = detail.data.text;\n        }\n        if (detail.data.type === 'cell') {\n            signDataValue = detail.data.cell;\n            signDataSchema = detail.data.schema;\n        }\n        if (detail.data.type === 'binary') {\n            signDataValue = detail.data.bytes;\n        }\n        analytics === null || analytics === void 0 ? void 0 : analytics.emitSignDataRequestFailed(Object.assign(Object.assign({}, buildTonConnectEvent(detail)), { sign_data_type: detail.data.type, sign_data_value: signDataValue, sign_data_schema: signDataSchema, error_code: (_a = detail.error_code) !== null && _a !== void 0 ? _a : 0, error_message: detail.error_message }));\n    });\n}\n\nclass DefaultEnvironment {\n    getClientEnvironment() {\n        return '';\n    }\n    getBrowser() {\n        return '';\n    }\n    getLocale() {\n        return '';\n    }\n    getPlatform() {\n        return '';\n    }\n    getTelegramUser() {\n        return undefined;\n    }\n}\n\nconst state = {};\n/**\n * Initializes the WalletConnect integration.\n *\n * This function must be called once before using WalletConnect features.\n * A second call will throw an error to prevent accidental re-initialization.\n *\n * @param UniversalConnectorCls - A UniversalConnector class imported from '@reown/appkit-universal-connector'\n * @param {WalletConnectOptions} walletConnectOptions - Configuration options used for initializing WalletConnect.\n * @example\n * import { UniversalConnector } from '@reown/appkit-universal-connector';\n *\n * initializeWalletConnect(UniversalConnector, {\n *     projectId: 'abcd1234abcd1234abcd1234abcd1234',\n *     metadata: {\n *         name: 'Demo DApp',\n *         icons: [\n *             'https://example.com/my-icon.png'\n *         ],\n *         url: window.location.origin,\n *         description: 'Demo DApp'\n *     }\n * });\n */\nfunction initializeWalletConnect(UniversalConnectorCls, walletConnectOptions) {\n    if ((state === null || state === void 0 ? void 0 : state.walletConnectOptions) !== undefined || (state === null || state === void 0 ? void 0 : state.UniversalConnectorCls) !== undefined) {\n        throw new TonConnectError('Wallet Connect already initialized.');\n    }\n    if (typeof UniversalConnectorCls !== 'function' || !('init' in UniversalConnectorCls)) {\n        throw new TonConnectError('Initialize UniversalConnectorCls must be set');\n    }\n    state.UniversalConnectorCls = UniversalConnectorCls;\n    state.walletConnectOptions = walletConnectOptions;\n}\nfunction isWalletConnectInitialized() {\n    return state.UniversalConnectorCls !== undefined && state.walletConnectOptions !== undefined;\n}\nfunction getUniversalConnector() {\n    if (state.UniversalConnectorCls === undefined) {\n        throw new TonConnectError('Wallet Connect is not initialized.');\n    }\n    return state.UniversalConnectorCls;\n}\nfunction getWalletConnectOptions() {\n    if (state.walletConnectOptions === undefined) {\n        throw new TonConnectError('Wallet Connect is not initialized.');\n    }\n    return state.walletConnectOptions;\n}\n\nconst DEFAULT_REQUEST_ID = '0';\nconst DEFAULT_EVENT_ID = 0;\nclass WalletConnectProvider {\n    constructor(connectionStorage) {\n        this.connectionStorage = connectionStorage;\n        this.type = 'injected';\n        this.listeners = [];\n        this.connector = undefined;\n        const { projectId, metadata } = getWalletConnectOptions();\n        this.config = {\n            networks: [\n                {\n                    namespace: 'ton',\n                    chains: [\n                        {\n                            id: -239,\n                            chainNamespace: 'ton',\n                            caipNetworkId: 'ton:-239',\n                            name: 'TON',\n                            nativeCurrency: { name: 'TON', symbol: 'TON', decimals: 9 },\n                            rpcUrls: { default: { http: [] } }\n                        },\n                        {\n                            id: -3,\n                            chainNamespace: 'ton',\n                            caipNetworkId: 'ton:-3',\n                            name: 'TON',\n                            nativeCurrency: { name: 'TON', symbol: 'TON', decimals: 9 },\n                            rpcUrls: { default: { http: [] } }\n                        }\n                    ],\n                    methods: ['ton_sendMessage', 'ton_signData'],\n                    events: []\n                }\n            ],\n            projectId,\n            metadata\n        };\n    }\n    static fromStorage(storage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new WalletConnectProvider(storage);\n        });\n    }\n    initialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.connector) {\n                this.connector = yield getUniversalConnector().init(this.config);\n            }\n            return this.connector;\n        });\n    }\n    connect(message, options) {\n        var _a, _b;\n        const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n        const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n        (_b = this.abortController) === null || _b === void 0 ? void 0 : _b.abort();\n        this.abortController = abortController;\n        void this._connect(message, {\n            traceId,\n            signal: abortController.signal,\n            abortController\n        }).catch(error => logDebug('WalletConnect connect unexpected error', error));\n    }\n    _connect(message, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            const connector = yield this.initialize();\n            if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {\n                logDebug('WalletConnect connect aborted before start');\n                this.clearAbortController(options.abortController);\n                return;\n            }\n            const tonProof = message.items.find(item => item.name === 'ton_proof');\n            const authentication = tonProof\n                ? [\n                    {\n                        domain: new URL(this.config.metadata.url).hostname,\n                        chains: ['ton:-239'],\n                        nonce: '',\n                        uri: 'ton_proof',\n                        ttl: 0,\n                        statement: tonProof.payload\n                    }\n                ]\n                : undefined;\n            logDebug('Connecting through this.connector.connect');\n            try {\n                yield connector.connect({ authentication });\n            }\n            catch (error) {\n                if ((_b = options.signal) === null || _b === void 0 ? void 0 : _b.aborted) {\n                    logDebug('WalletConnect connect aborted via signal');\n                    this.clearAbortController(options.abortController);\n                    return;\n                }\n                logDebug('WalletConnect connect error', error);\n                const event = {\n                    id: DEFAULT_EVENT_ID,\n                    event: 'connect_error',\n                    traceId: options.traceId,\n                    payload: {\n                        code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.USER_REJECTS_ERROR,\n                        message: 'User declined the connection'\n                    }\n                };\n                logDebug('WalletConnect connect response:', event);\n                this.emit(event);\n                this.clearAbortController(options.abortController);\n                return;\n            }\n            logDebug('Connected through this.connector.connect');\n            try {\n                yield this.onConnect(connector, Object.assign(Object.assign({}, options), { includeTonProof: true }));\n            }\n            catch (error) {\n                logDebug('WalletConnect onConnect error', error);\n                yield this.disconnect({ traceId: options.traceId, signal: options.signal });\n            }\n            finally {\n                this.clearAbortController(options.abortController);\n            }\n        });\n    }\n    restoreConnection(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n            (_b = this.abortController) === null || _b === void 0 ? void 0 : _b.abort();\n            this.abortController = abortController;\n            if (abortController.signal.aborted) {\n                return;\n            }\n            try {\n                logDebug('Restoring WalletConnect connection...');\n                const storedConnection = yield this.connectionStorage.getWalletConnectConnection();\n                if (!storedConnection || abortController.signal.aborted) {\n                    return;\n                }\n                const connector = yield this.initialize();\n                if (abortController.signal.aborted) {\n                    return;\n                }\n                yield this.onConnect(connector, {\n                    includeTonProof: false,\n                    traceId,\n                    signal: abortController.signal\n                });\n                logDebug('WalletConnect successfully restored.');\n            }\n            catch (error) {\n                logDebug('WalletConnect restore error', error);\n                yield this.disconnect({ traceId, signal: abortController.signal });\n            }\n            finally {\n                this.clearAbortController(abortController);\n            }\n        });\n    }\n    closeConnection() {\n        var _a;\n        (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort();\n        this.abortController = undefined;\n        void this.disconnect();\n    }\n    disconnect(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n            (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort();\n            this.abortController = abortController;\n            if (abortController.signal.aborted) {\n                return;\n            }\n            try {\n                yield this.connectionStorage.removeConnection();\n                if (abortController.signal.aborted) {\n                    return;\n                }\n                yield ((_b = this.connector) === null || _b === void 0 ? void 0 : _b.disconnect());\n            }\n            catch (error) {\n                logDebug('WalletConnect disconnect error', error);\n            }\n            finally {\n                this.clearAbortController(abortController);\n            }\n        });\n    }\n    sendRequest(request, optionsOrOnRequestSent) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d;\n            if (!this.connector) {\n                throw new TonConnectError('Wallet Connect not initialized');\n            }\n            const options = {};\n            if (typeof optionsOrOnRequestSent === 'function') {\n                options.onRequestSent = optionsOrOnRequestSent;\n            }\n            else {\n                options.onRequestSent = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.onRequestSent;\n                options.signal = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.signal;\n                options.attempts = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.attempts;\n                options.traceId = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.traceId;\n            }\n            (_a = options.traceId) !== null && _a !== void 0 ? _a : (options.traceId = UUIDv7());\n            try {\n                if ((_b = options.signal) === null || _b === void 0 ? void 0 : _b.aborted) {\n                    throw new TonConnectError('WalletConnect request aborted');\n                }\n                logDebug('Send wallet-connect request:', Object.assign(Object.assign({}, request), { id: DEFAULT_REQUEST_ID }));\n                if (request.method === 'sendTransaction') {\n                    const _e = JSON.parse(request.params[0]), { network } = _e, sendTransactionPayload = __rest(_e, [\"network\"]);\n                    const promise = this.connector.request({\n                        method: 'ton_sendMessage',\n                        params: sendTransactionPayload\n                    }, `ton:${network}`);\n                    (_c = options === null || options === void 0 ? void 0 : options.onRequestSent) === null || _c === void 0 ? void 0 : _c.call(options);\n                    const result = (yield promise);\n                    logDebug('Wallet message received:', { result, id: DEFAULT_REQUEST_ID });\n                    return {\n                        result,\n                        id: DEFAULT_REQUEST_ID,\n                        traceId: options.traceId\n                    };\n                }\n                else if (request.method === 'signData') {\n                    const _f = JSON.parse(request.params[0]), { network } = _f, signDataPayload = __rest(_f, [\"network\"]);\n                    const promise = this.connector.request({\n                        method: 'ton_signData',\n                        params: signDataPayload\n                    }, `ton:${network}`);\n                    (_d = options === null || options === void 0 ? void 0 : options.onRequestSent) === null || _d === void 0 ? void 0 : _d.call(options);\n                    const result = (yield promise);\n                    logDebug('Wallet message received:', { result, id: DEFAULT_REQUEST_ID });\n                    return { result, traceId: options.traceId, id: DEFAULT_REQUEST_ID };\n                }\n                else if (request.method === 'disconnect') {\n                    return {\n                        id: DEFAULT_REQUEST_ID,\n                        traceId: options.traceId\n                    };\n                }\n            }\n            catch (error) {\n                logDebug('WalletConnect request error', error, error.stack);\n                const result = (yield this.handleWalletConnectError(error, {\n                    traceId: options.traceId\n                }));\n                logDebug('Wallet message received:', result);\n                return result;\n            }\n            return {\n                id: DEFAULT_REQUEST_ID,\n                error: { code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.DISCONNECT_ERROR_CODES.UNKNOWN_ERROR, message: 'Not implemented.' },\n                traceId: options.traceId\n            };\n        });\n    }\n    handleWalletConnectError(error, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof error === 'object' && error !== null) {\n                const message = String('message' in error ? error.message : 'msg' in error ? error.msg : error);\n                if (message.toLowerCase().includes('reject')) {\n                    return {\n                        id: DEFAULT_REQUEST_ID,\n                        traceId: options.traceId,\n                        error: {\n                            code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.USER_REJECTS_ERROR,\n                            message\n                        }\n                    };\n                }\n                if (message.toLowerCase().includes('tonvalidationerror')) {\n                    return {\n                        id: DEFAULT_REQUEST_ID,\n                        traceId: options.traceId,\n                        error: {\n                            code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.BAD_REQUEST_ERROR,\n                            message\n                        }\n                    };\n                }\n                return {\n                    id: DEFAULT_REQUEST_ID,\n                    traceId: options.traceId,\n                    error: {\n                        code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.UNKNOWN_ERROR,\n                        message\n                    }\n                };\n            }\n            return {\n                id: DEFAULT_REQUEST_ID,\n                traceId: options.traceId,\n                error: {\n                    code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.UNKNOWN_ERROR,\n                    message: String(error)\n                }\n            };\n        });\n    }\n    listen(callback) {\n        this.listeners.push(callback);\n        return () => (this.listeners = this.listeners.filter(listener => listener !== callback));\n    }\n    buildTonProof(connector) {\n        var _a, _b, _c;\n        const auth = (_a = connector.provider.session.authentication) === null || _a === void 0 ? void 0 : _a[0];\n        const iat = (_b = auth === null || auth === void 0 ? void 0 : auth.p) === null || _b === void 0 ? void 0 : _b.iat;\n        const statement = (_c = auth === null || auth === void 0 ? void 0 : auth.p) === null || _c === void 0 ? void 0 : _c.statement;\n        if (!iat || !statement) {\n            return;\n        }\n        const domain = auth.p.domain;\n        return {\n            name: 'ton_proof',\n            proof: {\n                timestamp: Math.floor(new Date(iat).getTime() / 1000),\n                domain: {\n                    lengthBytes: domain.length,\n                    value: domain\n                },\n                payload: statement,\n                signature: auth.s.s\n            }\n        };\n    }\n    onConnect(connector, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d;\n            if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {\n                logDebug('WalletConnect onConnect aborted');\n                return;\n            }\n            const session = connector.provider.session;\n            const tonNamespace = session.namespaces['ton'];\n            if (!((_b = tonNamespace === null || tonNamespace === void 0 ? void 0 : tonNamespace.accounts) === null || _b === void 0 ? void 0 : _b[0])) {\n                yield this.disconnectWithError({\n                    traceId: options.traceId,\n                    code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.BAD_REQUEST_ERROR,\n                    message: 'Connection error. No TON accounts connected.'\n                });\n                return;\n            }\n            const account = tonNamespace.accounts[0];\n            const [, network, address] = account.split(':', 3);\n            const publicKey = (_c = session.sessionProperties) === null || _c === void 0 ? void 0 : _c.ton_getPublicKey;\n            if (!publicKey) {\n                yield this.disconnectWithError({\n                    traceId: options.traceId,\n                    code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.BAD_REQUEST_ERROR,\n                    message: 'Connection error. No sessionProperties.ton_getPublicKey provided.'\n                });\n                return;\n            }\n            const stateInit = (_d = session.sessionProperties) === null || _d === void 0 ? void 0 : _d.ton_getStateInit;\n            if (!stateInit) {\n                yield this.disconnectWithError({\n                    traceId: options.traceId,\n                    code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.BAD_REQUEST_ERROR,\n                    message: 'Connection error. No sessionProperties.ton_getStateInit provided.'\n                });\n                return;\n            }\n            connector.provider.once('session_delete', () => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    yield this.connectionStorage.removeConnection();\n                    const event = {\n                        event: 'disconnect',\n                        traceId: UUIDv7(),\n                        payload: {}\n                    };\n                    logDebug('Wallet message received:', event);\n                    this.emit(event);\n                }\n                catch (err) {\n                    logDebug('Error while deleting session', err);\n                }\n            }));\n            const tonProof = (options === null || options === void 0 ? void 0 : options.includeTonProof) ? this.buildTonProof(connector) : undefined;\n            const parsedAddress = isValidUserFriendlyAddress(address)\n                ? toRawAddress(parseUserFriendlyAddress(address))\n                : address;\n            const features = this.buildFeatureList(tonNamespace.methods);\n            const payload = {\n                items: [\n                    {\n                        name: 'ton_addr',\n                        address: parsedAddress,\n                        network: network,\n                        publicKey,\n                        walletStateInit: stateInit\n                    },\n                    ...(tonProof ? [tonProof] : [])\n                ],\n                device: {\n                    appName: 'wallet_connect',\n                    appVersion: '',\n                    maxProtocolVersion: 2,\n                    features,\n                    platform: 'browser'\n                }\n            };\n            logDebug('WalletConnect connect response:', {\n                event: 'connect',\n                payload,\n                id: DEFAULT_EVENT_ID\n            });\n            this.emit({ event: 'connect', payload, traceId: options.traceId });\n            yield this.storeConnection();\n        });\n    }\n    buildFeatureList(methods) {\n        const features = [];\n        if (methods.includes('ton_sendMessage')) {\n            features.push('SendTransaction', {\n                name: 'SendTransaction',\n                maxMessages: 4,\n                extraCurrencySupported: false\n            });\n        }\n        if (methods.includes('ton_signData')) {\n            features.push({ name: 'SignData', types: ['text', 'binary', 'cell'] });\n        }\n        return features;\n    }\n    disconnectWithError(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.disconnect();\n            const payload = {\n                code: options.code,\n                message: options.message\n            };\n            logDebug('WalletConnect connect response:', {\n                event: 'connect_error',\n                id: DEFAULT_EVENT_ID,\n                payload\n            });\n            this.emit({\n                event: 'connect_error',\n                traceId: options.traceId,\n                payload\n            });\n        });\n    }\n    clearAbortController(abortController) {\n        if (this.abortController === abortController) {\n            this.abortController = undefined;\n        }\n    }\n    emit(event, listeners) {\n        (listeners !== null && listeners !== void 0 ? listeners : this.listeners).forEach(listener => listener(event));\n    }\n    storeConnection() {\n        return this.connectionStorage.storeConnection({\n            type: 'wallet-connect'\n        });\n    }\n}\n\nclass TonConnect {\n    /**\n     * Returns available wallets list.\n     */\n    static getWallets() {\n        return this.walletsList.getWallets();\n    }\n    /**\n     * Shows if the wallet is connected right now.\n     */\n    get connected() {\n        return this._wallet !== null;\n    }\n    /**\n     * Current connected account or null if no account is connected.\n     */\n    get account() {\n        var _a;\n        return ((_a = this._wallet) === null || _a === void 0 ? void 0 : _a.account) || null;\n    }\n    /**\n     * Current connected wallet or null if no account is connected.\n     */\n    get wallet() {\n        return this._wallet;\n    }\n    set wallet(value) {\n        this._wallet = value;\n        this.statusChangeSubscriptions.forEach(callback => callback(this._wallet));\n    }\n    constructor(options) {\n        var _a, _b, _c;\n        this._wallet = null;\n        this.provider = null;\n        this.statusChangeSubscriptions = [];\n        this.statusChangeErrorSubscriptions = [];\n        const manifestUrl = (options === null || options === void 0 ? void 0 : options.manifestUrl) || getWebPageManifest();\n        this.dappSettings = {\n            manifestUrl,\n            storage: (options === null || options === void 0 ? void 0 : options.storage) || new DefaultStorage()\n        };\n        this.walletsRequiredFeatures = options === null || options === void 0 ? void 0 : options.walletsRequiredFeatures;\n        this.environment = (_a = options === null || options === void 0 ? void 0 : options.environment) !== null && _a !== void 0 ? _a : new DefaultEnvironment();\n        this.walletsList = new WalletsListManager({\n            walletsListSource: options === null || options === void 0 ? void 0 : options.walletsListSource,\n            cacheTTLMs: options === null || options === void 0 ? void 0 : options.walletsListCacheTTLMs,\n            onDownloadDurationMeasured: (duration) => {\n                var _a;\n                (_a = this.analytics) === null || _a === void 0 ? void 0 : _a.setWalletListDownloadDuration(duration);\n            }\n        });\n        const eventDispatcher = (_b = options === null || options === void 0 ? void 0 : options.eventDispatcher) !== null && _b !== void 0 ? _b : new BrowserEventDispatcher();\n        this.tracker = new TonConnectTracker({\n            eventDispatcher,\n            tonConnectSdkVersion: tonConnectSdkVersion\n        });\n        this.environment = (_c = options === null || options === void 0 ? void 0 : options.environment) !== null && _c !== void 0 ? _c : new DefaultEnvironment();\n        this.initAnalytics(manifestUrl, eventDispatcher, options);\n        if (!this.dappSettings.manifestUrl) {\n            throw new DappMetadataError('Dapp tonconnect-manifest.json must be specified if window.location.origin is undefined. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest');\n        }\n        this.bridgeConnectionStorage = new BridgeConnectionStorage(this.dappSettings.storage, this.walletsList);\n        if (!(options === null || options === void 0 ? void 0 : options.disableAutoPauseConnection)) {\n            this.addWindowFocusAndBlurSubscriptions();\n        }\n    }\n    /**\n     * Returns available wallets list.\n     */\n    getWallets() {\n        return this.walletsList.getWallets();\n    }\n    /**\n     * Allows to subscribe to connection status changes and handle connection errors.\n     * @param callback will be called after connections status changes with actual wallet or null.\n     * @param errorsHandler (optional) will be called with some instance of TonConnectError when connect error is received.\n     * @returns unsubscribe callback.\n     */\n    onStatusChange(callback, errorsHandler) {\n        this.statusChangeSubscriptions.push(callback);\n        if (errorsHandler) {\n            this.statusChangeErrorSubscriptions.push(errorsHandler);\n        }\n        return () => {\n            this.statusChangeSubscriptions = this.statusChangeSubscriptions.filter(item => item !== callback);\n            if (errorsHandler) {\n                this.statusChangeErrorSubscriptions = this.statusChangeErrorSubscriptions.filter(item => item !== errorsHandler);\n            }\n        };\n    }\n    // eslint-disable-next-line complexity\n    connect(wallet, requestOrOptions, additionalOptions) {\n        var _a, _b, _c;\n        // TODO: remove deprecated method\n        const options = Object.assign({}, additionalOptions);\n        if (typeof requestOrOptions === 'object' &&\n            requestOrOptions !== null &&\n            'tonProof' in requestOrOptions) {\n            options.request = requestOrOptions;\n        }\n        if (typeof requestOrOptions === 'object' &&\n            requestOrOptions !== null &&\n            ('openingDeadlineMS' in requestOrOptions ||\n                'signal' in requestOrOptions ||\n                'request' in requestOrOptions ||\n                'traceId' in requestOrOptions)) {\n            options.request = requestOrOptions === null || requestOrOptions === void 0 ? void 0 : requestOrOptions.request;\n            options.openingDeadlineMS = requestOrOptions === null || requestOrOptions === void 0 ? void 0 : requestOrOptions.openingDeadlineMS;\n            options.signal = requestOrOptions === null || requestOrOptions === void 0 ? void 0 : requestOrOptions.signal;\n        }\n        if (options.request) {\n            const validationError = validateConnectAdditionalRequest(options.request);\n            if (validationError) {\n                if (isQaModeEnabled()) {\n                    console.error('ConnectAdditionalRequest validation failed: ' + validationError);\n                }\n                else {\n                    throw new TonConnectError('ConnectAdditionalRequest validation failed: ' + validationError);\n                }\n            }\n        }\n        if (this.connected) {\n            throw new WalletAlreadyConnectedError();\n        }\n        const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n        (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort();\n        this.abortController = abortController;\n        if (abortController.signal.aborted) {\n            throw new TonConnectError('Connection was aborted');\n        }\n        (_b = this.provider) === null || _b === void 0 ? void 0 : _b.closeConnection();\n        this.provider = this.createProvider(wallet);\n        abortController.signal.addEventListener('abort', () => {\n            var _a;\n            (_a = this.provider) === null || _a === void 0 ? void 0 : _a.closeConnection();\n            this.provider = null;\n        });\n        const traceId = (_c = options === null || options === void 0 ? void 0 : options.traceId) !== null && _c !== void 0 ? _c : UUIDv7();\n        this.tracker.trackConnectionStarted(traceId);\n        return this.provider.connect(this.createConnectRequest(options === null || options === void 0 ? void 0 : options.request), {\n            openingDeadlineMS: options === null || options === void 0 ? void 0 : options.openingDeadlineMS,\n            signal: abortController.signal,\n            traceId\n        });\n    }\n    /**\n     * Try to restore existing session and reconnect to the corresponding wallet. Call it immediately when your app is loaded.\n     */\n    restoreConnection(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            this.tracker.trackConnectionRestoringStarted(traceId);\n            const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n            (_b = this.abortController) === null || _b === void 0 ? void 0 : _b.abort();\n            this.abortController = abortController;\n            if (abortController.signal.aborted) {\n                this.tracker.trackConnectionRestoringError('Connection restoring was aborted', traceId);\n                return;\n            }\n            // TODO: potentially race condition here\n            const [bridgeConnectionType, embeddedWallet] = yield Promise.all([\n                this.bridgeConnectionStorage.storedConnectionType(),\n                this.walletsList.getEmbeddedWallet()\n            ]);\n            if (abortController.signal.aborted) {\n                this.tracker.trackConnectionRestoringError('Connection restoring was aborted', traceId);\n                return;\n            }\n            let provider = null;\n            try {\n                switch (bridgeConnectionType) {\n                    case 'http':\n                        provider = yield BridgeProvider.fromStorage(this.bridgeConnectionStorage, this.analytics);\n                        break;\n                    case 'injected':\n                        provider = yield InjectedProvider.fromStorage(this.bridgeConnectionStorage, this.analytics);\n                        break;\n                    case 'wallet-connect':\n                        provider = yield WalletConnectProvider.fromStorage(this.bridgeConnectionStorage);\n                        break;\n                    default:\n                        if (embeddedWallet) {\n                            provider = this.createProvider(embeddedWallet);\n                        }\n                        else {\n                            return;\n                        }\n                }\n            }\n            catch (err) {\n                logDebug('Provider is not restored', err);\n                this.tracker.trackConnectionRestoringError('Provider is not restored', traceId);\n                yield this.bridgeConnectionStorage.removeConnection();\n                provider === null || provider === void 0 ? void 0 : provider.closeConnection();\n                provider = null;\n                return;\n            }\n            if (abortController.signal.aborted) {\n                provider === null || provider === void 0 ? void 0 : provider.closeConnection();\n                this.tracker.trackConnectionRestoringError('Connection restoring was aborted', traceId);\n                return;\n            }\n            if (!provider) {\n                logError('Provider is not restored');\n                this.tracker.trackConnectionRestoringError('Provider is not restored', traceId);\n                return;\n            }\n            (_c = this.provider) === null || _c === void 0 ? void 0 : _c.closeConnection();\n            this.provider = provider;\n            provider.listen(this.walletEventsListener.bind(this));\n            const onAbortRestore = () => {\n                this.tracker.trackConnectionRestoringError('Connection restoring was aborted', traceId);\n                provider === null || provider === void 0 ? void 0 : provider.closeConnection();\n                provider = null;\n            };\n            abortController.signal.addEventListener('abort', onAbortRestore);\n            const restoreConnectionTask = callForSuccess((_options) => __awaiter(this, void 0, void 0, function* () {\n                yield (provider === null || provider === void 0 ? void 0 : provider.restoreConnection({\n                    openingDeadlineMS: options === null || options === void 0 ? void 0 : options.openingDeadlineMS,\n                    signal: _options.signal,\n                    traceId\n                }));\n                abortController.signal.removeEventListener('abort', onAbortRestore);\n                if (this.connected) {\n                    const sessionInfo = this.getSessionInfo();\n                    this.tracker.trackConnectionRestoringCompleted(this.wallet, sessionInfo, traceId);\n                }\n                else {\n                    this.tracker.trackConnectionRestoringError('Connection restoring failed', traceId);\n                }\n            }), {\n                attempts: Number.MAX_SAFE_INTEGER,\n                delayMs: 2000,\n                signal: options === null || options === void 0 ? void 0 : options.signal\n            });\n            const restoreConnectionTimeout = new Promise(resolve => setTimeout(() => resolve(), 12000) // connection deadline\n            );\n            return Promise.race([restoreConnectionTask, restoreConnectionTimeout]);\n        });\n    }\n    sendTransaction(transaction, optionsOrOnRequestSent) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d;\n            // TODO: remove deprecated method\n            const options = {};\n            if (typeof optionsOrOnRequestSent === 'function') {\n                options.onRequestSent = optionsOrOnRequestSent;\n            }\n            else {\n                options.onRequestSent = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.onRequestSent;\n                options.signal = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.signal;\n                options.traceId = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.traceId;\n            }\n            // Validate transaction\n            const validationError = validateSendTransactionRequest(transaction);\n            if (validationError) {\n                if (isQaModeEnabled()) {\n                    console.error('SendTransactionRequest validation failed: ' + validationError);\n                }\n                else {\n                    throw new TonConnectError('SendTransactionRequest validation failed: ' + validationError);\n                }\n            }\n            const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n            if (abortController.signal.aborted) {\n                throw new TonConnectError('Transaction sending was aborted');\n            }\n            this.checkConnection();\n            const requiredMessagesNumber = transaction.messages.length;\n            const requireExtraCurrencies = transaction.messages.some(m => m.extraCurrency && Object.keys(m.extraCurrency).length > 0);\n            checkSendTransactionSupport(this.wallet.device.features, {\n                requiredMessagesNumber,\n                requireExtraCurrencies\n            });\n            const sessionInfo = this.getSessionInfo();\n            const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            this.tracker.trackTransactionSentForSignature(this.wallet, transaction, sessionInfo, traceId);\n            const { validUntil, messages } = transaction, tx = __rest(transaction, [\"validUntil\", \"messages\"]);\n            const from = transaction.from || this.account.address;\n            const network = transaction.network || this.account.chain;\n            if (((_b = this.wallet) === null || _b === void 0 ? void 0 : _b.account.chain) && network !== this.wallet.account.chain) {\n                if (!isQaModeEnabled()) {\n                    throw new WalletWrongNetworkError('Wallet connected to a wrong network', {\n                        cause: {\n                            expectedChainId: (_c = this.wallet) === null || _c === void 0 ? void 0 : _c.account.chain,\n                            actualChainId: network\n                        }\n                    });\n                }\n                console.error('Wallet connected to a wrong network', {\n                    expectedChainId: (_d = this.wallet) === null || _d === void 0 ? void 0 : _d.account.chain,\n                    actualChainId: network\n                });\n            }\n            const response = yield this.provider.sendRequest(sendTransactionParser.convertToRpcRequest(Object.assign(Object.assign({}, tx), { from,\n                network, valid_until: validUntil, messages: messages.map((_a) => {\n                    var { extraCurrency, payload, stateInit } = _a, msg = __rest(_a, [\"extraCurrency\", \"payload\", \"stateInit\"]);\n                    return (Object.assign(Object.assign({}, msg), { payload: normalizeBase64(payload), stateInit: normalizeBase64(stateInit), extra_currency: extraCurrency }));\n                }) })), {\n                onRequestSent: options.onRequestSent,\n                signal: abortController.signal,\n                traceId\n            });\n            if (sendTransactionParser.isError(response)) {\n                this.tracker.trackTransactionSigningFailed(this.wallet, transaction, response.error.message, response.error.code, sessionInfo, traceId);\n                return sendTransactionParser.parseAndThrowError(response);\n            }\n            const result = sendTransactionParser.convertFromRpcResponse(response);\n            this.tracker.trackTransactionSigned(this.wallet, transaction, result, sessionInfo, traceId);\n            return Object.assign(Object.assign({}, result), { traceId: response.traceId });\n        });\n    }\n    signData(data, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d;\n            const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n            if (abortController.signal.aborted) {\n                throw new TonConnectError('data sending was aborted');\n            }\n            // Validate sign data\n            const validationError = validateSignDataPayload(data);\n            if (validationError) {\n                if (isQaModeEnabled()) {\n                    console.error('SignDataPayload validation failed: ' + validationError);\n                }\n                else {\n                    throw new TonConnectError('SignDataPayload validation failed: ' + validationError);\n                }\n            }\n            this.checkConnection();\n            checkSignDataSupport(this.wallet.device.features, { requiredTypes: [data.type] });\n            const sessionInfo = this.getSessionInfo();\n            const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            this.tracker.trackDataSentForSignature(this.wallet, data, sessionInfo, traceId);\n            const from = data.from || this.account.address;\n            const network = data.network || this.account.chain;\n            if (((_b = this.wallet) === null || _b === void 0 ? void 0 : _b.account.chain) && network !== this.wallet.account.chain) {\n                if (!isQaModeEnabled()) {\n                    throw new WalletWrongNetworkError('Wallet connected to a wrong network', {\n                        cause: {\n                            expectedChainId: (_c = this.wallet) === null || _c === void 0 ? void 0 : _c.account.chain,\n                            actualChainId: network\n                        }\n                    });\n                }\n                console.error('Wallet connected to a wrong network', {\n                    expectedChainId: (_d = this.wallet) === null || _d === void 0 ? void 0 : _d.account.chain,\n                    actualChainId: network\n                });\n            }\n            const response = yield this.provider.sendRequest(signDataParser.convertToRpcRequest(Object.assign(Object.assign(Object.assign({}, data), (data.type === 'cell' ? { cell: normalizeBase64(data.cell) } : {})), { from,\n                network })), { onRequestSent: options === null || options === void 0 ? void 0 : options.onRequestSent, signal: abortController.signal, traceId });\n            if (signDataParser.isError(response)) {\n                this.tracker.trackDataSigningFailed(this.wallet, data, response.error.message, response.error.code, sessionInfo, traceId);\n                return signDataParser.parseAndThrowError(response);\n            }\n            const result = signDataParser.convertFromRpcResponse(response);\n            this.tracker.trackDataSigned(this.wallet, data, result, sessionInfo, traceId);\n            return Object.assign(Object.assign({}, result), { traceId });\n        });\n    }\n    /**\n     * Set desired network for the connection. Can only be set before connecting.\n     * If wallet connects with a different chain, the SDK will throw an error and abort connection.\n     * @param network desired network id (e.g., '-239', '-3', or custom). Pass undefined to allow any network.\n     */\n    setConnectionNetwork(network) {\n        if (this.connected) {\n            throw new TonConnectError('Cannot change network while wallet is connected');\n        }\n        this.desiredChainId = network;\n    }\n    /**\n     * Disconnect form thw connected wallet and drop current session.\n     */\n    disconnect(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            if (!this.connected) {\n                throw new WalletNotConnectedError();\n            }\n            const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n            const prevAbortController = this.abortController;\n            this.abortController = abortController;\n            if (abortController.signal.aborted) {\n                throw new TonConnectError('Disconnect was aborted');\n            }\n            const traceId = (_a = options === null || options === void 0 ? void 0 : options.traceId) !== null && _a !== void 0 ? _a : UUIDv7();\n            this.onWalletDisconnected('dapp', { traceId });\n            yield ((_b = this.provider) === null || _b === void 0 ? void 0 : _b.disconnect({\n                signal: abortController.signal,\n                traceId\n            }));\n            prevAbortController === null || prevAbortController === void 0 ? void 0 : prevAbortController.abort();\n        });\n    }\n    /**\n     * Gets the current session ID if available.\n     * @returns session ID string or null if not available.\n     */\n    getSessionId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.provider) {\n                return null;\n            }\n            try {\n                const connection = yield this.bridgeConnectionStorage.getConnection();\n                if (!connection || connection.type !== 'http') {\n                    return null;\n                }\n                if ('sessionCrypto' in connection) {\n                    // Pending connection\n                    return connection.sessionCrypto.sessionId;\n                }\n                else {\n                    // Established connection\n                    return connection.session.sessionCrypto.sessionId;\n                }\n            }\n            catch (_a) {\n                return null;\n            }\n        });\n    }\n    getSessionInfo() {\n        var _a;\n        if (((_a = this.provider) === null || _a === void 0 ? void 0 : _a.type) !== 'http') {\n            return null;\n        }\n        if (!('session' in this.provider)) {\n            return null;\n        }\n        try {\n            const session = this.provider.session;\n            if (!session) {\n                return null;\n            }\n            const clientId = session.sessionCrypto.sessionId;\n            let walletId = null;\n            if ('walletPublicKey' in session) {\n                walletId = session.walletPublicKey;\n            }\n            return { clientId, walletId };\n        }\n        catch (_b) {\n            return null;\n        }\n    }\n    /**\n     * Pause bridge HTTP connection. Might be helpful, if you want to pause connections while browser tab is unfocused,\n     * or if you use SDK with NodeJS and want to save server resources.\n     */\n    pauseConnection() {\n        var _a;\n        if (((_a = this.provider) === null || _a === void 0 ? void 0 : _a.type) !== 'http') {\n            return;\n        }\n        this.provider.pause();\n    }\n    /**\n     * Unpause bridge HTTP connection if it is paused.\n     */\n    unPauseConnection() {\n        var _a;\n        if (((_a = this.provider) === null || _a === void 0 ? void 0 : _a.type) !== 'http') {\n            return Promise.resolve();\n        }\n        return this.provider.unPause();\n    }\n    addWindowFocusAndBlurSubscriptions() {\n        const document = getDocument();\n        if (!document) {\n            return;\n        }\n        try {\n            document.addEventListener('visibilitychange', () => {\n                if (document.hidden) {\n                    this.pauseConnection();\n                }\n                else {\n                    this.unPauseConnection().catch(() => { });\n                }\n            });\n        }\n        catch (e) {\n            logError('Cannot subscribe to the document.visibilitychange: ', e);\n        }\n    }\n    initAnalytics(manifestUrl, eventDispatcher, options) {\n        var _a;\n        const analyticsSettings = options === null || options === void 0 ? void 0 : options.analytics;\n        const mode = (_a = analyticsSettings === null || analyticsSettings === void 0 ? void 0 : analyticsSettings.mode) !== null && _a !== void 0 ? _a : 'telemetry';\n        if (mode === 'off') {\n            return;\n        }\n        const analytics = new AnalyticsManager({\n            environment: this.environment,\n            mode\n        });\n        this.analytics = analytics;\n        const telegramUser = this.environment.getTelegramUser();\n        const sharedAnalyticsData = {\n            browser: this.environment.getBrowser(),\n            platform: this.environment.getPlatform(),\n            manifest_json_url: manifestUrl,\n            origin_url: getOriginWithPath,\n            locale: this.environment.getLocale()\n        };\n        if (telegramUser) {\n            sharedAnalyticsData.tg_id = telegramUser.id;\n            sharedAnalyticsData.tma_is_premium = telegramUser.isPremium;\n        }\n        bindEventsTo(eventDispatcher, analytics.scoped(sharedAnalyticsData));\n    }\n    createProvider(wallet) {\n        let provider;\n        if (!Array.isArray(wallet) && isWalletConnectionSourceJS(wallet)) {\n            provider = new InjectedProvider(this.bridgeConnectionStorage, wallet.jsBridgeKey, this.analytics);\n        }\n        else if (!Array.isArray(wallet) && isWalletConnectionSourceWalletConnect(wallet)) {\n            provider = new WalletConnectProvider(this.bridgeConnectionStorage);\n        }\n        else {\n            provider = new BridgeProvider(this.bridgeConnectionStorage, wallet, this.analytics);\n        }\n        provider.listen(this.walletEventsListener.bind(this));\n        return provider;\n    }\n    walletEventsListener(e) {\n        switch (e.event) {\n            case 'connect':\n                this.onWalletConnected(e.payload, { traceId: e.traceId });\n                break;\n            case 'connect_error':\n                this.tracker.trackConnectionError(e.payload.message, e.payload.code, this.getSessionInfo(), e.traceId);\n                const walletError = connectErrorsParser.parseError(e.payload);\n                this.onWalletConnectError(walletError);\n                break;\n            case 'disconnect':\n                this.onWalletDisconnected('wallet', { traceId: e.traceId });\n        }\n    }\n    onWalletConnected(connectEvent, options) {\n        var _a, _b;\n        const tonAccountItem = connectEvent.items.find(item => item.name === 'ton_addr');\n        const tonProofItem = connectEvent.items.find(item => item.name === 'ton_proof');\n        if (!tonAccountItem) {\n            throw new TonConnectError('ton_addr connection item was not found');\n        }\n        const hasRequiredFeatures = checkRequiredWalletFeatures(connectEvent.device.features, this.walletsRequiredFeatures);\n        if (!hasRequiredFeatures) {\n            (_a = this.provider) === null || _a === void 0 ? void 0 : _a.disconnect();\n            this.onWalletConnectError(new WalletMissingRequiredFeaturesError('Wallet does not support required features', { cause: { connectEvent } }));\n            return;\n        }\n        const wallet = {\n            device: connectEvent.device,\n            provider: this.provider.type,\n            account: {\n                address: tonAccountItem.address,\n                chain: tonAccountItem.network,\n                walletStateInit: tonAccountItem.walletStateInit,\n                publicKey: tonAccountItem.publicKey\n            }\n        };\n        if (this.desiredChainId && wallet.account.chain !== this.desiredChainId) {\n            const expectedChainId = this.desiredChainId;\n            const actualChainId = wallet.account.chain;\n            (_b = this.provider) === null || _b === void 0 ? void 0 : _b.disconnect();\n            this.onWalletConnectError(new WalletWrongNetworkError('Wallet connected to a wrong network', {\n                cause: { expectedChainId, actualChainId }\n            }));\n            return;\n        }\n        if (tonProofItem) {\n            const validationError = validateTonProofItemReply(tonProofItem);\n            let tonProof = undefined;\n            if (validationError) {\n                if (isQaModeEnabled()) {\n                    console.error('TonProofItem validation failed: ' + validationError);\n                }\n                tonProof = {\n                    name: 'ton_proof',\n                    error: {\n                        code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_ITEM_ERROR_CODES.UNKNOWN_ERROR,\n                        message: validationError\n                    }\n                };\n            }\n            else {\n                try {\n                    if ('proof' in tonProofItem) {\n                        tonProof = {\n                            name: 'ton_proof',\n                            proof: {\n                                timestamp: tonProofItem.proof.timestamp,\n                                domain: {\n                                    lengthBytes: tonProofItem.proof.domain.lengthBytes,\n                                    value: tonProofItem.proof.domain.value\n                                },\n                                payload: tonProofItem.proof.payload,\n                                signature: tonProofItem.proof.signature\n                            }\n                        };\n                    }\n                    else if ('error' in tonProofItem) {\n                        tonProof = {\n                            name: 'ton_proof',\n                            error: {\n                                code: tonProofItem.error.code,\n                                message: tonProofItem.error.message\n                            }\n                        };\n                    }\n                    else {\n                        throw new TonConnectError('Invalid data format');\n                    }\n                }\n                catch (e) {\n                    tonProof = {\n                        name: 'ton_proof',\n                        error: {\n                            code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_ITEM_ERROR_CODES.UNKNOWN_ERROR,\n                            message: 'Invalid data format'\n                        }\n                    };\n                }\n            }\n            wallet.connectItems = { tonProof };\n        }\n        this.wallet = wallet;\n        const sessionInfo = this.getSessionInfo();\n        this.tracker.trackConnectionCompleted(wallet, sessionInfo, options === null || options === void 0 ? void 0 : options.traceId);\n    }\n    onWalletConnectError(error) {\n        this.statusChangeErrorSubscriptions.forEach(errorsHandler => errorsHandler(error));\n        logDebug(error);\n        if (error instanceof ManifestNotFoundError || error instanceof ManifestContentErrorError) {\n            logError(error);\n            throw error;\n        }\n    }\n    onWalletDisconnected(scope, options) {\n        const sessionInfo = this.getSessionInfo();\n        this.tracker.trackDisconnection(this.wallet, scope, sessionInfo, options === null || options === void 0 ? void 0 : options.traceId);\n        this.wallet = null;\n    }\n    checkConnection() {\n        if (!this.connected) {\n            throw new WalletNotConnectedError();\n        }\n    }\n    createConnectRequest(request) {\n        const items = [\n            Object.assign({ name: 'ton_addr' }, (this.desiredChainId ? { network: this.desiredChainId } : {}))\n        ];\n        if (request === null || request === void 0 ? void 0 : request.tonProof) {\n            items.push({\n                name: 'ton_proof',\n                payload: request.tonProof\n            });\n        }\n        return {\n            manifestUrl: this.dappSettings.manifestUrl,\n            items\n        };\n    }\n}\nTonConnect.walletsList = new WalletsListManager();\n/**\n * Check if specified wallet is injected and available to use with the app.\n * @param walletJSKey target wallet's js bridge key.\n */\nTonConnect.isWalletInjected = (walletJSKey) => InjectedProvider.isWalletInjected(walletJSKey);\n/**\n * Check if the app is opened inside specified wallet's browser.\n * @param walletJSKey target wallet's js bridge key.\n */\nTonConnect.isInsideWalletBrowser = (walletJSKey) => InjectedProvider.isInsideWalletBrowser(walletJSKey);\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdG9uY29ubmVjdC9zZGsvbGliL2VzbS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStNO0FBQ3pDO0FBQzFIO0FBQ047O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdCQUF3QixFQUFFLHNCQUFzQixFQUFFLGtDQUFrQyxFQUFFLDhCQUE4QjtBQUM5STtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSywyRUFBeUI7QUFDOUIsS0FBSywyRUFBeUI7QUFDOUIsS0FBSywyRUFBeUI7QUFDOUIsS0FBSywyRUFBeUI7QUFDOUIsS0FBSywyRUFBeUI7QUFDOUIsS0FBSywyRUFBeUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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UyxLQUFLLDBEQUEwRDtBQUN4RSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPLEdBQUcsYUFBYTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTyxvQkFB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QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdEQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywyTkFBMk47QUFDcFE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SUFBNkk7QUFDN0k7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDRCQUE0QjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsOENBQThDLHdGQUF3RjtBQUM5TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxvQkFBb0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsUUFBUSxFQUFFLFdBQVc7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxNQUFNO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxRQUFRLEVBQUUsV0FBVztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxxQkFBcUIseUNBQXlDO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHNCQUFzQjtBQUM3RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCLHNFQUFzRSxtQ0FBbUMsNkNBQTZDO0FBQ3RKLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsNkVBQTZFLG1DQUFtQztBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYSxpSEFBaUg7QUFDOUgsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0lBQWdJLG1DQUFtQyxrTkFBa047QUFDclgsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHlDQUF5QztBQUN2Rix1Q0FBdUMsV0FBVztBQUNsRCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx5Q0FBeUM7QUFDdkYsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxnQkFBZ0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkVBQXlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLGNBQWMsdUJBQXVCO0FBQ25IO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrREFBa0Q7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MseUNBQXlDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsY0FBYyx3QkFBd0I7QUFDN0g7QUFDQSxnRUFBZ0UsVUFBVTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUyxRQUFRO0FBQ3RDO0FBQ0E7QUFDQSwyREFBMkQsZ0NBQWdDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFVBQVU7QUFDMUU7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVMsUUFBUTtBQUN0QztBQUNBO0FBQ0EsMkRBQTJELGdDQUFnQztBQUMzRiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsTUFBTSx3RUFBc0IsNkNBQTZDO0FBQ2xHO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsOEVBQTRCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw4RUFBNEI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4RUFBNEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4RUFBNEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJFQUF5QjtBQUNuRDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJFQUF5QjtBQUNuRDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkVBQXlCO0FBQ25EO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isd0JBQXdCLHFEQUFxRDtBQUM3RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSw0QkFBNEIscURBQXFEO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EscUlBQXFJLFNBQVM7QUFDOUk7QUFDQSwwQkFBMEIsb0NBQW9DO0FBQzlELDBEQUEwRCxVQUFVLHlHQUF5RztBQUM3SyxpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGFBQWEsMkJBQTJCO0FBQ3pGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSw0QkFBNEI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsNElBQTRJLG1DQUFtQyxtQ0FBbUMsSUFBSSxNQUFNO0FBQzVOLHlCQUF5QixNQUFNLGlJQUFpSTtBQUNoSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYSxTQUFTO0FBQ3ZFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsb0JBQW9CO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELG9CQUFvQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEgsU0FBUyxnQkFBZ0I7QUFDcko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBFQUF3QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDBFQUF3QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQiwyQkFBMkIsK0JBQStCLElBQUk7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXl6QztBQUN6ekMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0b25jb25uZWN0L3Nkay9saWIvZXNtL2luZGV4Lm1qcz81NmYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVMsIFNFTkRfVFJBTlNBQ1RJT05fRVJST1JfQ09ERVMsIFNJR05fREFUQV9FUlJPUl9DT0RFUywgQmFzZTY0LCBTZXNzaW9uQ3J5cHRvLCBoZXhUb0J5dGVBcnJheSwgRElTQ09OTkVDVF9FUlJPUl9DT0RFUywgQ09OTkVDVF9JVEVNX0VSUk9SX0NPREVTIH0gZnJvbSAnQHRvbmNvbm5lY3QvcHJvdG9jb2wnO1xuZXhwb3J0IHsgQ0hBSU4sIENPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVMsIENPTk5FQ1RfSVRFTV9FUlJPUl9DT0RFUywgU0VORF9UUkFOU0FDVElPTl9FUlJPUl9DT0RFUywgU0lHTl9EQVRBX0VSUk9SX0NPREVTLCBTZXNzaW9uQ3J5cHRvIH0gZnJvbSAnQHRvbmNvbm5lY3QvcHJvdG9jb2wnO1xuaW1wb3J0ICdAdG9uY29ubmVjdC9pc29tb3JwaGljLWV2ZW50c291cmNlJztcbmltcG9ydCAnQHRvbmNvbm5lY3QvaXNvbW9ycGhpYy1mZXRjaCc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wsIEl0ZXJhdG9yICovXHJcblxyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBUb25Db25uZWN0IGVycm9ycy4gWW91IGNhbiBjaGVjayBpZiB0aGUgZXJyb3Igd2FzIHRyaWdnZXJlZCBieSB0aGUgQHRvbmNvbm5lY3Qvc2RrIHVzaW5nIGBlcnIgaW5zdGFuY2VvZiBUb25Db25uZWN0RXJyb3JgLlxuICovXG5jbGFzcyBUb25Db25uZWN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gYCR7VG9uQ29ubmVjdEVycm9yLnByZWZpeH0gJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9JHt0aGlzLmluZm8gPyAnOiAnICsgdGhpcy5pbmZvIDogJyd9JHttZXNzYWdlID8gJ1xcbicgKyBtZXNzYWdlIDogJyd9YDtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFRvbkNvbm5lY3RFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cblRvbkNvbm5lY3RFcnJvci5wcmVmaXggPSAnW1RPTl9DT05ORUNUX1NES19FUlJPUl0nO1xuXG4vKipcbiAqIFRocm93biB3aGVuIHBhc3NlZCBEYXBwTWV0YWRhdGEgaXMgaW4gaW5jb3JyZWN0IGZvcm1hdC5cbiAqL1xuY2xhc3MgRGFwcE1ldGFkYXRhRXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJ1Bhc3NlZCBEYXBwTWV0YWRhdGEgaXMgaW4gaW5jb3JyZWN0IGZvcm1hdC4nO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgRGFwcE1ldGFkYXRhRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gcGFzc2VkIG1hbmlmZXN0IGNvbnRhaW5zIGVycm9ycy5cbiAqL1xuY2xhc3MgTWFuaWZlc3RDb250ZW50RXJyb3JFcnJvciBleHRlbmRzIFRvbkNvbm5lY3RFcnJvciB7XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiAnUGFzc2VkIGB0b25jb25uZWN0LW1hbmlmZXN0Lmpzb25gIGNvbnRhaW5zIGVycm9ycy4gQ2hlY2sgZm9ybWF0IG9mIHlvdXIgbWFuaWZlc3QuIFNlZSBtb3JlIGh0dHBzOi8vZ2l0aHViLmNvbS90b24tY29ubmVjdC9kb2NzL2Jsb2IvbWFpbi9yZXF1ZXN0cy1yZXNwb25zZXMubWQjYXBwLW1hbmlmZXN0JztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIE1hbmlmZXN0Q29udGVudEVycm9yRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gd2FsbGV0IGNhbid0IGdldCBtYW5pZmVzdCBieSBwYXNzZWQgbWFuaWZlc3RVcmwuXG4gKi9cbmNsYXNzIE1hbmlmZXN0Tm90Rm91bmRFcnJvciBleHRlbmRzIFRvbkNvbm5lY3RFcnJvciB7XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiAnTWFuaWZlc3Qgbm90IGZvdW5kLiBNYWtlIHN1cmUgeW91IGFkZGVkIGB0b25jb25uZWN0LW1hbmlmZXN0Lmpzb25gIHRvIHRoZSByb290IG9mIHlvdXIgYXBwIG9yIHBhc3NlZCBjb3JyZWN0IG1hbmlmZXN0VXJsLiBTZWUgbW9yZSBodHRwczovL2dpdGh1Yi5jb20vdG9uLWNvbm5lY3QvZG9jcy9ibG9iL21haW4vcmVxdWVzdHMtcmVzcG9uc2VzLm1kI2FwcC1tYW5pZmVzdCc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBNYW5pZmVzdE5vdEZvdW5kRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gd2FsbGV0IGNvbm5lY3Rpb24gY2FsbGVkIGJ1dCB3YWxsZXQgYWxyZWFkeSBjb25uZWN0ZWQuIFRvIGF2b2lkIHRoZSBlcnJvciwgZGlzY29ubmVjdCB0aGUgd2FsbGV0IGJlZm9yZSBkb2luZyBhIG5ldyBjb25uZWN0aW9uLlxuICovXG5jbGFzcyBXYWxsZXRBbHJlYWR5Q29ubmVjdGVkRXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJ1dhbGxldCBjb25uZWN0aW9uIGNhbGxlZCBidXQgd2FsbGV0IGFscmVhZHkgY29ubmVjdGVkLiBUbyBhdm9pZCB0aGUgZXJyb3IsIGRpc2Nvbm5lY3QgdGhlIHdhbGxldCBiZWZvcmUgZG9pbmcgYSBuZXcgY29ubmVjdGlvbi4nO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgV2FsbGV0QWxyZWFkeUNvbm5lY3RlZEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIHNlbmQgdHJhbnNhY3Rpb24gb3Igb3RoZXIgcHJvdG9jb2wgbWV0aG9kcyBjYWxsZWQgd2hpbGUgd2FsbGV0IGlzIG5vdCBjb25uZWN0ZWQuXG4gKi9cbmNsYXNzIFdhbGxldE5vdENvbm5lY3RlZEVycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuICdTZW5kIHRyYW5zYWN0aW9uIG9yIG90aGVyIHByb3RvY29sIG1ldGhvZHMgY2FsbGVkIHdoaWxlIHdhbGxldCBpcyBub3QgY29ubmVjdGVkLic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBXYWxsZXROb3RDb25uZWN0ZWRFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGVyZSBpcyBhbiBhdHRlbXB0IHRvIGNvbm5lY3QgdG8gdGhlIGluamVjdGVkIHdhbGxldCB3aGlsZSBpdCBpcyBub3QgZXhpc3RzIGluIHRoZSB3ZWJwYWdlLlxuICovXG5jbGFzcyBXYWxsZXROb3RJbmplY3RlZEVycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuICdUaGVyZSBpcyBhbiBhdHRlbXB0IHRvIGNvbm5lY3QgdG8gdGhlIGluamVjdGVkIHdhbGxldCB3aGlsZSBpdCBpcyBub3QgZXhpc3RzIGluIHRoZSB3ZWJwYWdlLic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBXYWxsZXROb3RJbmplY3RlZEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIHdhbGxldCBkb2Vzbid0IHN1cHBvcnQgcmVxdWVzdGVkIGZlYXR1cmUgbWV0aG9kLlxuICovXG5jbGFzcyBXYWxsZXROb3RTdXBwb3J0RmVhdHVyZUVycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuIFwiV2FsbGV0IGRvZXNuJ3Qgc3VwcG9ydCByZXF1ZXN0ZWQgZmVhdHVyZSBtZXRob2QuXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBXYWxsZXROb3RTdXBwb3J0RmVhdHVyZUVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIHdhbGxldCBjYW4ndCBnZXQgbWFuaWZlc3QgYnkgcGFzc2VkIG1hbmlmZXN0VXJsLlxuICovXG5jbGFzcyBXYWxsZXRNaXNzaW5nUmVxdWlyZWRGZWF0dXJlc0Vycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuICdNaXNzaW5nIHJlcXVpcmVkIGZlYXR1cmVzLiBZb3UgbmVlZCB0byB1cGRhdGUgeW91ciB3YWxsZXQuJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFdhbGxldE1pc3NpbmdSZXF1aXJlZEZlYXR1cmVzRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbmNsYXNzIFdhbGxldFdyb25nTmV0d29ya0Vycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0V3JvbmdOZXR3b3JrRXJyb3InO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgV2FsbGV0V3JvbmdOZXR3b3JrRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzV2FsbGV0Q29ubmVjdGlvblNvdXJjZUpTKHZhbHVlKSB7XG4gICAgcmV0dXJuICdqc0JyaWRnZUtleScgaW4gdmFsdWU7XG59XG5mdW5jdGlvbiBpc1dhbGxldENvbm5lY3Rpb25Tb3VyY2VXYWxsZXRDb25uZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuICd0eXBlJyBpbiB2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSAnd2FsbGV0LWNvbm5lY3QnO1xufVxuXG4vKipcbiAqIFRocm93biB3aGVuIHVzZXIgcmVqZWN0cyB0aGUgYWN0aW9uIGluIHRoZSB3YWxsZXQuXG4gKi9cbmNsYXNzIFVzZXJSZWplY3RzRXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJ1VzZXIgcmVqZWN0cyB0aGUgYWN0aW9uIGluIHRoZSB3YWxsZXQuJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFVzZXJSZWplY3RzRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gcmVxdWVzdCB0byB0aGUgd2FsbGV0IGNvbnRhaW5zIGVycm9ycy5cbiAqL1xuY2xhc3MgQmFkUmVxdWVzdEVycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuICdSZXF1ZXN0IHRvIHRoZSB3YWxsZXQgY29udGFpbnMgZXJyb3JzLic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBCYWRSZXF1ZXN0RXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYXBwIHRyaWVzIHRvIHNlbmQgcnBjIHJlcXVlc3QgdG8gdGhlIGluamVjdGVkIHdhbGxldCB3aGlsZSBub3QgY29ubmVjdGVkLlxuICovXG5jbGFzcyBVbmtub3duQXBwRXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJ0FwcCB0cmllcyB0byBzZW5kIHJwYyByZXF1ZXN0IHRvIHRoZSBpbmplY3RlZCB3YWxsZXQgd2hpbGUgbm90IGNvbm5lY3RlZC4nO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgVW5rbm93bkFwcEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIGBTdG9yYWdlYCB3YXMgbm90IHNwZWNpZmllZCBpbiB0aGUgYERhcHBNZXRhZGF0YWAgYW5kIGRlZmF1bHQgYGxvY2FsU3RvcmFnZWAgd2FzIG5vdCBkZXRlY3RlZCBpbiB0aGUgTm9kZS5qcyBlbnZpcm9ubWVudC5cbiAqL1xuY2xhc3MgTG9jYWxzdG9yYWdlTm90Rm91bmRFcnJvciBleHRlbmRzIFRvbkNvbm5lY3RFcnJvciB7XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiAnU3RvcmFnZSB3YXMgbm90IHNwZWNpZmllZCBpbiB0aGUgYERhcHBNZXRhZGF0YWAgYW5kIGRlZmF1bHQgYGxvY2FsU3RvcmFnZWAgd2FzIG5vdCBkZXRlY3RlZCBpbiB0aGUgZW52aXJvbm1lbnQuJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIExvY2Fsc3RvcmFnZU5vdEZvdW5kRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgZmV0Y2hpbmcgdGhlIHdhbGxldHMgbGlzdC5cbiAqL1xuY2xhc3MgRmV0Y2hXYWxsZXRzRXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxlIGZldGNoaW5nIHRoZSB3YWxsZXRzIGxpc3QuJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEZldGNoV2FsbGV0c0Vycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIHBhc3NlZCBhZGRyZXNzIGlzIGluIGluY29ycmVjdCBmb3JtYXQuXG4gKi9cbmNsYXNzIFdyb25nQWRkcmVzc0Vycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuICdQYXNzZWQgYWRkcmVzcyBpcyBpbiBpbmNvcnJlY3QgZm9ybWF0Lic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBXcm9uZ0FkZHJlc3NFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiBwYXNzZWQgaGV4IGlzIGluIGluY29ycmVjdCBmb3JtYXQuXG4gKi9cbmNsYXNzIFBhcnNlSGV4RXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJ1Bhc3NlZCBoZXggaXMgaW4gaW5jb3JyZWN0IGZvcm1hdC4nO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgUGFyc2VIZXhFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBVbmhhbmRlZCB1bmtub3duIGVycm9yLlxuICovXG5jbGFzcyBVbmtub3duRXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBVbmtub3duRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbmNvbnN0IGNvbm5lY3RFdmVudEVycm9yc0NvZGVzID0ge1xuICAgIFtDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTLlVOS05PV05fRVJST1JdOiBVbmtub3duRXJyb3IsXG4gICAgW0NPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVMuVVNFUl9SRUpFQ1RTX0VSUk9SXTogVXNlclJlamVjdHNFcnJvcixcbiAgICBbQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFUy5CQURfUkVRVUVTVF9FUlJPUl06IEJhZFJlcXVlc3RFcnJvcixcbiAgICBbQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFUy5VTktOT1dOX0FQUF9FUlJPUl06IFVua25vd25BcHBFcnJvcixcbiAgICBbQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFUy5NQU5JRkVTVF9OT1RfRk9VTkRfRVJST1JdOiBNYW5pZmVzdE5vdEZvdW5kRXJyb3IsXG4gICAgW0NPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVMuTUFOSUZFU1RfQ09OVEVOVF9FUlJPUl06IE1hbmlmZXN0Q29udGVudEVycm9yRXJyb3Jcbn07XG5jbGFzcyBDb25uZWN0RXJyb3JzUGFyc2VyIHtcbiAgICBwYXJzZUVycm9yKGVycm9yKSB7XG4gICAgICAgIGxldCBFcnJvckNvbnN0cnVjdG9yID0gVW5rbm93bkVycm9yO1xuICAgICAgICBpZiAoZXJyb3IuY29kZSBpbiBjb25uZWN0RXZlbnRFcnJvcnNDb2Rlcykge1xuICAgICAgICAgICAgRXJyb3JDb25zdHJ1Y3RvciA9IGNvbm5lY3RFdmVudEVycm9yc0NvZGVzW2Vycm9yLmNvZGVdIHx8IFVua25vd25FcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yQ29uc3RydWN0b3IoZXJyb3IubWVzc2FnZSk7XG4gICAgfVxufVxuY29uc3QgY29ubmVjdEVycm9yc1BhcnNlciA9IG5ldyBDb25uZWN0RXJyb3JzUGFyc2VyKCk7XG5cbmNsYXNzIFJwY1BhcnNlciB7XG4gICAgaXNFcnJvcihyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gJ2Vycm9yJyBpbiByZXNwb25zZTtcbiAgICB9XG59XG5cbmNvbnN0IHNlbmRUcmFuc2FjdGlvbkVycm9ycyA9IHtcbiAgICBbU0VORF9UUkFOU0FDVElPTl9FUlJPUl9DT0RFUy5VTktOT1dOX0VSUk9SXTogVW5rbm93bkVycm9yLFxuICAgIFtTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTLlVTRVJfUkVKRUNUU19FUlJPUl06IFVzZXJSZWplY3RzRXJyb3IsXG4gICAgW1NFTkRfVFJBTlNBQ1RJT05fRVJST1JfQ09ERVMuQkFEX1JFUVVFU1RfRVJST1JdOiBCYWRSZXF1ZXN0RXJyb3IsXG4gICAgW1NFTkRfVFJBTlNBQ1RJT05fRVJST1JfQ09ERVMuVU5LTk9XTl9BUFBfRVJST1JdOiBVbmtub3duQXBwRXJyb3Jcbn07XG5jbGFzcyBTZW5kVHJhbnNhY3Rpb25QYXJzZXIgZXh0ZW5kcyBScGNQYXJzZXIge1xuICAgIGNvbnZlcnRUb1JwY1JlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWV0aG9kOiAnc2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgIHBhcmFtczogW0pTT04uc3RyaW5naWZ5KHJlcXVlc3QpXVxuICAgICAgICB9O1xuICAgIH1cbiAgICBwYXJzZUFuZFRocm93RXJyb3IocmVzcG9uc2UpIHtcbiAgICAgICAgbGV0IEVycm9yQ29uc3RydWN0b3IgPSBVbmtub3duRXJyb3I7XG4gICAgICAgIGlmIChyZXNwb25zZS5lcnJvci5jb2RlIGluIHNlbmRUcmFuc2FjdGlvbkVycm9ycykge1xuICAgICAgICAgICAgRXJyb3JDb25zdHJ1Y3RvciA9IHNlbmRUcmFuc2FjdGlvbkVycm9yc1tyZXNwb25zZS5lcnJvci5jb2RlXSB8fCBVbmtub3duRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yQ29uc3RydWN0b3IocmVzcG9uc2UuZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnZlcnRGcm9tUnBjUmVzcG9uc2UocnBjUmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJvYzogcnBjUmVzcG9uc2UucmVzdWx0XG4gICAgICAgIH07XG4gICAgfVxufVxuY29uc3Qgc2VuZFRyYW5zYWN0aW9uUGFyc2VyID0gbmV3IFNlbmRUcmFuc2FjdGlvblBhcnNlcigpO1xuXG5jb25zdCBzaWduRGF0YUVycm9ycyA9IHtcbiAgICBbU0lHTl9EQVRBX0VSUk9SX0NPREVTLlVOS05PV05fRVJST1JdOiBVbmtub3duRXJyb3IsXG4gICAgW1NJR05fREFUQV9FUlJPUl9DT0RFUy5VU0VSX1JFSkVDVFNfRVJST1JdOiBVc2VyUmVqZWN0c0Vycm9yLFxuICAgIFtTSUdOX0RBVEFfRVJST1JfQ09ERVMuQkFEX1JFUVVFU1RfRVJST1JdOiBCYWRSZXF1ZXN0RXJyb3IsXG4gICAgW1NJR05fREFUQV9FUlJPUl9DT0RFUy5VTktOT1dOX0FQUF9FUlJPUl06IFVua25vd25BcHBFcnJvclxufTtcbmNsYXNzIFNpZ25EYXRhUGFyc2VyIGV4dGVuZHMgUnBjUGFyc2VyIHtcbiAgICBjb252ZXJ0VG9ScGNSZXF1ZXN0KHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ3NpZ25EYXRhJyxcbiAgICAgICAgICAgIHBhcmFtczogW0pTT04uc3RyaW5naWZ5KHBheWxvYWQpXVxuICAgICAgICB9O1xuICAgIH1cbiAgICBwYXJzZUFuZFRocm93RXJyb3IocmVzcG9uc2UpIHtcbiAgICAgICAgbGV0IEVycm9yQ29uc3RydWN0b3IgPSBVbmtub3duRXJyb3I7XG4gICAgICAgIGlmIChyZXNwb25zZS5lcnJvci5jb2RlIGluIHNpZ25EYXRhRXJyb3JzKSB7XG4gICAgICAgICAgICBFcnJvckNvbnN0cnVjdG9yID0gc2lnbkRhdGFFcnJvcnNbcmVzcG9uc2UuZXJyb3IuY29kZV0gfHwgVW5rbm93bkVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvckNvbnN0cnVjdG9yKHJlc3BvbnNlLmVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBjb252ZXJ0RnJvbVJwY1Jlc3BvbnNlKHJwY1Jlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBycGNSZXNwb25zZS5yZXN1bHQ7XG4gICAgfVxufVxuY29uc3Qgc2lnbkRhdGFQYXJzZXIgPSBuZXcgU2lnbkRhdGFQYXJzZXIoKTtcblxuY2xhc3MgSHR0cEJyaWRnZUdhdGV3YXlTdG9yYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihzdG9yYWdlLCBicmlkZ2VVcmwpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICAgICAgdGhpcy5zdG9yZUtleSA9ICd0b24tY29ubmVjdC1zdG9yYWdlX2h0dHAtYnJpZGdlLWdhdGV3YXk6OicgKyBicmlkZ2VVcmw7XG4gICAgfVxuICAgIHN0b3JlTGFzdEV2ZW50SWQobGFzdEV2ZW50SWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnN0b3JlS2V5LCBsYXN0RXZlbnRJZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVMYXN0RXZlbnRJZCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnN0b3JlS2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldExhc3RFdmVudElkKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkID0geWllbGQgdGhpcy5zdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yZUtleSk7XG4gICAgICAgICAgICBpZiAoIXN0b3JlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0b3JlZDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVVcmxMYXN0U2xhc2godXJsKSB7XG4gICAgaWYgKHVybC5zbGljZSgtMSkgPT09ICcvJykge1xuICAgICAgICByZXR1cm4gdXJsLnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbn1cbmZ1bmN0aW9uIGFkZFBhdGhUb1VybCh1cmwsIHBhdGgpIHtcbiAgICByZXR1cm4gcmVtb3ZlVXJsTGFzdFNsYXNoKHVybCkgKyAnLycgKyBwYXRoO1xufVxuZnVuY3Rpb24gaXNUZWxlZ3JhbVVybChsaW5rKSB7XG4gICAgaWYgKCFsaW5rKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChsaW5rKTtcbiAgICByZXR1cm4gdXJsLnByb3RvY29sID09PSAndGc6JyB8fCB1cmwuaG9zdG5hbWUgPT09ICd0Lm1lJztcbn1cbmZ1bmN0aW9uIGlzQ29ubmVjdFVybChsaW5rKSB7XG4gICAgaWYgKCFsaW5rKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmsuaW5jbHVkZXMoJ3Rvbl9hZGRyJykgfHwgbGluay5pbmNsdWRlcygndG9uLS01RmFkZHInKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVRlbGVncmFtVXJsUGFyYW1ldGVycyhwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIHBhcmFtZXRlcnNcbiAgICAgICAgLnJlcGxhY2VBbGwoJy4nLCAnJTJFJylcbiAgICAgICAgLnJlcGxhY2VBbGwoJy0nLCAnJTJEJylcbiAgICAgICAgLnJlcGxhY2VBbGwoJ18nLCAnJTVGJylcbiAgICAgICAgLnJlcGxhY2VBbGwoJyYnLCAnLScpXG4gICAgICAgIC5yZXBsYWNlQWxsKCc9JywgJ19fJylcbiAgICAgICAgLnJlcGxhY2VBbGwoJyUnLCAnLS0nKTtcbn1cbmZ1bmN0aW9uIGRlY29kZVRlbGVncmFtVXJsUGFyYW1ldGVycyhwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIHBhcmFtZXRlcnNcbiAgICAgICAgLnJlcGxhY2VBbGwoJy0tJywgJyUnKVxuICAgICAgICAucmVwbGFjZUFsbCgnX18nLCAnPScpXG4gICAgICAgIC5yZXBsYWNlQWxsKCctJywgJyYnKVxuICAgICAgICAucmVwbGFjZUFsbCgnJTVGJywgJ18nKVxuICAgICAgICAucmVwbGFjZUFsbCgnJTJEJywgJy0nKVxuICAgICAgICAucmVwbGFjZUFsbCgnJTJFJywgJy4nKTtcbn1cblxuLyoqXG4gKiBEZWxheXMgdGhlIGV4ZWN1dGlvbiBvZiBjb2RlIGZvciBhIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgLSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSB0aGUgZXhlY3V0aW9uLlxuICogQHBhcmFtIHtEZWxheU9wdGlvbnN9IFtvcHRpb25zXSAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIGRlbGF5LlxuICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB0aGUgc3BlY2lmaWVkIGRlbGF5LCBvciByZWplY3RzIGlmIHRoZSBkZWxheSBpcyBhYm9ydGVkLlxuICovXG5mdW5jdGlvbiBkZWxheSh0aW1lb3V0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoKF9hID0gdm9pZCAwICkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IFRvbkNvbm5lY3RFcnJvcignRGVsYXkgYWJvcnRlZCcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoKSwgdGltZW91dCk7XG4gICAgICAgICAgICAoX2IgPSB2b2lkIDAgKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUb25Db25uZWN0RXJyb3IoJ0RlbGF5IGFib3J0ZWQnKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBBYm9ydENvbnRyb2xsZXIgaW5zdGFuY2Ugd2l0aCBhbiBvcHRpb25hbCBBYm9ydFNpZ25hbC5cbiAqXG4gKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBbc2lnbmFsXSAtIEFuIG9wdGlvbmFsIEFib3J0U2lnbmFsIHRvIHVzZSBmb3IgYWJvcnRpbmcgdGhlIGNvbnRyb2xsZXIuXG4gKiBAcmV0dXJucyB7QWJvcnRDb250cm9sbGVyfSAtIEFuIGluc3RhbmNlIG9mIEFib3J0Q29udHJvbGxlci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQWJvcnRDb250cm9sbGVyKHNpZ25hbCkge1xuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBpZiAoc2lnbmFsID09PSBudWxsIHx8IHNpZ25hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzaWduYWwgPT09IG51bGwgfHwgc2lnbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYWJvcnRDb250cm9sbGVyO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRvIGNhbGwgdG9uIGFwaSB1bnRpbCB3ZSBnZXQgcmVzcG9uc2UuXG4gKiBCZWNhdXNlIHRvbiBuZXR3b3JrIGlzIHByZXR0eSB1bnN0YWJsZSB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSByZXNwb25zZSBpcyBmaW5hbC5cbiAqIEBwYXJhbSB7VH0gZm4gLSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0ge0NhbGxGb3JTdWNjZXNzT3B0aW9uc30gW29wdGlvbnNdIC0gb3B0aW9uYWwgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBjYWxsRm9yU3VjY2Vzcyhmbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGF0dGVtcHRzID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF0dGVtcHRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxMDtcbiAgICAgICAgY29uc3QgZGVsYXlNcyA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZWxheU1zKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAyMDA7XG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IGNyZWF0ZUFib3J0Q29udHJvbGxlcihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsKTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcihgRXhwZWN0ZWQgYSBmdW5jdGlvbiwgZ290ICR7dHlwZW9mIGZufWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IGxhc3RFcnJvcjtcbiAgICAgICAgd2hpbGUgKGkgPCBhdHRlbXB0cykge1xuICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoYEFib3J0ZWQgYWZ0ZXIgYXR0ZW1wdHMgJHtpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgZm4oeyBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbGFzdEVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBpZiAoaSA8IGF0dGVtcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGRlbGF5KGRlbGF5TXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBsYXN0RXJyb3I7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGxvZ0RlYnVnKC4uLmFyZ3MpIHtcbiAgICB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdbVE9OX0NPTk5FQ1RfU0RLXScsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgfVxufVxuZnVuY3Rpb24gbG9nRXJyb3IoLi4uYXJncykge1xuICAgIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tUT05fQ09OTkVDVF9TREtdJywgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICB9XG59XG5mdW5jdGlvbiBsb2dXYXJuaW5nKC4uLmFyZ3MpIHtcbiAgICB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tUT05fQ09OTkVDVF9TREtdJywgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVzb3VyY2UuXG4gKlxuICogQHRlbXBsYXRlIFQgLSBUaGUgdHlwZSBvZiB0aGUgcmVzb3VyY2UuXG4gKiBAdGVtcGxhdGUgQXJncyAtIFRoZSB0eXBlIG9mIHRoZSBhcmd1bWVudHMgZm9yIGNyZWF0aW5nIHRoZSByZXNvdXJjZS5cbiAqXG4gKiBAcGFyYW0geyguLi5hcmdzOiBBcmdzKSA9PiBQcm9taXNlPFQ+fSBjcmVhdGVGbiAtIEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSByZXNvdXJjZS5cbiAqIEBwYXJhbSB7KHJlc291cmNlOiBUKSA9PiBQcm9taXNlPHZvaWQ+fSBbZGlzcG9zZUZuXSAtIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgZGlzcG9zZXMgdGhlIHJlc291cmNlLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gY3JlYXRlUmVzb3VyY2UoY3JlYXRlRm4sIGRpc3Bvc2VGbikge1xuICAgIGxldCBjdXJyZW50UmVzb3VyY2UgPSBudWxsO1xuICAgIGxldCBjdXJyZW50QXJncyA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnRQcm9taXNlID0gbnVsbDtcbiAgICBsZXQgY3VycmVudFNpZ25hbCA9IG51bGw7XG4gICAgbGV0IGFib3J0Q29udHJvbGxlciA9IG51bGw7XG4gICAgLy8gY3JlYXRlIGEgbmV3IHJlc291cmNlXG4gICAgY29uc3QgY3JlYXRlID0gKHNpZ25hbCwgLi4uYXJncykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjdXJyZW50U2lnbmFsID0gc2lnbmFsICE9PSBudWxsICYmIHNpZ25hbCAhPT0gdm9pZCAwID8gc2lnbmFsIDogbnVsbDtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyID09PSBudWxsIHx8IGFib3J0Q29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIGFib3J0Q29udHJvbGxlciA9IGNyZWF0ZUFib3J0Q29udHJvbGxlcihzaWduYWwpO1xuICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdSZXNvdXJjZSBjcmVhdGlvbiB3YXMgYWJvcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmdzID0gYXJncyAhPT0gbnVsbCAmJiBhcmdzICE9PSB2b2lkIDAgPyBhcmdzIDogbnVsbDtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IGNyZWF0ZUZuKGFib3J0Q29udHJvbGxlci5zaWduYWwsIC4uLmFyZ3MpO1xuICAgICAgICBjdXJyZW50UHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIGNvbnN0IHJlc291cmNlID0geWllbGQgcHJvbWlzZTtcbiAgICAgICAgaWYgKGN1cnJlbnRQcm9taXNlICE9PSBwcm9taXNlICYmIHJlc291cmNlICE9PSBjdXJyZW50UmVzb3VyY2UpIHtcbiAgICAgICAgICAgIHlpZWxkIGRpc3Bvc2VGbihyZXNvdXJjZSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdSZXNvdXJjZSBjcmVhdGlvbiB3YXMgYWJvcnRlZCBieSBhIG5ldyByZXNvdXJjZSBjcmVhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRSZXNvdXJjZSA9IHJlc291cmNlO1xuICAgICAgICByZXR1cm4gY3VycmVudFJlc291cmNlO1xuICAgIH0pO1xuICAgIC8vIGdldCB0aGUgY3VycmVudCByZXNvdXJjZVxuICAgIGNvbnN0IGN1cnJlbnQgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBjdXJyZW50UmVzb3VyY2UgIT09IG51bGwgJiYgY3VycmVudFJlc291cmNlICE9PSB2b2lkIDAgPyBjdXJyZW50UmVzb3VyY2UgOiBudWxsO1xuICAgIH07XG4gICAgLy8gZGlzcG9zZSB0aGUgY3VycmVudCByZXNvdXJjZVxuICAgIGNvbnN0IGRpc3Bvc2UgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNvdXJjZSA9IGN1cnJlbnRSZXNvdXJjZTtcbiAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gY3VycmVudFByb21pc2U7XG4gICAgICAgICAgICBjdXJyZW50UHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGxTZXR0bGVkKFtcbiAgICAgICAgICAgICAgICByZXNvdXJjZSA/IGRpc3Bvc2VGbihyZXNvdXJjZSkgOiBQcm9taXNlLnJlc29sdmUoKSxcbiAgICAgICAgICAgICAgICBwcm9taXNlID8gZGlzcG9zZUZuKHlpZWxkIHByb21pc2UpIDogUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9KTtcbiAgICAvLyByZWNyZWF0ZSB0aGUgY3VycmVudCByZXNvdXJjZVxuICAgIGNvbnN0IHJlY3JlYXRlID0gKGRlbGF5TXMpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgcmVzb3VyY2UgPSBjdXJyZW50UmVzb3VyY2U7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBjdXJyZW50UHJvbWlzZTtcbiAgICAgICAgY29uc3QgYXJncyA9IGN1cnJlbnRBcmdzO1xuICAgICAgICBjb25zdCBzaWduYWwgPSBjdXJyZW50U2lnbmFsO1xuICAgICAgICB5aWVsZCBkZWxheShkZWxheU1zKTtcbiAgICAgICAgaWYgKHJlc291cmNlID09PSBjdXJyZW50UmVzb3VyY2UgJiZcbiAgICAgICAgICAgIHByb21pc2UgPT09IGN1cnJlbnRQcm9taXNlICYmXG4gICAgICAgICAgICBhcmdzID09PSBjdXJyZW50QXJncyAmJlxuICAgICAgICAgICAgc2lnbmFsID09PSBjdXJyZW50U2lnbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgY3JlYXRlKGN1cnJlbnRTaWduYWwsIC4uLihhcmdzICE9PSBudWxsICYmIGFyZ3MgIT09IHZvaWQgMCA/IGFyZ3MgOiBbXSkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ1Jlc291cmNlIHJlY3JlYXRpb24gd2FzIGFib3J0ZWQgYnkgYSBuZXcgcmVzb3VyY2UgY3JlYXRpb24nKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGUsXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIGRpc3Bvc2UsXG4gICAgICAgIHJlY3JlYXRlXG4gICAgfTtcbn1cblxuLyoqXG4gKiBFeGVjdXRlcyBhIGZ1bmN0aW9uIGFuZCBwcm92aWRlcyBkZWZlcnJlZCBiZWhhdmlvciwgYWxsb3dpbmcgZm9yIGEgdGltZW91dCBhbmQgYWJvcnQgZnVuY3Rpb25hbGl0eS5cbiAqXG4gKiBAcGFyYW0ge0RlZmVycmFibGU8VD59IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUuIEl0IHNob3VsZCByZXR1cm4gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZGVzaXJlZCByZXN1bHQuXG4gKiBAcGFyYW0ge0RlZmVyT3B0aW9uc30gb3B0aW9ucyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIGRlZmVyIGJlaGF2aW9yLlxuICogQHJldHVybnMge1Byb21pc2U8VD59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBleGVjdXRlZCBmdW5jdGlvbiwgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yIGlmIGl0IHRpbWVzIG91dCBvciBpcyBhYm9ydGVkLlxuICovXG5mdW5jdGlvbiB0aW1lb3V0KGZuLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGltZW91dCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50aW1lb3V0O1xuICAgIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWw7XG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gY3JlYXRlQWJvcnRDb250cm9sbGVyKHNpZ25hbCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBUb25Db25uZWN0RXJyb3IoJ09wZXJhdGlvbiBhYm9ydGVkJykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgICAgIGlmICh0eXBlb2YgdGltZW91dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVG9uQ29ubmVjdEVycm9yKGBUaW1lb3V0IGFmdGVyICR7dGltZW91dH1tc2ApKTtcbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgVG9uQ29ubmVjdEVycm9yKCdPcGVyYXRpb24gYWJvcnRlZCcpKTtcbiAgICAgICAgfSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBkZWZlck9wdGlvbnMgPSB7IHRpbWVvdXQsIGFib3J0OiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsIH07XG4gICAgICAgIHlpZWxkIGZuKCguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIHJlc29sdmUoLi4uYXJncyk7XG4gICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH0sIGRlZmVyT3B0aW9ucyk7XG4gICAgfSkpO1xufVxuXG5jbGFzcyBCcmlkZ2VHYXRld2F5IHtcbiAgICBnZXQgaXNSZWFkeSgpIHtcbiAgICAgICAgY29uc3QgZXZlbnRTb3VyY2UgPSB0aGlzLmV2ZW50U291cmNlLmN1cnJlbnQoKTtcbiAgICAgICAgcmV0dXJuIChldmVudFNvdXJjZSA9PT0gbnVsbCB8fCBldmVudFNvdXJjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXZlbnRTb3VyY2UucmVhZHlTdGF0ZSkgPT09IEV2ZW50U291cmNlLk9QRU47XG4gICAgfVxuICAgIGdldCBpc0Nsb3NlZCgpIHtcbiAgICAgICAgY29uc3QgZXZlbnRTb3VyY2UgPSB0aGlzLmV2ZW50U291cmNlLmN1cnJlbnQoKTtcbiAgICAgICAgcmV0dXJuIChldmVudFNvdXJjZSA9PT0gbnVsbCB8fCBldmVudFNvdXJjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXZlbnRTb3VyY2UucmVhZHlTdGF0ZSkgIT09IEV2ZW50U291cmNlLk9QRU47XG4gICAgfVxuICAgIGdldCBpc0Nvbm5lY3RpbmcoKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50U291cmNlID0gdGhpcy5ldmVudFNvdXJjZS5jdXJyZW50KCk7XG4gICAgICAgIHJldHVybiAoZXZlbnRTb3VyY2UgPT09IG51bGwgfHwgZXZlbnRTb3VyY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50U291cmNlLnJlYWR5U3RhdGUpID09PSBFdmVudFNvdXJjZS5DT05ORUNUSU5HO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzdG9yYWdlLCBicmlkZ2VVcmwsIHNlc3Npb25JZCwgbGlzdGVuZXIsIGVycm9yc0xpc3RlbmVyLCBhbmFseXRpY3NNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuYnJpZGdlVXJsID0gYnJpZGdlVXJsO1xuICAgICAgICB0aGlzLnNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLmVycm9yc0xpc3RlbmVyID0gZXJyb3JzTGlzdGVuZXI7XG4gICAgICAgIHRoaXMuc3NlUGF0aCA9ICdldmVudHMnO1xuICAgICAgICB0aGlzLnBvc3RQYXRoID0gJ21lc3NhZ2UnO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdE1lc3NhZ2UgPSAnaGVhcnRiZWF0JztcbiAgICAgICAgdGhpcy5kZWZhdWx0VHRsID0gMzAwO1xuICAgICAgICB0aGlzLmRlZmF1bHRSZWNvbm5lY3REZWxheSA9IDIwMDA7XG4gICAgICAgIHRoaXMuZGVmYXVsdFJlc2VuZERlbGF5ID0gNTAwMDtcbiAgICAgICAgdGhpcy5ldmVudFNvdXJjZSA9IGNyZWF0ZVJlc291cmNlKChzaWduYWwsIG9wZW5pbmdEZWFkbGluZU1TLCB0cmFjZUlkKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudFNvdXJjZUNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBicmlkZ2VVcmw6IHRoaXMuYnJpZGdlVXJsLFxuICAgICAgICAgICAgICAgIHNzZVBhdGg6IHRoaXMuc3NlUGF0aCxcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IHRoaXMuc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIGJyaWRnZUdhdGV3YXlTdG9yYWdlOiB0aGlzLmJyaWRnZUdhdGV3YXlTdG9yYWdlLFxuICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlcjogdGhpcy5lcnJvcnNIYW5kbGVyLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXI6IHRoaXMubWVzc2FnZXNIYW5kbGVyLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBzaWduYWwsXG4gICAgICAgICAgICAgICAgb3BlbmluZ0RlYWRsaW5lTVM6IG9wZW5pbmdEZWFkbGluZU1TLFxuICAgICAgICAgICAgICAgIHRyYWNlSWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4geWllbGQgY3JlYXRlRXZlbnRTb3VyY2UoZXZlbnRTb3VyY2VDb25maWcpO1xuICAgICAgICB9KSwgKHJlc291cmNlKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXNvdXJjZS5jbG9zZSgpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuYnJpZGdlR2F0ZXdheVN0b3JhZ2UgPSBuZXcgSHR0cEJyaWRnZUdhdGV3YXlTdG9yYWdlKHN0b3JhZ2UsIGJyaWRnZVVybCk7XG4gICAgICAgIHRoaXMuYW5hbHl0aWNzID0gYW5hbHl0aWNzTWFuYWdlciA9PT0gbnVsbCB8fCBhbmFseXRpY3NNYW5hZ2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbmFseXRpY3NNYW5hZ2VyLnNjb3BlZCh7XG4gICAgICAgICAgICBicmlkZ2VfdXJsOiBicmlkZ2VVcmwsXG4gICAgICAgICAgICBjbGllbnRfaWQ6IHNlc3Npb25JZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVnaXN0ZXJTZXNzaW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmFuYWx5dGljcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVtaXRCcmlkZ2VDbGllbnRDb25uZWN0U3RhcnRlZCh7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlX2lkOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25TdGFydGVkID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmV2ZW50U291cmNlLmNyZWF0ZShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub3BlbmluZ0RlYWRsaW5lTVMsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFjZUlkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBicmlkZ2VDb25uZWN0RHVyYXRpb24gPSBEYXRlLm5vdygpIC0gY29ubmVjdGlvblN0YXJ0ZWQ7XG4gICAgICAgICAgICAgICAgKF9iID0gdGhpcy5hbmFseXRpY3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5lbWl0QnJpZGdlQ2xpZW50Q29ubmVjdEVzdGFibGlzaGVkKHtcbiAgICAgICAgICAgICAgICAgICAgYnJpZGdlX2Nvbm5lY3RfZHVyYXRpb246IGJyaWRnZUNvbm5lY3REdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VfaWQ6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFjZUlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAoX2MgPSB0aGlzLmFuYWx5dGljcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmVtaXRCcmlkZ2VDbGllbnRDb25uZWN0RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICB0cmFjZV9pZDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYWNlSWQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yX21lc3NhZ2U6IFN0cmluZyhlcnJvcilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmQobWVzc2FnZSwgcmVjZWl2ZXIsIHRvcGljLCB0dGxPck9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSBkZXByZWNhdGVkIG1ldGhvZFxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0dGxPck9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy50dGwgPSB0dGxPck9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnR0bCA9IHR0bE9yT3B0aW9ucyA9PT0gbnVsbCB8fCB0dGxPck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHR0bE9yT3B0aW9ucy50dGw7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWwgPSB0dGxPck9wdGlvbnMgPT09IG51bGwgfHwgdHRsT3JPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0dGxPck9wdGlvbnMuc2lnbmFsO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuYXR0ZW1wdHMgPSB0dGxPck9wdGlvbnMgPT09IG51bGwgfHwgdHRsT3JPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0dGxPck9wdGlvbnMuYXR0ZW1wdHM7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy50cmFjZUlkID0gdHRsT3JPcHRpb25zID09PSBudWxsIHx8IHR0bE9yT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHRsT3JPcHRpb25zLnRyYWNlSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGFkZFBhdGhUb1VybCh0aGlzLmJyaWRnZVVybCwgdGhpcy5wb3N0UGF0aCkpO1xuICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ2NsaWVudF9pZCcsIHRoaXMuc2Vzc2lvbklkKTtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCd0bycsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCd0dGwnLCAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50dGwpIHx8IHRoaXMuZGVmYXVsdFR0bCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgndG9waWMnLCB0b3BpYyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYWNlSWQpIHtcbiAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgndHJhY2VfaWQnLCBvcHRpb25zLnRyYWNlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYm9keSA9IEJhc2U2NC5lbmNvZGUobWVzc2FnZSk7XG4gICAgICAgICAgICB5aWVsZCBjYWxsRm9yU3VjY2Vzcygob3B0aW9ucykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5wb3N0KHVybCwgYm9keSwgb3B0aW9ucy5zaWduYWwpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcihgQnJpZGdlIHNlbmQgZmFpbGVkLCBzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksIHtcbiAgICAgICAgICAgICAgICBhdHRlbXB0czogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF0dGVtcHRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgICAgICBkZWxheU1zOiB0aGlzLmRlZmF1bHRSZXNlbmREZWxheSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRTb3VyY2UuZGlzcG9zZSgpLmNhdGNoKGUgPT4gbG9nRXJyb3IoYEJyaWRnZSBwYXVzZSBmYWlsZWQsICR7ZX1gKSk7XG4gICAgfVxuICAgIHVuUGF1c2UoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBSRUNSRUFURV9XSVRIT1VUX0RFTEFZID0gMDtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZXZlbnRTb3VyY2UucmVjcmVhdGUoUkVDUkVBVEVfV0lUSE9VVF9ERUxBWSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZXZlbnRTb3VyY2UuZGlzcG9zZSgpLmNhdGNoKGUgPT4gbG9nRXJyb3IoYEJyaWRnZSBjbG9zZSBmYWlsZWQsICR7ZX1gKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgfVxuICAgIHNldEVycm9yc0xpc3RlbmVyKGVycm9yc0xpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzTGlzdGVuZXIgPSBlcnJvcnNMaXN0ZW5lcjtcbiAgICB9XG4gICAgcG9zdCh1cmwsIGJvZHksIHNpZ25hbCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdwb3N0JyxcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogc2lnbmFsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKGBCcmlkZ2Ugc2VuZCBmYWlsZWQsIHN0YXR1cyAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVycm9yc0hhbmRsZXIoZXZlbnRTb3VyY2UsIGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgIGV2ZW50U291cmNlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignQnJpZGdlIGVycm9yLCBmYWlsZWQgdG8gY29ubmVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZWFkeSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzTGlzdGVuZXIoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgICAgICAgIGV2ZW50U291cmNlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoYEJyaWRnZSByZWNvbm5lY3RpbmcsICR7dGhpcy5kZWZhdWx0UmVjb25uZWN0RGVsYXl9bXMgZGVsYXlgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5ldmVudFNvdXJjZS5yZWNyZWF0ZSh0aGlzLmRlZmF1bHRSZWNvbm5lY3REZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdCcmlkZ2UgZXJyb3IsIHVua25vd24gc3RhdGUnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1lc3NhZ2VzSGFuZGxlcihlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoZS5kYXRhID09PSB0aGlzLmhlYXJ0YmVhdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmJyaWRnZUdhdGV3YXlTdG9yYWdlLnN0b3JlTGFzdEV2ZW50SWQoZS5sYXN0RXZlbnRJZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBicmlkZ2VJbmNvbWluZ01lc3NhZ2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJyaWRnZUluY29taW5nTWVzc2FnZVJhdyA9IEpTT04ucGFyc2UoZS5kYXRhKTtcbiAgICAgICAgICAgICAgICBicmlkZ2VJbmNvbWluZ01lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGJyaWRnZUluY29taW5nTWVzc2FnZVJhdy5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiBicmlkZ2VJbmNvbWluZ01lc3NhZ2VSYXcuZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VJZDogYnJpZGdlSW5jb21pbmdNZXNzYWdlUmF3LnRyYWNlX2lkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcihgQnJpZGdlIG1lc3NhZ2UgcGFyc2UgZmFpbGVkLCBtZXNzYWdlICR7ZS5kYXRhfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcihicmlkZ2VJbmNvbWluZ01lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gZXZlbnQgc291cmNlLlxuICogQHBhcmFtIHtDcmVhdGVFdmVudFNvdXJjZUNvbmZpZ30gY29uZmlnIC0gQ29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYW4gZXZlbnQgc291cmNlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFdmVudFNvdXJjZShjb25maWcpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4geWllbGQgdGltZW91dCgocmVzb2x2ZSwgcmVqZWN0LCBkZWZlck9wdGlvbnMpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IGNyZWF0ZUFib3J0Q29udHJvbGxlcihkZWZlck9wdGlvbnMuc2lnbmFsKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbCA9IGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IFRvbkNvbm5lY3RFcnJvcignQnJpZGdlIGNvbm5lY3Rpb24gYWJvcnRlZCcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGFkZFBhdGhUb1VybChjb25maWcuYnJpZGdlVXJsLCBjb25maWcuc3NlUGF0aCkpO1xuICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ2NsaWVudF9pZCcsIGNvbmZpZy5zZXNzaW9uSWQpO1xuICAgICAgICAgICAgY29uc3QgbGFzdEV2ZW50SWQgPSB5aWVsZCBjb25maWcuYnJpZGdlR2F0ZXdheVN0b3JhZ2UuZ2V0TGFzdEV2ZW50SWQoKTtcbiAgICAgICAgICAgIGlmIChsYXN0RXZlbnRJZCkge1xuICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdsYXN0X2V2ZW50X2lkJywgbGFzdEV2ZW50SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZy50cmFjZUlkKSB7XG4gICAgICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ3RyYWNlX2lkJywgY29uZmlnLnRyYWNlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUb25Db25uZWN0RXJyb3IoJ0JyaWRnZSBjb25uZWN0aW9uIGFib3J0ZWQnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXZlbnRTb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UodXJsLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgZXZlbnRTb3VyY2Uub25lcnJvciA9IChyZWFzb24pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2UuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUb25Db25uZWN0RXJyb3IoJ0JyaWRnZSBjb25uZWN0aW9uIGFib3J0ZWQnKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SW5zdGFuY2UgPSB5aWVsZCBjb25maWcuZXJyb3JIYW5kbGVyKGV2ZW50U291cmNlLCByZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3SW5zdGFuY2UgIT09IGV2ZW50U291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFNvdXJjZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdJbnN0YW5jZSAmJiBuZXdJbnN0YW5jZSAhPT0gZXZlbnRTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobmV3SW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U291cmNlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV2ZW50U291cmNlLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2UuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUb25Db25uZWN0RXJyb3IoJ0JyaWRnZSBjb25uZWN0aW9uIGFib3J0ZWQnKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShldmVudFNvdXJjZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXZlbnRTb3VyY2Uub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U291cmNlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVG9uQ29ubmVjdEVycm9yKCdCcmlkZ2UgY29ubmVjdGlvbiBhYm9ydGVkJykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbmZpZy5tZXNzYWdlSGFuZGxlcihldmVudCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgKF9hID0gY29uZmlnLnNpZ25hbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50U291cmNlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUb25Db25uZWN0RXJyb3IoJ0JyaWRnZSBjb25uZWN0aW9uIGFib3J0ZWQnKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSksIHsgdGltZW91dDogY29uZmlnLm9wZW5pbmdEZWFkbGluZU1TLCBzaWduYWw6IGNvbmZpZy5zaWduYWwgfSk7XG4gICAgfSk7XG59XG5cbmNvbnN0IENPTk5FQ1RJT05fSFRUUF9FWFBJUkFUSU9OX1RJTUUgPSA1ICogNjAgKiAxMDAwO1xuZnVuY3Rpb24gaXNQZW5kaW5nQ29ubmVjdGlvbkh0dHAoY29ubmVjdGlvbikge1xuICAgIHJldHVybiAhKCdjb25uZWN0RXZlbnQnIGluIGNvbm5lY3Rpb24pO1xufVxuZnVuY3Rpb24gaXNQZW5kaW5nQ29ubmVjdGlvbkh0dHBSYXcoY29ubmVjdGlvbikge1xuICAgIHJldHVybiAhKCdjb25uZWN0RXZlbnQnIGluIGNvbm5lY3Rpb24pO1xufVxuZnVuY3Rpb24gaXNFeHBpcmVkUGVuZGluZ0Nvbm5lY3Rpb25IdHRwUmF3KGNvbm5lY3Rpb24pIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIERhdGUubm93KCkgLSAoKF9hID0gY29ubmVjdGlvbi5jcmVhdGVkQXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApID4gQ09OTkVDVElPTl9IVFRQX0VYUElSQVRJT05fVElNRTtcbn1cblxuY29uc3QgUFJPVE9DT0xfVkVSU0lPTiA9IDI7XG5cbi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMjAgUm9iZXJ0IEtpZWZmZXIgYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cbi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuIEluIHRoZSBicm93c2VyIHdlIHRoZXJlZm9yZVxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4vLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxubGV0IGdldFJhbmRvbVZhbHVlcztcbmNvbnN0IHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuZnVuY3Rpb24gcm5nKCkge1xuICAgIC8vIGxhenkgbG9hZCBzbyB0aGF0IGVudmlyb25tZW50cyB0aGF0IG5lZWQgdG8gcG9seWZpbGwgaGF2ZSBhIGNoYW5jZSB0byBkbyBzb1xuICAgIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY3J5cHRvID09PSAndW5kZWZpbmVkJyB8fCAhY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCkgbm90IHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCNnZXRyYW5kb212YWx1ZXMtbm90LXN1cHBvcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGdldFJhbmRvbVZhbHVlcyA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbn1cblxuLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAyMCBSb2JlcnQgS2llZmZlciBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5jb25zdCBieXRlVG9IZXggPSBbXTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc2xpY2UoMSkpO1xufVxuZnVuY3Rpb24gdW5zYWZlU3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICAgIC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gICAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gICAgLy9cbiAgICAvLyBOb3RlIHRvIGZ1dHVyZS1zZWxmOiBObywgeW91IGNhbid0IHJlbW92ZSB0aGUgYHRvTG93ZXJDYXNlKClgIGNhbGwuXG4gICAgLy8gUkVGOiBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC82NzcjaXNzdWVjb21tZW50LTE3NTczNTEzNTFcbiAgICByZXR1cm4gKGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICtcbiAgICAgICAgJy0nICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArXG4gICAgICAgICctJyArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gK1xuICAgICAgICAnLScgK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICtcbiAgICAgICAgJy0nICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dKS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDIwIFJvYmVydCBLaWVmZmVyIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5jb25zdCBfc3RhdGUgPSB7fTtcbmZ1bmN0aW9uIFVVSUR2NyhvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGxldCBieXRlcztcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAvLyBXaXRoIG9wdGlvbnM6IE1ha2UgVVVJRCBpbmRlcGVuZGVudCBvZiBpbnRlcm5hbCBzdGF0ZVxuICAgICAgICBieXRlcyA9IHY3Qnl0ZXMoKF9jID0gKF9hID0gb3B0aW9ucy5yYW5kb20pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYiA9IG9wdGlvbnMucm5nKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChvcHRpb25zKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogcm5nKCksIG9wdGlvbnMubXNlY3MsIG9wdGlvbnMuc2VxLCBidWYsIG9mZnNldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBObyBvcHRpb25zOiBVc2UgaW50ZXJuYWwgc3RhdGVcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3Qgcm5kcyA9IHJuZygpO1xuICAgICAgICB1cGRhdGVWN1N0YXRlKF9zdGF0ZSwgbm93LCBybmRzKTtcbiAgICAgICAgYnl0ZXMgPSB2N0J5dGVzKHJuZHMsIF9zdGF0ZS5tc2VjcywgX3N0YXRlLnNlcSwgYnVmLCBvZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmICE9PSBudWxsICYmIGJ1ZiAhPT0gdm9pZCAwID8gYnVmIDogdW5zYWZlU3RyaW5naWZ5KGJ5dGVzKTtcbn1cbi8vIChQcml2YXRlISkgIERvIG5vdCB1c2UuICBUaGlzIG1ldGhvZCBpcyBvbmx5IGV4cG9ydGVkIGZvciB0ZXN0aW5nIHB1cnBvc2VzXG4vLyBhbmQgbWF5IGNoYW5nZSB3aXRob3V0IG5vdGljZS5cbmZ1bmN0aW9uIHVwZGF0ZVY3U3RhdGUoc3RhdGUsIG5vdywgcm5kcykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgKF9hID0gc3RhdGUubXNlY3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChzdGF0ZS5tc2VjcyA9IC1JbmZpbml0eSk7XG4gICAgKF9iID0gc3RhdGUuc2VxKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAoc3RhdGUuc2VxID0gMCk7XG4gICAgaWYgKG5vdyA+IHN0YXRlLm1zZWNzKSB7XG4gICAgICAgIC8vIFRpbWUgaGFzIG1vdmVkIG9uISBQaWNrIGEgbmV3IHJhbmRvbSBzZXF1ZW5jZSBudW1iZXJcbiAgICAgICAgc3RhdGUuc2VxID0gKHJuZHNbNl0gPDwgMjMpIHwgKHJuZHNbN10gPDwgMTYpIHwgKHJuZHNbOF0gPDwgOCkgfCBybmRzWzldO1xuICAgICAgICBzdGF0ZS5tc2VjcyA9IG5vdztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEJ1bXAgc2VxdWVuY2UgY291bnRlciB3LyAzMi1iaXQgcm9sbG92ZXJcbiAgICAgICAgc3RhdGUuc2VxID0gKHN0YXRlLnNlcSArIDEpIHwgMDtcbiAgICAgICAgLy8gSW4gY2FzZSBvZiByb2xsb3ZlciwgYnVtcCB0aW1lc3RhbXAgdG8gcHJlc2VydmUgbW9ub3RvbmljaXR5LiBUaGlzIGlzXG4gICAgICAgIC8vIGFsbG93ZWQgYnkgdGhlIFJGQyBhbmQgc2hvdWxkIHNlbGYtY29ycmVjdCBhcyB0aGUgc3lzdGVtIGNsb2NrIGNhdGNoZXNcbiAgICAgICAgLy8gdXAuIFNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTU2Mi5odG1sI3NlY3Rpb24tNi4yLTkuNFxuICAgICAgICBpZiAoc3RhdGUuc2VxID09PSAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5tc2VjcysrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHY3Qnl0ZXMocm5kcywgbXNlY3MsIHNlcSwgYnVmLCBvZmZzZXQgPSAwKSB7XG4gICAgaWYgKHJuZHMubGVuZ3RoIDwgMTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSYW5kb20gYnl0ZXMgbGVuZ3RoIG11c3QgYmUgPj0gMTYnKTtcbiAgICB9XG4gICAgaWYgKCFidWYpIHtcbiAgICAgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMTYgPiBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVVVJRCBieXRlIHJhbmdlICR7b2Zmc2V0fToke29mZnNldCArIDE1fSBpcyBvdXQgb2YgYnVmZmVyIGJvdW5kc2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIERlZmF1bHRzXG4gICAgbXNlY3MgIT09IG51bGwgJiYgbXNlY3MgIT09IHZvaWQgMCA/IG1zZWNzIDogKG1zZWNzID0gRGF0ZS5ub3coKSk7XG4gICAgc2VxICE9PSBudWxsICYmIHNlcSAhPT0gdm9pZCAwID8gc2VxIDogKHNlcSA9ICgocm5kc1s2XSAqIDB4N2YpIDw8IDI0KSB8IChybmRzWzddIDw8IDE2KSB8IChybmRzWzhdIDw8IDgpIHwgcm5kc1s5XSk7XG4gICAgLy8gYnl0ZSAwLTU6IHRpbWVzdGFtcCAoNDggYml0cylcbiAgICBidWZbb2Zmc2V0KytdID0gKG1zZWNzIC8gMHgxMDAwMDAwMDAwMCkgJiAweGZmO1xuICAgIGJ1ZltvZmZzZXQrK10gPSAobXNlY3MgLyAweDEwMDAwMDAwMCkgJiAweGZmO1xuICAgIGJ1ZltvZmZzZXQrK10gPSAobXNlY3MgLyAweDEwMDAwMDApICYgMHhmZjtcbiAgICBidWZbb2Zmc2V0KytdID0gKG1zZWNzIC8gMHgxMDAwMCkgJiAweGZmO1xuICAgIGJ1ZltvZmZzZXQrK10gPSAobXNlY3MgLyAweDEwMCkgJiAweGZmO1xuICAgIGJ1ZltvZmZzZXQrK10gPSBtc2VjcyAmIDB4ZmY7XG4gICAgLy8gYnl0ZSA2OiBgdmVyc2lvbmAgKDQgYml0cykgfCBzZXF1ZW5jZSBiaXRzIDI4LTMxICg0IGJpdHMpXG4gICAgYnVmW29mZnNldCsrXSA9IDB4NzAgfCAoKHNlcSA+Pj4gMjgpICYgMHgwZik7XG4gICAgLy8gYnl0ZSA3OiBzZXF1ZW5jZSBiaXRzIDIwLTI3ICg4IGJpdHMpXG4gICAgYnVmW29mZnNldCsrXSA9IChzZXEgPj4+IDIwKSAmIDB4ZmY7XG4gICAgLy8gYnl0ZSA4OiBgdmFyaWFudGAgKDIgYml0cykgfCBzZXF1ZW5jZSBiaXRzIDE0LTE5ICg2IGJpdHMpXG4gICAgYnVmW29mZnNldCsrXSA9IDB4ODAgfCAoKHNlcSA+Pj4gMTQpICYgMHgzZik7XG4gICAgLy8gYnl0ZSA5OiBzZXF1ZW5jZSBiaXRzIDYtMTMgKDggYml0cylcbiAgICBidWZbb2Zmc2V0KytdID0gKHNlcSA+Pj4gNikgJiAweGZmO1xuICAgIC8vIGJ5dGUgMTA6IHNlcXVlbmNlIGJpdHMgMC01ICg2IGJpdHMpIHwgcmFuZG9tICgyIGJpdHMpXG4gICAgYnVmW29mZnNldCsrXSA9ICgoc2VxIDw8IDIpICYgMHhmZikgfCAocm5kc1sxMF0gJiAweDAzKTtcbiAgICAvLyBieXRlcyAxMS0xNTogcmFuZG9tICg0MCBiaXRzKVxuICAgIGJ1ZltvZmZzZXQrK10gPSBybmRzWzExXTtcbiAgICBidWZbb2Zmc2V0KytdID0gcm5kc1sxMl07XG4gICAgYnVmW29mZnNldCsrXSA9IHJuZHNbMTNdO1xuICAgIGJ1ZltvZmZzZXQrK10gPSBybmRzWzE0XTtcbiAgICBidWZbb2Zmc2V0KytdID0gcm5kc1sxNV07XG4gICAgcmV0dXJuIGJ1Zjtcbn1cblxuZnVuY3Rpb24gd2FpdEZvclNvbWUocHJvbWlzZXMsIGNvdW50KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKGNvdW50IDw9IDApXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGlmIChjb3VudCA+IHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2NvdW50IGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiBwcm9taXNlcycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkocHJvbWlzZXMubGVuZ3RoKTtcbiAgICAgICAgbGV0IHNldHRsZWRDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHByb21pc2VzLmZvckVhY2goKHAsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHApXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHZhbHVlID0+ICh7IHN0YXR1czogJ2Z1bGZpbGxlZCcsIHZhbHVlIH0pKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2gocmVhc29uID0+ICh7IHN0YXR1czogJ3JlamVjdGVkJywgcmVhc29uIH0pKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGxlZENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0bGVkQ291bnQgPT09IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmNsYXNzIEJyaWRnZVByb3ZpZGVyIHtcbiAgICBzdGF0aWMgZnJvbVN0b3JhZ2Uoc3RvcmFnZSwgYW5hbHl0aWNzTWFuYWdlcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHlpZWxkIHN0b3JhZ2UuZ2V0SHR0cENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChpc1BlbmRpbmdDb25uZWN0aW9uSHR0cChjb25uZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnJpZGdlUHJvdmlkZXIoc3RvcmFnZSwgY29ubmVjdGlvbi5jb25uZWN0aW9uU291cmNlLCBhbmFseXRpY3NNYW5hZ2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQnJpZGdlUHJvdmlkZXIoc3RvcmFnZSwgeyBicmlkZ2VVcmw6IGNvbm5lY3Rpb24uc2Vzc2lvbi5icmlkZ2VVcmwgfSwgYW5hbHl0aWNzTWFuYWdlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uU3RvcmFnZSwgd2FsbGV0Q29ubmVjdGlvblNvdXJjZSwgYW5hbHl0aWNzTWFuYWdlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblN0b3JhZ2UgPSBjb25uZWN0aW9uU3RvcmFnZTtcbiAgICAgICAgdGhpcy53YWxsZXRDb25uZWN0aW9uU291cmNlID0gd2FsbGV0Q29ubmVjdGlvblNvdXJjZTtcbiAgICAgICAgdGhpcy5hbmFseXRpY3NNYW5hZ2VyID0gYW5hbHl0aWNzTWFuYWdlcjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2h0dHAnO1xuICAgICAgICB0aGlzLnN0YW5kYXJkVW5pdmVyc2FsTGluayA9ICd0YzovLyc7XG4gICAgICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xuICAgICAgICB0aGlzLmdhdGV3YXkgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdHYXRld2F5cyA9IFtdO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLmRlZmF1bHRPcGVuaW5nRGVhZGxpbmVNUyA9IDEyMDAwO1xuICAgICAgICB0aGlzLmRlZmF1bHRSZXRyeVRpbWVvdXRNUyA9IDIwMDA7XG4gICAgICAgIHRoaXMub3B0aW9uYWxPcGVuR2F0ZXdheXMgPSAzO1xuICAgICAgICB0aGlzLmFuYWx5dGljcyA9IChfYSA9IHRoaXMuYW5hbHl0aWNzTWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNjb3BlZCgpO1xuICAgIH1cbiAgICBjb25uZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgdHJhY2VJZCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFjZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBVVUlEdjcoKTtcbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gY3JlYXRlQWJvcnRDb250cm9sbGVyKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWwpO1xuICAgICAgICAoX2IgPSB0aGlzLmFib3J0Q29udHJvbGxlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0KCk7XG4gICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gYWJvcnRDb250cm9sbGVyO1xuICAgICAgICB0aGlzLmNsb3NlR2F0ZXdheXMoKTtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbkNyeXB0byA9IG5ldyBTZXNzaW9uQ3J5cHRvKCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHtcbiAgICAgICAgICAgIHNlc3Npb25DcnlwdG8sXG4gICAgICAgICAgICBicmlkZ2VVcmw6ICdicmlkZ2VVcmwnIGluIHRoaXMud2FsbGV0Q29ubmVjdGlvblNvdXJjZVxuICAgICAgICAgICAgICAgID8gdGhpcy53YWxsZXRDb25uZWN0aW9uU291cmNlLmJyaWRnZVVybFxuICAgICAgICAgICAgICAgIDogJydcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uU3RvcmFnZVxuICAgICAgICAgICAgLnN0b3JlQ29ubmVjdGlvbih7XG4gICAgICAgICAgICB0eXBlOiAnaHR0cCcsXG4gICAgICAgICAgICBjb25uZWN0aW9uU291cmNlOiB0aGlzLndhbGxldENvbm5lY3Rpb25Tb3VyY2UsXG4gICAgICAgICAgICBzZXNzaW9uQ3J5cHRvXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgY2FsbEZvclN1Y2Nlc3MoX29wdGlvbnMgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVuR2F0ZXdheXMoc2Vzc2lvbkNyeXB0bywge1xuICAgICAgICAgICAgICAgICAgICBvcGVuaW5nRGVhZGxpbmVNUzogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9wZW5pbmdEZWFkbGluZU1TKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmRlZmF1bHRPcGVuaW5nRGVhZGxpbmVNUyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBfb3B0aW9ucyA9PT0gbnVsbCB8fCBfb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZUlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgYXR0ZW1wdHM6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgICAgIGRlbGF5TXM6IHRoaXMuZGVmYXVsdFJldHJ5VGltZW91dE1TLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QgdW5pdmVyc2FsTGluayA9ICd1bml2ZXJzYWxMaW5rJyBpbiB0aGlzLndhbGxldENvbm5lY3Rpb25Tb3VyY2UgJiZcbiAgICAgICAgICAgIHRoaXMud2FsbGV0Q29ubmVjdGlvblNvdXJjZS51bml2ZXJzYWxMaW5rXG4gICAgICAgICAgICA/IHRoaXMud2FsbGV0Q29ubmVjdGlvblNvdXJjZS51bml2ZXJzYWxMaW5rXG4gICAgICAgICAgICA6IHRoaXMuc3RhbmRhcmRVbml2ZXJzYWxMaW5rO1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVVuaXZlcnNhbExpbmsodW5pdmVyc2FsTGluaywgbWVzc2FnZSwgeyB0cmFjZUlkIH0pO1xuICAgIH1cbiAgICByZXN0b3JlQ29ubmVjdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IHRyYWNlSWQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVVVJRHY3KCk7XG4gICAgICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBjcmVhdGVBYm9ydENvbnRyb2xsZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCk7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLmFib3J0Q29udHJvbGxlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0KCk7XG4gICAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IGFib3J0Q29udHJvbGxlcjtcbiAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsb3NlR2F0ZXdheXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZENvbm5lY3Rpb24gPSB5aWVsZCB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlLmdldEh0dHBDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoIXN0b3JlZENvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3BlbmluZ0RlYWRsaW5lTVMgPSAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub3BlbmluZ0RlYWRsaW5lTVMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHRoaXMuZGVmYXVsdE9wZW5pbmdEZWFkbGluZU1TO1xuICAgICAgICAgICAgaWYgKGlzUGVuZGluZ0Nvbm5lY3Rpb25IdHRwKHN0b3JlZENvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uID0ge1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uQ3J5cHRvOiBzdG9yZWRDb25uZWN0aW9uLnNlc3Npb25DcnlwdG8sXG4gICAgICAgICAgICAgICAgICAgIGJyaWRnZVVybDogJ2JyaWRnZVVybCcgaW4gdGhpcy53YWxsZXRDb25uZWN0aW9uU291cmNlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMud2FsbGV0Q29ubmVjdGlvblNvdXJjZS5icmlkZ2VVcmxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJydcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLm9wZW5HYXRld2F5cyhzdG9yZWRDb25uZWN0aW9uLnNlc3Npb25DcnlwdG8sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbmluZ0RlYWRsaW5lTVM6IG9wZW5pbmdEZWFkbGluZU1TLFxuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlSWQ6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFjZUlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLndhbGxldENvbm5lY3Rpb25Tb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignSW50ZXJuYWwgZXJyb3IuIENvbm5lY3Rpb24gc291cmNlIGlzIGFycmF5IHdoaWxlIFdhbGxldENvbm5lY3Rpb25Tb3VyY2VIVFRQIHdhcyBleHBlY3RlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbiA9IHN0b3JlZENvbm5lY3Rpb24uc2Vzc2lvbjtcbiAgICAgICAgICAgIGlmICh0aGlzLmdhdGV3YXkpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnR2F0ZXdheSBpcyBhbHJlYWR5IG9wZW5lZCwgY2xvc2luZyBwcmV2aW91cyBnYXRld2F5Jyk7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5nYXRld2F5LmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdhdGV3YXkgPSBuZXcgQnJpZGdlR2F0ZXdheSh0aGlzLmNvbm5lY3Rpb25TdG9yYWdlLnN0b3JhZ2UsIHRoaXMud2FsbGV0Q29ubmVjdGlvblNvdXJjZS5icmlkZ2VVcmwsIHN0b3JlZENvbm5lY3Rpb24uc2Vzc2lvbi5zZXNzaW9uQ3J5cHRvLnNlc3Npb25JZCwgdGhpcy5nYXRld2F5TGlzdGVuZXIuYmluZCh0aGlzKSwgdGhpcy5nYXRld2F5RXJyb3JzTGlzdGVuZXIuYmluZCh0aGlzKSwgdGhpcy5hbmFseXRpY3NNYW5hZ2VyKTtcbiAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBub3RpZnkgbGlzdGVuZXJzIGFib3V0IHN0b3JlZCBjb25uZWN0aW9uXG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RvcmVkQ29ubmVjdGlvbi5jb25uZWN0RXZlbnQpLCB7IHRyYWNlSWQgfSkpKTtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIHRoZSBjb25uZWN0aW9uIHRvIGJlIG9wZW5lZFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB5aWVsZCBjYWxsRm9yU3VjY2VzcyhvcHRpb25zID0+IHRoaXMuZ2F0ZXdheS5yZWdpc3RlclNlc3Npb24oe1xuICAgICAgICAgICAgICAgICAgICBvcGVuaW5nRGVhZGxpbmVNUzogb3BlbmluZ0RlYWRsaW5lTVMsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlSWRcbiAgICAgICAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0czogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5TXM6IHRoaXMuZGVmYXVsdFJldHJ5VGltZW91dE1TLFxuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5kaXNjb25uZWN0KHsgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLCB0cmFjZUlkIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRSZXF1ZXN0KHJlcXVlc3QsIG9wdGlvbnNPck9uUmVxdWVzdFNlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBUT0RPOiByZW1vdmUgZGVwcmVjYXRlZCBtZXRob2RcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMub25SZXF1ZXN0U2VudCA9IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zLm9uUmVxdWVzdFNlbnQgPSBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSBudWxsIHx8IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQub25SZXF1ZXN0U2VudDtcbiAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsID0gb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gbnVsbCB8fCBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zT3JPblJlcXVlc3RTZW50LnNpZ25hbDtcbiAgICAgICAgICAgIG9wdGlvbnMuYXR0ZW1wdHMgPSBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSBudWxsIHx8IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQuYXR0ZW1wdHM7XG4gICAgICAgICAgICBvcHRpb25zLnRyYWNlSWQgPSBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSBudWxsIHx8IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQudHJhY2VJZDtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSBvcHRpb25zLnRyYWNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChvcHRpb25zLnRyYWNlSWQgPSBVVUlEdjcoKSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmdhdGV3YXkgfHwgIXRoaXMuc2Vzc2lvbiB8fCAhKCd3YWxsZXRQdWJsaWNLZXknIGluIHRoaXMuc2Vzc2lvbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdUcnlpbmcgdG8gc2VuZCBicmlkZ2UgcmVxdWVzdCB3aXRob3V0IHNlc3Npb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlkID0gKHlpZWxkIHRoaXMuY29ubmVjdGlvblN0b3JhZ2UuZ2V0TmV4dFJwY1JlcXVlc3RJZCgpKS50b1N0cmluZygpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0aW9uU3RvcmFnZS5pbmNyZWFzZU5leHRScGNSZXF1ZXN0SWQoKTtcbiAgICAgICAgICAgIGxvZ0RlYnVnKCdTZW5kIGh0dHAtYnJpZGdlIHJlcXVlc3Q6JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KSwgeyBpZCB9KSk7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkUmVxdWVzdCA9IHRoaXMuc2Vzc2lvbi5zZXNzaW9uQ3J5cHRvLmVuY3J5cHQoSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KSwgeyBpZCB9KSksIGhleFRvQnl0ZUFycmF5KHRoaXMuc2Vzc2lvbi53YWxsZXRQdWJsaWNLZXkpKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5hbmFseXRpY3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbWl0QnJpZGdlQ2xpZW50TWVzc2FnZVNlbnQoe1xuICAgICAgICAgICAgICAgICAgICBicmlkZ2VfdXJsOiB0aGlzLmdhdGV3YXkuYnJpZGdlVXJsLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRfaWQ6IHRoaXMuc2Vzc2lvbi5zZXNzaW9uQ3J5cHRvLnNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0X2lkOiB0aGlzLnNlc3Npb24ud2FsbGV0UHVibGljS2V5LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdF90eXBlOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VfaWQ6IG9wdGlvbnMudHJhY2VJZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2F0ZXdheS5zZW5kKGVuY29kZWRSZXF1ZXN0LCB0aGlzLnNlc3Npb24ud2FsbGV0UHVibGljS2V5LCByZXF1ZXN0Lm1ldGhvZCwge1xuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0czogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF0dGVtcHRzLFxuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlSWQ6IG9wdGlvbnMudHJhY2VJZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vblJlcXVlc3RTZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5zZXQoaWQudG9TdHJpbmcoKSwgcmVzb2x2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBjbG9zZUNvbm5lY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2xvc2VHYXRld2F5cygpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xuICAgICAgICB0aGlzLmdhdGV3YXkgPSBudWxsO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNlSWQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVVVJRHY3KCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IHRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25SZXF1ZXN0U2VudCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUJyaWRnZUFuZFNlc3Npb24oKS50aGVuKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlR2F0ZXdheXMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gY3JlYXRlQWJvcnRDb250cm9sbGVyKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWwpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLmRlZmF1bHRPcGVuaW5nRGVhZGxpbmVNUyk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuc2VuZFJlcXVlc3QoeyBtZXRob2Q6ICdkaXNjb25uZWN0JywgcGFyYW1zOiBbXSB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblJlcXVlc3RTZW50OiBvblJlcXVlc3RTZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdHM6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZUlkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnRGlzY29ubmVjdCBlcnJvcjonLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQnJpZGdlQW5kU2Vzc2lvbigpLnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9uUmVxdWVzdFNlbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsaXN0ZW4oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiAodGhpcy5saXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycy5maWx0ZXIobGlzdGVuZXIgPT4gbGlzdGVuZXIgIT09IGNhbGxiYWNrKSk7XG4gICAgfVxuICAgIHBhdXNlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuZ2F0ZXdheSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdXNlKCk7XG4gICAgICAgIHRoaXMucGVuZGluZ0dhdGV3YXlzLmZvckVhY2goYnJpZGdlID0+IGJyaWRnZS5wYXVzZSgpKTtcbiAgICB9XG4gICAgdW5QYXVzZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5wZW5kaW5nR2F0ZXdheXMubWFwKGJyaWRnZSA9PiBicmlkZ2UudW5QYXVzZSgpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdhdGV3YXkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZ2F0ZXdheS51blBhdXNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGVuZGluZ0dhdGV3YXlzTGlzdGVuZXIoZ2F0ZXdheSwgYnJpZGdlVXJsLCBicmlkZ2VJbmNvbWluZ01lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wZW5kaW5nR2F0ZXdheXMuaW5jbHVkZXMoZ2F0ZXdheSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBnYXRld2F5LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbG9zZUdhdGV3YXlzKHsgZXhjZXB0OiBnYXRld2F5IH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2F0ZXdheSkge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdHYXRld2F5IGlzIGFscmVhZHkgb3BlbmVkLCBjbG9zaW5nIHByZXZpb3VzIGdhdGV3YXknKTtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmdhdGV3YXkuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5icmlkZ2VVcmwgPSBicmlkZ2VVcmw7XG4gICAgICAgICAgICB0aGlzLmdhdGV3YXkgPSBnYXRld2F5O1xuICAgICAgICAgICAgdGhpcy5nYXRld2F5LnNldEVycm9yc0xpc3RlbmVyKHRoaXMuZ2F0ZXdheUVycm9yc0xpc3RlbmVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5nYXRld2F5LnNldExpc3RlbmVyKHRoaXMuZ2F0ZXdheUxpc3RlbmVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2F0ZXdheUxpc3RlbmVyKGJyaWRnZUluY29taW5nTWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnYXRld2F5TGlzdGVuZXIoYnJpZGdlSW5jb21pbmdNZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IHRyYWNlSWQgPSAoX2EgPSBicmlkZ2VJbmNvbWluZ01lc3NhZ2UudHJhY2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVVVJRHY3KCk7XG4gICAgICAgICAgICBsZXQgd2FsbGV0TWVzc2FnZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2FsbGV0TWVzc2FnZSA9IEpTT04ucGFyc2UodGhpcy5zZXNzaW9uLnNlc3Npb25DcnlwdG8uZGVjcnlwdChCYXNlNjQuZGVjb2RlKGJyaWRnZUluY29taW5nTWVzc2FnZS5tZXNzYWdlKS50b1VpbnQ4QXJyYXkoKSwgaGV4VG9CeXRlQXJyYXkoYnJpZGdlSW5jb21pbmdNZXNzYWdlLmZyb20pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgKF9iID0gdGhpcy5hbmFseXRpY3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5lbWl0QnJpZGdlQ2xpZW50TWVzc2FnZURlY29kZUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgYnJpZGdlX3VybDogdGhpcy5zZXNzaW9uLmJyaWRnZVVybCxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50X2lkOiB0aGlzLnNlc3Npb24uc2Vzc2lvbkNyeXB0by5zZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgICAgIHdhbGxldF9pZDogYnJpZGdlSW5jb21pbmdNZXNzYWdlLmZyb20sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yX21lc3NhZ2U6IFN0cmluZyhlcnIpLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZV9pZDogYnJpZGdlSW5jb21pbmdNZXNzYWdlID09PSBudWxsIHx8IGJyaWRnZUluY29taW5nTWVzc2FnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJpZGdlSW5jb21pbmdNZXNzYWdlLnRyYWNlSWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dEZWJ1ZygnV2FsbGV0IG1lc3NhZ2UgcmVjZWl2ZWQ6Jywgd2FsbGV0TWVzc2FnZSk7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0VHlwZSA9ICdldmVudCcgaW4gd2FsbGV0TWVzc2FnZSA/IHdhbGxldE1lc3NhZ2UuZXZlbnQgOiAnJztcbiAgICAgICAgICAgIChfYyA9IHRoaXMuYW5hbHl0aWNzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZW1pdEJyaWRnZUNsaWVudE1lc3NhZ2VSZWNlaXZlZCh7XG4gICAgICAgICAgICAgICAgYnJpZGdlX3VybDogdGhpcy5zZXNzaW9uLmJyaWRnZVVybCxcbiAgICAgICAgICAgICAgICBjbGllbnRfaWQ6IHRoaXMuc2Vzc2lvbi5zZXNzaW9uQ3J5cHRvLnNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICB3YWxsZXRfaWQ6IGJyaWRnZUluY29taW5nTWVzc2FnZS5mcm9tLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VfaWQ6IFN0cmluZyh3YWxsZXRNZXNzYWdlLmlkKSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0X3R5cGU6IHJlcXVlc3RUeXBlLFxuICAgICAgICAgICAgICAgIHRyYWNlX2lkOiBicmlkZ2VJbmNvbWluZ01lc3NhZ2UgPT09IG51bGwgfHwgYnJpZGdlSW5jb21pbmdNZXNzYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBicmlkZ2VJbmNvbWluZ01lc3NhZ2UudHJhY2VJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoISgnZXZlbnQnIGluIHdhbGxldE1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSB3YWxsZXRNZXNzYWdlLmlkLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZSA9IHRoaXMucGVuZGluZ1JlcXVlc3RzLmdldChpZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKGBSZXNwb25zZSBpZCAke2lkfSBkb2Vzbid0IG1hdGNoIGFueSByZXF1ZXN0J3MgaWRgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd2FsbGV0TWVzc2FnZSksIHsgdHJhY2VJZCB9KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2FsbGV0TWVzc2FnZS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdElkID0geWllbGQgdGhpcy5jb25uZWN0aW9uU3RvcmFnZS5nZXRMYXN0V2FsbGV0RXZlbnRJZCgpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0SWQgIT09IHVuZGVmaW5lZCAmJiB3YWxsZXRNZXNzYWdlLmlkIDw9IGxhc3RJZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFcnJvcihgUmVjZWl2ZWQgZXZlbnQgaWQgKD0ke3dhbGxldE1lc3NhZ2UuaWR9KSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBzdG9yZWQgbGFzdCB3YWxsZXQgZXZlbnQgaWQgKD0ke2xhc3RJZH0pIGApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh3YWxsZXRNZXNzYWdlLmV2ZW50ICE9PSAnY29ubmVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0aW9uU3RvcmFnZS5zdG9yZUxhc3RXYWxsZXRFdmVudElkKHdhbGxldE1lc3NhZ2UuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGB0aGlzLmxpc3RlbmVyc2AgbWlnaHQgYmUgbW9kaWZpZWQgaW4gdGhlIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzO1xuICAgICAgICAgICAgaWYgKHdhbGxldE1lc3NhZ2UuZXZlbnQgPT09ICdjb25uZWN0Jykge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMudXBkYXRlU2Vzc2lvbih3YWxsZXRNZXNzYWdlLCBicmlkZ2VJbmNvbWluZ01lc3NhZ2UuZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2FsbGV0TWVzc2FnZS5ldmVudCA9PT0gJ2Rpc2Nvbm5lY3QnKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoYFJlbW92aW5nIGJyaWRnZSBhbmQgc2Vzc2lvbjogcmVjZWl2ZWQgZGlzY29ubmVjdCBldmVudGApO1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucmVtb3ZlQnJpZGdlQW5kU2Vzc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB3YWxsZXRNZXNzYWdlKSwgeyB0cmFjZUlkIH0pKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnYXRld2F5RXJyb3JzTGlzdGVuZXIoZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcihgQnJpZGdlIGVycm9yICR7SlNPTi5zdHJpbmdpZnkoZSl9YCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVTZXNzaW9uKGNvbm5lY3RFdmVudCwgd2FsbGV0UHVibGljS2V5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc2Vzc2lvbiksIHsgd2FsbGV0UHVibGljS2V5IH0pO1xuICAgICAgICAgICAgY29uc3QgdG9uQWRkckl0ZW0gPSBjb25uZWN0RXZlbnQucGF5bG9hZC5pdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5uYW1lID09PSAndG9uX2FkZHInKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RFdmVudFRvU2F2ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29ubmVjdEV2ZW50KSwgeyBwYXlsb2FkOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbm5lY3RFdmVudC5wYXlsb2FkKSwgeyBpdGVtczogW3RvbkFkZHJJdGVtXSB9KSB9KTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdGlvblN0b3JhZ2Uuc3RvcmVDb25uZWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaHR0cCcsXG4gICAgICAgICAgICAgICAgc2Vzc2lvbjogdGhpcy5zZXNzaW9uLFxuICAgICAgICAgICAgICAgIGxhc3RXYWxsZXRFdmVudElkOiBjb25uZWN0RXZlbnQuaWQsXG4gICAgICAgICAgICAgICAgY29ubmVjdEV2ZW50OiBjb25uZWN0RXZlbnRUb1NhdmUsXG4gICAgICAgICAgICAgICAgbmV4dFJwY1JlcXVlc3RJZDogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVCcmlkZ2VBbmRTZXNzaW9uKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdGlvblN0b3JhZ2UucmVtb3ZlQ29ubmVjdGlvbigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2VuZXJhdGVVbml2ZXJzYWxMaW5rKHVuaXZlcnNhbExpbmssIG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGlzVGVsZWdyYW1VcmwodW5pdmVyc2FsTGluaykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlVEdVbml2ZXJzYWxMaW5rKHVuaXZlcnNhbExpbmssIG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlUmVndWxhclVuaXZlcnNhbExpbmsodW5pdmVyc2FsTGluaywgbWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGdlbmVyYXRlUmVndWxhclVuaXZlcnNhbExpbmsodW5pdmVyc2FsTGluaywgbWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHVuaXZlcnNhbExpbmspO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgndicsIFBST1RPQ09MX1ZFUlNJT04udG9TdHJpbmcoKSk7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdpZCcsIHRoaXMuc2Vzc2lvbi5zZXNzaW9uQ3J5cHRvLnNlc3Npb25JZCk7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCd0cmFjZV9pZCcsIG9wdGlvbnMudHJhY2VJZCk7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdyJywgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xuICAgICAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGdlbmVyYXRlVEdVbml2ZXJzYWxMaW5rKHVuaXZlcnNhbExpbmssIG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdXJsVG9XcmFwID0gdGhpcy5nZW5lcmF0ZVJlZ3VsYXJVbml2ZXJzYWxMaW5rKCdhYm91dDpibGFuaycsIG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBsaW5rUGFyYW1zID0gdXJsVG9XcmFwLnNwbGl0KCc/JylbMV07XG4gICAgICAgIGNvbnN0IHN0YXJ0YXBwID0gJ3RvbmNvbm5lY3QtJyArIGVuY29kZVRlbGVncmFtVXJsUGFyYW1ldGVycyhsaW5rUGFyYW1zKTtcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgbGluZSBhZnRlciBhbGwgZEFwcHMgYW5kIHRoZSB3YWxsZXRzLWxpc3QuanNvbiBoYXZlIGJlZW4gdXBkYXRlZFxuICAgICAgICBjb25zdCB1cGRhdGVkVW5pdmVyc2FsTGluayA9IHRoaXMuY29udmVydFRvRGlyZWN0TGluayh1bml2ZXJzYWxMaW5rKTtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCh1cGRhdGVkVW5pdmVyc2FsTGluayk7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdzdGFydGFwcCcsIHN0YXJ0YXBwKTtcbiAgICAgICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBtZXRob2QgYWZ0ZXIgYWxsIGRBcHBzIGFuZCB0aGUgd2FsbGV0cy1saXN0Lmpzb24gaGF2ZSBiZWVuIHVwZGF0ZWRcbiAgICBjb252ZXJ0VG9EaXJlY3RMaW5rKHVuaXZlcnNhbExpbmspIHtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCh1bml2ZXJzYWxMaW5rKTtcbiAgICAgICAgaWYgKHVybC5zZWFyY2hQYXJhbXMuaGFzKCdhdHRhY2gnKSkge1xuICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoJ2F0dGFjaCcpO1xuICAgICAgICAgICAgdXJsLnBhdGhuYW1lICs9ICcvc3RhcnQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgb3BlbkdhdGV3YXlzKHNlc3Npb25DcnlwdG8sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNlSWQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVVVJRHY3KCk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLndhbGxldENvbm5lY3Rpb25Tb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gY2xvc2UgYWxsIGdhdGV3YXlzIGJlZm9yZSBvcGVuaW5nIG5ldyBvbmVzXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nR2F0ZXdheXMubWFwKGJyaWRnZSA9PiBicmlkZ2UuY2xvc2UoKS5jYXRjaCgpKTtcbiAgICAgICAgICAgICAgICAvLyBvcGVuIG5ldyBnYXRld2F5c1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0dhdGV3YXlzID0gdGhpcy53YWxsZXRDb25uZWN0aW9uU291cmNlLm1hcChzb3VyY2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXRld2F5ID0gbmV3IEJyaWRnZUdhdGV3YXkodGhpcy5jb25uZWN0aW9uU3RvcmFnZS5zdG9yYWdlLCBzb3VyY2UuYnJpZGdlVXJsLCBzZXNzaW9uQ3J5cHRvLnNlc3Npb25JZCwgKCkgPT4geyB9LCAoKSA9PiB7IH0sIHRoaXMuYW5hbHl0aWNzTWFuYWdlcik7XG4gICAgICAgICAgICAgICAgICAgIGdhdGV3YXkuc2V0TGlzdGVuZXIobWVzc2FnZSA9PiB0aGlzLnBlbmRpbmdHYXRld2F5c0xpc3RlbmVyKGdhdGV3YXksIHNvdXJjZS5icmlkZ2VVcmwsIG1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdhdGV3YXk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gV2FpdCB1bnRpbCB0aGUgc3BlY2lmaWVkIG9wdGlvbmFsIGdhdGV3YXlzIGFyZSBvcGVuZWQsIG5vdCBuZWNlc3NhcmlseSBhbGwgZ2F0ZXdheXNcbiAgICAgICAgICAgICAgICBjb25zdCBnYXRld2F5c1RvV2FpdEZvciA9IE1hdGgubWF4KHRoaXMucGVuZGluZ0dhdGV3YXlzLmxlbmd0aCAtIHRoaXMub3B0aW9uYWxPcGVuR2F0ZXdheXMsIDEpO1xuICAgICAgICAgICAgICAgIHlpZWxkIHdhaXRGb3JTb21lKHRoaXMucGVuZGluZ0dhdGV3YXlzLm1hcChicmlkZ2UgPT4gY2FsbEZvclN1Y2Nlc3MoKF9vcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBlbmRpbmdHYXRld2F5cy5zb21lKGl0ZW0gPT4gaXRlbSA9PT0gYnJpZGdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJyaWRnZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBicmlkZ2UucmVnaXN0ZXJTZXNzaW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5pbmdEZWFkbGluZU1TOiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub3BlbmluZ0RlYWRsaW5lTVMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuZGVmYXVsdE9wZW5pbmdEZWFkbGluZU1TLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBfb3B0aW9ucy5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZUlkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdHM6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgICAgICAgICBkZWxheU1zOiB0aGlzLmRlZmF1bHRSZXRyeVRpbWVvdXRNUyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsXG4gICAgICAgICAgICAgICAgfSkpLCBnYXRld2F5c1RvV2FpdEZvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2F0ZXdheSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhgR2F0ZXdheSBpcyBhbHJlYWR5IG9wZW5lZCwgY2xvc2luZyBwcmV2aW91cyBnYXRld2F5YCk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2F0ZXdheS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmdhdGV3YXkgPSBuZXcgQnJpZGdlR2F0ZXdheSh0aGlzLmNvbm5lY3Rpb25TdG9yYWdlLnN0b3JhZ2UsIHRoaXMud2FsbGV0Q29ubmVjdGlvblNvdXJjZS5icmlkZ2VVcmwsIHNlc3Npb25DcnlwdG8uc2Vzc2lvbklkLCB0aGlzLmdhdGV3YXlMaXN0ZW5lci5iaW5kKHRoaXMpLCB0aGlzLmdhdGV3YXlFcnJvcnNMaXN0ZW5lci5iaW5kKHRoaXMpLCB0aGlzLmFuYWx5dGljc01hbmFnZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmdhdGV3YXkucmVnaXN0ZXJTZXNzaW9uKHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbmluZ0RlYWRsaW5lTVM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vcGVuaW5nRGVhZGxpbmVNUyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZUlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbG9zZUdhdGV3YXlzKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmdhdGV3YXkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpO1xuICAgICAgICB0aGlzLnBlbmRpbmdHYXRld2F5c1xuICAgICAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0gIT09IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZXhjZXB0KSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGJyaWRnZSA9PiBicmlkZ2UuY2xvc2UoKSk7XG4gICAgICAgIHRoaXMucGVuZGluZ0dhdGV3YXlzID0gW107XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYXNQcm9wZXJ0eSh2YWx1ZSwgcHJvcGVydHlLZXkpIHtcbiAgICByZXR1cm4gaGFzUHJvcGVydGllcyh2YWx1ZSwgW3Byb3BlcnR5S2V5XSk7XG59XG5mdW5jdGlvbiBoYXNQcm9wZXJ0aWVzKHZhbHVlLCBwcm9wZXJ0eUtleXMpIHtcbiAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcGVydHlLZXlzLmV2ZXJ5KHByb3BlcnR5S2V5ID0+IHByb3BlcnR5S2V5IGluIHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gaXNKU0JyaWRnZVdpdGhNZXRhZGF0YSh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghaGFzUHJvcGVydHkodmFsdWUsICd0b25jb25uZWN0JykgfHwgIWhhc1Byb3BlcnR5KHZhbHVlLnRvbmNvbm5lY3QsICd3YWxsZXRJbmZvJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzUHJvcGVydGllcyh2YWx1ZS50b25jb25uZWN0LndhbGxldEluZm8sIFtcbiAgICAgICAgICAgICduYW1lJyxcbiAgICAgICAgICAgICdhcHBfbmFtZScsXG4gICAgICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAgICAgJ2Fib3V0X3VybCcsXG4gICAgICAgICAgICAncGxhdGZvcm1zJ1xuICAgICAgICBdKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogSW4gbWVtb3J5IHN0b3JhZ2UgbGlrZSBsb2NhbFN0b3JhZ2UsIGJ1dCB3aXRob3V0IHBlcnNpc3RlbmNlLlxuICogVXNlcyBhcyBhIGZhbGxiYWNrIGZvciBsb2NhbFN0b3JhZ2UgaW4gU2FmYXJpJ3MgcHJpdmF0ZSBtb2RlLlxuICovXG5jbGFzcyBJbk1lbW9yeVN0b3JhZ2Uge1xuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcbiAgICAgICAgaWYgKCFJbk1lbW9yeVN0b3JhZ2UuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIEluTWVtb3J5U3RvcmFnZS5pbnN0YW5jZSA9IG5ldyBJbk1lbW9yeVN0b3JhZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSW5NZW1vcnlTdG9yYWdlLmluc3RhbmNlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0ge307XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnN0b3JhZ2UpLmxlbmd0aDtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHt9O1xuICAgIH1cbiAgICBnZXRJdGVtKGtleSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnN0b3JhZ2Vba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICB9XG4gICAga2V5KGluZGV4KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuc3RvcmFnZSk7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0ga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2EgPSBrZXlzW2luZGV4XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICB9XG4gICAgcmVtb3ZlSXRlbShrZXkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RvcmFnZVtrZXldO1xuICAgIH1cbiAgICBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlW2tleV0gPSB2YWx1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvdygpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdztcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50KCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBkb2N1bWVudDtcbn1cbmZ1bmN0aW9uIGdldFdlYlBhZ2VNYW5pZmVzdCgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgb3JpZ2luID0gKF9hID0gZ2V0V2luZG93KCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhdGlvbi5vcmlnaW47XG4gICAgaWYgKG9yaWdpbikge1xuICAgICAgICByZXR1cm4gb3JpZ2luICsgJy90b25jb25uZWN0LW1hbmlmZXN0Lmpzb24nO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5mdW5jdGlvbiBnZXRPcmlnaW5XaXRoUGF0aCgpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgY29uc3Qgb3JpZ2luID0gKF9iID0gKF9hID0gZ2V0V2luZG93KCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9yaWdpbjtcbiAgICBjb25zdCBwYXRoID0gKF9kID0gKF9jID0gZ2V0V2luZG93KCkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sb2NhdGlvbikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnBhdGhuYW1lO1xuICAgIGlmIChvcmlnaW4gJiYgcGF0aCkge1xuICAgICAgICByZXR1cm4gb3JpZ2luICsgcGF0aDtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuLyoqXG4gKiBSZXR1cm5zIGBsb2NhbFN0b3JhZ2VgIGlmIGl0IGlzIGF2YWlsYWJsZS4gSW4gU2FmYXJpJ3MgcHJpdmF0ZSBtb2RlLCBpdCByZXR1cm5zIGBJbk1lbW9yeVN0b3JhZ2VgLiBJbiBOb2RlLmpzLCBpdCB0aHJvd3MgYW4gZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIHRyeUdldExvY2FsU3RvcmFnZSgpIHtcbiAgICBpZiAoaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSkge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlO1xuICAgIH1cbiAgICBpZiAoaXNOb2RlSnMoKSkge1xuICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdgbG9jYWxTdG9yYWdlYCBpcyB1bmF2YWlsYWJsZSwgYnV0IGl0IGlzIHJlcXVpcmVkIGZvciBUb25Db25uZWN0LiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3Rvbi1jb25uZWN0L3Nkay90cmVlL21haW4vcGFja2FnZXMvc2RrI2luaXQtY29ubmVjdG9yJyk7XG4gICAgfVxuICAgIHJldHVybiBJbk1lbW9yeVN0b3JhZ2UuZ2V0SW5zdGFuY2UoKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGBsb2NhbFN0b3JhZ2VgIGlzIGF2YWlsYWJsZS5cbiAqL1xuZnVuY3Rpb24gaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSB7XG4gICAgLy8gV2UgdXNlIGEgdHJ5L2NhdGNoIGJsb2NrIGJlY2F1c2UgU2FmYXJpJ3MgcHJpdmF0ZSBtb2RlIHRocm93cyBhbiBlcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gYWNjZXNzIGxvY2FsU3RvcmFnZS5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGVudmlyb25tZW50IGlzIE5vZGUuanMuXG4gKi9cbmZ1bmN0aW9uIGlzTm9kZUpzKCkge1xuICAgIHJldHVybiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudmVyc2lvbnMgIT0gbnVsbCAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgIT0gbnVsbCk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgZG9tYWluIChob3N0bmFtZSkgaWYgYXZhaWxhYmxlLlxuICogSW4gYnJvd3NlciBlbnZpcm9ubWVudCwgcmV0dXJucyB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUuXG4gKiBJbiBOb2RlLmpzIGVudmlyb25tZW50IG9yIHdoZW4gd2luZG93IGlzIG5vdCBhdmFpbGFibGUsIHJldHVybnMgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0RG9tYWluKCkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEluIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5sb2NhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEluIE5vZGUuanMgZW52aXJvbm1lbnQsIHNraXAgZG9tYWluIHZhbGlkYXRpb25cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgW2tleSwgdmFsdWVdIHBhaXJzIGZyb20gd2luZG93IG9iamVjdCBpZiBhdmFpbGFibGUuXG4gKiBJbiBicm93c2VyIGVudmlyb25tZW50LCByZXR1cm5zIE9iamVjdC5lbnRyaWVzKHdpbmRvdykuXG4gKiBJbiBOb2RlLmpzIGVudmlyb25tZW50IG9yIHdoZW4gd2luZG93IGlzIG5vdCBhdmFpbGFibGUsIHJldHVybnMgZW1wdHkgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvd0VudHJpZXMoKSB7XG4gICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgaWYgKCF3aW5kb3cpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMod2luZG93KTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5cbmNsYXNzIEluamVjdGVkUHJvdmlkZXIge1xuICAgIHN0YXRpYyBmcm9tU3RvcmFnZShzdG9yYWdlLCBhbmFseXRpY3NNYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geWllbGQgc3RvcmFnZS5nZXRJbmplY3RlZENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5qZWN0ZWRQcm92aWRlcihzdG9yYWdlLCBjb25uZWN0aW9uLmpzQnJpZGdlS2V5LCBhbmFseXRpY3NNYW5hZ2VyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc1dhbGxldEluamVjdGVkKGluamVjdGVkV2FsbGV0S2V5KSB7XG4gICAgICAgIHJldHVybiBJbmplY3RlZFByb3ZpZGVyLmlzV2luZG93Q29udGFpbnNXYWxsZXQodGhpcy53aW5kb3csIGluamVjdGVkV2FsbGV0S2V5KTtcbiAgICB9XG4gICAgc3RhdGljIGlzSW5zaWRlV2FsbGV0QnJvd3NlcihpbmplY3RlZFdhbGxldEtleSkge1xuICAgICAgICBpZiAoSW5qZWN0ZWRQcm92aWRlci5pc1dpbmRvd0NvbnRhaW5zV2FsbGV0KHRoaXMud2luZG93LCBpbmplY3RlZFdhbGxldEtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpbmRvd1tpbmplY3RlZFdhbGxldEtleV0udG9uY29ubmVjdC5pc1dhbGxldEJyb3dzZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q3VycmVudGx5SW5qZWN0ZWRXYWxsZXRzKCkge1xuICAgICAgICBpZiAoIXRoaXMud2luZG93KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2luZG93RW50cmllcyA9IGdldFdpbmRvd0VudHJpZXMoKTtcbiAgICAgICAgY29uc3Qgd2FsbGV0cyA9IHdpbmRvd0VudHJpZXMuZmlsdGVyKChbX2tleSwgdmFsdWVdKSA9PiBpc0pTQnJpZGdlV2l0aE1ldGFkYXRhKHZhbHVlKSk7XG4gICAgICAgIHJldHVybiB3YWxsZXRzLm1hcCgoW2pzQnJpZGdlS2V5LCB3YWxsZXRdKSA9PiAoe1xuICAgICAgICAgICAgbmFtZTogd2FsbGV0LnRvbmNvbm5lY3Qud2FsbGV0SW5mby5uYW1lLFxuICAgICAgICAgICAgYXBwTmFtZTogd2FsbGV0LnRvbmNvbm5lY3Qud2FsbGV0SW5mby5hcHBfbmFtZSxcbiAgICAgICAgICAgIGFib3V0VXJsOiB3YWxsZXQudG9uY29ubmVjdC53YWxsZXRJbmZvLmFib3V0X3VybCxcbiAgICAgICAgICAgIGltYWdlVXJsOiB3YWxsZXQudG9uY29ubmVjdC53YWxsZXRJbmZvLmltYWdlLFxuICAgICAgICAgICAgdG9uZG5zOiB3YWxsZXQudG9uY29ubmVjdC53YWxsZXRJbmZvLnRvbmRucyxcbiAgICAgICAgICAgIGpzQnJpZGdlS2V5LFxuICAgICAgICAgICAgaW5qZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICBlbWJlZGRlZDogd2FsbGV0LnRvbmNvbm5lY3QuaXNXYWxsZXRCcm93c2VyLFxuICAgICAgICAgICAgcGxhdGZvcm1zOiB3YWxsZXQudG9uY29ubmVjdC53YWxsZXRJbmZvLnBsYXRmb3JtcyxcbiAgICAgICAgICAgIGZlYXR1cmVzOiB3YWxsZXQudG9uY29ubmVjdC53YWxsZXRJbmZvLmZlYXR1cmVzXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgc3RhdGljIGlzV2luZG93Q29udGFpbnNXYWxsZXQod2luZG93LCBpbmplY3RlZFdhbGxldEtleSkge1xuICAgICAgICByZXR1cm4gKCEhd2luZG93ICYmXG4gICAgICAgICAgICBpbmplY3RlZFdhbGxldEtleSBpbiB3aW5kb3cgJiZcbiAgICAgICAgICAgIHR5cGVvZiB3aW5kb3dbaW5qZWN0ZWRXYWxsZXRLZXldID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgJ3RvbmNvbm5lY3QnIGluIHdpbmRvd1tpbmplY3RlZFdhbGxldEtleV0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uU3RvcmFnZSwgaW5qZWN0ZWRXYWxsZXRLZXksIGFuYWx5dGljc01hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uU3RvcmFnZSA9IGNvbm5lY3Rpb25TdG9yYWdlO1xuICAgICAgICB0aGlzLmluamVjdGVkV2FsbGV0S2V5ID0gaW5qZWN0ZWRXYWxsZXRLZXk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdpbmplY3RlZCc7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIHRoaXMubGlzdGVuU3Vic2NyaXB0aW9ucyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICBjb25zdCB3aW5kb3cgPSBJbmplY3RlZFByb3ZpZGVyLndpbmRvdztcbiAgICAgICAgaWYgKCFJbmplY3RlZFByb3ZpZGVyLmlzV2luZG93Q29udGFpbnNXYWxsZXQod2luZG93LCBpbmplY3RlZFdhbGxldEtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RJbmplY3RlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmplY3RlZFdhbGxldCA9IHdpbmRvd1tpbmplY3RlZFdhbGxldEtleV0udG9uY29ubmVjdDtcbiAgICAgICAgaWYgKGFuYWx5dGljc01hbmFnZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYW5hbHl0aWNzID0gYW5hbHl0aWNzTWFuYWdlci5zY29wZWQoe1xuICAgICAgICAgICAgICAgIGJyaWRnZV9rZXk6IGluamVjdGVkV2FsbGV0S2V5LFxuICAgICAgICAgICAgICAgIHdhbGxldF9hcHBfbmFtZTogdGhpcy5pbmplY3RlZFdhbGxldC5kZXZpY2VJbmZvLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgd2FsbGV0X2FwcF92ZXJzaW9uOiB0aGlzLmluamVjdGVkV2FsbGV0LmRldmljZUluZm8uYXBwVmVyc2lvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29ubmVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3QoUFJPVE9DT0xfVkVSU0lPTiwgbWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJlc3RvcmVDb25uZWN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNlSWQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVVVJRHY3KCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKGBJbmplY3RlZCBQcm92aWRlciByZXN0b3JpbmcgY29ubmVjdGlvbi4uLmApO1xuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMuYW5hbHl0aWNzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZW1pdEpzQnJpZGdlQ2FsbCh7XG4gICAgICAgICAgICAgICAgICAgIGpzX2JyaWRnZV9tZXRob2Q6ICdyZXN0b3JlQ29ubmVjdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlX2lkOiB0cmFjZUlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdEV2ZW50ID0geWllbGQgdGhpcy5pbmplY3RlZFdhbGxldC5yZXN0b3JlQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIChfYyA9IHRoaXMuYW5hbHl0aWNzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZW1pdEpzQnJpZGdlUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgICAgICBqc19icmlkZ2VfbWV0aG9kOiAncmVzdG9yZUNvbm5lY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZV9pZDogdHJhY2VJZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdJbmplY3RlZCBQcm92aWRlciByZXN0b3JpbmcgY29ubmVjdGlvbiByZXNwb25zZScsIGNvbm5lY3RFdmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3RFdmVudC5ldmVudCA9PT0gJ2Nvbm5lY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFrZVN1YnNjcmlwdGlvbnMoeyB0cmFjZUlkIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29ubmVjdEV2ZW50KSwgeyB0cmFjZUlkIH0pKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlLnJlbW92ZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIChfZCA9IHRoaXMuYW5hbHl0aWNzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZW1pdEpzQnJpZGdlRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBqc19icmlkZ2VfbWV0aG9kOiAncmVzdG9yZUNvbm5lY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcl9tZXNzYWdlOiBTdHJpbmcoZSksXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlX2lkOiB0cmFjZUlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0aW9uU3RvcmFnZS5yZW1vdmVDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsb3NlQ29ubmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuU3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5pbmplY3RlZFdhbGxldC5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZUFsbExpc3RlbmVycygpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNlSWQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVVVJRHY3KCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25SZXF1ZXN0U2VudCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlLnJlbW92ZUNvbm5lY3Rpb24oKS50aGVuKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmplY3RlZFdhbGxldC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIG9uUmVxdWVzdFNlbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnZGlzY29ubmVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtdXG4gICAgICAgICAgICAgICAgICAgIH0sIHsgb25SZXF1ZXN0U2VudCwgdHJhY2VJZCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsb3NlQWxsTGlzdGVuZXJzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMubGlzdGVuU3Vic2NyaXB0aW9ucyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICAoX2EgPSB0aGlzLnVuc3Vic2NyaWJlQ2FsbGJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBsaXN0ZW4oZXZlbnRzQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChldmVudHNDYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiAodGhpcy5saXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycy5maWx0ZXIobGlzdGVuZXIgPT4gbGlzdGVuZXIgIT09IGV2ZW50c0NhbGxiYWNrKSk7XG4gICAgfVxuICAgIHNlbmRSZXF1ZXN0KHJlcXVlc3QsIG9wdGlvbnNPck9uUmVxdWVzdFNlbnQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGRlcHJlY2F0ZWQgbWV0aG9kXG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uUmVxdWVzdFNlbnQgPSBvcHRpb25zT3JPblJlcXVlc3RTZW50O1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudHJhY2VJZCA9IFVVSUR2NygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlcXVlc3RTZW50ID0gb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gbnVsbCB8fCBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zT3JPblJlcXVlc3RTZW50Lm9uUmVxdWVzdFNlbnQ7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWwgPSBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSBudWxsIHx8IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQuc2lnbmFsO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuYXR0ZW1wdHMgPSBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSBudWxsIHx8IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQuYXR0ZW1wdHM7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy50cmFjZUlkID0gKF9hID0gb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gbnVsbCB8fCBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zT3JPblJlcXVlc3RTZW50LnRyYWNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFVVSUR2NygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaWQgPSAoeWllbGQgdGhpcy5jb25uZWN0aW9uU3RvcmFnZS5nZXROZXh0UnBjUmVxdWVzdElkKCkpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlLmluY3JlYXNlTmV4dFJwY1JlcXVlc3RJZCgpO1xuICAgICAgICAgICAgbG9nRGVidWcoJ1NlbmQgaW5qZWN0ZWQtYnJpZGdlIHJlcXVlc3Q6JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KSwgeyBpZCB9KSk7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLmFuYWx5dGljcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVtaXRKc0JyaWRnZUNhbGwoe1xuICAgICAgICAgICAgICAgIGpzX2JyaWRnZV9tZXRob2Q6ICdzZW5kJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmluamVjdGVkV2FsbGV0LnNlbmQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KSwgeyBpZCB9KSk7XG4gICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuYW5hbHl0aWNzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW1pdEpzQnJpZGdlUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgICAgICBqc19icmlkZ2VfbWV0aG9kOiAnc2VuZCdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnV2FsbGV0IG1lc3NhZ2UgcmVjZWl2ZWQ6JywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmFuYWx5dGljcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVtaXRKc0JyaWRnZUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAganNfYnJpZGdlX21ldGhvZDogJ3NlbmQnLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcl9tZXNzYWdlOiBTdHJpbmcoZXJyb3IpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vblJlcXVlc3RTZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfY29ubmVjdChwcm90b2NvbFZlcnNpb24sIG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNlSWQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVVVJRHY3KCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKGBJbmplY3RlZCBQcm92aWRlciBjb25uZWN0IHJlcXVlc3Q6IHByb3RvY29sVmVyc2lvbjogJHtwcm90b2NvbFZlcnNpb259LCBtZXNzYWdlOmAsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMuYW5hbHl0aWNzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZW1pdEpzQnJpZGdlQ2FsbCh7XG4gICAgICAgICAgICAgICAgICAgIGpzX2JyaWRnZV9tZXRob2Q6ICdjb25uZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VfaWQ6IHRyYWNlSWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0RXZlbnQgPSB5aWVsZCB0aGlzLmluamVjdGVkV2FsbGV0LmNvbm5lY3QocHJvdG9jb2xWZXJzaW9uLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAoX2MgPSB0aGlzLmFuYWx5dGljcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmVtaXRKc0JyaWRnZVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICAgICAganNfYnJpZGdlX21ldGhvZDogJ2Nvbm5lY3QnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ0luamVjdGVkIFByb3ZpZGVyIGNvbm5lY3QgcmVzcG9uc2U6JywgY29ubmVjdEV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdEV2ZW50LmV2ZW50ID09PSAnY29ubmVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy51cGRhdGVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFrZVN1YnNjcmlwdGlvbnMoeyB0cmFjZUlkIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29ubmVjdEV2ZW50KSwgeyB0cmFjZUlkIH0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIChfZCA9IHRoaXMuYW5hbHl0aWNzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZW1pdEpzQnJpZGdlRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBqc19icmlkZ2VfbWV0aG9kOiAnY29ubmVjdCcsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yX21lc3NhZ2U6IFN0cmluZyhlKSxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VfaWQ6IHRyYWNlSWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnSW5qZWN0ZWQgUHJvdmlkZXIgY29ubmVjdCBlcnJvcjonLCBlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0RXZlbnRFcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6ICdjb25uZWN0X2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25uZWN0RXZlbnRFcnJvciksIHsgdHJhY2VJZCB9KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFrZVN1YnNjcmlwdGlvbnMob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdGhpcy5saXN0ZW5TdWJzY3JpcHRpb25zID0gdHJ1ZTtcbiAgICAgICAgKF9hID0gdGhpcy5hbmFseXRpY3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbWl0SnNCcmlkZ2VDYWxsKHtcbiAgICAgICAgICAgIGpzX2JyaWRnZV9tZXRob2Q6ICdsaXN0ZW4nLFxuICAgICAgICAgICAgdHJhY2VfaWQ6IG9wdGlvbnMudHJhY2VJZFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmVDYWxsYmFjayA9IHRoaXMuaW5qZWN0ZWRXYWxsZXQubGlzdGVuKGUgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFjZUlkID0gKF9hID0gZS50cmFjZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBVVUlEdjcoKTtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnV2FsbGV0IG1lc3NhZ2UgcmVjZWl2ZWQ6JywgZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGlzdGVuU3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZSksIHsgdHJhY2VJZCB9KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZS5ldmVudCA9PT0gJ2Rpc2Nvbm5lY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCh7IHRyYWNlSWQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLmFuYWx5dGljcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVtaXRKc0JyaWRnZVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICBqc19icmlkZ2VfbWV0aG9kOiAnbGlzdGVuJyxcbiAgICAgICAgICAgICAgICB0cmFjZV9pZDogb3B0aW9ucy50cmFjZUlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAoX2MgPSB0aGlzLmFuYWx5dGljcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmVtaXRKc0JyaWRnZUVycm9yKHtcbiAgICAgICAgICAgICAgICBqc19icmlkZ2VfbWV0aG9kOiAnbGlzdGVuJyxcbiAgICAgICAgICAgICAgICBlcnJvcl9tZXNzYWdlOiBTdHJpbmcoZXJyKSxcbiAgICAgICAgICAgICAgICB0cmFjZV9pZDogb3B0aW9ucy50cmFjZUlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVTZXNzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uU3RvcmFnZS5zdG9yZUNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgdHlwZTogJ2luamVjdGVkJyxcbiAgICAgICAgICAgIGpzQnJpZGdlS2V5OiB0aGlzLmluamVjdGVkV2FsbGV0S2V5LFxuICAgICAgICAgICAgbmV4dFJwY1JlcXVlc3RJZDogMFxuICAgICAgICB9KTtcbiAgICB9XG59XG5JbmplY3RlZFByb3ZpZGVyLndpbmRvdyA9IGdldFdpbmRvdygpO1xuXG5jbGFzcyBCcmlkZ2VDb25uZWN0aW9uU3RvcmFnZSB7XG4gICAgY29uc3RydWN0b3Ioc3RvcmFnZSwgd2FsbGV0c0xpc3RNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgICAgIHRoaXMud2FsbGV0c0xpc3RNYW5hZ2VyID0gd2FsbGV0c0xpc3RNYW5hZ2VyO1xuICAgICAgICB0aGlzLnN0b3JlS2V5ID0gJ3Rvbi1jb25uZWN0LXN0b3JhZ2VfYnJpZGdlLWNvbm5lY3Rpb24nO1xuICAgIH1cbiAgICBzdG9yZUNvbm5lY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24udHlwZSA9PT0gJ2luamVjdGVkJyB8fCBjb25uZWN0aW9uLnR5cGUgPT09ICd3YWxsZXQtY29ubmVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yZUtleSwgSlNPTi5zdHJpbmdpZnkoY29ubmVjdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1BlbmRpbmdDb25uZWN0aW9uSHR0cChjb25uZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhd1Nlc3Npb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25LZXlQYWlyOiBjb25uZWN0aW9uLnNlc3Npb24uc2Vzc2lvbkNyeXB0by5zdHJpbmdpZnlLZXlwYWlyKCksXG4gICAgICAgICAgICAgICAgICAgIHdhbGxldFB1YmxpY0tleTogY29ubmVjdGlvbi5zZXNzaW9uLndhbGxldFB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICAgICAgYnJpZGdlVXJsOiBjb25uZWN0aW9uLnNlc3Npb24uYnJpZGdlVXJsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByYXdDb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaHR0cCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RFdmVudDogY29ubmVjdGlvbi5jb25uZWN0RXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb246IHJhd1Nlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIGxhc3RXYWxsZXRFdmVudElkOiBjb25uZWN0aW9uLmxhc3RXYWxsZXRFdmVudElkLFxuICAgICAgICAgICAgICAgICAgICBuZXh0UnBjUmVxdWVzdElkOiBjb25uZWN0aW9uLm5leHRScGNSZXF1ZXN0SWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnN0b3JlS2V5LCBKU09OLnN0cmluZ2lmeShyYXdDb25uZWN0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByYXdDb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdodHRwJyxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uU291cmNlOiBjb25uZWN0aW9uLmNvbm5lY3Rpb25Tb3VyY2UsXG4gICAgICAgICAgICAgICAgc2Vzc2lvbkNyeXB0bzogY29ubmVjdGlvbi5zZXNzaW9uQ3J5cHRvLnN0cmluZ2lmeUtleXBhaXIoKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVkQXQ6IERhdGUubm93KClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yZUtleSwgSlNPTi5zdHJpbmdpZnkocmF3Q29ubmVjdGlvbikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlQ29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnN0b3JlS2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldENvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlZCA9IHlpZWxkIHRoaXMuc3RvcmFnZS5nZXRJdGVtKHRoaXMuc3RvcmVLZXkpO1xuICAgICAgICAgICAgICAgIGlmICghc3RvcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gSlNPTi5wYXJzZShzdG9yZWQpO1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLnR5cGUgPT09ICdpbmplY3RlZCcgfHwgY29ubmVjdGlvbi50eXBlID09PSAnd2FsbGV0LWNvbm5lY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzUGVuZGluZ0Nvbm5lY3Rpb25IdHRwUmF3KGNvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25DcnlwdG8gPSBuZXcgU2Vzc2lvbkNyeXB0byhjb25uZWN0aW9uLnNlc3Npb24uc2Vzc2lvbktleVBhaXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5hY3R1YWxpemVCcmlkZ2VDb25uZWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdodHRwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RFdmVudDogY29ubmVjdGlvbi5jb25uZWN0RXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0V2FsbGV0RXZlbnRJZDogY29ubmVjdGlvbi5sYXN0V2FsbGV0RXZlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRScGNSZXF1ZXN0SWQ6IGNvbm5lY3Rpb24ubmV4dFJwY1JlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uQ3J5cHRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyaWRnZVVybDogY29ubmVjdGlvbi5zZXNzaW9uLmJyaWRnZVVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXRQdWJsaWNLZXk6IGNvbm5lY3Rpb24uc2Vzc2lvbi53YWxsZXRQdWJsaWNLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0V4cGlyZWRQZW5kaW5nQ29ubmVjdGlvbkh0dHBSYXcoY29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5yZW1vdmVDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaHR0cCcsXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25DcnlwdG86IG5ldyBTZXNzaW9uQ3J5cHRvKGNvbm5lY3Rpb24uc2Vzc2lvbkNyeXB0byksXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25Tb3VyY2U6IGNvbm5lY3Rpb24uY29ubmVjdGlvblNvdXJjZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ0Vycm9yIHJldHJpZXZpbmcgY29ubmVjdGlvbicsIGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRIdHRwQ29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB5aWVsZCB0aGlzLmdldENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICghY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ1RyeWluZyB0byByZWFkIEhUVFAgY29ubmVjdGlvbiBzb3VyY2Ugd2hpbGUgbm90aGluZyBpcyBzdG9yZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLnR5cGUgIT09ICdodHRwJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoYFRyeWluZyB0byByZWFkIEhUVFAgY29ubmVjdGlvbiBzb3VyY2Ugd2hpbGUgJHtjb25uZWN0aW9uLnR5cGV9IGNvbm5lY3Rpb24gaXMgc3RvcmVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEh0dHBQZW5kaW5nQ29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB5aWVsZCB0aGlzLmdldENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICghY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ1RyeWluZyB0byByZWFkIEhUVFAgY29ubmVjdGlvbiBzb3VyY2Ugd2hpbGUgbm90aGluZyBpcyBzdG9yZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLnR5cGUgIT09ICdodHRwJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoYFRyeWluZyB0byByZWFkIEhUVFAgY29ubmVjdGlvbiBzb3VyY2Ugd2hpbGUgJHtjb25uZWN0aW9uLnR5cGV9IGNvbm5lY3Rpb24gaXMgc3RvcmVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUGVuZGluZ0Nvbm5lY3Rpb25IdHRwKGNvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignVHJ5aW5nIHRvIHJlYWQgSFRUUC1wZW5kaW5nIGNvbm5lY3Rpb24gd2hpbGUgaHR0cCBjb25uZWN0aW9uIGlzIHN0b3JlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRJbmplY3RlZENvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geWllbGQgdGhpcy5nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoIWNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdUcnlpbmcgdG8gcmVhZCBJbmplY3RlZCBicmlkZ2UgY29ubmVjdGlvbiBzb3VyY2Ugd2hpbGUgbm90aGluZyBpcyBzdG9yZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoY29ubmVjdGlvbiA9PT0gbnVsbCB8fCBjb25uZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25uZWN0aW9uLnR5cGUpICE9PSAnaW5qZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcihgVHJ5aW5nIHRvIHJlYWQgSW5qZWN0ZWQgYnJpZGdlIGNvbm5lY3Rpb24gc291cmNlIHdoaWxlICR7Y29ubmVjdGlvbi50eXBlfSBjb25uZWN0aW9uIGlzIHN0b3JlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRXYWxsZXRDb25uZWN0Q29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB5aWVsZCB0aGlzLmdldENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICghY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ1RyeWluZyB0byByZWFkIHdhbGxldCBjb25uZWN0IGJyaWRnZSBjb25uZWN0aW9uIHNvdXJjZSB3aGlsZSBub3RoaW5nIGlzIHN0b3JlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChjb25uZWN0aW9uID09PSBudWxsIHx8IGNvbm5lY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbm5lY3Rpb24udHlwZSkgIT09ICd3YWxsZXQtY29ubmVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKGBUcnlpbmcgdG8gcmVhZCB3YWxsZXQgY29ubmVjdCBicmlkZ2UgY29ubmVjdGlvbiBzb3VyY2Ugd2hpbGUgJHtjb25uZWN0aW9uLnR5cGV9IGNvbm5lY3Rpb24gaXMgc3RvcmVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0b3JlZENvbm5lY3Rpb25UeXBlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkID0geWllbGQgdGhpcy5zdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yZUtleSk7XG4gICAgICAgICAgICBpZiAoIXN0b3JlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLnR5cGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdG9yZUxhc3RXYWxsZXRFdmVudElkKGlkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geWllbGQgdGhpcy5nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbiAmJiBjb25uZWN0aW9uLnR5cGUgPT09ICdodHRwJyAmJiAhaXNQZW5kaW5nQ29ubmVjdGlvbkh0dHAoY29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmxhc3RXYWxsZXRFdmVudElkID0gaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmVDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TGFzdFdhbGxldEV2ZW50SWQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geWllbGQgdGhpcy5nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbiAmJiAnbGFzdFdhbGxldEV2ZW50SWQnIGluIGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5sYXN0V2FsbGV0RXZlbnRJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbmNyZWFzZU5leHRScGNSZXF1ZXN0SWQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geWllbGQgdGhpcy5nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbiAmJiAnbmV4dFJwY1JlcXVlc3RJZCcgaW4gY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RJZCA9IGNvbm5lY3Rpb24ubmV4dFJwY1JlcXVlc3RJZCB8fCAwO1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ubmV4dFJwY1JlcXVlc3RJZCA9IGxhc3RJZCArIDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmVDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TmV4dFJwY1JlcXVlc3RJZCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB5aWVsZCB0aGlzLmdldENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uICYmICduZXh0UnBjUmVxdWVzdElkJyBpbiBjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24ubmV4dFJwY1JlcXVlc3RJZCB8fCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhY3R1YWxpemVCcmlkZ2VDb25uZWN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBwTmFtZSA9IGNvbm5lY3Rpb24uY29ubmVjdEV2ZW50LnBheWxvYWQuZGV2aWNlLmFwcE5hbWU7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0geWllbGQgdGhpcy53YWxsZXRzTGlzdE1hbmFnZXIuZ2V0UmVtb3RlV2FsbGV0KGFwcE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh3YWxsZXQuYnJpZGdlVXJsID09PSBjb25uZWN0aW9uLnNlc3Npb24uYnJpZGdlVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBhY3R1YWxpemVkQ29ubmVjdGlvbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29ubmVjdGlvbiksIHsgc2Vzc2lvbjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25uZWN0aW9uLnNlc3Npb24pLCB7IGJyaWRnZVVybDogd2FsbGV0LmJyaWRnZVVybCB9KSB9KTtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnN0b3JlQ29ubmVjdGlvbihhY3R1YWxpemVkQ29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdHVhbGl6ZWRDb25uZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ0ZhaWxlZCB0byBhY3R1YWxpemUgYnJpZGdlIGNvbm5lY3Rpb24nLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEZWZhdWx0IHN0b3JhZ2UgdG8gc2F2ZSBwcm90b2NvbCBkYXRhLCB1c2VzIGBsb2NhbFN0b3JhZ2VgIGlmIGl0IGlzIGF2YWlsYWJsZS4gSW4gU2FmYXJpJ3MgcHJpdmF0ZSBtb2RlLCBpdCB1c2VzIGBJbk1lbW9yeVN0b3JhZ2VgLiBJbiBOb2RlLmpzLCBpdCB0aHJvd3MgYW4gZXJyb3IuXG4gKi9cbmNsYXNzIERlZmF1bHRTdG9yYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5sb2NhbFN0b3JhZ2UgPSB0cnlHZXRMb2NhbFN0b3JhZ2UoKTtcbiAgICB9XG4gICAgZ2V0SXRlbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVJdGVtKGtleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0SXRlbShrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBXYWxsZXRJbmZvYCBpcyBgV2FsbGV0SW5mb0luamVjdGFibGVgIGFuZCBgV2FsbGV0SW5mb2AgaXMgaW5qZWN0ZWQgdG8gdGhlIGN1cnJlbnQgd2VicGFnZSAoYHdhbGxldEluZm8uaW5qZWN0ZWQgPT09IHRydWVgKS5cbiAqIEBwYXJhbSB2YWx1ZSBXYWxsZXRJbmZvIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBpc1dhbGxldEluZm9DdXJyZW50bHlJbmplY3RlZCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1dhbGxldEluZm9JbmplY3RhYmxlKHZhbHVlKSAmJiB2YWx1ZS5pbmplY3RlZDtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGBXYWxsZXRJbmZvYCBpcyBgV2FsbGV0SW5mb0luamVjdGFibGVgIGFuZCBkQXBwIGlzIG9wZW5lZCBpbnNpZGUgdGhpcyB3YWxsZXQncyBicm93c2VyLlxuICogQHBhcmFtIHZhbHVlIFdhbGxldEluZm8gdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIGlzV2FsbGV0SW5mb0N1cnJlbnRseUVtYmVkZGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzV2FsbGV0SW5mb0N1cnJlbnRseUluamVjdGVkKHZhbHVlKSAmJiB2YWx1ZS5lbWJlZGRlZDtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGBXYWxsZXRJbmZvYCBpcyBgV2FsbGV0SW5mb0luamVjdGVkYCwgYnV0IGRvZXNuJ3QgY2hlY2sgaWYgaXQgaXMgaW5qZWN0ZWQgdG8gdGhlIHBhZ2Ugb3Igbm90LlxuICogQHBhcmFtIHZhbHVlIFdhbGxldEluZm8gdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIGlzV2FsbGV0SW5mb0luamVjdGFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gJ2pzQnJpZGdlS2V5JyBpbiB2YWx1ZTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGBXYWxsZXRJbmZvYCBpcyBgV2FsbGV0SW5mb1JlbW90ZWAuXG4gKiBAcGFyYW0gdmFsdWUgV2FsbGV0SW5mbyB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gaXNXYWxsZXRJbmZvUmVtb3RlKHZhbHVlKSB7XG4gICAgcmV0dXJuICdicmlkZ2VVcmwnIGluIHZhbHVlO1xufVxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgYGlzV2FsbGV0SW5mb0luamVjdGFibGVgIG9yIGBpc1dhbGxldEluZm9DdXJyZW50bHlJbmplY3RlZGAgaW5zdGVhZC5cbiAqIEBwYXJhbSB2YWx1ZSBXYWxsZXRJbmZvIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBpc1dhbGxldEluZm9JbmplY3RlZCh2YWx1ZSkge1xuICAgIHJldHVybiAnanNCcmlkZ2VLZXknIGluIHZhbHVlO1xufVxuXG5jb25zdCBGQUxMQkFDS19XQUxMRVRTX0xJU1QgPSBbXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ3RlbGVncmFtLXdhbGxldCcsXG4gICAgICAgIG5hbWU6ICdXYWxsZXQnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vd2FsbGV0LnRnL2ltYWdlcy9sb2dvLTI4OC5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL3dhbGxldC50Zy8nLFxuICAgICAgICB1bml2ZXJzYWxfdXJsOiAnaHR0cHM6Ly90Lm1lL3dhbGxldD9hdHRhY2g9d2FsbGV0JyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly93YWxsZXRib3QubWUvdG9uY29ubmVjdC1icmlkZ2UvYnJpZGdlJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnaW9zJywgJ2FuZHJvaWQnLCAnbWFjb3MnLCAnd2luZG93cycsICdsaW51eCddLFxuICAgICAgICBmZWF0dXJlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VzOiAyNTUsXG4gICAgICAgICAgICAgICAgZXh0cmFDdXJyZW5jeVN1cHBvcnRlZDogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2lnbkRhdGEnLFxuICAgICAgICAgICAgICAgIHR5cGVzOiBbJ3RleHQnLCAnYmluYXJ5JywgJ2NlbGwnXVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAndG9ua2VlcGVyJyxcbiAgICAgICAgbmFtZTogJ1RvbmtlZXBlcicsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly90b25rZWVwZXIuY29tL2Fzc2V0cy90b25jb25uZWN0LWljb24ucG5nJyxcbiAgICAgICAgdG9uZG5zOiAndG9ua2VlcGVyLnRvbicsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vdG9ua2VlcGVyLmNvbScsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL2FwcC50b25rZWVwZXIuY29tL3Rvbi1jb25uZWN0JyxcbiAgICAgICAgZGVlcExpbms6ICd0b25rZWVwZXItdGM6Ly8nLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3NlJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL2JyaWRnZS50b25hcGkuaW8vYnJpZGdlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnanMnLFxuICAgICAgICAgICAgICAgIGtleTogJ3RvbmtlZXBlcidcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2lvcycsICdhbmRyb2lkJywgJ2Nocm9tZScsICdmaXJlZm94JywgJ21hY29zJ10sXG4gICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgbWF4TWVzc2FnZXM6IDI1NSxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTaWduRGF0YScsXG4gICAgICAgICAgICAgICAgdHlwZXM6IFsndGV4dCcsICdiaW5hcnknLCAnY2VsbCddXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdteXRvbndhbGxldCcsXG4gICAgICAgIG5hbWU6ICdNeVRvbldhbGxldCcsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9zdGF0aWMubXl0b253YWxsZXQuaW8vaWNvbi0yNTYucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly9teXRvbndhbGxldC5pbycsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL2Nvbm5lY3QubXl0b253YWxsZXQub3JnJyxcbiAgICAgICAgZGVlcExpbms6ICdteXRvbndhbGxldC10YzovLycsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdqcycsXG4gICAgICAgICAgICAgICAga2V5OiAnbXl0b253YWxsZXQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vdG9uY29ubmVjdGJyaWRnZS5teXRvbndhbGxldC5vcmcvYnJpZGdlLydcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2Nocm9tZScsICd3aW5kb3dzJywgJ21hY29zJywgJ2xpbnV4JywgJ2lvcycsICdhbmRyb2lkJywgJ2ZpcmVmb3gnXSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogMjU1LFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTaWduRGF0YScsXG4gICAgICAgICAgICAgICAgdHlwZXM6IFsndGV4dCcsICdiaW5hcnknLCAnY2VsbCddXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICd0b25odWInLFxuICAgICAgICBuYW1lOiAnVG9uaHViJyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3Rvbmh1Yi5jb20vdG9uY29ubmVjdF9sb2dvLnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vdG9uaHViLmNvbScsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL3Rvbmh1Yi5jb20vdG9uLWNvbm5lY3QnLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnanMnLFxuICAgICAgICAgICAgICAgIGtleTogJ3Rvbmh1YidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9jb25uZWN0LnRvbmh1YmFwaS5jb20vdG9uY29ubmVjdCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2lvcycsICdhbmRyb2lkJ10sXG4gICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgbWF4TWVzc2FnZXM6IDI1NSxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTaWduRGF0YScsXG4gICAgICAgICAgICAgICAgdHlwZXM6IFsndGV4dCcsICdiaW5hcnknLCAnY2VsbCddXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdiaXRnZXRUb25XYWxsZXQnLFxuICAgICAgICBuYW1lOiAnQml0Z2V0IFdhbGxldCcsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2JpdGdldHdhbGxldC9kb3dubG9hZC9yZWZzL2hlYWRzL21haW4vbG9nby9wbmcvYml0Z2V0X3dhbGxldF9sb2dvXzI4OF9taW5pLnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vd2ViMy5iaXRnZXQuY29tJyxcbiAgICAgICAgZGVlcExpbms6ICdiaXRrZWVwOi8vJyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdiaXRnZXRUb25XYWxsZXQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vdG9uLWNvbm5lY3QtYnJpZGdlLmJnd2FwaS5pby9icmlkZ2UnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydpb3MnLCAnYW5kcm9pZCcsICdjaHJvbWUnXSxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vYmtjb2RlLnZpcC90b24tY29ubmVjdCcsXG4gICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgbWF4TWVzc2FnZXM6IDQsXG4gICAgICAgICAgICAgICAgZXh0cmFDdXJyZW5jeVN1cHBvcnRlZDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ29reE1pbmlXYWxsZXQnLFxuICAgICAgICBuYW1lOiAnT0tYIE1pbmkgV2FsbGV0JyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3N0YXRpYy5va3guY29tL2Nkbi9hc3NldHMvaW1ncy8yNDExLzhCRTFBNEE0MzREOEY1OEEucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly93d3cub2t4LmNvbS93ZWIzJyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vdC5tZS9PS1hfV0FMTEVUX0JPVD9hdHRhY2g9d2FsbGV0JyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly93d3cub2t4LmNvbS90b25icmlkZ2UvZGlzY292ZXIvcnBjL2JyaWRnZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2lvcycsICdhbmRyb2lkJywgJ21hY29zJywgJ3dpbmRvd3MnLCAnbGludXgnXSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogNCxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAnYmluYW5jZVdlYjNUb25XYWxsZXQnLFxuICAgICAgICBuYW1lOiAnQmluYW5jZSBXYWxsZXQnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vcHVibGljLmJuYnN0YXRpYy5jb20vc3RhdGljL2JpbmFuY2UtdzN3L3Rvbi1wcm92aWRlci9iaW5hbmNldzN3LnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vd3d3LmJpbmFuY2UuY29tL2VuL3dlYjN3YWxsZXQnLFxuICAgICAgICBkZWVwTGluazogJ2JuYzovL2FwcC5iaW5hbmNlLmNvbS9jZWRlZmkvdG9uLWNvbm5lY3QnLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnanMnLFxuICAgICAgICAgICAgICAgIGtleTogJ2JpbmFuY2V3M3cnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vd2FsbGV0LmJpbmFuY2UuY29tL3RvbmJyaWRnZS9icmlkZ2UnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydpb3MnLCAnYW5kcm9pZCcsICdtYWNvcycsICd3aW5kb3dzJywgJ2xpbnV4J10sXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL2FwcC5iaW5hbmNlLmNvbS9jZWRlZmkvdG9uLWNvbm5lY3QnLFxuICAgICAgICBmZWF0dXJlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VzOiA0LFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdmaW50b3Bpby10ZycsXG4gICAgICAgIG5hbWU6ICdGaW50b3BpbycsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2ZpbnRvcGlvL3Rvbi1wdWIvcmVmcy9oZWFkcy9tYWluL2xvZ29zL3RvbmNvbm5lY3QtaWNvbi5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL2ZpbnRvcGlvLmNvbScsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL3QubWUvZmludG9waW8/YXR0YWNoPXdhbGxldCcsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vd2FsbGV0LWJyaWRnZS5maW50b3Bpby5jb20vYnJpZGdlJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnaW9zJywgJ2FuZHJvaWQnLCAnbWFjb3MnLCAnd2luZG93cycsICdsaW51eCddLFxuICAgICAgICBmZWF0dXJlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VzOiA0LFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdva3hUb25XYWxsZXQnLFxuICAgICAgICBuYW1lOiAnT0tYIFdhbGxldCcsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9zdGF0aWMub2t4LmNvbS9jZG4vYXNzZXRzL2ltZ3MvMjQ3LzU4RTYzRkVBNDdBMkI3RDcucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly93d3cub2t4LmNvbS93ZWIzJyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vd3d3Lm9reC5jb20vZG93bmxvYWQ/YXBwZW5kUXVlcnk9dHJ1ZSZkZWVwbGluaz1va3g6Ly93ZWIzL3dhbGxldC90b25jb25uZWN0JyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdva3hUb25XYWxsZXQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vd3d3Lm9reC5jb20vdG9uYnJpZGdlL2Rpc2NvdmVyL3JwYy9icmlkZ2UnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydjaHJvbWUnLCAnc2FmYXJpJywgJ2ZpcmVmb3gnLCAnaW9zJywgJ2FuZHJvaWQnXSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogNCxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAnaG90JyxcbiAgICAgICAgbmFtZTogJ0hPVCcsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2hvdC1kYW8vbWVkaWEvbWFpbi9sb2dvLnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vaG90LWxhYnMub3JnLycsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL3QubWUvaGVyZXdhbGxldGJvdD9hdHRhY2g9d2FsbGV0JyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9zc2UtYnJpZGdlLmhvdC1sYWJzLm9yZydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdob3RXYWxsZXQnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydpb3MnLCAnYW5kcm9pZCcsICdtYWNvcycsICd3aW5kb3dzJywgJ2xpbnV4J10sXG4gICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgbWF4TWVzc2FnZXM6IDQsXG4gICAgICAgICAgICAgICAgZXh0cmFDdXJyZW5jeVN1cHBvcnRlZDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ2J5Yml0VG9uV2FsbGV0JyxcbiAgICAgICAgbmFtZTogJ0J5Yml0IFdhbGxldCcsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2J5Yml0LXdlYjMvYnliaXQtd2ViMy5naXRodWIuaW8vbWFpbi9kb2NzL2ltYWdlcy9ieWJpdC1sb2dvLnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vd3d3LmJ5Yml0LmNvbS93ZWIzJyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vYXBwLmJ5Yml0LmNvbS90b24tY29ubmVjdCcsXG4gICAgICAgIGRlZXBMaW5rOiAnYnliaXRhcHA6Ly8nLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnanMnLFxuICAgICAgICAgICAgICAgIGtleTogJ2J5Yml0VG9uV2FsbGV0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3NlJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL2FwaS1ub2RlLmJ5Yml0LmNvbS9zcG90L2FwaS93ZWIzL2JyaWRnZS90b24vYnJpZGdlJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnaW9zJywgJ2FuZHJvaWQnLCAnY2hyb21lJ10sXG4gICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgbWF4TWVzc2FnZXM6IDQsXG4gICAgICAgICAgICAgICAgZXh0cmFDdXJyZW5jeVN1cHBvcnRlZDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ2Rld2FsbGV0JyxcbiAgICAgICAgbmFtZTogJ0RlV2FsbGV0JyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZGVsYWItdGVhbS9tYW5pZmVzdHMtaW1hZ2VzL21haW4vV2FsbGV0QXZhdGFyLnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vZGVsYWJ3YWxsZXQuY29tJyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vdC5tZS9kZXdhbGxldD9hdHRhY2g9d2FsbGV0JyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9icmlkZ2UuZGV3YWxsZXQucHJvL2JyaWRnZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2lvcycsICdhbmRyb2lkJywgJ21hY29zJywgJ3dpbmRvd3MnLCAnbGludXgnXSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogNCxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAnc2FmZXBhbHdhbGxldCcsXG4gICAgICAgIG5hbWU6ICdTYWZlUGFsJyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3MucHZjbGlwaW5nLmNvbS93ZWIvcHVibGljX2ltYWdlL1NhZmVQYWxfeDI4OC5wbmcnLFxuICAgICAgICB0b25kbnM6ICcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL3d3dy5zYWZlcGFsLmNvbScsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL2xpbmsuc2FmZXBhbC5pby90b24tY29ubmVjdCcsXG4gICAgICAgIGRlZXBMaW5rOiAnc2FmZXBhbC10YzovLycsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vdG9uLWJyaWRnZS5zYWZlcGFsLmNvbS90b25icmlkZ2UvdjEvYnJpZGdlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnanMnLFxuICAgICAgICAgICAgICAgIGtleTogJ3NhZmVwYWx3YWxsZXQnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydpb3MnLCAnYW5kcm9pZCcsICdjaHJvbWUnLCAnZmlyZWZveCddLFxuICAgICAgICBmZWF0dXJlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VzOiAxLFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdHYXRlV2FsbGV0JyxcbiAgICAgICAgbmFtZTogJ0dhdGVXYWxsZXQnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vaW1nLmdhdGVkYXRhaW1nLmNvbS9wcmQtb3JkaW5hbC1pbWdzLzAzNmYwN2JiODczMDcxNmUvZ2F0ZWlvLTA5MjUucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly93d3cuZ2F0ZS5pby8nLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnanMnLFxuICAgICAgICAgICAgICAgIGtleTogJ2dhdGV0b253YWxsZXQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vZGFwcC5nYXRlaW8uc2VydmljZXMvdG9uYnJpZGdlX2FwaS9icmlkZ2UvdjEnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydpb3MnLCAnYW5kcm9pZCddLFxuICAgICAgICB1bml2ZXJzYWxfdXJsOiAnaHR0cHM6Ly9nYXRlLm9uZWxpbmsubWUvSGxzMC93ZWIzP2dhdGVfd2ViM193YWxsZXRfdW5pdmVyc2FsX3R5cGU9dG9uX2Nvbm5lY3QnLFxuICAgICAgICBmZWF0dXJlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VzOiA0LFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdvcGVubWFzaycsXG4gICAgICAgIG5hbWU6ICdPcGVuTWFzaycsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL09wZW5Qcm9kdWN0L29wZW5tYXNrLWV4dGVuc2lvbi9tYWluL3B1YmxpYy9vcGVubWFzay1sb2dvLTI4OC5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL3d3dy5vcGVubWFzay5hcHAvJyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdvcGVubWFzaydcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2Nocm9tZSddLFxuICAgICAgICBmZWF0dXJlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VzOiA0LFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdCaXRnZXRXZWIzJyxcbiAgICAgICAgbmFtZTogJ0JpdGdldFdlYjMnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vaW1nLmJpdGdldGltZy5jb20vaW1hZ2UvdGhpcmQvMTczMTYzODA1OTc5NS5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICfigItodHRwczovL3d3dy5iaXRnZXQuY29tJyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vdC5tZS9CaXRnZXRPZmZpY2lhbEJvdD9hdHRhY2g9d2FsbGV0JyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly90b24tY29ubmVjdC1icmlkZ2UuYmd3YXBpLmlvL2JyaWRnZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2lvcycsICdhbmRyb2lkJywgJ3dpbmRvd3MnLCAnbWFjb3MnLCAnbGludXgnXSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogNCxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAneHRvbndhbGxldCcsXG4gICAgICAgIG5hbWU6ICdYVE9OV2FsbGV0JyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3h0b253YWxsZXQuY29tL2Fzc2V0cy9pbWcvaWNvbi0yNTYtYmFjay5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL3h0b253YWxsZXQuY29tJyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzJyxcbiAgICAgICAgICAgICAgICBrZXk6ICd4dG9ud2FsbGV0J1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnY2hyb21lJywgJ2ZpcmVmb3gnXSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogMSxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAndG9ud2FsbGV0JyxcbiAgICAgICAgbmFtZTogJ1RPTiBXYWxsZXQnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vd2FsbGV0LnRvbi5vcmcvYXNzZXRzL3VpL3FyLWxvZ28ucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvdG9uLXdhbGxldC9ucGhwbHBnb2FraGhqY2hra2htaWdnYWtpam5raGZuZCcsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdqcycsXG4gICAgICAgICAgICAgICAga2V5OiAndG9ud2FsbGV0J1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnY2hyb21lJ10sXG4gICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgbWF4TWVzc2FnZXM6IDQsXG4gICAgICAgICAgICAgICAgZXh0cmFDdXJyZW5jeVN1cHBvcnRlZDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ2JpdGdldFdhbGxldExpdGUnLFxuICAgICAgICBuYW1lOiAnQml0Z2V0IFdhbGxldCBMaXRlJyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYml0Z2V0d2FsbGV0L2Rvd25sb2FkL3JlZnMvaGVhZHMvbWFpbi9sb2dvL3BuZy9iaXRnZXRfd2FsbGV0X2xpdGVfbG9nb18yODgucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly93ZWIzLmJpdGdldC5jb20nLFxuICAgICAgICB1bml2ZXJzYWxfdXJsOiAnaHR0cHM6Ly90Lm1lL0JpdGdldFdhbGxldF9UR0JvdD9hdHRhY2g9d2FsbGV0JyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly90b24tY29ubmVjdC1icmlkZ2UuYmd3YXBpLmlvL2JyaWRnZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2lvcycsICdhbmRyb2lkJywgJ21hY29zJywgJ3dpbmRvd3MnLCAnbGludXgnXSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogMjU1LFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICd0b21vV2FsbGV0JyxcbiAgICAgICAgbmFtZTogJ1RvbW8gV2FsbGV0JyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3B1Yi50b21vLmluYy9sb2dvLnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vd3d3LnRvbW8uaW5jLycsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL3QubWUvdG9tb3dhbGxldGJvdD9hdHRhY2g9d2FsbGV0JyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9nby1icmlkZ2UudG9tby5pbmMvYnJpZGdlJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnaW9zJywgJ2FuZHJvaWQnLCAnbWFjb3MnLCAnd2luZG93cycsICdsaW51eCddLFxuICAgICAgICBmZWF0dXJlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VzOiA0LFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdtaXJhaWFwcC10ZycsXG4gICAgICAgIG5hbWU6ICdNaXJhaSBNaW5pIEFwcCcsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9jZG4ubWlyYWlsYWJzLmNvL21pcmFpaHViL21pcmFpYXBwLXRnLWljb24tMjg4LnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vbWlyYWkuYXBwJyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vdC5tZS9NaXJhaUFwcEJvdD9hdHRhY2g9d2FsbGV0JyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9icmlkZ2UubWlyYWkuYXBwJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnaW9zJywgJ2FuZHJvaWQnLCAnbWFjb3MnLCAnd2luZG93cycsICdsaW51eCddLFxuICAgICAgICBmZWF0dXJlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VzOiAyNTUsXG4gICAgICAgICAgICAgICAgZXh0cmFDdXJyZW5jeVN1cHBvcnRlZDogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NpZ25EYXRhJyxcbiAgICAgICAgICAgICAgICB0eXBlczogWyd0ZXh0JywgJ2JpbmFyeScsICdjZWxsJ11cbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ0FyY2hpdGVjLnRvbicsXG4gICAgICAgIG5hbWU6ICdBcmNoaXRlYy50b24nLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9BcmNoaXRlYy1Ub24vd2FsbGV0LXRtYS9yZWZzL2hlYWRzL2Rldi9wdWJsaWMvaW1hZ2VzL2FyY3dhbGxldF9sb2dvLnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vYXJjaGl0ZWN0b24udGVjaCcsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL3QubWUvYXJjaGl0ZWNfdG9uX2JvdD9hdHRhY2g9d2FsbGV0JyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly90Yy5hcmNoaXRlY3Rvbi5zdS9icmlkZ2UnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydpb3MnLCAnYW5kcm9pZCcsICdtYWNvcycsICd3aW5kb3dzJywgJ2xpbnV4J10sXG4gICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgbWF4TWVzc2FnZXM6IDI1NSxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAndG9rZW5wb2NrZXQnLFxuICAgICAgICBuYW1lOiAnVG9rZW5Qb2NrZXQnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vaGsudHBzdGF0aWMubmV0L2xvZ28vdG9rZW5wb2NrZXQucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly93d3cudG9rZW5wb2NrZXQucHJvJyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vdHAtbGFiLnRwdG9vbC5wcm8vdG9uLWNvbm5lY3QvJyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzJyxcbiAgICAgICAgICAgICAgICBrZXk6ICd0b2tlbnBvY2tldCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly90b24tY29ubmVjdC5teXRva2VucG9ja2V0LnZpcC9icmlkZ2UnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydpb3MnLCAnYW5kcm9pZCddLFxuICAgICAgICBmZWF0dXJlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VzOiA0LFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICd1eHV5V2FsbGV0JyxcbiAgICAgICAgbmFtZTogJ1VYVVkgV2FsbGV0JyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL2NoYWluLWNkbi51eHV5LmNvbS9sb2dvL3NxdWFyZV8yODgucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly9kb2NzLnV4dXkuY29tJyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vdC5tZS9VWFVZYm90P2F0dGFjaD13YWxsZXQnLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3NlJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL2JyaWRnZS51eHV5Lm1lL2JyaWRnZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2lvcycsICdhbmRyb2lkJywgJ21hY29zJywgJ3dpbmRvd3MnLCAnbGludXgnXSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogNCxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAndG9ua2VlcGVyLXBybycsXG4gICAgICAgIG5hbWU6ICdUb25rZWVwZXIgUHJvJyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3RvbmtlZXBlci5jb20vYXNzZXRzL3RvbmNvbm5lY3QtaWNvbi1wcm8ucG5nJyxcbiAgICAgICAgdG9uZG5zOiAndG9ua2VlcGVyLnRvbicsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vdG9ua2VlcGVyLmNvbS9wcm8nLFxuICAgICAgICB1bml2ZXJzYWxfdXJsOiAnaHR0cHM6Ly9hcHAudG9ua2VlcGVyLmNvbS9wcm8vdG9uLWNvbm5lY3QnLFxuICAgICAgICBkZWVwTGluazogJ3RvbmtlZXBlci1wcm8tdGM6Ly8nLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3NlJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL2JyaWRnZS50b25hcGkuaW8vYnJpZGdlJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnaW9zJywgJ21hY29zJywgJ3dpbmRvd3MnLCAnbGludXgnXSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogMjU1LFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NpZ25EYXRhJyxcbiAgICAgICAgICAgICAgICB0eXBlczogWyd0ZXh0JywgJ2JpbmFyeScsICdjZWxsJ11cbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ25pY2VncmFtV2FsbGV0JyxcbiAgICAgICAgbmFtZTogJ05pY2VncmFtIFdhbGxldCcsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9zdGF0aWMubmljZWdyYW0uYXBwL2ljb24ucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly9uaWNlZ3JhbS5hcHAnLFxuICAgICAgICB1bml2ZXJzYWxfdXJsOiAnaHR0cHM6Ly9uaWNlZ3JhbS5hcHAvdGMnLFxuICAgICAgICBkZWVwTGluazogJ25pY2VncmFtLXRjOi8vJyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly90Yy5uaWNlZ3JhbS5hcHAvYnJpZGdlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnanMnLFxuICAgICAgICAgICAgICAgIGtleTogJ25pY2VncmFtV2FsbGV0J1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnaW9zJywgJ2FuZHJvaWQnXSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogMjU1LFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdlY2hvb29Ub25XYWxsZXQnLFxuICAgICAgICBuYW1lOiAnRWNob29vV2FsbGV0JyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL2Nkbi5lY2hvb28ueHl6L2Zyb250LWVuZC9zb3VyY2UvaW1hZ2VzL2xvZ28vZWNob29vLXRvbi5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL3d3dy5lY2hvb28ueHl6JyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vd3d3LmVjaG9vby54eXovdG9uLWNvbm5lY3QnLFxuICAgICAgICBkZWVwTGluazogJ2VjaG9vbzovLycsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdqcycsXG4gICAgICAgICAgICAgICAga2V5OiAnZWNob29vVG9uV2FsbGV0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3NlJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL3Rvbi1jb25uZWN0LWJyaWRnZS5lY2hvb28ubGluay9icmlkZ2UnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydpb3MnLCAnYW5kcm9pZCddLFxuICAgICAgICBmZWF0dXJlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VzOiAyNTUsXG4gICAgICAgICAgICAgICAgZXh0cmFDdXJyZW5jeVN1cHBvcnRlZDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ2JsaXR6d2FsbGV0JyxcbiAgICAgICAgbmFtZTogJ0JMSVRaIHdhbGxldCcsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9ibGl0endhbGxldC5jZmQvd2FsbGV0L3B1YmxpYy9sb2dvLnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vYmxpdHp3YWxsZXQuY2ZkJyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vdC5tZS9ibGl0el93YWxsZXRfYm90P2F0dGFjaD13YWxsZXQnLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3NlJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL2JsaXR6d2FsbGV0LmNmZC9icmlkZ2UvJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnaW9zJywgJ2FuZHJvaWQnLCAnbWFjb3MnLCAnd2luZG93cycsICdsaW51eCddLFxuICAgICAgICBmZWF0dXJlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VzOiA0LFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdrb2xvV2ViM1dhbGxldCcsXG4gICAgICAgIG5hbWU6ICdLb2xvJyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vb25pZGV2MS90Yy1hc3NldHMvcmVmcy9oZWFkcy9tYWluL2tvbG9fbG9nb18yODgucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly9rb2xvLnh5eicsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL3QubWUva29sbz9hdHRhY2g9d2FsbGV0JyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly93ZWIzLWJyaWRnZS5rb2xvLmluL2JyaWRnZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2lvcycsICdhbmRyb2lkJywgJ21hY29zJywgJ3dpbmRvd3MnLCAnbGludXgnXSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogMjU1LFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdpbVRva2VuJyxcbiAgICAgICAgbmFtZTogJ2ltVG9rZW4nLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vYXdzLXYyLWNkbi50b2tlbi5pbS9vcmJpdC90b2tlbi12Mi9pY29ucy9sb2dvLXRvbi1jb25uZWN0LnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vdG9rZW4uaW0nLFxuICAgICAgICB1bml2ZXJzYWxfdXJsOiAnaHR0cHM6Ly9jb25uZWN0LnRva2VuLmltL2xpbmsvdG9uLWNvbm5lY3QnLFxuICAgICAgICBkZWVwTGluazogJ2ltdG9rZW52MjovL2xpbmsvdG9uLWNvbm5lY3QnLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3NlJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL2Nvbm5lY3QudG9rZW4uaW0vdG9uYnJpZGdlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnanMnLFxuICAgICAgICAgICAgICAgIGtleTogJ2ltVG9rZW4nXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydpb3MnLCAnYW5kcm9pZCddLFxuICAgICAgICBmZWF0dXJlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VzOiAyNTUsXG4gICAgICAgICAgICAgICAgZXh0cmFDdXJyZW5jeVN1cHBvcnRlZDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ2NhY3R1c2xpbmsnLFxuICAgICAgICBuYW1lOiAnQ2FjdHVzIExpbmsnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vZG93bmxvYWRzLm15Y2FjdHVzLmNvbS8yODhfY2FjdHVzX2xpbmsucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly93d3cubXljYWN0dXMuY29tL2RlZmktY29ubmVjdG9yJyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdjYWN0dXNsaW5rX3RvbidcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2Nocm9tZSddLFxuICAgICAgICBmZWF0dXJlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VzOiA0LFxuICAgICAgICAgICAgICAgIGV4dHJhQ3VycmVuY3lTdXBwb3J0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTaWduRGF0YScsXG4gICAgICAgICAgICAgICAgdHlwZXM6IFsndGV4dCcsICdiaW5hcnknXVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAnb25la2V5JyxcbiAgICAgICAgbmFtZTogJ09uZUtleScsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly91bmkub25la2V5LWFzc2V0LmNvbS9zdGF0aWMvbG9nby9vbmVrZXkteDI4OC5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL29uZWtleS5zbycsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdqcycsXG4gICAgICAgICAgICAgICAga2V5OiAnb25la2V5VG9uV2FsbGV0J1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnY2hyb21lJ10sXG4gICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgbWF4TWVzc2FnZXM6IDQsXG4gICAgICAgICAgICAgICAgZXh0cmFDdXJyZW5jeVN1cHBvcnRlZDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH1cbl07XG5cbmxldCBxYU1vZGVFbmFibGVkID0gZmFsc2U7XG5sZXQgYmFubmVyT2JzZXJ2ZXIgPSBudWxsO1xuZnVuY3Rpb24gZW5hYmxlUWFNb2RlKCkge1xuICAgIHFhTW9kZUVuYWJsZWQgPSB0cnVlO1xuICAgIGNvbnNvbGUud2Fybign8J+aqCBRQSBNb2RlIGVuYWJsZWQgLSB2YWxpZGF0aW9uIGlzIGRpc2FibGVkLiBUaGlzIGlzIHVuc2FmZSBmb3IgcHJvZHVjdGlvbiEnKTtcbiAgICBzaG93UWFNb2RlQmFubmVyKCk7XG4gICAgc3RhcnRCYW5uZXJPYnNlcnZlcigpO1xuICAgIGFkZFFhTW9kZVN0eWxlcygpO1xufVxuZnVuY3Rpb24gaXNRYU1vZGVFbmFibGVkKCkge1xuICAgIHJldHVybiBxYU1vZGVFbmFibGVkO1xufVxuZnVuY3Rpb24gc2hvd1FhTW9kZUJhbm5lcigpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBleGlzdGluZ0Jhbm5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0b24tY29ubmVjdC1xYS1iYW5uZXInKTtcbiAgICBpZiAoZXhpc3RpbmdCYW5uZXIpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBiYW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBiYW5uZXIuaWQgPSAndG9uLWNvbm5lY3QtcWEtYmFubmVyJztcbiAgICBiYW5uZXIuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICNmZjZiNmIsICNmZjhlOGUpO1xuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIHBhZGRpbmc6IDEycHggMjBweDtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAnU2Vnb2UgVUknLCBSb2JvdG8sIHNhbnMtc2VyaWY7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgei1pbmRleDogOTk5OTk5O1xuICAgICAgICBib3gtc2hhZG93OiAwIDJweCA4cHggcmdiYSgwLDAsMCwwLjIpO1xuICAgICAgICBhbmltYXRpb246IHNsaWRlRG93biAwLjNzIGVhc2Utb3V0O1xuICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgYDtcbiAgICBiYW5uZXIuaW5uZXJIVE1MID0gYFxuICAgICAgICDwn5qoIFFBIE1vZGUgQWN0aXZlIC0gVmFsaWRhdGlvbiBEaXNhYmxlZCAoVW5zYWZlIGZvciBQcm9kdWN0aW9uKVxuICAgIGA7XG4gICAgLy8gQWRkIENTUyBhbmltYXRpb25cbiAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgc3R5bGUudGV4dENvbnRlbnQgPSBgXG4gICAgICAgIEBrZXlmcmFtZXMgc2xpZGVEb3duIHtcbiAgICAgICAgICAgIGZyb20geyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTEwMCUpOyB9XG4gICAgICAgICAgICB0byB7IHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTsgfVxuICAgICAgICB9XG4gICAgYDtcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGJhbm5lcik7XG4gICAgYWRkUWFNb2RlU3R5bGVzKCk7XG59XG5mdW5jdGlvbiBhZGRRYU1vZGVTdHlsZXMoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgZXhpc3RpbmdTdHlsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0b24tY29ubmVjdC1xYS1tb2RlLXN0eWxlcycpO1xuICAgIGlmIChleGlzdGluZ1N0eWxlKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlLmlkID0gJ3Rvbi1jb25uZWN0LXFhLW1vZGUtc3R5bGVzJztcbiAgICBzdHlsZS50ZXh0Q29udGVudCA9IGBcbiAgICAgICAgYm9keS5xYS1tb2RlLWFjdGl2ZSB7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogNDhweCAhaW1wb3J0YW50O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBib2R5LnFhLW1vZGUtYWN0aXZlIGhlYWRlciB7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiA0OHB4ICFpbXBvcnRhbnQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGJvZHkucWEtbW9kZS1hY3RpdmUgLnFhLW1vZGUtY29udHJvbCB7XG4gICAgICAgICAgICB0b3A6IDEyOHB4ICFpbXBvcnRhbnQ7XG4gICAgICAgIH1cbiAgICBgO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgncWEtbW9kZS1hY3RpdmUnKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0QmFubmVyT2JzZXJ2ZXIoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IGJhbm5lck9ic2VydmVyKVxuICAgICAgICByZXR1cm47XG4gICAgYmFubmVyT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgICBtdXRhdGlvbnMuZm9yRWFjaChtdXRhdGlvbiA9PiB7XG4gICAgICAgICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICAgICAgICBtdXRhdGlvbi5yZW1vdmVkTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmlkID09PSAndG9uLWNvbm5lY3QtcWEtYmFubmVyJyAmJiBxYU1vZGVFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdRQSBNb2RlIGJhbm5lciB3YXMgcmVtb3ZlZCwgcmVzdG9yaW5nLi4uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzaG93UWFNb2RlQmFubmVyKCksIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbGVtZW50LmlkID09PSAndG9uLWNvbm5lY3QtcWEtbW9kZS1zdHlsZXMnICYmIHFhTW9kZUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1FBIE1vZGUgc3R5bGVzIHdlcmUgcmVtb3ZlZCwgcmVzdG9yaW5nLi4uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBhZGRRYU1vZGVTdHlsZXMoKSwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBiYW5uZXJPYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmJvZHksIHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiBmYWxzZVxuICAgIH0pO1xuICAgIGJhbm5lck9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuaGVhZCwge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IGZhbHNlXG4gICAgfSk7XG59XG5cbmNsYXNzIFdhbGxldHNMaXN0TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMud2FsbGV0c0xpc3REVE9DYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMud2FsbGV0c0xpc3REVE9DYWNoZUNyZWF0aW9uVGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgaWYgKGlzUWFNb2RlRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLndhbGxldHNMaXN0U291cmNlID1cbiAgICAgICAgICAgICAgICAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3Rvbi1jb25uZWN0L3dhbGxldHMtbGlzdC1zdGFnaW5nL3JlZnMvaGVhZHMvbWFpbi93YWxsZXRzLXYyLmpzb24nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53YWxsZXRzTGlzdFNvdXJjZSA9XG4gICAgICAgICAgICAgICAgKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndhbGxldHNMaXN0U291cmNlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnaHR0cHM6Ly9jb25maWcudG9uLm9yZy93YWxsZXRzLXYyLmpzb24nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGVUVExNcyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYWNoZVRUTE1zO1xuICAgICAgICB0aGlzLm9uRG93bmxvYWREdXJhdGlvbk1lYXN1cmVkID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uRG93bmxvYWREdXJhdGlvbk1lYXN1cmVkO1xuICAgIH1cbiAgICBnZXRXYWxsZXRzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgW3dhbGxldHNMaXN0RFRPLCBjdXJyZW50bHlJbmplY3RlZFdhbGxldHNdID0geWllbGQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMuZmV0Y2hXYWxsZXRzTGlzdERUTygpLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q3VycmVudGx5SW5qZWN0ZWRXYWxsZXRzKClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2VXYWxsZXRzTGlzdHModGhpcy53YWxsZXRDb25maWdEVE9MaXN0VG9XYWxsZXRDb25maWdMaXN0KHdhbGxldHNMaXN0RFRPKSwgY3VycmVudGx5SW5qZWN0ZWRXYWxsZXRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEVtYmVkZGVkV2FsbGV0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgd2FsbGV0c0xpc3QgPSB5aWVsZCB0aGlzLmdldFdhbGxldHMoKTtcbiAgICAgICAgICAgIGNvbnN0IGVtYmVkZGVkV2FsbGV0cyA9IHdhbGxldHNMaXN0LmZpbHRlcihpc1dhbGxldEluZm9DdXJyZW50bHlFbWJlZGRlZCk7XG4gICAgICAgICAgICByZXR1cm4gZW1iZWRkZWRXYWxsZXRzLmxlbmd0aCA9PT0gMSA/IGVtYmVkZGVkV2FsbGV0c1swXSA6IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmZXRjaFdhbGxldHNMaXN0RFRPKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGVUVExNcyAmJlxuICAgICAgICAgICAgICAgIHRoaXMud2FsbGV0c0xpc3REVE9DYWNoZUNyZWF0aW9uVGltZXN0YW1wICYmXG4gICAgICAgICAgICAgICAgRGF0ZS5ub3coKSA+IHRoaXMud2FsbGV0c0xpc3REVE9DYWNoZUNyZWF0aW9uVGltZXN0YW1wICsgdGhpcy5jYWNoZVRUTE1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxsZXRzTGlzdERUT0NhY2hlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy53YWxsZXRzTGlzdERUT0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxsZXRzTGlzdERUT0NhY2hlID0gdGhpcy5mZXRjaFdhbGxldHNMaXN0RnJvbVNvdXJjZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMud2FsbGV0c0xpc3REVE9DYWNoZVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2FsbGV0c0xpc3REVE9DYWNoZUNyZWF0aW9uVGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndhbGxldHNMaXN0RFRPQ2FjaGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndhbGxldHNMaXN0RFRPQ2FjaGVDcmVhdGlvblRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53YWxsZXRzTGlzdERUT0NhY2hlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UmVtb3RlV2FsbGV0KGFwcE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHdhbGxldHNMaXN0ID0geWllbGQgdGhpcy5nZXRXYWxsZXRzKCk7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXQgPSB3YWxsZXRzTGlzdC5maW5kKHdhbGxldCA9PiB3YWxsZXQuYXBwTmFtZSA9PT0gYXBwTmFtZSk7XG4gICAgICAgICAgICBpZiAoIXdhbGxldCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoYFdhbGxldCBpbmZvIG5vdCBmb3VuZCBmb3IgYXBwTmFtZTogXCIke2FwcE5hbWV9XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNXYWxsZXRJbmZvUmVtb3RlKHdhbGxldCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKGBXYWxsZXQgXCIke2FwcE5hbWV9XCIgaXMgbm90IHJlbW90ZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdhbGxldDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZldGNoV2FsbGV0c0xpc3RGcm9tU291cmNlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGxldCB3YWxsZXRzTGlzdCA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhbGxldHNSZXNwb25zZSA9IHlpZWxkIGZldGNoKHRoaXMud2FsbGV0c0xpc3RTb3VyY2UpO1xuICAgICAgICAgICAgICAgIHdhbGxldHNMaXN0ID0geWllbGQgd2FsbGV0c1Jlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkod2FsbGV0c0xpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGZXRjaFdhbGxldHNFcnJvcignV3Jvbmcgd2FsbGV0cyBsaXN0IGZvcm1hdCwgd2FsbGV0cyBsaXN0IG11c3QgYmUgYW4gYXJyYXkuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHdyb25nRm9ybWF0V2FsbGV0cyA9IHdhbGxldHNMaXN0LmZpbHRlcih3YWxsZXQgPT4gIXRoaXMuaXNDb3JyZWN0V2FsbGV0Q29uZmlnRFRPKHdhbGxldCkpO1xuICAgICAgICAgICAgICAgIGlmICh3cm9uZ0Zvcm1hdFdhbGxldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Vycm9yKGBXYWxsZXQocykgJHt3cm9uZ0Zvcm1hdFdhbGxldHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAod2FsbGV0ID0+ICh3YWxsZXQgPT09IG51bGwgfHwgd2FsbGV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3YWxsZXQubmFtZSkgfHwgJ3Vua25vd24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyl9IGNvbmZpZyBmb3JtYXQgaXMgd3JvbmcuIFRoZXkgd2VyZSByZW1vdmVkIGZyb20gdGhlIHdhbGxldHMgbGlzdC5gKTtcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0c0xpc3QgPSB3YWxsZXRzTGlzdC5maWx0ZXIod2FsbGV0ID0+IHRoaXMuaXNDb3JyZWN0V2FsbGV0Q29uZmlnRFRPKHdhbGxldCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZHVyYXRpb24gPSBNYXRoLnJvdW5kKGVuZFRpbWUgLSBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMub25Eb3dubG9hZER1cmF0aW9uTWVhc3VyZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgd2FsbGV0c0xpc3QgPSBGQUxMQkFDS19XQUxMRVRTX0xJU1Q7XG4gICAgICAgICAgICAgICAgKF9iID0gdGhpcy5vbkRvd25sb2FkRHVyYXRpb25NZWFzdXJlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwodGhpcywgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3YWxsZXRzTGlzdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEN1cnJlbnRseUluamVjdGVkV2FsbGV0cygpIHtcbiAgICAgICAgaWYgKCFpc1FhTW9kZUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gSW5qZWN0ZWRQcm92aWRlci5nZXRDdXJyZW50bHlJbmplY3RlZFdhbGxldHMoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nRXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2FsbGV0Q29uZmlnRFRPTGlzdFRvV2FsbGV0Q29uZmlnTGlzdCh3YWxsZXRDb25maWdEVE8pIHtcbiAgICAgICAgcmV0dXJuIHdhbGxldENvbmZpZ0RUTy5tYXAod2FsbGV0Q29uZmlnRFRPID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHdhbGxldENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiB3YWxsZXRDb25maWdEVE8ubmFtZSxcbiAgICAgICAgICAgICAgICBhcHBOYW1lOiB3YWxsZXRDb25maWdEVE8uYXBwX25hbWUsXG4gICAgICAgICAgICAgICAgaW1hZ2VVcmw6IHdhbGxldENvbmZpZ0RUTy5pbWFnZSxcbiAgICAgICAgICAgICAgICBhYm91dFVybDogd2FsbGV0Q29uZmlnRFRPLmFib3V0X3VybCxcbiAgICAgICAgICAgICAgICB0b25kbnM6IHdhbGxldENvbmZpZ0RUTy50b25kbnMsXG4gICAgICAgICAgICAgICAgcGxhdGZvcm1zOiB3YWxsZXRDb25maWdEVE8ucGxhdGZvcm1zLFxuICAgICAgICAgICAgICAgIGZlYXR1cmVzOiB3YWxsZXRDb25maWdEVE8uZmVhdHVyZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3YWxsZXRDb25maWdEVE8uYnJpZGdlLmZvckVhY2goYnJpZGdlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYnJpZGdlLnR5cGUgPT09ICdzc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhbGxldENvbmZpZy5icmlkZ2VVcmwgPSBicmlkZ2UudXJsO1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXRDb25maWcudW5pdmVyc2FsTGluayA9XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXRDb25maWdEVE8udW5pdmVyc2FsX3VybDtcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0Q29uZmlnLmRlZXBMaW5rID0gd2FsbGV0Q29uZmlnRFRPLmRlZXBMaW5rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYnJpZGdlLnR5cGUgPT09ICdqcycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QganNCcmlkZ2VLZXkgPSBicmlkZ2Uua2V5O1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXRDb25maWcuanNCcmlkZ2VLZXkgPSBqc0JyaWRnZUtleTtcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0Q29uZmlnLmluamVjdGVkID1cbiAgICAgICAgICAgICAgICAgICAgICAgIEluamVjdGVkUHJvdmlkZXIuaXNXYWxsZXRJbmplY3RlZChqc0JyaWRnZUtleSk7XG4gICAgICAgICAgICAgICAgICAgIHdhbGxldENvbmZpZy5lbWJlZGRlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBJbmplY3RlZFByb3ZpZGVyLmlzSW5zaWRlV2FsbGV0QnJvd3Nlcihqc0JyaWRnZUtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gd2FsbGV0Q29uZmlnO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWVyZ2VXYWxsZXRzTGlzdHMobGlzdDEsIGxpc3QyKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gbmV3IFNldChsaXN0MS5jb25jYXQobGlzdDIpLm1hcChpdGVtID0+IGl0ZW0ubmFtZSkpO1xuICAgICAgICByZXR1cm4gWy4uLm5hbWVzLnZhbHVlcygpXS5tYXAobmFtZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsaXN0MUl0ZW0gPSBsaXN0MS5maW5kKGl0ZW0gPT4gaXRlbS5uYW1lID09PSBuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGxpc3QySXRlbSA9IGxpc3QyLmZpbmQoaXRlbSA9PiBpdGVtLm5hbWUgPT09IG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKGxpc3QxSXRlbSAmJiBPYmplY3QuYXNzaWduKHt9LCBsaXN0MUl0ZW0pKSksIChsaXN0Mkl0ZW0gJiYgT2JqZWN0LmFzc2lnbih7fSwgbGlzdDJJdGVtKSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICBpc0NvcnJlY3RXYWxsZXRDb25maWdEVE8odmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCAhKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbnNOYW1lID0gJ25hbWUnIGluIHZhbHVlO1xuICAgICAgICBjb25zdCBjb250YWluc0FwcE5hbWUgPSAnYXBwX25hbWUnIGluIHZhbHVlO1xuICAgICAgICBjb25zdCBjb250YWluc0ltYWdlID0gJ2ltYWdlJyBpbiB2YWx1ZTtcbiAgICAgICAgY29uc3QgY29udGFpbnNBYm91dCA9ICdhYm91dF91cmwnIGluIHZhbHVlO1xuICAgICAgICBjb25zdCBjb250YWluc1BsYXRmb3JtcyA9ICdwbGF0Zm9ybXMnIGluIHZhbHVlO1xuICAgICAgICBpZiAoIWNvbnRhaW5zTmFtZSB8fFxuICAgICAgICAgICAgIWNvbnRhaW5zSW1hZ2UgfHxcbiAgICAgICAgICAgICFjb250YWluc0Fib3V0IHx8XG4gICAgICAgICAgICAhY29udGFpbnNQbGF0Zm9ybXMgfHxcbiAgICAgICAgICAgICFjb250YWluc0FwcE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhbHVlLnBsYXRmb3JtcyB8fFxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUucGxhdGZvcm1zKSB8fFxuICAgICAgICAgICAgIXZhbHVlLnBsYXRmb3Jtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgnYnJpZGdlJyBpbiB2YWx1ZSkgfHxcbiAgICAgICAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlLmJyaWRnZSkgfHxcbiAgICAgICAgICAgICF2YWx1ZS5icmlkZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnJpZGdlID0gdmFsdWUuYnJpZGdlO1xuICAgICAgICBpZiAoYnJpZGdlLnNvbWUoaXRlbSA9PiAhaXRlbSB8fCB0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcgfHwgISgndHlwZScgaW4gaXRlbSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3NlQnJpZGdlID0gYnJpZGdlLmZpbmQoaXRlbSA9PiBpdGVtLnR5cGUgPT09ICdzc2UnKTtcbiAgICAgICAgaWYgKHNzZUJyaWRnZSkge1xuICAgICAgICAgICAgaWYgKCEodHlwZW9mIHNzZUJyaWRnZSA9PT0gJ29iamVjdCcgJiYgJ3VybCcgaW4gc3NlQnJpZGdlKSB8fFxuICAgICAgICAgICAgICAgICFzc2VCcmlkZ2UudXJsIHx8XG4gICAgICAgICAgICAgICAgIXZhbHVlLnVuaXZlcnNhbF91cmwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QganNCcmlkZ2UgPSBicmlkZ2UuZmluZChpdGVtID0+IGl0ZW0udHlwZSA9PT0gJ2pzJyk7XG4gICAgICAgIGlmIChqc0JyaWRnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc0JyaWRnZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICAgICAhKCdrZXknIGluIGpzQnJpZGdlKSB8fFxuICAgICAgICAgICAgICAgICFqc0JyaWRnZS5rZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1NlbmRUcmFuc2FjdGlvblN1cHBvcnQoZmVhdHVyZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdXBwb3J0c0RlcHJlY2F0ZWRTZW5kVHJhbnNhY3Rpb25GZWF0dXJlID0gZmVhdHVyZXMuaW5jbHVkZXMoJ1NlbmRUcmFuc2FjdGlvbicpO1xuICAgIGNvbnN0IHNlbmRUcmFuc2FjdGlvbkZlYXR1cmUgPSBmaW5kRmVhdHVyZShmZWF0dXJlcywgJ1NlbmRUcmFuc2FjdGlvbicpO1xuICAgIGNvbnN0IHJlcXVpcmVkRmVhdHVyZSA9IHtcbiAgICAgICAgbWluTWVzc2FnZXM6IG9wdGlvbnMucmVxdWlyZWRNZXNzYWdlc051bWJlcixcbiAgICAgICAgZXh0cmFDdXJyZW5jeVJlcXVpcmVkOiBvcHRpb25zLnJlcXVpcmVFeHRyYUN1cnJlbmNpZXNcbiAgICB9O1xuICAgIGlmICghc3VwcG9ydHNEZXByZWNhdGVkU2VuZFRyYW5zYWN0aW9uRmVhdHVyZSAmJiAhc2VuZFRyYW5zYWN0aW9uRmVhdHVyZSkge1xuICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90U3VwcG9ydEZlYXR1cmVFcnJvcihcIldhbGxldCBkb2Vzbid0IHN1cHBvcnQgU2VuZFRyYW5zYWN0aW9uIGZlYXR1cmUuXCIsIHtcbiAgICAgICAgICAgIGNhdXNlOiB7IHJlcXVpcmVkRmVhdHVyZTogeyBmZWF0dXJlTmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsIHZhbHVlOiByZXF1aXJlZEZlYXR1cmUgfSB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZXF1aXJlRXh0cmFDdXJyZW5jaWVzKSB7XG4gICAgICAgIGlmICghc2VuZFRyYW5zYWN0aW9uRmVhdHVyZSB8fCAhc2VuZFRyYW5zYWN0aW9uRmVhdHVyZS5leHRyYUN1cnJlbmN5U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90U3VwcG9ydEZlYXR1cmVFcnJvcihgV2FsbGV0IGlzIG5vdCBhYmxlIHRvIGhhbmRsZSBzdWNoIFNlbmRUcmFuc2FjdGlvbiByZXF1ZXN0LiBFeHRyYSBjdXJyZW5jaWVzIHN1cHBvcnQgaXMgcmVxdWlyZWQuYCwge1xuICAgICAgICAgICAgICAgIGNhdXNlOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkRmVhdHVyZTogeyBmZWF0dXJlTmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsIHZhbHVlOiByZXF1aXJlZEZlYXR1cmUgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzZW5kVHJhbnNhY3Rpb25GZWF0dXJlICYmIHNlbmRUcmFuc2FjdGlvbkZlYXR1cmUubWF4TWVzc2FnZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc2VuZFRyYW5zYWN0aW9uRmVhdHVyZS5tYXhNZXNzYWdlcyA8IG9wdGlvbnMucmVxdWlyZWRNZXNzYWdlc051bWJlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdFN1cHBvcnRGZWF0dXJlRXJyb3IoYFdhbGxldCBpcyBub3QgYWJsZSB0byBoYW5kbGUgc3VjaCBTZW5kVHJhbnNhY3Rpb24gcmVxdWVzdC4gTWF4IHN1cHBvcnQgbWVzc2FnZXMgbnVtYmVyIGlzICR7c2VuZFRyYW5zYWN0aW9uRmVhdHVyZS5tYXhNZXNzYWdlc30sIGJ1dCAke29wdGlvbnMucmVxdWlyZWRNZXNzYWdlc051bWJlcn0gaXMgcmVxdWlyZWQuYCwge1xuICAgICAgICAgICAgICAgIGNhdXNlOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkRmVhdHVyZTogeyBmZWF0dXJlTmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsIHZhbHVlOiByZXF1aXJlZEZlYXR1cmUgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nV2FybmluZyhcIkNvbm5lY3RlZCB3YWxsZXQgZGlkbid0IHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgbWF4IGFsbG93ZWQgbWVzc2FnZXMgaW4gdGhlIFNlbmRUcmFuc2FjdGlvbiByZXF1ZXN0LiBSZXF1ZXN0IG1heSBiZSByZWplY3RlZCBieSB0aGUgd2FsbGV0LlwiKTtcbn1cbmZ1bmN0aW9uIGNoZWNrU2lnbkRhdGFTdXBwb3J0KGZlYXR1cmVzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc2lnbkRhdGFGZWF0dXJlID0gZmVhdHVyZXMuZmluZChmZWF0dXJlID0+IGZlYXR1cmUgJiYgdHlwZW9mIGZlYXR1cmUgPT09ICdvYmplY3QnICYmIGZlYXR1cmUubmFtZSA9PT0gJ1NpZ25EYXRhJyk7XG4gICAgaWYgKCFzaWduRGF0YUZlYXR1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdFN1cHBvcnRGZWF0dXJlRXJyb3IoXCJXYWxsZXQgZG9lc24ndCBzdXBwb3J0IFNpZ25EYXRhIGZlYXR1cmUuXCIsIHtcbiAgICAgICAgICAgIGNhdXNlOiB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWRGZWF0dXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVOYW1lOiAnU2lnbkRhdGEnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogeyB0eXBlczogb3B0aW9ucy5yZXF1aXJlZFR5cGVzIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB1bnN1cHBvcnRlZFR5cGVzID0gb3B0aW9ucy5yZXF1aXJlZFR5cGVzLmZpbHRlcihyZXF1aXJlZFR5cGUgPT4gIXNpZ25EYXRhRmVhdHVyZS50eXBlcy5pbmNsdWRlcyhyZXF1aXJlZFR5cGUpKTtcbiAgICBpZiAodW5zdXBwb3J0ZWRUeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdFN1cHBvcnRGZWF0dXJlRXJyb3IoYFdhbGxldCBkb2Vzbid0IHN1cHBvcnQgcmVxdWlyZWQgU2lnbkRhdGEgdHlwZXM6ICR7dW5zdXBwb3J0ZWRUeXBlcy5qb2luKCcsICcpfS5gLCB7XG4gICAgICAgICAgICBjYXVzZToge1xuICAgICAgICAgICAgICAgIHJlcXVpcmVkRmVhdHVyZTogeyBmZWF0dXJlTmFtZTogJ1NpZ25EYXRhJywgdmFsdWU6IHsgdHlwZXM6IHVuc3VwcG9ydGVkVHlwZXMgfSB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrUmVxdWlyZWRXYWxsZXRGZWF0dXJlcyhmZWF0dXJlcywgd2FsbGV0c1JlcXVpcmVkRmVhdHVyZXMpIHtcbiAgICBpZiAodHlwZW9mIHdhbGxldHNSZXF1aXJlZEZlYXR1cmVzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgeyBzZW5kVHJhbnNhY3Rpb24sIHNpZ25EYXRhIH0gPSB3YWxsZXRzUmVxdWlyZWRGZWF0dXJlcztcbiAgICBpZiAoc2VuZFRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGZlYXR1cmUgPSBmaW5kRmVhdHVyZShmZWF0dXJlcywgJ1NlbmRUcmFuc2FjdGlvbicpO1xuICAgICAgICBpZiAoIWZlYXR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoZWNrU2VuZFRyYW5zYWN0aW9uKGZlYXR1cmUsIHNlbmRUcmFuc2FjdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2lnbkRhdGEpIHtcbiAgICAgICAgY29uc3QgZmVhdHVyZSA9IGZpbmRGZWF0dXJlKGZlYXR1cmVzLCAnU2lnbkRhdGEnKTtcbiAgICAgICAgaWYgKCFmZWF0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGVja1NpZ25EYXRhKGZlYXR1cmUsIHNpZ25EYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZmluZEZlYXR1cmUoZmVhdHVyZXMsIHJlcXVpcmVkRmVhdHVyZU5hbWUpIHtcbiAgICByZXR1cm4gZmVhdHVyZXMuZmluZChmID0+IGYgJiYgdHlwZW9mIGYgPT09ICdvYmplY3QnICYmIGYubmFtZSA9PT0gcmVxdWlyZWRGZWF0dXJlTmFtZSk7XG59XG5mdW5jdGlvbiBjaGVja1NlbmRUcmFuc2FjdGlvbihmZWF0dXJlLCByZXF1aXJlZEZlYXR1cmUpIHtcbiAgICBjb25zdCBjb3JyZWN0TWVzc2FnZXNOdW1iZXIgPSByZXF1aXJlZEZlYXR1cmUubWluTWVzc2FnZXMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICByZXF1aXJlZEZlYXR1cmUubWluTWVzc2FnZXMgPD0gZmVhdHVyZS5tYXhNZXNzYWdlcztcbiAgICBjb25zdCBjb3JyZWN0RXh0cmFDdXJyZW5jeSA9ICFyZXF1aXJlZEZlYXR1cmUuZXh0cmFDdXJyZW5jeVJlcXVpcmVkIHx8IGZlYXR1cmUuZXh0cmFDdXJyZW5jeVN1cHBvcnRlZDtcbiAgICByZXR1cm4gISEoY29ycmVjdE1lc3NhZ2VzTnVtYmVyICYmIGNvcnJlY3RFeHRyYUN1cnJlbmN5KTtcbn1cbmZ1bmN0aW9uIGNoZWNrU2lnbkRhdGEoZmVhdHVyZSwgcmVxdWlyZWRGZWF0dXJlKSB7XG4gICAgcmV0dXJuIHJlcXVpcmVkRmVhdHVyZS50eXBlcy5ldmVyeShyZXF1aXJlZFR5cGUgPT4gZmVhdHVyZS50eXBlcy5pbmNsdWRlcyhyZXF1aXJlZFR5cGUpKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSByZXF1ZXN0IHZlcnNpb24gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3RWZXJzaW9uRXZlbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3JlcXVlc3QtdmVyc2lvbidcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSByZXNwb25zZSB2ZXJzaW9uIGV2ZW50LlxuICogQHBhcmFtIHZlcnNpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VWZXJzaW9uRXZlbnQodmVyc2lvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdyZXNwb25zZS12ZXJzaW9uJyxcbiAgICAgICAgdmVyc2lvbjogdmVyc2lvblxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSBhIHZlcnNpb24gaW5mby5cbiAqIEBwYXJhbSB2ZXJzaW9uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVZlcnNpb25JbmZvKHZlcnNpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b25fY29ubmVjdF9zZGtfbGliOiB2ZXJzaW9uLnRvbl9jb25uZWN0X3Nka19saWIsXG4gICAgICAgIHRvbl9jb25uZWN0X3VpX2xpYjogdmVyc2lvbi50b25fY29ubmVjdF91aV9saWJcbiAgICB9O1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3Rpb25JbmZvKHZlcnNpb24sIHdhbGxldCwgc2Vzc2lvbkluZm8pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sO1xuICAgIGNvbnN0IGlzVG9uUHJvb2YgPSAoKF9hID0gd2FsbGV0ID09PSBudWxsIHx8IHdhbGxldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2FsbGV0LmNvbm5lY3RJdGVtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvblByb29mKSAmJiAncHJvb2YnIGluIHdhbGxldC5jb25uZWN0SXRlbXMudG9uUHJvb2Y7XG4gICAgY29uc3QgYXV0aFR5cGUgPSBpc1RvblByb29mID8gJ3Rvbl9wcm9vZicgOiAndG9uX2FkZHInO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdhbGxldF9hZGRyZXNzOiAoX2MgPSAoX2IgPSB3YWxsZXQgPT09IG51bGwgfHwgd2FsbGV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3YWxsZXQuYWNjb3VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFkZHJlc3MpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGwsXG4gICAgICAgIHdhbGxldF9zdGF0ZV9pbml0OiAoX2QgPSB3YWxsZXQgPT09IG51bGwgfHwgd2FsbGV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3YWxsZXQuYWNjb3VudC53YWxsZXRTdGF0ZUluaXQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG51bGwsXG4gICAgICAgIHdhbGxldF90eXBlOiAoX2UgPSB3YWxsZXQgPT09IG51bGwgfHwgd2FsbGV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3YWxsZXQuZGV2aWNlLmFwcE5hbWUpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IG51bGwsXG4gICAgICAgIHdhbGxldF92ZXJzaW9uOiAoX2YgPSB3YWxsZXQgPT09IG51bGwgfHwgd2FsbGV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3YWxsZXQuZGV2aWNlLmFwcFZlcnNpb24pICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IG51bGwsXG4gICAgICAgIGF1dGhfdHlwZTogYXV0aFR5cGUsXG4gICAgICAgIGN1c3RvbV9kYXRhOiBPYmplY3QuYXNzaWduKHsgY2xpZW50X2lkOiAoX2cgPSBzZXNzaW9uSW5mbyA9PT0gbnVsbCB8fCBzZXNzaW9uSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbkluZm8uY2xpZW50SWQpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IG51bGwsIHdhbGxldF9pZDogKF9oID0gc2Vzc2lvbkluZm8gPT09IG51bGwgfHwgc2Vzc2lvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb25JbmZvLndhbGxldElkKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBudWxsLCBjaGFpbl9pZDogKF9rID0gKF9qID0gd2FsbGV0ID09PSBudWxsIHx8IHdhbGxldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2FsbGV0LmFjY291bnQpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5jaGFpbikgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogbnVsbCwgcHJvdmlkZXI6IChfbCA9IHdhbGxldCA9PT0gbnVsbCB8fCB3YWxsZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdhbGxldC5wcm92aWRlcikgIT09IG51bGwgJiYgX2wgIT09IHZvaWQgMCA/IF9sIDogbnVsbCB9LCBjcmVhdGVWZXJzaW9uSW5mbyh2ZXJzaW9uKSlcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBjb25uZWN0aW9uIGluaXQgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3Rpb25TdGFydGVkRXZlbnQodmVyc2lvbiwgdHJhY2VJZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdjb25uZWN0aW9uLXN0YXJ0ZWQnLFxuICAgICAgICBjdXN0b21fZGF0YTogY3JlYXRlVmVyc2lvbkluZm8odmVyc2lvbiksXG4gICAgICAgIHRyYWNlX2lkOiB0cmFjZUlkICE9PSBudWxsICYmIHRyYWNlSWQgIT09IHZvaWQgMCA/IHRyYWNlSWQgOiBudWxsXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgY29ubmVjdGlvbiBjb21wbGV0ZWQgZXZlbnQuXG4gKiBAcGFyYW0gdmVyc2lvblxuICogQHBhcmFtIHdhbGxldFxuICogQHBhcmFtIHNlc3Npb25JbmZvXG4gKiBAcGFyYW0gdHJhY2VJZFxuICovXG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uQ29tcGxldGVkRXZlbnQodmVyc2lvbiwgd2FsbGV0LCBzZXNzaW9uSW5mbywgdHJhY2VJZCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgdHlwZTogJ2Nvbm5lY3Rpb24tY29tcGxldGVkJywgaXNfc3VjY2VzczogdHJ1ZSwgdHJhY2VfaWQ6IHRyYWNlSWQgIT09IG51bGwgJiYgdHJhY2VJZCAhPT0gdm9pZCAwID8gdHJhY2VJZCA6IG51bGwgfSwgY3JlYXRlQ29ubmVjdGlvbkluZm8odmVyc2lvbiwgd2FsbGV0LCBzZXNzaW9uSW5mbykpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBjb25uZWN0aW9uIGVycm9yIGV2ZW50LlxuICogQHBhcmFtIHZlcnNpb25cbiAqIEBwYXJhbSBlcnJvcl9tZXNzYWdlXG4gKiBAcGFyYW0gZXJyb3JDb2RlXG4gKiBAcGFyYW0gc2Vzc2lvbkluZm9cbiAqIEBwYXJhbSB0cmFjZUlkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3Rpb25FcnJvckV2ZW50KHZlcnNpb24sIGVycm9yX21lc3NhZ2UsIGVycm9yQ29kZSwgc2Vzc2lvbkluZm8sIHRyYWNlSWQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdjb25uZWN0aW9uLWVycm9yJyxcbiAgICAgICAgaXNfc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yX21lc3NhZ2U6IGVycm9yX21lc3NhZ2UsXG4gICAgICAgIGVycm9yX2NvZGU6IGVycm9yQ29kZSAhPT0gbnVsbCAmJiBlcnJvckNvZGUgIT09IHZvaWQgMCA/IGVycm9yQ29kZSA6IG51bGwsXG4gICAgICAgIHRyYWNlX2lkOiB0cmFjZUlkICE9PSBudWxsICYmIHRyYWNlSWQgIT09IHZvaWQgMCA/IHRyYWNlSWQgOiBudWxsLFxuICAgICAgICBjdXN0b21fZGF0YTogT2JqZWN0LmFzc2lnbih7IGNsaWVudF9pZDogKF9hID0gc2Vzc2lvbkluZm8gPT09IG51bGwgfHwgc2Vzc2lvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb25JbmZvLmNsaWVudElkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLCB3YWxsZXRfaWQ6IChfYiA9IHNlc3Npb25JbmZvID09PSBudWxsIHx8IHNlc3Npb25JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uSW5mby53YWxsZXRJZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbCB9LCBjcmVhdGVWZXJzaW9uSW5mbyh2ZXJzaW9uKSlcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBjb25uZWN0aW9uIHJlc3RvcmluZyBzdGFydGVkIGV2ZW50LlxuICovXG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uUmVzdG9yaW5nU3RhcnRlZEV2ZW50KHZlcnNpb24sIHRyYWNlSWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnY29ubmVjdGlvbi1yZXN0b3Jpbmctc3RhcnRlZCcsXG4gICAgICAgIGN1c3RvbV9kYXRhOiBjcmVhdGVWZXJzaW9uSW5mbyh2ZXJzaW9uKSxcbiAgICAgICAgdHJhY2VfaWQ6IHRyYWNlSWQgIT09IG51bGwgJiYgdHJhY2VJZCAhPT0gdm9pZCAwID8gdHJhY2VJZCA6IG51bGxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBjb25uZWN0aW9uIHJlc3RvcmluZyBjb21wbGV0ZWQgZXZlbnQuXG4gKiBAcGFyYW0gdmVyc2lvblxuICogQHBhcmFtIHdhbGxldFxuICogQHBhcmFtIHNlc3Npb25JbmZvXG4gKiBAcGFyYW0gdHJhY2VJZFxuICovXG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uUmVzdG9yaW5nQ29tcGxldGVkRXZlbnQodmVyc2lvbiwgd2FsbGV0LCBzZXNzaW9uSW5mbywgdHJhY2VJZCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgdHlwZTogJ2Nvbm5lY3Rpb24tcmVzdG9yaW5nLWNvbXBsZXRlZCcsIGlzX3N1Y2Nlc3M6IHRydWUsIHRyYWNlX2lkOiB0cmFjZUlkICE9PSBudWxsICYmIHRyYWNlSWQgIT09IHZvaWQgMCA/IHRyYWNlSWQgOiBudWxsIH0sIGNyZWF0ZUNvbm5lY3Rpb25JbmZvKHZlcnNpb24sIHdhbGxldCwgc2Vzc2lvbkluZm8pKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgY29ubmVjdGlvbiByZXN0b3JpbmcgZXJyb3IgZXZlbnQuXG4gKiBAcGFyYW0gdmVyc2lvblxuICogQHBhcmFtIGVycm9yTWVzc2FnZVxuICogQHBhcmFtIHRyYWNlSWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvblJlc3RvcmluZ0Vycm9yRXZlbnQodmVyc2lvbiwgZXJyb3JNZXNzYWdlLCB0cmFjZUlkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2Nvbm5lY3Rpb24tcmVzdG9yaW5nLWVycm9yJyxcbiAgICAgICAgaXNfc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yX21lc3NhZ2U6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgdHJhY2VfaWQ6IHRyYWNlSWQgIT09IG51bGwgJiYgdHJhY2VJZCAhPT0gdm9pZCAwID8gdHJhY2VJZCA6IG51bGwsXG4gICAgICAgIGN1c3RvbV9kYXRhOiBjcmVhdGVWZXJzaW9uSW5mbyh2ZXJzaW9uKVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVUcmFuc2FjdGlvbkluZm8od2FsbGV0LCB0cmFuc2FjdGlvbikge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWxpZF91bnRpbDogKF9hID0gU3RyaW5nKHRyYW5zYWN0aW9uLnZhbGlkVW50aWwpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLFxuICAgICAgICBmcm9tOiAoX2QgPSAoX2IgPSB0cmFuc2FjdGlvbi5mcm9tKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAoX2MgPSB3YWxsZXQgPT09IG51bGwgfHwgd2FsbGV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3YWxsZXQuYWNjb3VudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFkZHJlc3MpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG51bGwsXG4gICAgICAgIG1lc3NhZ2VzOiB0cmFuc2FjdGlvbi5tZXNzYWdlcy5tYXAobWVzc2FnZSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogKF9hID0gbWVzc2FnZS5hZGRyZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLFxuICAgICAgICAgICAgICAgIGFtb3VudDogKF9iID0gbWVzc2FnZS5hbW91bnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVUcmFuc2FjdGlvbkZ1bGxJbmZvKHdhbGxldCwgdHJhbnNhY3Rpb24pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWRfdW50aWw6IChfYSA9IFN0cmluZyh0cmFuc2FjdGlvbi52YWxpZFVudGlsKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCxcbiAgICAgICAgZnJvbTogKF9kID0gKF9iID0gdHJhbnNhY3Rpb24uZnJvbSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKF9jID0gd2FsbGV0ID09PSBudWxsIHx8IHdhbGxldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2FsbGV0LmFjY291bnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hZGRyZXNzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBudWxsLFxuICAgICAgICBtZXNzYWdlczogdHJhbnNhY3Rpb24ubWVzc2FnZXMubWFwKG1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogKF9hID0gbWVzc2FnZS5hZGRyZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLFxuICAgICAgICAgICAgICAgIGFtb3VudDogKF9iID0gbWVzc2FnZS5hbW91bnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGwsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogKF9jID0gbWVzc2FnZS5wYXlsb2FkKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBudWxsLFxuICAgICAgICAgICAgICAgIHN0YXRlX2luaXQ6IChfZCA9IG1lc3NhZ2Uuc3RhdGVJbml0KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSB0cmFuc2FjdGlvbiBpbml0IGV2ZW50LlxuICogQHBhcmFtIHZlcnNpb25cbiAqIEBwYXJhbSB3YWxsZXRcbiAqIEBwYXJhbSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHNlc3Npb25JbmZvXG4gKiBAcGFyYW0gdHJhY2VJZFxuICovXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2FjdGlvblNlbnRGb3JTaWduYXR1cmVFdmVudCh2ZXJzaW9uLCB3YWxsZXQsIHRyYW5zYWN0aW9uLCBzZXNzaW9uSW5mbywgdHJhY2VJZCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB0eXBlOiAndHJhbnNhY3Rpb24tc2VudC1mb3Itc2lnbmF0dXJlJywgdHJhY2VfaWQ6IHRyYWNlSWQgIT09IG51bGwgJiYgdHJhY2VJZCAhPT0gdm9pZCAwID8gdHJhY2VJZCA6IG51bGwgfSwgY3JlYXRlQ29ubmVjdGlvbkluZm8odmVyc2lvbiwgd2FsbGV0LCBzZXNzaW9uSW5mbykpLCBjcmVhdGVUcmFuc2FjdGlvbkluZm8od2FsbGV0LCB0cmFuc2FjdGlvbikpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSB0cmFuc2FjdGlvbiBzaWduZWQgZXZlbnQuXG4gKiBAcGFyYW0gdmVyc2lvblxuICogQHBhcmFtIHdhbGxldFxuICogQHBhcmFtIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0gc2lnbmVkVHJhbnNhY3Rpb25cbiAqIEBwYXJhbSBzZXNzaW9uSW5mb1xuICogQHBhcmFtIHRyYWNlSWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNhY3Rpb25TaWduZWRFdmVudCh2ZXJzaW9uLCB3YWxsZXQsIHRyYW5zYWN0aW9uLCBzaWduZWRUcmFuc2FjdGlvbiwgc2Vzc2lvbkluZm8sIHRyYWNlSWQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdHlwZTogJ3RyYW5zYWN0aW9uLXNpZ25lZCcsIGlzX3N1Y2Nlc3M6IHRydWUsIHNpZ25lZF90cmFuc2FjdGlvbjogc2lnbmVkVHJhbnNhY3Rpb24uYm9jLCB0cmFjZV9pZDogdHJhY2VJZCAhPT0gbnVsbCAmJiB0cmFjZUlkICE9PSB2b2lkIDAgPyB0cmFjZUlkIDogbnVsbCB9LCBjcmVhdGVDb25uZWN0aW9uSW5mbyh2ZXJzaW9uLCB3YWxsZXQsIHNlc3Npb25JbmZvKSksIGNyZWF0ZVRyYW5zYWN0aW9uSW5mbyh3YWxsZXQsIHRyYW5zYWN0aW9uKSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHRyYW5zYWN0aW9uIGVycm9yIGV2ZW50LlxuICogQHBhcmFtIHZlcnNpb25cbiAqIEBwYXJhbSB3YWxsZXRcbiAqIEBwYXJhbSB0cmFuc2FjdGlvblxuICogQHBhcmFtIGVycm9yTWVzc2FnZVxuICogQHBhcmFtIGVycm9yQ29kZVxuICogQHBhcmFtIHNlc3Npb25JbmZvXG4gKiBAcGFyYW0gdHJhY2VJZFxuICovXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2FjdGlvblNpZ25pbmdGYWlsZWRFdmVudCh2ZXJzaW9uLCB3YWxsZXQsIHRyYW5zYWN0aW9uLCBlcnJvck1lc3NhZ2UsIGVycm9yQ29kZSwgc2Vzc2lvbkluZm8sIHRyYWNlSWQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdHlwZTogJ3RyYW5zYWN0aW9uLXNpZ25pbmctZmFpbGVkJywgaXNfc3VjY2VzczogZmFsc2UsIGVycm9yX21lc3NhZ2U6IGVycm9yTWVzc2FnZSwgZXJyb3JfY29kZTogZXJyb3JDb2RlICE9PSBudWxsICYmIGVycm9yQ29kZSAhPT0gdm9pZCAwID8gZXJyb3JDb2RlIDogbnVsbCwgdHJhY2VfaWQ6IHRyYWNlSWQgIT09IG51bGwgJiYgdHJhY2VJZCAhPT0gdm9pZCAwID8gdHJhY2VJZCA6IG51bGwgfSwgY3JlYXRlQ29ubmVjdGlvbkluZm8odmVyc2lvbiwgd2FsbGV0LCBzZXNzaW9uSW5mbykpLCBjcmVhdGVUcmFuc2FjdGlvbkZ1bGxJbmZvKHdhbGxldCwgdHJhbnNhY3Rpb24pKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURhdGFTZW50Rm9yU2lnbmF0dXJlRXZlbnQodmVyc2lvbiwgd2FsbGV0LCBkYXRhLCBzZXNzaW9uSW5mbywgdHJhY2VJZCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgdHlwZTogJ3NpZ24tZGF0YS1yZXF1ZXN0LWluaXRpYXRlZCcsIGRhdGEsIHRyYWNlX2lkOiB0cmFjZUlkICE9PSBudWxsICYmIHRyYWNlSWQgIT09IHZvaWQgMCA/IHRyYWNlSWQgOiBudWxsIH0sIGNyZWF0ZUNvbm5lY3Rpb25JbmZvKHZlcnNpb24sIHdhbGxldCwgc2Vzc2lvbkluZm8pKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURhdGFTaWduZWRFdmVudCh2ZXJzaW9uLCB3YWxsZXQsIGRhdGEsIHNpZ25lZERhdGEsIHNlc3Npb25JbmZvLCB0cmFjZUlkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyB0eXBlOiAnc2lnbi1kYXRhLXJlcXVlc3QtY29tcGxldGVkJywgaXNfc3VjY2VzczogdHJ1ZSwgZGF0YSwgc2lnbmVkX2RhdGE6IHNpZ25lZERhdGEsIHRyYWNlX2lkOiB0cmFjZUlkICE9PSBudWxsICYmIHRyYWNlSWQgIT09IHZvaWQgMCA/IHRyYWNlSWQgOiBudWxsIH0sIGNyZWF0ZUNvbm5lY3Rpb25JbmZvKHZlcnNpb24sIHdhbGxldCwgc2Vzc2lvbkluZm8pKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURhdGFTaWduaW5nRmFpbGVkRXZlbnQodmVyc2lvbiwgd2FsbGV0LCBkYXRhLCBlcnJvck1lc3NhZ2UsIGVycm9yQ29kZSwgc2Vzc2lvbkluZm8sIHRyYWNlSWQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdzaWduLWRhdGEtcmVxdWVzdC1mYWlsZWQnLCBpc19zdWNjZXNzOiBmYWxzZSwgZGF0YSwgZXJyb3JfbWVzc2FnZTogZXJyb3JNZXNzYWdlLCBlcnJvcl9jb2RlOiBlcnJvckNvZGUgIT09IG51bGwgJiYgZXJyb3JDb2RlICE9PSB2b2lkIDAgPyBlcnJvckNvZGUgOiBudWxsLCB0cmFjZV9pZDogdHJhY2VJZCAhPT0gbnVsbCAmJiB0cmFjZUlkICE9PSB2b2lkIDAgPyB0cmFjZUlkIDogbnVsbCB9LCBjcmVhdGVDb25uZWN0aW9uSW5mbyh2ZXJzaW9uLCB3YWxsZXQsIHNlc3Npb25JbmZvKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVEaXNjb25uZWN0aW9uRXZlbnQodmVyc2lvbiwgd2FsbGV0LCBzY29wZSwgc2Vzc2lvbkluZm8sIHRyYWNlSWQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdkaXNjb25uZWN0aW9uJywgc2NvcGU6IHNjb3BlLCB0cmFjZV9pZDogdHJhY2VJZCAhPT0gbnVsbCAmJiB0cmFjZUlkICE9PSB2b2lkIDAgPyB0cmFjZUlkIDogbnVsbCB9LCBjcmVhdGVDb25uZWN0aW9uSW5mbyh2ZXJzaW9uLCB3YWxsZXQsIHNlc3Npb25JbmZvKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVXYWxsZXRNb2RhbE9wZW5lZEV2ZW50KHZlcnNpb24sIHZpc2libGVXYWxsZXRzLCBjbGllbnRJZCwgdHJhY2VJZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICd3YWxsZXQtbW9kYWwtb3BlbmVkJyxcbiAgICAgICAgdmlzaWJsZV93YWxsZXRzOiB2aXNpYmxlV2FsbGV0cyxcbiAgICAgICAgY2xpZW50X2lkOiBjbGllbnRJZCAhPT0gbnVsbCAmJiBjbGllbnRJZCAhPT0gdm9pZCAwID8gY2xpZW50SWQgOiBudWxsLFxuICAgICAgICBjdXN0b21fZGF0YTogdmVyc2lvbixcbiAgICAgICAgdHJhY2VfaWQ6IHRyYWNlSWQgIT09IG51bGwgJiYgdHJhY2VJZCAhPT0gdm9pZCAwID8gdHJhY2VJZCA6IG51bGxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2VsZWN0ZWRXYWxsZXRFdmVudCh2ZXJzaW9uLCB2aXNpYmxlV2FsbGV0cywgbGFzdFNlbGVjdGVkV2FsbGV0LCB3YWxsZXRzTWVudSwgcmVkaXJlY3RMaW5rLCByZWRpcmVjdExpbmtUeXBlLCBjbGllbnRJZCwgdHJhY2VJZCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgd2FsbGV0UmVkaXJlY3RNZXRob2QgPSByZWRpcmVjdExpbmtUeXBlO1xuICAgIGlmICghd2FsbGV0UmVkaXJlY3RNZXRob2QgJiYgcmVkaXJlY3RMaW5rKSB7XG4gICAgICAgIHdhbGxldFJlZGlyZWN0TWV0aG9kID0gaXNUZWxlZ3JhbVVybChyZWRpcmVjdExpbmspID8gJ3RnX2xpbmsnIDogJ2V4dGVybmFsX2xpbmsnO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnc2VsZWN0ZWQtd2FsbGV0JyxcbiAgICAgICAgd2FsbGV0c19tZW51OiB3YWxsZXRzTWVudSxcbiAgICAgICAgdmlzaWJsZV93YWxsZXRzOiB2aXNpYmxlV2FsbGV0cyxcbiAgICAgICAgY2xpZW50X2lkOiBjbGllbnRJZCAhPT0gbnVsbCAmJiBjbGllbnRJZCAhPT0gdm9pZCAwID8gY2xpZW50SWQgOiBudWxsLFxuICAgICAgICBjdXN0b21fZGF0YTogdmVyc2lvbixcbiAgICAgICAgdHJhY2VfaWQ6IHRyYWNlSWQgIT09IG51bGwgJiYgdHJhY2VJZCAhPT0gdm9pZCAwID8gdHJhY2VJZCA6IG51bGwsXG4gICAgICAgIHdhbGxldF9yZWRpcmVjdF9tZXRob2Q6IHdhbGxldFJlZGlyZWN0TWV0aG9kLFxuICAgICAgICB3YWxsZXRfcmVkaXJlY3RfbGluazogcmVkaXJlY3RMaW5rIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgd2FsbGV0X3R5cGU6IChfYSA9IGxhc3RTZWxlY3RlZFdhbGxldCA9PT0gbnVsbCB8fCBsYXN0U2VsZWN0ZWRXYWxsZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3RTZWxlY3RlZFdhbGxldC5hcHBOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBUcmFja2VyIGZvciBUb25Db25uZWN0IHVzZXIgYWN0aW9ucywgc3VjaCBhcyB0cmFuc2FjdGlvbiBzaWduaW5nLCBjb25uZWN0aW9uLCBldGMuXG4gKlxuICogTGlzdCBvZiBldmVudHM6XG4gKiAgKiBgY29ubmVjdGlvbi1zdGFydGVkYDogd2hlbiBhIHVzZXIgc3RhcnRzIGNvbm5lY3RpbmcgYSB3YWxsZXQuXG4gKiAgKiBgY29ubmVjdGlvbi1jb21wbGV0ZWRgOiB3aGVuIGEgdXNlciBzdWNjZXNzZnVsbHkgY29ubmVjdGVkIGEgd2FsbGV0LlxuICogICogYGNvbm5lY3Rpb24tZXJyb3JgOiB3aGVuIGEgdXNlciBjYW5jZWxzIGEgY29ubmVjdGlvbiBvciB0aGVyZSBpcyBhbiBlcnJvciBkdXJpbmcgdGhlIGNvbm5lY3Rpb24gcHJvY2Vzcy5cbiAqICAqIGBjb25uZWN0aW9uLXJlc3RvcmluZy1zdGFydGVkYDogd2hlbiB0aGUgZEFwcCBzdGFydHMgcmVzdG9yaW5nIGEgY29ubmVjdGlvbi5cbiAqICAqIGBjb25uZWN0aW9uLXJlc3RvcmluZy1jb21wbGV0ZWRgOiB3aGVuIHRoZSBkQXBwIHN1Y2Nlc3NmdWxseSByZXN0b3JlcyBhIGNvbm5lY3Rpb24uXG4gKiAgKiBgY29ubmVjdGlvbi1yZXN0b3JpbmctZXJyb3JgOiB3aGVuIHRoZSBkQXBwIGZhaWxzIHRvIHJlc3RvcmUgYSBjb25uZWN0aW9uLlxuICogICogYGRpc2Nvbm5lY3Rpb25gOiB3aGVuIGEgdXNlciBzdGFydHMgZGlzY29ubmVjdGluZyBhIHdhbGxldC5cbiAqICAqIGB0cmFuc2FjdGlvbi1zZW50LWZvci1zaWduYXR1cmVgOiB3aGVuIGEgdXNlciBzZW5kcyBhIHRyYW5zYWN0aW9uIGZvciBzaWduYXR1cmUuXG4gKiAgKiBgdHJhbnNhY3Rpb24tc2lnbmVkYDogd2hlbiBhIHVzZXIgc3VjY2Vzc2Z1bGx5IHNpZ25zIGEgdHJhbnNhY3Rpb24uXG4gKiAgKiBgdHJhbnNhY3Rpb24tc2lnbmluZy1mYWlsZWRgOiB3aGVuIGEgdXNlciBjYW5jZWxzIHRyYW5zYWN0aW9uIHNpZ25pbmcgb3IgdGhlcmUgaXMgYW4gZXJyb3IgZHVyaW5nIHRoZSBzaWduaW5nIHByb2Nlc3MuXG4gKiAgKiBgc2lnbi1kYXRhLXJlcXVlc3QtaW5pdGlhdGVkYDogd2hlbiBhIHVzZXIgc2VuZHMgZGF0YSBmb3Igc2lnbmF0dXJlLlxuICogICogYHNpZ24tZGF0YS1yZXF1ZXN0LWNvbXBsZXRlZGA6IHdoZW4gYSB1c2VyIHN1Y2Nlc3NmdWxseSBzaWducyBkYXRhLlxuICogICogYHNpZ24tZGF0YS1yZXF1ZXN0LWZhaWxlZGA6IHdoZW4gYSB1c2VyIGNhbmNlbHMgZGF0YSBzaWduaW5nIG9yIHRoZXJlIGlzIGFuIGVycm9yIGR1cmluZyB0aGUgc2lnbmluZyBwcm9jZXNzLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIHRyYWNrIHVzZXIgYWN0aW9ucywgeW91IGNhbiBzdWJzY3JpYmUgdG8gdGhlIHdpbmRvdyBldmVudHMgd2l0aCBwcmVmaXggYHRvbi1jb25uZWN0LWA6XG4gKlxuICogQGV4YW1wbGVcbiAqIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b24tY29ubmVjdC10cmFuc2FjdGlvbi1zZW50LWZvci1zaWduYXR1cmUnLCAoZXZlbnQpID0+IHtcbiAqICAgIGNvbnNvbGUubG9nKCdUcmFuc2FjdGlvbiBpbml0JywgZXZlbnQuZGV0YWlsKTtcbiAqIH0pO1xuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBUb25Db25uZWN0VHJhY2tlciB7XG4gICAgLyoqXG4gICAgICogVmVyc2lvbiBvZiB0aGUgbGlicmFyeS5cbiAgICAgKi9cbiAgICBnZXQgdmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZlcnNpb25JbmZvKHtcbiAgICAgICAgICAgIHRvbl9jb25uZWN0X3Nka19saWI6IHRoaXMudG9uQ29ubmVjdFNka1ZlcnNpb24sXG4gICAgICAgICAgICB0b25fY29ubmVjdF91aV9saWI6IHRoaXMudG9uQ29ubmVjdFVpVmVyc2lvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgcHJlZml4IGZvciB1c2VyIGFjdGlvbnMuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV2ZW50UHJlZml4ID0gJ3Rvbi1jb25uZWN0LSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb25Db25uZWN0IFVJIHZlcnNpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvbkNvbm5lY3RVaVZlcnNpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlciA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ldmVudERpc3BhdGNoZXI7XG4gICAgICAgIHRoaXMudG9uQ29ubmVjdFNka1ZlcnNpb24gPSBvcHRpb25zLnRvbkNvbm5lY3RTZGtWZXJzaW9uO1xuICAgICAgICB0aGlzLmluaXQoKS5jYXRjaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgb25jZSB3aGVuIHRoZSB0cmFja2VyIGlzIGNyZWF0ZWQgYW5kIHJlcXVlc3QgdmVyc2lvbiBvdGhlciBsaWJyYXJpZXMuXG4gICAgICovXG4gICAgaW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5zZXRSZXF1ZXN0VmVyc2lvbkhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvbkNvbm5lY3RVaVZlcnNpb24gPSB5aWVsZCB0aGlzLnJlcXVlc3RUb25Db25uZWN0VWlWZXJzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgcmVxdWVzdCB2ZXJzaW9uIGhhbmRsZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZXRSZXF1ZXN0VmVyc2lvbkhhbmRsZXIoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmV2ZW50RGlzcGF0Y2hlci5hZGRFdmVudExpc3RlbmVyKCd0b24tY29ubmVjdC1yZXF1ZXN0LXZlcnNpb24nLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5ldmVudERpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudCgndG9uLWNvbm5lY3QtcmVzcG9uc2UtdmVyc2lvbicsIGNyZWF0ZVJlc3BvbnNlVmVyc2lvbkV2ZW50KHRoaXMudG9uQ29ubmVjdFNka1ZlcnNpb24pKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgVG9uQ29ubmVjdCBVSSB2ZXJzaW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcmVxdWVzdFRvbkNvbm5lY3RVaVZlcnNpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZXZlbnREaXNwYXRjaGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3Rvbi1jb25uZWN0LXVpLXJlc3BvbnNlLXZlcnNpb24nLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZXZlbnQuZGV0YWlsLnZlcnNpb24pO1xuICAgICAgICAgICAgICAgICAgICB9LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZXZlbnREaXNwYXRjaGVyLmRpc3BhdGNoRXZlbnQoJ3Rvbi1jb25uZWN0LXVpLXJlcXVlc3QtdmVyc2lvbicsIGNyZWF0ZVJlcXVlc3RWZXJzaW9uRXZlbnQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0IHVzZXIgYWN0aW9uIGV2ZW50IHRvIHRoZSB3aW5kb3cuXG4gICAgICogQHBhcmFtIGV2ZW50RGV0YWlsc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnREZXRhaWxzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlclxuICAgICAgICAgICAgICAgIC5kaXNwYXRjaEV2ZW50KGAke3RoaXMuZXZlbnRQcmVmaXh9JHtldmVudERldGFpbHMudHlwZX1gLCBldmVudERldGFpbHMpXG4gICAgICAgICAgICAgICAgLmNhdGNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFjayBjb25uZWN0aW9uIGluaXQgZXZlbnQuXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICB0cmFja0Nvbm5lY3Rpb25TdGFydGVkKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlQ29ubmVjdGlvblN0YXJ0ZWRFdmVudCh0aGlzLnZlcnNpb24sIC4uLmFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFVzZXJBY3Rpb25FdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFjayBjb25uZWN0aW9uIHN1Y2Nlc3MgZXZlbnQuXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICB0cmFja0Nvbm5lY3Rpb25Db21wbGV0ZWQoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVDb25uZWN0aW9uQ29tcGxldGVkRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhY2sgY29ubmVjdGlvbiBlcnJvciBldmVudC5cbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIHRyYWNrQ29ubmVjdGlvbkVycm9yKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlQ29ubmVjdGlvbkVycm9yRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhY2sgY29ubmVjdGlvbiByZXN0b3JpbmcgaW5pdCBldmVudC5cbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIHRyYWNrQ29ubmVjdGlvblJlc3RvcmluZ1N0YXJ0ZWQoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVDb25uZWN0aW9uUmVzdG9yaW5nU3RhcnRlZEV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYWNrIGNvbm5lY3Rpb24gcmVzdG9yaW5nIHN1Y2Nlc3MgZXZlbnQuXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICB0cmFja0Nvbm5lY3Rpb25SZXN0b3JpbmdDb21wbGV0ZWQoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVDb25uZWN0aW9uUmVzdG9yaW5nQ29tcGxldGVkRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhY2sgY29ubmVjdGlvbiByZXN0b3JpbmcgZXJyb3IgZXZlbnQuXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICB0cmFja0Nvbm5lY3Rpb25SZXN0b3JpbmdFcnJvciguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGNyZWF0ZUNvbm5lY3Rpb25SZXN0b3JpbmdFcnJvckV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYWNrIGRpc2Nvbm5lY3QgZXZlbnQuXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICB0cmFja0Rpc2Nvbm5lY3Rpb24oLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVEaXNjb25uZWN0aW9uRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhY2sgdHJhbnNhY3Rpb24gaW5pdCBldmVudC5cbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIHRyYWNrVHJhbnNhY3Rpb25TZW50Rm9yU2lnbmF0dXJlKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlVHJhbnNhY3Rpb25TZW50Rm9yU2lnbmF0dXJlRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhY2sgdHJhbnNhY3Rpb24gc2lnbmVkIGV2ZW50LlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgdHJhY2tUcmFuc2FjdGlvblNpZ25lZCguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGNyZWF0ZVRyYW5zYWN0aW9uU2lnbmVkRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhY2sgdHJhbnNhY3Rpb24gZXJyb3IgZXZlbnQuXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICB0cmFja1RyYW5zYWN0aW9uU2lnbmluZ0ZhaWxlZCguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGNyZWF0ZVRyYW5zYWN0aW9uU2lnbmluZ0ZhaWxlZEV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYWNrIHNpZ24gZGF0YSBpbml0IGV2ZW50LlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgdHJhY2tEYXRhU2VudEZvclNpZ25hdHVyZSguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGNyZWF0ZURhdGFTZW50Rm9yU2lnbmF0dXJlRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhY2sgc2lnbiBkYXRhIHN1Y2Nlc3MgZXZlbnQuXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICB0cmFja0RhdGFTaWduZWQoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVEYXRhU2lnbmVkRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhY2sgc2lnbiBkYXRhIGVycm9yIGV2ZW50LlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgdHJhY2tEYXRhU2lnbmluZ0ZhaWxlZCguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGNyZWF0ZURhdGFTaWduaW5nRmFpbGVkRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG59XG5cbmNvbnN0IHRvbkNvbm5lY3RTZGtWZXJzaW9uID0gXCIzLjQuMVwiO1xuXG5jb25zdCBib3VuY2VhYmxlVGFnID0gMHgxMTtcbmNvbnN0IG5vQm91bmNlYWJsZVRhZyA9IDB4NTE7XG5jb25zdCB0ZXN0T25seVRhZyA9IDB4ODA7XG4vKipcbiAqIENvbnZlcnRzIHJhdyBUT04gYWRkcmVzcyB0byBuby1ib3VuY2VhYmxlIHVzZXItZnJpZW5kbHkgZm9ybWF0LiBbU2VlIGRldGFpbHNde0BsaW5rIGh0dHBzOi8vdG9uLm9yZy9kb2NzL2xlYXJuL292ZXJ2aWV3cy9hZGRyZXNzZXMjdXNlci1mcmllbmRseS1hZGRyZXNzfVxuICogQHBhcmFtIGhleEFkZHJlc3MgcmF3IFRPTiBhZGRyZXNzIGZvcm1hdHRlZCBhcyBcIjA6PGhleCBzdHJpbmcgd2l0aG91dCAweD5cIi5cbiAqIEBwYXJhbSBbdGVzdE9ubHk9ZmFsc2VdIGNvbnZlcnQgYWRkcmVzcyB0byB0ZXN0LW9ubHkgZm9ybS4gW1NlZSBkZXRhaWxzXXtAbGluayBodHRwczovL3Rvbi5vcmcvZG9jcy9sZWFybi9vdmVydmlld3MvYWRkcmVzc2VzI3VzZXItZnJpZW5kbHktYWRkcmVzc31cbiAqL1xuZnVuY3Rpb24gdG9Vc2VyRnJpZW5kbHlBZGRyZXNzKGhleEFkZHJlc3MsIHRlc3RPbmx5ID0gZmFsc2UpIHtcbiAgICBjb25zdCB7IHdjLCBoZXggfSA9IHBhcnNlSGV4QWRkcmVzcyhoZXhBZGRyZXNzKTtcbiAgICBsZXQgdGFnID0gbm9Cb3VuY2VhYmxlVGFnO1xuICAgIGlmICh0ZXN0T25seSkge1xuICAgICAgICB0YWcgfD0gdGVzdE9ubHlUYWc7XG4gICAgfVxuICAgIGNvbnN0IGFkZHIgPSBuZXcgSW50OEFycmF5KDM0KTtcbiAgICBhZGRyWzBdID0gdGFnO1xuICAgIGFkZHJbMV0gPSB3YztcbiAgICBhZGRyLnNldChoZXgsIDIpO1xuICAgIGNvbnN0IGFkZHJlc3NXaXRoQ2hlY2tzdW0gPSBuZXcgVWludDhBcnJheSgzNik7XG4gICAgYWRkcmVzc1dpdGhDaGVja3N1bS5zZXQoYWRkcik7XG4gICAgYWRkcmVzc1dpdGhDaGVja3N1bS5zZXQoY3JjMTYoYWRkciksIDM0KTtcbiAgICBsZXQgYWRkcmVzc0Jhc2U2NCA9IEJhc2U2NC5lbmNvZGUoYWRkcmVzc1dpdGhDaGVja3N1bSk7XG4gICAgcmV0dXJuIGFkZHJlc3NCYXNlNjQucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJyk7XG59XG4vKipcbiAqIFZhbGlkYXRlcyBpZiB0aGUgYWRkcmVzcyBpcyBpbiB1c2VyLWZyaWVuZGx5IGZvcm1hdCBieSBhdHRlbXB0aW5nIHRvIHBhcnNlIGl0LlxuICogQHBhcmFtIGFkZHJlc3MgYWRkcmVzcyB0byB2YWxpZGF0ZVxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgYWRkcmVzcyBpcyB2YWxpZCB1c2VyLWZyaWVuZGx5IGZvcm1hdCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRVc2VyRnJpZW5kbHlBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgICBwYXJzZVVzZXJGcmllbmRseUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGVzIGlmIHRoZSBhZGRyZXNzIGlzIGluIHJhdyBoZXggZm9ybWF0IChlLmcuLCBcIjA6MTIzNC4uLlwiIG9yIFwiLTE6MTIzNC4uLlwiKS5cbiAqIEBwYXJhbSBhZGRyZXNzIGFkZHJlc3MgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGFkZHJlc3MgaXMgdmFsaWQgcmF3IGZvcm1hdCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRSYXdBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgICBwYXJzZUhleEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvUmF3QWRkcmVzcyh7IHdjLCBoZXggfSkge1xuICAgIHJldHVybiBgJHt3Y306JHtoZXh9YDtcbn1cbi8qKlxuICogUGFyc2VzIHVzZXItZnJpZW5kbHkgYWRkcmVzcyBhbmQgcmV0dXJucyBpdHMgY29tcG9uZW50cy5cbiAqIEBwYXJhbSBhZGRyZXNzIHVzZXItZnJpZW5kbHkgYWRkcmVzc1xuICogQHJldHVybnMgcGFyc2VkIGFkZHJlc3MgY29tcG9uZW50c1xuICovXG5mdW5jdGlvbiBwYXJzZVVzZXJGcmllbmRseUFkZHJlc3MoYWRkcmVzcykge1xuICAgIGNvbnN0IGJhc2U2NCA9IGFkZHJlc3MucmVwbGFjZSgvLS9nLCAnKycpLnJlcGxhY2UoL18vZywgJy8nKTtcbiAgICBsZXQgZGVjb2RlZDtcbiAgICB0cnkge1xuICAgICAgICBkZWNvZGVkID0gQmFzZTY0LmRlY29kZShiYXNlNjQpLnRvVWludDhBcnJheSgpO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdyb25nQWRkcmVzc0Vycm9yKGBJbnZhbGlkIGJhc2U2NCBlbmNvZGluZyBpbiBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuICAgIGlmIChkZWNvZGVkLmxlbmd0aCAhPT0gMzYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdyb25nQWRkcmVzc0Vycm9yKGBJbnZhbGlkIGFkZHJlc3MgbGVuZ3RoOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuICAgIGNvbnN0IGFkZHIgPSBkZWNvZGVkLnNsaWNlKDAsIDM0KTtcbiAgICBjb25zdCBjaGVja3N1bSA9IGRlY29kZWQuc2xpY2UoMzQsIDM2KTtcbiAgICBjb25zdCBjYWxjdWxhdGVkQ2hlY2tzdW0gPSBjcmMxNihhZGRyKTtcbiAgICBpZiAoIWNoZWNrc3VtLmV2ZXJ5KChieXRlLCBpKSA9PiBieXRlID09PSBjYWxjdWxhdGVkQ2hlY2tzdW1baV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBXcm9uZ0FkZHJlc3NFcnJvcihgSW52YWxpZCBjaGVja3N1bSBpbiBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuICAgIGxldCB0YWcgPSBhZGRyWzBdO1xuICAgIGxldCBpc1Rlc3RPbmx5ID0gZmFsc2U7XG4gICAgbGV0IGlzQm91bmNlYWJsZSA9IGZhbHNlO1xuICAgIGlmICh0YWcgJiB0ZXN0T25seVRhZykge1xuICAgICAgICBpc1Rlc3RPbmx5ID0gdHJ1ZTtcbiAgICAgICAgdGFnID0gdGFnIF4gdGVzdE9ubHlUYWc7XG4gICAgfVxuICAgIGlmICh0YWcgIT09IGJvdW5jZWFibGVUYWcgJiYgdGFnICE9PSBub0JvdW5jZWFibGVUYWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdyb25nQWRkcmVzc0Vycm9yKGBVbmtub3duIGFkZHJlc3MgdGFnOiAke3RhZ31gKTtcbiAgICB9XG4gICAgaXNCb3VuY2VhYmxlID0gdGFnID09PSBib3VuY2VhYmxlVGFnO1xuICAgIGxldCB3YyA9IG51bGw7XG4gICAgaWYgKGFkZHJbMV0gPT09IDB4ZmYpIHtcbiAgICAgICAgLy8gVE9ETyB3ZSBzaG91bGQgcmVhZCBzaWduZWQgaW50ZWdlciBoZXJlXG4gICAgICAgIHdjID0gLTE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3YyA9IGFkZHJbMV07XG4gICAgfVxuICAgIGNvbnN0IGhleCA9IGFkZHIuc2xpY2UoMik7XG4gICAgaWYgKHdjICE9PSAwICYmIHdjICE9PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgV3JvbmdBZGRyZXNzRXJyb3IoYEludmFsaWQgd29ya2NoYWluOiAke3djfWApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB3YyxcbiAgICAgICAgaGV4OiBBcnJheS5mcm9tKGhleClcbiAgICAgICAgICAgIC5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKVxuICAgICAgICAgICAgLmpvaW4oJycpLFxuICAgICAgICB0ZXN0T25seTogaXNUZXN0T25seSxcbiAgICAgICAgaXNCb3VuY2VhYmxlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlSGV4QWRkcmVzcyhoZXhBZGRyZXNzKSB7XG4gICAgaWYgKCFoZXhBZGRyZXNzLmluY2x1ZGVzKCc6JykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdyb25nQWRkcmVzc0Vycm9yKGBXcm9uZyBhZGRyZXNzICR7aGV4QWRkcmVzc30uIEFkZHJlc3MgbXVzdCBpbmNsdWRlIFwiOlwiLmApO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0cyA9IGhleEFkZHJlc3Muc3BsaXQoJzonKTtcbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBXcm9uZ0FkZHJlc3NFcnJvcihgV3JvbmcgYWRkcmVzcyAke2hleEFkZHJlc3N9LiBBZGRyZXNzIG11c3QgaW5jbHVkZSBcIjpcIiBvbmx5IG9uY2UuYCk7XG4gICAgfVxuICAgIGNvbnN0IHdjID0gcGFyc2VJbnQocGFydHNbMF0pO1xuICAgIGlmICh3YyAhPT0gMCAmJiB3YyAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdyb25nQWRkcmVzc0Vycm9yKGBXcm9uZyBhZGRyZXNzICR7aGV4QWRkcmVzc30uIFdDIG11c3QgYmUgZXEgMCBvciAtMSwgYnV0ICR7d2N9IHJlY2VpdmVkLmApO1xuICAgIH1cbiAgICBjb25zdCBoZXggPSBwYXJ0c1sxXTtcbiAgICBpZiAoKGhleCA9PT0gbnVsbCB8fCBoZXggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhleC5sZW5ndGgpICE9PSA2NCkge1xuICAgICAgICB0aHJvdyBuZXcgV3JvbmdBZGRyZXNzRXJyb3IoYFdyb25nIGFkZHJlc3MgJHtoZXhBZGRyZXNzfS4gSGV4IHBhcnQgbXVzdCBiZSA2NGJ5dGVzIGxlbmd0aCwgYnV0ICR7aGV4ID09PSBudWxsIHx8IGhleCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaGV4Lmxlbmd0aH0gcmVjZWl2ZWQuYCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHdjLFxuICAgICAgICBoZXg6IGhleFRvQnl0ZXMoaGV4KVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmMxNihkYXRhKSB7XG4gICAgY29uc3QgcG9seSA9IDB4MTAyMTtcbiAgICBsZXQgcmVnID0gMDtcbiAgICBjb25zdCBtZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyAyKTtcbiAgICBtZXNzYWdlLnNldChkYXRhKTtcbiAgICBmb3IgKGxldCBieXRlIG9mIG1lc3NhZ2UpIHtcbiAgICAgICAgbGV0IG1hc2sgPSAweDgwO1xuICAgICAgICB3aGlsZSAobWFzayA+IDApIHtcbiAgICAgICAgICAgIHJlZyA8PD0gMTtcbiAgICAgICAgICAgIGlmIChieXRlICYgbWFzaykge1xuICAgICAgICAgICAgICAgIHJlZyArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFzayA+Pj0gMTtcbiAgICAgICAgICAgIGlmIChyZWcgPiAweGZmZmYpIHtcbiAgICAgICAgICAgICAgICByZWcgJj0gMHhmZmZmO1xuICAgICAgICAgICAgICAgIHJlZyBePSBwb2x5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShbTWF0aC5mbG9vcihyZWcgLyAyNTYpLCByZWcgJSAyNTZdKTtcbn1cbmNvbnN0IHRvQnl0ZU1hcCA9IHt9O1xuZm9yIChsZXQgb3JkID0gMDsgb3JkIDw9IDB4ZmY7IG9yZCsrKSB7XG4gICAgbGV0IHMgPSBvcmQudG9TdHJpbmcoMTYpO1xuICAgIGlmIChzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcyA9ICcwJyArIHM7XG4gICAgfVxuICAgIHRvQnl0ZU1hcFtzXSA9IG9yZDtcbn1cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaGV4ID0gaGV4LnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgbGVuZ3RoMiA9IGhleC5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aDIgJSAyICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUhleEVycm9yKCdIZXggc3RyaW5nIG11c3QgaGF2ZSBsZW5ndGggYSBtdWx0aXBsZSBvZiAyOiAnICsgaGV4KTtcbiAgICB9XG4gICAgY29uc3QgbGVuZ3RoID0gbGVuZ3RoMiAvIDI7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRvdWJsZWQgPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4U3Vic3RyaW5nID0gaGV4LnN1YnN0cmluZyhkb3VibGVkLCBkb3VibGVkICsgMik7XG4gICAgICAgIGlmICghdG9CeXRlTWFwLmhhc093blByb3BlcnR5KGhleFN1YnN0cmluZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUhleEVycm9yKCdJbnZhbGlkIGhleCBjaGFyYWN0ZXI6ICcgKyBoZXhTdWJzdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtpXSA9IHRvQnl0ZU1hcFtoZXhTdWJzdHJpbmddO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBCQVNFNjRfUkVHRVggPSAvXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC87XG5jb25zdCBCQVNFNjRVUkxfUkVHRVggPSAvXltBLVphLXowLTlcXC1fXSskLztcbmNvbnN0IEJPQ19QUkVGSVggPSAndGU2Y2MnO1xuY29uc3QgSU5URUdFUl9SRUdFWCA9IC9eLT9cXGQrJC87XG5jb25zdCBQT1NJVElWRV9JTlRFR0VSX1JFR0VYID0gL15cXGQrJC87XG5jb25zdCBNQVhfRE9NQUlOX0JZVEVTID0gMTI4O1xuY29uc3QgTUFYX1BBWUxPQURfQllURVMgPSAxMjg7XG5jb25zdCBNQVhfVE9UQUxfQllURVMgPSAyMjI7XG5mdW5jdGlvbiBpc1ZhbGlkTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5sZW5ndGggPiAwO1xufVxuZnVuY3Rpb24gaXNWYWxpZEFkZHJlc3ModmFsdWUpIHtcbiAgICByZXR1cm4gaXNWYWxpZFN0cmluZyh2YWx1ZSkgJiYgKGlzVmFsaWRSYXdBZGRyZXNzKHZhbHVlKSB8fCBpc1ZhbGlkVXNlckZyaWVuZGx5QWRkcmVzcyh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gaXNWYWxpZE5ldHdvcmsodmFsdWUpIHtcbiAgICByZXR1cm4gaXNWYWxpZFN0cmluZyh2YWx1ZSkgJiYgL14tP1xcZCskLy50ZXN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRCb2ModmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgKEJBU0U2NF9SRUdFWC50ZXN0KHZhbHVlKSB8fCBCQVNFNjRVUkxfUkVHRVgudGVzdCh2YWx1ZSkpICYmXG4gICAgICAgIHZhbHVlLnN0YXJ0c1dpdGgoQk9DX1BSRUZJWCkpO1xufVxuZnVuY3Rpb24gaXNWYWxpZE9iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGhhc0V4dHJhUHJvcGVydGllcyhvYmosIGFsbG93ZWRLZXlzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikuc29tZShrZXkgPT4gIWFsbG93ZWRLZXlzLmluY2x1ZGVzKGtleSkpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVTZW5kVHJhbnNhY3Rpb25SZXF1ZXN0KGRhdGEpIHtcbiAgICBpZiAoIWlzVmFsaWRPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuICdSZXF1ZXN0IG11c3QgYmUgYW4gb2JqZWN0JztcbiAgICB9XG4gICAgY29uc3QgYWxsb3dlZEtleXMgPSBbJ3ZhbGlkVW50aWwnLCAnbmV0d29yaycsICdmcm9tJywgJ21lc3NhZ2VzJ107XG4gICAgaWYgKGhhc0V4dHJhUHJvcGVydGllcyhkYXRhLCBhbGxvd2VkS2V5cykpIHtcbiAgICAgICAgcmV0dXJuICdSZXF1ZXN0IGNvbnRhaW5zIGV4dHJhIHByb3BlcnRpZXMnO1xuICAgIH1cbiAgICBpZiAoZGF0YS52YWxpZFVudGlsKSB7XG4gICAgICAgIGlmICghaXNWYWxpZE51bWJlcihkYXRhLnZhbGlkVW50aWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJJbmNvcnJlY3QgJ3ZhbGlkVW50aWwnXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm93ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICAgIGNvbnN0IGZpdmVNaW51dGVzRnJvbU5vdyA9IG5vdyArIDMwMDtcbiAgICAgICAgaWYgKGRhdGEudmFsaWRVbnRpbCA+IGZpdmVNaW51dGVzRnJvbU5vdykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGB2YWxpZFVudGlsICgke2RhdGEudmFsaWRVbnRpbH0pIGlzIG1vcmUgdGhhbiA1IG1pbnV0ZXMgZnJvbSBub3cgKCR7bm93fSlgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YS5uZXR3b3JrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkTmV0d29yayhkYXRhLm5ldHdvcmspKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJJbnZhbGlkICduZXR3b3JrJyBmb3JtYXRcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YS5mcm9tICE9PSB1bmRlZmluZWQgJiYgIWlzVmFsaWRBZGRyZXNzKGRhdGEuZnJvbSkpIHtcbiAgICAgICAgcmV0dXJuIFwiSW52YWxpZCAnZnJvbScgYWRkcmVzcyBmb3JtYXRcIjtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkQXJyYXkoZGF0YS5tZXNzYWdlcykgfHwgZGF0YS5tZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFwiJ21lc3NhZ2VzJyBpcyByZXF1aXJlZFwiO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGRhdGEubWVzc2FnZXNbaV07XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VFcnJvciA9IHZhbGlkYXRlVHJhbnNhY3Rpb25NZXNzYWdlKG1lc3NhZ2UsIGkpO1xuICAgICAgICBpZiAobWVzc2FnZUVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZUVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVUcmFuc2FjdGlvbk1lc3NhZ2UobWVzc2FnZSwgaW5kZXgpIHtcbiAgICBpZiAoIWlzVmFsaWRPYmplY3QobWVzc2FnZSkpIHtcbiAgICAgICAgcmV0dXJuIGBNZXNzYWdlIGF0IGluZGV4ICR7aW5kZXh9IG11c3QgYmUgYW4gb2JqZWN0YDtcbiAgICB9XG4gICAgY29uc3QgYWxsb3dlZEtleXMgPSBbJ2FkZHJlc3MnLCAnYW1vdW50JywgJ3N0YXRlSW5pdCcsICdwYXlsb2FkJywgJ2V4dHJhQ3VycmVuY3knXTtcbiAgICBpZiAoaGFzRXh0cmFQcm9wZXJ0aWVzKG1lc3NhZ2UsIGFsbG93ZWRLZXlzKSkge1xuICAgICAgICByZXR1cm4gYE1lc3NhZ2UgYXQgaW5kZXggJHtpbmRleH0gY29udGFpbnMgZXh0cmEgcHJvcGVydGllc2A7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZFN0cmluZyhtZXNzYWdlLmFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBgJ2FkZHJlc3MnIGlzIHJlcXVpcmVkIGluIG1lc3NhZ2UgYXQgaW5kZXggJHtpbmRleH1gO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWRVc2VyRnJpZW5kbHlBZGRyZXNzKG1lc3NhZ2UuYWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuIGBXcm9uZyAnYWRkcmVzcycgZm9ybWF0IGluIG1lc3NhZ2UgYXQgaW5kZXggJHtpbmRleH1gO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWRTdHJpbmcobWVzc2FnZS5hbW91bnQpKSB7XG4gICAgICAgIHJldHVybiBgJ2Ftb3VudCcgaXMgcmVxdWlyZWQgaW4gbWVzc2FnZSBhdCBpbmRleCAke2luZGV4fWA7XG4gICAgfVxuICAgIGlmICghL15bMC05XSskLy50ZXN0KG1lc3NhZ2UuYW1vdW50KSkge1xuICAgICAgICByZXR1cm4gYEluY29ycmVjdCAnYW1vdW50JyBpbiBtZXNzYWdlIGF0IGluZGV4ICR7aW5kZXh9YDtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2Uuc3RhdGVJbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RyaW5nKG1lc3NhZ2Uuc3RhdGVJbml0KSB8fCAhaXNWYWxpZEJvYyhtZXNzYWdlLnN0YXRlSW5pdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCAnc3RhdGVJbml0JyBpbiBtZXNzYWdlIGF0IGluZGV4ICR7aW5kZXh9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobWVzc2FnZS5wYXlsb2FkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RyaW5nKG1lc3NhZ2UucGF5bG9hZCkgfHwgIWlzVmFsaWRCb2MobWVzc2FnZS5wYXlsb2FkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGBJbnZhbGlkICdwYXlsb2FkJyBpbiBtZXNzYWdlIGF0IGluZGV4ICR7aW5kZXh9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobWVzc2FnZS5leHRyYUN1cnJlbmN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkT2JqZWN0KG1lc3NhZ2UuZXh0cmFDdXJyZW5jeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCAnZXh0cmFDdXJyZW5jeScgaW4gbWVzc2FnZSBhdCBpbmRleCAke2luZGV4fWA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobWVzc2FnZS5leHRyYUN1cnJlbmN5KSkge1xuICAgICAgICAgICAgaWYgKCFJTlRFR0VSX1JFR0VYLnRlc3Qoa2V5KSB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgICAgICAhUE9TSVRJVkVfSU5URUdFUl9SRUdFWC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCAnZXh0cmFDdXJyZW5jeScgZm9ybWF0IGluIG1lc3NhZ2UgYXQgaW5kZXggJHtpbmRleH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVDb25uZWN0QWRkaXRpb25hbFJlcXVlc3QoZGF0YSkge1xuICAgIGlmICghaXNWYWxpZE9iamVjdChkYXRhKSkge1xuICAgICAgICByZXR1cm4gJ1JlcXVlc3QgbXVzdCBiZSBhbiBvYmplY3QnO1xuICAgIH1cbiAgICBjb25zdCBhbGxvd2VkS2V5cyA9IFsndG9uUHJvb2YnXTtcbiAgICBpZiAoaGFzRXh0cmFQcm9wZXJ0aWVzKGRhdGEsIGFsbG93ZWRLZXlzKSkge1xuICAgICAgICByZXR1cm4gJ1JlcXVlc3QgY29udGFpbnMgZXh0cmEgcHJvcGVydGllcyc7XG4gICAgfVxuICAgIGlmIChkYXRhLnRvblByb29mICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLnRvblByb29mICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIFwiSW52YWxpZCAndG9uUHJvb2YnXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRhdGEudG9uUHJvb2Y7XG4gICAgICAgIGlmIChwYXlsb2FkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiRW1wdHkgJ3RvblByb29mJyBwYXlsb2FkXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IGN1cnJlbnQgZG9tYWluIGZvciB2YWxpZGF0aW9uIGZpcnN0XG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgICAgICBpZiAoIWRvbWFpbikge1xuICAgICAgICAgICAgLy8gSW4gTm9kZS5qcyBlbnZpcm9ubWVudCwgc2tpcCBkb21haW4gdmFsaWRhdGlvblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmFsaWRhdGUgZG9tYWluIHNpemUgKG1heCAxMjggYnl0ZXMpXG4gICAgICAgIGNvbnN0IGRvbWFpbkJ5dGVzID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGRvbWFpbikubGVuZ3RoO1xuICAgICAgICBpZiAoZG9tYWluQnl0ZXMgPiBNQVhfRE9NQUlOX0JZVEVTKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0N1cnJlbnQgZG9tYWluIGV4Y2VlZHMgMTI4IGJ5dGVzIGxpbWl0JztcbiAgICAgICAgfVxuICAgICAgICAvLyBWYWxpZGF0ZSBwYXlsb2FkIHNpemUgKG1heCAxMjggYnl0ZXMpXG4gICAgICAgIGNvbnN0IHBheWxvYWRCeXRlcyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShwYXlsb2FkKS5sZW5ndGg7XG4gICAgICAgIGlmIChwYXlsb2FkQnl0ZXMgPiBNQVhfUEFZTE9BRF9CWVRFUykge1xuICAgICAgICAgICAgcmV0dXJuIFwiJ3RvblByb29mJyBwYXlsb2FkIGV4Y2VlZHMgMTI4IGJ5dGVzIGxpbWl0XCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmFsaWRhdGUgdG90YWwgc2l6ZSAoZG9tYWluICsgcGF5bG9hZCA8PSAyMjIgYnl0ZXMpXG4gICAgICAgIGlmIChkb21haW5CeXRlcyArIHBheWxvYWRCeXRlcyA+IE1BWF9UT1RBTF9CWVRFUykge1xuICAgICAgICAgICAgcmV0dXJuIFwiJ3RvblByb29mJyBkb21haW4gKyBwYXlsb2FkIGV4Y2VlZHMgMjIyIGJ5dGVzIGxpbWl0XCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVNpZ25EYXRhUGF5bG9hZChkYXRhKSB7XG4gICAgaWYgKCFpc1ZhbGlkT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgIHJldHVybiAnUGF5bG9hZCBtdXN0IGJlIGFuIG9iamVjdCc7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZFN0cmluZyhkYXRhLnR5cGUpKSB7XG4gICAgICAgIHJldHVybiBcIid0eXBlJyBpcyByZXF1aXJlZFwiO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZVNpZ25EYXRhUGF5bG9hZFRleHQoZGF0YSk7XG4gICAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVTaWduRGF0YVBheWxvYWRCaW5hcnkoZGF0YSk7XG4gICAgICAgIGNhc2UgJ2NlbGwnOlxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlU2lnbkRhdGFQYXlsb2FkQ2VsbChkYXRhKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIkludmFsaWQgJ3R5cGUnIHZhbHVlXCI7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVTaWduRGF0YVBheWxvYWRUZXh0KGRhdGEpIHtcbiAgICBjb25zdCBhbGxvd2VkS2V5cyA9IFsndHlwZScsICd0ZXh0JywgJ25ldHdvcmsnLCAnZnJvbSddO1xuICAgIGlmIChoYXNFeHRyYVByb3BlcnRpZXMoZGF0YSwgYWxsb3dlZEtleXMpKSB7XG4gICAgICAgIHJldHVybiAnVGV4dCBwYXlsb2FkIGNvbnRhaW5zIGV4dHJhIHByb3BlcnRpZXMnO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWRTdHJpbmcoZGF0YS50ZXh0KSkge1xuICAgICAgICByZXR1cm4gXCIndGV4dCcgaXMgcmVxdWlyZWRcIjtcbiAgICB9XG4gICAgaWYgKGRhdGEubmV0d29yayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghaXNWYWxpZE5ldHdvcmsoZGF0YS5uZXR3b3JrKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiSW52YWxpZCAnbmV0d29yaycgZm9ybWF0XCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRhdGEuZnJvbSAhPT0gdW5kZWZpbmVkICYmICFpc1ZhbGlkQWRkcmVzcyhkYXRhLmZyb20pKSB7XG4gICAgICAgIHJldHVybiBcIkludmFsaWQgJ2Zyb20nXCI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVTaWduRGF0YVBheWxvYWRCaW5hcnkoZGF0YSkge1xuICAgIGNvbnN0IGFsbG93ZWRLZXlzID0gWyd0eXBlJywgJ2J5dGVzJywgJ25ldHdvcmsnLCAnZnJvbSddO1xuICAgIGlmIChoYXNFeHRyYVByb3BlcnRpZXMoZGF0YSwgYWxsb3dlZEtleXMpKSB7XG4gICAgICAgIHJldHVybiAnQmluYXJ5IHBheWxvYWQgY29udGFpbnMgZXh0cmEgcHJvcGVydGllcyc7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZFN0cmluZyhkYXRhLmJ5dGVzKSkge1xuICAgICAgICByZXR1cm4gXCInYnl0ZXMnIGlzIHJlcXVpcmVkXCI7XG4gICAgfVxuICAgIGlmIChkYXRhLm5ldHdvcmsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIWlzVmFsaWROZXR3b3JrKGRhdGEubmV0d29yaykpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkludmFsaWQgJ25ldHdvcmsnIGZvcm1hdFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhLmZyb20gIT09IHVuZGVmaW5lZCAmJiAhaXNWYWxpZEFkZHJlc3MoZGF0YS5mcm9tKSkge1xuICAgICAgICByZXR1cm4gXCJJbnZhbGlkICdmcm9tJ1wiO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlU2lnbkRhdGFQYXlsb2FkQ2VsbChkYXRhKSB7XG4gICAgY29uc3QgYWxsb3dlZEtleXMgPSBbJ3R5cGUnLCAnc2NoZW1hJywgJ2NlbGwnLCAnbmV0d29yaycsICdmcm9tJ107XG4gICAgaWYgKGhhc0V4dHJhUHJvcGVydGllcyhkYXRhLCBhbGxvd2VkS2V5cykpIHtcbiAgICAgICAgcmV0dXJuICdDZWxsIHBheWxvYWQgY29udGFpbnMgZXh0cmEgcHJvcGVydGllcyc7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZFN0cmluZyhkYXRhLnNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIFwiJ3NjaGVtYScgaXMgcmVxdWlyZWRcIjtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkU3RyaW5nKGRhdGEuY2VsbCkpIHtcbiAgICAgICAgcmV0dXJuIFwiJ2NlbGwnIGlzIHJlcXVpcmVkXCI7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZEJvYyhkYXRhLmNlbGwpKSB7XG4gICAgICAgIHJldHVybiBcIkludmFsaWQgJ2NlbGwnIGZvcm1hdCAobXVzdCBiZSB2YWxpZCBiYXNlNjQpXCI7XG4gICAgfVxuICAgIGlmIChkYXRhLm5ldHdvcmsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIWlzVmFsaWROZXR3b3JrKGRhdGEubmV0d29yaykpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkludmFsaWQgJ25ldHdvcmsnIGZvcm1hdFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhLmZyb20gIT09IHVuZGVmaW5lZCAmJiAhaXNWYWxpZEFkZHJlc3MoZGF0YS5mcm9tKSkge1xuICAgICAgICByZXR1cm4gXCJJbnZhbGlkICdmcm9tJ1wiO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogVmFsaWRhdGVzIHRvbl9wcm9vZiBpdGVtIHJlY2VpdmVkIGZyb20gd2FsbGV0IGluIGNvbm5lY3QgZXZlbnQuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB2YWxpZGF0ZVRvblByb29mSXRlbVJlcGx5KGRhdGEpIHtcbiAgICBpZiAoIWlzVmFsaWRPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuICd0b25fcHJvb2YgaXRlbSBtdXN0IGJlIGFuIG9iamVjdCc7XG4gICAgfVxuICAgIGNvbnN0IGFsbG93ZWRLZXlzID0gWydlcnJvcicsICdwcm9vZicsICduYW1lJ107XG4gICAgaWYgKGhhc0V4dHJhUHJvcGVydGllcyhkYXRhLCBhbGxvd2VkS2V5cykpIHtcbiAgICAgICAgcmV0dXJuICd0b25fcHJvb2YgaXRlbSBjb250YWlucyBleHRyYSBwcm9wZXJ0aWVzJztcbiAgICB9XG4gICAgY29uc3QgaGFzUHJvb2YgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgJ3Byb29mJyk7XG4gICAgY29uc3QgaGFzRXJyb3IgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgJ2Vycm9yJyk7XG4gICAgaWYgKCFoYXNQcm9vZiAmJiAhaGFzRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFwiJ3Rvbl9wcm9vZicgaXRlbSBtdXN0IGNvbnRhaW4gZWl0aGVyICdwcm9vZicgb3IgJ2Vycm9yJ1wiO1xuICAgIH1cbiAgICBpZiAoaGFzUHJvb2YgJiYgaGFzRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFwiJ3Rvbl9wcm9vZicgaXRlbSBtdXN0IGNvbnRhaW4gZWl0aGVyICdwcm9vZicgb3IgJ2Vycm9yJywgbm90IGJvdGhcIjtcbiAgICB9XG4gICAgaWYgKGhhc1Byb29mKSB7XG4gICAgICAgIGNvbnN0IHByb29mID0gZGF0YS5wcm9vZjtcbiAgICAgICAgaWYgKCFpc1ZhbGlkT2JqZWN0KHByb29mKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiSW52YWxpZCAncHJvb2YnIG9iamVjdFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNWYWxpZE51bWJlcihwcm9vZi50aW1lc3RhbXApKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJJbnZhbGlkICdwcm9vZi50aW1lc3RhbXAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9tYWluID0gcHJvb2YuZG9tYWluO1xuICAgICAgICBpZiAoIWlzVmFsaWRPYmplY3QoZG9tYWluKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiSW52YWxpZCAncHJvb2YuZG9tYWluJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNWYWxpZE51bWJlcihkb21haW4ubGVuZ3RoQnl0ZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJJbnZhbGlkICdwcm9vZi5kb21haW4ubGVuZ3RoQnl0ZXMnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RyaW5nKGRvbWFpbi52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkludmFsaWQgJ3Byb29mLmRvbWFpbi52YWx1ZSdcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gdmVyaWZ5IHRoYXQgcHJvdmlkZWQgYnl0ZSBsZW5ndGggbWF0Y2hlcyBhY3R1YWwgYnl0ZSBsZW5ndGggb2YgdmFsdWVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXJBdmFpbGFibGUgPSB0eXBlb2YgVGV4dEVuY29kZXIgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgY29uc3QgYWN0dWFsTGVuZ3RoID0gZW5jb2RlckF2YWlsYWJsZVxuICAgICAgICAgICAgICAgID8gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGRvbWFpbi52YWx1ZSkubGVuZ3RoXG4gICAgICAgICAgICAgICAgOiBkb21haW4udmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGFjdHVhbExlbmd0aCAhPT0gZG9tYWluLmxlbmd0aEJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiJ3Byb29mLmRvbWFpbi5sZW5ndGhCeXRlcycgZG9lcyBub3QgbWF0Y2ggJ3Byb29mLmRvbWFpbi52YWx1ZSdcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBlbnZpcm9ubWVudCBpc3N1ZXM7IGJlc3QtZWZmb3J0IHZhbGlkYXRpb25cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVmFsaWRTdHJpbmcocHJvb2YucGF5bG9hZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkludmFsaWQgJ3Byb29mLnBheWxvYWQnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RyaW5nKHByb29mLnNpZ25hdHVyZSkgfHwgIUJBU0U2NF9SRUdFWC50ZXN0KHByb29mLnNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkludmFsaWQgJ3Byb29mLnNpZ25hdHVyZScgZm9ybWF0XCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc0Vycm9yKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZGF0YS5lcnJvcjtcbiAgICAgICAgaWYgKCFpc1ZhbGlkT2JqZWN0KGVycm9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiSW52YWxpZCAnZXJyb3InIG9iamVjdFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsbG93ZWRFcnJvcktleXMgPSBbJ2NvZGUnLCAnbWVzc2FnZSddO1xuICAgICAgICBpZiAoaGFzRXh0cmFQcm9wZXJ0aWVzKGVycm9yLCBhbGxvd2VkRXJyb3JLZXlzKSkge1xuICAgICAgICAgICAgcmV0dXJuICd0b25fcHJvb2YgZXJyb3IgY29udGFpbnMgZXh0cmEgcHJvcGVydGllcyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1ZhbGlkTnVtYmVyKGVycm9yLmNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJJbnZhbGlkICdlcnJvci5jb2RlJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNWYWxpZFN0cmluZyhlcnJvci5tZXNzYWdlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiSW52YWxpZCAnZXJyb3IubWVzc2FnZSdcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQmFzZTY0KGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHBhZGRlZExlbmd0aCA9IGRhdGEubGVuZ3RoICsgKCg0IC0gKGRhdGEubGVuZ3RoICUgNCkpICUgNCk7XG4gICAgcmV0dXJuIGRhdGEucmVwbGFjZSgvLS9nLCAnKycpLnJlcGxhY2UoL18vZywgJy8nKS5wYWRFbmQocGFkZGVkTGVuZ3RoLCAnPScpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgUGFzY2FsQ2FzZSAob3IgY2FtZWxDYXNlKSBzdHJpbmcgdG8ga2ViYWItY2FzZS5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqIC0gXCJQYXNjYWxDYXNlXCIg4oaSIFwicGFzY2FsLWNhc2VcIlxuICogLSBcImNhbWVsQ2FzZUV4YW1wbGVcIiDihpIgXCJjYW1lbC1jYXNlLWV4YW1wbGVcIlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBpbnB1dCBzdHJpbmcgaW4gUGFzY2FsQ2FzZSBvciBjYW1lbENhc2UgZm9ybWF0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBrZWJhYi1jYXNlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcGFzY2FsVG9LZWJhYih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC8oW2EtejAtOV0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xufVxuLyoqXG4gKiBDb2xsZWN0cyBzdGF0aWMgY29ubmVjdGlvbiBtZXRyaWNzIGZyb20gdGhlIGJyb3dzZXIncyBQZXJmb3JtYW5jZSBBUEkuXG4gKiBUVEZCIGlzIG1lYXN1cmVkIG9uY2UgYXQgcGFnZSBsb2FkIGFuZCBkb2Vzbid0IGNoYW5nZS5cbiAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIHN0YXRpYyBjb25uZWN0aW9uIG1ldHJpY3MgKFRURkIpIG9yIGVtcHR5IG9iamVjdCBpZiBub3QgYXZhaWxhYmxlLlxuICovXG5mdW5jdGlvbiBnZXRTdGF0aWNDb25uZWN0aW9uTWV0cmljcygpIHtcbiAgICBjb25zdCBtZXRyaWNzID0ge307XG4gICAgLy8gR2V0IFRURkIgZnJvbSBOYXZpZ2F0aW9uIFRpbWluZyBBUEkgKHN0YXRpYywgbWVhc3VyZWQgb25jZSBhdCBwYWdlIGxvYWQpXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbmF2RW50cmllcyA9IHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeVR5cGUoJ25hdmlnYXRpb24nKTtcbiAgICAgICAgaWYgKG5hdkVudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbmF2ID0gbmF2RW50cmllc1swXTtcbiAgICAgICAgICAgIGlmIChuYXYucmVzcG9uc2VTdGFydCAmJiBuYXYucmVxdWVzdFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgbWV0cmljcy5jb25uX3R0ZmIgPSBNYXRoLnJvdW5kKG5hdi5yZXNwb25zZVN0YXJ0IC0gbmF2LnJlcXVlc3RTdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gUGVyZm9ybWFuY2UgQVBJIG5vdCBhdmFpbGFibGUgb3IgZXJyb3Igb2NjdXJyZWRcbiAgICB9XG4gICAgcmV0dXJuIG1ldHJpY3M7XG59XG4vKipcbiAqIENvbGxlY3RzIGR5bmFtaWMgY29ubmVjdGlvbiBtZXRyaWNzIGZyb20gdGhlIGJyb3dzZXIncyBOZXR3b3JrIEluZm9ybWF0aW9uIEFQSS5cbiAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIGR5bmFtaWMgY29ubmVjdGlvbiBtZXRyaWNzIChSVFQsIG5ldHdvcmsgdHlwZSkgb3IgZW1wdHkgb2JqZWN0IGlmIG5vdCBhdmFpbGFibGUuXG4gKi9cbmZ1bmN0aW9uIGdldER5bmFtaWNDb25uZWN0aW9uTWV0cmljcygpIHtcbiAgICBjb25zdCBtZXRyaWNzID0ge307XG4gICAgLy8gR2V0IFJUVCBhbmQgbmV0d29yayB0eXBlIGZyb20gTmV0d29yayBJbmZvcm1hdGlvbiBBUEkgKGR5bmFtaWMsIGNhbiBjaGFuZ2UpXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbmF2aWdhdG9yV2l0aENvbm5lY3Rpb24gPSBuYXZpZ2F0b3I7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBuYXZpZ2F0b3JXaXRoQ29ubmVjdGlvbi5jb25uZWN0aW9uIHx8XG4gICAgICAgICAgICBuYXZpZ2F0b3JXaXRoQ29ubmVjdGlvbi5tb3pDb25uZWN0aW9uIHx8XG4gICAgICAgICAgICBuYXZpZ2F0b3JXaXRoQ29ubmVjdGlvbi53ZWJraXRDb25uZWN0aW9uO1xuICAgICAgICBpZiAoY29ubmVjdGlvbikge1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24ucnR0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtZXRyaWNzLmNvbm5fcnR0ID0gY29ubmVjdGlvbi5ydHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5lZmZlY3RpdmVUeXBlKSB7XG4gICAgICAgICAgICAgICAgbWV0cmljcy5jb25uX25ldHdvcmtfdHlwZSA9IGNvbm5lY3Rpb24uZWZmZWN0aXZlVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbm5lY3Rpb24udHlwZSkge1xuICAgICAgICAgICAgICAgIG1ldHJpY3MuY29ubl9uZXR3b3JrX3R5cGUgPSBjb25uZWN0aW9uLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gTmV0d29yayBJbmZvcm1hdGlvbiBBUEkgbm90IGF2YWlsYWJsZSBvciBlcnJvciBvY2N1cnJlZFxuICAgIH1cbiAgICByZXR1cm4gbWV0cmljcztcbn1cblxuY2xhc3MgQW5hbHl0aWNzTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmFja29mZiA9IDE7XG4gICAgICAgIHRoaXMuc2hvdWxkU2VuZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYmF0Y2hUaW1lb3V0TXMgPSAoX2EgPSBvcHRpb25zLmJhdGNoVGltZW91dE1zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAyMDAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRCYXRjaFRpbWVvdXRNcyA9IHRoaXMuYmF0Y2hUaW1lb3V0TXM7XG4gICAgICAgIHRoaXMubWF4QmF0Y2hTaXplID0gKF9iID0gb3B0aW9ucy5tYXhCYXRjaFNpemUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDEwMDtcbiAgICAgICAgdGhpcy5hbmFseXRpY3NVcmwgPSAoX2MgPSBvcHRpb25zLmFuYWx5dGljc1VybCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJ2h0dHBzOi8vYW5hbHl0aWNzLnRvbi5vcmcvZXZlbnRzJztcbiAgICAgICAgdGhpcy5tb2RlID0gKF9kID0gb3B0aW9ucy5tb2RlKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAndGVsZW1ldHJ5JztcbiAgICAgICAgdGhpcy5iYXNlRXZlbnQgPSBPYmplY3QuYXNzaWduKHsgc3Vic3lzdGVtOiAnZGFwcC1zZGsnLCB2ZXJzaW9uOiB0b25Db25uZWN0U2RrVmVyc2lvbiwgY2xpZW50X2Vudmlyb25tZW50OiAoX2YgPSAoX2UgPSBvcHRpb25zLmVudmlyb25tZW50KSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuZ2V0Q2xpZW50RW52aXJvbm1lbnQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxsKF9lKSB9LCBnZXRTdGF0aWNDb25uZWN0aW9uTWV0cmljcygpKTtcbiAgICAgICAgdGhpcy5hZGRXaW5kb3dGb2N1c0FuZEJsdXJTdWJzY3JpcHRpb25zKCk7XG4gICAgfVxuICAgIHNjb3BlZChzaGFyZWREYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gcHJvcC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wTmFtZS5zdGFydHNXaXRoKCdlbWl0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnROYW1lUGFzY2FsID0gcHJvcE5hbWUucmVwbGFjZSgnZW1pdCcsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnROYW1lS2ViYWIgPSBwYXNjYWxUb0tlYmFiKGV2ZW50TmFtZVBhc2NhbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4ZWN1dGVkRGF0YSA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhzaGFyZWREYXRhICE9PSBudWxsICYmIHNoYXJlZERhdGEgIT09IHZvaWQgMCA/IHNoYXJlZERhdGEgOiB7fSkubWFwKChba2V5LCB2YWx1ZV0pID0+IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUoKSA6IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmVtaXQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgZXZlbnRfbmFtZTogZXZlbnROYW1lS2ViYWIgfSwgZXhlY3V0ZWREYXRhKSwgZXZlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW1pdChldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdvZmYnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhY2VJZCA9IChfYSA9IGV2ZW50LnRyYWNlX2lkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBVVUlEdjcoKTtcbiAgICAgICAgY29uc3QgZHluYW1pY01ldHJpY3MgPSBnZXREeW5hbWljQ29ubmVjdGlvbk1ldHJpY3MoKTtcbiAgICAgICAgY29uc3QgZW5oYW5jZWRFdmVudCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZUV2ZW50KSwgZHluYW1pY01ldHJpY3MpLCBldmVudCksIHsgZXZlbnRfaWQ6IFVVSUR2NygpLCBjbGllbnRfdGltZXN0YW1wOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSwgdHJhY2VfaWQ6IHRyYWNlSWQgfSk7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkRXZlbnQgPSB0aGlzLm1vZGUgPT09ICd0ZWxlbWV0cnknID8gdGhpcy5maWx0ZXJGdWxsTW9kZUZpZWxkcyhlbmhhbmNlZEV2ZW50KSA6IGVuaGFuY2VkRXZlbnQ7XG4gICAgICAgIGlmIChpc1FhTW9kZUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgbG9nRGVidWcoZmlsdGVyZWRFdmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudHMucHVzaChmaWx0ZXJlZEV2ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmxlbmd0aCA+PSB0aGlzLm1heEJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgdm9pZCB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydFRpbWVvdXQoKTtcbiAgICB9XG4gICAgc3RhcnRUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0SWQgfHwgdGhpcy5pc1Byb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdm9pZCB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH0sIHRoaXMuY3VycmVudEJhdGNoVGltZW91dE1zKTtcbiAgICB9XG4gICAgZmx1c2goKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1Byb2Nlc3NpbmcgfHwgdGhpcy5ldmVudHMubGVuZ3RoID09PSAwIHx8ICF0aGlzLnNob3VsZFNlbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgICAgICAgICAgdGhpcy5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgZXZlbnRzVG9TZW5kID0gdGhpcy5leHRyYWN0RXZlbnRzVG9TZW5kKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucHJvY2Vzc0V2ZW50c0JhdGNoKGV2ZW50c1RvU2VuZCk7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ0FuYWx5dGljcyBldmVudHMgc2VudCBzdWNjZXNzZnVsbHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZUV2ZW50cyhldmVudHNUb1NlbmQpO1xuICAgICAgICAgICAgICAgIGxvZ0Vycm9yKCdGYWlsZWQgdG8gc2VuZCBhbmFseXRpY3MgZXZlbnRzOicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZU5leHRGbHVzaElmTmVlZGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbGVhclRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKTtcbiAgICAgICAgICAgIHRoaXMudGltZW91dElkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleHRyYWN0RXZlbnRzVG9TZW5kKCkge1xuICAgICAgICBjb25zdCBldmVudHNUb1NlbmQgPSB0aGlzLmV2ZW50cy5zbGljZSgwLCB0aGlzLm1heEJhdGNoU2l6ZSk7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gdGhpcy5ldmVudHMuc2xpY2UodGhpcy5tYXhCYXRjaFNpemUpO1xuICAgICAgICByZXR1cm4gZXZlbnRzVG9TZW5kO1xuICAgIH1cbiAgICBwcm9jZXNzRXZlbnRzQmF0Y2goZXZlbnRzVG9TZW5kKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZygnU2VuZGluZyBhbmFseXRpY3MgZXZlbnRzLi4uJywgZXZlbnRzVG9TZW5kLmxlbmd0aCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zZW5kRXZlbnRzKGV2ZW50c1RvU2VuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVVbmtub3duRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBzdGF0dXNUZXh0IH0gPSByZXNwb25zZTtcbiAgICAgICAgaWYgKHRoaXMuaXNUb29NYW55UmVxdWVzdHMoc3RhdHVzKSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVUb29NYW55UmVxdWVzdHMoc3RhdHVzLCBzdGF0dXNUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzQ2xpZW50RXJyb3Ioc3RhdHVzKSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDbGllbnRFcnJvcihzdGF0dXMsIHN0YXR1c1RleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNTZXJ2ZXJFcnJvcihzdGF0dXMpKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVVua25vd25FcnJvcih7IHN0YXR1cywgc3RhdHVzVGV4dCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN0b3JlRXZlbnRzKGV2ZW50c1RvU2VuZCkge1xuICAgICAgICB0aGlzLmV2ZW50cy51bnNoaWZ0KC4uLmV2ZW50c1RvU2VuZCk7XG4gICAgfVxuICAgIHNjaGVkdWxlTmV4dEZsdXNoSWZOZWVkZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZW91dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRFdmVudHMoZXZlbnRzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgZmV0Y2godGhpcy5hbmFseXRpY3NVcmwsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgICdYLUNsaWVudC1UaW1lc3RhbXAnOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShldmVudHMpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzQ2xpZW50RXJyb3Ioc3RhdHVzKSB7XG4gICAgICAgIHJldHVybiAoc3RhdHVzID49IEFuYWx5dGljc01hbmFnZXIuSFRUUF9TVEFUVVMuQ0xJRU5UX0VSUk9SX1NUQVJUICYmXG4gICAgICAgICAgICBzdGF0dXMgPCBBbmFseXRpY3NNYW5hZ2VyLkhUVFBfU1RBVFVTLlNFUlZFUl9FUlJPUl9TVEFSVCk7XG4gICAgfVxuICAgIGlzU2VydmVyRXJyb3Ioc3RhdHVzKSB7XG4gICAgICAgIHJldHVybiBzdGF0dXMgPj0gQW5hbHl0aWNzTWFuYWdlci5IVFRQX1NUQVRVUy5TRVJWRVJfRVJST1JfU1RBUlQ7XG4gICAgfVxuICAgIGlzVG9vTWFueVJlcXVlc3RzKHN0YXR1cykge1xuICAgICAgICByZXR1cm4gc3RhdHVzID09PSBBbmFseXRpY3NNYW5hZ2VyLkhUVFBfU1RBVFVTLlRPT19NQU5ZX1JFUVVFU1RTO1xuICAgIH1cbiAgICBoYW5kbGVDbGllbnRFcnJvcihzdGF0dXMsIHN0YXR1c1RleHQpIHtcbiAgICAgICAgLy8gRG9uJ3QgcmV0cnlcbiAgICAgICAgbG9nRXJyb3IoJ0ZhaWxlZCB0byBzZW5kIGFuYWx5dGljcyBldmVudHM6JywgbmV3IFRvbkNvbm5lY3RFcnJvcihgQW5hbHl0aWNzIEFQSSBlcnJvcjogJHtzdGF0dXN9ICR7c3RhdHVzVGV4dH1gKSk7XG4gICAgfVxuICAgIGhhbmRsZVVua25vd25FcnJvcihlcnJvcikge1xuICAgICAgICBpZiAodGhpcy5iYWNrb2ZmIDwgQW5hbHl0aWNzTWFuYWdlci5NQVhfQkFDS09GRl9BVFRFTVBUUykge1xuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmKys7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRCYXRjaFRpbWVvdXRNcyAqPSBBbmFseXRpY3NNYW5hZ2VyLkJBQ0tPRkZfTVVMVElQTElFUjtcbiAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoYFVua25vd24gYW5hbHl0aWNzIEFQSSBlcnJvcjogJHtlcnJvcn1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJhdGNoVGltZW91dE1zID0gdGhpcy5iYXRjaFRpbWVvdXRNcztcbiAgICAgICAgICAgIHRoaXMuYmFja29mZiA9IDE7XG4gICAgICAgICAgICByZXR1cm47IC8vIERvbid0IHJldHJ5XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlVG9vTWFueVJlcXVlc3RzKHN0YXR1cywgc3RhdHVzVGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKGBBbmFseXRpY3MgQVBJIGVycm9yOiAke3N0YXR1c30gJHtzdGF0dXNUZXh0fWApO1xuICAgIH1cbiAgICBhZGRXaW5kb3dGb2N1c0FuZEJsdXJTdWJzY3JpcHRpb25zKCkge1xuICAgICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gICAgICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvdWxkU2VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG91bGRTZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZU5leHRGbHVzaElmTmVlZGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yKCdDYW5ub3Qgc3Vic2NyaWJlIHRvIHRoZSBkb2N1bWVudC52aXNpYmlsaXR5Y2hhbmdlOiAnLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRNb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlO1xuICAgIH1cbiAgICBnZXRQZW5kaW5nRXZlbnRzQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50cy5sZW5ndGg7XG4gICAgfVxuICAgIGZpbHRlckZ1bGxNb2RlRmllbGRzKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQpO1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIEFuYWx5dGljc01hbmFnZXIuRlVMTF9NT0RFX0ZJRUxEUykge1xuICAgICAgICAgICAgZGVsZXRlIGZpbHRlcmVkW2ZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3YWxsZXRfYWRkcmVzcyBpcyBrZXB0IGZvciBlcnJvciBldmVudHMsIHJlbW92ZWQgZm9yIG5vbi1lcnJvciBldmVudHNcbiAgICAgICAgY29uc3QgZXZlbnROYW1lID0gJ2V2ZW50X25hbWUnIGluIGV2ZW50ID8gU3RyaW5nKGV2ZW50LmV2ZW50X25hbWUpIDogJyc7XG4gICAgICAgIGNvbnN0IGlzRXJyb3JFdmVudCA9ICdlcnJvcl9jb2RlJyBpbiBldmVudCB8fFxuICAgICAgICAgICAgJ2Vycm9yX21lc3NhZ2UnIGluIGV2ZW50IHx8XG4gICAgICAgICAgICBldmVudE5hbWUuaW5jbHVkZXMoJ2Vycm9yJykgfHxcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9PT0gJ2Nvbm5lY3Rpb24tZXJyb3InIHx8XG4gICAgICAgICAgICBldmVudE5hbWUgPT09ICd0cmFuc2FjdGlvbi1zaWduaW5nLWZhaWxlZCcgfHxcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9PT0gJ3NpZ24tZGF0YS1yZXF1ZXN0LWZhaWxlZCc7XG4gICAgICAgIGlmICghaXNFcnJvckV2ZW50ICYmICd3YWxsZXRfYWRkcmVzcycgaW4gZmlsdGVyZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBmaWx0ZXJlZC53YWxsZXRfYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XG4gICAgfVxuICAgIHNldFdhbGxldExpc3REb3dubG9hZER1cmF0aW9uKGR1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMuYmFzZUV2ZW50ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VFdmVudCksIHsgd2FsbGV0X2xpc3RfZG93bmxvYWRfZHVyYXRpb246IGR1cmF0aW9uIH0pO1xuICAgIH1cbn1cbkFuYWx5dGljc01hbmFnZXIuSFRUUF9TVEFUVVMgPSB7XG4gICAgVE9PX01BTllfUkVRVUVTVFM6IDQyOSxcbiAgICBDTElFTlRfRVJST1JfU1RBUlQ6IDQwMCxcbiAgICBTRVJWRVJfRVJST1JfU1RBUlQ6IDUwMFxufTtcbkFuYWx5dGljc01hbmFnZXIuTUFYX0JBQ0tPRkZfQVRURU1QVFMgPSA1O1xuQW5hbHl0aWNzTWFuYWdlci5CQUNLT0ZGX01VTFRJUExJRVIgPSAyO1xuQW5hbHl0aWNzTWFuYWdlci5GVUxMX01PREVfRklFTERTID0gW1xuICAgICd1c2VyX2lkJyxcbiAgICAndGdfaWQnLFxuICAgICdsb2NhbGUnLFxuICAgICd0bWFfaXNfcHJlbWl1bSdcbl07XG5cbi8qKlxuICogQSBjb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBFdmVudERpc3BhdGNoZXIgdGhhdCBkaXNwYXRjaGVzIGV2ZW50cyB0byB0aGUgYnJvd3NlciB3aW5kb3cuXG4gKi9cbmNsYXNzIEJyb3dzZXJFdmVudERpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdpbmRvdyBvYmplY3QsIHBvc3NpYmx5IHVuZGVmaW5lZCBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoZXMgYW4gZXZlbnQgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBhbmQgZGV0YWlscyB0byB0aGUgYnJvd3NlciB3aW5kb3cuXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBkaXNwYXRjaC5cbiAgICAgKiBAcGFyYW0gZXZlbnREZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIGV2ZW50IHRvIGRpc3BhdGNoLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGV2ZW50IGhhcyBiZWVuIGRpc3BhdGNoZWQuXG4gICAgICovXG4gICAgZGlzcGF0Y2hFdmVudChldmVudE5hbWUsIGV2ZW50RGV0YWlscykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7IGRldGFpbDogZXZlbnREZXRhaWxzIH0pO1xuICAgICAgICAgICAgKF9hID0gdGhpcy53aW5kb3cpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGJyb3dzZXIgd2luZG93LlxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvci5cbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgdG8gYWRkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBsaXN0ZW5lci5cbiAgICAgKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyB0aGUgbGlzdGVuZXIuXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLndpbmRvdykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKF9hID0gdGhpcy53aW5kb3cpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBidWlsZFZlcnNpb25JbmZvKHZlcnNpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAnQHRvbmNvbm5lY3Qvc2RrJzogdmVyc2lvbi50b25fY29ubmVjdF9zZGtfbGliIHx8ICcnLFxuICAgICAgICAnQHRvbmNvbm5lY3QvdWknOiB2ZXJzaW9uLnRvbl9jb25uZWN0X3VpX2xpYiB8fCAnJ1xuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZFRvbkNvbm5lY3RFdmVudChkZXRhaWwpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgIHJldHVybiB7XG4gICAgICAgIHZlcnNpb25zOiBidWlsZFZlcnNpb25JbmZvKGRldGFpbC5jdXN0b21fZGF0YSksXG4gICAgICAgIG5ldHdvcmtfaWQ6IChfYSA9IGRldGFpbC5jdXN0b21fZGF0YS5jaGFpbl9pZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycsXG4gICAgICAgIGNsaWVudF9pZDogKF9iID0gZGV0YWlsLmN1c3RvbV9kYXRhLmNsaWVudF9pZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycsXG4gICAgICAgIHdhbGxldF9pZDogKF9jID0gZGV0YWlsLmN1c3RvbV9kYXRhLndhbGxldF9pZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJycsXG4gICAgICAgIHdhbGxldF9hZGRyZXNzOiAoX2QgPSBkZXRhaWwud2FsbGV0X2FkZHJlc3MpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICcnLFxuICAgICAgICB3YWxsZXRfYXBwX25hbWU6IChfZSA9IGRldGFpbC53YWxsZXRfdHlwZSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogJycsXG4gICAgICAgIHdhbGxldF9hcHBfdmVyc2lvbjogKF9mID0gZGV0YWlsLndhbGxldF92ZXJzaW9uKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiAnJyxcbiAgICAgICAgd2FsbGV0X3N0YXRlX2luaXQ6IChfZyA9IGRldGFpbC53YWxsZXRfc3RhdGVfaW5pdCkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogJycsXG4gICAgICAgIHRyYWNlX2lkOiAoX2ggPSBkZXRhaWwudHJhY2VfaWQpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IHVuZGVmaW5lZFxuICAgIH07XG59XG5mdW5jdGlvbiBiaW5kRXZlbnRzVG8oZXZlbnREaXNwYXRjaGVyLCBhbmFseXRpY3MpIHtcbiAgICBldmVudERpc3BhdGNoZXIuYWRkRXZlbnRMaXN0ZW5lcigndG9uLWNvbm5lY3QtdWktd2FsbGV0LW1vZGFsLW9wZW5lZCcsIGV2ZW50ID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IGRldGFpbCB9ID0gZXZlbnQ7XG4gICAgICAgIGFuYWx5dGljcy5lbWl0Q29ubmVjdGlvblN0YXJ0ZWQoe1xuICAgICAgICAgICAgY2xpZW50X2lkOiBkZXRhaWwuY2xpZW50X2lkIHx8ICcnLFxuICAgICAgICAgICAgdmVyc2lvbnM6IGJ1aWxkVmVyc2lvbkluZm8oZGV0YWlsLmN1c3RvbV9kYXRhKSxcbiAgICAgICAgICAgIG1haW5fc2NyZWVuOiBkZXRhaWwudmlzaWJsZV93YWxsZXRzLFxuICAgICAgICAgICAgdHJhY2VfaWQ6IChfYSA9IGRldGFpbC50cmFjZV9pZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGV2ZW50RGlzcGF0Y2hlci5hZGRFdmVudExpc3RlbmVyKCd0b24tY29ubmVjdC11aS1zZWxlY3RlZC13YWxsZXQnLCBldmVudCA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHsgZGV0YWlsIH0gPSBldmVudDtcbiAgICAgICAgYW5hbHl0aWNzLmVtaXRDb25uZWN0aW9uU2VsZWN0ZWRXYWxsZXQoe1xuICAgICAgICAgICAgY2xpZW50X2lkOiBkZXRhaWwuY2xpZW50X2lkIHx8ICcnLFxuICAgICAgICAgICAgdmVyc2lvbnM6IGJ1aWxkVmVyc2lvbkluZm8oZGV0YWlsLmN1c3RvbV9kYXRhKSxcbiAgICAgICAgICAgIG1haW5fc2NyZWVuOiBkZXRhaWwudmlzaWJsZV93YWxsZXRzLFxuICAgICAgICAgICAgd2FsbGV0c19tZW51OiBkZXRhaWwud2FsbGV0c19tZW51LFxuICAgICAgICAgICAgdHJhY2VfaWQ6IChfYSA9IGRldGFpbC50cmFjZV9pZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgd2FsbGV0X2FwcF9uYW1lOiAoX2IgPSBkZXRhaWwud2FsbGV0X3R5cGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLFxuICAgICAgICAgICAgd2FsbGV0X3JlZGlyZWN0X21ldGhvZDogZGV0YWlsLndhbGxldF9yZWRpcmVjdF9tZXRob2QsXG4gICAgICAgICAgICB3YWxsZXRfcmVkaXJlY3RfbGluazogZGV0YWlsLndhbGxldF9yZWRpcmVjdF9saW5rXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGV2ZW50RGlzcGF0Y2hlci5hZGRFdmVudExpc3RlbmVyKCd0b24tY29ubmVjdC1jb25uZWN0aW9uLWNvbXBsZXRlZCcsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgeyBkZXRhaWwgfSA9IGV2ZW50O1xuICAgICAgICBhbmFseXRpY3MuZW1pdENvbm5lY3Rpb25Db21wbGV0ZWQoYnVpbGRUb25Db25uZWN0RXZlbnQoZGV0YWlsKSk7XG4gICAgfSk7XG4gICAgZXZlbnREaXNwYXRjaGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3Rvbi1jb25uZWN0LWNvbm5lY3Rpb24tZXJyb3InLCBldmVudCA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHsgZGV0YWlsIH0gPSBldmVudDtcbiAgICAgICAgYW5hbHl0aWNzLmVtaXRDb25uZWN0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgY2xpZW50X2lkOiBkZXRhaWwuY3VzdG9tX2RhdGEuY2xpZW50X2lkIHx8ICcnLFxuICAgICAgICAgICAgd2FsbGV0X2lkOiBkZXRhaWwuY3VzdG9tX2RhdGEud2FsbGV0X2lkIHx8ICcnLFxuICAgICAgICAgICAgZXJyb3JfY29kZTogKF9hID0gZGV0YWlsLmVycm9yX2NvZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDAsXG4gICAgICAgICAgICBlcnJvcl9tZXNzYWdlOiBkZXRhaWwuZXJyb3JfbWVzc2FnZSxcbiAgICAgICAgICAgIHRyYWNlX2lkOiAoX2IgPSBkZXRhaWwudHJhY2VfaWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBldmVudERpc3BhdGNoZXIuYWRkRXZlbnRMaXN0ZW5lcigndG9uLWNvbm5lY3QtZGlzY29ubmVjdGlvbicsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgeyBkZXRhaWwgfSA9IGV2ZW50O1xuICAgICAgICBhbmFseXRpY3MuZW1pdERpc2Nvbm5lY3Rpb24oYnVpbGRUb25Db25uZWN0RXZlbnQoZGV0YWlsKSk7XG4gICAgfSk7XG4gICAgZXZlbnREaXNwYXRjaGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3Rvbi1jb25uZWN0LXRyYW5zYWN0aW9uLXNlbnQtZm9yLXNpZ25hdHVyZScsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgeyBkZXRhaWwgfSA9IGV2ZW50O1xuICAgICAgICBhbmFseXRpY3MuZW1pdFRyYW5zYWN0aW9uU2VudChidWlsZFRvbkNvbm5lY3RFdmVudChkZXRhaWwpKTtcbiAgICB9KTtcbiAgICBldmVudERpc3BhdGNoZXIuYWRkRXZlbnRMaXN0ZW5lcigndG9uLWNvbm5lY3QtdHJhbnNhY3Rpb24tc2lnbmVkJywgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7IGRldGFpbCB9ID0gZXZlbnQ7XG4gICAgICAgIGFuYWx5dGljcy5lbWl0VHJhbnNhY3Rpb25TaWduZWQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZFRvbkNvbm5lY3RFdmVudChkZXRhaWwpKSwgeyBzaWduZWRfYm9jOiBldmVudC5kZXRhaWwuc2lnbmVkX3RyYW5zYWN0aW9uIH0pKTtcbiAgICB9KTtcbiAgICBldmVudERpc3BhdGNoZXIuYWRkRXZlbnRMaXN0ZW5lcigndG9uLWNvbm5lY3QtdHJhbnNhY3Rpb24tc2lnbmluZy1mYWlsZWQnLCBldmVudCA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBkZXRhaWwgfSA9IGV2ZW50O1xuICAgICAgICBhbmFseXRpY3MuZW1pdFRyYW5zYWN0aW9uU2lnbmluZ0ZhaWxlZChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkVG9uQ29ubmVjdEV2ZW50KGRldGFpbCkpLCB7IHZhbGlkX3VudGlsOiBOdW1iZXIoZGV0YWlsLnZhbGlkX3VudGlsKSwgbWVzc2FnZXM6IGRldGFpbC5tZXNzYWdlcy5tYXAobWVzc2FnZSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiAoX2EgPSBtZXNzYWdlLmFkZHJlc3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnLFxuICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IChfYiA9IG1lc3NhZ2UuYW1vdW50KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogKF9jID0gbWVzc2FnZS5wYXlsb2FkKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVfaW5pdDogKF9kID0gbWVzc2FnZS5zdGF0ZV9pbml0KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAnJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSksIGVycm9yX21lc3NhZ2U6IGRldGFpbC5lcnJvcl9tZXNzYWdlLCBlcnJvcl9jb2RlOiAoX2EgPSBkZXRhaWwuZXJyb3JfY29kZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCB9KSk7XG4gICAgfSk7XG4gICAgZXZlbnREaXNwYXRjaGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3Rvbi1jb25uZWN0LXNpZ24tZGF0YS1yZXF1ZXN0LWluaXRpYXRlZCcsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgeyBkZXRhaWwgfSA9IGV2ZW50O1xuICAgICAgICBhbmFseXRpY3MgPT09IG51bGwgfHwgYW5hbHl0aWNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbmFseXRpY3MuZW1pdFNpZ25EYXRhUmVxdWVzdEluaXRpYXRlZChidWlsZFRvbkNvbm5lY3RFdmVudChkZXRhaWwpKTtcbiAgICB9KTtcbiAgICBldmVudERpc3BhdGNoZXIuYWRkRXZlbnRMaXN0ZW5lcigndG9uLWNvbm5lY3Qtc2lnbi1kYXRhLXJlcXVlc3QtY29tcGxldGVkJywgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7IGRldGFpbCB9ID0gZXZlbnQ7XG4gICAgICAgIGFuYWx5dGljcyA9PT0gbnVsbCB8fCBhbmFseXRpY3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFuYWx5dGljcy5lbWl0U2lnbkRhdGFSZXF1ZXN0Q29tcGxldGVkKGJ1aWxkVG9uQ29ubmVjdEV2ZW50KGRldGFpbCkpO1xuICAgIH0pO1xuICAgIGV2ZW50RGlzcGF0Y2hlci5hZGRFdmVudExpc3RlbmVyKCd0b24tY29ubmVjdC1zaWduLWRhdGEtcmVxdWVzdC1mYWlsZWQnLCBldmVudCA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBkZXRhaWwgfSA9IGV2ZW50O1xuICAgICAgICBsZXQgc2lnbkRhdGFWYWx1ZSA9ICcnO1xuICAgICAgICBsZXQgc2lnbkRhdGFTY2hlbWEgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChkZXRhaWwuZGF0YS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHNpZ25EYXRhVmFsdWUgPSBkZXRhaWwuZGF0YS50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXRhaWwuZGF0YS50eXBlID09PSAnY2VsbCcpIHtcbiAgICAgICAgICAgIHNpZ25EYXRhVmFsdWUgPSBkZXRhaWwuZGF0YS5jZWxsO1xuICAgICAgICAgICAgc2lnbkRhdGFTY2hlbWEgPSBkZXRhaWwuZGF0YS5zY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRldGFpbC5kYXRhLnR5cGUgPT09ICdiaW5hcnknKSB7XG4gICAgICAgICAgICBzaWduRGF0YVZhbHVlID0gZGV0YWlsLmRhdGEuYnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgYW5hbHl0aWNzID09PSBudWxsIHx8IGFuYWx5dGljcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5hbHl0aWNzLmVtaXRTaWduRGF0YVJlcXVlc3RGYWlsZWQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZFRvbkNvbm5lY3RFdmVudChkZXRhaWwpKSwgeyBzaWduX2RhdGFfdHlwZTogZGV0YWlsLmRhdGEudHlwZSwgc2lnbl9kYXRhX3ZhbHVlOiBzaWduRGF0YVZhbHVlLCBzaWduX2RhdGFfc2NoZW1hOiBzaWduRGF0YVNjaGVtYSwgZXJyb3JfY29kZTogKF9hID0gZGV0YWlsLmVycm9yX2NvZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDAsIGVycm9yX21lc3NhZ2U6IGRldGFpbC5lcnJvcl9tZXNzYWdlIH0pKTtcbiAgICB9KTtcbn1cblxuY2xhc3MgRGVmYXVsdEVudmlyb25tZW50IHtcbiAgICBnZXRDbGllbnRFbnZpcm9ubWVudCgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBnZXRCcm93c2VyKCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGdldExvY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBnZXRQbGF0Zm9ybSgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBnZXRUZWxlZ3JhbVVzZXIoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG5jb25zdCBzdGF0ZSA9IHt9O1xuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgV2FsbGV0Q29ubmVjdCBpbnRlZ3JhdGlvbi5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIG9uY2UgYmVmb3JlIHVzaW5nIFdhbGxldENvbm5lY3QgZmVhdHVyZXMuXG4gKiBBIHNlY29uZCBjYWxsIHdpbGwgdGhyb3cgYW4gZXJyb3IgdG8gcHJldmVudCBhY2NpZGVudGFsIHJlLWluaXRpYWxpemF0aW9uLlxuICpcbiAqIEBwYXJhbSBVbml2ZXJzYWxDb25uZWN0b3JDbHMgLSBBIFVuaXZlcnNhbENvbm5lY3RvciBjbGFzcyBpbXBvcnRlZCBmcm9tICdAcmVvd24vYXBwa2l0LXVuaXZlcnNhbC1jb25uZWN0b3InXG4gKiBAcGFyYW0ge1dhbGxldENvbm5lY3RPcHRpb25zfSB3YWxsZXRDb25uZWN0T3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyB1c2VkIGZvciBpbml0aWFsaXppbmcgV2FsbGV0Q29ubmVjdC5cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBVbml2ZXJzYWxDb25uZWN0b3IgfSBmcm9tICdAcmVvd24vYXBwa2l0LXVuaXZlcnNhbC1jb25uZWN0b3InO1xuICpcbiAqIGluaXRpYWxpemVXYWxsZXRDb25uZWN0KFVuaXZlcnNhbENvbm5lY3Rvciwge1xuICogICAgIHByb2plY3RJZDogJ2FiY2QxMjM0YWJjZDEyMzRhYmNkMTIzNGFiY2QxMjM0JyxcbiAqICAgICBtZXRhZGF0YToge1xuICogICAgICAgICBuYW1lOiAnRGVtbyBEQXBwJyxcbiAqICAgICAgICAgaWNvbnM6IFtcbiAqICAgICAgICAgICAgICdodHRwczovL2V4YW1wbGUuY29tL215LWljb24ucG5nJ1xuICogICAgICAgICBdLFxuICogICAgICAgICB1cmw6IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXG4gKiAgICAgICAgIGRlc2NyaXB0aW9uOiAnRGVtbyBEQXBwJ1xuICogICAgIH1cbiAqIH0pO1xuICovXG5mdW5jdGlvbiBpbml0aWFsaXplV2FsbGV0Q29ubmVjdChVbml2ZXJzYWxDb25uZWN0b3JDbHMsIHdhbGxldENvbm5lY3RPcHRpb25zKSB7XG4gICAgaWYgKChzdGF0ZSA9PT0gbnVsbCB8fCBzdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhdGUud2FsbGV0Q29ubmVjdE9wdGlvbnMpICE9PSB1bmRlZmluZWQgfHwgKHN0YXRlID09PSBudWxsIHx8IHN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGF0ZS5Vbml2ZXJzYWxDb25uZWN0b3JDbHMpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignV2FsbGV0IENvbm5lY3QgYWxyZWFkeSBpbml0aWFsaXplZC4nKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBVbml2ZXJzYWxDb25uZWN0b3JDbHMgIT09ICdmdW5jdGlvbicgfHwgISgnaW5pdCcgaW4gVW5pdmVyc2FsQ29ubmVjdG9yQ2xzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdJbml0aWFsaXplIFVuaXZlcnNhbENvbm5lY3RvckNscyBtdXN0IGJlIHNldCcpO1xuICAgIH1cbiAgICBzdGF0ZS5Vbml2ZXJzYWxDb25uZWN0b3JDbHMgPSBVbml2ZXJzYWxDb25uZWN0b3JDbHM7XG4gICAgc3RhdGUud2FsbGV0Q29ubmVjdE9wdGlvbnMgPSB3YWxsZXRDb25uZWN0T3B0aW9ucztcbn1cbmZ1bmN0aW9uIGlzV2FsbGV0Q29ubmVjdEluaXRpYWxpemVkKCkge1xuICAgIHJldHVybiBzdGF0ZS5Vbml2ZXJzYWxDb25uZWN0b3JDbHMgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZS53YWxsZXRDb25uZWN0T3B0aW9ucyAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0VW5pdmVyc2FsQ29ubmVjdG9yKCkge1xuICAgIGlmIChzdGF0ZS5Vbml2ZXJzYWxDb25uZWN0b3JDbHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdXYWxsZXQgQ29ubmVjdCBpcyBub3QgaW5pdGlhbGl6ZWQuJyk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5Vbml2ZXJzYWxDb25uZWN0b3JDbHM7XG59XG5mdW5jdGlvbiBnZXRXYWxsZXRDb25uZWN0T3B0aW9ucygpIHtcbiAgICBpZiAoc3RhdGUud2FsbGV0Q29ubmVjdE9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdXYWxsZXQgQ29ubmVjdCBpcyBub3QgaW5pdGlhbGl6ZWQuJyk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS53YWxsZXRDb25uZWN0T3B0aW9ucztcbn1cblxuY29uc3QgREVGQVVMVF9SRVFVRVNUX0lEID0gJzAnO1xuY29uc3QgREVGQVVMVF9FVkVOVF9JRCA9IDA7XG5jbGFzcyBXYWxsZXRDb25uZWN0UHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25TdG9yYWdlKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblN0b3JhZ2UgPSBjb25uZWN0aW9uU3RvcmFnZTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2luamVjdGVkJztcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jb25uZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHsgcHJvamVjdElkLCBtZXRhZGF0YSB9ID0gZ2V0V2FsbGV0Q29ubmVjdE9wdGlvbnMoKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAgICAgICBuZXR3b3JrczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlOiAndG9uJyxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IC0yMzksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5OYW1lc3BhY2U6ICd0b24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhaXBOZXR3b3JrSWQ6ICd0b246LTIzOScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1RPTicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlQ3VycmVuY3k6IHsgbmFtZTogJ1RPTicsIHN5bWJvbDogJ1RPTicsIGRlY2ltYWxzOiA5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnBjVXJsczogeyBkZWZhdWx0OiB7IGh0dHA6IFtdIH0gfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogLTMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5OYW1lc3BhY2U6ICd0b24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhaXBOZXR3b3JrSWQ6ICd0b246LTMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdUT04nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZUN1cnJlbmN5OiB7IG5hbWU6ICdUT04nLCBzeW1ib2w6ICdUT04nLCBkZWNpbWFsczogOSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJwY1VybHM6IHsgZGVmYXVsdDogeyBodHRwOiBbXSB9IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kczogWyd0b25fc2VuZE1lc3NhZ2UnLCAndG9uX3NpZ25EYXRhJ10sXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50czogW11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcHJvamVjdElkLFxuICAgICAgICAgICAgbWV0YWRhdGFcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdG9yYWdlKHN0b3JhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2FsbGV0Q29ubmVjdFByb3ZpZGVyKHN0b3JhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25uZWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RvciA9IHlpZWxkIGdldFVuaXZlcnNhbENvbm5lY3RvcigpLmluaXQodGhpcy5jb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdG9yO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHRyYWNlSWQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVVVJRHY3KCk7XG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IGNyZWF0ZUFib3J0Q29udHJvbGxlcihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsKTtcbiAgICAgICAgKF9iID0gdGhpcy5hYm9ydENvbnRyb2xsZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydCgpO1xuICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IGFib3J0Q29udHJvbGxlcjtcbiAgICAgICAgdm9pZCB0aGlzLl9jb25uZWN0KG1lc3NhZ2UsIHtcbiAgICAgICAgICAgIHRyYWNlSWQsXG4gICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICBhYm9ydENvbnRyb2xsZXJcbiAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4gbG9nRGVidWcoJ1dhbGxldENvbm5lY3QgY29ubmVjdCB1bmV4cGVjdGVkIGVycm9yJywgZXJyb3IpKTtcbiAgICB9XG4gICAgX2Nvbm5lY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RvciA9IHlpZWxkIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgaWYgKChfYSA9IG9wdGlvbnMuc2lnbmFsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdXYWxsZXRDb25uZWN0IGNvbm5lY3QgYWJvcnRlZCBiZWZvcmUgc3RhcnQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyQWJvcnRDb250cm9sbGVyKG9wdGlvbnMuYWJvcnRDb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b25Qcm9vZiA9IG1lc3NhZ2UuaXRlbXMuZmluZChpdGVtID0+IGl0ZW0ubmFtZSA9PT0gJ3Rvbl9wcm9vZicpO1xuICAgICAgICAgICAgY29uc3QgYXV0aGVudGljYXRpb24gPSB0b25Qcm9vZlxuICAgICAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IG5ldyBVUkwodGhpcy5jb25maWcubWV0YWRhdGEudXJsKS5ob3N0bmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluczogWyd0b246LTIzOSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9uY2U6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJpOiAndG9uX3Byb29mJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudDogdG9uUHJvb2YucGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbG9nRGVidWcoJ0Nvbm5lY3RpbmcgdGhyb3VnaCB0aGlzLmNvbm5lY3Rvci5jb25uZWN0Jyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNvbm5lY3Rvci5jb25uZWN0KHsgYXV0aGVudGljYXRpb24gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoKF9iID0gb3B0aW9ucy5zaWduYWwpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdXYWxsZXRDb25uZWN0IGNvbm5lY3QgYWJvcnRlZCB2aWEgc2lnbmFsJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJBYm9ydENvbnRyb2xsZXIob3B0aW9ucy5hYm9ydENvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdXYWxsZXRDb25uZWN0IGNvbm5lY3QgZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBERUZBVUxUX0VWRU5UX0lELFxuICAgICAgICAgICAgICAgICAgICBldmVudDogJ2Nvbm5lY3RfZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZUlkOiBvcHRpb25zLnRyYWNlSWQsXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IENPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVMuVVNFUl9SRUpFQ1RTX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ1VzZXIgZGVjbGluZWQgdGhlIGNvbm5lY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdXYWxsZXRDb25uZWN0IGNvbm5lY3QgcmVzcG9uc2U6JywgZXZlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckFib3J0Q29udHJvbGxlcihvcHRpb25zLmFib3J0Q29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nRGVidWcoJ0Nvbm5lY3RlZCB0aHJvdWdoIHRoaXMuY29ubmVjdG9yLmNvbm5lY3QnKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5vbkNvbm5lY3QoY29ubmVjdG9yLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGluY2x1ZGVUb25Qcm9vZjogdHJ1ZSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnV2FsbGV0Q29ubmVjdCBvbkNvbm5lY3QgZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5kaXNjb25uZWN0KHsgdHJhY2VJZDogb3B0aW9ucy50cmFjZUlkLCBzaWduYWw6IG9wdGlvbnMuc2lnbmFsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckFib3J0Q29udHJvbGxlcihvcHRpb25zLmFib3J0Q29udHJvbGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXN0b3JlQ29ubmVjdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc3QgdHJhY2VJZCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFjZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBVVUlEdjcoKTtcbiAgICAgICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IGNyZWF0ZUFib3J0Q29udHJvbGxlcihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsKTtcbiAgICAgICAgICAgIChfYiA9IHRoaXMuYWJvcnRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gYWJvcnRDb250cm9sbGVyO1xuICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ1Jlc3RvcmluZyBXYWxsZXRDb25uZWN0IGNvbm5lY3Rpb24uLi4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZWRDb25uZWN0aW9uID0geWllbGQgdGhpcy5jb25uZWN0aW9uU3RvcmFnZS5nZXRXYWxsZXRDb25uZWN0Q29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmICghc3RvcmVkQ29ubmVjdGlvbiB8fCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0b3IgPSB5aWVsZCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5vbkNvbm5lY3QoY29ubmVjdG9yLCB7XG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGVUb25Qcm9vZjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlSWQsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdXYWxsZXRDb25uZWN0IHN1Y2Nlc3NmdWxseSByZXN0b3JlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdXYWxsZXRDb25uZWN0IHJlc3RvcmUgZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5kaXNjb25uZWN0KHsgdHJhY2VJZCwgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckFib3J0Q29udHJvbGxlcihhYm9ydENvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvc2VDb25uZWN0aW9uKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuYWJvcnRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWJvcnQoKTtcbiAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZvaWQgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IGNyZWF0ZUFib3J0Q29udHJvbGxlcihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsKTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuYWJvcnRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWJvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gYWJvcnRDb250cm9sbGVyO1xuICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0aW9uU3RvcmFnZS5yZW1vdmVDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkICgoX2IgPSB0aGlzLmNvbm5lY3RvcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc2Nvbm5lY3QoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnV2FsbGV0Q29ubmVjdCBkaXNjb25uZWN0IGVycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckFib3J0Q29udHJvbGxlcihhYm9ydENvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZFJlcXVlc3QocmVxdWVzdCwgb3B0aW9uc09yT25SZXF1ZXN0U2VudCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3Rvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ1dhbGxldCBDb25uZWN0IG5vdCBpbml0aWFsaXplZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlcXVlc3RTZW50ID0gb3B0aW9uc09yT25SZXF1ZXN0U2VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub25SZXF1ZXN0U2VudCA9IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IG51bGwgfHwgb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uc09yT25SZXF1ZXN0U2VudC5vblJlcXVlc3RTZW50O1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsID0gb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gbnVsbCB8fCBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zT3JPblJlcXVlc3RTZW50LnNpZ25hbDtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmF0dGVtcHRzID0gb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gbnVsbCB8fCBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zT3JPblJlcXVlc3RTZW50LmF0dGVtcHRzO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudHJhY2VJZCA9IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IG51bGwgfHwgb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uc09yT25SZXF1ZXN0U2VudC50cmFjZUlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9hID0gb3B0aW9ucy50cmFjZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAob3B0aW9ucy50cmFjZUlkID0gVVVJRHY3KCkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoKF9iID0gb3B0aW9ucy5zaWduYWwpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ1dhbGxldENvbm5lY3QgcmVxdWVzdCBhYm9ydGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdTZW5kIHdhbGxldC1jb25uZWN0IHJlcXVlc3Q6JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KSwgeyBpZDogREVGQVVMVF9SRVFVRVNUX0lEIH0pKTtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09ICdzZW5kVHJhbnNhY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IF9lID0gSlNPTi5wYXJzZShyZXF1ZXN0LnBhcmFtc1swXSksIHsgbmV0d29yayB9ID0gX2UsIHNlbmRUcmFuc2FjdGlvblBheWxvYWQgPSBfX3Jlc3QoX2UsIFtcIm5ldHdvcmtcIl0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5jb25uZWN0b3IucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICd0b25fc2VuZE1lc3NhZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBzZW5kVHJhbnNhY3Rpb25QYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgIH0sIGB0b246JHtuZXR3b3JrfWApO1xuICAgICAgICAgICAgICAgICAgICAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25SZXF1ZXN0U2VudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9ICh5aWVsZCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoJ1dhbGxldCBtZXNzYWdlIHJlY2VpdmVkOicsIHsgcmVzdWx0LCBpZDogREVGQVVMVF9SRVFVRVNUX0lEIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IERFRkFVTFRfUkVRVUVTVF9JRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlSWQ6IG9wdGlvbnMudHJhY2VJZFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ3NpZ25EYXRhJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBfZiA9IEpTT04ucGFyc2UocmVxdWVzdC5wYXJhbXNbMF0pLCB7IG5ldHdvcmsgfSA9IF9mLCBzaWduRGF0YVBheWxvYWQgPSBfX3Jlc3QoX2YsIFtcIm5ldHdvcmtcIl0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5jb25uZWN0b3IucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICd0b25fc2lnbkRhdGEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBzaWduRGF0YVBheWxvYWRcbiAgICAgICAgICAgICAgICAgICAgfSwgYHRvbjoke25ldHdvcmt9YCk7XG4gICAgICAgICAgICAgICAgICAgIChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vblJlcXVlc3RTZW50KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gKHlpZWxkIHByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnV2FsbGV0IG1lc3NhZ2UgcmVjZWl2ZWQ6JywgeyByZXN1bHQsIGlkOiBERUZBVUxUX1JFUVVFU1RfSUQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdCwgdHJhY2VJZDogb3B0aW9ucy50cmFjZUlkLCBpZDogREVGQVVMVF9SRVFVRVNUX0lEIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcXVlc3QubWV0aG9kID09PSAnZGlzY29ubmVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBERUZBVUxUX1JFUVVFU1RfSUQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZUlkOiBvcHRpb25zLnRyYWNlSWRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnV2FsbGV0Q29ubmVjdCByZXF1ZXN0IGVycm9yJywgZXJyb3IsIGVycm9yLnN0YWNrKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoeWllbGQgdGhpcy5oYW5kbGVXYWxsZXRDb25uZWN0RXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VJZDogb3B0aW9ucy50cmFjZUlkXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdXYWxsZXQgbWVzc2FnZSByZWNlaXZlZDonLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBERUZBVUxUX1JFUVVFU1RfSUQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHsgY29kZTogRElTQ09OTkVDVF9FUlJPUl9DT0RFUy5VTktOT1dOX0VSUk9SLCBtZXNzYWdlOiAnTm90IGltcGxlbWVudGVkLicgfSxcbiAgICAgICAgICAgICAgICB0cmFjZUlkOiBvcHRpb25zLnRyYWNlSWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVXYWxsZXRDb25uZWN0RXJyb3IoZXJyb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IFN0cmluZygnbWVzc2FnZScgaW4gZXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ21zZycgaW4gZXJyb3IgPyBlcnJvci5tc2cgOiBlcnJvcik7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygncmVqZWN0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBERUZBVUxUX1JFUVVFU1RfSUQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZUlkOiBvcHRpb25zLnRyYWNlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFNFTkRfVFJBTlNBQ1RJT05fRVJST1JfQ09ERVMuVVNFUl9SRUpFQ1RTX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygndG9udmFsaWRhdGlvbmVycm9yJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBERUZBVUxUX1JFUVVFU1RfSUQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZUlkOiBvcHRpb25zLnRyYWNlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFNFTkRfVFJBTlNBQ1RJT05fRVJST1JfQ09ERVMuQkFEX1JFUVVFU1RfRVJST1IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpZDogREVGQVVMVF9SRVFVRVNUX0lELFxuICAgICAgICAgICAgICAgICAgICB0cmFjZUlkOiBvcHRpb25zLnRyYWNlSWQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTLlVOS05PV05fRVJST1IsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZDogREVGQVVMVF9SRVFVRVNUX0lELFxuICAgICAgICAgICAgICAgIHRyYWNlSWQ6IG9wdGlvbnMudHJhY2VJZCxcbiAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTLlVOS05PV05fRVJST1IsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFN0cmluZyhlcnJvcilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGlzdGVuKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4gKHRoaXMubGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMuZmlsdGVyKGxpc3RlbmVyID0+IGxpc3RlbmVyICE9PSBjYWxsYmFjaykpO1xuICAgIH1cbiAgICBidWlsZFRvblByb29mKGNvbm5lY3Rvcikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgYXV0aCA9IChfYSA9IGNvbm5lY3Rvci5wcm92aWRlci5zZXNzaW9uLmF1dGhlbnRpY2F0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF07XG4gICAgICAgIGNvbnN0IGlhdCA9IChfYiA9IGF1dGggPT09IG51bGwgfHwgYXV0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXV0aC5wKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaWF0O1xuICAgICAgICBjb25zdCBzdGF0ZW1lbnQgPSAoX2MgPSBhdXRoID09PSBudWxsIHx8IGF1dGggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF1dGgucCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnN0YXRlbWVudDtcbiAgICAgICAgaWYgKCFpYXQgfHwgIXN0YXRlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IGF1dGgucC5kb21haW47XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiAndG9uX3Byb29mJyxcbiAgICAgICAgICAgIHByb29mOiB7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBNYXRoLmZsb29yKG5ldyBEYXRlKGlhdCkuZ2V0VGltZSgpIC8gMTAwMCksXG4gICAgICAgICAgICAgICAgZG9tYWluOiB7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aEJ5dGVzOiBkb21haW4ubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZG9tYWluXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBzdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBhdXRoLnMuc1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBvbkNvbm5lY3QoY29ubmVjdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICBpZiAoKF9hID0gb3B0aW9ucy5zaWduYWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ1dhbGxldENvbm5lY3Qgb25Db25uZWN0IGFib3J0ZWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gY29ubmVjdG9yLnByb3ZpZGVyLnNlc3Npb247XG4gICAgICAgICAgICBjb25zdCB0b25OYW1lc3BhY2UgPSBzZXNzaW9uLm5hbWVzcGFjZXNbJ3RvbiddO1xuICAgICAgICAgICAgaWYgKCEoKF9iID0gdG9uTmFtZXNwYWNlID09PSBudWxsIHx8IHRvbk5hbWVzcGFjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9uTmFtZXNwYWNlLmFjY291bnRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbMF0pKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5kaXNjb25uZWN0V2l0aEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VJZDogb3B0aW9ucy50cmFjZUlkLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTLkJBRF9SRVFVRVNUX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQ29ubmVjdGlvbiBlcnJvci4gTm8gVE9OIGFjY291bnRzIGNvbm5lY3RlZC4nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWNjb3VudCA9IHRvbk5hbWVzcGFjZS5hY2NvdW50c1swXTtcbiAgICAgICAgICAgIGNvbnN0IFssIG5ldHdvcmssIGFkZHJlc3NdID0gYWNjb3VudC5zcGxpdCgnOicsIDMpO1xuICAgICAgICAgICAgY29uc3QgcHVibGljS2V5ID0gKF9jID0gc2Vzc2lvbi5zZXNzaW9uUHJvcGVydGllcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvbl9nZXRQdWJsaWNLZXk7XG4gICAgICAgICAgICBpZiAoIXB1YmxpY0tleSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZGlzY29ubmVjdFdpdGhFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlSWQ6IG9wdGlvbnMudHJhY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFUy5CQURfUkVRVUVTVF9FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0Nvbm5lY3Rpb24gZXJyb3IuIE5vIHNlc3Npb25Qcm9wZXJ0aWVzLnRvbl9nZXRQdWJsaWNLZXkgcHJvdmlkZWQuJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXRlSW5pdCA9IChfZCA9IHNlc3Npb24uc2Vzc2lvblByb3BlcnRpZXMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC50b25fZ2V0U3RhdGVJbml0O1xuICAgICAgICAgICAgaWYgKCFzdGF0ZUluaXQpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmRpc2Nvbm5lY3RXaXRoRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICB0cmFjZUlkOiBvcHRpb25zLnRyYWNlSWQsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IENPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVMuQkFEX1JFUVVFU1RfRVJST1IsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdDb25uZWN0aW9uIGVycm9yLiBObyBzZXNzaW9uUHJvcGVydGllcy50b25fZ2V0U3RhdGVJbml0IHByb3ZpZGVkLidcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25uZWN0b3IucHJvdmlkZXIub25jZSgnc2Vzc2lvbl9kZWxldGUnLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0aW9uU3RvcmFnZS5yZW1vdmVDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6ICdkaXNjb25uZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlSWQ6IFVVSUR2NygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDoge31cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoJ1dhbGxldCBtZXNzYWdlIHJlY2VpdmVkOicsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnRXJyb3Igd2hpbGUgZGVsZXRpbmcgc2Vzc2lvbicsIGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgY29uc3QgdG9uUHJvb2YgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmluY2x1ZGVUb25Qcm9vZikgPyB0aGlzLmJ1aWxkVG9uUHJvb2YoY29ubmVjdG9yKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFkZHJlc3MgPSBpc1ZhbGlkVXNlckZyaWVuZGx5QWRkcmVzcyhhZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gdG9SYXdBZGRyZXNzKHBhcnNlVXNlckZyaWVuZGx5QWRkcmVzcyhhZGRyZXNzKSlcbiAgICAgICAgICAgICAgICA6IGFkZHJlc3M7XG4gICAgICAgICAgICBjb25zdCBmZWF0dXJlcyA9IHRoaXMuYnVpbGRGZWF0dXJlTGlzdCh0b25OYW1lc3BhY2UubWV0aG9kcyk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0b25fYWRkcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBwYXJzZWRBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29yazogbmV0d29yayxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhbGxldFN0YXRlSW5pdDogc3RhdGVJbml0XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC4uLih0b25Qcm9vZiA/IFt0b25Qcm9vZl0gOiBbXSlcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRldmljZToge1xuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lOiAnd2FsbGV0X2Nvbm5lY3QnLFxuICAgICAgICAgICAgICAgICAgICBhcHBWZXJzaW9uOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgbWF4UHJvdG9jb2xWZXJzaW9uOiAyLFxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcyxcbiAgICAgICAgICAgICAgICAgICAgcGxhdGZvcm06ICdicm93c2VyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsb2dEZWJ1ZygnV2FsbGV0Q29ubmVjdCBjb25uZWN0IHJlc3BvbnNlOicsIHtcbiAgICAgICAgICAgICAgICBldmVudDogJ2Nvbm5lY3QnLFxuICAgICAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICAgICAgaWQ6IERFRkFVTFRfRVZFTlRfSURcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KHsgZXZlbnQ6ICdjb25uZWN0JywgcGF5bG9hZCwgdHJhY2VJZDogb3B0aW9ucy50cmFjZUlkIH0pO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5zdG9yZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJ1aWxkRmVhdHVyZUxpc3QobWV0aG9kcykge1xuICAgICAgICBjb25zdCBmZWF0dXJlcyA9IFtdO1xuICAgICAgICBpZiAobWV0aG9kcy5pbmNsdWRlcygndG9uX3NlbmRNZXNzYWdlJykpIHtcbiAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goJ1NlbmRUcmFuc2FjdGlvbicsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBtYXhNZXNzYWdlczogNCxcbiAgICAgICAgICAgICAgICBleHRyYUN1cnJlbmN5U3VwcG9ydGVkOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZHMuaW5jbHVkZXMoJ3Rvbl9zaWduRGF0YScpKSB7XG4gICAgICAgICAgICBmZWF0dXJlcy5wdXNoKHsgbmFtZTogJ1NpZ25EYXRhJywgdHlwZXM6IFsndGV4dCcsICdiaW5hcnknLCAnY2VsbCddIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmZWF0dXJlcztcbiAgICB9XG4gICAgZGlzY29ubmVjdFdpdGhFcnJvcihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgY29kZTogb3B0aW9ucy5jb2RlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMubWVzc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxvZ0RlYnVnKCdXYWxsZXRDb25uZWN0IGNvbm5lY3QgcmVzcG9uc2U6Jywge1xuICAgICAgICAgICAgICAgIGV2ZW50OiAnY29ubmVjdF9lcnJvcicsXG4gICAgICAgICAgICAgICAgaWQ6IERFRkFVTFRfRVZFTlRfSUQsXG4gICAgICAgICAgICAgICAgcGF5bG9hZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoe1xuICAgICAgICAgICAgICAgIGV2ZW50OiAnY29ubmVjdF9lcnJvcicsXG4gICAgICAgICAgICAgICAgdHJhY2VJZDogb3B0aW9ucy50cmFjZUlkLFxuICAgICAgICAgICAgICAgIHBheWxvYWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xlYXJBYm9ydENvbnRyb2xsZXIoYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmFib3J0Q29udHJvbGxlciA9PT0gYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbWl0KGV2ZW50LCBsaXN0ZW5lcnMpIHtcbiAgICAgICAgKGxpc3RlbmVycyAhPT0gbnVsbCAmJiBsaXN0ZW5lcnMgIT09IHZvaWQgMCA/IGxpc3RlbmVycyA6IHRoaXMubGlzdGVuZXJzKS5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKGV2ZW50KSk7XG4gICAgfVxuICAgIHN0b3JlQ29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblN0b3JhZ2Uuc3RvcmVDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6ICd3YWxsZXQtY29ubmVjdCdcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBUb25Db25uZWN0IHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGF2YWlsYWJsZSB3YWxsZXRzIGxpc3QuXG4gICAgICovXG4gICAgc3RhdGljIGdldFdhbGxldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndhbGxldHNMaXN0LmdldFdhbGxldHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgaWYgdGhlIHdhbGxldCBpcyBjb25uZWN0ZWQgcmlnaHQgbm93LlxuICAgICAqL1xuICAgIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93YWxsZXQgIT09IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgY29ubmVjdGVkIGFjY291bnQgb3IgbnVsbCBpZiBubyBhY2NvdW50IGlzIGNvbm5lY3RlZC5cbiAgICAgKi9cbiAgICBnZXQgYWNjb3VudCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuX3dhbGxldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY291bnQpIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgY29ubmVjdGVkIHdhbGxldCBvciBudWxsIGlmIG5vIGFjY291bnQgaXMgY29ubmVjdGVkLlxuICAgICAqL1xuICAgIGdldCB3YWxsZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93YWxsZXQ7XG4gICAgfVxuICAgIHNldCB3YWxsZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fd2FsbGV0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc3RhdHVzQ2hhbmdlU3Vic2NyaXB0aW9ucy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKHRoaXMuX3dhbGxldCkpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB0aGlzLl93YWxsZXQgPSBudWxsO1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0dXNDaGFuZ2VTdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMuc3RhdHVzQ2hhbmdlRXJyb3JTdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIGNvbnN0IG1hbmlmZXN0VXJsID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYW5pZmVzdFVybCkgfHwgZ2V0V2ViUGFnZU1hbmlmZXN0KCk7XG4gICAgICAgIHRoaXMuZGFwcFNldHRpbmdzID0ge1xuICAgICAgICAgICAgbWFuaWZlc3RVcmwsXG4gICAgICAgICAgICBzdG9yYWdlOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnN0b3JhZ2UpIHx8IG5ldyBEZWZhdWx0U3RvcmFnZSgpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2FsbGV0c1JlcXVpcmVkRmVhdHVyZXMgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud2FsbGV0c1JlcXVpcmVkRmVhdHVyZXM7XG4gICAgICAgIHRoaXMuZW52aXJvbm1lbnQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW52aXJvbm1lbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBEZWZhdWx0RW52aXJvbm1lbnQoKTtcbiAgICAgICAgdGhpcy53YWxsZXRzTGlzdCA9IG5ldyBXYWxsZXRzTGlzdE1hbmFnZXIoe1xuICAgICAgICAgICAgd2FsbGV0c0xpc3RTb3VyY2U6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53YWxsZXRzTGlzdFNvdXJjZSxcbiAgICAgICAgICAgIGNhY2hlVFRMTXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53YWxsZXRzTGlzdENhY2hlVFRMTXMsXG4gICAgICAgICAgICBvbkRvd25sb2FkRHVyYXRpb25NZWFzdXJlZDogKGR1cmF0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuYW5hbHl0aWNzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0V2FsbGV0TGlzdERvd25sb2FkRHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZXZlbnREaXNwYXRjaGVyID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmV2ZW50RGlzcGF0Y2hlcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IEJyb3dzZXJFdmVudERpc3BhdGNoZXIoKTtcbiAgICAgICAgdGhpcy50cmFja2VyID0gbmV3IFRvbkNvbm5lY3RUcmFja2VyKHtcbiAgICAgICAgICAgIGV2ZW50RGlzcGF0Y2hlcixcbiAgICAgICAgICAgIHRvbkNvbm5lY3RTZGtWZXJzaW9uOiB0b25Db25uZWN0U2RrVmVyc2lvblxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbnZpcm9ubWVudCA9IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5lbnZpcm9ubWVudCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbmV3IERlZmF1bHRFbnZpcm9ubWVudCgpO1xuICAgICAgICB0aGlzLmluaXRBbmFseXRpY3MobWFuaWZlc3RVcmwsIGV2ZW50RGlzcGF0Y2hlciwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghdGhpcy5kYXBwU2V0dGluZ3MubWFuaWZlc3RVcmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBEYXBwTWV0YWRhdGFFcnJvcignRGFwcCB0b25jb25uZWN0LW1hbmlmZXN0Lmpzb24gbXVzdCBiZSBzcGVjaWZpZWQgaWYgd2luZG93LmxvY2F0aW9uLm9yaWdpbiBpcyB1bmRlZmluZWQuIFNlZSBtb3JlIGh0dHBzOi8vZ2l0aHViLmNvbS90b24tY29ubmVjdC9kb2NzL2Jsb2IvbWFpbi9yZXF1ZXN0cy1yZXNwb25zZXMubWQjYXBwLW1hbmlmZXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5icmlkZ2VDb25uZWN0aW9uU3RvcmFnZSA9IG5ldyBCcmlkZ2VDb25uZWN0aW9uU3RvcmFnZSh0aGlzLmRhcHBTZXR0aW5ncy5zdG9yYWdlLCB0aGlzLndhbGxldHNMaXN0KTtcbiAgICAgICAgaWYgKCEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRpc2FibGVBdXRvUGF1c2VDb25uZWN0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5hZGRXaW5kb3dGb2N1c0FuZEJsdXJTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhdmFpbGFibGUgd2FsbGV0cyBsaXN0LlxuICAgICAqL1xuICAgIGdldFdhbGxldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndhbGxldHNMaXN0LmdldFdhbGxldHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRvIHN1YnNjcmliZSB0byBjb25uZWN0aW9uIHN0YXR1cyBjaGFuZ2VzIGFuZCBoYW5kbGUgY29ubmVjdGlvbiBlcnJvcnMuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGNvbm5lY3Rpb25zIHN0YXR1cyBjaGFuZ2VzIHdpdGggYWN0dWFsIHdhbGxldCBvciBudWxsLlxuICAgICAqIEBwYXJhbSBlcnJvcnNIYW5kbGVyIChvcHRpb25hbCkgd2lsbCBiZSBjYWxsZWQgd2l0aCBzb21lIGluc3RhbmNlIG9mIFRvbkNvbm5lY3RFcnJvciB3aGVuIGNvbm5lY3QgZXJyb3IgaXMgcmVjZWl2ZWQuXG4gICAgICogQHJldHVybnMgdW5zdWJzY3JpYmUgY2FsbGJhY2suXG4gICAgICovXG4gICAgb25TdGF0dXNDaGFuZ2UoY2FsbGJhY2ssIGVycm9yc0hhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNDaGFuZ2VTdWJzY3JpcHRpb25zLnB1c2goY2FsbGJhY2spO1xuICAgICAgICBpZiAoZXJyb3JzSGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNDaGFuZ2VFcnJvclN1YnNjcmlwdGlvbnMucHVzaChlcnJvcnNIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNDaGFuZ2VTdWJzY3JpcHRpb25zID0gdGhpcy5zdGF0dXNDaGFuZ2VTdWJzY3JpcHRpb25zLmZpbHRlcihpdGVtID0+IGl0ZW0gIT09IGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChlcnJvcnNIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNDaGFuZ2VFcnJvclN1YnNjcmlwdGlvbnMgPSB0aGlzLnN0YXR1c0NoYW5nZUVycm9yU3Vic2NyaXB0aW9ucy5maWx0ZXIoaXRlbSA9PiBpdGVtICE9PSBlcnJvcnNIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICBjb25uZWN0KHdhbGxldCwgcmVxdWVzdE9yT3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSBkZXByZWNhdGVkIG1ldGhvZFxuICAgICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgYWRkaXRpb25hbE9wdGlvbnMpO1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3RPck9wdGlvbnMgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICByZXF1ZXN0T3JPcHRpb25zICE9PSBudWxsICYmXG4gICAgICAgICAgICAndG9uUHJvb2YnIGluIHJlcXVlc3RPck9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucmVxdWVzdCA9IHJlcXVlc3RPck9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0T3JPcHRpb25zID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgcmVxdWVzdE9yT3B0aW9ucyAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgKCdvcGVuaW5nRGVhZGxpbmVNUycgaW4gcmVxdWVzdE9yT3B0aW9ucyB8fFxuICAgICAgICAgICAgICAgICdzaWduYWwnIGluIHJlcXVlc3RPck9wdGlvbnMgfHxcbiAgICAgICAgICAgICAgICAncmVxdWVzdCcgaW4gcmVxdWVzdE9yT3B0aW9ucyB8fFxuICAgICAgICAgICAgICAgICd0cmFjZUlkJyBpbiByZXF1ZXN0T3JPcHRpb25zKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5yZXF1ZXN0ID0gcmVxdWVzdE9yT3B0aW9ucyA9PT0gbnVsbCB8fCByZXF1ZXN0T3JPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXF1ZXN0T3JPcHRpb25zLnJlcXVlc3Q7XG4gICAgICAgICAgICBvcHRpb25zLm9wZW5pbmdEZWFkbGluZU1TID0gcmVxdWVzdE9yT3B0aW9ucyA9PT0gbnVsbCB8fCByZXF1ZXN0T3JPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXF1ZXN0T3JPcHRpb25zLm9wZW5pbmdEZWFkbGluZU1TO1xuICAgICAgICAgICAgb3B0aW9ucy5zaWduYWwgPSByZXF1ZXN0T3JPcHRpb25zID09PSBudWxsIHx8IHJlcXVlc3RPck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlcXVlc3RPck9wdGlvbnMuc2lnbmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnJlcXVlc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25FcnJvciA9IHZhbGlkYXRlQ29ubmVjdEFkZGl0aW9uYWxSZXF1ZXN0KG9wdGlvbnMucmVxdWVzdCk7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUWFNb2RlRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nvbm5lY3RBZGRpdGlvbmFsUmVxdWVzdCB2YWxpZGF0aW9uIGZhaWxlZDogJyArIHZhbGlkYXRpb25FcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdDb25uZWN0QWRkaXRpb25hbFJlcXVlc3QgdmFsaWRhdGlvbiBmYWlsZWQ6ICcgKyB2YWxpZGF0aW9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRBbHJlYWR5Q29ubmVjdGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBjcmVhdGVBYm9ydENvbnRyb2xsZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCk7XG4gICAgICAgIChfYSA9IHRoaXMuYWJvcnRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWJvcnQoKTtcbiAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBhYm9ydENvbnRyb2xsZXI7XG4gICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ0Nvbm5lY3Rpb24gd2FzIGFib3J0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAoX2IgPSB0aGlzLnByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2xvc2VDb25uZWN0aW9uKCk7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSB0aGlzLmNyZWF0ZVByb3ZpZGVyKHdhbGxldCk7XG4gICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2VDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRyYWNlSWQgPSAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogVVVJRHY3KCk7XG4gICAgICAgIHRoaXMudHJhY2tlci50cmFja0Nvbm5lY3Rpb25TdGFydGVkKHRyYWNlSWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5jb25uZWN0KHRoaXMuY3JlYXRlQ29ubmVjdFJlcXVlc3Qob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlcXVlc3QpLCB7XG4gICAgICAgICAgICBvcGVuaW5nRGVhZGxpbmVNUzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9wZW5pbmdEZWFkbGluZU1TLFxuICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgdHJhY2VJZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ5IHRvIHJlc3RvcmUgZXhpc3Rpbmcgc2Vzc2lvbiBhbmQgcmVjb25uZWN0IHRvIHRoZSBjb3JyZXNwb25kaW5nIHdhbGxldC4gQ2FsbCBpdCBpbW1lZGlhdGVseSB3aGVuIHlvdXIgYXBwIGlzIGxvYWRlZC5cbiAgICAgKi9cbiAgICByZXN0b3JlQ29ubmVjdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IHRyYWNlSWQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVVVJRHY3KCk7XG4gICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uUmVzdG9yaW5nU3RhcnRlZCh0cmFjZUlkKTtcbiAgICAgICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IGNyZWF0ZUFib3J0Q29udHJvbGxlcihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsKTtcbiAgICAgICAgICAgIChfYiA9IHRoaXMuYWJvcnRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gYWJvcnRDb250cm9sbGVyO1xuICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tlci50cmFja0Nvbm5lY3Rpb25SZXN0b3JpbmdFcnJvcignQ29ubmVjdGlvbiByZXN0b3Jpbmcgd2FzIGFib3J0ZWQnLCB0cmFjZUlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBwb3RlbnRpYWxseSByYWNlIGNvbmRpdGlvbiBoZXJlXG4gICAgICAgICAgICBjb25zdCBbYnJpZGdlQ29ubmVjdGlvblR5cGUsIGVtYmVkZGVkV2FsbGV0XSA9IHlpZWxkIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICB0aGlzLmJyaWRnZUNvbm5lY3Rpb25TdG9yYWdlLnN0b3JlZENvbm5lY3Rpb25UeXBlKCksXG4gICAgICAgICAgICAgICAgdGhpcy53YWxsZXRzTGlzdC5nZXRFbWJlZGRlZFdhbGxldCgpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uUmVzdG9yaW5nRXJyb3IoJ0Nvbm5lY3Rpb24gcmVzdG9yaW5nIHdhcyBhYm9ydGVkJywgdHJhY2VJZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHByb3ZpZGVyID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChicmlkZ2VDb25uZWN0aW9uVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdodHRwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0geWllbGQgQnJpZGdlUHJvdmlkZXIuZnJvbVN0b3JhZ2UodGhpcy5icmlkZ2VDb25uZWN0aW9uU3RvcmFnZSwgdGhpcy5hbmFseXRpY3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2luamVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0geWllbGQgSW5qZWN0ZWRQcm92aWRlci5mcm9tU3RvcmFnZSh0aGlzLmJyaWRnZUNvbm5lY3Rpb25TdG9yYWdlLCB0aGlzLmFuYWx5dGljcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2FsbGV0LWNvbm5lY3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSB5aWVsZCBXYWxsZXRDb25uZWN0UHJvdmlkZXIuZnJvbVN0b3JhZ2UodGhpcy5icmlkZ2VDb25uZWN0aW9uU3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbWJlZGRlZFdhbGxldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gdGhpcy5jcmVhdGVQcm92aWRlcihlbWJlZGRlZFdhbGxldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdQcm92aWRlciBpcyBub3QgcmVzdG9yZWQnLCBlcnIpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tlci50cmFja0Nvbm5lY3Rpb25SZXN0b3JpbmdFcnJvcignUHJvdmlkZXIgaXMgbm90IHJlc3RvcmVkJywgdHJhY2VJZCk7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5icmlkZ2VDb25uZWN0aW9uU3RvcmFnZS5yZW1vdmVDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIgPT09IG51bGwgfHwgcHJvdmlkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3ZpZGVyLmNsb3NlQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIgPT09IG51bGwgfHwgcHJvdmlkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3ZpZGVyLmNsb3NlQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tlci50cmFja0Nvbm5lY3Rpb25SZXN0b3JpbmdFcnJvcignQ29ubmVjdGlvbiByZXN0b3Jpbmcgd2FzIGFib3J0ZWQnLCB0cmFjZUlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgbG9nRXJyb3IoJ1Byb3ZpZGVyIGlzIG5vdCByZXN0b3JlZCcpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tlci50cmFja0Nvbm5lY3Rpb25SZXN0b3JpbmdFcnJvcignUHJvdmlkZXIgaXMgbm90IHJlc3RvcmVkJywgdHJhY2VJZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9jID0gdGhpcy5wcm92aWRlcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNsb3NlQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgcHJvdmlkZXIubGlzdGVuKHRoaXMud2FsbGV0RXZlbnRzTGlzdGVuZXIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICBjb25zdCBvbkFib3J0UmVzdG9yZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uUmVzdG9yaW5nRXJyb3IoJ0Nvbm5lY3Rpb24gcmVzdG9yaW5nIHdhcyBhYm9ydGVkJywgdHJhY2VJZCk7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIgPT09IG51bGwgfHwgcHJvdmlkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3ZpZGVyLmNsb3NlQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25BYm9ydFJlc3RvcmUpO1xuICAgICAgICAgICAgY29uc3QgcmVzdG9yZUNvbm5lY3Rpb25UYXNrID0gY2FsbEZvclN1Y2Nlc3MoKF9vcHRpb25zKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgKHByb3ZpZGVyID09PSBudWxsIHx8IHByb3ZpZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm92aWRlci5yZXN0b3JlQ29ubmVjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5pbmdEZWFkbGluZU1TOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub3BlbmluZ0RlYWRsaW5lTVMsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbDogX29wdGlvbnMuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZUlkXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkFib3J0UmVzdG9yZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JbmZvID0gdGhpcy5nZXRTZXNzaW9uSW5mbygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uUmVzdG9yaW5nQ29tcGxldGVkKHRoaXMud2FsbGV0LCBzZXNzaW9uSW5mbywgdHJhY2VJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uUmVzdG9yaW5nRXJyb3IoJ0Nvbm5lY3Rpb24gcmVzdG9yaW5nIGZhaWxlZCcsIHRyYWNlSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICAgICAgYXR0ZW1wdHM6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgICAgIGRlbGF5TXM6IDIwMDAsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3RvcmVDb25uZWN0aW9uVGltZW91dCA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKCksIDEyMDAwKSAvLyBjb25uZWN0aW9uIGRlYWRsaW5lXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbcmVzdG9yZUNvbm5lY3Rpb25UYXNrLCByZXN0b3JlQ29ubmVjdGlvblRpbWVvdXRdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgb3B0aW9uc09yT25SZXF1ZXN0U2VudCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGRlcHJlY2F0ZWQgbWV0aG9kXG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uUmVxdWVzdFNlbnQgPSBvcHRpb25zT3JPblJlcXVlc3RTZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlcXVlc3RTZW50ID0gb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gbnVsbCB8fCBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zT3JPblJlcXVlc3RTZW50Lm9uUmVxdWVzdFNlbnQ7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWwgPSBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSBudWxsIHx8IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQuc2lnbmFsO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudHJhY2VJZCA9IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IG51bGwgfHwgb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uc09yT25SZXF1ZXN0U2VudC50cmFjZUlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVmFsaWRhdGUgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25FcnJvciA9IHZhbGlkYXRlU2VuZFRyYW5zYWN0aW9uUmVxdWVzdCh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUWFNb2RlRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NlbmRUcmFuc2FjdGlvblJlcXVlc3QgdmFsaWRhdGlvbiBmYWlsZWQ6ICcgKyB2YWxpZGF0aW9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignU2VuZFRyYW5zYWN0aW9uUmVxdWVzdCB2YWxpZGF0aW9uIGZhaWxlZDogJyArIHZhbGlkYXRpb25FcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gY3JlYXRlQWJvcnRDb250cm9sbGVyKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWwpO1xuICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ1RyYW5zYWN0aW9uIHNlbmRpbmcgd2FzIGFib3J0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2hlY2tDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCByZXF1aXJlZE1lc3NhZ2VzTnVtYmVyID0gdHJhbnNhY3Rpb24ubWVzc2FnZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgcmVxdWlyZUV4dHJhQ3VycmVuY2llcyA9IHRyYW5zYWN0aW9uLm1lc3NhZ2VzLnNvbWUobSA9PiBtLmV4dHJhQ3VycmVuY3kgJiYgT2JqZWN0LmtleXMobS5leHRyYUN1cnJlbmN5KS5sZW5ndGggPiAwKTtcbiAgICAgICAgICAgIGNoZWNrU2VuZFRyYW5zYWN0aW9uU3VwcG9ydCh0aGlzLndhbGxldC5kZXZpY2UuZmVhdHVyZXMsIHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZE1lc3NhZ2VzTnVtYmVyLFxuICAgICAgICAgICAgICAgIHJlcXVpcmVFeHRyYUN1cnJlbmNpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbkluZm8gPSB0aGlzLmdldFNlc3Npb25JbmZvKCk7XG4gICAgICAgICAgICBjb25zdCB0cmFjZUlkID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYWNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFVVSUR2NygpO1xuICAgICAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrVHJhbnNhY3Rpb25TZW50Rm9yU2lnbmF0dXJlKHRoaXMud2FsbGV0LCB0cmFuc2FjdGlvbiwgc2Vzc2lvbkluZm8sIHRyYWNlSWQpO1xuICAgICAgICAgICAgY29uc3QgeyB2YWxpZFVudGlsLCBtZXNzYWdlcyB9ID0gdHJhbnNhY3Rpb24sIHR4ID0gX19yZXN0KHRyYW5zYWN0aW9uLCBbXCJ2YWxpZFVudGlsXCIsIFwibWVzc2FnZXNcIl0pO1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IHRyYW5zYWN0aW9uLmZyb20gfHwgdGhpcy5hY2NvdW50LmFkZHJlc3M7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gdHJhbnNhY3Rpb24ubmV0d29yayB8fCB0aGlzLmFjY291bnQuY2hhaW47XG4gICAgICAgICAgICBpZiAoKChfYiA9IHRoaXMud2FsbGV0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWNjb3VudC5jaGFpbikgJiYgbmV0d29yayAhPT0gdGhpcy53YWxsZXQuYWNjb3VudC5jaGFpbikge1xuICAgICAgICAgICAgICAgIGlmICghaXNRYU1vZGVFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFdyb25nTmV0d29ya0Vycm9yKCdXYWxsZXQgY29ubmVjdGVkIHRvIGEgd3JvbmcgbmV0d29yaycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRDaGFpbklkOiAoX2MgPSB0aGlzLndhbGxldCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFjY291bnQuY2hhaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsQ2hhaW5JZDogbmV0d29ya1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignV2FsbGV0IGNvbm5lY3RlZCB0byBhIHdyb25nIG5ldHdvcmsnLCB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkQ2hhaW5JZDogKF9kID0gdGhpcy53YWxsZXQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hY2NvdW50LmNoYWluLFxuICAgICAgICAgICAgICAgICAgICBhY3R1YWxDaGFpbklkOiBuZXR3b3JrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucHJvdmlkZXIuc2VuZFJlcXVlc3Qoc2VuZFRyYW5zYWN0aW9uUGFyc2VyLmNvbnZlcnRUb1JwY1JlcXVlc3QoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0eCksIHsgZnJvbSxcbiAgICAgICAgICAgICAgICBuZXR3b3JrLCB2YWxpZF91bnRpbDogdmFsaWRVbnRpbCwgbWVzc2FnZXM6IG1lc3NhZ2VzLm1hcCgoX2EpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHsgZXh0cmFDdXJyZW5jeSwgcGF5bG9hZCwgc3RhdGVJbml0IH0gPSBfYSwgbXNnID0gX19yZXN0KF9hLCBbXCJleHRyYUN1cnJlbmN5XCIsIFwicGF5bG9hZFwiLCBcInN0YXRlSW5pdFwiXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtc2cpLCB7IHBheWxvYWQ6IG5vcm1hbGl6ZUJhc2U2NChwYXlsb2FkKSwgc3RhdGVJbml0OiBub3JtYWxpemVCYXNlNjQoc3RhdGVJbml0KSwgZXh0cmFfY3VycmVuY3k6IGV4dHJhQ3VycmVuY3kgfSkpO1xuICAgICAgICAgICAgICAgIH0pIH0pKSwge1xuICAgICAgICAgICAgICAgIG9uUmVxdWVzdFNlbnQ6IG9wdGlvbnMub25SZXF1ZXN0U2VudCxcbiAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICAgICAgdHJhY2VJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc2VuZFRyYW5zYWN0aW9uUGFyc2VyLmlzRXJyb3IocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrVHJhbnNhY3Rpb25TaWduaW5nRmFpbGVkKHRoaXMud2FsbGV0LCB0cmFuc2FjdGlvbiwgcmVzcG9uc2UuZXJyb3IubWVzc2FnZSwgcmVzcG9uc2UuZXJyb3IuY29kZSwgc2Vzc2lvbkluZm8sIHRyYWNlSWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZW5kVHJhbnNhY3Rpb25QYXJzZXIucGFyc2VBbmRUaHJvd0Vycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHNlbmRUcmFuc2FjdGlvblBhcnNlci5jb252ZXJ0RnJvbVJwY1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHRoaXMudHJhY2tlci50cmFja1RyYW5zYWN0aW9uU2lnbmVkKHRoaXMud2FsbGV0LCB0cmFuc2FjdGlvbiwgcmVzdWx0LCBzZXNzaW9uSW5mbywgdHJhY2VJZCk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN1bHQpLCB7IHRyYWNlSWQ6IHJlc3BvbnNlLnRyYWNlSWQgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduRGF0YShkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBjcmVhdGVBYm9ydENvbnRyb2xsZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCk7XG4gICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignZGF0YSBzZW5kaW5nIHdhcyBhYm9ydGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSBzaWduIGRhdGFcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25FcnJvciA9IHZhbGlkYXRlU2lnbkRhdGFQYXlsb2FkKGRhdGEpO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1FhTW9kZUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdTaWduRGF0YVBheWxvYWQgdmFsaWRhdGlvbiBmYWlsZWQ6ICcgKyB2YWxpZGF0aW9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignU2lnbkRhdGFQYXlsb2FkIHZhbGlkYXRpb24gZmFpbGVkOiAnICsgdmFsaWRhdGlvbkVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgY2hlY2tTaWduRGF0YVN1cHBvcnQodGhpcy53YWxsZXQuZGV2aWNlLmZlYXR1cmVzLCB7IHJlcXVpcmVkVHlwZXM6IFtkYXRhLnR5cGVdIH0pO1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbkluZm8gPSB0aGlzLmdldFNlc3Npb25JbmZvKCk7XG4gICAgICAgICAgICBjb25zdCB0cmFjZUlkID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYWNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFVVSUR2NygpO1xuICAgICAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrRGF0YVNlbnRGb3JTaWduYXR1cmUodGhpcy53YWxsZXQsIGRhdGEsIHNlc3Npb25JbmZvLCB0cmFjZUlkKTtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBkYXRhLmZyb20gfHwgdGhpcy5hY2NvdW50LmFkZHJlc3M7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gZGF0YS5uZXR3b3JrIHx8IHRoaXMuYWNjb3VudC5jaGFpbjtcbiAgICAgICAgICAgIGlmICgoKF9iID0gdGhpcy53YWxsZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hY2NvdW50LmNoYWluKSAmJiBuZXR3b3JrICE9PSB0aGlzLndhbGxldC5hY2NvdW50LmNoYWluKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1FhTW9kZUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0V3JvbmdOZXR3b3JrRXJyb3IoJ1dhbGxldCBjb25uZWN0ZWQgdG8gYSB3cm9uZyBuZXR3b3JrJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2F1c2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZENoYWluSWQ6IChfYyA9IHRoaXMud2FsbGV0KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWNjb3VudC5jaGFpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWxDaGFpbklkOiBuZXR3b3JrXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdXYWxsZXQgY29ubmVjdGVkIHRvIGEgd3JvbmcgbmV0d29yaycsIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRDaGFpbklkOiAoX2QgPSB0aGlzLndhbGxldCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFjY291bnQuY2hhaW4sXG4gICAgICAgICAgICAgICAgICAgIGFjdHVhbENoYWluSWQ6IG5ldHdvcmtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5wcm92aWRlci5zZW5kUmVxdWVzdChzaWduRGF0YVBhcnNlci5jb252ZXJ0VG9ScGNSZXF1ZXN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgKGRhdGEudHlwZSA9PT0gJ2NlbGwnID8geyBjZWxsOiBub3JtYWxpemVCYXNlNjQoZGF0YS5jZWxsKSB9IDoge30pKSwgeyBmcm9tLFxuICAgICAgICAgICAgICAgIG5ldHdvcmsgfSkpLCB7IG9uUmVxdWVzdFNlbnQ6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vblJlcXVlc3RTZW50LCBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsIHRyYWNlSWQgfSk7XG4gICAgICAgICAgICBpZiAoc2lnbkRhdGFQYXJzZXIuaXNFcnJvcihyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tEYXRhU2lnbmluZ0ZhaWxlZCh0aGlzLndhbGxldCwgZGF0YSwgcmVzcG9uc2UuZXJyb3IubWVzc2FnZSwgcmVzcG9uc2UuZXJyb3IuY29kZSwgc2Vzc2lvbkluZm8sIHRyYWNlSWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWduRGF0YVBhcnNlci5wYXJzZUFuZFRocm93RXJyb3IocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc2lnbkRhdGFQYXJzZXIuY29udmVydEZyb21ScGNSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tEYXRhU2lnbmVkKHRoaXMud2FsbGV0LCBkYXRhLCByZXN1bHQsIHNlc3Npb25JbmZvLCB0cmFjZUlkKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3VsdCksIHsgdHJhY2VJZCB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBkZXNpcmVkIG5ldHdvcmsgZm9yIHRoZSBjb25uZWN0aW9uLiBDYW4gb25seSBiZSBzZXQgYmVmb3JlIGNvbm5lY3RpbmcuXG4gICAgICogSWYgd2FsbGV0IGNvbm5lY3RzIHdpdGggYSBkaWZmZXJlbnQgY2hhaW4sIHRoZSBTREsgd2lsbCB0aHJvdyBhbiBlcnJvciBhbmQgYWJvcnQgY29ubmVjdGlvbi5cbiAgICAgKiBAcGFyYW0gbmV0d29yayBkZXNpcmVkIG5ldHdvcmsgaWQgKGUuZy4sICctMjM5JywgJy0zJywgb3IgY3VzdG9tKS4gUGFzcyB1bmRlZmluZWQgdG8gYWxsb3cgYW55IG5ldHdvcmsuXG4gICAgICovXG4gICAgc2V0Q29ubmVjdGlvbk5ldHdvcmsobmV0d29yaykge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ0Nhbm5vdCBjaGFuZ2UgbmV0d29yayB3aGlsZSB3YWxsZXQgaXMgY29ubmVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXNpcmVkQ2hhaW5JZCA9IG5ldHdvcms7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3QgZm9ybSB0aHcgY29ubmVjdGVkIHdhbGxldCBhbmQgZHJvcCBjdXJyZW50IHNlc3Npb24uXG4gICAgICovXG4gICAgZGlzY29ubmVjdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gY3JlYXRlQWJvcnRDb250cm9sbGVyKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWwpO1xuICAgICAgICAgICAgY29uc3QgcHJldkFib3J0Q29udHJvbGxlciA9IHRoaXMuYWJvcnRDb250cm9sbGVyO1xuICAgICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBhYm9ydENvbnRyb2xsZXI7XG4gICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignRGlzY29ubmVjdCB3YXMgYWJvcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHJhY2VJZCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFjZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBVVUlEdjcoKTtcbiAgICAgICAgICAgIHRoaXMub25XYWxsZXREaXNjb25uZWN0ZWQoJ2RhcHAnLCB7IHRyYWNlSWQgfSk7XG4gICAgICAgICAgICB5aWVsZCAoKF9iID0gdGhpcy5wcm92aWRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc2Nvbm5lY3Qoe1xuICAgICAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICAgICAgICB0cmFjZUlkXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBwcmV2QWJvcnRDb250cm9sbGVyID09PSBudWxsIHx8IHByZXZBYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXZBYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgc2Vzc2lvbiBJRCBpZiBhdmFpbGFibGUuXG4gICAgICogQHJldHVybnMgc2Vzc2lvbiBJRCBzdHJpbmcgb3IgbnVsbCBpZiBub3QgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIGdldFNlc3Npb25JZCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geWllbGQgdGhpcy5icmlkZ2VDb25uZWN0aW9uU3RvcmFnZS5nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb25uZWN0aW9uIHx8IGNvbm5lY3Rpb24udHlwZSAhPT0gJ2h0dHAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJ3Nlc3Npb25DcnlwdG8nIGluIGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGVuZGluZyBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLnNlc3Npb25DcnlwdG8uc2Vzc2lvbklkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXN0YWJsaXNoZWQgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5zZXNzaW9uLnNlc3Npb25DcnlwdG8uc2Vzc2lvbklkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0U2Vzc2lvbkluZm8oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLnByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgIT09ICdodHRwJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoJ3Nlc3Npb24nIGluIHRoaXMucHJvdmlkZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMucHJvdmlkZXIuc2Vzc2lvbjtcbiAgICAgICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2xpZW50SWQgPSBzZXNzaW9uLnNlc3Npb25DcnlwdG8uc2Vzc2lvbklkO1xuICAgICAgICAgICAgbGV0IHdhbGxldElkID0gbnVsbDtcbiAgICAgICAgICAgIGlmICgnd2FsbGV0UHVibGljS2V5JyBpbiBzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgd2FsbGV0SWQgPSBzZXNzaW9uLndhbGxldFB1YmxpY0tleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGNsaWVudElkLCB3YWxsZXRJZCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF1c2UgYnJpZGdlIEhUVFAgY29ubmVjdGlvbi4gTWlnaHQgYmUgaGVscGZ1bCwgaWYgeW91IHdhbnQgdG8gcGF1c2UgY29ubmVjdGlvbnMgd2hpbGUgYnJvd3NlciB0YWIgaXMgdW5mb2N1c2VkLFxuICAgICAqIG9yIGlmIHlvdSB1c2UgU0RLIHdpdGggTm9kZUpTIGFuZCB3YW50IHRvIHNhdmUgc2VydmVyIHJlc291cmNlcy5cbiAgICAgKi9cbiAgICBwYXVzZUNvbm5lY3Rpb24oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLnByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgIT09ICdodHRwJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvdmlkZXIucGF1c2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5wYXVzZSBicmlkZ2UgSFRUUCBjb25uZWN0aW9uIGlmIGl0IGlzIHBhdXNlZC5cbiAgICAgKi9cbiAgICB1blBhdXNlQ29ubmVjdGlvbigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKChfYSA9IHRoaXMucHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSAhPT0gJ2h0dHAnKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIudW5QYXVzZSgpO1xuICAgIH1cbiAgICBhZGRXaW5kb3dGb2N1c0FuZEJsdXJTdWJzY3JpcHRpb25zKCkge1xuICAgICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gICAgICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF1c2VDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuUGF1c2VDb25uZWN0aW9uKCkuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nRXJyb3IoJ0Nhbm5vdCBzdWJzY3JpYmUgdG8gdGhlIGRvY3VtZW50LnZpc2liaWxpdHljaGFuZ2U6ICcsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXRBbmFseXRpY3MobWFuaWZlc3RVcmwsIGV2ZW50RGlzcGF0Y2hlciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGFuYWx5dGljc1NldHRpbmdzID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFuYWx5dGljcztcbiAgICAgICAgY29uc3QgbW9kZSA9IChfYSA9IGFuYWx5dGljc1NldHRpbmdzID09PSBudWxsIHx8IGFuYWx5dGljc1NldHRpbmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbmFseXRpY3NTZXR0aW5ncy5tb2RlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAndGVsZW1ldHJ5JztcbiAgICAgICAgaWYgKG1vZGUgPT09ICdvZmYnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5hbHl0aWNzID0gbmV3IEFuYWx5dGljc01hbmFnZXIoe1xuICAgICAgICAgICAgZW52aXJvbm1lbnQ6IHRoaXMuZW52aXJvbm1lbnQsXG4gICAgICAgICAgICBtb2RlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFuYWx5dGljcyA9IGFuYWx5dGljcztcbiAgICAgICAgY29uc3QgdGVsZWdyYW1Vc2VyID0gdGhpcy5lbnZpcm9ubWVudC5nZXRUZWxlZ3JhbVVzZXIoKTtcbiAgICAgICAgY29uc3Qgc2hhcmVkQW5hbHl0aWNzRGF0YSA9IHtcbiAgICAgICAgICAgIGJyb3dzZXI6IHRoaXMuZW52aXJvbm1lbnQuZ2V0QnJvd3NlcigpLFxuICAgICAgICAgICAgcGxhdGZvcm06IHRoaXMuZW52aXJvbm1lbnQuZ2V0UGxhdGZvcm0oKSxcbiAgICAgICAgICAgIG1hbmlmZXN0X2pzb25fdXJsOiBtYW5pZmVzdFVybCxcbiAgICAgICAgICAgIG9yaWdpbl91cmw6IGdldE9yaWdpbldpdGhQYXRoLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmVudmlyb25tZW50LmdldExvY2FsZSgpXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0ZWxlZ3JhbVVzZXIpIHtcbiAgICAgICAgICAgIHNoYXJlZEFuYWx5dGljc0RhdGEudGdfaWQgPSB0ZWxlZ3JhbVVzZXIuaWQ7XG4gICAgICAgICAgICBzaGFyZWRBbmFseXRpY3NEYXRhLnRtYV9pc19wcmVtaXVtID0gdGVsZWdyYW1Vc2VyLmlzUHJlbWl1bTtcbiAgICAgICAgfVxuICAgICAgICBiaW5kRXZlbnRzVG8oZXZlbnREaXNwYXRjaGVyLCBhbmFseXRpY3Muc2NvcGVkKHNoYXJlZEFuYWx5dGljc0RhdGEpKTtcbiAgICB9XG4gICAgY3JlYXRlUHJvdmlkZXIod2FsbGV0KSB7XG4gICAgICAgIGxldCBwcm92aWRlcjtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHdhbGxldCkgJiYgaXNXYWxsZXRDb25uZWN0aW9uU291cmNlSlMod2FsbGV0KSkge1xuICAgICAgICAgICAgcHJvdmlkZXIgPSBuZXcgSW5qZWN0ZWRQcm92aWRlcih0aGlzLmJyaWRnZUNvbm5lY3Rpb25TdG9yYWdlLCB3YWxsZXQuanNCcmlkZ2VLZXksIHRoaXMuYW5hbHl0aWNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheSh3YWxsZXQpICYmIGlzV2FsbGV0Q29ubmVjdGlvblNvdXJjZVdhbGxldENvbm5lY3Qod2FsbGV0KSkge1xuICAgICAgICAgICAgcHJvdmlkZXIgPSBuZXcgV2FsbGV0Q29ubmVjdFByb3ZpZGVyKHRoaXMuYnJpZGdlQ29ubmVjdGlvblN0b3JhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvdmlkZXIgPSBuZXcgQnJpZGdlUHJvdmlkZXIodGhpcy5icmlkZ2VDb25uZWN0aW9uU3RvcmFnZSwgd2FsbGV0LCB0aGlzLmFuYWx5dGljcyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvdmlkZXIubGlzdGVuKHRoaXMud2FsbGV0RXZlbnRzTGlzdGVuZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIHJldHVybiBwcm92aWRlcjtcbiAgICB9XG4gICAgd2FsbGV0RXZlbnRzTGlzdGVuZXIoZSkge1xuICAgICAgICBzd2l0Y2ggKGUuZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3QnOlxuICAgICAgICAgICAgICAgIHRoaXMub25XYWxsZXRDb25uZWN0ZWQoZS5wYXlsb2FkLCB7IHRyYWNlSWQ6IGUudHJhY2VJZCB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RfZXJyb3InOlxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tlci50cmFja0Nvbm5lY3Rpb25FcnJvcihlLnBheWxvYWQubWVzc2FnZSwgZS5wYXlsb2FkLmNvZGUsIHRoaXMuZ2V0U2Vzc2lvbkluZm8oKSwgZS50cmFjZUlkKTtcbiAgICAgICAgICAgICAgICBjb25zdCB3YWxsZXRFcnJvciA9IGNvbm5lY3RFcnJvcnNQYXJzZXIucGFyc2VFcnJvcihlLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgIHRoaXMub25XYWxsZXRDb25uZWN0RXJyb3Iod2FsbGV0RXJyb3IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdCc6XG4gICAgICAgICAgICAgICAgdGhpcy5vbldhbGxldERpc2Nvbm5lY3RlZCgnd2FsbGV0JywgeyB0cmFjZUlkOiBlLnRyYWNlSWQgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25XYWxsZXRDb25uZWN0ZWQoY29ubmVjdEV2ZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHRvbkFjY291bnRJdGVtID0gY29ubmVjdEV2ZW50Lml0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLm5hbWUgPT09ICd0b25fYWRkcicpO1xuICAgICAgICBjb25zdCB0b25Qcm9vZkl0ZW0gPSBjb25uZWN0RXZlbnQuaXRlbXMuZmluZChpdGVtID0+IGl0ZW0ubmFtZSA9PT0gJ3Rvbl9wcm9vZicpO1xuICAgICAgICBpZiAoIXRvbkFjY291bnRJdGVtKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCd0b25fYWRkciBjb25uZWN0aW9uIGl0ZW0gd2FzIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc1JlcXVpcmVkRmVhdHVyZXMgPSBjaGVja1JlcXVpcmVkV2FsbGV0RmVhdHVyZXMoY29ubmVjdEV2ZW50LmRldmljZS5mZWF0dXJlcywgdGhpcy53YWxsZXRzUmVxdWlyZWRGZWF0dXJlcyk7XG4gICAgICAgIGlmICghaGFzUmVxdWlyZWRGZWF0dXJlcykge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5wcm92aWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMub25XYWxsZXRDb25uZWN0RXJyb3IobmV3IFdhbGxldE1pc3NpbmdSZXF1aXJlZEZlYXR1cmVzRXJyb3IoJ1dhbGxldCBkb2VzIG5vdCBzdXBwb3J0IHJlcXVpcmVkIGZlYXR1cmVzJywgeyBjYXVzZTogeyBjb25uZWN0RXZlbnQgfSB9KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2FsbGV0ID0ge1xuICAgICAgICAgICAgZGV2aWNlOiBjb25uZWN0RXZlbnQuZGV2aWNlLFxuICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIudHlwZSxcbiAgICAgICAgICAgIGFjY291bnQ6IHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0b25BY2NvdW50SXRlbS5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIGNoYWluOiB0b25BY2NvdW50SXRlbS5uZXR3b3JrLFxuICAgICAgICAgICAgICAgIHdhbGxldFN0YXRlSW5pdDogdG9uQWNjb3VudEl0ZW0ud2FsbGV0U3RhdGVJbml0LFxuICAgICAgICAgICAgICAgIHB1YmxpY0tleTogdG9uQWNjb3VudEl0ZW0ucHVibGljS2V5XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmRlc2lyZWRDaGFpbklkICYmIHdhbGxldC5hY2NvdW50LmNoYWluICE9PSB0aGlzLmRlc2lyZWRDaGFpbklkKSB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZENoYWluSWQgPSB0aGlzLmRlc2lyZWRDaGFpbklkO1xuICAgICAgICAgICAgY29uc3QgYWN0dWFsQ2hhaW5JZCA9IHdhbGxldC5hY2NvdW50LmNoYWluO1xuICAgICAgICAgICAgKF9iID0gdGhpcy5wcm92aWRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMub25XYWxsZXRDb25uZWN0RXJyb3IobmV3IFdhbGxldFdyb25nTmV0d29ya0Vycm9yKCdXYWxsZXQgY29ubmVjdGVkIHRvIGEgd3JvbmcgbmV0d29yaycsIHtcbiAgICAgICAgICAgICAgICBjYXVzZTogeyBleHBlY3RlZENoYWluSWQsIGFjdHVhbENoYWluSWQgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b25Qcm9vZkl0ZW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25FcnJvciA9IHZhbGlkYXRlVG9uUHJvb2ZJdGVtUmVwbHkodG9uUHJvb2ZJdGVtKTtcbiAgICAgICAgICAgIGxldCB0b25Qcm9vZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNRYU1vZGVFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVG9uUHJvb2ZJdGVtIHZhbGlkYXRpb24gZmFpbGVkOiAnICsgdmFsaWRhdGlvbkVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9uUHJvb2YgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0b25fcHJvb2YnLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogQ09OTkVDVF9JVEVNX0VSUk9SX0NPREVTLlVOS05PV05fRVJST1IsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB2YWxpZGF0aW9uRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJ3Byb29mJyBpbiB0b25Qcm9vZkl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvblByb29mID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0b25fcHJvb2YnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb29mOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdG9uUHJvb2ZJdGVtLnByb29mLnRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhCeXRlczogdG9uUHJvb2ZJdGVtLnByb29mLmRvbWFpbi5sZW5ndGhCeXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0b25Qcm9vZkl0ZW0ucHJvb2YuZG9tYWluLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHRvblByb29mSXRlbS5wcm9vZi5wYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHRvblByb29mSXRlbS5wcm9vZi5zaWduYXR1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCdlcnJvcicgaW4gdG9uUHJvb2ZJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b25Qcm9vZiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndG9uX3Byb29mJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiB0b25Qcm9vZkl0ZW0uZXJyb3IuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdG9uUHJvb2ZJdGVtLmVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignSW52YWxpZCBkYXRhIGZvcm1hdCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvblByb29mID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Rvbl9wcm9vZicsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IENPTk5FQ1RfSVRFTV9FUlJPUl9DT0RFUy5VTktOT1dOX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGRhdGEgZm9ybWF0J1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdhbGxldC5jb25uZWN0SXRlbXMgPSB7IHRvblByb29mIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YWxsZXQgPSB3YWxsZXQ7XG4gICAgICAgIGNvbnN0IHNlc3Npb25JbmZvID0gdGhpcy5nZXRTZXNzaW9uSW5mbygpO1xuICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uQ29tcGxldGVkKHdhbGxldCwgc2Vzc2lvbkluZm8sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFjZUlkKTtcbiAgICB9XG4gICAgb25XYWxsZXRDb25uZWN0RXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNDaGFuZ2VFcnJvclN1YnNjcmlwdGlvbnMuZm9yRWFjaChlcnJvcnNIYW5kbGVyID0+IGVycm9yc0hhbmRsZXIoZXJyb3IpKTtcbiAgICAgICAgbG9nRGVidWcoZXJyb3IpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBNYW5pZmVzdE5vdEZvdW5kRXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBNYW5pZmVzdENvbnRlbnRFcnJvckVycm9yKSB7XG4gICAgICAgICAgICBsb2dFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbldhbGxldERpc2Nvbm5lY3RlZChzY29wZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzZXNzaW9uSW5mbyA9IHRoaXMuZ2V0U2Vzc2lvbkluZm8oKTtcbiAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrRGlzY29ubmVjdGlvbih0aGlzLndhbGxldCwgc2NvcGUsIHNlc3Npb25JbmZvLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZCk7XG4gICAgICAgIHRoaXMud2FsbGV0ID0gbnVsbDtcbiAgICB9XG4gICAgY2hlY2tDb25uZWN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVDb25uZWN0UmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gW1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7IG5hbWU6ICd0b25fYWRkcicgfSwgKHRoaXMuZGVzaXJlZENoYWluSWQgPyB7IG5ldHdvcms6IHRoaXMuZGVzaXJlZENoYWluSWQgfSA6IHt9KSlcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKHJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVxdWVzdC50b25Qcm9vZikge1xuICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3Rvbl9wcm9vZicsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogcmVxdWVzdC50b25Qcm9vZlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hbmlmZXN0VXJsOiB0aGlzLmRhcHBTZXR0aW5ncy5tYW5pZmVzdFVybCxcbiAgICAgICAgICAgIGl0ZW1zXG4gICAgICAgIH07XG4gICAgfVxufVxuVG9uQ29ubmVjdC53YWxsZXRzTGlzdCA9IG5ldyBXYWxsZXRzTGlzdE1hbmFnZXIoKTtcbi8qKlxuICogQ2hlY2sgaWYgc3BlY2lmaWVkIHdhbGxldCBpcyBpbmplY3RlZCBhbmQgYXZhaWxhYmxlIHRvIHVzZSB3aXRoIHRoZSBhcHAuXG4gKiBAcGFyYW0gd2FsbGV0SlNLZXkgdGFyZ2V0IHdhbGxldCdzIGpzIGJyaWRnZSBrZXkuXG4gKi9cblRvbkNvbm5lY3QuaXNXYWxsZXRJbmplY3RlZCA9ICh3YWxsZXRKU0tleSkgPT4gSW5qZWN0ZWRQcm92aWRlci5pc1dhbGxldEluamVjdGVkKHdhbGxldEpTS2V5KTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGFwcCBpcyBvcGVuZWQgaW5zaWRlIHNwZWNpZmllZCB3YWxsZXQncyBicm93c2VyLlxuICogQHBhcmFtIHdhbGxldEpTS2V5IHRhcmdldCB3YWxsZXQncyBqcyBicmlkZ2Uga2V5LlxuICovXG5Ub25Db25uZWN0LmlzSW5zaWRlV2FsbGV0QnJvd3NlciA9ICh3YWxsZXRKU0tleSkgPT4gSW5qZWN0ZWRQcm92aWRlci5pc0luc2lkZVdhbGxldEJyb3dzZXIod2FsbGV0SlNLZXkpO1xuXG5leHBvcnQgeyBCYWRSZXF1ZXN0RXJyb3IsIEJyb3dzZXJFdmVudERpc3BhdGNoZXIsIEZldGNoV2FsbGV0c0Vycm9yLCBMb2NhbHN0b3JhZ2VOb3RGb3VuZEVycm9yLCBQYXJzZUhleEVycm9yLCBUb25Db25uZWN0LCBUb25Db25uZWN0RXJyb3IsIFVVSUR2NywgVW5rbm93bkFwcEVycm9yLCBVbmtub3duRXJyb3IsIFVzZXJSZWplY3RzRXJyb3IsIFdhbGxldEFscmVhZHlDb25uZWN0ZWRFcnJvciwgV2FsbGV0TWlzc2luZ1JlcXVpcmVkRmVhdHVyZXNFcnJvciwgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IsIFdhbGxldE5vdEluamVjdGVkRXJyb3IsIFdhbGxldE5vdFN1cHBvcnRGZWF0dXJlRXJyb3IsIFdhbGxldFdyb25nTmV0d29ya0Vycm9yLCBXYWxsZXRzTGlzdE1hbmFnZXIsIFdyb25nQWRkcmVzc0Vycm9yLCBjaGVja1JlcXVpcmVkV2FsbGV0RmVhdHVyZXMsIGNyZWF0ZUNvbm5lY3Rpb25Db21wbGV0ZWRFdmVudCwgY3JlYXRlQ29ubmVjdGlvbkVycm9yRXZlbnQsIGNyZWF0ZUNvbm5lY3Rpb25SZXN0b3JpbmdDb21wbGV0ZWRFdmVudCwgY3JlYXRlQ29ubmVjdGlvblJlc3RvcmluZ0Vycm9yRXZlbnQsIGNyZWF0ZUNvbm5lY3Rpb25SZXN0b3JpbmdTdGFydGVkRXZlbnQsIGNyZWF0ZUNvbm5lY3Rpb25TdGFydGVkRXZlbnQsIGNyZWF0ZURhdGFTZW50Rm9yU2lnbmF0dXJlRXZlbnQsIGNyZWF0ZURhdGFTaWduZWRFdmVudCwgY3JlYXRlRGF0YVNpZ25pbmdGYWlsZWRFdmVudCwgY3JlYXRlRGlzY29ubmVjdGlvbkV2ZW50LCBjcmVhdGVSZXF1ZXN0VmVyc2lvbkV2ZW50LCBjcmVhdGVSZXNwb25zZVZlcnNpb25FdmVudCwgY3JlYXRlU2VsZWN0ZWRXYWxsZXRFdmVudCwgY3JlYXRlVHJhbnNhY3Rpb25TZW50Rm9yU2lnbmF0dXJlRXZlbnQsIGNyZWF0ZVRyYW5zYWN0aW9uU2lnbmVkRXZlbnQsIGNyZWF0ZVRyYW5zYWN0aW9uU2lnbmluZ0ZhaWxlZEV2ZW50LCBjcmVhdGVWZXJzaW9uSW5mbywgY3JlYXRlV2FsbGV0TW9kYWxPcGVuZWRFdmVudCwgZGVjb2RlVGVsZWdyYW1VcmxQYXJhbWV0ZXJzLCBUb25Db25uZWN0IGFzIGRlZmF1bHQsIGVuYWJsZVFhTW9kZSwgZW5jb2RlVGVsZWdyYW1VcmxQYXJhbWV0ZXJzLCBpbml0aWFsaXplV2FsbGV0Q29ubmVjdCwgaXNDb25uZWN0VXJsLCBpc1FhTW9kZUVuYWJsZWQsIGlzVGVsZWdyYW1VcmwsIGlzV2FsbGV0Q29ubmVjdEluaXRpYWxpemVkLCBpc1dhbGxldEluZm9DdXJyZW50bHlFbWJlZGRlZCwgaXNXYWxsZXRJbmZvQ3VycmVudGx5SW5qZWN0ZWQsIGlzV2FsbGV0SW5mb0luamVjdGFibGUsIGlzV2FsbGV0SW5mb0luamVjdGVkLCBpc1dhbGxldEluZm9SZW1vdGUsIHRvVXNlckZyaWVuZGx5QWRkcmVzcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tonconnect/sdk/lib/esm/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tonconnect/ui-react/lib/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@tonconnect/ui-react/lib/index.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BadRequestError: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.BadRequestError; },\n/* harmony export */   BrowserEventDispatcher: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.BrowserEventDispatcher; },\n/* harmony export */   CHAIN: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.CHAIN; },\n/* harmony export */   CONNECT_EVENT_ERROR_CODES: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.CONNECT_EVENT_ERROR_CODES; },\n/* harmony export */   CONNECT_ITEM_ERROR_CODES: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.CONNECT_ITEM_ERROR_CODES; },\n/* harmony export */   FetchWalletsError: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.FetchWalletsError; },\n/* harmony export */   LocalstorageNotFoundError: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.LocalstorageNotFoundError; },\n/* harmony export */   ParseHexError: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.ParseHexError; },\n/* harmony export */   SEND_TRANSACTION_ERROR_CODES: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.SEND_TRANSACTION_ERROR_CODES; },\n/* harmony export */   SIGN_DATA_ERROR_CODES: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.SIGN_DATA_ERROR_CODES; },\n/* harmony export */   SessionCrypto: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.SessionCrypto; },\n/* harmony export */   THEME: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.THEME; },\n/* harmony export */   TonConnect: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.TonConnect; },\n/* harmony export */   TonConnectButton: function() { return /* binding */ TonConnectButton$1; },\n/* harmony export */   TonConnectError: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.TonConnectError; },\n/* harmony export */   TonConnectProviderNotSetError: function() { return /* binding */ TonConnectProviderNotSetError; },\n/* harmony export */   TonConnectUI: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.TonConnectUI; },\n/* harmony export */   TonConnectUIContext: function() { return /* binding */ TonConnectUIContext; },\n/* harmony export */   TonConnectUIError: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.TonConnectUIError; },\n/* harmony export */   TonConnectUIProvider: function() { return /* binding */ TonConnectUIProvider$1; },\n/* harmony export */   TonConnectUIReactError: function() { return /* binding */ TonConnectUIReactError; },\n/* harmony export */   UUIDv7: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.UUIDv7; },\n/* harmony export */   UnknownAppError: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.UnknownAppError; },\n/* harmony export */   UnknownError: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.UnknownError; },\n/* harmony export */   UserRejectsError: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.UserRejectsError; },\n/* harmony export */   WalletAlreadyConnectedError: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.WalletAlreadyConnectedError; },\n/* harmony export */   WalletMissingRequiredFeaturesError: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.WalletMissingRequiredFeaturesError; },\n/* harmony export */   WalletNotConnectedError: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.WalletNotConnectedError; },\n/* harmony export */   WalletNotInjectedError: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.WalletNotInjectedError; },\n/* harmony export */   WalletNotSupportFeatureError: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.WalletNotSupportFeatureError; },\n/* harmony export */   WalletWrongNetworkError: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.WalletWrongNetworkError; },\n/* harmony export */   WalletsListManager: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.WalletsListManager; },\n/* harmony export */   WrongAddressError: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.WrongAddressError; },\n/* harmony export */   checkRequiredWalletFeatures: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.checkRequiredWalletFeatures; },\n/* harmony export */   createConnectionCompletedEvent: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createConnectionCompletedEvent; },\n/* harmony export */   createConnectionErrorEvent: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createConnectionErrorEvent; },\n/* harmony export */   createConnectionRestoringCompletedEvent: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createConnectionRestoringCompletedEvent; },\n/* harmony export */   createConnectionRestoringErrorEvent: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createConnectionRestoringErrorEvent; },\n/* harmony export */   createConnectionRestoringStartedEvent: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createConnectionRestoringStartedEvent; },\n/* harmony export */   createConnectionStartedEvent: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createConnectionStartedEvent; },\n/* harmony export */   createDataSentForSignatureEvent: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createDataSentForSignatureEvent; },\n/* harmony export */   createDataSignedEvent: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createDataSignedEvent; },\n/* harmony export */   createDataSigningFailedEvent: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createDataSigningFailedEvent; },\n/* harmony export */   createDisconnectionEvent: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createDisconnectionEvent; },\n/* harmony export */   createRequestVersionEvent: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createRequestVersionEvent; },\n/* harmony export */   createResponseVersionEvent: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createResponseVersionEvent; },\n/* harmony export */   createSelectedWalletEvent: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createSelectedWalletEvent; },\n/* harmony export */   createTransactionSentForSignatureEvent: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createTransactionSentForSignatureEvent; },\n/* harmony export */   createTransactionSignedEvent: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createTransactionSignedEvent; },\n/* harmony export */   createTransactionSigningFailedEvent: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createTransactionSigningFailedEvent; },\n/* harmony export */   createVersionInfo: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createVersionInfo; },\n/* harmony export */   createWalletModalOpenedEvent: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.createWalletModalOpenedEvent; },\n/* harmony export */   decodeTelegramUrlParameters: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.decodeTelegramUrlParameters; },\n/* harmony export */   enableQaMode: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.enableQaMode; },\n/* harmony export */   encodeTelegramUrlParameters: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.encodeTelegramUrlParameters; },\n/* harmony export */   initializeWalletConnect: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.initializeWalletConnect; },\n/* harmony export */   isConnectUrl: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.isConnectUrl; },\n/* harmony export */   isQaModeEnabled: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.isQaModeEnabled; },\n/* harmony export */   isTelegramUrl: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.isTelegramUrl; },\n/* harmony export */   isWalletConnectInitialized: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.isWalletConnectInitialized; },\n/* harmony export */   isWalletInfoCurrentlyEmbedded: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.isWalletInfoCurrentlyEmbedded; },\n/* harmony export */   isWalletInfoCurrentlyInjected: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.isWalletInfoCurrentlyInjected; },\n/* harmony export */   isWalletInfoInjectable: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.isWalletInfoInjectable; },\n/* harmony export */   isWalletInfoInjected: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.isWalletInfoInjected; },\n/* harmony export */   isWalletInfoRemote: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.isWalletInfoRemote; },\n/* harmony export */   toUserFriendlyAddress: function() { return /* reexport safe */ _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.toUserFriendlyAddress; },\n/* harmony export */   useIsConnectionRestored: function() { return /* binding */ useIsConnectionRestored; },\n/* harmony export */   useTonAddress: function() { return /* binding */ useTonAddress; },\n/* harmony export */   useTonConnectModal: function() { return /* binding */ useTonConnectModal; },\n/* harmony export */   useTonConnectUI: function() { return /* binding */ useTonConnectUI; },\n/* harmony export */   useTonWallet: function() { return /* binding */ useTonWallet; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tonconnect/ui */ \"(app-pages-browser)/./node_modules/@tonconnect/ui/lib/index.mjs\");\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\n\n\n\n\nfunction isClientSide() {\n  return typeof window !== \"undefined\";\n}\nfunction isServerSide() {\n  return !isClientSide();\n}\nconst TonConnectUIContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nlet tonConnectUI = null;\nconst TonConnectUIProvider = (_a) => {\n  var _b = _a, {\n    children\n  } = _b, options = __objRest(_b, [\n    \"children\"\n  ]);\n  const [uiInstance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(() => {\n    if (!isClientSide()) {\n      return null;\n    }\n    if (tonConnectUI !== null) {\n      return tonConnectUI;\n    }\n    if (\"instance\" in options) {\n      tonConnectUI = options.instance;\n    } else {\n      tonConnectUI = new _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.TonConnectUI(options);\n    }\n    return tonConnectUI;\n  });\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(TonConnectUIContext.Provider, { value: uiInstance, children });\n};\nconst TonConnectUIProvider$1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(TonConnectUIProvider);\nclass TonConnectUIReactError extends _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.TonConnectUIError {\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, TonConnectUIReactError.prototype);\n  }\n}\nclass TonConnectProviderNotSetError extends TonConnectUIReactError {\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, TonConnectProviderNotSetError.prototype);\n  }\n}\nfunction checkProvider(provider) {\n  if (!provider) {\n    throw new TonConnectProviderNotSetError(\n      \"You should add <TonConnectUIProvider> on the top of the app to use TonConnect\"\n    );\n  }\n  return true;\n}\nfunction useTonConnectUI() {\n  const tonConnectUI2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(TonConnectUIContext);\n  const setOptions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (options) => {\n      if (tonConnectUI2) {\n        tonConnectUI2.uiOptions = options;\n      }\n    },\n    [tonConnectUI2]\n  );\n  if (isServerSide()) {\n    return [null, () => {\n    }];\n  }\n  checkProvider(tonConnectUI2);\n  return [tonConnectUI2, setOptions];\n}\nconst buttonRootId = \"ton-connect-button\";\nconst TonConnectButton = ({ className, style }) => {\n  const [_, setOptions] = useTonConnectUI();\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    setOptions({ buttonRootId });\n    return () => setOptions({ buttonRootId: null });\n  }, [setOptions]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    \"div\",\n    {\n      id: buttonRootId,\n      className,\n      style: __spreadValues({ width: \"fit-content\" }, style)\n    }\n  );\n};\nconst TonConnectButton$1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(TonConnectButton);\nfunction useTonWallet() {\n  const [tonConnectUI2] = useTonConnectUI();\n  const [wallet, setWallet] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\n    (tonConnectUI2 == null ? void 0 : tonConnectUI2.wallet) || null\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (tonConnectUI2) {\n      setWallet(tonConnectUI2.wallet);\n      return tonConnectUI2.onStatusChange((value) => {\n        setWallet(value);\n      });\n    }\n  }, [tonConnectUI2]);\n  return wallet;\n}\nfunction useTonAddress(userFriendly = true) {\n  const wallet = useTonWallet();\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    if (wallet) {\n      return userFriendly ? (0,_tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.toUserFriendlyAddress)(\n        wallet.account.address,\n        wallet.account.chain === _tonconnect_ui__WEBPACK_IMPORTED_MODULE_2__.CHAIN.TESTNET\n      ) : wallet.account.address;\n    } else {\n      return \"\";\n    }\n  }, [wallet, userFriendly, wallet == null ? void 0 : wallet.account.address, wallet == null ? void 0 : wallet.account.chain]);\n}\nfunction useTonConnectModal() {\n  const [tonConnectUI2] = useTonConnectUI();\n  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)((tonConnectUI2 == null ? void 0 : tonConnectUI2.modal.state) || null);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (tonConnectUI2) {\n      setState(tonConnectUI2.modal.state);\n      return tonConnectUI2.onModalStateChange((value) => {\n        setState(value);\n      });\n    }\n  }, [tonConnectUI2]);\n  return {\n    state,\n    open: () => tonConnectUI2 == null ? void 0 : tonConnectUI2.modal.open(),\n    close: () => tonConnectUI2 == null ? void 0 : tonConnectUI2.modal.close()\n  };\n}\nfunction useIsConnectionRestored() {\n  const [restored, setRestored] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n  const [tonConnectUI2] = useTonConnectUI();\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (tonConnectUI2) {\n      tonConnectUI2.connectionRestored.then(() => setRestored(true));\n    }\n  }, [tonConnectUI2]);\n  return restored;\n}\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdG9uY29ubmVjdC91aS1yZWFjdC9saWIvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN3QztBQUMyRDtBQUNKO0FBQ2hFO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvREFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsdUJBQXVCLCtDQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUJBQXlCLHdEQUFZO0FBQ3JDO0FBQ0E7QUFDQSxHQUFHO0FBQ0gseUJBQXlCLHNEQUFHLGlDQUFpQyw2QkFBNkI7QUFDMUY7QUFDQSwrQkFBK0IsMkNBQUk7QUFDbkMscUNBQXFDLDZEQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlEQUFVO0FBQ2xDLHFCQUFxQixrREFBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBLEVBQUUsZ0RBQVM7QUFDWCxpQkFBaUIsY0FBYztBQUMvQiw4QkFBOEIsb0JBQW9CO0FBQ2xELEdBQUc7QUFDSCx5QkFBeUIsc0RBQUc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0JBQXNCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQ0FBSTtBQUMvQjtBQUNBO0FBQ0EsOEJBQThCLCtDQUFRO0FBQ3RDO0FBQ0E7QUFDQSxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhDQUFPO0FBQ2hCO0FBQ0EsNEJBQTRCLHFFQUFxQjtBQUNqRDtBQUNBLGlDQUFpQyxpREFBSztBQUN0QztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQ0FBUTtBQUNwQyxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsK0NBQVE7QUFDMUM7QUFDQSxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFZRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdG9uY29ubmVjdC91aS1yZWFjdC9saWIvaW5kZXgubWpzPzQ3OWMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fb2JqUmVzdCA9IChzb3VyY2UsIGV4Y2x1ZGUpID0+IHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoc291cmNlLCBwcm9wKSAmJiBleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwKVxuICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICBpZiAoc291cmNlICE9IG51bGwgJiYgX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoc291cmNlKSkge1xuICAgICAgaWYgKGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDAgJiYgX19wcm9wSXNFbnVtLmNhbGwoc291cmNlLCBwcm9wKSlcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIG1lbW8sIHVzZVN0YXRlLCB1c2VDb250ZXh0LCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBUb25Db25uZWN0VUksIFRvbkNvbm5lY3RVSUVycm9yLCB0b1VzZXJGcmllbmRseUFkZHJlc3MsIENIQUlOIH0gZnJvbSBcIkB0b25jb25uZWN0L3VpXCI7XG5leHBvcnQgKiBmcm9tIFwiQHRvbmNvbm5lY3QvdWlcIjtcbmZ1bmN0aW9uIGlzQ2xpZW50U2lkZSgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59XG5mdW5jdGlvbiBpc1NlcnZlclNpZGUoKSB7XG4gIHJldHVybiAhaXNDbGllbnRTaWRlKCk7XG59XG5jb25zdCBUb25Db25uZWN0VUlDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmxldCB0b25Db25uZWN0VUkgPSBudWxsO1xuY29uc3QgVG9uQ29ubmVjdFVJUHJvdmlkZXIgPSAoX2EpID0+IHtcbiAgdmFyIF9iID0gX2EsIHtcbiAgICBjaGlsZHJlblxuICB9ID0gX2IsIG9wdGlvbnMgPSBfX29ialJlc3QoX2IsIFtcbiAgICBcImNoaWxkcmVuXCJcbiAgXSk7XG4gIGNvbnN0IFt1aUluc3RhbmNlXSA9IHVzZVN0YXRlKCgpID0+IHtcbiAgICBpZiAoIWlzQ2xpZW50U2lkZSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvbkNvbm5lY3RVSSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRvbkNvbm5lY3RVSTtcbiAgICB9XG4gICAgaWYgKFwiaW5zdGFuY2VcIiBpbiBvcHRpb25zKSB7XG4gICAgICB0b25Db25uZWN0VUkgPSBvcHRpb25zLmluc3RhbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b25Db25uZWN0VUkgPSBuZXcgVG9uQ29ubmVjdFVJKG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9uQ29ubmVjdFVJO1xuICB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goVG9uQ29ubmVjdFVJQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdWlJbnN0YW5jZSwgY2hpbGRyZW4gfSk7XG59O1xuY29uc3QgVG9uQ29ubmVjdFVJUHJvdmlkZXIkMSA9IG1lbW8oVG9uQ29ubmVjdFVJUHJvdmlkZXIpO1xuY2xhc3MgVG9uQ29ubmVjdFVJUmVhY3RFcnJvciBleHRlbmRzIFRvbkNvbm5lY3RVSUVycm9yIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBUb25Db25uZWN0VUlSZWFjdEVycm9yLnByb3RvdHlwZSk7XG4gIH1cbn1cbmNsYXNzIFRvbkNvbm5lY3RQcm92aWRlck5vdFNldEVycm9yIGV4dGVuZHMgVG9uQ29ubmVjdFVJUmVhY3RFcnJvciB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgVG9uQ29ubmVjdFByb3ZpZGVyTm90U2V0RXJyb3IucHJvdG90eXBlKTtcbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tQcm92aWRlcihwcm92aWRlcikge1xuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RQcm92aWRlck5vdFNldEVycm9yKFxuICAgICAgXCJZb3Ugc2hvdWxkIGFkZCA8VG9uQ29ubmVjdFVJUHJvdmlkZXI+IG9uIHRoZSB0b3Agb2YgdGhlIGFwcCB0byB1c2UgVG9uQ29ubmVjdFwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHVzZVRvbkNvbm5lY3RVSSgpIHtcbiAgY29uc3QgdG9uQ29ubmVjdFVJMiA9IHVzZUNvbnRleHQoVG9uQ29ubmVjdFVJQ29udGV4dCk7XG4gIGNvbnN0IHNldE9wdGlvbnMgPSB1c2VDYWxsYmFjayhcbiAgICAob3B0aW9ucykgPT4ge1xuICAgICAgaWYgKHRvbkNvbm5lY3RVSTIpIHtcbiAgICAgICAgdG9uQ29ubmVjdFVJMi51aU9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3RvbkNvbm5lY3RVSTJdXG4gICk7XG4gIGlmIChpc1NlcnZlclNpZGUoKSkge1xuICAgIHJldHVybiBbbnVsbCwgKCkgPT4ge1xuICAgIH1dO1xuICB9XG4gIGNoZWNrUHJvdmlkZXIodG9uQ29ubmVjdFVJMik7XG4gIHJldHVybiBbdG9uQ29ubmVjdFVJMiwgc2V0T3B0aW9uc107XG59XG5jb25zdCBidXR0b25Sb290SWQgPSBcInRvbi1jb25uZWN0LWJ1dHRvblwiO1xuY29uc3QgVG9uQ29ubmVjdEJ1dHRvbiA9ICh7IGNsYXNzTmFtZSwgc3R5bGUgfSkgPT4ge1xuICBjb25zdCBbXywgc2V0T3B0aW9uc10gPSB1c2VUb25Db25uZWN0VUkoKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRPcHRpb25zKHsgYnV0dG9uUm9vdElkIH0pO1xuICAgIHJldHVybiAoKSA9PiBzZXRPcHRpb25zKHsgYnV0dG9uUm9vdElkOiBudWxsIH0pO1xuICB9LCBbc2V0T3B0aW9uc10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIGlkOiBidXR0b25Sb290SWQsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICBzdHlsZTogX19zcHJlYWRWYWx1ZXMoeyB3aWR0aDogXCJmaXQtY29udGVudFwiIH0sIHN0eWxlKVxuICAgIH1cbiAgKTtcbn07XG5jb25zdCBUb25Db25uZWN0QnV0dG9uJDEgPSBtZW1vKFRvbkNvbm5lY3RCdXR0b24pO1xuZnVuY3Rpb24gdXNlVG9uV2FsbGV0KCkge1xuICBjb25zdCBbdG9uQ29ubmVjdFVJMl0gPSB1c2VUb25Db25uZWN0VUkoKTtcbiAgY29uc3QgW3dhbGxldCwgc2V0V2FsbGV0XSA9IHVzZVN0YXRlKFxuICAgICh0b25Db25uZWN0VUkyID09IG51bGwgPyB2b2lkIDAgOiB0b25Db25uZWN0VUkyLndhbGxldCkgfHwgbnVsbFxuICApO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0b25Db25uZWN0VUkyKSB7XG4gICAgICBzZXRXYWxsZXQodG9uQ29ubmVjdFVJMi53YWxsZXQpO1xuICAgICAgcmV0dXJuIHRvbkNvbm5lY3RVSTIub25TdGF0dXNDaGFuZ2UoKHZhbHVlKSA9PiB7XG4gICAgICAgIHNldFdhbGxldCh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFt0b25Db25uZWN0VUkyXSk7XG4gIHJldHVybiB3YWxsZXQ7XG59XG5mdW5jdGlvbiB1c2VUb25BZGRyZXNzKHVzZXJGcmllbmRseSA9IHRydWUpIHtcbiAgY29uc3Qgd2FsbGV0ID0gdXNlVG9uV2FsbGV0KCk7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAod2FsbGV0KSB7XG4gICAgICByZXR1cm4gdXNlckZyaWVuZGx5ID8gdG9Vc2VyRnJpZW5kbHlBZGRyZXNzKFxuICAgICAgICB3YWxsZXQuYWNjb3VudC5hZGRyZXNzLFxuICAgICAgICB3YWxsZXQuYWNjb3VudC5jaGFpbiA9PT0gQ0hBSU4uVEVTVE5FVFxuICAgICAgKSA6IHdhbGxldC5hY2NvdW50LmFkZHJlc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgfSwgW3dhbGxldCwgdXNlckZyaWVuZGx5LCB3YWxsZXQgPT0gbnVsbCA/IHZvaWQgMCA6IHdhbGxldC5hY2NvdW50LmFkZHJlc3MsIHdhbGxldCA9PSBudWxsID8gdm9pZCAwIDogd2FsbGV0LmFjY291bnQuY2hhaW5dKTtcbn1cbmZ1bmN0aW9uIHVzZVRvbkNvbm5lY3RNb2RhbCgpIHtcbiAgY29uc3QgW3RvbkNvbm5lY3RVSTJdID0gdXNlVG9uQ29ubmVjdFVJKCk7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUoKHRvbkNvbm5lY3RVSTIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvbkNvbm5lY3RVSTIubW9kYWwuc3RhdGUpIHx8IG51bGwpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0b25Db25uZWN0VUkyKSB7XG4gICAgICBzZXRTdGF0ZSh0b25Db25uZWN0VUkyLm1vZGFsLnN0YXRlKTtcbiAgICAgIHJldHVybiB0b25Db25uZWN0VUkyLm9uTW9kYWxTdGF0ZUNoYW5nZSgodmFsdWUpID0+IHtcbiAgICAgICAgc2V0U3RhdGUodmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBbdG9uQ29ubmVjdFVJMl0pO1xuICByZXR1cm4ge1xuICAgIHN0YXRlLFxuICAgIG9wZW46ICgpID0+IHRvbkNvbm5lY3RVSTIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvbkNvbm5lY3RVSTIubW9kYWwub3BlbigpLFxuICAgIGNsb3NlOiAoKSA9PiB0b25Db25uZWN0VUkyID09IG51bGwgPyB2b2lkIDAgOiB0b25Db25uZWN0VUkyLm1vZGFsLmNsb3NlKClcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUlzQ29ubmVjdGlvblJlc3RvcmVkKCkge1xuICBjb25zdCBbcmVzdG9yZWQsIHNldFJlc3RvcmVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3RvbkNvbm5lY3RVSTJdID0gdXNlVG9uQ29ubmVjdFVJKCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHRvbkNvbm5lY3RVSTIpIHtcbiAgICAgIHRvbkNvbm5lY3RVSTIuY29ubmVjdGlvblJlc3RvcmVkLnRoZW4oKCkgPT4gc2V0UmVzdG9yZWQodHJ1ZSkpO1xuICAgIH1cbiAgfSwgW3RvbkNvbm5lY3RVSTJdKTtcbiAgcmV0dXJuIHJlc3RvcmVkO1xufVxuZXhwb3J0IHtcbiAgVG9uQ29ubmVjdEJ1dHRvbiQxIGFzIFRvbkNvbm5lY3RCdXR0b24sXG4gIFRvbkNvbm5lY3RQcm92aWRlck5vdFNldEVycm9yLFxuICBUb25Db25uZWN0VUlDb250ZXh0LFxuICBUb25Db25uZWN0VUlQcm92aWRlciQxIGFzIFRvbkNvbm5lY3RVSVByb3ZpZGVyLFxuICBUb25Db25uZWN0VUlSZWFjdEVycm9yLFxuICB1c2VJc0Nvbm5lY3Rpb25SZXN0b3JlZCxcbiAgdXNlVG9uQWRkcmVzcyxcbiAgdXNlVG9uQ29ubmVjdE1vZGFsLFxuICB1c2VUb25Db25uZWN0VUksXG4gIHVzZVRvbldhbGxldFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tonconnect/ui-react/lib/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tonconnect/ui/lib/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@tonconnect/ui/lib/index.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BadRequestError: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.BadRequestError; },\n/* harmony export */   BrowserEventDispatcher: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.BrowserEventDispatcher; },\n/* harmony export */   CHAIN: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.CHAIN; },\n/* harmony export */   CONNECT_EVENT_ERROR_CODES: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES; },\n/* harmony export */   CONNECT_ITEM_ERROR_CODES: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.CONNECT_ITEM_ERROR_CODES; },\n/* harmony export */   FetchWalletsError: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.FetchWalletsError; },\n/* harmony export */   LocalstorageNotFoundError: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.LocalstorageNotFoundError; },\n/* harmony export */   ParseHexError: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.ParseHexError; },\n/* harmony export */   SEND_TRANSACTION_ERROR_CODES: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES; },\n/* harmony export */   SIGN_DATA_ERROR_CODES: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.SIGN_DATA_ERROR_CODES; },\n/* harmony export */   SessionCrypto: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.SessionCrypto; },\n/* harmony export */   THEME: function() { return /* binding */ THEME; },\n/* harmony export */   TonConnect: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnect; },\n/* harmony export */   TonConnectError: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnectError; },\n/* harmony export */   TonConnectUI: function() { return /* binding */ TonConnectUI; },\n/* harmony export */   TonConnectUIError: function() { return /* binding */ TonConnectUIError; },\n/* harmony export */   UUIDv7: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.UUIDv7; },\n/* harmony export */   UnknownAppError: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.UnknownAppError; },\n/* harmony export */   UnknownError: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.UnknownError; },\n/* harmony export */   UserRejectsError: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.UserRejectsError; },\n/* harmony export */   WalletAlreadyConnectedError: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletAlreadyConnectedError; },\n/* harmony export */   WalletMissingRequiredFeaturesError: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletMissingRequiredFeaturesError; },\n/* harmony export */   WalletNotConnectedError: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletNotConnectedError; },\n/* harmony export */   WalletNotInjectedError: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletNotInjectedError; },\n/* harmony export */   WalletNotSupportFeatureError: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletNotSupportFeatureError; },\n/* harmony export */   WalletWrongNetworkError: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletWrongNetworkError; },\n/* harmony export */   WalletsListManager: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletsListManager; },\n/* harmony export */   WrongAddressError: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WrongAddressError; },\n/* harmony export */   checkRequiredWalletFeatures: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.checkRequiredWalletFeatures; },\n/* harmony export */   createConnectionCompletedEvent: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionCompletedEvent; },\n/* harmony export */   createConnectionErrorEvent: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionErrorEvent; },\n/* harmony export */   createConnectionRestoringCompletedEvent: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionRestoringCompletedEvent; },\n/* harmony export */   createConnectionRestoringErrorEvent: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionRestoringErrorEvent; },\n/* harmony export */   createConnectionRestoringStartedEvent: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionRestoringStartedEvent; },\n/* harmony export */   createConnectionStartedEvent: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionStartedEvent; },\n/* harmony export */   createDataSentForSignatureEvent: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createDataSentForSignatureEvent; },\n/* harmony export */   createDataSignedEvent: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createDataSignedEvent; },\n/* harmony export */   createDataSigningFailedEvent: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createDataSigningFailedEvent; },\n/* harmony export */   createDisconnectionEvent: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createDisconnectionEvent; },\n/* harmony export */   createRequestVersionEvent: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createRequestVersionEvent; },\n/* harmony export */   createResponseVersionEvent: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createResponseVersionEvent; },\n/* harmony export */   createSelectedWalletEvent: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createSelectedWalletEvent; },\n/* harmony export */   createTransactionSentForSignatureEvent: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createTransactionSentForSignatureEvent; },\n/* harmony export */   createTransactionSignedEvent: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createTransactionSignedEvent; },\n/* harmony export */   createTransactionSigningFailedEvent: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createTransactionSigningFailedEvent; },\n/* harmony export */   createVersionInfo: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createVersionInfo; },\n/* harmony export */   createWalletModalOpenedEvent: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createWalletModalOpenedEvent; },\n/* harmony export */   decodeTelegramUrlParameters: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.decodeTelegramUrlParameters; },\n/* harmony export */   enableQaMode: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.enableQaMode; },\n/* harmony export */   encodeTelegramUrlParameters: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.encodeTelegramUrlParameters; },\n/* harmony export */   initializeWalletConnect: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.initializeWalletConnect; },\n/* harmony export */   isConnectUrl: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isConnectUrl; },\n/* harmony export */   isQaModeEnabled: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isQaModeEnabled; },\n/* harmony export */   isTelegramUrl: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isTelegramUrl; },\n/* harmony export */   isWalletConnectInitialized: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletConnectInitialized; },\n/* harmony export */   isWalletInfoCurrentlyEmbedded: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyEmbedded; },\n/* harmony export */   isWalletInfoCurrentlyInjected: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyInjected; },\n/* harmony export */   isWalletInfoInjectable: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoInjectable; },\n/* harmony export */   isWalletInfoInjected: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoInjected; },\n/* harmony export */   isWalletInfoRemote: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoRemote; },\n/* harmony export */   toUserFriendlyAddress: function() { return /* reexport safe */ _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.toUserFriendlyAddress; }\n/* harmony export */ });\n/* harmony import */ var _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tonconnect/sdk */ \"(app-pages-browser)/./node_modules/@tonconnect/sdk/lib/esm/index.mjs\");\n/* harmony import */ var ua_parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ua-parser-js */ \"(app-pages-browser)/./node_modules/ua-parser-js/src/ua-parser.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! deepmerge */ \"(app-pages-browser)/./node_modules/deepmerge/dist/cjs.js\");\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! classnames */ \"(app-pages-browser)/./node_modules/classnames/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a2, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a2, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a2, prop, b[prop]);\n    }\n  return a2;\n};\nvar __spreadProps = (a2, b) => __defProps(a2, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e2) {\n        reject(e2);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e2) {\n        reject(e2);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar _a, _b, _c, _d, _e, _f, _g, _h;\n\n\n\n\n\nconst IS_DEV = false;\nconst equalFn = (a2, b) => a2 === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst SUPPORTS_PROXY = typeof Proxy === \"function\";\nconst $TRACK = Symbol(\"solid-track\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet runEffects = runQueue;\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst NO_INIT = {};\nvar Owner = null;\nlet Transition$1 = null;\nlet ExternalSourceConfig = null;\nlet Listener = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nfunction createRoot(fn, detachedOwner) {\n  const listener = Listener, owner = Owner, unowned = fn.length === 0, current = detachedOwner === void 0 ? owner : detachedOwner, root = unowned ? UNOWNED : {\n    owned: null,\n    cleanups: null,\n    context: current ? current.context : null,\n    owner: current\n  }, updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));\n  Owner = root;\n  Listener = null;\n  try {\n    return runUpdates(updateFn, true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s2 = {\n    value,\n    observers: null,\n    observerSlots: null,\n    comparator: options.equals || void 0\n  };\n  const setter = (value2) => {\n    if (typeof value2 === \"function\") {\n      value2 = value2(s2.value);\n    }\n    return writeSignal(s2, value2);\n  };\n  return [readSignal.bind(s2), setter];\n}\nfunction createComputed(fn, value, options) {\n  const c2 = createComputation(fn, value, true, STALE);\n  updateComputation(c2);\n}\nfunction createRenderEffect(fn, value, options) {\n  const c2 = createComputation(fn, value, false, STALE);\n  updateComputation(c2);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c2 = createComputation(fn, value, false, STALE);\n  if (!options || !options.render) c2.user = true;\n  Effects ? Effects.push(c2) : updateComputation(c2);\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c2 = createComputation(fn, value, true, 0);\n  c2.observers = null;\n  c2.observerSlots = null;\n  c2.comparator = options.equals || void 0;\n  updateComputation(c2);\n  return readSignal.bind(c2);\n}\nfunction isPromise(v) {\n  return v && typeof v === \"object\" && \"then\" in v;\n}\nfunction createResource(pSource, pFetcher, pOptions) {\n  let source;\n  let fetcher;\n  let options;\n  {\n    source = true;\n    fetcher = pSource;\n    options = {};\n  }\n  let pr = null, initP = NO_INIT, scheduled = false, resolved = \"initialValue\" in options, dynamic = typeof source === \"function\" && createMemo(source);\n  const contexts = /* @__PURE__ */ new Set(), [value, setValue] = (options.storage || createSignal)(options.initialValue), [error, setError] = createSignal(void 0), [track, trigger] = createSignal(void 0, {\n    equals: false\n  }), [state, setState] = createSignal(resolved ? \"ready\" : \"unresolved\");\n  function loadEnd(p2, v, error2, key) {\n    if (pr === p2) {\n      pr = null;\n      key !== void 0 && (resolved = true);\n      if ((p2 === initP || v === initP) && options.onHydrated) queueMicrotask(() => options.onHydrated(key, {\n        value: v\n      }));\n      initP = NO_INIT;\n      completeLoad(v, error2);\n    }\n    return v;\n  }\n  function completeLoad(v, err) {\n    runUpdates(() => {\n      if (err === void 0) setValue(() => v);\n      setState(err !== void 0 ? \"errored\" : resolved ? \"ready\" : \"unresolved\");\n      setError(err);\n      for (const c2 of contexts.keys()) c2.decrement();\n      contexts.clear();\n    }, false);\n  }\n  function read() {\n    const c2 = SuspenseContext, v = value(), err = error();\n    if (err !== void 0 && !pr) throw err;\n    if (Listener && !Listener.user && c2) ;\n    return v;\n  }\n  function load(refetching = true) {\n    if (refetching !== false && scheduled) return;\n    scheduled = false;\n    const lookup = dynamic ? dynamic() : source;\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(value));\n      return;\n    }\n    let error2;\n    const p2 = initP !== NO_INIT ? initP : untrack(() => {\n      try {\n        return fetcher(lookup, {\n          value: value(),\n          refetching\n        });\n      } catch (fetcherError) {\n        error2 = fetcherError;\n      }\n    });\n    if (error2 !== void 0) {\n      loadEnd(pr, void 0, castError(error2), lookup);\n      return;\n    } else if (!isPromise(p2)) {\n      loadEnd(pr, p2, void 0, lookup);\n      return p2;\n    }\n    pr = p2;\n    if (\"v\" in p2) {\n      if (p2.s === 1) loadEnd(pr, p2.v, void 0, lookup);\n      else loadEnd(pr, void 0, castError(p2.v), lookup);\n      return p2;\n    }\n    scheduled = true;\n    queueMicrotask(() => scheduled = false);\n    runUpdates(() => {\n      setState(resolved ? \"refreshing\" : \"pending\");\n      trigger();\n    }, false);\n    return p2.then((v) => loadEnd(p2, v, void 0, lookup), (e2) => loadEnd(p2, void 0, castError(e2), lookup));\n  }\n  Object.defineProperties(read, {\n    state: {\n      get: () => state()\n    },\n    error: {\n      get: () => error()\n    },\n    loading: {\n      get() {\n        const s2 = state();\n        return s2 === \"pending\" || s2 === \"refreshing\";\n      }\n    },\n    latest: {\n      get() {\n        if (!resolved) return read();\n        const err = error();\n        if (err && !pr) throw err;\n        return value();\n      }\n    }\n  });\n  let owner = Owner;\n  if (dynamic) createComputed(() => (owner = Owner, load(false)));\n  else load(false);\n  return [read, {\n    refetch: (info) => runWithOwner(owner, () => load(info)),\n    mutate: setValue\n  }];\n}\nfunction batch(fn) {\n  return runUpdates(fn, false);\n}\nfunction untrack(fn) {\n  if (Listener === null) return fn();\n  const listener = Listener;\n  Listener = null;\n  try {\n    if (ExternalSourceConfig) ;\n    return fn();\n  } finally {\n    Listener = listener;\n  }\n}\nfunction on(deps, fn, options) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  return (prevValue) => {\n    let input;\n    if (isArray) {\n      input = Array(deps.length);\n      for (let i2 = 0; i2 < deps.length; i2++) input[i2] = deps[i2]();\n    } else input = deps();\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null) ;\n  else if (Owner.cleanups === null) Owner.cleanups = [fn];\n  else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction getListener() {\n  return Listener;\n}\nfunction getOwner() {\n  return Owner;\n}\nfunction runWithOwner(o2, fn) {\n  const prev = Owner;\n  const prevListener = Listener;\n  Owner = o2;\n  Listener = null;\n  try {\n    return runUpdates(fn, true);\n  } catch (err) {\n    handleError(err);\n  } finally {\n    Owner = prev;\n    Listener = prevListener;\n  }\n}\nfunction startTransition(fn) {\n  const l2 = Listener;\n  const o2 = Owner;\n  return Promise.resolve().then(() => {\n    Listener = l2;\n    Owner = o2;\n    runUpdates(fn, false);\n    Listener = Owner = null;\n    return void 0;\n  });\n}\nconst [transPending, setTransPending] = /* @__PURE__ */ createSignal(false);\nfunction useTransition() {\n  return [transPending, startTransition];\n}\nfunction createContext(defaultValue, options) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\nfunction useContext(context) {\n  let value;\n  return Owner && Owner.context && (value = Owner.context[context.id]) !== void 0 ? value : context.defaultValue;\n}\nfunction children(fn) {\n  const children2 = createMemo(fn);\n  const memo2 = createMemo(() => resolveChildren(children2()));\n  memo2.toArray = () => {\n    const c2 = memo2();\n    return Array.isArray(c2) ? c2 : c2 != null ? [c2] : [];\n  };\n  return memo2;\n}\nlet SuspenseContext;\nfunction readSignal() {\n  if (this.sources && this.state) {\n    if (this.state === STALE) updateComputation(this);\n    else {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(this), false);\n      Updates = updates;\n    }\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  let current = node.value;\n  if (!node.comparator || !node.comparator(current, value)) {\n    node.value = value;\n    if (node.observers && node.observers.length) {\n      runUpdates(() => {\n        for (let i2 = 0; i2 < node.observers.length; i2 += 1) {\n          const o2 = node.observers[i2];\n          const TransitionRunning = Transition$1 && Transition$1.running;\n          if (TransitionRunning && Transition$1.disposed.has(o2)) ;\n          if (TransitionRunning ? !o2.tState : !o2.state) {\n            if (o2.pure) Updates.push(o2);\n            else Effects.push(o2);\n            if (o2.observers) markDownstream(o2);\n          }\n          if (!TransitionRunning) o2.state = STALE;\n        }\n        if (Updates.length > 1e6) {\n          Updates = [];\n          if (IS_DEV) ;\n          throw new Error();\n        }\n      }, false);\n    }\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const time = ExecCount;\n  runComputation(node, node.value, time);\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  const owner = Owner, listener = Listener;\n  Listener = Owner = node;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    if (node.pure) {\n      {\n        node.state = STALE;\n        node.owned && node.owned.forEach(cleanNode);\n        node.owned = null;\n      }\n    }\n    node.updatedAt = time + 1;\n    return handleError(err);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.updatedAt != null && \"observers\" in node) {\n      writeSignal(node, nextValue);\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c2 = {\n    fn,\n    state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: Owner ? Owner.context : null,\n    pure\n  };\n  if (Owner === null) ;\n  else if (Owner !== UNOWNED) {\n    {\n      if (!Owner.owned) Owner.owned = [c2];\n      else Owner.owned.push(c2);\n    }\n  }\n  return c2;\n}\nfunction runTop(node) {\n  if (node.state === 0) return;\n  if (node.state === PENDING) return lookUpstream(node);\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (node.state) ancestors.push(node);\n  }\n  for (let i2 = ancestors.length - 1; i2 >= 0; i2--) {\n    node = ancestors[i2];\n    if (node.state === STALE) {\n      updateComputation(node);\n    } else if (node.state === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(node, ancestors[0]), false);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;\n  else Effects = [];\n  ExecCount++;\n  try {\n    const res = fn();\n    completeUpdates(wait);\n    return res;\n  } catch (err) {\n    if (!wait) Effects = null;\n    Updates = null;\n    handleError(err);\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  const e2 = Effects;\n  Effects = null;\n  if (e2.length) runUpdates(() => runEffects(e2), false);\n}\nfunction runQueue(queue) {\n  for (let i2 = 0; i2 < queue.length; i2++) runTop(queue[i2]);\n}\nfunction runUserEffects(queue) {\n  let i2, userLength = 0;\n  for (i2 = 0; i2 < queue.length; i2++) {\n    const e2 = queue[i2];\n    if (!e2.user) runTop(e2);\n    else queue[userLength++] = e2;\n  }\n  for (i2 = 0; i2 < userLength; i2++) runTop(queue[i2]);\n}\nfunction lookUpstream(node, ignore) {\n  node.state = 0;\n  for (let i2 = 0; i2 < node.sources.length; i2 += 1) {\n    const source = node.sources[i2];\n    if (source.sources) {\n      const state = source.state;\n      if (state === STALE) {\n        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);\n      } else if (state === PENDING) lookUpstream(source, ignore);\n    }\n  }\n}\nfunction markDownstream(node) {\n  for (let i2 = 0; i2 < node.observers.length; i2 += 1) {\n    const o2 = node.observers[i2];\n    if (!o2.state) {\n      o2.state = PENDING;\n      if (o2.pure) Updates.push(o2);\n      else Effects.push(o2);\n      o2.observers && markDownstream(o2);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i2;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;\n      if (obs && obs.length) {\n        const n2 = obs.pop(), s2 = source.observerSlots.pop();\n        if (index < obs.length) {\n          n2.sourceSlots[s2] = index;\n          obs[index] = n2;\n          source.observerSlots[index] = s2;\n        }\n      }\n    }\n  }\n  if (node.tOwned) {\n    for (i2 = node.tOwned.length - 1; i2 >= 0; i2--) cleanNode(node.tOwned[i2]);\n    delete node.tOwned;\n  }\n  if (node.owned) {\n    for (i2 = node.owned.length - 1; i2 >= 0; i2--) cleanNode(node.owned[i2]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i2 = node.cleanups.length - 1; i2 >= 0; i2--) node.cleanups[i2]();\n    node.cleanups = null;\n  }\n  node.state = 0;\n}\nfunction castError(err) {\n  if (err instanceof Error) return err;\n  return new Error(typeof err === \"string\" ? err : \"Unknown error\", {\n    cause: err\n  });\n}\nfunction handleError(err, owner = Owner) {\n  const error = castError(err);\n  throw error;\n}\nfunction resolveChildren(children2) {\n  if (typeof children2 === \"function\" && !children2.length) return resolveChildren(children2());\n  if (Array.isArray(children2)) {\n    const results = [];\n    for (let i2 = 0; i2 < children2.length; i2++) {\n      const result = resolveChildren(children2[i2]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children2;\n}\nfunction createProvider(id, options) {\n  return function provider(props) {\n    let res;\n    createRenderEffect(() => res = untrack(() => {\n      Owner.context = __spreadProps(__spreadValues({}, Owner.context), {\n        [id]: props.value\n      });\n      return children(() => props.children);\n    }), void 0);\n    return res;\n  };\n}\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i2 = 0; i2 < d.length; i2++) d[i2]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [], mapped = [], disposers = [], len = 0, indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [], newLen = newItems.length, i2, j;\n    newItems[$TRACK];\n    return untrack(() => {\n      let newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start, end, newEnd, item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot((disposer) => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      } else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++) ;\n        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = /* @__PURE__ */ new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i2 = newIndices.get(item);\n          newIndicesNext[j] = i2 === void 0 ? -1 : i2;\n          newIndices.set(item, j);\n        }\n        for (i2 = start; i2 <= end; i2++) {\n          item = items[i2];\n          j = newIndices.get(item);\n          if (j !== void 0 && j !== -1) {\n            temp[j] = mapped[i2];\n            tempdisposers[j] = disposers[i2];\n            indexes && (tempIndexes[j] = indexes[i2]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i2]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, len = newLen);\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s2, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s2);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction createComponent(Comp, props) {\n  return untrack(() => Comp(props || {}));\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    if (property === $PROXY) return true;\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s2) {\n  return !(s2 = typeof s2 === \"function\" ? s2() : s2) ? {} : s2;\n}\nfunction resolveSources() {\n  for (let i2 = 0, length = this.length; i2 < length; ++i2) {\n    const v = this[i2]();\n    if (v !== void 0) return v;\n  }\n}\nfunction mergeProps(...sources) {\n  let proxy = false;\n  for (let i2 = 0; i2 < sources.length; i2++) {\n    const s2 = sources[i2];\n    proxy = proxy || !!s2 && $PROXY in s2;\n    sources[i2] = typeof s2 === \"function\" ? (proxy = true, createMemo(s2)) : s2;\n  }\n  if (SUPPORTS_PROXY && proxy) {\n    return new Proxy({\n      get(property) {\n        for (let i2 = sources.length - 1; i2 >= 0; i2--) {\n          const v = resolveSource(sources[i2])[property];\n          if (v !== void 0) return v;\n        }\n      },\n      has(property) {\n        for (let i2 = sources.length - 1; i2 >= 0; i2--) {\n          if (property in resolveSource(sources[i2])) return true;\n        }\n        return false;\n      },\n      keys() {\n        const keys = [];\n        for (let i2 = 0; i2 < sources.length; i2++) keys.push(...Object.keys(resolveSource(sources[i2])));\n        return [...new Set(keys)];\n      }\n    }, propTraps);\n  }\n  const sourcesMap = {};\n  const defined = /* @__PURE__ */ Object.create(null);\n  for (let i2 = sources.length - 1; i2 >= 0; i2--) {\n    const source = sources[i2];\n    if (!source) continue;\n    const sourceKeys = Object.getOwnPropertyNames(source);\n    for (let i3 = sourceKeys.length - 1; i3 >= 0; i3--) {\n      const key = sourceKeys[i3];\n      if (key === \"__proto__\" || key === \"constructor\") continue;\n      const desc = Object.getOwnPropertyDescriptor(source, key);\n      if (!defined[key]) {\n        defined[key] = desc.get ? {\n          enumerable: true,\n          configurable: true,\n          get: resolveSources.bind(sourcesMap[key] = [desc.get.bind(source)])\n        } : desc.value !== void 0 ? desc : void 0;\n      } else {\n        const sources2 = sourcesMap[key];\n        if (sources2) {\n          if (desc.get) sources2.push(desc.get.bind(source));\n          else if (desc.value !== void 0) sources2.push(() => desc.value);\n        }\n      }\n    }\n  }\n  const target = {};\n  const definedKeys = Object.keys(defined);\n  for (let i2 = definedKeys.length - 1; i2 >= 0; i2--) {\n    const key = definedKeys[i2], desc = defined[key];\n    if (desc && desc.get) Object.defineProperty(target, key, desc);\n    else target[key] = desc ? desc.value : void 0;\n  }\n  return target;\n}\nfunction splitProps(props, ...keys) {\n  if (SUPPORTS_PROXY && $PROXY in props) {\n    const blocked = new Set(keys.length > 1 ? keys.flat() : keys[0]);\n    const res = keys.map((k) => {\n      return new Proxy({\n        get(property) {\n          return k.includes(property) ? props[property] : void 0;\n        },\n        has(property) {\n          return k.includes(property) && property in props;\n        },\n        keys() {\n          return k.filter((property) => property in props);\n        }\n      }, propTraps);\n    });\n    res.push(new Proxy({\n      get(property) {\n        return blocked.has(property) ? void 0 : props[property];\n      },\n      has(property) {\n        return blocked.has(property) ? false : property in props;\n      },\n      keys() {\n        return Object.keys(props).filter((k) => !blocked.has(k));\n      }\n    }, propTraps));\n    return res;\n  }\n  const otherObject = {};\n  const objects = keys.map(() => ({}));\n  for (const propName of Object.getOwnPropertyNames(props)) {\n    const desc = Object.getOwnPropertyDescriptor(props, propName);\n    const isDefaultDesc = !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;\n    let blocked = false;\n    let objectIndex = 0;\n    for (const k of keys) {\n      if (k.includes(propName)) {\n        blocked = true;\n        isDefaultDesc ? objects[objectIndex][propName] = desc.value : Object.defineProperty(objects[objectIndex], propName, desc);\n      }\n      ++objectIndex;\n    }\n    if (!blocked) {\n      isDefaultDesc ? otherObject[propName] = desc.value : Object.defineProperty(otherObject, propName, desc);\n    }\n  }\n  return [...objects, otherObject];\n}\nconst narrowedError = (name) => `Stale read from <${name}>.`;\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback || void 0));\n}\nfunction Show(props) {\n  const keyed = props.keyed;\n  const conditionValue = createMemo(() => props.when, void 0, void 0);\n  const condition = keyed ? conditionValue : createMemo(conditionValue, void 0, {\n    equals: (a2, b) => !a2 === !b\n  });\n  return createMemo(() => {\n    const c2 = condition();\n    if (c2) {\n      const child = props.children;\n      const fn = typeof child === \"function\" && child.length > 0;\n      return fn ? untrack(() => child(keyed ? c2 : () => {\n        if (!untrack(condition)) throw narrowedError(\"Show\");\n        return conditionValue();\n      })) : child;\n    }\n    return props.fallback;\n  }, void 0, void 0);\n}\nfunction Switch(props) {\n  const chs = children(() => props.children);\n  const switchFunc = createMemo(() => {\n    const ch = chs();\n    const mps = Array.isArray(ch) ? ch : [ch];\n    let func = () => void 0;\n    for (let i2 = 0; i2 < mps.length; i2++) {\n      const index = i2;\n      const mp = mps[i2];\n      const prevFunc = func;\n      const conditionValue = createMemo(() => prevFunc() ? void 0 : mp.when, void 0, void 0);\n      const condition = mp.keyed ? conditionValue : createMemo(conditionValue, void 0, {\n        equals: (a2, b) => !a2 === !b\n      });\n      func = () => prevFunc() || (condition() ? [index, conditionValue, mp] : void 0);\n    }\n    return func;\n  });\n  return createMemo(() => {\n    const sel = switchFunc()();\n    if (!sel) return props.fallback;\n    const [index, conditionValue, mp] = sel;\n    const child = mp.children;\n    const fn = typeof child === \"function\" && child.length > 0;\n    return fn ? untrack(() => child(mp.keyed ? conditionValue() : () => {\n      var _a2;\n      if (((_a2 = untrack(switchFunc)()) == null ? void 0 : _a2[0]) !== index) throw narrowedError(\"Match\");\n      return conditionValue();\n    })) : child;\n  }, void 0, void 0);\n}\nfunction Match(props) {\n  return props;\n}\nconst booleans = [\"allowfullscreen\", \"async\", \"autofocus\", \"autoplay\", \"checked\", \"controls\", \"default\", \"disabled\", \"formnovalidate\", \"hidden\", \"indeterminate\", \"inert\", \"ismap\", \"loop\", \"multiple\", \"muted\", \"nomodule\", \"novalidate\", \"open\", \"playsinline\", \"readonly\", \"required\", \"reversed\", \"seamless\", \"selected\"];\nconst Properties = /* @__PURE__ */ new Set([\"className\", \"value\", \"readOnly\", \"noValidate\", \"formNoValidate\", \"isMap\", \"noModule\", \"playsInline\", ...booleans]);\nconst ChildProperties = /* @__PURE__ */ new Set([\"innerHTML\", \"textContent\", \"innerText\", \"children\"]);\nconst Aliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {\n  className: \"class\",\n  htmlFor: \"for\"\n});\nconst PropAliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {\n  class: \"className\",\n  novalidate: {\n    $: \"noValidate\",\n    FORM: 1\n  },\n  formnovalidate: {\n    $: \"formNoValidate\",\n    BUTTON: 1,\n    INPUT: 1\n  },\n  ismap: {\n    $: \"isMap\",\n    IMG: 1\n  },\n  nomodule: {\n    $: \"noModule\",\n    SCRIPT: 1\n  },\n  playsinline: {\n    $: \"playsInline\",\n    VIDEO: 1\n  },\n  readonly: {\n    $: \"readOnly\",\n    INPUT: 1,\n    TEXTAREA: 1\n  }\n});\nfunction getPropAlias(prop, tagName) {\n  const a2 = PropAliases[prop];\n  return typeof a2 === \"object\" ? a2[tagName] ? a2[\"$\"] : void 0 : a2;\n}\nconst DelegatedEvents = /* @__PURE__ */ new Set([\"beforeinput\", \"click\", \"dblclick\", \"contextmenu\", \"focusin\", \"focusout\", \"input\", \"keydown\", \"keyup\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\", \"mouseup\", \"pointerdown\", \"pointermove\", \"pointerout\", \"pointerover\", \"pointerup\", \"touchend\", \"touchmove\", \"touchstart\"]);\nconst SVGElements = /* @__PURE__ */ new Set([\n  \"altGlyph\",\n  \"altGlyphDef\",\n  \"altGlyphItem\",\n  \"animate\",\n  \"animateColor\",\n  \"animateMotion\",\n  \"animateTransform\",\n  \"circle\",\n  \"clipPath\",\n  \"color-profile\",\n  \"cursor\",\n  \"defs\",\n  \"desc\",\n  \"ellipse\",\n  \"feBlend\",\n  \"feColorMatrix\",\n  \"feComponentTransfer\",\n  \"feComposite\",\n  \"feConvolveMatrix\",\n  \"feDiffuseLighting\",\n  \"feDisplacementMap\",\n  \"feDistantLight\",\n  \"feDropShadow\",\n  \"feFlood\",\n  \"feFuncA\",\n  \"feFuncB\",\n  \"feFuncG\",\n  \"feFuncR\",\n  \"feGaussianBlur\",\n  \"feImage\",\n  \"feMerge\",\n  \"feMergeNode\",\n  \"feMorphology\",\n  \"feOffset\",\n  \"fePointLight\",\n  \"feSpecularLighting\",\n  \"feSpotLight\",\n  \"feTile\",\n  \"feTurbulence\",\n  \"filter\",\n  \"font\",\n  \"font-face\",\n  \"font-face-format\",\n  \"font-face-name\",\n  \"font-face-src\",\n  \"font-face-uri\",\n  \"foreignObject\",\n  \"g\",\n  \"glyph\",\n  \"glyphRef\",\n  \"hkern\",\n  \"image\",\n  \"line\",\n  \"linearGradient\",\n  \"marker\",\n  \"mask\",\n  \"metadata\",\n  \"missing-glyph\",\n  \"mpath\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"radialGradient\",\n  \"rect\",\n  \"set\",\n  \"stop\",\n  \"svg\",\n  \"switch\",\n  \"symbol\",\n  \"text\",\n  \"textPath\",\n  \"tref\",\n  \"tspan\",\n  \"use\",\n  \"view\",\n  \"vkern\"\n]);\nconst SVGNamespace = {\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\"\n};\nconst memo = (fn) => createMemo(() => fn());\nfunction reconcileArrays(parentNode, a2, b) {\n  let bLength = b.length, aEnd = a2.length, bEnd = bLength, aStart = 0, bStart = 0, after = a2[aEnd - 1].nextSibling, map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    if (a2[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n      continue;\n    }\n    while (a2[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    if (aEnd === aStart) {\n      const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;\n      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);\n    } else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        if (!map || !map.has(a2[aStart])) a2[aStart].remove();\n        aStart++;\n      }\n    } else if (a2[aStart] === b[bEnd - 1] && b[bStart] === a2[aEnd - 1]) {\n      const node = a2[--aEnd].nextSibling;\n      parentNode.insertBefore(b[bStart++], a2[aStart++].nextSibling);\n      parentNode.insertBefore(b[--bEnd], node);\n      a2[aEnd] = b[bEnd];\n    } else {\n      if (!map) {\n        map = /* @__PURE__ */ new Map();\n        let i2 = bStart;\n        while (i2 < bEnd) map.set(b[i2], i2++);\n      }\n      const index = map.get(a2[aStart]);\n      if (index != null) {\n        if (bStart < index && index < bEnd) {\n          let i2 = aStart, sequence = 1, t2;\n          while (++i2 < aEnd && i2 < bEnd) {\n            if ((t2 = map.get(a2[i2])) == null || t2 !== index + sequence) break;\n            sequence++;\n          }\n          if (sequence > index - bStart) {\n            const node = a2[aStart];\n            while (bStart < index) parentNode.insertBefore(b[bStart++], node);\n          } else parentNode.replaceChild(b[bStart++], a2[aStart++]);\n        } else aStart++;\n      } else a2[aStart++].remove();\n    }\n  }\n}\nconst $$EVENTS = \"_$DX_DELEGATE\";\nfunction render(code, element, init, options = {}) {\n  let disposer;\n  createRoot((dispose2) => {\n    disposer = dispose2;\n    element === document ? code() : insert(element, code(), element.firstChild ? null : void 0, init);\n  }, options.owner);\n  return () => {\n    disposer();\n    element.textContent = \"\";\n  };\n}\nfunction template$1(html, isImportNode, isSVG, isMathML) {\n  let node;\n  const create = () => {\n    const t2 = isMathML ? document.createElementNS(\"http://www.w3.org/1998/Math/MathML\", \"template\") : document.createElement(\"template\");\n    t2.innerHTML = html;\n    return isSVG ? t2.content.firstChild.firstChild : isMathML ? t2.firstChild : t2.content.firstChild;\n  };\n  const fn = isImportNode ? () => untrack(() => document.importNode(node || (node = create()), true)) : () => (node || (node = create())).cloneNode(true);\n  fn.cloneNode = fn;\n  return fn;\n}\nfunction delegateEvents(eventNames, document2 = window.document) {\n  const e2 = document2[$$EVENTS] || (document2[$$EVENTS] = /* @__PURE__ */ new Set());\n  for (let i2 = 0, l2 = eventNames.length; i2 < l2; i2++) {\n    const name = eventNames[i2];\n    if (!e2.has(name)) {\n      e2.add(name);\n      document2.addEventListener(name, eventHandler);\n    }\n  }\n}\nfunction setAttribute(node, name, value) {\n  if (value == null) node.removeAttribute(name);\n  else node.setAttribute(name, value);\n}\nfunction setAttributeNS(node, namespace, name, value) {\n  if (value == null) node.removeAttributeNS(namespace, name);\n  else node.setAttributeNS(namespace, name, value);\n}\nfunction setBoolAttribute(node, name, value) {\n  value ? node.setAttribute(name, \"\") : node.removeAttribute(name);\n}\nfunction className(node, value) {\n  if (value == null) node.removeAttribute(\"class\");\n  else node.className = value;\n}\nfunction addEventListener(node, name, handler, delegate) {\n  if (delegate) {\n    if (Array.isArray(handler)) {\n      node[`$$${name}`] = handler[0];\n      node[`$$${name}Data`] = handler[1];\n    } else node[`$$${name}`] = handler;\n  } else if (Array.isArray(handler)) {\n    const handlerFn = handler[0];\n    node.addEventListener(name, handler[0] = (e2) => handlerFn.call(node, handler[1], e2));\n  } else node.addEventListener(name, handler, typeof handler !== \"function\" && handler);\n}\nfunction classList(node, value, prev = {}) {\n  const classKeys = Object.keys(value || {}), prevKeys = Object.keys(prev);\n  let i2, len;\n  for (i2 = 0, len = prevKeys.length; i2 < len; i2++) {\n    const key = prevKeys[i2];\n    if (!key || key === \"undefined\" || value[key]) continue;\n    toggleClassKey(node, key, false);\n    delete prev[key];\n  }\n  for (i2 = 0, len = classKeys.length; i2 < len; i2++) {\n    const key = classKeys[i2], classValue = !!value[key];\n    if (!key || key === \"undefined\" || prev[key] === classValue || !classValue) continue;\n    toggleClassKey(node, key, true);\n    prev[key] = classValue;\n  }\n  return prev;\n}\nfunction style(node, value, prev) {\n  if (!value) return prev ? setAttribute(node, \"style\") : value;\n  const nodeStyle = node.style;\n  if (typeof value === \"string\") return nodeStyle.cssText = value;\n  typeof prev === \"string\" && (nodeStyle.cssText = prev = void 0);\n  prev || (prev = {});\n  value || (value = {});\n  let v, s2;\n  for (s2 in prev) {\n    value[s2] == null && nodeStyle.removeProperty(s2);\n    delete prev[s2];\n  }\n  for (s2 in value) {\n    v = value[s2];\n    if (v !== prev[s2]) {\n      nodeStyle.setProperty(s2, v);\n      prev[s2] = v;\n    }\n  }\n  return prev;\n}\nfunction spread(node, props = {}, isSVG, skipChildren) {\n  const prevProps = {};\n  {\n    createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));\n  }\n  createRenderEffect(() => typeof props.ref === \"function\" && use(props.ref, node));\n  createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));\n  return prevProps;\n}\nfunction use(fn, element, arg) {\n  return untrack(() => fn(element, arg));\n}\nfunction insert(parent, accessor, marker, initial) {\n  if (marker !== void 0 && !initial) initial = [];\n  if (typeof accessor !== \"function\") return insertExpression(parent, accessor, initial, marker);\n  createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);\n}\nfunction assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {\n  props || (props = {});\n  for (const prop in prevProps) {\n    if (!(prop in props)) {\n      if (prop === \"children\") continue;\n      prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef, props);\n    }\n  }\n  for (const prop in props) {\n    if (prop === \"children\") {\n      continue;\n    }\n    const value = props[prop];\n    prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef, props);\n  }\n}\nfunction toPropertyName(name) {\n  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());\n}\nfunction toggleClassKey(node, key, value) {\n  const classNames = key.trim().split(/\\s+/);\n  for (let i2 = 0, nameLen = classNames.length; i2 < nameLen; i2++) node.classList.toggle(classNames[i2], value);\n}\nfunction assignProp(node, prop, value, prev, isSVG, skipRef, props) {\n  let isCE, isProp, isChildProp, propAlias, forceProp;\n  if (prop === \"style\") return style(node, value, prev);\n  if (prop === \"classList\") return classList(node, value, prev);\n  if (value === prev) return prev;\n  if (prop === \"ref\") {\n    if (!skipRef) value(node);\n  } else if (prop.slice(0, 3) === \"on:\") {\n    const e2 = prop.slice(3);\n    prev && node.removeEventListener(e2, prev, typeof prev !== \"function\" && prev);\n    value && node.addEventListener(e2, value, typeof value !== \"function\" && value);\n  } else if (prop.slice(0, 10) === \"oncapture:\") {\n    const e2 = prop.slice(10);\n    prev && node.removeEventListener(e2, prev, true);\n    value && node.addEventListener(e2, value, true);\n  } else if (prop.slice(0, 2) === \"on\") {\n    const name = prop.slice(2).toLowerCase();\n    const delegate = DelegatedEvents.has(name);\n    if (!delegate && prev) {\n      const h2 = Array.isArray(prev) ? prev[0] : prev;\n      node.removeEventListener(name, h2);\n    }\n    if (delegate || value) {\n      addEventListener(node, name, value, delegate);\n      delegate && delegateEvents([name]);\n    }\n  } else if (prop.slice(0, 5) === \"attr:\") {\n    setAttribute(node, prop.slice(5), value);\n  } else if (prop.slice(0, 5) === \"bool:\") {\n    setBoolAttribute(node, prop.slice(5), value);\n  } else if ((forceProp = prop.slice(0, 5) === \"prop:\") || (isChildProp = ChildProperties.has(prop)) || !isSVG && ((propAlias = getPropAlias(prop, node.tagName)) || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes(\"-\") || \"is\" in props)) {\n    if (forceProp) {\n      prop = prop.slice(5);\n      isProp = true;\n    }\n    if (prop === \"class\" || prop === \"className\") className(node, value);\n    else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;\n    else node[propAlias || prop] = value;\n  } else {\n    const ns = isSVG && prop.indexOf(\":\") > -1 && SVGNamespace[prop.split(\":\")[0]];\n    if (ns) setAttributeNS(node, ns, prop, value);\n    else setAttribute(node, Aliases[prop] || prop, value);\n  }\n  return value;\n}\nfunction eventHandler(e2) {\n  let node = e2.target;\n  const key = `$$${e2.type}`;\n  const oriTarget = e2.target;\n  const oriCurrentTarget = e2.currentTarget;\n  const retarget = (value) => Object.defineProperty(e2, \"target\", {\n    configurable: true,\n    value\n  });\n  const handleNode = () => {\n    const handler = node[key];\n    if (handler && !node.disabled) {\n      const data = node[`${key}Data`];\n      data !== void 0 ? handler.call(node, data, e2) : handler.call(node, e2);\n      if (e2.cancelBubble) return;\n    }\n    node.host && typeof node.host !== \"string\" && !node.host._$host && node.contains(e2.target) && retarget(node.host);\n    return true;\n  };\n  const walkUpTree = () => {\n    while (handleNode() && (node = node._$host || node.parentNode || node.host)) ;\n  };\n  Object.defineProperty(e2, \"currentTarget\", {\n    configurable: true,\n    get() {\n      return node || document;\n    }\n  });\n  if (e2.composedPath) {\n    const path = e2.composedPath();\n    retarget(path[0]);\n    for (let i2 = 0; i2 < path.length - 2; i2++) {\n      node = path[i2];\n      if (!handleNode()) break;\n      if (node._$host) {\n        node = node._$host;\n        walkUpTree();\n        break;\n      }\n      if (node.parentNode === oriCurrentTarget) {\n        break;\n      }\n    }\n  } else walkUpTree();\n  retarget(oriTarget);\n}\nfunction insertExpression(parent, value, current, marker, unwrapArray) {\n  while (typeof current === \"function\") current = current();\n  if (value === current) return current;\n  const t2 = typeof value, multi = marker !== void 0;\n  parent = multi && current[0] && current[0].parentNode || parent;\n  if (t2 === \"string\" || t2 === \"number\") {\n    if (t2 === \"number\") {\n      value = value.toString();\n      if (value === current) return current;\n    }\n    if (multi) {\n      let node = current[0];\n      if (node && node.nodeType === 3) {\n        node.data !== value && (node.data = value);\n      } else node = document.createTextNode(value);\n      current = cleanChildren(parent, current, marker, node);\n    } else {\n      if (current !== \"\" && typeof current === \"string\") {\n        current = parent.firstChild.data = value;\n      } else current = parent.textContent = value;\n    }\n  } else if (value == null || t2 === \"boolean\") {\n    current = cleanChildren(parent, current, marker);\n  } else if (t2 === \"function\") {\n    createRenderEffect(() => {\n      let v = value();\n      while (typeof v === \"function\") v = v();\n      current = insertExpression(parent, v, current, marker);\n    });\n    return () => current;\n  } else if (Array.isArray(value)) {\n    const array = [];\n    const currentArray = current && Array.isArray(current);\n    if (normalizeIncomingArray(array, value, current, unwrapArray)) {\n      createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));\n      return () => current;\n    }\n    if (array.length === 0) {\n      current = cleanChildren(parent, current, marker);\n      if (multi) return current;\n    } else if (currentArray) {\n      if (current.length === 0) {\n        appendNodes(parent, array, marker);\n      } else reconcileArrays(parent, current, array);\n    } else {\n      current && cleanChildren(parent);\n      appendNodes(parent, array);\n    }\n    current = array;\n  } else if (value.nodeType) {\n    if (Array.isArray(current)) {\n      if (multi) return current = cleanChildren(parent, current, marker, value);\n      cleanChildren(parent, current, null, value);\n    } else if (current == null || current === \"\" || !parent.firstChild) {\n      parent.appendChild(value);\n    } else parent.replaceChild(value, parent.firstChild);\n    current = value;\n  } else ;\n  return current;\n}\nfunction normalizeIncomingArray(normalized, array, current, unwrap2) {\n  let dynamic = false;\n  for (let i2 = 0, len = array.length; i2 < len; i2++) {\n    let item = array[i2], prev = current && current[normalized.length], t2;\n    if (item == null || item === true || item === false) ;\n    else if ((t2 = typeof item) === \"object\" && item.nodeType) {\n      normalized.push(item);\n    } else if (Array.isArray(item)) {\n      dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;\n    } else if (t2 === \"function\") {\n      if (unwrap2) {\n        while (typeof item === \"function\") item = item();\n        dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev) ? prev : [prev]) || dynamic;\n      } else {\n        normalized.push(item);\n        dynamic = true;\n      }\n    } else {\n      const value = String(item);\n      if (prev && prev.nodeType === 3 && prev.data === value) normalized.push(prev);\n      else normalized.push(document.createTextNode(value));\n    }\n  }\n  return dynamic;\n}\nfunction appendNodes(parent, array, marker = null) {\n  for (let i2 = 0, len = array.length; i2 < len; i2++) parent.insertBefore(array[i2], marker);\n}\nfunction cleanChildren(parent, current, marker, replacement) {\n  if (marker === void 0) return parent.textContent = \"\";\n  const node = replacement || document.createTextNode(\"\");\n  if (current.length) {\n    let inserted = false;\n    for (let i2 = current.length - 1; i2 >= 0; i2--) {\n      const el = current[i2];\n      if (node !== el) {\n        const isParent = el.parentNode === parent;\n        if (!inserted && !i2) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);\n        else isParent && el.remove();\n      } else inserted = true;\n    }\n  } else parent.insertBefore(node, marker);\n  return [node];\n}\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nfunction createElement(tagName, isSVG = false) {\n  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);\n}\nfunction Portal(props) {\n  const {\n    useShadow\n  } = props, marker = document.createTextNode(\"\"), mount = () => props.mount || document.body, owner = getOwner();\n  let content;\n  createEffect(() => {\n    content || (content = runWithOwner(owner, () => createMemo(() => props.children)));\n    const el = mount();\n    if (el instanceof HTMLHeadElement) {\n      const [clean, setClean] = createSignal(false);\n      const cleanup = () => setClean(true);\n      createRoot((dispose2) => insert(el, () => !clean() ? content() : dispose2(), null));\n      onCleanup(cleanup);\n    } else {\n      const container = createElement(props.isSVG ? \"g\" : \"div\", props.isSVG), renderRoot = useShadow && container.attachShadow ? container.attachShadow({\n        mode: \"open\"\n      }) : container;\n      Object.defineProperty(container, \"_$host\", {\n        get() {\n          return marker.parentNode;\n        },\n        configurable: true\n      });\n      insert(renderRoot, content);\n      el.appendChild(container);\n      props.ref && props.ref(container);\n      onCleanup(() => el.removeChild(container));\n    }\n  }, void 0, {\n    render: true\n  });\n  return marker;\n}\nfunction createDynamic(component, props) {\n  const cached = createMemo(component);\n  return createMemo(() => {\n    const component2 = cached();\n    switch (typeof component2) {\n      case \"function\":\n        return untrack(() => component2(props));\n      case \"string\":\n        const isSvg = SVGElements.has(component2);\n        const el = createElement(component2, isSvg);\n        spread(el, props, isSvg);\n        return el;\n    }\n  });\n}\nfunction Dynamic(props) {\n  const [, others] = splitProps(props, [\"component\"]);\n  return createDynamic(() => props.component, others);\n}\nvar THEME = /* @__PURE__ */ ((THEME2) => {\n  THEME2[\"DARK\"] = \"DARK\";\n  THEME2[\"LIGHT\"] = \"LIGHT\";\n  return THEME2;\n})(THEME || {});\nlet e = { data: \"\" }, t = (t2) => \"object\" == typeof window ? ((t2 ? t2.querySelector(\"#_goober\") : window._goober) || Object.assign((t2 || document.head).appendChild(document.createElement(\"style\")), { innerHTML: \" \", id: \"_goober\" })).firstChild : t2 || e, l = /(?:([\\u0080-\\uFFFF\\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\\s*)/g, a = /\\/\\*[^]*?\\*\\/|  +/g, n = /\\n+/g, o = (e2, t2) => {\n  let r = \"\", l2 = \"\", a2 = \"\";\n  for (let n2 in e2) {\n    let c2 = e2[n2];\n    \"@\" == n2[0] ? \"i\" == n2[1] ? r = n2 + \" \" + c2 + \";\" : l2 += \"f\" == n2[1] ? o(c2, n2) : n2 + \"{\" + o(c2, \"k\" == n2[1] ? \"\" : t2) + \"}\" : \"object\" == typeof c2 ? l2 += o(c2, t2 ? t2.replace(/([^,])+/g, (e3) => n2.replace(/(^:.*)|([^,])+/g, (t3) => /&/.test(t3) ? t3.replace(/&/g, e3) : e3 ? e3 + \" \" + t3 : t3)) : n2) : null != c2 && (n2 = /^--/.test(n2) ? n2 : n2.replace(/[A-Z]/g, \"-$&\").toLowerCase(), a2 += o.p ? o.p(n2, c2) : n2 + \":\" + c2 + \";\");\n  }\n  return r + (t2 && a2 ? t2 + \"{\" + a2 + \"}\" : a2) + l2;\n}, c = {}, s = (e2) => {\n  if (\"object\" == typeof e2) {\n    let t2 = \"\";\n    for (let r in e2) t2 += r + s(e2[r]);\n    return t2;\n  }\n  return e2;\n}, i = (e2, t2, r, i2, p2) => {\n  let u2 = s(e2), d = c[u2] || (c[u2] = ((e3) => {\n    let t3 = 0, r2 = 11;\n    for (; t3 < e3.length; ) r2 = 101 * r2 + e3.charCodeAt(t3++) >>> 0;\n    return \"go\" + r2;\n  })(u2));\n  if (!c[d]) {\n    let t3 = u2 !== e2 ? e2 : ((e3) => {\n      let t4, r2, o2 = [{}];\n      for (; t4 = l.exec(e3.replace(a, \"\")); ) t4[4] ? o2.shift() : t4[3] ? (r2 = t4[3].replace(n, \" \").trim(), o2.unshift(o2[0][r2] = o2[0][r2] || {})) : o2[0][t4[1]] = t4[2].replace(n, \" \").trim();\n      return o2[0];\n    })(e2);\n    c[d] = o(p2 ? { [\"@keyframes \" + d]: t3 } : t3, r ? \"\" : \".\" + d);\n  }\n  let f = r && c.g ? c.g : null;\n  return r && (c.g = c[d]), ((e3, t3, r2, l2) => {\n    l2 ? t3.data = t3.data.replace(l2, e3) : -1 === t3.data.indexOf(e3) && (t3.data = r2 ? e3 + t3.data : t3.data + e3);\n  })(c[d], t2, i2, f), d;\n}, p = (e2, t2, r) => e2.reduce((e3, l2, a2) => {\n  let n2 = t2[a2];\n  if (n2 && n2.call) {\n    let e4 = n2(r), t3 = e4 && e4.props && e4.props.className || /^go/.test(e4) && e4;\n    n2 = t3 ? \".\" + t3 : e4 && \"object\" == typeof e4 ? e4.props ? \"\" : o(e4, \"\") : false === e4 ? \"\" : e4;\n  }\n  return e3 + l2 + (null == n2 ? \"\" : n2);\n}, \"\");\nfunction u(e2) {\n  let r = this || {}, l2 = e2.call ? e2(r.p) : e2;\n  return i(l2.unshift ? l2.raw ? p(l2, [].slice.call(arguments, 1), r.p) : l2.reduce((e3, t2) => Object.assign(e3, t2 && t2.call ? t2(r.p) : t2), {}) : l2, t(r.target), r.g, r.o, r.k);\n}\nu.bind({ g: 1 });\nlet h = u.bind({ k: 1 });\nconst ThemeContext = createContext();\nfunction ThemeProvider(props) {\n  return createComponent(ThemeContext.Provider, {\n    value: props.theme,\n    get children() {\n      return props.children;\n    }\n  });\n}\nfunction useTheme() {\n  return useContext(ThemeContext);\n}\nfunction makeStyled(tag) {\n  let _ctx = this || {};\n  return (...args) => {\n    const Styled = (props) => {\n      const theme = useContext(ThemeContext);\n      const withTheme = mergeProps(props, { theme });\n      const clone = mergeProps(withTheme, {\n        get class() {\n          const pClass = withTheme.class, append = \"class\" in withTheme && /^go[0-9]+/.test(pClass);\n          let className2 = u.apply(\n            { target: _ctx.target, o: append, p: withTheme, g: _ctx.g },\n            args\n          );\n          return [pClass, className2].filter(Boolean).join(\" \");\n        }\n      });\n      const [local, newProps] = splitProps(clone, [\"as\", \"theme\"]);\n      const htmlProps = newProps;\n      const createTag = local.as || tag;\n      let el;\n      if (typeof createTag === \"function\") {\n        el = createTag(htmlProps);\n      } else {\n        {\n          if (_ctx.g == 1) {\n            el = document.createElement(createTag);\n            spread(el, htmlProps);\n          } else {\n            el = Dynamic(mergeProps({ component: createTag }, htmlProps));\n          }\n        }\n      }\n      return el;\n    };\n    Styled.class = (props) => {\n      return untrack(() => {\n        return u.apply({ target: _ctx.target, p: props, g: _ctx.g }, args);\n      });\n    };\n    return Styled;\n  };\n}\nconst styled = new Proxy(makeStyled, {\n  get(target, tag) {\n    return target(tag);\n  }\n});\nfunction createGlobalStyles() {\n  const fn = makeStyled.call({ g: 1 }, \"div\").apply(null, arguments);\n  return function GlobalStyles2(props) {\n    fn(props);\n    return null;\n  };\n}\nconst globalStylesTag = \"tc-root\";\nconst disableScrollClass = \"tc-disable-scroll\";\nconst usingMouseClass = \"tc-using-mouse\";\nconst GlobalStyles = () => {\n  document.body.addEventListener(\"mousedown\", () => document.body.classList.add(usingMouseClass));\n  document.body.addEventListener(\"keydown\", (event) => {\n    if (event.key === \"Tab\") {\n      document.body.classList.remove(usingMouseClass);\n    }\n  });\n  const Styles = createGlobalStyles`\n    ${globalStylesTag} * {\n        margin: 0;\n        padding: 0;\n        box-sizing: border-box;\n        \n        font-family: -apple-system, BlinkMacSystemFont, 'Roboto', 'Helvetica Neue', Arial, Tahoma, Verdana, sans-serif;\n        -webkit-font-smoothing: antialiased;\n        -moz-osx-font-smoothing: grayscale;        \n        -webkit-tap-highlight-color: transparent;\n    }\n    \n    ${globalStylesTag} img {\n      -webkit-user-select: none;\n      -webkit-touch-callout: none;\n    }   \n \n    ${globalStylesTag} *:focus {\n        outline: #08f auto 2px;\n    }\n    \n    ${globalStylesTag} li {\n        list-style: none;\n    }\n    \n    ${globalStylesTag} button {\n        outline: none;\n    }\n    \n    body.${disableScrollClass} {\n        position: fixed; \n        overflow-y: scroll;\n        right: 0;\n        left: 0;\n    }\n    \n    body.${usingMouseClass} ${globalStylesTag} *:focus {\n        outline: none;\n    }\n`;\n  return createComponent(Styles, {});\n};\nfunction hexToRgb(hex) {\n  if (hex[0] === \"#\") {\n    hex = hex.slice(1);\n  }\n  const bigint = parseInt(hex, 16);\n  const r = bigint >> 16 & 255;\n  const g = bigint >> 8 & 255;\n  const b = bigint & 255;\n  return [r, g, b].join(\",\");\n}\nfunction rgba(color, opacity) {\n  if (color[0] === \"#\") {\n    color = hexToRgb(color);\n  }\n  return `rgba(${color}, ${opacity})`;\n}\nfunction toPx(value) {\n  return value.toString() + \"px\";\n}\nclass InMemoryStorage {\n  constructor() {\n    this.storage = {};\n  }\n  static getInstance() {\n    if (!InMemoryStorage.instance) {\n      InMemoryStorage.instance = new InMemoryStorage();\n    }\n    return InMemoryStorage.instance;\n  }\n  get length() {\n    return Object.keys(this.storage).length;\n  }\n  clear() {\n    this.storage = {};\n  }\n  getItem(key) {\n    var _a2;\n    return (_a2 = this.storage[key]) != null ? _a2 : null;\n  }\n  key(index) {\n    var _a2;\n    const keys = Object.keys(this.storage);\n    if (index < 0 || index >= keys.length) {\n      return null;\n    }\n    return (_a2 = keys[index]) != null ? _a2 : null;\n  }\n  removeItem(key) {\n    delete this.storage[key];\n  }\n  setItem(key, value) {\n    this.storage[key] = value;\n  }\n}\nclass TonConnectUIError extends _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnectError {\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, TonConnectUIError.prototype);\n  }\n}\nfunction logDebug(...args) {\n  {\n    try {\n      console.debug(\"[TON_CONNECT_UI]\", ...args);\n    } catch (e2) {\n    }\n  }\n}\nfunction logError(...args) {\n  {\n    try {\n      console.error(\"[TON_CONNECT_UI]\", ...args);\n    } catch (e2) {\n    }\n  }\n}\nfunction logWarning(...args) {\n  {\n    try {\n      console.warn(\"[TON_CONNECT_UI]\", ...args);\n    } catch (e2) {\n    }\n  }\n}\nfunction openLink(href, target = \"_self\") {\n  setLastOpenedLink({ link: href });\n  logDebug(\"openLink\", href, target);\n  window.open(href, target, \"noopener noreferrer\");\n}\nfunction openLinkBlank(href) {\n  openLink(href, \"_blank\");\n}\nfunction openDeeplinkWithFallback(href, fallback) {\n  const doFallback = () => {\n    if (isBrowser(\"safari\") || isOS(\"android\") && isBrowser(\"firefox\") || isOS(\"windows\")) {\n      return;\n    }\n    fallback();\n  };\n  const fallbackTimeout = setTimeout(() => doFallback(), 200);\n  window.addEventListener(\"blur\", () => clearTimeout(fallbackTimeout), { once: true });\n  openLink(href, \"_self\");\n}\nfunction getSystemTheme() {\n  if (window.matchMedia && window.matchMedia(\"(prefers-color-scheme: light)\").matches) {\n    return THEME.LIGHT;\n  }\n  return THEME.DARK;\n}\nfunction subscribeToThemeChange(callback) {\n  const handler = (event) => callback(event.matches ? THEME.DARK : THEME.LIGHT);\n  window.matchMedia(\"(prefers-color-scheme: dark)\").addEventListener(\"change\", handler);\n  return () => window.matchMedia(\"(prefers-color-scheme: dark)\").removeEventListener(\"change\", handler);\n}\nfunction disableScroll() {\n  if (document.documentElement.scrollHeight === document.documentElement.clientHeight) {\n    return;\n  }\n  document.body.style.top = toPx(-document.documentElement.scrollTop);\n  document.body.classList.add(disableScrollClass);\n}\nfunction enableScroll() {\n  if (!document.body.classList.contains(disableScrollClass)) {\n    return;\n  }\n  document.body.classList.remove(disableScrollClass);\n  document.documentElement.scrollTo({ top: -parseFloat(getComputedStyle(document.body).top) });\n  document.body.style.top = \"auto\";\n}\nfunction fixMobileSafariActiveTransition() {\n  if (!document.body.hasAttribute(\"ontouchstart\")) {\n    document.body.setAttribute(\"ontouchstart\", \"\");\n  }\n}\nfunction defineStylesRoot() {\n  if (!customElements.get(\"tc-root\")) {\n    customElements.define(globalStylesTag, class TcRootElement extends HTMLElement {\n    });\n  }\n}\nfunction createMacrotask(callback) {\n  return __async(this, null, function* () {\n    yield new Promise((resolve) => requestAnimationFrame(resolve));\n    callback();\n  });\n}\nfunction createMacrotaskAsync(callback) {\n  return __async(this, null, function* () {\n    yield new Promise((resolve) => requestAnimationFrame(resolve));\n    return callback();\n  });\n}\nfunction preloadImages(images) {\n  if (document.readyState !== \"complete\") {\n    window.addEventListener(\"load\", () => createMacrotask(() => preloadImages(images)), {\n      once: true\n    });\n  } else {\n    images.forEach((img) => {\n      const node = new window.Image();\n      node.src = img;\n    });\n  }\n}\nfunction getWindow$1() {\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  return void 0;\n}\nfunction tryGetLocalStorage() {\n  if (isLocalStorageAvailable()) {\n    return localStorage;\n  }\n  if (isNodeJs()) {\n    throw new TonConnectUIError(\n      \"`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector\"\n    );\n  }\n  return InMemoryStorage.getInstance();\n}\nfunction isLocalStorageAvailable() {\n  try {\n    return typeof localStorage !== \"undefined\";\n  } catch (e2) {\n    return false;\n  }\n}\nfunction isNodeJs() {\n  return typeof process !== \"undefined\" && process.versions != null && process.versions.node != null;\n}\nfunction getUserAgent() {\n  var _a2, _b2, _c2;\n  const results = new ua_parser_js__WEBPACK_IMPORTED_MODULE_1__().getResult();\n  const osName = (_a2 = results.os.name) == null ? void 0 : _a2.toLowerCase();\n  const deviceModel = (_b2 = results.device.model) == null ? void 0 : _b2.toLowerCase();\n  let os;\n  switch (true) {\n    case deviceModel === \"ipad\":\n      os = \"ipad\";\n      break;\n    case osName === \"ios\":\n      os = \"ios\";\n      break;\n    case osName === \"android\":\n      os = \"android\";\n      break;\n    case osName === \"mac os\":\n      os = \"macos\";\n      break;\n    case osName === \"linux\":\n      os = \"linux\";\n      break;\n    case (osName == null ? void 0 : osName.includes(\"windows\")):\n      os = \"windows\";\n      break;\n  }\n  const browserName = (_c2 = results.browser.name) == null ? void 0 : _c2.toLowerCase();\n  let browser;\n  switch (true) {\n    case browserName === \"chrome\":\n      browser = \"chrome\";\n      break;\n    case browserName === \"firefox\":\n      browser = \"firefox\";\n      break;\n    case (browserName == null ? void 0 : browserName.includes(\"safari\")):\n      browser = \"safari\";\n      break;\n    case (browserName == null ? void 0 : browserName.includes(\"opera\")):\n      browser = \"opera\";\n      break;\n  }\n  return {\n    os,\n    browser\n  };\n}\nfunction isOS(...os) {\n  return os.includes(getUserAgent().os);\n}\nfunction isBrowser(...browser) {\n  return browser.includes(getUserAgent().browser);\n}\nfunction toDeeplink(universalLink, deeplink) {\n  const url = new URL(universalLink);\n  return deeplink + url.search;\n}\nclass WalletInfoStorage {\n  constructor() {\n    this.storageKey = \"ton-connect-ui_wallet-info\";\n    this.localStorage = tryGetLocalStorage();\n  }\n  setWalletInfo(walletInfo) {\n    this.localStorage.setItem(this.storageKey, JSON.stringify(walletInfo));\n  }\n  getWalletInfo() {\n    const walletInfoString = this.localStorage.getItem(this.storageKey);\n    if (!walletInfoString) {\n      return null;\n    }\n    return JSON.parse(walletInfoString);\n  }\n  removeWalletInfo() {\n    this.localStorage.removeItem(this.storageKey);\n  }\n}\nclass PreferredWalletStorage {\n  constructor() {\n    this.storageKey = \"ton-connect-ui_preferred-wallet\";\n    this.localStorage = tryGetLocalStorage();\n  }\n  setPreferredWalletAppName(name) {\n    this.localStorage.setItem(this.storageKey, name);\n  }\n  getPreferredWalletAppName() {\n    return this.localStorage.getItem(this.storageKey) || void 0;\n  }\n}\nclass LastSelectedWalletInfoStorage {\n  constructor() {\n    this.storageKey = \"ton-connect-ui_last-selected-wallet-info\";\n    this.localStorage = tryGetLocalStorage();\n  }\n  setLastSelectedWalletInfo(walletInfo) {\n    this.localStorage.setItem(this.storageKey, JSON.stringify(walletInfo));\n  }\n  getLastSelectedWalletInfo() {\n    const walletInfoString = this.localStorage.getItem(this.storageKey);\n    if (!walletInfoString) {\n      return null;\n    }\n    return JSON.parse(walletInfoString);\n  }\n  removeLastSelectedWalletInfo() {\n    this.localStorage.removeItem(this.storageKey);\n  }\n}\nconst [walletsModalState, setWalletsModalState] = createSignal({\n  status: \"closed\",\n  closeReason: null\n});\nconst getWalletsModalIsOpened = createMemo(() => walletsModalState().status === \"opened\");\nconst [singleWalletModalState, setSingleWalletModalState] = createSignal({\n  status: \"closed\",\n  closeReason: null\n});\nconst getSingleWalletModalIsOpened = createMemo(\n  () => singleWalletModalState().status === \"opened\"\n);\nconst getSingleWalletModalWalletInfo = createMemo(() => {\n  const state = singleWalletModalState();\n  if (state.status === \"opened\") {\n    return state.walletInfo;\n  }\n  return null;\n});\nlet lastSelectedWalletInfoStorage = typeof window !== \"undefined\" ? new LastSelectedWalletInfoStorage() : void 0;\nconst [lastSelectedWalletInfo, _setLastSelectedWalletInfo] = createSignal((lastSelectedWalletInfoStorage == null ? void 0 : lastSelectedWalletInfoStorage.getLastSelectedWalletInfo()) || null);\nconst setLastSelectedWalletInfo = (walletInfo) => {\n  if (!lastSelectedWalletInfoStorage) {\n    lastSelectedWalletInfoStorage = new LastSelectedWalletInfoStorage();\n  }\n  if (walletInfo) {\n    lastSelectedWalletInfoStorage.setLastSelectedWalletInfo(walletInfo);\n  } else {\n    lastSelectedWalletInfoStorage.removeLastSelectedWalletInfo();\n  }\n  _setLastSelectedWalletInfo(walletInfo);\n};\nconst [action, setAction] = createSignal(null);\nconst [lastVisibleWalletsInfo, setLastVisibleWalletsInfo] = createSignal({\n  walletsMenu: \"explicit_wallet\",\n  wallets: []\n});\nconst [lastOpenedLink, setLastOpenedLink] = createSignal({\n  link: \"\"\n});\nconst common$1 = { \"close\": \"Close\", \"openWallet\": \"Open wallet\", \"copyLink\": \"Copy Link\", \"linkCopied\": \"Link Copied\", \"copied\": \"Copied\", \"yourWallet\": \"Your Wallet\", \"retry\": \"Retry\", \"get\": \"GET\", \"mobile\": \"Mobile\", \"browserExtension\": \"Browser Extension\", \"desktop\": \"Desktop\" };\nconst button$1 = { \"connectWallet\": \"Connect Wallet\", \"dropdown\": { \"copy\": \"Copy address\", \"copied\": \"Address copied!\", \"disconnect\": \"Disconnect\" } };\nconst notifications$1 = { \"confirm\": { \"header\": \"Open {{ name }} toconfirm thetransaction.\" }, \"transactionSent\": { \"header\": \"Transaction sent\", \"text\": \"Your transactionwill beprocessed inafew seconds.\" }, \"transactionCanceled\": { \"header\": \"Transaction canceled\", \"text\": \"There will be no changes toyour account.\" }, \"dataSigned\": { \"header\": \"Data signed\" }, \"signDataCanceled\": { \"header\": \"Sign data canceled\" } };\nconst walletItem$1 = { \"walletOn\": \"Wallet in\", \"recent\": \"Recent\", \"installed\": \"Installed\", \"popular\": \"Popular\" };\nconst walletModal$1 = { \"loading\": \"Loading wallets\", \"wallets\": \"Wallets\", \"mobileUniversalModal\": { \"connectYourWallet\": \"Connect your TONwallet\", \"openWalletOnTelegramOrSelect\": \"Use Wallet in Telegram or choose other application\", \"openWalletOnTelegram\": \"Connect Wallet in Telegram\", \"chooseOtherApplication\": \"Choose other application\", \"openLink\": \"Open Link\", \"scan\": \"Scan with your mobilewallet\" }, \"desktopUniversalModal\": { \"connectYourWallet\": \"Connect your TON wallet\", \"scan\": \"Scan with your mobile wallet\", \"availableWallets\": \"Available wallets\" }, \"mobileConnectionModal\": { \"showQR\": \"Show QR Code\", \"scanQR\": \"Scan theQR code below with your phonesor{{ name }}s camera\", \"missingFeatures\": \"Please update {{ name }}, your version does not support required features for this dApp\", \"wrongNetwork\": \"Connected wallet is on a different network. Please switch network in {{ name }} and try again\", \"notSupportedWallet\": \"{{ name }} doesnt support the requested action. Please connect another wallet that supports it\", \"continueIn\": \"Continue in {{ name }}\", \"updateWallet\": \"Update {{ name }}\", \"chooseAnotherWallet\": \"Choose Another Wallet\", \"connectionDeclined\": \"Connection declined\" }, \"desktopConnectionModal\": { \"scanQR\": \"Scan theQR code below with your phonesor{{ name }}s camera\", \"continueInExtension\": \"Continue in{{ name }} browser extension\", \"dontHaveExtension\": \"Seems you don't have installed {{ name }}browserextension\", \"missingFeatures\": \"Please update {{ name }}, your version does not support required features for this dApp\", \"wrongNetwork\": \"Connected wallet is on a different network. Please switch network in {{ name }} and try again\", \"notSupportedWallet\": \"{{ name }} doesnt support the requested action. Please connect another wallet that supports it\", \"getWallet\": \"Get {{ name }}\", \"updateWallet\": \"Update {{ name }}\", \"chooseAnotherWallet\": \"Choose Another Wallet\", \"continueOnDesktop\": \"Continue in{{ name }} on desktop\", \"openWalletOnTelegram\": \"Connect Wallet in Telegram on desktop\", \"connectionDeclined\": \"Connection declined\" }, \"infoModal\": { \"whatIsAWallet\": \"What is a wallet\", \"secureDigitalAssets\": \"Secure digital assets storage\", \"walletProtects\": \"A wallet protects and manages your digital assetsincluding TON, tokens and collectables.\", \"controlIdentity\": \"Control your Web3 identity\", \"manageIdentity\": \"Manage your digital identity and access decentralized applications with ease. Maintain control over your data and engage securely intheblockchain ecosystem.\", \"effortlessCryptoTransactions\": \"Effortless crypto transactions\", \"easilySend\": \"Easily send, receive, monitor your cryptocurrencies.Streamline your operations withdecentralized applications.\", \"getAWallet\": \"Get a Wallet\" }, \"restoreModal\": { \"title\": \"Restore\", \"step1\": { \"title\": \"Find your current recovery phrase\", \"text\": \"Open your wallet settings and locate therecoveryphrase\" }, \"step2\": { \"title\": \"Copy your recovery phrase\", \"text\": \"Write it down or copy it to a safe place\" }, \"step3\": { \"title\": \"Restore in a supported wallet\", \"text\": \"Enter the recovery phrase to access your wallet\" } }, \"allWallets\": { \"walletsBelowNotSupported\": \"The wallets below dont support all features ofthe connected service. You can use your recovery phrase in one of the supported wallets above.\", \"walletNotSupportService\": \"{{ name }} doesnt support connected service\" }, \"featureNotSupported\": { \"wallet\": { \"title\": \"{{ name }} doesnt support the requestedaction\", \"description\": \"Install a supported wallet from the list below, restore it with your recovery phrase, then connect it and try again.\", \"info\": \"Learn how to restore your wallet\" }, \"version\": { \"description\": \"Your current version of {{ name }} or wallet contract type doesn't support the required features. Please update it to continue.\", \"updateButton\": \"Update {{ name }}\", \"aboutW5\": \"About W5\" }, \"disconnect\": { \"title\": \"Confirm Disconnect\", \"description\": \"You will be disconnected from your current wallet and redirected to connect {{ name }}.\", \"button\": \"Disconnect\" } } };\nconst actionModal$1 = { \"confirmTransaction\": { \"header\": \"Confirm thetransaction in{{ name }}\", \"text\": \"It will only take amoment.\" }, \"signData\": { \"header\": \"Sign thedata in{{ name }}\", \"text\": \"It will only take amoment.\" }, \"transactionSent\": \"$notifications.transactionSent\", \"transactionCanceled\": \"$notifications.transactionCanceled\", \"dataSigned\": \"$notifications.dataSigned\", \"signDataCanceled\": \"$notifications.signDataCanceled\" };\nconst en = {\n  common: common$1,\n  button: button$1,\n  notifications: notifications$1,\n  walletItem: walletItem$1,\n  walletModal: walletModal$1,\n  actionModal: actionModal$1\n};\nconst common = { \"close\": \"\", \"openWallet\": \" \", \"copyLink\": \"\", \"linkCopied\": \" \", \"copied\": \"\", \"yourWallet\": \" \", \"retry\": \"\", \"get\": \"\", \"mobile\": \"\", \"browserExtension\": \"\", \"desktop\": \"\" };\nconst button = { \"connectWallet\": \" \", \"dropdown\": { \"copy\": \" \", \"copied\": \" !\", \"disconnect\": \" \" } };\nconst notifications = { \"confirm\": { \"header\": \" {{ name }},  .\" }, \"transactionSent\": { \"header\": \" \", \"text\": \"    .\" }, \"transactionCanceled\": { \"header\": \" \", \"text\": \"   .\" }, \"dataSigned\": { \"header\": \" \" }, \"signDataCanceled\": { \"header\": \"  \" } };\nconst walletItem = { \"walletOn\": \"Wallet \", \"recent\": \"\", \"installed\": \"\", \"popular\": \"\" };\nconst walletModal = { \"loading\": \" \", \"wallets\": \"\", \"mobileUniversalModal\": { \"connectYourWallet\": \" TON\", \"openWalletOnTelegramOrSelect\": \" Wallet Telegram   \", \"openWalletOnTelegram\": \" Wallet  Telegram\", \"chooseOtherApplication\": \"  \", \"openLink\": \"\", \"scan\": \"  \" }, \"desktopUniversalModal\": { \"connectYourWallet\": \" TON \", \"scan\": \" QR-  \", \"availableWallets\": \" \" }, \"mobileConnectionModal\": { \"showQR\": \" QR-\", \"scanQR\": \" QR-    {{ name }},  \", \"missingFeatures\": \" {{ name }},         dApp\", \"wrongNetwork\": \"     . ,    {{ name }}   \", \"notSupportedWallet\": \"{{ name }}    . ,   ,   \", \"continueIn\": \"  {{ name }}\", \"updateWallet\": \" {{ name }}\", \"chooseAnotherWallet\": \"  \", \"connectionDeclined\": \" \" }, \"desktopConnectionModal\": { \"scanQR\": \" QR-    {{ name }},  \", \"continueInExtension\": \"   {{ name }}\", \"dontHaveExtension\": \",    {{ name }}\", \"missingFeatures\": \" {{ name }},         dApp\", \"wrongNetwork\": \"     . ,    {{ name }}   \", \"notSupportedWallet\": \"{{ name }}    . ,   ,   \", \"getWallet\": \" {{ name }}\", \"updateWallet\": \" {{ name }}\", \"chooseAnotherWallet\": \"  \", \"continueOnDesktop\": \" {{ name }} \", \"openWalletOnTelegram\": \" Wallet Telegram\", \"connectionDeclined\": \" \" }, \"infoModal\": { \"whatIsAWallet\": \"  ?\", \"secureDigitalAssets\": \"   \", \"walletProtects\": \"    ,  TON,   ,  .\", \"controlIdentity\": \"   Web3\", \"manageIdentity\": \"        .       .\", \"effortlessCryptoTransactions\": \" \", \"easilySend\": \" ,    .      .\", \"getAWallet\": \" \" }, \"restoreModal\": { \"title\": \"\", \"step1\": { \"title\": \"    \", \"text\": \"     \" }, \"step2\": { \"title\": \"   \", \"text\": \"      \" }, \"step3\": { \"title\": \"   \", \"text\": \"    \" } }, \"allWallets\": { \"walletsBelowNotSupported\": \"       .            .\", \"walletNotSupportService\": \"{{ name }}    \" }, \"featureNotSupported\": { \"wallet\": { \"title\": \"{{ name }}   \", \"description\": \"     ,      ,     .\", \"info\": \",   \" }, \"version\": { \"description\": \"  {{ name }}        .  ,  .\", \"updateButton\": \" {{ name }}\", \"aboutW5\": \" W5\" }, \"disconnect\": { \"title\": \" \", \"description\": \"          {{ name }}.\", \"button\": \"\" } } };\nconst actionModal = { \"confirmTransaction\": { \"header\": \"  {{ name }}\", \"text\": \"   .\" }, \"signData\": { \"header\": \"  {{ name }}\", \"text\": \"   .\" }, \"transactionSent\": \"$notifications.transactionSent\", \"transactionCanceled\": \"$notifications.transactionCanceled\", \"dataSigned\": \"$notifications.dataSigned\", \"signDataCanceled\": \"$notifications.signDataCanceled\" };\nconst ru = {\n  common,\n  button,\n  notifications,\n  walletItem,\n  walletModal,\n  actionModal\n};\nconst i18nDictionary = {\n  en: parseDictionary(en),\n  ru: parseDictionary(ru)\n};\nfunction parseDictionary(dictionary) {\n  const refSymbol = \"$\";\n  const iterate = (subDictionary) => {\n    Object.entries(subDictionary).forEach(([key, value]) => {\n      if (typeof value === \"object\" && value) {\n        return iterate(value);\n      }\n      if (typeof value === \"string\") {\n        if (value[0] === refSymbol) {\n          const path = value.slice(1).split(\".\");\n          let obj = dictionary;\n          path.forEach((item) => {\n            if (item in obj) {\n              obj = obj[item];\n            } else {\n              throw new Error(\n                `Cannot parse translations: there is no property ${item} in translation`\n              );\n            }\n          });\n          subDictionary[key] = obj;\n        }\n        if (value.slice(0, 2) === `\\\\${refSymbol}`) {\n          subDictionary[key] = value.slice(1);\n        }\n      }\n    });\n  };\n  iterate(dictionary);\n  return dictionary;\n}\nconst ConnectorContext = createContext();\nconst $RAW = Symbol(\"store-raw\"), $NODE = Symbol(\"store-node\"), $HAS = Symbol(\"store-has\"), $SELF = Symbol(\"store-self\");\nfunction wrap$1(value) {\n  let p2 = value[$PROXY];\n  if (!p2) {\n    Object.defineProperty(value, $PROXY, {\n      value: p2 = new Proxy(value, proxyTraps$1)\n    });\n    if (!Array.isArray(value)) {\n      const keys = Object.keys(value), desc = Object.getOwnPropertyDescriptors(value);\n      for (let i2 = 0, l2 = keys.length; i2 < l2; i2++) {\n        const prop = keys[i2];\n        if (desc[prop].get) {\n          Object.defineProperty(value, prop, {\n            enumerable: desc[prop].enumerable,\n            get: desc[prop].get.bind(p2)\n          });\n        }\n      }\n    }\n  }\n  return p2;\n}\nfunction isWrappable(obj) {\n  let proto;\n  return obj != null && typeof obj === \"object\" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));\n}\nfunction unwrap(item, set = /* @__PURE__ */ new Set()) {\n  let result, unwrapped, v, prop;\n  if (result = item != null && item[$RAW]) return result;\n  if (!isWrappable(item) || set.has(item)) return item;\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item)) item = item.slice(0);\n    else set.add(item);\n    for (let i2 = 0, l2 = item.length; i2 < l2; i2++) {\n      v = item[i2];\n      if ((unwrapped = unwrap(v, set)) !== v) item[i2] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item)) item = Object.assign({}, item);\n    else set.add(item);\n    const keys = Object.keys(item), desc = Object.getOwnPropertyDescriptors(item);\n    for (let i2 = 0, l2 = keys.length; i2 < l2; i2++) {\n      prop = keys[i2];\n      if (desc[prop].get) continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;\n    }\n  }\n  return item;\n}\nfunction getNodes(target, symbol) {\n  let nodes = target[symbol];\n  if (!nodes) Object.defineProperty(target, symbol, {\n    value: nodes = /* @__PURE__ */ Object.create(null)\n  });\n  return nodes;\n}\nfunction getNode(nodes, property, value) {\n  if (nodes[property]) return nodes[property];\n  const [s2, set] = createSignal(value, {\n    equals: false,\n    internal: true\n  });\n  s2.$ = set;\n  return nodes[property] = s2;\n}\nfunction proxyDescriptor$1(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE) return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  return desc;\n}\nfunction trackSelf(target) {\n  getListener() && getNode(getNodes(target, $NODE), $SELF)();\n}\nfunction ownKeys(target) {\n  trackSelf(target);\n  return Reflect.ownKeys(target);\n}\nconst proxyTraps$1 = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getNodes(target, $NODE);\n    const tracked = nodes[property];\n    let value = tracked ? tracked() : target[property];\n    if (property === $NODE || property === $HAS || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      if (getListener() && (typeof value !== \"function\" || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getNode(nodes, property, value)();\n    }\n    return isWrappable(value) ? wrap$1(value) : value;\n  },\n  has(target, property) {\n    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === $HAS || property === \"__proto__\") return true;\n    getListener() && getNode(getNodes(target, $HAS), property)();\n    return property in target;\n  },\n  set() {\n    return true;\n  },\n  deleteProperty() {\n    return true;\n  },\n  ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor$1\n};\nfunction setProperty(state, property, value, deleting = false) {\n  if (!deleting && state[property] === value) return;\n  const prev = state[property], len = state.length;\n  if (value === void 0) {\n    delete state[property];\n    if (state[$HAS] && state[$HAS][property] && prev !== void 0) state[$HAS][property].$();\n  } else {\n    state[property] = value;\n    if (state[$HAS] && state[$HAS][property] && prev === void 0) state[$HAS][property].$();\n  }\n  let nodes = getNodes(state, $NODE), node;\n  if (node = getNode(nodes, property, prev)) node.$(() => value);\n  if (Array.isArray(state) && state.length !== len) {\n    for (let i2 = state.length; i2 < len; i2++) (node = nodes[i2]) && node.$();\n    (node = getNode(nodes, \"length\", len)) && node.$(state.length);\n  }\n  (node = nodes[$SELF]) && node.$();\n}\nfunction mergeStoreNode(state, value) {\n  const keys = Object.keys(value);\n  for (let i2 = 0; i2 < keys.length; i2 += 1) {\n    const key = keys[i2];\n    setProperty(state, key, value[key]);\n  }\n}\nfunction updateArray(current, next) {\n  if (typeof next === \"function\") next = next(current);\n  next = unwrap(next);\n  if (Array.isArray(next)) {\n    if (current === next) return;\n    let i2 = 0, len = next.length;\n    for (; i2 < len; i2++) {\n      const value = next[i2];\n      if (current[i2] !== value) setProperty(current, i2, value);\n    }\n    setProperty(current, \"length\", len);\n  } else mergeStoreNode(current, next);\n}\nfunction updatePath(current, path, traversed = []) {\n  let part, prev = current;\n  if (path.length > 1) {\n    part = path.shift();\n    const partType = typeof part, isArray = Array.isArray(current);\n    if (Array.isArray(part)) {\n      for (let i2 = 0; i2 < part.length; i2++) {\n        updatePath(current, [part[i2]].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"function\") {\n      for (let i2 = 0; i2 < current.length; i2++) {\n        if (part(current[i2], i2)) updatePath(current, [i2].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"object\") {\n      const {\n        from = 0,\n        to = current.length - 1,\n        by = 1\n      } = part;\n      for (let i2 = from; i2 <= to; i2 += by) {\n        updatePath(current, [i2].concat(path), traversed);\n      }\n      return;\n    } else if (path.length > 1) {\n      updatePath(current[part], path, [part].concat(traversed));\n      return;\n    }\n    prev = current[part];\n    traversed = [part].concat(traversed);\n  }\n  let value = path[0];\n  if (typeof value === \"function\") {\n    value = value(prev, traversed);\n    if (value === prev) return;\n  }\n  if (part === void 0 && value == void 0) return;\n  value = unwrap(value);\n  if (part === void 0 || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) {\n    mergeStoreNode(prev, value);\n  } else setProperty(current, part, value);\n}\nfunction createStore(...[store, options]) {\n  const unwrappedStore = unwrap(store || {});\n  const isArray = Array.isArray(unwrappedStore);\n  const wrappedStore = wrap$1(unwrappedStore);\n  function setStore(...args) {\n    batch(() => {\n      isArray && args.length === 1 ? updateArray(unwrappedStore, args[0]) : updatePath(unwrappedStore, args);\n    });\n  }\n  return [wrappedStore, setStore];\n}\nconst defaultLightColorsSet = {\n  constant: {\n    black: \"#000000\",\n    white: \"#FFFFFF\"\n  },\n  connectButton: {\n    background: \"#0098EA\",\n    foreground: \"#FFFFFF\"\n  },\n  accent: \"#0098EA\",\n  telegramButton: \"#0098EA\",\n  icon: {\n    primary: \"#0F0F0F\",\n    secondary: \"#7A8999\",\n    tertiary: \"#C1CAD2\",\n    success: \"#29CC6A\",\n    error: \"#F5A73B\"\n  },\n  background: {\n    primary: \"#FFFFFF\",\n    secondary: \"#F1F3F5\",\n    segment: \"#FFFFFF\",\n    tint: \"#F1F3F5\",\n    qr: \"#F1F3F5\"\n  },\n  text: {\n    primary: \"#0F0F0F\",\n    secondary: \"#6A7785\"\n  }\n};\nconst defaultDarkColorsSet = {\n  constant: {\n    black: \"#000000\",\n    white: \"#FFFFFF\"\n  },\n  connectButton: {\n    background: \"#0098EA\",\n    foreground: \"#FFFFFF\"\n  },\n  accent: \"#E5E5EA\",\n  telegramButton: \"#31A6F5\",\n  icon: {\n    primary: \"#E5E5EA\",\n    secondary: \"#909099\",\n    tertiary: \"#434347\",\n    success: \"#29CC6A\",\n    error: \"#F5A73B\"\n  },\n  background: {\n    primary: \"#121214\",\n    secondary: \"#18181A\",\n    segment: \"#262629\",\n    tint: \"#222224\",\n    qr: \"#FFFFFF\"\n  },\n  text: {\n    primary: \"#E5E5EA\",\n    secondary: \"#7D7D85\"\n  }\n};\n/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\nfunction isObject(o2) {\n  return Object.prototype.toString.call(o2) === \"[object Object]\";\n}\nfunction isPlainObject(o2) {\n  var ctor, prot;\n  if (isObject(o2) === false) return false;\n  ctor = o2.constructor;\n  if (ctor === void 0) return true;\n  prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n  if (prot.hasOwnProperty(\"isPrototypeOf\") === false) {\n    return false;\n  }\n  return true;\n}\nfunction mergeOptions(options, defaultOptions) {\n  if (!options) {\n    return defaultOptions;\n  }\n  const overwriteMerge = (_, sourceArray, __) => sourceArray;\n  return deepmerge__WEBPACK_IMPORTED_MODULE_2__(defaultOptions, options, {\n    arrayMerge: overwriteMerge,\n    isMergeableObject: isPlainObject\n  });\n}\nconst [themeState, setThemeState] = createStore({\n  theme: THEME.LIGHT,\n  colors: defaultLightColorsSet,\n  borderRadius: \"m\"\n});\nconst themeColorsMappingDefault = {\n  [THEME.LIGHT]: defaultLightColorsSet,\n  [THEME.DARK]: defaultDarkColorsSet\n};\nconst themeCustomColors = {\n  [THEME.LIGHT]: void 0,\n  [THEME.DARK]: void 0\n};\nfunction setTheme(theme, colorsSet) {\n  if (colorsSet) {\n    themeCustomColors[THEME.DARK] = mergeOptions(\n      colorsSet[THEME.DARK],\n      themeCustomColors[THEME.DARK]\n    );\n    themeCustomColors[THEME.LIGHT] = mergeOptions(\n      colorsSet[THEME.LIGHT],\n      themeCustomColors[THEME.LIGHT]\n    );\n  }\n  setThemeState({\n    theme,\n    colors: mergeOptions(themeCustomColors[theme], themeColorsMappingDefault[theme])\n  });\n}\nfunction setBorderRadius(borderRadius) {\n  setThemeState({ borderRadius });\n}\nfunction setColors(colorsSet) {\n  themeCustomColors[THEME.DARK] = mergeOptions(\n    colorsSet[THEME.DARK],\n    themeCustomColors[THEME.DARK]\n  );\n  themeCustomColors[THEME.LIGHT] = mergeOptions(\n    colorsSet[THEME.LIGHT],\n    themeCustomColors[THEME.LIGHT]\n  );\n  setThemeState((state) => ({\n    colors: mergeOptions(\n      themeCustomColors[state.theme],\n      themeColorsMappingDefault[state.theme]\n    )\n  }));\n}\nconst ImagePlaceholder = styled.div`\n    background-color: ${(props) => props.theme.colors.background.secondary};\n`;\nconst Image = (props) => {\n  let imgRef;\n  const [image, setImage] = createSignal(null);\n  createEffect(() => {\n    const img = new window.Image();\n    img.src = props.src;\n    img.alt = props.alt || \"\";\n    img.setAttribute(\"draggable\", \"false\");\n    if (props.class) {\n      img.classList.add(props.class);\n    }\n    if (img.complete) {\n      return setImage(img);\n    }\n    img.addEventListener(\"load\", () => setImage(img));\n    return () => img.removeEventListener(\"load\", () => setImage(img));\n  });\n  return [createComponent(Show, {\n    get when() {\n      return image();\n    },\n    get children() {\n      return image();\n    }\n  }), createComponent(Show, {\n    get when() {\n      return !image();\n    },\n    get children() {\n      return createComponent(ImagePlaceholder, {\n        get [\"class\"]() {\n          return props.class;\n        },\n        ref(r$) {\n          var _ref$ = imgRef;\n          typeof _ref$ === \"function\" ? _ref$(r$) : imgRef = r$;\n        }\n      });\n    }\n  })];\n};\nlet initParams = {};\ntry {\n  let locationHash = location.hash.toString();\n  initParams = urlParseHashParams(locationHash);\n} catch (e2) {\n}\ntry {\n  const launchParamsStorageKey = \"ton-connect-session_storage_launchParams\";\n  if (Object.entries(initParams).length > 0) {\n    sessionStorage.setItem(launchParamsStorageKey, JSON.stringify(initParams));\n  } else {\n    const savedInitParams = sessionStorage.getItem(launchParamsStorageKey);\n    if (savedInitParams) {\n      initParams = JSON.parse(savedInitParams);\n    }\n  }\n} catch (e2) {\n}\nlet tmaPlatform = \"unknown\";\nif (initParams == null ? void 0 : initParams.tgWebAppPlatform) {\n  tmaPlatform = (_a = initParams.tgWebAppPlatform) != null ? _a : \"unknown\";\n}\nif (tmaPlatform === \"unknown\") {\n  const window2 = getWindow$1();\n  tmaPlatform = (_d = (_c = (_b = window2 == null ? void 0 : window2.Telegram) == null ? void 0 : _b.WebApp) == null ? void 0 : _c.platform) != null ? _d : \"unknown\";\n}\nlet webAppVersion = \"6.0\";\nif (initParams == null ? void 0 : initParams.tgWebAppVersion) {\n  webAppVersion = initParams.tgWebAppVersion;\n}\nif (!webAppVersion) {\n  const window2 = getWindow$1();\n  webAppVersion = (_g = (_f = (_e = window2 == null ? void 0 : window2.Telegram) == null ? void 0 : _e.WebApp) == null ? void 0 : _f.version) != null ? _g : \"6.0\";\n}\nconst initDataRaw = initParams == null ? void 0 : initParams.tgWebAppData;\nlet telegramUser = void 0;\ntry {\n  if (initDataRaw) {\n    let initData = urlParseQueryString(initDataRaw);\n    let userRaw = initData.user;\n    if (userRaw) {\n      let user = JSON.parse(userRaw);\n      if (typeof user.id === \"number\" && typeof user.is_premium === \"boolean\") {\n        telegramUser = {\n          id: user.id,\n          isPremium: user.is_premium\n        };\n      }\n    }\n  }\n} catch (e2) {\n}\nfunction getTgUser() {\n  return telegramUser;\n}\nfunction isTmaPlatform(...platforms) {\n  return platforms.includes(tmaPlatform);\n}\nfunction isInTMA() {\n  var _a2;\n  return tmaPlatform !== \"unknown\" || !!((_a2 = getWindow$1()) == null ? void 0 : _a2.TelegramWebviewProxy);\n}\nfunction isInTelegramBrowser() {\n  var _a2;\n  const isTelegramWebview = !!((_a2 = getWindow$1()) == null ? void 0 : _a2.TelegramWebview);\n  return (isInTMA() || isTelegramWebview) && tmaPlatform === \"unknown\";\n}\nfunction sendExpand() {\n  postEvent(\"web_app_expand\", {});\n}\nfunction sendOpenTelegramLink(link, fallback) {\n  const url = new URL(link);\n  if (url.protocol !== \"http:\" && url.protocol !== \"https:\") {\n    if (fallback) {\n      return fallback();\n    }\n    throw new TonConnectUIError(`Url protocol is not supported: ${url}`);\n  }\n  if (url.hostname !== \"t.me\") {\n    if (fallback) {\n      return fallback();\n    }\n    throw new TonConnectUIError(`Url host is not supported: ${url}`);\n  }\n  const pathFull = url.pathname + url.search;\n  if (isIframe() || versionAtLeast(\"6.1\")) {\n    setLastOpenedLink({ link: pathFull, type: \"tg_link\" });\n    postEvent(\"web_app_open_tg_link\", { path_full: pathFull });\n  } else {\n    openLinkBlank(\"https://t.me\" + pathFull);\n  }\n}\nfunction isIframe() {\n  try {\n    const window2 = getWindow$1();\n    if (!window2) {\n      return false;\n    }\n    return window2.parent != null && window2 !== window2.parent;\n  } catch (e2) {\n    return false;\n  }\n}\nfunction postEvent(eventType, eventData) {\n  try {\n    const window2 = getWindow$1();\n    if (!window2) {\n      throw new TonConnectUIError(`Can't post event to parent window: window is not defined`);\n    }\n    if (window2.TelegramWebviewProxy !== void 0) {\n      logDebug(\"postEvent\", eventType, eventData);\n      window2.TelegramWebviewProxy.postEvent(eventType, JSON.stringify(eventData));\n    } else if (window2.external && \"notify\" in window2.external) {\n      logDebug(\"postEvent\", eventType, eventData);\n      window2.external.notify(JSON.stringify({ eventType, eventData }));\n    } else if (isIframe()) {\n      const trustedTarget = \"*\";\n      const message = JSON.stringify({ eventType, eventData });\n      logDebug(\"postEvent\", eventType, eventData);\n      window2.parent.postMessage(message, trustedTarget);\n    } else {\n      throw new TonConnectUIError(`Can't post event to TMA`);\n    }\n  } catch (e2) {\n    logError(`Can't post event to parent window: ${e2}`);\n  }\n}\nfunction urlParseHashParams(locationHash) {\n  locationHash = locationHash.replace(/^#/, \"\");\n  let params = {};\n  if (!locationHash.length) {\n    return params;\n  }\n  if (locationHash.indexOf(\"=\") < 0 && locationHash.indexOf(\"?\") < 0) {\n    params._path = urlSafeDecode(locationHash);\n    return params;\n  }\n  let qIndex = locationHash.indexOf(\"?\");\n  if (qIndex >= 0) {\n    let pathParam = locationHash.substr(0, qIndex);\n    params._path = urlSafeDecode(pathParam);\n    locationHash = locationHash.substr(qIndex + 1);\n  }\n  let query_params = urlParseQueryString(locationHash);\n  for (let k in query_params) {\n    params[k] = query_params[k];\n  }\n  return params;\n}\nfunction urlSafeDecode(urlencoded) {\n  try {\n    urlencoded = urlencoded.replace(/\\+/g, \"%20\");\n    return decodeURIComponent(urlencoded);\n  } catch (e2) {\n    return urlencoded;\n  }\n}\nfunction urlParseQueryString(queryString) {\n  let params = {};\n  if (!queryString.length) {\n    return params;\n  }\n  let queryStringParams = queryString.split(\"&\");\n  let i2, param, paramName, paramValue;\n  for (i2 = 0; i2 < queryStringParams.length; i2++) {\n    param = queryStringParams[i2].split(\"=\");\n    paramName = urlSafeDecode(param[0]);\n    paramValue = param[1] == null ? null : urlSafeDecode(param[1]);\n    params[paramName] = paramValue;\n  }\n  return params;\n}\nfunction versionCompare(v1, v2) {\n  if (typeof v1 !== \"string\") v1 = \"\";\n  let v1List = v1.replace(/^\\s+|\\s+$/g, \"\").split(\".\");\n  let v2List = v2.replace(/^\\s+|\\s+$/g, \"\").split(\".\");\n  let a2, i2, p1, p2;\n  a2 = Math.max(v1List.length, v2List.length);\n  for (i2 = 0; i2 < a2; i2++) {\n    p1 = parseInt(v1List[i2]) || 0;\n    p2 = parseInt(v2List[i2]) || 0;\n    if (p1 === p2) continue;\n    if (p1 > p2) return 1;\n    return -1;\n  }\n  return 0;\n}\nfunction versionAtLeast(ver) {\n  return versionCompare(webAppVersion, ver) >= 0;\n}\nconst maxWidth = {\n  mobile: 440,\n  tablet: 1020\n};\nfunction isDevice(device) {\n  const window2 = getWindow$1();\n  if (!window2) {\n    return device === \"desktop\";\n  }\n  if (isTmaPlatform(\"weba\")) {\n    return true;\n  }\n  const width = window2.innerWidth;\n  switch (device) {\n    case \"desktop\":\n      return width > maxWidth.tablet;\n    case \"tablet\":\n      return width > maxWidth.mobile;\n    default:\n    case \"mobile\":\n      return width <= maxWidth.mobile || isOS(\"ios\", \"android\", \"ipad\");\n  }\n}\nfunction media(device) {\n  switch (device) {\n    case \"mobile\":\n      return `@media (max-width: ${maxWidth.mobile}px)`;\n    case \"tablet\":\n      return `@media (max-width: ${maxWidth.tablet}px) (min-width: ${maxWidth.mobile}px)`;\n    default:\n    case \"desktop\":\n      return `@media (min-width: ${maxWidth.tablet}px)`;\n  }\n}\nconst mediaTouch = \"@media (hover: none)\";\nconst mediaNotTouch = \"@media not all and (hover: none)\";\nconst borders$6 = {\n  m: \"100vh\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst scaleValues = {\n  s: 0.02,\n  m: 0.04\n};\nconst ButtonStyled$1 = styled.button`\n    display: ${(props) => props.leftIcon || props.rightIcon ? \"flex\" : \"inline-block\"};\n    gap: ${(props) => props.leftIcon || props.rightIcon ? \"6px\" : \"unset\"};\n    align-items: ${(props) => props.leftIcon || props.rightIcon ? \"center\" : \"unset\"};\n    justify-content: ${(props) => props.leftIcon || props.rightIcon ? \"space-between\" : \"unset\"};\n    background-color: ${(props) => props.appearance === \"flat\" ? \"transparent\" : props.appearance === \"secondary\" ? props.theme.colors.background.tint : rgba(props.theme.colors.accent, 0.12)};\n    color: ${(props) => props.appearance === \"secondary\" ? props.theme.colors.text.primary : props.theme.colors.accent};\n\n    padding: ${(props) => props.appearance === \"flat\" ? \"0\" : \"9px 16px\"};\n    padding-left: ${(props) => props.leftIcon && props.appearance !== \"flat\" ? \"12px\" : \"16px\"};\n    padding-right: ${(props) => props.rightIcon && props.appearance !== \"flat\" ? \"12px\" : \"16px\"};\n    border: none;\n    border-radius: ${(props) => borders$6[props.theme.borderRadius]};\n    cursor: ${(props) => props.disabled ? \"not-allowed\" : \"pointer\"};\n\n    font-size: 14px;\n    font-weight: 510;\n    line-height: 18px;\n\n    transition: transform 0.125s ease-in-out;\n\n    ${mediaNotTouch} {\n        &:hover {\n            transform: ${(props) => props.disabled ? \"unset\" : `scale(${1 + scaleValues[props.scale]})`};\n        }\n    }\n\n    &:active {\n        transform: ${(props) => props.disabled ? \"unset\" : `scale(${1 - scaleValues[props.scale]})`};\n    }\n\n    ${mediaTouch} {\n        &:active {\n            transform: ${(props) => props.disabled ? \"unset\" : `scale(${1 - scaleValues[props.scale] * 2})`};\n        }\n    }\n`;\nfunction useDataAttributes(props) {\n  const keys = untrack(() => Object.keys(props).filter((key) => key.startsWith(\"data-\")));\n  const [dataAttrs] = splitProps(props, keys);\n  return dataAttrs;\n}\nconst Button = (props) => {\n  const dataAttrs = useDataAttributes(props);\n  return createComponent(ButtonStyled$1, mergeProps({\n    type: \"button\",\n    get appearance() {\n      return props.appearance || \"primary\";\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    onClick: (e2) => {\n      var _a2;\n      return (_a2 = props.onClick) == null ? void 0 : _a2.call(props, e2);\n    },\n    onMouseEnter: (e2) => {\n      var _a2;\n      return (_a2 = props.onMouseEnter) == null ? void 0 : _a2.call(props, e2);\n    },\n    onMouseLeave: (e2) => {\n      var _a2;\n      return (_a2 = props.onMouseLeave) == null ? void 0 : _a2.call(props, e2);\n    },\n    ref(r$) {\n      var _ref$ = props.ref;\n      typeof _ref$ === \"function\" ? _ref$(r$) : props.ref = r$;\n    },\n    get disabled() {\n      return props.disabled;\n    },\n    get scale() {\n      return props.scale || \"m\";\n    },\n    get leftIcon() {\n      return !!props.leftIcon;\n    },\n    get rightIcon() {\n      return !!props.rightIcon;\n    },\n    \"data-tc-button\": \"true\"\n  }, dataAttrs, {\n    get children() {\n      return [memo(() => props.leftIcon), memo(() => props.children), memo(() => props.rightIcon)];\n    }\n  }));\n};\nconst noop = () => {\n};\nconst noopTransition = (el, done) => done();\nfunction createSwitchTransition(source, options) {\n  const initSource = untrack(source);\n  const initReturned = initSource ? [initSource] : [];\n  const { onEnter = noopTransition, onExit = noopTransition } = options;\n  const [returned, setReturned] = createSignal(options.appear ? [] : initReturned);\n  const [isTransitionPending] = useTransition();\n  let next;\n  let isExiting = false;\n  function exitTransition2(el, after) {\n    if (!el)\n      return after && after();\n    isExiting = true;\n    onExit(el, () => {\n      batch(() => {\n        isExiting = false;\n        setReturned((p2) => p2.filter((e2) => e2 !== el));\n        after && after();\n      });\n    });\n  }\n  function enterTransition2(after) {\n    const el = next;\n    if (!el)\n      return after && after();\n    next = void 0;\n    setReturned((p2) => [el, ...p2]);\n    onEnter(el, after != null ? after : noop);\n  }\n  const triggerTransitions = options.mode === \"out-in\" ? (\n    // exit -> enter\n    // exit -> enter\n    (prev) => isExiting || exitTransition2(prev, enterTransition2)\n  ) : options.mode === \"in-out\" ? (\n    // enter -> exit\n    // enter -> exit\n    (prev) => enterTransition2(() => exitTransition2(prev))\n  ) : (\n    // exit & enter\n    // exit & enter\n    (prev) => {\n      exitTransition2(prev);\n      enterTransition2();\n    }\n  );\n  createComputed((prev) => {\n    const el = source();\n    if (untrack(isTransitionPending)) {\n      isTransitionPending();\n      return prev;\n    }\n    if (el !== prev) {\n      next = el;\n      batch(() => untrack(() => triggerTransitions(prev)));\n    }\n    return el;\n  }, options.appear ? void 0 : initSource);\n  return returned;\n}\nfunction createListTransition(source, options) {\n  const initSource = untrack(source);\n  const { onChange } = options;\n  let prevSet = new Set(options.appear ? void 0 : initSource);\n  const exiting = /* @__PURE__ */ new WeakSet();\n  const [toRemove, setToRemove] = createSignal([], { equals: false });\n  const [isTransitionPending] = useTransition();\n  const finishRemoved = (els) => {\n    setToRemove((p2) => (p2.push.apply(p2, els), p2));\n    for (const el of els)\n      exiting.delete(el);\n  };\n  const handleRemoved = (els, el, i2) => els.splice(i2, 0, el);\n  return createMemo((prev) => {\n    const elsToRemove = toRemove();\n    const sourceList = source();\n    sourceList[$TRACK];\n    if (untrack(isTransitionPending)) {\n      isTransitionPending();\n      return prev;\n    }\n    if (elsToRemove.length) {\n      const next = prev.filter((e2) => !elsToRemove.includes(e2));\n      elsToRemove.length = 0;\n      onChange({ list: next, added: [], removed: [], unchanged: next, finishRemoved });\n      return next;\n    }\n    return untrack(() => {\n      const nextSet = new Set(sourceList);\n      const next = sourceList.slice();\n      const added = [];\n      const removed = [];\n      const unchanged = [];\n      for (const el of sourceList) {\n        (prevSet.has(el) ? unchanged : added).push(el);\n      }\n      let nothingChanged = !added.length;\n      for (let i2 = 0; i2 < prev.length; i2++) {\n        const el = prev[i2];\n        if (!nextSet.has(el)) {\n          if (!exiting.has(el)) {\n            removed.push(el);\n            exiting.add(el);\n          }\n          handleRemoved(next, el, i2);\n        }\n        if (nothingChanged && el !== next[i2])\n          nothingChanged = false;\n      }\n      if (!removed.length && nothingChanged)\n        return prev;\n      onChange({ list: next, added, removed, unchanged, finishRemoved });\n      prevSet = nextSet;\n      return next;\n    });\n  }, options.appear ? [] : initSource.slice());\n}\nconst defaultElementPredicate = (item) => item instanceof Element;\nfunction getResolvedElements(value, predicate) {\n  if (predicate(value))\n    return value;\n  if (typeof value === \"function\" && !value.length)\n    return getResolvedElements(value(), predicate);\n  if (Array.isArray(value)) {\n    const results = [];\n    for (const item of value) {\n      const result = getResolvedElements(item, predicate);\n      if (result)\n        Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results.length ? results : null;\n  }\n  return null;\n}\nfunction resolveElements(fn, predicate = defaultElementPredicate, serverPredicate = defaultElementPredicate) {\n  const children2 = createMemo(fn);\n  const memo2 = createMemo(() => getResolvedElements(children2(), predicate));\n  memo2.toArray = () => {\n    const value = memo2();\n    return Array.isArray(value) ? value : value ? [value] : [];\n  };\n  return memo2;\n}\nfunction getFirstChild(value, predicate) {\n  if (predicate(value))\n    return value;\n  if (typeof value === \"function\" && !value.length)\n    return getFirstChild(value(), predicate);\n  if (Array.isArray(value)) {\n    for (const item of value) {\n      const result = getFirstChild(item, predicate);\n      if (result)\n        return result;\n    }\n  }\n  return null;\n}\nfunction resolveFirst(fn, predicate = defaultElementPredicate, serverPredicate = defaultElementPredicate) {\n  const children2 = createMemo(fn);\n  return createMemo(() => getFirstChild(children2(), predicate));\n}\nfunction createClassnames(props) {\n  return createMemo(() => {\n    const name = props.name || \"s\";\n    return {\n      enterActive: (props.enterActiveClass || name + \"-enter-active\").split(\" \"),\n      enter: (props.enterClass || name + \"-enter\").split(\" \"),\n      enterTo: (props.enterToClass || name + \"-enter-to\").split(\" \"),\n      exitActive: (props.exitActiveClass || name + \"-exit-active\").split(\" \"),\n      exit: (props.exitClass || name + \"-exit\").split(\" \"),\n      exitTo: (props.exitToClass || name + \"-exit-to\").split(\" \"),\n      move: (props.moveClass || name + \"-move\").split(\" \")\n    };\n  });\n}\nfunction nextFrame(fn) {\n  requestAnimationFrame(() => requestAnimationFrame(fn));\n}\nfunction enterTransition(classes, events, el, done) {\n  const { onBeforeEnter, onEnter, onAfterEnter } = events;\n  onBeforeEnter == null ? void 0 : onBeforeEnter(el);\n  el.classList.add(...classes.enter);\n  el.classList.add(...classes.enterActive);\n  queueMicrotask(() => {\n    if (!el.parentNode)\n      return done == null ? void 0 : done();\n    onEnter == null ? void 0 : onEnter(el, () => endTransition());\n  });\n  nextFrame(() => {\n    el.classList.remove(...classes.enter);\n    el.classList.add(...classes.enterTo);\n    if (!onEnter || onEnter.length < 2) {\n      el.addEventListener(\"transitionend\", endTransition);\n      el.addEventListener(\"animationend\", endTransition);\n    }\n  });\n  function endTransition(e2) {\n    if (!e2 || e2.target === el) {\n      done == null ? void 0 : done();\n      el.removeEventListener(\"transitionend\", endTransition);\n      el.removeEventListener(\"animationend\", endTransition);\n      el.classList.remove(...classes.enterActive);\n      el.classList.remove(...classes.enterTo);\n      onAfterEnter == null ? void 0 : onAfterEnter(el);\n    }\n  }\n}\nfunction exitTransition(classes, events, el, done) {\n  const { onBeforeExit, onExit, onAfterExit } = events;\n  if (!el.parentNode)\n    return done == null ? void 0 : done();\n  onBeforeExit == null ? void 0 : onBeforeExit(el);\n  el.classList.add(...classes.exit);\n  el.classList.add(...classes.exitActive);\n  onExit == null ? void 0 : onExit(el, () => endTransition());\n  nextFrame(() => {\n    el.classList.remove(...classes.exit);\n    el.classList.add(...classes.exitTo);\n    if (!onExit || onExit.length < 2) {\n      el.addEventListener(\"transitionend\", endTransition);\n      el.addEventListener(\"animationend\", endTransition);\n    }\n  });\n  function endTransition(e2) {\n    if (!e2 || e2.target === el) {\n      done == null ? void 0 : done();\n      el.removeEventListener(\"transitionend\", endTransition);\n      el.removeEventListener(\"animationend\", endTransition);\n      el.classList.remove(...classes.exitActive);\n      el.classList.remove(...classes.exitTo);\n      onAfterExit == null ? void 0 : onAfterExit(el);\n    }\n  }\n}\nconst TRANSITION_MODE_MAP = {\n  inout: \"in-out\",\n  outin: \"out-in\"\n};\nconst Transition = (props) => {\n  const classnames = createClassnames(props);\n  return createSwitchTransition(resolveFirst(() => props.children), {\n    mode: TRANSITION_MODE_MAP[props.mode],\n    appear: props.appear,\n    onEnter(el, done) {\n      enterTransition(classnames(), props, el, done);\n    },\n    onExit(el, done) {\n      exitTransition(classnames(), props, el, done);\n    }\n  });\n};\nconst TransitionGroup = (props) => {\n  const classnames = createClassnames(props);\n  return createListTransition(resolveElements(() => props.children).toArray, {\n    appear: props.appear,\n    onChange({ added, removed, finishRemoved, list }) {\n      const classes = classnames();\n      for (const el of added) {\n        enterTransition(classes, props, el);\n      }\n      const toMove = [];\n      for (const el of list) {\n        if (el.isConnected && (el instanceof HTMLElement || el instanceof SVGElement)) {\n          toMove.push({ el, rect: el.getBoundingClientRect() });\n        }\n      }\n      queueMicrotask(() => {\n        const moved = [];\n        for (const { el, rect } of toMove) {\n          if (el.isConnected) {\n            const newRect = el.getBoundingClientRect(), dX = rect.left - newRect.left, dY = rect.top - newRect.top;\n            if (dX || dY) {\n              el.style.transform = `translate(${dX}px, ${dY}px)`;\n              el.style.transitionDuration = \"0s\";\n              moved.push(el);\n            }\n          }\n        }\n        document.body.offsetHeight;\n        for (const el of moved) {\n          let endTransition = function(e2) {\n            if (e2.target === el || /transform$/.test(e2.propertyName)) {\n              el.removeEventListener(\"transitionend\", endTransition);\n              el.classList.remove(...classes.move);\n            }\n          };\n          el.classList.add(...classes.move);\n          el.style.transform = el.style.transitionDuration = \"\";\n          el.addEventListener(\"transitionend\", endTransition);\n        }\n      });\n      for (const el of removed) {\n        exitTransition(classes, props, el, () => finishRemoved([el]));\n      }\n    }\n  });\n};\nfunction clickOutside$1(el, accessor) {\n  const onClick = (e2) => {\n    var _a2;\n    return !el.contains(e2.target) && ((_a2 = accessor()) == null ? void 0 : _a2());\n  };\n  document.body.addEventListener(\"click\", onClick);\n  onCleanup(() => document.body.removeEventListener(\"click\", onClick));\n}\nfunction escPressed(_, accessor) {\n  const onKeyPress = (e2) => {\n    var _a2, _b2;\n    if (e2.key === \"Escape\") {\n      (_a2 = document.activeElement) == null ? void 0 : _a2.blur();\n      (_b2 = accessor()) == null ? void 0 : _b2();\n    }\n  };\n  document.body.addEventListener(\"keydown\", onKeyPress);\n  onCleanup(() => document.body.removeEventListener(\"keydown\", onKeyPress));\n}\nfunction androidBackHandler$1(_, config) {\n  const {\n    isEnabled,\n    onClose\n  } = config();\n  if (!isEnabled) {\n    return;\n  }\n  const userOSIsAndroid = getUserAgent().os === \"android\";\n  if (!userOSIsAndroid) {\n    return;\n  }\n  window.history.pushState(ROUTE_STATE, \"\");\n  const popstateHandler = (event) => {\n    event.preventDefault();\n    onClose();\n  };\n  window.addEventListener(\"popstate\", popstateHandler, {\n    once: true\n  });\n  onCleanup(() => {\n    window.removeEventListener(\"popstate\", popstateHandler);\n    createMacrotask(() => {\n      var _a2;\n      if (((_a2 = window.history.state) == null ? void 0 : _a2[ROUTE_STATE_KEY]) === true) {\n        window.history.back();\n      }\n    });\n  });\n}\nconst ROUTE_STATE_KEY = \"androidBackHandler\";\nconst ROUTE_STATE = {\n  [ROUTE_STATE_KEY]: true\n};\nvar _tmpl$$v = /* @__PURE__ */ template$1(`<svg><path fill-rule=evenodd clip-rule=evenodd d=\"M10.2122 14.3407C10.5384 14.0854 10.5959 13.614 10.3406 13.2878L6.20237 8.00003L10.3406 2.71227C10.5959 2.38607 10.5384 1.91469 10.2122 1.6594C9.88604 1.40412 9.41465 1.46161 9.15937 1.7878L4.65937 7.5378C4.44688 7.80932 4.44688 8.19074 4.65937 8.46226L9.15937 14.2123C9.41465 14.5385 9.88604 14.5959 10.2122 14.3407Z\"></svg>`, false, true, false);\nconst rotationDegrees = {\n  left: 0,\n  top: 90,\n  right: 180,\n  bottom: 270\n};\nconst ArrowIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  const direction = () => props.direction || \"left\";\n  const Svg = styled(\"svg\")`\n        transform: rotate(${(props2) => rotationDegrees[props2.svgDirection]}deg);\n        transition: transform 0.1s ease-in-out;\n    `;\n  return createComponent(Svg, {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: \"16\",\n    height: \"16\",\n    viewBox: \"0 0 16 16\",\n    fill: \"none\",\n    get svgDirection() {\n      return direction();\n    },\n    get children() {\n      var _el$ = _tmpl$$v();\n      createRenderEffect(() => setAttribute(_el$, \"fill\", fill()));\n      return _el$;\n    }\n  });\n};\nvar _tmpl$$u = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M2.71966 2.71968C3.01255 2.42678 3.48743 2.42677 3.78032 2.71966L8.00002 6.93925L12.2197 2.71967C12.5126 2.42677 12.9874 2.42678 13.2803 2.71967C13.5732 3.01257 13.5732 3.48744 13.2803 3.78033L9.06068 7.99991L13.2803 12.2197C13.5732 12.5126 13.5732 12.9874 13.2803 13.2803C12.9874 13.5732 12.5126 13.5732 12.2197 13.2803L8.00002 9.06057L3.78033 13.2803C3.48744 13.5732 3.01257 13.5732 2.71967 13.2803C2.42678 12.9874 2.42677 12.5126 2.71967 12.2197L6.93936 7.99991L2.71968 3.78034C2.42678 3.48745 2.42677 3.01257 2.71966 2.71968Z\">`);\nconst CloseIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    var _el$ = _tmpl$$u(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nconst IconButtonStyled = styled.button`\n    padding: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 32px;\n    height: 32px;\n    border-radius: 50%;\n    background-color: ${(props) => props.theme.colors.background.tint};\n    border: none;\n    cursor: pointer;\n\n    transition: transform 0.125s ease-in-out;\n\n    ${mediaNotTouch} {\n        &:hover {\n            transform: scale(1.04);\n        }\n    }\n\n    &:active {\n        transform: scale(0.96);\n    }\n\n    ${mediaTouch} {\n        &:active {\n            transform: scale(0.92);\n        }\n    }\n`;\nconst IconButton = (props) => {\n  const dataAttrs = useDataAttributes(props);\n  const icon = () => props.icon || \"close\";\n  return createComponent(IconButtonStyled, mergeProps({\n    get [\"class\"]() {\n      return props.class;\n    },\n    onClick: () => props.onClick(),\n    \"data-tc-icon-button\": \"true\"\n  }, dataAttrs, {\n    get children() {\n      return [createComponent(Show, {\n        get when() {\n          return !!props.children;\n        },\n        get children() {\n          return props.children;\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !props.children;\n        },\n        get children() {\n          return createComponent(Switch, {\n            get children() {\n              return [createComponent(Match, {\n                get when() {\n                  return icon() === \"close\";\n                },\n                get children() {\n                  return createComponent(CloseIcon, {\n                    get fill() {\n                      return props.fill;\n                    }\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return icon() === \"arrow\";\n                },\n                get children() {\n                  return createComponent(ArrowIcon, {\n                    get fill() {\n                      return props.fill;\n                    }\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return icon() === \"question\";\n                },\n                get children() {\n                  return createComponent(QuestionIcon, {\n                    get fill() {\n                      return props.fill;\n                    }\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return typeof icon() !== \"string\";\n                },\n                get children() {\n                  return icon();\n                }\n              })];\n            }\n          });\n        }\n      })];\n    }\n  }));\n};\nconst borders$5 = {\n  m: \"24px\",\n  s: \"16px\",\n  none: \"0\"\n};\nconst ModalBackgroundStyled = styled.div`\n    display: flex;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.4);\n    padding: 20px 0;\n    overflow-y: auto;\n\n    ${media(\"mobile\")} {\n        padding-bottom: 0;\n    }\n`;\nconst ModalWrapperClass = u`\n    box-shadow:\n        0 4px 16px rgba(0, 0, 0, 0.08),\n        0 16px 64px rgba(0, 0, 0, 0.16);\n    width: fit-content;\n    margin: auto;\n\n    ${media(\"mobile\")} {\n        width: 100%;\n        height: fit-content;\n        margin: auto 0 0 0;\n    }\n`;\nconst ModalBodyStyled = styled.div`\n    position: relative;\n    min-height: 100px;\n    width: 416px;\n    padding: 44px 56px 24px;\n\n    box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.04);\n\n    background-color: ${(props) => props.theme.colors.background.primary};\n    border-radius: ${(props) => borders$5[props.theme.borderRadius]};\n\n    ${media(\"mobile\")} {\n        width: 100%;\n    }\n`;\nconst CloseButtonStyled = styled(IconButton)`\n    position: absolute;\n    right: 16px;\n    top: 16px;\n`;\nconst ModalFooterStyled = styled.div`\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 16px 16px 16px 18px;\n    border-radius: 0 0 ${(props) => borders$5[props.theme.borderRadius]}\n        ${(props) => borders$5[props.theme.borderRadius]};\n`;\nconst QuestionButtonStyled = styled(IconButton)`\n    background-color: ${(props) => rgba(props.theme.colors.icon.secondary, 0.12)};\n`;\nclass AnimationTimelineNoop {\n  constructor() {\n    this.currentTime = 0;\n  }\n}\nconst _AnimationNoop = class _AnimationNoop {\n  constructor() {\n    this.currentTime = 0;\n    this.playbackRate = 1;\n    this.startTime = null;\n    this.timeline = new AnimationTimelineNoop();\n    this.finished = Promise.resolve(this);\n    this.effect = null;\n    this.id = \"\";\n    this.pending = false;\n    this.playState = \"finished\";\n    this.replaceState = \"active\";\n    this.ready = Promise.resolve(this);\n    this.oncancel = null;\n    this.onfinish = null;\n    this.onremove = null;\n  }\n  static create() {\n    if (!_AnimationNoop._instance) {\n      logWarning(\n        \"Animation is not supported in this environment: please consider using the `web-animations-js` polyfill to provide a fallback implementation of the Web Animations API.\"\n      );\n      _AnimationNoop._instance = new _AnimationNoop();\n    }\n    return _AnimationNoop._instance;\n  }\n  cancel() {\n  }\n  finish() {\n  }\n  pause() {\n  }\n  play() {\n  }\n  reverse() {\n  }\n  addEventListener(_type, _listener, _options) {\n  }\n  dispatchEvent(_event) {\n    return false;\n  }\n  removeEventListener(_type, _callback, _options) {\n  }\n  updatePlaybackRate(_playbackRate) {\n  }\n  commitStyles() {\n  }\n  persist() {\n  }\n};\n_AnimationNoop._instance = null;\nlet AnimationNoop = _AnimationNoop;\nfunction animate(element, keyframes, options) {\n  if (\"animate\" in element) {\n    return element.animate(keyframes, options);\n  }\n  return AnimationNoop.create();\n}\nvar _tmpl$$t = /* @__PURE__ */ template$1(`<div>`);\nconst clickOutside = clickOutside$1;\nconst keyPressed = escPressed;\nconst androidBackHandler = androidBackHandler$1;\nconst Modal = (props) => {\n  const theme = useTheme();\n  const dataAttrs = useDataAttributes(props);\n  createEffect(() => {\n    if (props.opened) {\n      disableScroll();\n    } else {\n      enableScroll();\n    }\n  });\n  return createComponent(Transition, {\n    onBeforeEnter: (el) => {\n      const duration = isDevice(\"mobile\") ? 200 : 100;\n      animate(el, [{\n        opacity: 0\n      }, {\n        opacity: 1\n      }], {\n        duration\n      });\n      if (isDevice(\"mobile\")) {\n        animate(el.firstElementChild, [{\n          transform: \"translateY(390px)\"\n        }, {\n          transform: \"translateY(0)\"\n        }], {\n          duration\n        });\n      }\n    },\n    onExit: (el, done) => {\n      const duration = isDevice(\"mobile\") ? 200 : 100;\n      const backgroundAnimation = animate(el, [{\n        opacity: 1\n      }, {\n        opacity: 0\n      }], {\n        duration\n      });\n      if (isDevice(\"mobile\")) {\n        const contentAnimation = animate(el.firstElementChild, [{\n          transform: \"translateY(0)\"\n        }, {\n          transform: \"translateY(390px)\"\n        }], {\n          duration\n        });\n        Promise.all([backgroundAnimation.finished, contentAnimation.finished]).then(done);\n      } else {\n        backgroundAnimation.finished.then(done);\n      }\n    },\n    get children() {\n      return createComponent(Show, {\n        get when() {\n          return props.opened;\n        },\n        get children() {\n          return createComponent(ModalBackgroundStyled, mergeProps({\n            \"data-tc-modal\": \"true\"\n          }, dataAttrs, {\n            get children() {\n              var _el$ = _tmpl$$t();\n              use(androidBackHandler, _el$, () => ({\n                isEnabled: props.enableAndroidBackHandler,\n                onClose: () => props.onClose()\n              }));\n              use(keyPressed, _el$, () => () => props.onClose());\n              use(clickOutside, _el$, () => () => props.onClose());\n              insert(_el$, createComponent(ModalBodyStyled, {\n                get [\"class\"]() {\n                  return props.class;\n                },\n                get children() {\n                  return [createComponent(CloseButtonStyled, {\n                    icon: \"close\",\n                    onClick: () => props.onClose()\n                  }), memo(() => props.children)];\n                }\n              }), null);\n              insert(_el$, createComponent(Show, {\n                get when() {\n                  return props.onClickQuestion && props.showFooter;\n                },\n                get children() {\n                  return createComponent(ModalFooterStyled, {\n                    get children() {\n                      return [createComponent(TonConnectBrand, {}), createComponent(QuestionButtonStyled, {\n                        get onClick() {\n                          return props.onClickQuestion;\n                        },\n                        icon: \"question\"\n                      })];\n                    }\n                  });\n                }\n              }), null);\n              createRenderEffect(() => className(_el$, classnames__WEBPACK_IMPORTED_MODULE_3__(ModalWrapperClass, u`\n                                border-radius: ${borders$5[theme.borderRadius]};\n                                background-color: ${theme.colors.background.tint};\n\n                                ${media(\"mobile\")} {\n                                    border-radius: ${borders$5[theme.borderRadius]}\n                                        ${borders$5[theme.borderRadius]} 0 0;\n                                }\n                            `)));\n              return _el$;\n            }\n          }));\n        }\n      });\n    }\n  });\n};\nconst wrapperBorderRadius = {\n  m: \"22px\",\n  s: \"12px\",\n  none: \"0\"\n};\nconst sliderBorderRadius = {\n  m: \"18px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst TabBarStyled = styled.div`\n    display: grid;\n    grid-template: 1fr / 1fr 1fr;\n    width: fit-content;\n    justify-items: center;\n    gap: 4px;\n\n    position: relative;\n    padding: 4px;\n    border-radius: ${(props) => wrapperBorderRadius[props.theme.borderRadius]};\n\n    background-color: ${(props) => props.theme.colors.background.secondary};\n`;\nconst SliderStyled = styled.div`\n    position: absolute;\n    top: 4px;\n    left: 4px;\n\n    height: calc(100% - 8px);\n    width: calc(50% - 4px);\n\n    border-radius: ${(props) => sliderBorderRadius[props.theme.borderRadius]};\n    background-color: ${(props) => props.theme.colors.background.segment};\n\n    transform: ${(props) => props.right ? \"translateX(100%)\" : \"translateX(0)\"};\n\n    transition: transform 0.13s ease-in-out;\n`;\nconst InputStyled = styled.input`\n    display: none;\n`;\nconst LabelStyled = styled.label`\n    padding: 9px 12px;\n    z-index: 1;\n\n    cursor: ${(props) => props.isActive ? \"default\" : \"pointer\"};\n\n    transition: transform 0.13s ease-in-out;\n\n    &:hover {\n        transform: ${(props) => props.isActive ? \"none\" : \"scale(1.025)\"};\n    }\n\n    > * {\n        ${(props) => !props.isActive ? `color: ${props.theme.colors.text.secondary};` : \"\"}\n    }\n`;\nconst TabBar = (props) => {\n  const groupName = \"tabBar\" + Math.floor(Math.random() * 1e4);\n  return createComponent(TabBarStyled, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-tab-bar\": \"true\",\n    get children() {\n      return [createComponent(SliderStyled, {\n        get right() {\n          return props.selectedTabIndex === 1;\n        }\n      }), createComponent(LabelStyled, {\n        get isActive() {\n          return props.selectedTabIndex === 0;\n        },\n        get children() {\n          return [createComponent(InputStyled, {\n            type: \"radio\",\n            name: groupName,\n            get checked() {\n              return props.selectedTabIndex === 0;\n            },\n            onInput: () => {\n              var _a2;\n              return (_a2 = props.onSelectedTabIndexChange) == null ? void 0 : _a2.call(props, 0);\n            }\n          }), memo(() => props.tab1)];\n        }\n      }), createComponent(LabelStyled, {\n        get isActive() {\n          return props.selectedTabIndex === 1;\n        },\n        get children() {\n          return [createComponent(InputStyled, {\n            type: \"radio\",\n            get checked() {\n              return props.selectedTabIndex === 1;\n            },\n            name: groupName,\n            onInput: () => {\n              var _a2;\n              return (_a2 = props.onSelectedTabIndexChange) == null ? void 0 : _a2.call(props, 1);\n            }\n          }), memo(() => props.tab2)];\n        }\n      })];\n    }\n  });\n};\nconst backgroundBorders = {\n  m: \"16px\",\n  s: \"12px\",\n  none: \"0\"\n};\nconst imageBorders = {\n  m: \"12px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst qrNormalSize = 256;\nconst imgSizeDefault = 60;\nconst picSizeDefault = 48;\nconst qrPaddingTop = 24;\nconst CopyIconButton = styled.div`\n    width: 52px;\n    height: 52px;\n    background: transparent;\n    position: absolute;\n    right: 0;\n    bottom: 0;\n\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    transition: transform 0.125s ease-in-out;\n`;\nconst QrCodeBackground = styled.button`\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    position: relative;\n    background-color: ${(props) => props.theme.colors.background.qr};\n    border-radius: ${(props) => backgroundBorders[props.theme.borderRadius]};\n    padding: ${toPx(qrPaddingTop)} 0;\n    height: ${toPx(qrNormalSize + qrPaddingTop * 2)};\n    width: 100%;\n\n    overflow: hidden;\n    cursor: pointer;\n    border: none;\n\n    ${mediaNotTouch} {\n        &:hover {\n            ${CopyIconButton.class} {\n                transform: scale(1.04);\n            }\n        }\n    }\n\n    &:active {\n        ${CopyIconButton.class} {\n            transform: scale(0.96);\n        }\n    }\n\n    ${mediaTouch} {\n        &:active {\n            ${CopyIconButton.class} {\n                transform: scale(0.92);\n            }\n        }\n    }\n`;\nconst QrCodeWrapper$2 = styled.div`\n    position: relative;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    margin: 0 auto;\n\n    > div:first-child {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n\n    rect {\n        fill: transparent;\n    }\n\n    path {\n        fill: ${(props) => props.theme.colors.constant.black};\n    }\n`;\nconst ImageBackground = styled.div`\n    position: absolute;\n    width: ${toPx(imgSizeDefault)};\n    height: ${toPx(imgSizeDefault)};\n    background: ${(props) => props.theme.colors.background.qr};\n\n    display: flex;\n    align-items: center;\n    justify-content: center;\n`;\nconst ImageStyled$3 = styled(Image)`\n    width: ${(props) => toPx(props.size)};\n    height: ${(props) => toPx(props.size)};\n    border-radius: ${(props) => imageBorders[props.theme.borderRadius]};\n    background-color: ${(props) => props.theme.colors.background.qr};\n`;\nconst CopiedBoxStyled = styled.div`\n    position: absolute;\n    bottom: 14px;\n    left: 50%;\n    transform: translate(-50%, 0);\n\n    display: flex;\n    gap: 6px;\n    align-items: center;\n    border-radius: 18px;\n    min-width: 126px;\n    padding: 9px 16px 9px 10px;\n\n    filter: drop-shadow(0px 2px 8px rgba(0, 0, 0, 0.08));\n    background-color: ${(props) => props.theme.colors.background.segment};\n`;\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar qrcode$1 = { exports: {} };\nvar hasRequiredQrcode;\nfunction requireQrcode() {\n  if (hasRequiredQrcode) return qrcode$1.exports;\n  hasRequiredQrcode = 1;\n  (function(module, exports) {\n    var qrcode2 = function() {\n      var qrcode3 = function(typeNumber, errorCorrectionLevel) {\n        var PAD0 = 236;\n        var PAD1 = 17;\n        var _typeNumber = typeNumber;\n        var _errorCorrectionLevel = QRErrorCorrectionLevel[errorCorrectionLevel];\n        var _modules = null;\n        var _moduleCount = 0;\n        var _dataCache = null;\n        var _dataList = [];\n        var _this = {};\n        var makeImpl = function(test, maskPattern) {\n          _moduleCount = _typeNumber * 4 + 17;\n          _modules = function(moduleCount) {\n            var modules = new Array(moduleCount);\n            for (var row = 0; row < moduleCount; row += 1) {\n              modules[row] = new Array(moduleCount);\n              for (var col = 0; col < moduleCount; col += 1) {\n                modules[row][col] = null;\n              }\n            }\n            return modules;\n          }(_moduleCount);\n          setupPositionProbePattern(0, 0);\n          setupPositionProbePattern(_moduleCount - 7, 0);\n          setupPositionProbePattern(0, _moduleCount - 7);\n          setupPositionAdjustPattern();\n          setupTimingPattern();\n          setupTypeInfo(test, maskPattern);\n          if (_typeNumber >= 7) {\n            setupTypeNumber(test);\n          }\n          if (_dataCache == null) {\n            _dataCache = createData(_typeNumber, _errorCorrectionLevel, _dataList);\n          }\n          mapData(_dataCache, maskPattern);\n        };\n        var setupPositionProbePattern = function(row, col) {\n          for (var r = -1; r <= 7; r += 1) {\n            if (row + r <= -1 || _moduleCount <= row + r) continue;\n            for (var c2 = -1; c2 <= 7; c2 += 1) {\n              if (col + c2 <= -1 || _moduleCount <= col + c2) continue;\n              if (0 <= r && r <= 6 && (c2 == 0 || c2 == 6) || 0 <= c2 && c2 <= 6 && (r == 0 || r == 6) || 2 <= r && r <= 4 && 2 <= c2 && c2 <= 4) {\n                _modules[row + r][col + c2] = true;\n              } else {\n                _modules[row + r][col + c2] = false;\n              }\n            }\n          }\n        };\n        var getBestMaskPattern = function() {\n          var minLostPoint = 0;\n          var pattern = 0;\n          for (var i2 = 0; i2 < 8; i2 += 1) {\n            makeImpl(true, i2);\n            var lostPoint = QRUtil.getLostPoint(_this);\n            if (i2 == 0 || minLostPoint > lostPoint) {\n              minLostPoint = lostPoint;\n              pattern = i2;\n            }\n          }\n          return pattern;\n        };\n        var setupTimingPattern = function() {\n          for (var r = 8; r < _moduleCount - 8; r += 1) {\n            if (_modules[r][6] != null) {\n              continue;\n            }\n            _modules[r][6] = r % 2 == 0;\n          }\n          for (var c2 = 8; c2 < _moduleCount - 8; c2 += 1) {\n            if (_modules[6][c2] != null) {\n              continue;\n            }\n            _modules[6][c2] = c2 % 2 == 0;\n          }\n        };\n        var setupPositionAdjustPattern = function() {\n          var pos = QRUtil.getPatternPosition(_typeNumber);\n          for (var i2 = 0; i2 < pos.length; i2 += 1) {\n            for (var j = 0; j < pos.length; j += 1) {\n              var row = pos[i2];\n              var col = pos[j];\n              if (_modules[row][col] != null) {\n                continue;\n              }\n              for (var r = -2; r <= 2; r += 1) {\n                for (var c2 = -2; c2 <= 2; c2 += 1) {\n                  if (r == -2 || r == 2 || c2 == -2 || c2 == 2 || r == 0 && c2 == 0) {\n                    _modules[row + r][col + c2] = true;\n                  } else {\n                    _modules[row + r][col + c2] = false;\n                  }\n                }\n              }\n            }\n          }\n        };\n        var setupTypeNumber = function(test) {\n          var bits = QRUtil.getBCHTypeNumber(_typeNumber);\n          for (var i2 = 0; i2 < 18; i2 += 1) {\n            var mod = !test && (bits >> i2 & 1) == 1;\n            _modules[Math.floor(i2 / 3)][i2 % 3 + _moduleCount - 8 - 3] = mod;\n          }\n          for (var i2 = 0; i2 < 18; i2 += 1) {\n            var mod = !test && (bits >> i2 & 1) == 1;\n            _modules[i2 % 3 + _moduleCount - 8 - 3][Math.floor(i2 / 3)] = mod;\n          }\n        };\n        var setupTypeInfo = function(test, maskPattern) {\n          var data = _errorCorrectionLevel << 3 | maskPattern;\n          var bits = QRUtil.getBCHTypeInfo(data);\n          for (var i2 = 0; i2 < 15; i2 += 1) {\n            var mod = !test && (bits >> i2 & 1) == 1;\n            if (i2 < 6) {\n              _modules[i2][8] = mod;\n            } else if (i2 < 8) {\n              _modules[i2 + 1][8] = mod;\n            } else {\n              _modules[_moduleCount - 15 + i2][8] = mod;\n            }\n          }\n          for (var i2 = 0; i2 < 15; i2 += 1) {\n            var mod = !test && (bits >> i2 & 1) == 1;\n            if (i2 < 8) {\n              _modules[8][_moduleCount - i2 - 1] = mod;\n            } else if (i2 < 9) {\n              _modules[8][15 - i2 - 1 + 1] = mod;\n            } else {\n              _modules[8][15 - i2 - 1] = mod;\n            }\n          }\n          _modules[_moduleCount - 8][8] = !test;\n        };\n        var mapData = function(data, maskPattern) {\n          var inc = -1;\n          var row = _moduleCount - 1;\n          var bitIndex = 7;\n          var byteIndex = 0;\n          var maskFunc = QRUtil.getMaskFunction(maskPattern);\n          for (var col = _moduleCount - 1; col > 0; col -= 2) {\n            if (col == 6) col -= 1;\n            while (true) {\n              for (var c2 = 0; c2 < 2; c2 += 1) {\n                if (_modules[row][col - c2] == null) {\n                  var dark = false;\n                  if (byteIndex < data.length) {\n                    dark = (data[byteIndex] >>> bitIndex & 1) == 1;\n                  }\n                  var mask = maskFunc(row, col - c2);\n                  if (mask) {\n                    dark = !dark;\n                  }\n                  _modules[row][col - c2] = dark;\n                  bitIndex -= 1;\n                  if (bitIndex == -1) {\n                    byteIndex += 1;\n                    bitIndex = 7;\n                  }\n                }\n              }\n              row += inc;\n              if (row < 0 || _moduleCount <= row) {\n                row -= inc;\n                inc = -inc;\n                break;\n              }\n            }\n          }\n        };\n        var createBytes = function(buffer, rsBlocks) {\n          var offset = 0;\n          var maxDcCount = 0;\n          var maxEcCount = 0;\n          var dcdata = new Array(rsBlocks.length);\n          var ecdata = new Array(rsBlocks.length);\n          for (var r = 0; r < rsBlocks.length; r += 1) {\n            var dcCount = rsBlocks[r].dataCount;\n            var ecCount = rsBlocks[r].totalCount - dcCount;\n            maxDcCount = Math.max(maxDcCount, dcCount);\n            maxEcCount = Math.max(maxEcCount, ecCount);\n            dcdata[r] = new Array(dcCount);\n            for (var i2 = 0; i2 < dcdata[r].length; i2 += 1) {\n              dcdata[r][i2] = 255 & buffer.getBuffer()[i2 + offset];\n            }\n            offset += dcCount;\n            var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);\n            var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);\n            var modPoly = rawPoly.mod(rsPoly);\n            ecdata[r] = new Array(rsPoly.getLength() - 1);\n            for (var i2 = 0; i2 < ecdata[r].length; i2 += 1) {\n              var modIndex = i2 + modPoly.getLength() - ecdata[r].length;\n              ecdata[r][i2] = modIndex >= 0 ? modPoly.getAt(modIndex) : 0;\n            }\n          }\n          var totalCodeCount = 0;\n          for (var i2 = 0; i2 < rsBlocks.length; i2 += 1) {\n            totalCodeCount += rsBlocks[i2].totalCount;\n          }\n          var data = new Array(totalCodeCount);\n          var index = 0;\n          for (var i2 = 0; i2 < maxDcCount; i2 += 1) {\n            for (var r = 0; r < rsBlocks.length; r += 1) {\n              if (i2 < dcdata[r].length) {\n                data[index] = dcdata[r][i2];\n                index += 1;\n              }\n            }\n          }\n          for (var i2 = 0; i2 < maxEcCount; i2 += 1) {\n            for (var r = 0; r < rsBlocks.length; r += 1) {\n              if (i2 < ecdata[r].length) {\n                data[index] = ecdata[r][i2];\n                index += 1;\n              }\n            }\n          }\n          return data;\n        };\n        var createData = function(typeNumber2, errorCorrectionLevel2, dataList) {\n          var rsBlocks = QRRSBlock.getRSBlocks(typeNumber2, errorCorrectionLevel2);\n          var buffer = qrBitBuffer();\n          for (var i2 = 0; i2 < dataList.length; i2 += 1) {\n            var data = dataList[i2];\n            buffer.put(data.getMode(), 4);\n            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber2));\n            data.write(buffer);\n          }\n          var totalDataCount = 0;\n          for (var i2 = 0; i2 < rsBlocks.length; i2 += 1) {\n            totalDataCount += rsBlocks[i2].dataCount;\n          }\n          if (buffer.getLengthInBits() > totalDataCount * 8) {\n            throw \"code length overflow. (\" + buffer.getLengthInBits() + \">\" + totalDataCount * 8 + \")\";\n          }\n          if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {\n            buffer.put(0, 4);\n          }\n          while (buffer.getLengthInBits() % 8 != 0) {\n            buffer.putBit(false);\n          }\n          while (true) {\n            if (buffer.getLengthInBits() >= totalDataCount * 8) {\n              break;\n            }\n            buffer.put(PAD0, 8);\n            if (buffer.getLengthInBits() >= totalDataCount * 8) {\n              break;\n            }\n            buffer.put(PAD1, 8);\n          }\n          return createBytes(buffer, rsBlocks);\n        };\n        _this.addData = function(data, mode) {\n          mode = mode || \"Byte\";\n          var newData = null;\n          switch (mode) {\n            case \"Numeric\":\n              newData = qrNumber(data);\n              break;\n            case \"Alphanumeric\":\n              newData = qrAlphaNum(data);\n              break;\n            case \"Byte\":\n              newData = qr8BitByte(data);\n              break;\n            case \"Kanji\":\n              newData = qrKanji(data);\n              break;\n            default:\n              throw \"mode:\" + mode;\n          }\n          _dataList.push(newData);\n          _dataCache = null;\n        };\n        _this.isDark = function(row, col) {\n          if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {\n            throw row + \",\" + col;\n          }\n          return _modules[row][col];\n        };\n        _this.getModuleCount = function() {\n          return _moduleCount;\n        };\n        _this.make = function() {\n          if (_typeNumber < 1) {\n            var typeNumber2 = 1;\n            for (; typeNumber2 < 40; typeNumber2++) {\n              var rsBlocks = QRRSBlock.getRSBlocks(typeNumber2, _errorCorrectionLevel);\n              var buffer = qrBitBuffer();\n              for (var i2 = 0; i2 < _dataList.length; i2++) {\n                var data = _dataList[i2];\n                buffer.put(data.getMode(), 4);\n                buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber2));\n                data.write(buffer);\n              }\n              var totalDataCount = 0;\n              for (var i2 = 0; i2 < rsBlocks.length; i2++) {\n                totalDataCount += rsBlocks[i2].dataCount;\n              }\n              if (buffer.getLengthInBits() <= totalDataCount * 8) {\n                break;\n              }\n            }\n            _typeNumber = typeNumber2;\n          }\n          makeImpl(false, getBestMaskPattern());\n        };\n        _this.createTableTag = function(cellSize, margin) {\n          cellSize = cellSize || 2;\n          margin = typeof margin == \"undefined\" ? cellSize * 4 : margin;\n          var qrHtml = \"\";\n          qrHtml += '<table style=\"';\n          qrHtml += \" border-width: 0px; border-style: none;\";\n          qrHtml += \" border-collapse: collapse;\";\n          qrHtml += \" padding: 0px; margin: \" + margin + \"px;\";\n          qrHtml += '\">';\n          qrHtml += \"<tbody>\";\n          for (var r = 0; r < _this.getModuleCount(); r += 1) {\n            qrHtml += \"<tr>\";\n            for (var c2 = 0; c2 < _this.getModuleCount(); c2 += 1) {\n              qrHtml += '<td style=\"';\n              qrHtml += \" border-width: 0px; border-style: none;\";\n              qrHtml += \" border-collapse: collapse;\";\n              qrHtml += \" padding: 0px; margin: 0px;\";\n              qrHtml += \" width: \" + cellSize + \"px;\";\n              qrHtml += \" height: \" + cellSize + \"px;\";\n              qrHtml += \" background-color: \";\n              qrHtml += _this.isDark(r, c2) ? \"#000000\" : \"#ffffff\";\n              qrHtml += \";\";\n              qrHtml += '\"/>';\n            }\n            qrHtml += \"</tr>\";\n          }\n          qrHtml += \"</tbody>\";\n          qrHtml += \"</table>\";\n          return qrHtml;\n        };\n        _this.createSvgTag = function(cellSize, margin, alt, title) {\n          var opts = {};\n          if (typeof arguments[0] == \"object\") {\n            opts = arguments[0];\n            cellSize = opts.cellSize;\n            margin = opts.margin;\n            alt = opts.alt;\n            title = opts.title;\n          }\n          cellSize = cellSize || 2;\n          margin = typeof margin == \"undefined\" ? cellSize * 4 : margin;\n          alt = typeof alt === \"string\" ? { text: alt } : alt || {};\n          alt.text = alt.text || null;\n          alt.id = alt.text ? alt.id || \"qrcode-description\" : null;\n          title = typeof title === \"string\" ? { text: title } : title || {};\n          title.text = title.text || null;\n          title.id = title.text ? title.id || \"qrcode-title\" : null;\n          var size = _this.getModuleCount() * cellSize + margin * 2;\n          var c2, mc, r, mr, qrSvg = \"\", rect;\n          rect = \"l\" + cellSize + \",0 0,\" + cellSize + \" -\" + cellSize + \",0 0,-\" + cellSize + \"z \";\n          qrSvg += '<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"';\n          qrSvg += !opts.scalable ? ' width=\"' + size + 'px\" height=\"' + size + 'px\"' : \"\";\n          qrSvg += ' viewBox=\"0 0 ' + size + \" \" + size + '\" ';\n          qrSvg += ' preserveAspectRatio=\"xMinYMin meet\"';\n          qrSvg += title.text || alt.text ? ' role=\"img\" aria-labelledby=\"' + escapeXml([title.id, alt.id].join(\" \").trim()) + '\"' : \"\";\n          qrSvg += \">\";\n          qrSvg += title.text ? '<title id=\"' + escapeXml(title.id) + '\">' + escapeXml(title.text) + \"</title>\" : \"\";\n          qrSvg += alt.text ? '<description id=\"' + escapeXml(alt.id) + '\">' + escapeXml(alt.text) + \"</description>\" : \"\";\n          qrSvg += '<rect width=\"100%\" height=\"100%\" fill=\"white\" cx=\"0\" cy=\"0\"/>';\n          qrSvg += '<path d=\"';\n          for (r = 0; r < _this.getModuleCount(); r += 1) {\n            mr = r * cellSize + margin;\n            for (c2 = 0; c2 < _this.getModuleCount(); c2 += 1) {\n              if (_this.isDark(r, c2)) {\n                mc = c2 * cellSize + margin;\n                qrSvg += \"M\" + mc + \",\" + mr + rect;\n              }\n            }\n          }\n          qrSvg += '\" stroke=\"transparent\" fill=\"black\"/>';\n          qrSvg += \"</svg>\";\n          return qrSvg;\n        };\n        _this.createDataURL = function(cellSize, margin) {\n          cellSize = cellSize || 2;\n          margin = typeof margin == \"undefined\" ? cellSize * 4 : margin;\n          var size = _this.getModuleCount() * cellSize + margin * 2;\n          var min2 = margin;\n          var max2 = size - margin;\n          return createDataURL(size, size, function(x, y) {\n            if (min2 <= x && x < max2 && min2 <= y && y < max2) {\n              var c2 = Math.floor((x - min2) / cellSize);\n              var r = Math.floor((y - min2) / cellSize);\n              return _this.isDark(r, c2) ? 0 : 1;\n            } else {\n              return 1;\n            }\n          });\n        };\n        _this.createImgTag = function(cellSize, margin, alt) {\n          cellSize = cellSize || 2;\n          margin = typeof margin == \"undefined\" ? cellSize * 4 : margin;\n          var size = _this.getModuleCount() * cellSize + margin * 2;\n          var img = \"\";\n          img += \"<img\";\n          img += ' src=\"';\n          img += _this.createDataURL(cellSize, margin);\n          img += '\"';\n          img += ' width=\"';\n          img += size;\n          img += '\"';\n          img += ' height=\"';\n          img += size;\n          img += '\"';\n          if (alt) {\n            img += ' alt=\"';\n            img += escapeXml(alt);\n            img += '\"';\n          }\n          img += \"/>\";\n          return img;\n        };\n        var escapeXml = function(s2) {\n          var escaped = \"\";\n          for (var i2 = 0; i2 < s2.length; i2 += 1) {\n            var c2 = s2.charAt(i2);\n            switch (c2) {\n              case \"<\":\n                escaped += \"&lt;\";\n                break;\n              case \">\":\n                escaped += \"&gt;\";\n                break;\n              case \"&\":\n                escaped += \"&amp;\";\n                break;\n              case '\"':\n                escaped += \"&quot;\";\n                break;\n              default:\n                escaped += c2;\n                break;\n            }\n          }\n          return escaped;\n        };\n        var _createHalfASCII = function(margin) {\n          var cellSize = 1;\n          margin = typeof margin == \"undefined\" ? cellSize * 2 : margin;\n          var size = _this.getModuleCount() * cellSize + margin * 2;\n          var min2 = margin;\n          var max2 = size - margin;\n          var y, x, r1, r2, p2;\n          var blocks = {\n            \"\": \"\",\n            \" \": \"\",\n            \" \": \"\",\n            \"  \": \" \"\n          };\n          var blocksLastLineNoMargin = {\n            \"\": \"\",\n            \" \": \"\",\n            \" \": \" \",\n            \"  \": \" \"\n          };\n          var ascii = \"\";\n          for (y = 0; y < size; y += 2) {\n            r1 = Math.floor((y - min2) / cellSize);\n            r2 = Math.floor((y + 1 - min2) / cellSize);\n            for (x = 0; x < size; x += 1) {\n              p2 = \"\";\n              if (min2 <= x && x < max2 && min2 <= y && y < max2 && _this.isDark(r1, Math.floor((x - min2) / cellSize))) {\n                p2 = \" \";\n              }\n              if (min2 <= x && x < max2 && min2 <= y + 1 && y + 1 < max2 && _this.isDark(r2, Math.floor((x - min2) / cellSize))) {\n                p2 += \" \";\n              } else {\n                p2 += \"\";\n              }\n              ascii += margin < 1 && y + 1 >= max2 ? blocksLastLineNoMargin[p2] : blocks[p2];\n            }\n            ascii += \"\\n\";\n          }\n          if (size % 2 && margin > 0) {\n            return ascii.substring(0, ascii.length - size - 1) + Array(size + 1).join(\"\");\n          }\n          return ascii.substring(0, ascii.length - 1);\n        };\n        _this.createASCII = function(cellSize, margin) {\n          cellSize = cellSize || 1;\n          if (cellSize < 2) {\n            return _createHalfASCII(margin);\n          }\n          cellSize -= 1;\n          margin = typeof margin == \"undefined\" ? cellSize * 2 : margin;\n          var size = _this.getModuleCount() * cellSize + margin * 2;\n          var min2 = margin;\n          var max2 = size - margin;\n          var y, x, r, p2;\n          var white = Array(cellSize + 1).join(\"\");\n          var black = Array(cellSize + 1).join(\"  \");\n          var ascii = \"\";\n          var line = \"\";\n          for (y = 0; y < size; y += 1) {\n            r = Math.floor((y - min2) / cellSize);\n            line = \"\";\n            for (x = 0; x < size; x += 1) {\n              p2 = 1;\n              if (min2 <= x && x < max2 && min2 <= y && y < max2 && _this.isDark(r, Math.floor((x - min2) / cellSize))) {\n                p2 = 0;\n              }\n              line += p2 ? white : black;\n            }\n            for (r = 0; r < cellSize; r += 1) {\n              ascii += line + \"\\n\";\n            }\n          }\n          return ascii.substring(0, ascii.length - 1);\n        };\n        _this.renderTo2dContext = function(context, cellSize) {\n          cellSize = cellSize || 2;\n          var length = _this.getModuleCount();\n          for (var row = 0; row < length; row++) {\n            for (var col = 0; col < length; col++) {\n              context.fillStyle = _this.isDark(row, col) ? \"black\" : \"white\";\n              context.fillRect(row * cellSize, col * cellSize, cellSize, cellSize);\n            }\n          }\n        };\n        return _this;\n      };\n      qrcode3.stringToBytesFuncs = {\n        \"default\": function(s2) {\n          var bytes = [];\n          for (var i2 = 0; i2 < s2.length; i2 += 1) {\n            var c2 = s2.charCodeAt(i2);\n            bytes.push(c2 & 255);\n          }\n          return bytes;\n        }\n      };\n      qrcode3.stringToBytes = qrcode3.stringToBytesFuncs[\"default\"];\n      qrcode3.createStringToBytes = function(unicodeData, numChars) {\n        var unicodeMap = function() {\n          var bin = base64DecodeInputStream(unicodeData);\n          var read = function() {\n            var b = bin.read();\n            if (b == -1) throw \"eof\";\n            return b;\n          };\n          var count = 0;\n          var unicodeMap2 = {};\n          while (true) {\n            var b0 = bin.read();\n            if (b0 == -1) break;\n            var b1 = read();\n            var b2 = read();\n            var b3 = read();\n            var k = String.fromCharCode(b0 << 8 | b1);\n            var v = b2 << 8 | b3;\n            unicodeMap2[k] = v;\n            count += 1;\n          }\n          if (count != numChars) {\n            throw count + \" != \" + numChars;\n          }\n          return unicodeMap2;\n        }();\n        var unknownChar = \"?\".charCodeAt(0);\n        return function(s2) {\n          var bytes = [];\n          for (var i2 = 0; i2 < s2.length; i2 += 1) {\n            var c2 = s2.charCodeAt(i2);\n            if (c2 < 128) {\n              bytes.push(c2);\n            } else {\n              var b = unicodeMap[s2.charAt(i2)];\n              if (typeof b == \"number\") {\n                if ((b & 255) == b) {\n                  bytes.push(b);\n                } else {\n                  bytes.push(b >>> 8);\n                  bytes.push(b & 255);\n                }\n              } else {\n                bytes.push(unknownChar);\n              }\n            }\n          }\n          return bytes;\n        };\n      };\n      var QRMode = {\n        MODE_NUMBER: 1 << 0,\n        MODE_ALPHA_NUM: 1 << 1,\n        MODE_8BIT_BYTE: 1 << 2,\n        MODE_KANJI: 1 << 3\n      };\n      var QRErrorCorrectionLevel = {\n        L: 1,\n        M: 0,\n        Q: 3,\n        H: 2\n      };\n      var QRMaskPattern = {\n        PATTERN000: 0,\n        PATTERN001: 1,\n        PATTERN010: 2,\n        PATTERN011: 3,\n        PATTERN100: 4,\n        PATTERN101: 5,\n        PATTERN110: 6,\n        PATTERN111: 7\n      };\n      var QRUtil = function() {\n        var PATTERN_POSITION_TABLE = [\n          [],\n          [6, 18],\n          [6, 22],\n          [6, 26],\n          [6, 30],\n          [6, 34],\n          [6, 22, 38],\n          [6, 24, 42],\n          [6, 26, 46],\n          [6, 28, 50],\n          [6, 30, 54],\n          [6, 32, 58],\n          [6, 34, 62],\n          [6, 26, 46, 66],\n          [6, 26, 48, 70],\n          [6, 26, 50, 74],\n          [6, 30, 54, 78],\n          [6, 30, 56, 82],\n          [6, 30, 58, 86],\n          [6, 34, 62, 90],\n          [6, 28, 50, 72, 94],\n          [6, 26, 50, 74, 98],\n          [6, 30, 54, 78, 102],\n          [6, 28, 54, 80, 106],\n          [6, 32, 58, 84, 110],\n          [6, 30, 58, 86, 114],\n          [6, 34, 62, 90, 118],\n          [6, 26, 50, 74, 98, 122],\n          [6, 30, 54, 78, 102, 126],\n          [6, 26, 52, 78, 104, 130],\n          [6, 30, 56, 82, 108, 134],\n          [6, 34, 60, 86, 112, 138],\n          [6, 30, 58, 86, 114, 142],\n          [6, 34, 62, 90, 118, 146],\n          [6, 30, 54, 78, 102, 126, 150],\n          [6, 24, 50, 76, 102, 128, 154],\n          [6, 28, 54, 80, 106, 132, 158],\n          [6, 32, 58, 84, 110, 136, 162],\n          [6, 26, 54, 82, 110, 138, 166],\n          [6, 30, 58, 86, 114, 142, 170]\n        ];\n        var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;\n        var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;\n        var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;\n        var _this = {};\n        var getBCHDigit = function(data) {\n          var digit = 0;\n          while (data != 0) {\n            digit += 1;\n            data >>>= 1;\n          }\n          return digit;\n        };\n        _this.getBCHTypeInfo = function(data) {\n          var d = data << 10;\n          while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {\n            d ^= G15 << getBCHDigit(d) - getBCHDigit(G15);\n          }\n          return (data << 10 | d) ^ G15_MASK;\n        };\n        _this.getBCHTypeNumber = function(data) {\n          var d = data << 12;\n          while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {\n            d ^= G18 << getBCHDigit(d) - getBCHDigit(G18);\n          }\n          return data << 12 | d;\n        };\n        _this.getPatternPosition = function(typeNumber) {\n          return PATTERN_POSITION_TABLE[typeNumber - 1];\n        };\n        _this.getMaskFunction = function(maskPattern) {\n          switch (maskPattern) {\n            case QRMaskPattern.PATTERN000:\n              return function(i2, j) {\n                return (i2 + j) % 2 == 0;\n              };\n            case QRMaskPattern.PATTERN001:\n              return function(i2, j) {\n                return i2 % 2 == 0;\n              };\n            case QRMaskPattern.PATTERN010:\n              return function(i2, j) {\n                return j % 3 == 0;\n              };\n            case QRMaskPattern.PATTERN011:\n              return function(i2, j) {\n                return (i2 + j) % 3 == 0;\n              };\n            case QRMaskPattern.PATTERN100:\n              return function(i2, j) {\n                return (Math.floor(i2 / 2) + Math.floor(j / 3)) % 2 == 0;\n              };\n            case QRMaskPattern.PATTERN101:\n              return function(i2, j) {\n                return i2 * j % 2 + i2 * j % 3 == 0;\n              };\n            case QRMaskPattern.PATTERN110:\n              return function(i2, j) {\n                return (i2 * j % 2 + i2 * j % 3) % 2 == 0;\n              };\n            case QRMaskPattern.PATTERN111:\n              return function(i2, j) {\n                return (i2 * j % 3 + (i2 + j) % 2) % 2 == 0;\n              };\n            default:\n              throw \"bad maskPattern:\" + maskPattern;\n          }\n        };\n        _this.getErrorCorrectPolynomial = function(errorCorrectLength) {\n          var a2 = qrPolynomial([1], 0);\n          for (var i2 = 0; i2 < errorCorrectLength; i2 += 1) {\n            a2 = a2.multiply(qrPolynomial([1, QRMath.gexp(i2)], 0));\n          }\n          return a2;\n        };\n        _this.getLengthInBits = function(mode, type) {\n          if (1 <= type && type < 10) {\n            switch (mode) {\n              case QRMode.MODE_NUMBER:\n                return 10;\n              case QRMode.MODE_ALPHA_NUM:\n                return 9;\n              case QRMode.MODE_8BIT_BYTE:\n                return 8;\n              case QRMode.MODE_KANJI:\n                return 8;\n              default:\n                throw \"mode:\" + mode;\n            }\n          } else if (type < 27) {\n            switch (mode) {\n              case QRMode.MODE_NUMBER:\n                return 12;\n              case QRMode.MODE_ALPHA_NUM:\n                return 11;\n              case QRMode.MODE_8BIT_BYTE:\n                return 16;\n              case QRMode.MODE_KANJI:\n                return 10;\n              default:\n                throw \"mode:\" + mode;\n            }\n          } else if (type < 41) {\n            switch (mode) {\n              case QRMode.MODE_NUMBER:\n                return 14;\n              case QRMode.MODE_ALPHA_NUM:\n                return 13;\n              case QRMode.MODE_8BIT_BYTE:\n                return 16;\n              case QRMode.MODE_KANJI:\n                return 12;\n              default:\n                throw \"mode:\" + mode;\n            }\n          } else {\n            throw \"type:\" + type;\n          }\n        };\n        _this.getLostPoint = function(qrcode4) {\n          var moduleCount = qrcode4.getModuleCount();\n          var lostPoint = 0;\n          for (var row = 0; row < moduleCount; row += 1) {\n            for (var col = 0; col < moduleCount; col += 1) {\n              var sameCount = 0;\n              var dark = qrcode4.isDark(row, col);\n              for (var r = -1; r <= 1; r += 1) {\n                if (row + r < 0 || moduleCount <= row + r) {\n                  continue;\n                }\n                for (var c2 = -1; c2 <= 1; c2 += 1) {\n                  if (col + c2 < 0 || moduleCount <= col + c2) {\n                    continue;\n                  }\n                  if (r == 0 && c2 == 0) {\n                    continue;\n                  }\n                  if (dark == qrcode4.isDark(row + r, col + c2)) {\n                    sameCount += 1;\n                  }\n                }\n              }\n              if (sameCount > 5) {\n                lostPoint += 3 + sameCount - 5;\n              }\n            }\n          }\n          for (var row = 0; row < moduleCount - 1; row += 1) {\n            for (var col = 0; col < moduleCount - 1; col += 1) {\n              var count = 0;\n              if (qrcode4.isDark(row, col)) count += 1;\n              if (qrcode4.isDark(row + 1, col)) count += 1;\n              if (qrcode4.isDark(row, col + 1)) count += 1;\n              if (qrcode4.isDark(row + 1, col + 1)) count += 1;\n              if (count == 0 || count == 4) {\n                lostPoint += 3;\n              }\n            }\n          }\n          for (var row = 0; row < moduleCount; row += 1) {\n            for (var col = 0; col < moduleCount - 6; col += 1) {\n              if (qrcode4.isDark(row, col) && !qrcode4.isDark(row, col + 1) && qrcode4.isDark(row, col + 2) && qrcode4.isDark(row, col + 3) && qrcode4.isDark(row, col + 4) && !qrcode4.isDark(row, col + 5) && qrcode4.isDark(row, col + 6)) {\n                lostPoint += 40;\n              }\n            }\n          }\n          for (var col = 0; col < moduleCount; col += 1) {\n            for (var row = 0; row < moduleCount - 6; row += 1) {\n              if (qrcode4.isDark(row, col) && !qrcode4.isDark(row + 1, col) && qrcode4.isDark(row + 2, col) && qrcode4.isDark(row + 3, col) && qrcode4.isDark(row + 4, col) && !qrcode4.isDark(row + 5, col) && qrcode4.isDark(row + 6, col)) {\n                lostPoint += 40;\n              }\n            }\n          }\n          var darkCount = 0;\n          for (var col = 0; col < moduleCount; col += 1) {\n            for (var row = 0; row < moduleCount; row += 1) {\n              if (qrcode4.isDark(row, col)) {\n                darkCount += 1;\n              }\n            }\n          }\n          var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;\n          lostPoint += ratio * 10;\n          return lostPoint;\n        };\n        return _this;\n      }();\n      var QRMath = function() {\n        var EXP_TABLE = new Array(256);\n        var LOG_TABLE = new Array(256);\n        for (var i2 = 0; i2 < 8; i2 += 1) {\n          EXP_TABLE[i2] = 1 << i2;\n        }\n        for (var i2 = 8; i2 < 256; i2 += 1) {\n          EXP_TABLE[i2] = EXP_TABLE[i2 - 4] ^ EXP_TABLE[i2 - 5] ^ EXP_TABLE[i2 - 6] ^ EXP_TABLE[i2 - 8];\n        }\n        for (var i2 = 0; i2 < 255; i2 += 1) {\n          LOG_TABLE[EXP_TABLE[i2]] = i2;\n        }\n        var _this = {};\n        _this.glog = function(n2) {\n          if (n2 < 1) {\n            throw \"glog(\" + n2 + \")\";\n          }\n          return LOG_TABLE[n2];\n        };\n        _this.gexp = function(n2) {\n          while (n2 < 0) {\n            n2 += 255;\n          }\n          while (n2 >= 256) {\n            n2 -= 255;\n          }\n          return EXP_TABLE[n2];\n        };\n        return _this;\n      }();\n      function qrPolynomial(num, shift2) {\n        if (typeof num.length == \"undefined\") {\n          throw num.length + \"/\" + shift2;\n        }\n        var _num = function() {\n          var offset = 0;\n          while (offset < num.length && num[offset] == 0) {\n            offset += 1;\n          }\n          var _num2 = new Array(num.length - offset + shift2);\n          for (var i2 = 0; i2 < num.length - offset; i2 += 1) {\n            _num2[i2] = num[i2 + offset];\n          }\n          return _num2;\n        }();\n        var _this = {};\n        _this.getAt = function(index) {\n          return _num[index];\n        };\n        _this.getLength = function() {\n          return _num.length;\n        };\n        _this.multiply = function(e2) {\n          var num2 = new Array(_this.getLength() + e2.getLength() - 1);\n          for (var i2 = 0; i2 < _this.getLength(); i2 += 1) {\n            for (var j = 0; j < e2.getLength(); j += 1) {\n              num2[i2 + j] ^= QRMath.gexp(QRMath.glog(_this.getAt(i2)) + QRMath.glog(e2.getAt(j)));\n            }\n          }\n          return qrPolynomial(num2, 0);\n        };\n        _this.mod = function(e2) {\n          if (_this.getLength() - e2.getLength() < 0) {\n            return _this;\n          }\n          var ratio = QRMath.glog(_this.getAt(0)) - QRMath.glog(e2.getAt(0));\n          var num2 = new Array(_this.getLength());\n          for (var i2 = 0; i2 < _this.getLength(); i2 += 1) {\n            num2[i2] = _this.getAt(i2);\n          }\n          for (var i2 = 0; i2 < e2.getLength(); i2 += 1) {\n            num2[i2] ^= QRMath.gexp(QRMath.glog(e2.getAt(i2)) + ratio);\n          }\n          return qrPolynomial(num2, 0).mod(e2);\n        };\n        return _this;\n      }\n      var QRRSBlock = function() {\n        var RS_BLOCK_TABLE = [\n          // L\n          // M\n          // Q\n          // H\n          // 1\n          [1, 26, 19],\n          [1, 26, 16],\n          [1, 26, 13],\n          [1, 26, 9],\n          // 2\n          [1, 44, 34],\n          [1, 44, 28],\n          [1, 44, 22],\n          [1, 44, 16],\n          // 3\n          [1, 70, 55],\n          [1, 70, 44],\n          [2, 35, 17],\n          [2, 35, 13],\n          // 4\n          [1, 100, 80],\n          [2, 50, 32],\n          [2, 50, 24],\n          [4, 25, 9],\n          // 5\n          [1, 134, 108],\n          [2, 67, 43],\n          [2, 33, 15, 2, 34, 16],\n          [2, 33, 11, 2, 34, 12],\n          // 6\n          [2, 86, 68],\n          [4, 43, 27],\n          [4, 43, 19],\n          [4, 43, 15],\n          // 7\n          [2, 98, 78],\n          [4, 49, 31],\n          [2, 32, 14, 4, 33, 15],\n          [4, 39, 13, 1, 40, 14],\n          // 8\n          [2, 121, 97],\n          [2, 60, 38, 2, 61, 39],\n          [4, 40, 18, 2, 41, 19],\n          [4, 40, 14, 2, 41, 15],\n          // 9\n          [2, 146, 116],\n          [3, 58, 36, 2, 59, 37],\n          [4, 36, 16, 4, 37, 17],\n          [4, 36, 12, 4, 37, 13],\n          // 10\n          [2, 86, 68, 2, 87, 69],\n          [4, 69, 43, 1, 70, 44],\n          [6, 43, 19, 2, 44, 20],\n          [6, 43, 15, 2, 44, 16],\n          // 11\n          [4, 101, 81],\n          [1, 80, 50, 4, 81, 51],\n          [4, 50, 22, 4, 51, 23],\n          [3, 36, 12, 8, 37, 13],\n          // 12\n          [2, 116, 92, 2, 117, 93],\n          [6, 58, 36, 2, 59, 37],\n          [4, 46, 20, 6, 47, 21],\n          [7, 42, 14, 4, 43, 15],\n          // 13\n          [4, 133, 107],\n          [8, 59, 37, 1, 60, 38],\n          [8, 44, 20, 4, 45, 21],\n          [12, 33, 11, 4, 34, 12],\n          // 14\n          [3, 145, 115, 1, 146, 116],\n          [4, 64, 40, 5, 65, 41],\n          [11, 36, 16, 5, 37, 17],\n          [11, 36, 12, 5, 37, 13],\n          // 15\n          [5, 109, 87, 1, 110, 88],\n          [5, 65, 41, 5, 66, 42],\n          [5, 54, 24, 7, 55, 25],\n          [11, 36, 12, 7, 37, 13],\n          // 16\n          [5, 122, 98, 1, 123, 99],\n          [7, 73, 45, 3, 74, 46],\n          [15, 43, 19, 2, 44, 20],\n          [3, 45, 15, 13, 46, 16],\n          // 17\n          [1, 135, 107, 5, 136, 108],\n          [10, 74, 46, 1, 75, 47],\n          [1, 50, 22, 15, 51, 23],\n          [2, 42, 14, 17, 43, 15],\n          // 18\n          [5, 150, 120, 1, 151, 121],\n          [9, 69, 43, 4, 70, 44],\n          [17, 50, 22, 1, 51, 23],\n          [2, 42, 14, 19, 43, 15],\n          // 19\n          [3, 141, 113, 4, 142, 114],\n          [3, 70, 44, 11, 71, 45],\n          [17, 47, 21, 4, 48, 22],\n          [9, 39, 13, 16, 40, 14],\n          // 20\n          [3, 135, 107, 5, 136, 108],\n          [3, 67, 41, 13, 68, 42],\n          [15, 54, 24, 5, 55, 25],\n          [15, 43, 15, 10, 44, 16],\n          // 21\n          [4, 144, 116, 4, 145, 117],\n          [17, 68, 42],\n          [17, 50, 22, 6, 51, 23],\n          [19, 46, 16, 6, 47, 17],\n          // 22\n          [2, 139, 111, 7, 140, 112],\n          [17, 74, 46],\n          [7, 54, 24, 16, 55, 25],\n          [34, 37, 13],\n          // 23\n          [4, 151, 121, 5, 152, 122],\n          [4, 75, 47, 14, 76, 48],\n          [11, 54, 24, 14, 55, 25],\n          [16, 45, 15, 14, 46, 16],\n          // 24\n          [6, 147, 117, 4, 148, 118],\n          [6, 73, 45, 14, 74, 46],\n          [11, 54, 24, 16, 55, 25],\n          [30, 46, 16, 2, 47, 17],\n          // 25\n          [8, 132, 106, 4, 133, 107],\n          [8, 75, 47, 13, 76, 48],\n          [7, 54, 24, 22, 55, 25],\n          [22, 45, 15, 13, 46, 16],\n          // 26\n          [10, 142, 114, 2, 143, 115],\n          [19, 74, 46, 4, 75, 47],\n          [28, 50, 22, 6, 51, 23],\n          [33, 46, 16, 4, 47, 17],\n          // 27\n          [8, 152, 122, 4, 153, 123],\n          [22, 73, 45, 3, 74, 46],\n          [8, 53, 23, 26, 54, 24],\n          [12, 45, 15, 28, 46, 16],\n          // 28\n          [3, 147, 117, 10, 148, 118],\n          [3, 73, 45, 23, 74, 46],\n          [4, 54, 24, 31, 55, 25],\n          [11, 45, 15, 31, 46, 16],\n          // 29\n          [7, 146, 116, 7, 147, 117],\n          [21, 73, 45, 7, 74, 46],\n          [1, 53, 23, 37, 54, 24],\n          [19, 45, 15, 26, 46, 16],\n          // 30\n          [5, 145, 115, 10, 146, 116],\n          [19, 75, 47, 10, 76, 48],\n          [15, 54, 24, 25, 55, 25],\n          [23, 45, 15, 25, 46, 16],\n          // 31\n          [13, 145, 115, 3, 146, 116],\n          [2, 74, 46, 29, 75, 47],\n          [42, 54, 24, 1, 55, 25],\n          [23, 45, 15, 28, 46, 16],\n          // 32\n          [17, 145, 115],\n          [10, 74, 46, 23, 75, 47],\n          [10, 54, 24, 35, 55, 25],\n          [19, 45, 15, 35, 46, 16],\n          // 33\n          [17, 145, 115, 1, 146, 116],\n          [14, 74, 46, 21, 75, 47],\n          [29, 54, 24, 19, 55, 25],\n          [11, 45, 15, 46, 46, 16],\n          // 34\n          [13, 145, 115, 6, 146, 116],\n          [14, 74, 46, 23, 75, 47],\n          [44, 54, 24, 7, 55, 25],\n          [59, 46, 16, 1, 47, 17],\n          // 35\n          [12, 151, 121, 7, 152, 122],\n          [12, 75, 47, 26, 76, 48],\n          [39, 54, 24, 14, 55, 25],\n          [22, 45, 15, 41, 46, 16],\n          // 36\n          [6, 151, 121, 14, 152, 122],\n          [6, 75, 47, 34, 76, 48],\n          [46, 54, 24, 10, 55, 25],\n          [2, 45, 15, 64, 46, 16],\n          // 37\n          [17, 152, 122, 4, 153, 123],\n          [29, 74, 46, 14, 75, 47],\n          [49, 54, 24, 10, 55, 25],\n          [24, 45, 15, 46, 46, 16],\n          // 38\n          [4, 152, 122, 18, 153, 123],\n          [13, 74, 46, 32, 75, 47],\n          [48, 54, 24, 14, 55, 25],\n          [42, 45, 15, 32, 46, 16],\n          // 39\n          [20, 147, 117, 4, 148, 118],\n          [40, 75, 47, 7, 76, 48],\n          [43, 54, 24, 22, 55, 25],\n          [10, 45, 15, 67, 46, 16],\n          // 40\n          [19, 148, 118, 6, 149, 119],\n          [18, 75, 47, 31, 76, 48],\n          [34, 54, 24, 34, 55, 25],\n          [20, 45, 15, 61, 46, 16]\n        ];\n        var qrRSBlock = function(totalCount, dataCount) {\n          var _this2 = {};\n          _this2.totalCount = totalCount;\n          _this2.dataCount = dataCount;\n          return _this2;\n        };\n        var _this = {};\n        var getRsBlockTable = function(typeNumber, errorCorrectionLevel) {\n          switch (errorCorrectionLevel) {\n            case QRErrorCorrectionLevel.L:\n              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];\n            case QRErrorCorrectionLevel.M:\n              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];\n            case QRErrorCorrectionLevel.Q:\n              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];\n            case QRErrorCorrectionLevel.H:\n              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];\n            default:\n              return void 0;\n          }\n        };\n        _this.getRSBlocks = function(typeNumber, errorCorrectionLevel) {\n          var rsBlock = getRsBlockTable(typeNumber, errorCorrectionLevel);\n          if (typeof rsBlock == \"undefined\") {\n            throw \"bad rs block @ typeNumber:\" + typeNumber + \"/errorCorrectionLevel:\" + errorCorrectionLevel;\n          }\n          var length = rsBlock.length / 3;\n          var list = [];\n          for (var i2 = 0; i2 < length; i2 += 1) {\n            var count = rsBlock[i2 * 3 + 0];\n            var totalCount = rsBlock[i2 * 3 + 1];\n            var dataCount = rsBlock[i2 * 3 + 2];\n            for (var j = 0; j < count; j += 1) {\n              list.push(qrRSBlock(totalCount, dataCount));\n            }\n          }\n          return list;\n        };\n        return _this;\n      }();\n      var qrBitBuffer = function() {\n        var _buffer = [];\n        var _length = 0;\n        var _this = {};\n        _this.getBuffer = function() {\n          return _buffer;\n        };\n        _this.getAt = function(index) {\n          var bufIndex = Math.floor(index / 8);\n          return (_buffer[bufIndex] >>> 7 - index % 8 & 1) == 1;\n        };\n        _this.put = function(num, length) {\n          for (var i2 = 0; i2 < length; i2 += 1) {\n            _this.putBit((num >>> length - i2 - 1 & 1) == 1);\n          }\n        };\n        _this.getLengthInBits = function() {\n          return _length;\n        };\n        _this.putBit = function(bit) {\n          var bufIndex = Math.floor(_length / 8);\n          if (_buffer.length <= bufIndex) {\n            _buffer.push(0);\n          }\n          if (bit) {\n            _buffer[bufIndex] |= 128 >>> _length % 8;\n          }\n          _length += 1;\n        };\n        return _this;\n      };\n      var qrNumber = function(data) {\n        var _mode = QRMode.MODE_NUMBER;\n        var _data = data;\n        var _this = {};\n        _this.getMode = function() {\n          return _mode;\n        };\n        _this.getLength = function(buffer) {\n          return _data.length;\n        };\n        _this.write = function(buffer) {\n          var data2 = _data;\n          var i2 = 0;\n          while (i2 + 2 < data2.length) {\n            buffer.put(strToNum(data2.substring(i2, i2 + 3)), 10);\n            i2 += 3;\n          }\n          if (i2 < data2.length) {\n            if (data2.length - i2 == 1) {\n              buffer.put(strToNum(data2.substring(i2, i2 + 1)), 4);\n            } else if (data2.length - i2 == 2) {\n              buffer.put(strToNum(data2.substring(i2, i2 + 2)), 7);\n            }\n          }\n        };\n        var strToNum = function(s2) {\n          var num = 0;\n          for (var i2 = 0; i2 < s2.length; i2 += 1) {\n            num = num * 10 + chatToNum(s2.charAt(i2));\n          }\n          return num;\n        };\n        var chatToNum = function(c2) {\n          if (\"0\" <= c2 && c2 <= \"9\") {\n            return c2.charCodeAt(0) - \"0\".charCodeAt(0);\n          }\n          throw \"illegal char :\" + c2;\n        };\n        return _this;\n      };\n      var qrAlphaNum = function(data) {\n        var _mode = QRMode.MODE_ALPHA_NUM;\n        var _data = data;\n        var _this = {};\n        _this.getMode = function() {\n          return _mode;\n        };\n        _this.getLength = function(buffer) {\n          return _data.length;\n        };\n        _this.write = function(buffer) {\n          var s2 = _data;\n          var i2 = 0;\n          while (i2 + 1 < s2.length) {\n            buffer.put(\n              getCode(s2.charAt(i2)) * 45 + getCode(s2.charAt(i2 + 1)),\n              11\n            );\n            i2 += 2;\n          }\n          if (i2 < s2.length) {\n            buffer.put(getCode(s2.charAt(i2)), 6);\n          }\n        };\n        var getCode = function(c2) {\n          if (\"0\" <= c2 && c2 <= \"9\") {\n            return c2.charCodeAt(0) - \"0\".charCodeAt(0);\n          } else if (\"A\" <= c2 && c2 <= \"Z\") {\n            return c2.charCodeAt(0) - \"A\".charCodeAt(0) + 10;\n          } else {\n            switch (c2) {\n              case \" \":\n                return 36;\n              case \"$\":\n                return 37;\n              case \"%\":\n                return 38;\n              case \"*\":\n                return 39;\n              case \"+\":\n                return 40;\n              case \"-\":\n                return 41;\n              case \".\":\n                return 42;\n              case \"/\":\n                return 43;\n              case \":\":\n                return 44;\n              default:\n                throw \"illegal char :\" + c2;\n            }\n          }\n        };\n        return _this;\n      };\n      var qr8BitByte = function(data) {\n        var _mode = QRMode.MODE_8BIT_BYTE;\n        var _bytes = qrcode3.stringToBytes(data);\n        var _this = {};\n        _this.getMode = function() {\n          return _mode;\n        };\n        _this.getLength = function(buffer) {\n          return _bytes.length;\n        };\n        _this.write = function(buffer) {\n          for (var i2 = 0; i2 < _bytes.length; i2 += 1) {\n            buffer.put(_bytes[i2], 8);\n          }\n        };\n        return _this;\n      };\n      var qrKanji = function(data) {\n        var _mode = QRMode.MODE_KANJI;\n        var stringToBytes = qrcode3.stringToBytesFuncs[\"SJIS\"];\n        if (!stringToBytes) {\n          throw \"sjis not supported.\";\n        }\n        !function(c2, code) {\n          var test = stringToBytes(c2);\n          if (test.length != 2 || (test[0] << 8 | test[1]) != code) {\n            throw \"sjis not supported.\";\n          }\n        }(\"\", 38726);\n        var _bytes = stringToBytes(data);\n        var _this = {};\n        _this.getMode = function() {\n          return _mode;\n        };\n        _this.getLength = function(buffer) {\n          return ~~(_bytes.length / 2);\n        };\n        _this.write = function(buffer) {\n          var data2 = _bytes;\n          var i2 = 0;\n          while (i2 + 1 < data2.length) {\n            var c2 = (255 & data2[i2]) << 8 | 255 & data2[i2 + 1];\n            if (33088 <= c2 && c2 <= 40956) {\n              c2 -= 33088;\n            } else if (57408 <= c2 && c2 <= 60351) {\n              c2 -= 49472;\n            } else {\n              throw \"illegal char at \" + (i2 + 1) + \"/\" + c2;\n            }\n            c2 = (c2 >>> 8 & 255) * 192 + (c2 & 255);\n            buffer.put(c2, 13);\n            i2 += 2;\n          }\n          if (i2 < data2.length) {\n            throw \"illegal char at \" + (i2 + 1);\n          }\n        };\n        return _this;\n      };\n      var byteArrayOutputStream = function() {\n        var _bytes = [];\n        var _this = {};\n        _this.writeByte = function(b) {\n          _bytes.push(b & 255);\n        };\n        _this.writeShort = function(i2) {\n          _this.writeByte(i2);\n          _this.writeByte(i2 >>> 8);\n        };\n        _this.writeBytes = function(b, off, len) {\n          off = off || 0;\n          len = len || b.length;\n          for (var i2 = 0; i2 < len; i2 += 1) {\n            _this.writeByte(b[i2 + off]);\n          }\n        };\n        _this.writeString = function(s2) {\n          for (var i2 = 0; i2 < s2.length; i2 += 1) {\n            _this.writeByte(s2.charCodeAt(i2));\n          }\n        };\n        _this.toByteArray = function() {\n          return _bytes;\n        };\n        _this.toString = function() {\n          var s2 = \"\";\n          s2 += \"[\";\n          for (var i2 = 0; i2 < _bytes.length; i2 += 1) {\n            if (i2 > 0) {\n              s2 += \",\";\n            }\n            s2 += _bytes[i2];\n          }\n          s2 += \"]\";\n          return s2;\n        };\n        return _this;\n      };\n      var base64EncodeOutputStream = function() {\n        var _buffer = 0;\n        var _buflen = 0;\n        var _length = 0;\n        var _base64 = \"\";\n        var _this = {};\n        var writeEncoded = function(b) {\n          _base64 += String.fromCharCode(encode(b & 63));\n        };\n        var encode = function(n2) {\n          if (n2 < 0) ;\n          else if (n2 < 26) {\n            return 65 + n2;\n          } else if (n2 < 52) {\n            return 97 + (n2 - 26);\n          } else if (n2 < 62) {\n            return 48 + (n2 - 52);\n          } else if (n2 == 62) {\n            return 43;\n          } else if (n2 == 63) {\n            return 47;\n          }\n          throw \"n:\" + n2;\n        };\n        _this.writeByte = function(n2) {\n          _buffer = _buffer << 8 | n2 & 255;\n          _buflen += 8;\n          _length += 1;\n          while (_buflen >= 6) {\n            writeEncoded(_buffer >>> _buflen - 6);\n            _buflen -= 6;\n          }\n        };\n        _this.flush = function() {\n          if (_buflen > 0) {\n            writeEncoded(_buffer << 6 - _buflen);\n            _buffer = 0;\n            _buflen = 0;\n          }\n          if (_length % 3 != 0) {\n            var padlen = 3 - _length % 3;\n            for (var i2 = 0; i2 < padlen; i2 += 1) {\n              _base64 += \"=\";\n            }\n          }\n        };\n        _this.toString = function() {\n          return _base64;\n        };\n        return _this;\n      };\n      var base64DecodeInputStream = function(str) {\n        var _str = str;\n        var _pos = 0;\n        var _buffer = 0;\n        var _buflen = 0;\n        var _this = {};\n        _this.read = function() {\n          while (_buflen < 8) {\n            if (_pos >= _str.length) {\n              if (_buflen == 0) {\n                return -1;\n              }\n              throw \"unexpected end of file./\" + _buflen;\n            }\n            var c2 = _str.charAt(_pos);\n            _pos += 1;\n            if (c2 == \"=\") {\n              _buflen = 0;\n              return -1;\n            } else if (c2.match(/^\\s$/)) {\n              continue;\n            }\n            _buffer = _buffer << 6 | decode(c2.charCodeAt(0));\n            _buflen += 6;\n          }\n          var n2 = _buffer >>> _buflen - 8 & 255;\n          _buflen -= 8;\n          return n2;\n        };\n        var decode = function(c2) {\n          if (65 <= c2 && c2 <= 90) {\n            return c2 - 65;\n          } else if (97 <= c2 && c2 <= 122) {\n            return c2 - 97 + 26;\n          } else if (48 <= c2 && c2 <= 57) {\n            return c2 - 48 + 52;\n          } else if (c2 == 43) {\n            return 62;\n          } else if (c2 == 47) {\n            return 63;\n          } else {\n            throw \"c:\" + c2;\n          }\n        };\n        return _this;\n      };\n      var gifImage = function(width, height) {\n        var _width = width;\n        var _height = height;\n        var _data = new Array(width * height);\n        var _this = {};\n        _this.setPixel = function(x, y, pixel) {\n          _data[y * _width + x] = pixel;\n        };\n        _this.write = function(out) {\n          out.writeString(\"GIF87a\");\n          out.writeShort(_width);\n          out.writeShort(_height);\n          out.writeByte(128);\n          out.writeByte(0);\n          out.writeByte(0);\n          out.writeByte(0);\n          out.writeByte(0);\n          out.writeByte(0);\n          out.writeByte(255);\n          out.writeByte(255);\n          out.writeByte(255);\n          out.writeString(\",\");\n          out.writeShort(0);\n          out.writeShort(0);\n          out.writeShort(_width);\n          out.writeShort(_height);\n          out.writeByte(0);\n          var lzwMinCodeSize = 2;\n          var raster = getLZWRaster(lzwMinCodeSize);\n          out.writeByte(lzwMinCodeSize);\n          var offset = 0;\n          while (raster.length - offset > 255) {\n            out.writeByte(255);\n            out.writeBytes(raster, offset, 255);\n            offset += 255;\n          }\n          out.writeByte(raster.length - offset);\n          out.writeBytes(raster, offset, raster.length - offset);\n          out.writeByte(0);\n          out.writeString(\";\");\n        };\n        var bitOutputStream = function(out) {\n          var _out = out;\n          var _bitLength = 0;\n          var _bitBuffer = 0;\n          var _this2 = {};\n          _this2.write = function(data, length) {\n            if (data >>> length != 0) {\n              throw \"length over\";\n            }\n            while (_bitLength + length >= 8) {\n              _out.writeByte(255 & (data << _bitLength | _bitBuffer));\n              length -= 8 - _bitLength;\n              data >>>= 8 - _bitLength;\n              _bitBuffer = 0;\n              _bitLength = 0;\n            }\n            _bitBuffer = data << _bitLength | _bitBuffer;\n            _bitLength = _bitLength + length;\n          };\n          _this2.flush = function() {\n            if (_bitLength > 0) {\n              _out.writeByte(_bitBuffer);\n            }\n          };\n          return _this2;\n        };\n        var getLZWRaster = function(lzwMinCodeSize) {\n          var clearCode = 1 << lzwMinCodeSize;\n          var endCode = (1 << lzwMinCodeSize) + 1;\n          var bitLength = lzwMinCodeSize + 1;\n          var table = lzwTable();\n          for (var i2 = 0; i2 < clearCode; i2 += 1) {\n            table.add(String.fromCharCode(i2));\n          }\n          table.add(String.fromCharCode(clearCode));\n          table.add(String.fromCharCode(endCode));\n          var byteOut = byteArrayOutputStream();\n          var bitOut = bitOutputStream(byteOut);\n          bitOut.write(clearCode, bitLength);\n          var dataIndex = 0;\n          var s2 = String.fromCharCode(_data[dataIndex]);\n          dataIndex += 1;\n          while (dataIndex < _data.length) {\n            var c2 = String.fromCharCode(_data[dataIndex]);\n            dataIndex += 1;\n            if (table.contains(s2 + c2)) {\n              s2 = s2 + c2;\n            } else {\n              bitOut.write(table.indexOf(s2), bitLength);\n              if (table.size() < 4095) {\n                if (table.size() == 1 << bitLength) {\n                  bitLength += 1;\n                }\n                table.add(s2 + c2);\n              }\n              s2 = c2;\n            }\n          }\n          bitOut.write(table.indexOf(s2), bitLength);\n          bitOut.write(endCode, bitLength);\n          bitOut.flush();\n          return byteOut.toByteArray();\n        };\n        var lzwTable = function() {\n          var _map = {};\n          var _size = 0;\n          var _this2 = {};\n          _this2.add = function(key) {\n            if (_this2.contains(key)) {\n              throw \"dup key:\" + key;\n            }\n            _map[key] = _size;\n            _size += 1;\n          };\n          _this2.size = function() {\n            return _size;\n          };\n          _this2.indexOf = function(key) {\n            return _map[key];\n          };\n          _this2.contains = function(key) {\n            return typeof _map[key] != \"undefined\";\n          };\n          return _this2;\n        };\n        return _this;\n      };\n      var createDataURL = function(width, height, getPixel) {\n        var gif = gifImage(width, height);\n        for (var y = 0; y < height; y += 1) {\n          for (var x = 0; x < width; x += 1) {\n            gif.setPixel(x, y, getPixel(x, y));\n          }\n        }\n        var b = byteArrayOutputStream();\n        gif.write(b);\n        var base64 = base64EncodeOutputStream();\n        var bytes = b.toByteArray();\n        for (var i2 = 0; i2 < bytes.length; i2 += 1) {\n          base64.writeByte(bytes[i2]);\n        }\n        base64.flush();\n        return \"data:image/gif;base64,\" + base64;\n      };\n      return qrcode3;\n    }();\n    !function() {\n      qrcode2.stringToBytesFuncs[\"UTF-8\"] = function(s2) {\n        function toUTF8Array(str) {\n          var utf8 = [];\n          for (var i2 = 0; i2 < str.length; i2++) {\n            var charcode = str.charCodeAt(i2);\n            if (charcode < 128) utf8.push(charcode);\n            else if (charcode < 2048) {\n              utf8.push(\n                192 | charcode >> 6,\n                128 | charcode & 63\n              );\n            } else if (charcode < 55296 || charcode >= 57344) {\n              utf8.push(\n                224 | charcode >> 12,\n                128 | charcode >> 6 & 63,\n                128 | charcode & 63\n              );\n            } else {\n              i2++;\n              charcode = 65536 + ((charcode & 1023) << 10 | str.charCodeAt(i2) & 1023);\n              utf8.push(\n                240 | charcode >> 18,\n                128 | charcode >> 12 & 63,\n                128 | charcode >> 6 & 63,\n                128 | charcode & 63\n              );\n            }\n          }\n          return utf8;\n        }\n        return toUTF8Array(s2);\n      };\n    }();\n    (function(factory) {\n      {\n        module.exports = factory();\n      }\n    })(function() {\n      return qrcode2;\n    });\n  })(qrcode$1);\n  return qrcode$1.exports;\n}\nvar qrcodeExports = requireQrcode();\nconst qrcode = /* @__PURE__ */ getDefaultExportFromCjs(qrcodeExports);\nfunction copyToClipboard(text) {\n  return __async(this, null, function* () {\n    try {\n      if (!(navigator == null ? void 0 : navigator.clipboard)) {\n        throw new TonConnectUIError(\"Clipboard API not available\");\n      }\n      return yield navigator.clipboard.writeText(text);\n    } catch (e2) {\n    }\n    fallbackCopyTextToClipboard(text);\n  });\n}\nfunction fallbackCopyTextToClipboard(text) {\n  const textArea = document.createElement(\"textarea\");\n  textArea.value = text;\n  textArea.style.top = \"0\";\n  textArea.style.left = \"0\";\n  textArea.style.position = \"fixed\";\n  document.body.appendChild(textArea);\n  textArea.focus();\n  textArea.select();\n  try {\n    document.execCommand(\"copy\");\n  } finally {\n    document.body.removeChild(textArea);\n  }\n}\nvar _tmpl$$s = /* @__PURE__ */ template$1(`<div>`);\nconst QRCode = (props) => {\n  let qrCodeCanvasRef;\n  let qrCodeWrapperRef;\n  let imageRef;\n  const [copyButtonOpened, setCopyButtonOpened] = createSignal(false);\n  const [picSize, setPicSize] = createSignal(picSizeDefault);\n  createEffect(() => {\n    const errorCorrectionLevel = \"L\";\n    const cellSize = 4;\n    const qr = qrcode(0, errorCorrectionLevel);\n    qr.addData(props.sourceUrl);\n    qr.make();\n    qrCodeCanvasRef.innerHTML = qr.createSvgTag(cellSize, 0);\n    const qrSize = qrCodeCanvasRef.firstElementChild.clientWidth;\n    const scale = Math.round(qrNormalSize / qrSize * 1e5) / 1e5;\n    if (imageRef) {\n      const imgSize = Math.ceil(imgSizeDefault / (scale * cellSize)) * cellSize;\n      const imgOffset = toPx(Math.ceil((qrSize - imgSize) / (2 * cellSize)) * cellSize);\n      imageRef.style.top = imgOffset;\n      imageRef.style.left = imgOffset;\n      imageRef.style.height = toPx(imgSize);\n      imageRef.style.width = toPx(imgSize);\n      setPicSize(Math.round(picSizeDefault / scale));\n    }\n    qrCodeWrapperRef.style.transform = `scale(${scale})`;\n  });\n  let timeoutId = null;\n  const onCopyClick = () => {\n    setCopyButtonOpened(true);\n    copyToClipboard(props.sourceUrl);\n    if (timeoutId != null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => setCopyButtonOpened(false), 1500);\n  };\n  return createComponent(QrCodeBackground, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    onClick: onCopyClick,\n    get children() {\n      return [createComponent(QrCodeWrapper$2, {\n        ref(r$) {\n          var _ref$ = qrCodeWrapperRef;\n          typeof _ref$ === \"function\" ? _ref$(r$) : qrCodeWrapperRef = r$;\n        },\n        get children() {\n          return [(() => {\n            var _el$ = _tmpl$$s();\n            var _ref$2 = qrCodeCanvasRef;\n            typeof _ref$2 === \"function\" ? use(_ref$2, _el$) : qrCodeCanvasRef = _el$;\n            return _el$;\n          })(), createComponent(Show, {\n            get when() {\n              return props.imageUrl;\n            },\n            get children() {\n              return createComponent(ImageBackground, {\n                ref(r$) {\n                  var _ref$3 = imageRef;\n                  typeof _ref$3 === \"function\" ? _ref$3(r$) : imageRef = r$;\n                },\n                get children() {\n                  return createComponent(ImageStyled$3, {\n                    get src() {\n                      return props.imageUrl;\n                    },\n                    alt: \"\",\n                    get size() {\n                      return picSize();\n                    }\n                  });\n                }\n              });\n            }\n          })];\n        }\n      }), createComponent(Transition, {\n        onBeforeEnter: (el) => {\n          animate(el, [{\n            opacity: 0,\n            transform: \"translate(-50%, 44px)\"\n          }, {\n            opacity: 1,\n            transform: \"translate(-50%, 0)\"\n          }], {\n            duration: 150,\n            easing: \"ease-out\"\n          });\n        },\n        onExit: (el, done) => {\n          animate(el, [{\n            opacity: 1,\n            transform: \"translate(-50%, 0)\"\n          }, {\n            opacity: 0,\n            transform: \"translate(-50%, 44px)\"\n          }], {\n            duration: 150,\n            easing: \"ease-out\"\n          }).finished.then(() => {\n            done();\n          });\n        },\n        get children() {\n          return createComponent(Show, {\n            get when() {\n              return copyButtonOpened() && !props.disableCopy;\n            },\n            get children() {\n              return createComponent(CopiedBoxStyled, {\n                get children() {\n                  return [createComponent(SuccessIcon, {\n                    size: \"xs\"\n                  }), createComponent(Text, {\n                    translationKey: \"common.linkCopied\",\n                    children: \"Link Copied\"\n                  })];\n                }\n              });\n            }\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !props.disableCopy;\n        },\n        get children() {\n          return createComponent(CopyIconButton, {\n            get children() {\n              return createComponent(CopyLightIcon, {});\n            }\n          });\n        }\n      })];\n    }\n  });\n};\nvar deepReadObject = (obj, path, defaultValue) => {\n  const value = path.trim().split(\".\").reduce((a2, b) => a2 ? a2[b] : void 0, obj);\n  return value !== void 0 ? value : defaultValue;\n};\nvar template = (str, params, reg = /{{(.*?)}}/g) => str.replace(reg, (_, key) => deepReadObject(params, key, \"\"));\nvar createI18nContext = (init = {}, lang = navigator.language in init ? navigator.language : Object.keys(init)[0]) => {\n  const [locale, setLocale] = createSignal(lang);\n  const [dict, setDict] = createStore(init);\n  const translate = (key, params, defaultValue) => {\n    const val = deepReadObject(dict[locale()], key, defaultValue || \"\");\n    if (typeof val === \"function\")\n      return val(params);\n    if (typeof val === \"string\")\n      return template(val, params || {});\n    return val;\n  };\n  const actions = {\n    add(lang2, table) {\n      setDict(lang2, (t2) => Object.assign(t2 || {}, table));\n    },\n    locale: (lang2) => lang2 ? setLocale(lang2) : locale(),\n    dict: (lang2) => deepReadObject(dict, lang2)\n  };\n  return [translate, actions];\n};\nvar I18nContext = createContext({});\nvar useI18n = () => useContext(I18nContext);\nconst TextStyled$4 = styled.div`\n    font-style: normal;\n    font-weight: ${(props) => props.fontWeight};\n    font-size: ${(props) => props.fontSize};\n    line-height: ${(props) => props.lineHeight};\n\n    color: ${(props) => props.color};\n`;\nconst Text = (inputs) => {\n  const theme = useTheme();\n  const [t2] = useI18n();\n  let textRef;\n  const color = () => inputs.color || theme.colors.text.primary;\n  const props = mergeProps({\n    fontSize: \"14px\",\n    fontWeight: \"510\",\n    lineHeight: \"130%\"\n  }, inputs);\n  createEffect(() => {\n    if (!textRef) {\n      return;\n    }\n    if (props.cursor === \"unset\") {\n      return;\n    }\n    if (getComputedStyle(textRef).cursor !== \"pointer\") {\n      textRef.style.cursor = \"default\";\n    }\n  });\n  return createComponent(TextStyled$4, {\n    get fontSize() {\n      return props.fontSize;\n    },\n    get fontWeight() {\n      return props.fontWeight;\n    },\n    get lineHeight() {\n      return props.lineHeight;\n    },\n    get color() {\n      return color();\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    ref(r$) {\n      var _ref$ = textRef;\n      typeof _ref$ === \"function\" ? _ref$(r$) : textRef = r$;\n    },\n    \"data-tc-text\": \"true\",\n    get children() {\n      var _a2;\n      return memo(() => !!props.translationKey)() ? t2(props.translationKey, props.translationValues, (_a2 = props.children) == null ? void 0 : _a2.toString()) : props.children;\n    }\n  });\n};\nconst ImageContainer = styled.div`\n    position: relative;\n\n    &::after {\n        content: '';\n        display: block;\n        position: absolute;\n        top: 0;\n        bottom: 0;\n        left: 0;\n        right: 0;\n        border: 0.5px solid rgba(0, 0, 0, 0.08);\n        border-radius: inherit;\n    }\n`;\nconst ImageStyled$2 = styled(Image)`\n    width: 100%;\n    height: 100%;\n    border-radius: inherit;\n`;\nconst WalletImage = (props) => {\n  return createComponent(ImageContainer, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    get children() {\n      return [createComponent(ImageStyled$2, {\n        get src() {\n          return props.src;\n        }\n      }), memo(() => props.badge)];\n    }\n  });\n};\nconst borders$4 = {\n  m: \"16px\",\n  s: \"12px\",\n  none: \"0\"\n};\nconst badgeBorders = {\n  m: \"6px\",\n  s: \"6px\",\n  none: \"0\"\n};\nconst WalletUlContainer = styled.ul`\n    display: flex;\n    gap: 0;\n    width: 100%;\n    overflow-x: auto;\n    padding: 8px 12px 16px 12px;\n    margin: 0;\n    list-style: none;\n    flex-wrap: nowrap;\n\n    &&::-webkit-scrollbar {\n        display: none;\n    }\n    -ms-overflow-style: none;\n    scrollbar-width: none;\n\n    > li {\n        display: flex;\n        flex: 1;\n        min-width: 78px;\n        height: fit-content;\n    }\n\n    > li > button {\n        width: 100%;\n    }\n`;\nconst WalletItemStyled = styled.button`\n    position: relative;\n    cursor: pointer;\n    border: none;\n    background-color: unset;\n    padding: 8px 4px;\n    min-width: 78px;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n\n    transition: transform 0.125s ease-in-out;\n\n    ${mediaNotTouch} {\n        &:hover {\n            transform: scale(1.04);\n        }\n    }\n\n    &:active {\n        transform: scale(0.96);\n    }\n\n    ${mediaTouch} {\n        &:active {\n            transform: scale(0.92);\n        }\n    }\n`;\nconst ImageStyled$1 = styled(WalletImage)`\n    width: 60px;\n    height: 60px;\n    border-radius: ${(props) => borders$4[props.theme.borderRadius]};\n    margin-bottom: 8px;\n    position: relative;\n`;\nconst BadgeStyled = styled(Image)`\n    position: absolute;\n    right: -6px;\n    bottom: -6px;\n    width: 24px;\n    height: 24px;\n    border-radius: ${(props) => badgeBorders[props.theme.borderRadius]};\n    box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.08);\n`;\nconst StyledText = styled(Text)`\n    max-width: 90px;\n    font-weight: 510;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    overflow: hidden;\n\n    ${media(\"mobile\")} {\n        max-width: 80px;\n    }\n`;\nconst StyledSecondLine = styled(Text)`\n    font-weight: ${(props) => props.colorPrimary ? \"510\" : \"400\"};\n    max-width: 90px;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    color: ${(props) => props.colorPrimary ? props.theme.colors.text.primary : props.theme.colors.text.secondary};\n\n    ${media(\"mobile\")} {\n        max-width: 80px;\n    }\n`;\nvar _tmpl$$r = /* @__PURE__ */ template$1(`<div>`);\nconst WalletItem = (props) => {\n  let ctxRef = null;\n  const adjustLetterSpacing = () => {\n    const name = ctxRef == null ? void 0 : ctxRef.querySelector(\"div\");\n    if (name && name.scrollWidth > name.clientWidth) {\n      let spacing = 0;\n      const minSpacing = -0.4;\n      const step = 0.05;\n      while (name.scrollWidth > name.clientWidth && spacing >= minSpacing) {\n        spacing -= step;\n        name.style.letterSpacing = `${spacing}px`;\n      }\n      if (spacing !== 0) {\n        spacing -= step;\n        name.style.letterSpacing = `${spacing}px`;\n      }\n    }\n  };\n  onMount(() => adjustLetterSpacing());\n  createEffect(() => {\n    adjustLetterSpacing();\n  });\n  return createComponent(WalletItemStyled, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    onClick: () => props.onClick(),\n    \"data-tc-wallet-item\": \"true\",\n    get children() {\n      return [memo(() => memo(() => typeof props.icon === \"string\")() ? createComponent(ImageStyled$1, {\n        get src() {\n          return props.icon;\n        },\n        get badge() {\n          return memo(() => !!props.badgeUrl)() && createComponent(BadgeStyled, {\n            get src() {\n              return props.badgeUrl;\n            }\n          });\n        }\n      }) : props.icon), (() => {\n        var _el$ = _tmpl$$r();\n        use((el) => ctxRef = el, _el$);\n        insert(_el$, createComponent(StyledText, {\n          get children() {\n            return props.name;\n          }\n        }));\n        return _el$;\n      })(), memo(() => memo(() => !!props.secondLine)() && createComponent(StyledSecondLine, {\n        get colorPrimary() {\n          var _a2;\n          return (_a2 = props.secondLineColorPrimary) != null ? _a2 : true;\n        },\n        get children() {\n          return props.secondLine;\n        }\n      }))];\n    }\n  });\n};\nconst H1Styled$b = styled.h1`\n    font-style: normal;\n    font-weight: 590;\n    font-size: 20px;\n    line-height: 28px;\n\n    text-align: center;\n\n    color: ${(props) => props.theme.colors.text.primary};\n\n    margin-top: 0;\n    margin-bottom: 0;\n\n    cursor: default;\n`;\nconst H1 = (props) => {\n  const [t2] = useI18n();\n  return createComponent(H1Styled$b, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-h1\": \"true\",\n    get children() {\n      var _a2;\n      return memo(() => !!props.translationKey)() ? t2(props.translationKey, props.translationValues, (_a2 = props.children) == null ? void 0 : _a2.toString()) : props.children;\n    }\n  });\n};\nconst H2Styled$5 = styled.h2`\n    font-style: normal;\n    font-weight: 400;\n    font-size: 16px;\n    line-height: 22px;\n\n    text-align: center;\n\n    color: ${(props) => props.theme.colors.text.secondary};\n\n    margin-top: 0;\n    margin-bottom: 32px;\n\n    cursor: default;\n`;\nconst H2 = (props) => {\n  const [t2] = useI18n();\n  return createComponent(H2Styled$5, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-h2\": \"true\",\n    get children() {\n      var _a2;\n      return memo(() => !!props.translationKey)() ? t2(props.translationKey, props.translationValues, (_a2 = props.children) == null ? void 0 : _a2.toString()) : props.children;\n    }\n  });\n};\nconst H3Styled$2 = styled.h3`\n    font-style: normal;\n    font-weight: 510;\n    font-size: 16px;\n    line-height: 20px;\n\n    color: ${(props) => props.theme.colors.text.primary};\n\n    margin-top: 0;\n    margin-bottom: 0;\n\n    cursor: default;\n`;\nconst H3 = (props) => {\n  const [t2] = useI18n();\n  return createComponent(H3Styled$2, {\n    \"data-tc-h3\": \"true\",\n    get [\"class\"]() {\n      return props.class;\n    },\n    get children() {\n      var _a2;\n      return memo(() => !!props.translationKey)() ? t2(props.translationKey, props.translationValues, (_a2 = props.children) == null ? void 0 : _a2.toString()) : props.children;\n    }\n  });\n};\nvar _tmpl$$q = /* @__PURE__ */ template$1(`<svg width=24 height=24 viewBox=\"0 0 24 24\"fill=none xmlns=http://www.w3.org/2000/svg><path fill-rule=evenodd clip-rule=evenodd d=\"M14.1839 17.7069C13.6405 18.6507 13.3688 19.1226 13.0591 19.348C12.4278 19.8074 11.5723 19.8074 10.941 19.348C10.6312 19.1226 10.3595 18.6507 9.81613 17.7069L5.52066 10.2464C4.76864 8.94024 4.39263 8.28717 4.33762 7.75894C4.2255 6.68236 4.81894 5.65591 5.80788 5.21589C6.29309 5 7.04667 5 8.55383 5H15.4462C16.9534 5 17.7069 5 18.1922 5.21589C19.1811 5.65591 19.7745 6.68236 19.6624 7.75894C19.6074 8.28717 19.2314 8.94024 18.4794 10.2464L14.1839 17.7069ZM11.1 16.3412L6.56139 8.48002C6.31995 8.06185 6.19924 7.85276 6.18146 7.68365C6.14523 7.33896 6.33507 7.01015 6.65169 6.86919C6.80703 6.80002 7.04847 6.80002 7.53133 6.80002H7.53134L11.1 6.80002V16.3412ZM12.9 16.3412L17.4387 8.48002C17.6801 8.06185 17.8008 7.85276 17.8186 7.68365C17.8548 7.33896 17.665 7.01015 17.3484 6.86919C17.193 6.80002 16.9516 6.80002 16.4687 6.80002L12.9 6.80002V16.3412Z\">`);\nconst TonIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.primary;\n  return (() => {\n    var _el$ = _tmpl$$q(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$p = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none><g clip-path=url(#clip0_3783_2045)><circle cx=8 cy=8.00098 r=8></circle><path d=\"M4.75 8.50098L7 10.751L11.75 6.00098\"stroke-width=1.5 stroke-linecap=round stroke-linejoin=round></path></g><defs><clipPath id=clip0_3783_2045><rect width=16 height=16 fill=white transform=\"translate(0 0.000976562)\">`), _tmpl$2$4 = /* @__PURE__ */ template$1(`<svg width=24 height=24 viewBox=\"0 0 24 24\"fill=none xmlns=http://www.w3.org/2000/svg><circle cx=12 cy=12 r=11></circle><path d=\"M17.1364 9.6364C17.4879 9.28493 17.4879 8.71508 17.1364 8.36361C16.7849 8.01214 16.2151 8.01214 15.8636 8.36361L10 14.2272L8.1364 12.3636C7.78493 12.0121 7.21508 12.0121 6.86361 12.3636C6.51214 12.7151 6.51214 13.2849 6.86361 13.6364L9.36361 16.1364C9.71508 16.4879 10.2849 16.4879 10.6364 16.1364L17.1364 9.6364Z\">`), _tmpl$3$2 = /* @__PURE__ */ template$1(`<svg width=72 height=72 viewBox=\"0 0 72 72\"fill=none xmlns=http://www.w3.org/2000/svg><circle cx=36 cy=36 r=33></circle><path d=\"M50.9142 28.4142C51.6953 27.6332 51.6953 26.3668 50.9142 25.5858C50.1332 24.8047 48.8668 24.8047 48.0858 25.5858L30 43.6716L23.9142 37.5858C23.1332 36.8047 21.8668 36.8047 21.0858 37.5858C20.3047 38.3668 20.3047 39.6332 21.0858 40.4142L28.5858 47.9142C29.3668 48.6953 30.6332 48.6953 31.4142 47.9142L50.9142 28.4142Z\">`);\nconst SuccessIcon = (props) => {\n  const theme = useTheme();\n  const size = () => props.size || \"s\";\n  const fill = () => props.fill || theme.colors.icon.success;\n  return memo(() => memo(() => size() === \"xs\")() ? (() => {\n    var _el$ = _tmpl$$p(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$ = props.class, _v$2 = fill(), _v$3 = theme.colors.constant.white;\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$3, \"fill\", _p$.t = _v$2);\n      _v$3 !== _p$.a && setAttribute(_el$4, \"stroke\", _p$.a = _v$3);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0\n    });\n    return _el$;\n  })() : memo(() => size() === \"s\")() ? (() => {\n    var _el$5 = _tmpl$2$4(), _el$6 = _el$5.firstChild, _el$7 = _el$6.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$4 = props.class, _v$5 = fill(), _v$6 = theme.colors.constant.white;\n      _v$4 !== _p$.e && setAttribute(_el$5, \"class\", _p$.e = _v$4);\n      _v$5 !== _p$.t && setAttribute(_el$6, \"fill\", _p$.t = _v$5);\n      _v$6 !== _p$.a && setAttribute(_el$7, \"fill\", _p$.a = _v$6);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0\n    });\n    return _el$5;\n  })() : (() => {\n    var _el$8 = _tmpl$3$2(), _el$9 = _el$8.firstChild, _el$0 = _el$9.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$7 = props.class, _v$8 = fill(), _v$9 = theme.colors.constant.white;\n      _v$7 !== _p$.e && setAttribute(_el$8, \"class\", _p$.e = _v$7);\n      _v$8 !== _p$.t && setAttribute(_el$9, \"fill\", _p$.t = _v$8);\n      _v$9 !== _p$.a && setAttribute(_el$0, \"fill\", _p$.a = _v$9);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0\n    });\n    return _el$8;\n  })());\n};\nvar _tmpl$$o = /* @__PURE__ */ template$1(`<svg width=72 height=72 viewBox=\"0 0 72 72\"fill=none xmlns=http://www.w3.org/2000/svg><circle cx=36 cy=36 r=33></circle><path d=\"M24.0858 26.9142C23.3047 26.1332 23.3047 24.8668 24.0858 24.0858C24.8668 23.3047 26.1332 23.3047 26.9142 24.0858L36 33.1716L45.0858 24.0858C45.8668 23.3047 47.1332 23.3047 47.9142 24.0858C48.6953 24.8668 48.6953 26.1332 47.9142 26.9142L38.8284 36L47.9142 45.0858C48.6953 45.8668 48.6953 47.1332 47.9142 47.9142C47.1332 48.6953 45.8668 48.6953 45.0858 47.9142L36 38.8284L26.9142 47.9142C26.1332 48.6953 24.8668 48.6953 24.0858 47.9142C23.3047 47.1332 23.3047 45.8668 24.0858 45.0858L33.1716 36L24.0858 26.9142Z\">`), _tmpl$2$3 = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=48 height=48 viewBox=\"0 0 48 48\"fill=none><circle cx=24 cy=24.001 r=22></circle><path d=\"M24 24.001L31.5 16.501M24 24.001L16.5 16.501M24 24.001L16.5 31.501M24 24.001L31.5 31.501\"stroke-width=3 stroke-linecap=round stroke-linejoin=round>`), _tmpl$3$1 = /* @__PURE__ */ template$1(`<svg width=24 height=24 viewBox=\"0 0 24 24\"fill=none xmlns=http://www.w3.org/2000/svg><circle cx=12 cy=12 r=11></circle><path d=\"M7.86361 9.1364C7.51214 8.78493 7.51214 8.21508 7.86361 7.86361C8.21508 7.51214 8.78493 7.51214 9.1364 7.86361L12 10.7272L14.8636 7.86361C15.2151 7.51214 15.7849 7.51214 16.1364 7.86361C16.4879 8.21508 16.4879 8.78493 16.1364 9.1364L13.2728 12L16.1364 14.8636C16.4879 15.2151 16.4879 15.7849 16.1364 16.1364C15.7849 16.4879 15.2151 16.4879 14.8636 16.1364L12 13.2728L9.1364 16.1364C8.78493 16.4879 8.21508 16.4879 7.86361 16.1364C7.51214 15.7849 7.51214 15.2151 7.86361 14.8636L10.7272 12L7.86361 9.1364Z\">`);\nconst ErrorIcon = (props) => {\n  const theme = useTheme();\n  const size = () => props.size || \"m\";\n  const fill = () => props.fill || theme.colors.icon.error;\n  return memo(() => memo(() => size() === \"m\")() ? (() => {\n    var _el$ = _tmpl$$o(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$ = props.class, _v$2 = fill(), _v$3 = theme.colors.constant.white;\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      _v$3 !== _p$.a && setAttribute(_el$3, \"fill\", _p$.a = _v$3);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0\n    });\n    return _el$;\n  })() : memo(() => size() === \"s\")() ? (() => {\n    var _el$4 = _tmpl$2$3(), _el$5 = _el$4.firstChild, _el$6 = _el$5.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$4 = props.class, _v$5 = fill(), _v$6 = theme.colors.constant.white;\n      _v$4 !== _p$.e && setAttribute(_el$4, \"class\", _p$.e = _v$4);\n      _v$5 !== _p$.t && setAttribute(_el$5, \"fill\", _p$.t = _v$5);\n      _v$6 !== _p$.a && setAttribute(_el$6, \"stroke\", _p$.a = _v$6);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0\n    });\n    return _el$4;\n  })() : (() => {\n    var _el$7 = _tmpl$3$1(), _el$8 = _el$7.firstChild, _el$9 = _el$8.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$7 = props.class, _v$8 = fill(), _v$9 = theme.colors.constant.white;\n      _v$7 !== _p$.e && setAttribute(_el$7, \"class\", _p$.e = _v$7);\n      _v$8 !== _p$.t && setAttribute(_el$8, \"fill\", _p$.t = _v$8);\n      _v$9 !== _p$.a && setAttribute(_el$9, \"fill\", _p$.a = _v$9);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0\n    });\n    return _el$7;\n  })());\n};\nvar _tmpl$$n = /* @__PURE__ */ template$1(`<svg width=24 height=24 viewBox=\"0 0 24 24\"fill=none xmlns=http://www.w3.org/2000/svg><path d=\"M15.55 5.85123C18.9459 7.81184 20.1094 12.1541 18.1488 15.55C16.1882 18.9459 11.8459 20.1094 8.44998 18.1488C8.01952 17.9003 7.46909 18.0478 7.22056 18.4782C6.97203 18.9087 7.11952 19.4591 7.54998 19.7076C11.8068 22.1653 17.2499 20.7068 19.7076 16.45C22.1653 12.1932 20.7068 6.75005 16.45 4.29239C12.1932 1.83472 6.75003 3.29321 4.29236 7.55001C4.04383 7.98047 4.19132 8.53091 4.62178 8.77943C5.05224 9.02796 5.60268 8.88048 5.8512 8.45001C7.81181 5.05413 12.1541 3.89062 15.55 5.85123Z\">`), _tmpl$2$2 = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=44 height=44 viewBox=\"0 0 44 44\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M22 2.99951C11.5066 2.99951 3 11.5061 3 21.9995C3 32.4929 11.5066 40.9995 22 40.9995C22.8284 40.9995 23.5 41.6711 23.5 42.4995C23.5 43.3279 22.8284 43.9995 22 43.9995C9.84974 43.9995 0 34.1498 0 21.9995C0 9.84925 9.84974 -0.000488281 22 -0.000488281C34.1503 -0.000488281 44 9.84925 44 21.9995C44 22.8279 43.3284 23.4995 42.5 23.4995C41.6716 23.4995 41 22.8279 41 21.9995C41 11.5061 32.4934 2.99951 22 2.99951Z\">`), _tmpl$3 = /* @__PURE__ */ template$1(`<svg width=72 height=72 viewBox=\"0 0 72 72\"fill=none xmlns=http://www.w3.org/2000/svg><path d=\"M24 56.7846C35.479 63.412 50.1572 59.479 56.7846 47.9999C63.412 36.5209 59.479 21.8427 48 15.2153C36.521 8.58791 21.8428 12.5209 15.2154 23.9999\"stroke-width=4 stroke-linecap=round stroke-linejoin=round>`);\nconst LoaderIcon = (props) => {\n  const theme = useTheme();\n  const size = () => props.size || \"xs\";\n  const fill = () => props.fill || theme.colors.icon.tertiary;\n  const rotateAnimation = h`\n        0% {\n          transform: rotate(0deg);\n        }\n        100% {\n          transform: rotate(360deg);\n        }\n    `;\n  const svgClass = u`\n        animation: ${rotateAnimation} 1s linear infinite;\n    `;\n  return memo(() => memo(() => size() === \"xs\")() ? (() => {\n    var _el$ = _tmpl$$n(), _el$2 = _el$.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = classnames__WEBPACK_IMPORTED_MODULE_3__(svgClass, props.class), _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })() : memo(() => size() === \"s\")() ? (() => {\n    var _el$3 = _tmpl$2$2(), _el$4 = _el$3.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$3 = classnames__WEBPACK_IMPORTED_MODULE_3__(svgClass, props.class), _v$4 = fill();\n      _v$3 !== _p$.e && setAttribute(_el$3, \"class\", _p$.e = _v$3);\n      _v$4 !== _p$.t && setAttribute(_el$4, \"fill\", _p$.t = _v$4);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$3;\n  })() : (() => {\n    var _el$5 = _tmpl$3(), _el$6 = _el$5.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$5 = classnames__WEBPACK_IMPORTED_MODULE_3__(svgClass, props.class), _v$6 = fill();\n      _v$5 !== _p$.e && setAttribute(_el$5, \"class\", _p$.e = _v$5);\n      _v$6 !== _p$.t && setAttribute(_el$6, \"stroke\", _p$.t = _v$6);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$5;\n  })());\n};\nvar _tmpl$$m = /* @__PURE__ */ template$1(`<svg width=158 height=28 viewBox=\"0 0 158 28\"fill=none xmlns=http://www.w3.org/2000/svg><path fill-rule=evenodd clip-rule=evenodd d=\"M28 14.001C28 21.733 21.732 28.001 14 28.001C6.26801 28.001 0 21.733 0 14.001C0 6.26899 6.26801 0.000976562 14 0.000976562C21.732 0.000976562 28 6.26899 28 14.001ZM9.21931 8.00098H18.7801H18.7813C20.538 8.00098 21.6522 9.89966 20.7691 11.4302L14.8672 21.6576C14.4822 22.3254 13.5172 22.3254 13.1322 21.6576L7.23158 11.4302C6.34721 9.89726 7.4614 8.00098 9.21931 8.00098ZM13.1262 18.5882V9.74806H9.21811C8.78976 9.74806 8.53708 10.2029 8.74163 10.5578L11.8423 16.1035L13.1262 18.5882ZM16.1559 16.1047L19.2554 10.5566C19.4599 10.2017 19.2073 9.74685 18.7789 9.74685H14.8709V18.5906L16.1559 16.1047Z\"fill=#0098EA></path><path d=\"M18.7802 8.00098H9.21936C7.46145 8.00098 6.34727 9.89726 7.23164 11.4302L13.1322 21.6576C13.5173 22.3254 14.4823 22.3254 14.8673 21.6576L20.7691 11.4302C21.6523 9.89966 20.5381 8.00098 18.7814 8.00098H18.7802ZM13.1274 18.5906L11.8424 16.1035L8.74168 10.5578C8.53714 10.2029 8.78981 9.74806 9.21816 9.74806H13.1262V18.5918L13.1274 18.5906ZM19.2555 10.5566L16.156 16.1047L14.8709 18.5906V9.74685H18.779C19.2073 9.74685 19.46 10.2017 19.2555 10.5566Z\"fill=white></path><path fill-rule=evenodd clip-rule=evenodd d=\"M51.7483 22.1967C55.7182 22.1967 58.9609 18.954 58.9609 14.9841C58.9609 11.0142 55.7182 7.77148 51.7483 7.77148C47.7588 7.77148 44.5357 11.0142 44.5357 14.9841C44.5357 18.954 47.7588 22.1967 51.7483 22.1967ZM51.7483 19.1702C49.4686 19.1702 47.6802 17.2442 47.6802 14.9841C47.6802 12.724 49.4686 10.798 51.7483 10.798C54.0084 10.798 55.7968 12.724 55.7968 14.9841C55.7968 17.2442 54.0084 19.1702 51.7483 19.1702ZM37.0698 21.9609H40.2142V10.9946H44.2843V8.00732H33V10.9946H37.0698V21.9609ZM69.9379 8.00732H73.0823V21.9609H70.3899L63.59 13.3333V21.9609H60.4652V8.00732H63.1576L69.9379 16.6153V8.00732ZM79.2259 14.9887C79.2259 10.9202 82.351 7.77539 86.4982 7.77539C89.8592 7.77539 92.5519 9.95709 93.2202 12.6891H90.7437C90.154 11.0971 88.4637 9.9964 86.4982 9.9964C83.5893 9.9964 81.5452 12.1781 81.5452 14.9887C81.5452 17.7994 83.5893 19.9811 86.4982 19.9811C88.4637 19.9811 90.154 18.8804 90.7437 17.2884H93.2202C92.5519 20.0204 89.8592 22.2021 86.4982 22.2021C82.351 22.2021 79.2259 19.0573 79.2259 14.9887ZM104.584 17.0525C104.584 19.9025 102.343 22.1628 99.4342 22.1628C96.5253 22.1628 94.2846 19.9025 94.2846 17.0525C94.2846 14.2025 96.5253 11.9422 99.4342 11.9422C102.343 11.9422 104.584 14.2025 104.584 17.0525ZM96.4663 17.0525C96.4663 18.8018 97.6849 20.158 99.4342 20.158C101.164 20.158 102.382 18.8018 102.382 17.0525C102.382 15.3032 101.164 13.947 99.4342 13.947C97.6849 13.947 96.4663 15.3032 96.4663 17.0525ZM108.626 12.1388H106.463V21.9662H108.626V17.1311C108.626 15.0281 109.726 13.9077 111.161 13.9077C112.419 13.9077 113.205 14.8512 113.205 16.4039V21.9662H115.367V16.0501C115.367 13.5539 113.893 11.9422 111.613 11.9422C110.335 11.9422 109.215 12.4926 108.626 13.4753V12.1388ZM117.839 12.1388H120.001V13.4753C120.59 12.4926 121.711 11.9422 122.988 11.9422C125.268 11.9422 126.742 13.5539 126.742 16.0501V21.9662H124.58V16.4039C124.58 14.8512 123.794 13.9077 122.536 13.9077C121.101 13.9077 120.001 15.0281 120.001 17.1311V21.9662H117.839V12.1388ZM133.558 22.1628C136.054 22.1628 137.823 20.728 138.373 18.8804H136.113C135.661 19.8238 134.717 20.2563 133.636 20.2563C131.887 20.2563 130.747 19.077 130.668 17.5832H138.491C138.688 14.2419 136.585 11.9422 133.577 11.9422C130.551 11.9422 128.526 14.1436 128.526 17.0525C128.526 20.0007 130.629 22.1628 133.558 22.1628ZM130.747 16.0501C131.042 14.5367 132.162 13.7505 133.518 13.7505C134.717 13.7505 135.838 14.4581 136.172 16.0501H130.747ZM149.851 18.3694C149.32 20.5511 147.453 22.1628 144.859 22.1628C141.871 22.1628 139.709 19.8828 139.709 17.0525C139.709 14.2222 141.871 11.9422 144.859 11.9422C147.453 11.9422 149.32 13.5539 149.851 15.7356H147.571C147.178 14.6743 146.215 13.9077 144.859 13.9077C143.109 13.9077 141.91 15.2246 141.91 17.0525C141.91 18.8804 143.109 20.1973 144.859 20.1973C146.215 20.1973 147.178 19.4307 147.571 18.3694H149.851ZM155.75 22.0645C156.418 22.0645 156.929 21.9859 157.362 21.8483V19.9221C157.047 20.0401 156.615 20.1187 156.202 20.1187C155.082 20.1187 154.551 19.6666 154.551 18.448V14.065H157.362V12.1388H154.551V9.40675H152.389V12.1388H150.345V14.065H152.389V18.8018C152.389 21.0228 153.863 22.0645 155.75 22.0645Z\">`);\nconst TonConnectBrand = () => {\n  const theme = useTheme();\n  const fill = () => theme.theme === THEME.DARK ? theme.colors.constant.white : theme.colors.constant.black;\n  return (() => {\n    var _el$ = _tmpl$$m(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling, _el$4 = _el$3.nextSibling;\n    createRenderEffect(() => setAttribute(_el$4, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$l = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M5.56608 4.42584C5.82527 3.32158 6.8176 2.5 8.00001 2.5C9.38072 2.5 10.5 3.61929 10.5 5C10.5 5.63026 10.3391 6.0386 10.1264 6.34455C9.90018 6.66993 9.58561 6.92478 9.18864 7.20877C9.12579 7.25372 9.05873 7.30025 8.9887 7.34883C8.27392 7.84472 7.25001 8.55507 7.25001 10V10.25C7.25001 10.6642 7.5858 11 8.00001 11C8.41422 11 8.75001 10.6642 8.75001 10.25V10C8.75001 9.36502 9.10777 9.1096 9.94554 8.51149L10.0614 8.42873C10.4769 8.13147 10.9748 7.75194 11.358 7.20076C11.7547 6.63015 12 5.91973 12 5C12 2.79086 10.2091 1 8.00001 1C6.10564 1 4.5205 2.31615 4.10577 4.08308C4.01112 4.48634 4.26129 4.88997 4.66454 4.98462C5.0678 5.07927 5.47143 4.8291 5.56608 4.42584ZM8.00001 15C8.60752 15 9.10001 14.5075 9.10001 13.9C9.10001 13.2925 8.60752 12.8 8.00001 12.8C7.39249 12.8 6.90001 13.2925 6.90001 13.9C6.90001 14.5075 7.39249 15 8.00001 15Z\">`);\nconst QuestionIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    var _el$ = _tmpl$$l(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$k = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M9.98156 8.75C9.84854 11.4328 9.01206 13.5 8 13.5C6.98794 13.5 6.15146 11.4328 6.01844 8.75H9.98156ZM11.4832 8.75C11.4217 10.1155 11.1929 11.3869 10.8239 12.4017C10.7734 12.5405 10.7188 12.6789 10.6595 12.8154C12.1454 11.993 13.2103 10.5029 13.4493 8.75H11.4832ZM13.4493 7.25H11.4832C11.4217 5.88453 11.1929 4.61314 10.8239 3.5983C10.7734 3.4595 10.7188 3.32111 10.6595 3.18459C12.1454 4.00697 13.2103 5.49709 13.4493 7.25ZM9.98156 7.25H6.01844C6.15144 4.56764 6.98769 2.50062 7.99955 2.5H8C9.01206 2.5 9.84854 4.56724 9.98156 7.25ZM4.51678 7.25C4.57826 5.88453 4.80706 4.61314 5.1761 3.5983C5.22657 3.4595 5.28124 3.32111 5.3405 3.18459C3.85463 4.00697 2.78972 5.49709 2.55071 7.25H4.51678ZM2.55071 8.75C2.78972 10.5029 3.85463 11.993 5.3405 12.8154C5.28124 12.6789 5.22657 12.5405 5.1761 12.4017C4.80706 11.3869 4.57826 10.1155 4.51678 8.75H2.55071ZM15 8C15 11.866 11.866 15 8 15C4.13401 15 1 11.866 1 8C1 4.13401 4.13401 1 8 1C11.866 1 15 4.13401 15 8Z\">`);\nconst BrowserIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.primary;\n  return (() => {\n    var _el$ = _tmpl$$k(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$j = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M2.5 4.8C2.5 3.11984 2.5 2.27976 2.82698 1.63803C3.1146 1.07354 3.57354 0.614601 4.13803 0.32698C4.77976 0 5.61984 0 7.3 0H8.7C10.3802 0 11.2202 0 11.862 0.32698C12.4265 0.614601 12.8854 1.07354 13.173 1.63803C13.5 2.27976 13.5 3.11984 13.5 4.8V11.2C13.5 12.8802 13.5 13.7202 13.173 14.362C12.8854 14.9265 12.4265 15.3854 11.862 15.673C11.2202 16 10.3802 16 8.7 16H7.3C5.61984 16 4.77976 16 4.13803 15.673C3.57354 15.3854 3.1146 14.9265 2.82698 14.362C2.5 13.7202 2.5 12.8802 2.5 11.2V4.8ZM4 3.9C4 3.05992 4 2.63988 4.16349 2.31901C4.3073 2.03677 4.53677 1.8073 4.81901 1.66349C5.13988 1.5 5.55992 1.5 6.4 1.5H9.6C10.4401 1.5 10.8601 1.5 11.181 1.66349C11.4632 1.8073 11.6927 2.03677 11.8365 2.31901C12 2.63988 12 3.05992 12 3.9V12.1C12 12.9401 12 13.3601 11.8365 13.681C11.6927 13.9632 11.4632 14.1927 11.181 14.3365C10.8601 14.5 10.4401 14.5 9.6 14.5H6.4C5.55992 14.5 5.13988 14.5 4.81901 14.3365C4.53677 14.1927 4.3073 13.9632 4.16349 13.681C4 13.3601 4 12.9401 4 12.1V3.9ZM7 2.5C6.58579 2.5 6.25 2.83579 6.25 3.25C6.25 3.66421 6.58579 4 7 4H9C9.41421 4 9.75 3.66421 9.75 3.25C9.75 2.83579 9.41421 2.5 9 2.5H7Z\">`);\nconst MobileIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.primary;\n  return (() => {\n    var _el$ = _tmpl$$j(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$i = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M1.5 6.8C1.5 5.11984 1.5 4.27976 1.82698 3.63803C2.1146 3.07354 2.57354 2.6146 3.13803 2.32698C3.77976 2 4.61984 2 6.3 2H9.7C11.3802 2 12.2202 2 12.862 2.32698C13.4265 2.6146 13.8854 3.07354 14.173 3.63803C14.5 4.27976 14.5 5.11984 14.5 6.8V11.5H15.25C15.6642 11.5 16 11.8358 16 12.25C16 12.6642 15.6642 13 15.25 13H0.75C0.335786 13 0 12.6642 0 12.25C0 11.8358 0.335786 11.5 0.75 11.5H1.5V6.8ZM3 11.5H13V5.9C13 5.05992 13 4.63988 12.8365 4.31901C12.6927 4.03677 12.4632 3.8073 12.181 3.66349C11.8601 3.5 11.4401 3.5 10.6 3.5H5.4C4.55992 3.5 4.13988 3.5 3.81901 3.66349C3.53677 3.8073 3.3073 4.03677 3.16349 4.31901C3 4.63988 3 5.05992 3 5.9V11.5Z\">`);\nconst DesktopIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.primary;\n  return (() => {\n    var _el$ = _tmpl$$i(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$h = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=17 height=16 viewBox=\"0 0 17 16\"fill=none><g clip-path=url(#clip0_3676_1603)><path fill-rule=evenodd clip-rule=evenodd d=\"M15.5 1.25049C15.5 0.836275 15.1642 0.500488 14.75 0.500488C14.3358 0.500488 14 0.836275 14 1.25049V3.67012C12.7187 2.04487 10.7318 1.00049 8.5 1.00049C4.63401 1.00049 1.5 4.1345 1.5 8.00049C1.5 11.8665 4.63401 15.0005 8.5 15.0005C11.6844 15.0005 14.3703 12.8748 15.2199 9.96661C15.3361 9.56902 15.1079 9.15254 14.7103 9.03638C14.3127 8.92023 13.8962 9.14838 13.7801 9.54597C13.1123 11.8319 11 13.5005 8.5 13.5005C5.46243 13.5005 3 11.0381 3 8.00049C3 4.96292 5.46243 2.50049 8.5 2.50049C10.321 2.50049 11.9363 3.3855 12.9377 4.75049H10.5C10.0858 4.75049 9.75 5.08627 9.75 5.50049C9.75 5.9147 10.0858 6.25049 10.5 6.25049H14.75C15.1642 6.25049 15.5 5.9147 15.5 5.50049V1.25049Z\"></path></g><defs><clipPath id=clip0_3676_1603><rect width=16 height=16 fill=white transform=\"translate(0.5 0.000488281)\">`);\nconst RetryIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.accent;\n  return (() => {\n    var _el$ = _tmpl$$h(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild;\n    createRenderEffect(() => setAttribute(_el$3, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$g = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M13 4.06119V6.75053C13 7.16474 13.3358 7.50053 13.75 7.50053C14.1642 7.50053 14.5 7.16474 14.5 6.75053V2.75053L14.5 2.72807C14.5001 2.63191 14.5003 2.49627 14.4842 2.37627C14.4638 2.22503 14.4063 1.99261 14.2071 1.79342C14.0079 1.59423 13.7755 1.5367 13.6243 1.51637C13.5043 1.50023 13.3686 1.50039 13.2725 1.50051L13.25 1.50053H9.25C8.83579 1.50053 8.5 1.83631 8.5 2.25053C8.5 2.66474 8.83579 3.00053 9.25 3.00053H11.9393L7.21967 7.7202C6.92678 8.01309 6.92678 8.48796 7.21967 8.78086C7.51256 9.07375 7.98744 9.07375 8.28033 8.78086L13 4.06119ZM5.85 1.50053H5.81903H5.81899C5.21528 1.50052 4.71702 1.50051 4.31113 1.53367C3.88956 1.56812 3.50203 1.64204 3.13803 1.82751C2.57354 2.11513 2.1146 2.57407 1.82698 3.13856C1.64151 3.50256 1.56759 3.89009 1.53315 4.31166C1.49998 4.71755 1.49999 5.21581 1.5 5.81953V5.81955V5.85053V10.1505V10.1815V10.1815C1.49999 10.7852 1.49998 11.2835 1.53315 11.6894C1.56759 12.111 1.64151 12.4985 1.82698 12.8625C2.1146 13.427 2.57354 13.8859 3.13803 14.1735C3.50203 14.359 3.88956 14.4329 4.31113 14.4674C4.71702 14.5005 5.21527 14.5005 5.81897 14.5005H5.81901H5.85H10.15H10.181H10.181C10.7847 14.5005 11.283 14.5005 11.6889 14.4674C12.1104 14.4329 12.498 14.359 12.862 14.1735C13.4265 13.8859 13.8854 13.427 14.173 12.8625C14.3585 12.4985 14.4324 12.111 14.4669 11.6894C14.5 11.2835 14.5 10.7853 14.5 10.1816V10.1815V10.1505V9.75053C14.5 9.33631 14.1642 9.00053 13.75 9.00053C13.3358 9.00053 13 9.33631 13 9.75053V10.1505C13 10.793 12.9994 11.2297 12.9718 11.5672C12.945 11.8961 12.8963 12.0642 12.8365 12.1815C12.6927 12.4638 12.4632 12.6932 12.181 12.837C12.0637 12.8968 11.8955 12.9455 11.5667 12.9724C11.2292 12.9999 10.7924 13.0005 10.15 13.0005H5.85C5.20757 13.0005 4.77085 12.9999 4.43328 12.9724C4.10447 12.9455 3.93632 12.8968 3.81902 12.837C3.53677 12.6932 3.3073 12.4638 3.16349 12.1815C3.10372 12.0642 3.05503 11.8961 3.02816 11.5672C3.00058 11.2297 3 10.793 3 10.1505V5.85053C3 5.20809 3.00058 4.77137 3.02816 4.43381C3.05503 4.10499 3.10372 3.93684 3.16349 3.81954C3.3073 3.5373 3.53677 3.30783 3.81902 3.16402C3.93632 3.10425 4.10447 3.05556 4.43328 3.02869C4.77085 3.00111 5.20757 3.00053 5.85 3.00053H6.25C6.66422 3.00053 7 2.66474 7 2.25053C7 1.83631 6.66422 1.50053 6.25 1.50053H5.85Z\">`);\nconst LinkIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.accent;\n  return (() => {\n    var _el$ = _tmpl$$g(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$f = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=17 height=16 viewBox=\"0 0 17 16\"fill=none><g clip-path=url(#clip0_3676_1274)><path fill-rule=evenodd clip-rule=evenodd d=\"M1.82698 2.63901C1.5 3.28074 1.5 4.12082 1.5 5.80098V8.80098V9.00098V10.201C1.5 11.8811 1.5 12.7212 1.82698 13.3629C2.1146 13.9274 2.57354 14.3864 3.13803 14.674C3.77976 15.001 4.61984 15.001 6.3 15.001H11.7C13.3802 15.001 14.2202 15.001 14.862 14.674C15.4265 14.3864 15.8854 13.9274 16.173 13.3629C16.5 12.7212 16.5 11.8811 16.5 10.201V8.80098C16.5 7.12082 16.5 6.28074 16.173 5.63901C15.8854 5.07452 15.4265 4.61558 14.862 4.32796C14.743 4.26733 14.6172 4.21795 14.4805 4.17772C14.4501 3.49449 14.3722 3.02994 14.173 2.63901C13.8854 2.07452 13.4265 1.61558 12.862 1.32796C12.2202 1.00098 11.3802 1.00098 9.7 1.00098H6.3C4.61984 1.00098 3.77976 1.00098 3.13803 1.32796C2.57354 1.61558 2.1146 2.07452 1.82698 2.63901ZM12.9861 4.00942C12.9684 3.7108 12.9281 3.49982 12.8365 3.31999C12.6927 3.03775 12.4632 2.80828 12.181 2.66447C11.8601 2.50098 11.4401 2.50098 10.6 2.50098H5.4C4.55992 2.50098 4.13988 2.50098 3.81901 2.66447C3.53677 2.80828 3.3073 3.03775 3.16349 3.31999C3.03615 3.56991 3.00799 3.88 3.00177 4.40188C3.04646 4.37612 3.09189 4.35146 3.13803 4.32796C3.77976 4.00098 4.61984 4.00098 6.3 4.00098H11.7C12.1966 4.00098 12.6197 4.00098 12.9861 4.00942ZM3 7.90098V8.10098C3 8.47468 3 8.76527 3.01439 9.00098H3V11.101C3 11.9411 3 12.3611 3.16349 12.682C3.3073 12.9642 3.53677 13.1937 3.81901 13.3375C4.13988 13.501 4.55992 13.501 5.4 13.501H12.6C13.4401 13.501 13.8601 13.501 14.181 13.3375C14.4632 13.1937 14.6927 12.9642 14.8365 12.682C15 12.3611 15 11.9411 15 11.101V7.90098C15 7.0609 15 6.64086 14.8365 6.31999C14.6927 6.03775 14.4632 5.80828 14.181 5.66447C13.8601 5.50098 13.4401 5.50098 12.6 5.50098H5.4C4.55992 5.50098 4.13988 5.50098 3.81901 5.66447C3.53677 5.80828 3.3073 6.03775 3.16349 6.31999C3 6.64086 3 7.0609 3 7.90098ZM10.5 9.75098C10.5 9.33676 10.8358 9.00098 11.25 9.00098H12.75C13.1642 9.00098 13.5 9.33676 13.5 9.75098C13.5 10.1652 13.1642 10.501 12.75 10.501H11.25C10.8358 10.501 10.5 10.1652 10.5 9.75098Z\"></path></g><defs><clipPath id=clip0_3676_1274><rect width=16 height=16 fill=white transform=\"translate(0.5 0.000976562)\">`);\nconst WalletIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.accent;\n  return (() => {\n    var _el$ = _tmpl$$f(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild;\n    createRenderEffect(() => setAttribute(_el$3, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$e = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=48 height=48 viewBox=\"0 0 48 48\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M39.6319 16.8719C38.3212 16.2041 36.7002 16.0478 34 16.0112V11C34 5.47715 29.5228 1 24 1C18.4772 1 14 5.47715 14 11V16.0112C11.2998 16.0478 9.6788 16.2041 8.36808 16.8719C6.86278 17.6389 5.63893 18.8628 4.87195 20.3681C4 22.0794 4 24.3196 4 28.8V32.2C4 36.6804 4 38.9206 4.87195 40.6319C5.63893 42.1372 6.86278 43.3611 8.36808 44.1281C10.0794 45 12.3196 45 16.8 45H31.2C35.6804 45 37.9206 45 39.6319 44.1281C41.1372 43.3611 42.3611 42.1372 43.1281 40.6319C44 38.9206 44 36.6804 44 32.2V28.8C44 24.3196 44 22.0794 43.1281 20.3681C42.3611 18.8628 41.1372 17.6389 39.6319 16.8719ZM31 11V16H17V11C17 7.13401 20.134 4 24 4C27.866 4 31 7.13401 31 11ZM7.54497 21.73C7 22.7996 7 24.1997 7 27V34C7 36.8003 7 38.2004 7.54497 39.27C8.02433 40.2108 8.78924 40.9757 9.73005 41.455C10.7996 42 12.1997 42 15 42H33C35.8003 42 37.2004 42 38.27 41.455C39.2108 40.9757 39.9757 40.2108 40.455 39.27C41 38.2004 41 36.8003 41 34V27C41 24.1997 41 22.7996 40.455 21.73C39.9757 20.7892 39.2108 20.0243 38.27 19.545C37.2004 19 35.8003 19 33 19H15C12.1997 19 10.7996 19 9.73005 19.545C8.78924 20.0243 8.02433 20.7892 7.54497 21.73ZM24 24C23.1716 24 22.5 24.6716 22.5 25.5V29.5C22.5 30.3284 23.1716 31 24 31C24.8284 31 25.5 30.3284 25.5 29.5V25.5C25.5 24.6716 24.8284 24 24 24Z\">`);\nconst SecurityIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    var _el$ = _tmpl$$e(), _el$2 = _el$.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = props.class, _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })();\n};\nvar _tmpl$$d = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=48 height=48 viewBox=\"0 0 48 48\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M37.485 37.3849C40.894 33.9506 43 29.2212 43 24C43 13.5066 34.4934 5 24 5C13.5066 5 5 13.5066 5 24C5 29.2213 7.1061 33.9507 10.5151 37.385C13.3583 32.9438 18.3354 30 24.0001 30C29.6647 30 34.6418 32.9437 37.485 37.3849ZM35.1809 39.3635C32.9143 35.5532 28.7554 33 24.0001 33C19.2448 33 15.0858 35.5533 12.8193 39.3636C15.9564 41.6506 19.8206 43 24 43C28.1795 43 32.0437 41.6505 35.1809 39.3635ZM24 46C36.1503 46 46 36.1503 46 24C46 11.8497 36.1503 2 24 2C11.8497 2 2 11.8497 2 24C2 36.1503 11.8497 46 24 46ZM24 24C26.7614 24 29 21.7614 29 19C29 16.2386 26.7614 14 24 14C21.2386 14 19 16.2386 19 19C19 21.7614 21.2386 24 24 24ZM24 27C28.4183 27 32 23.4183 32 19C32 14.5817 28.4183 11 24 11C19.5817 11 16 14.5817 16 19C16 23.4183 19.5817 27 24 27Z\">`);\nconst PersonalityIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    var _el$ = _tmpl$$d(), _el$2 = _el$.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = props.class, _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })();\n};\nvar _tmpl$$c = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=48 height=48 viewBox=\"0 0 48 48\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M34.5607 4.43934C33.9749 3.85355 33.0251 3.85355 32.4393 4.43934C31.8536 5.02513 31.8536 5.97487 32.4393 6.56066L37.8787 12H10.5C9.67157 12 9 12.6716 9 13.5C9 14.3284 9.67157 15 10.5 15H37.8787L32.4393 20.4393C31.8536 21.0251 31.8536 21.9749 32.4393 22.5607C33.0251 23.1464 33.9749 23.1464 34.5607 22.5607L42.5607 14.5607C43.1464 13.9749 43.1464 13.0251 42.5607 12.4393L34.5607 4.43934ZM13.4393 25.4393C14.0251 24.8536 14.9749 24.8536 15.5607 25.4393C16.1464 26.0251 16.1464 26.9749 15.5607 27.5607L10.1213 33H37.5C38.3284 33 39 33.6716 39 34.5C39 35.3284 38.3284 36 37.5 36H10.1213L15.5607 41.4393C16.1464 42.0251 16.1464 42.9749 15.5607 43.5607C14.9749 44.1464 14.0251 44.1464 13.4393 43.5607L5.43934 35.5607C4.85355 34.9749 4.85355 34.0251 5.43934 33.4393L13.4393 25.4393Z\">`);\nconst SwapIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    var _el$ = _tmpl$$c(), _el$2 = _el$.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = props.class, _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })();\n};\nvar _tmpl$$b = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=28 height=28 viewBox=\"0 0 28 28\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M1.75 12.002C1.75 9.20169 1.75 7.80156 2.29497 6.732C2.77433 5.79119 3.53924 5.02629 4.48005 4.54692C5.54961 4.00195 6.94974 4.00195 9.75 4.00195H17.25C20.0503 4.00195 21.4504 4.00195 22.52 4.54692C23.4608 5.02629 24.2257 5.79119 24.705 6.732C24.8256 6.96861 24.9195 7.2214 24.9926 7.50195H21.5C19.6377 7.50195 18.7065 7.50195 17.9609 7.77334C16.711 8.22828 15.7263 9.21291 15.2714 10.4629C15 11.2085 15 12.1396 15 14.002C15 15.8643 15 16.7954 15.2714 17.541C15.7263 18.791 16.711 19.7756 17.9609 20.2306C18.7065 20.502 19.6377 20.502 21.5 20.502H24.9926C24.9195 20.7825 24.8256 21.0353 24.705 21.2719C24.2257 22.2127 23.4608 22.9776 22.52 23.457C21.4504 24.002 20.0503 24.002 17.25 24.002H9.75C6.94974 24.002 5.54961 24.002 4.48005 23.457C3.53924 22.9776 2.77433 22.2127 2.29497 21.2719C1.75 20.2023 1.75 18.8022 1.75 16.002V12.002ZM16.4999 13.802C16.4999 12.1218 16.4999 11.2817 16.8269 10.64C17.1145 10.0755 17.5735 9.61656 18.138 9.32894C18.7797 9.00196 19.6198 9.00196 21.2999 9.00196H23.1999C24.8801 9.00196 25.7202 9.00196 26.3619 9.32894C26.9264 9.61656 27.3853 10.0755 27.673 10.64C27.9999 11.2817 27.9999 12.1218 27.9999 13.802V14.202C27.9999 15.8821 27.9999 16.7222 27.673 17.3639C27.3853 17.9284 26.9264 18.3874 26.3619 18.675C25.7202 19.002 24.8801 19.002 23.1999 19.002H21.2999C19.6198 19.002 18.7797 19.002 18.138 18.675C17.5735 18.3874 17.1145 17.9284 16.8269 17.3639C16.4999 16.7222 16.4999 15.8821 16.4999 14.202V13.802ZM22.4999 14.002C22.4999 14.9685 21.7164 15.752 20.7499 15.752C19.7834 15.752 18.9999 14.9685 18.9999 14.002C18.9999 13.0355 19.7834 12.252 20.7499 12.252C21.7164 12.252 22.4999 13.0355 22.4999 14.002Z\">`);\nconst AtWalletIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.constant.white;\n  return (() => {\n    var _el$ = _tmpl$$b(), _el$2 = _el$.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = props.class, _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })();\n};\nvar _tmpl$$a = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=28 height=28 viewBox=\"0 0 28 28\"><path fill-rule=evenodd clip-rule=evenodd d=\"M10.0001 10.0001C10.0016 8.02333 10.0267 6.98719 10.436 6.18404C10.8195 5.43139 11.4314 4.81947 12.184 4.43597C13.0397 4 14.1598 4 16.4 4H17.6C19.8402 4 20.9603 4 21.816 4.43597C22.5686 4.81947 23.1805 5.43139 23.564 6.18404C24 7.03969 24 8.15979 24 10.4V11.6C24 13.8402 24 14.9603 23.564 15.816C23.1805 16.5686 22.5686 17.1805 21.816 17.564C21.0128 17.9733 19.9767 17.9984 17.9999 17.9999C17.9984 19.9767 17.9733 21.0128 17.564 21.816C17.1805 22.5686 16.5686 23.1805 15.816 23.564C14.9603 24 13.8402 24 11.6 24H10.4C8.15979 24 7.03969 24 6.18404 23.564C5.43139 23.1805 4.81947 22.5686 4.43597 21.816C4 20.9603 4 19.8402 4 17.6V16.4C4 14.1598 4 13.0397 4.43597 12.184C4.81947 11.4314 5.43139 10.8195 6.18404 10.436C6.98719 10.0267 8.02333 10.0016 10.0001 10.0001ZM10 11.5H9.5C8.09987 11.5 7.3998 11.5 6.86502 11.7725C6.39462 12.0122 6.01217 12.3946 5.77248 12.865C5.5 13.3998 5.5 14.0999 5.5 15.5V18.5C5.5 19.9001 5.5 20.6002 5.77248 21.135C6.01217 21.6054 6.39462 21.9878 6.86502 22.2275C7.3998 22.5 8.09987 22.5 9.5 22.5H12.5C13.9001 22.5 14.6002 22.5 15.135 22.2275C15.6054 21.9878 15.9878 21.6054 16.2275 21.135C16.5 20.6002 16.5 19.9001 16.5 18.5V18H16.4C14.1598 18 13.0397 18 12.184 17.564C11.4314 17.1805 10.8195 16.5686 10.436 15.816C10 14.9603 10 13.8402 10 11.6V11.5ZM11.5 9.5C11.5 8.09987 11.5 7.3998 11.7725 6.86502C12.0122 6.39462 12.3946 6.01217 12.865 5.77248C13.3998 5.5 14.0999 5.5 15.5 5.5H18.5C19.9001 5.5 20.6002 5.5 21.135 5.77248C21.6054 6.01217 21.9878 6.39462 22.2275 6.86502C22.5 7.3998 22.5 8.09987 22.5 9.5V12.5C22.5 13.9001 22.5 14.6002 22.2275 15.135C21.9878 15.6054 21.6054 15.9878 21.135 16.2275C20.6002 16.5 19.9001 16.5 18.5 16.5H15.5C14.0999 16.5 13.3998 16.5 12.865 16.2275C12.3946 15.9878 12.0122 15.6054 11.7725 15.135C11.5 14.6002 11.5 13.9001 11.5 12.5V9.5Z\">`);\nconst CopyLightIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    var _el$ = _tmpl$$a(), _el$2 = _el$.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = fill(), _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$, \"fill\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })();\n};\nvar _tmpl$$9 = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=17 viewBox=\"0 0 16 17\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M1 4.12695C1 3.07754 1 2.55284 1.19202 2.14684C1.38986 1.72856 1.7266 1.39181 2.14489 1.19397C2.55088 1.00195 3.07559 1.00195 4.125 1.00195C5.17441 1.00195 5.69912 1.00195 6.10511 1.19397C6.5234 1.39181 6.86014 1.72856 7.05798 2.14684C7.25 2.55284 7.25 3.07754 7.25 4.12695C7.25 5.17636 7.25 5.70107 7.05798 6.10706C6.86014 6.52535 6.5234 6.8621 6.10511 7.05993C5.69912 7.25195 5.17441 7.25195 4.125 7.25195C3.07559 7.25195 2.55088 7.25195 2.14489 7.05993C1.7266 6.8621 1.38986 6.52535 1.19202 6.10706C1 5.70107 1 5.17636 1 4.12695ZM2.5 3.30195C2.5 3.02193 2.5 2.88191 2.5545 2.77496C2.60243 2.68088 2.67892 2.60439 2.773 2.55645C2.87996 2.50195 3.01997 2.50195 3.3 2.50195H4.95C5.23003 2.50195 5.37004 2.50195 5.477 2.55645C5.57108 2.60439 5.64757 2.68088 5.6955 2.77496C5.75 2.88191 5.75 3.02193 5.75 3.30195V4.95195C5.75 5.23198 5.75 5.37199 5.6955 5.47895C5.64757 5.57303 5.57108 5.64952 5.477 5.69746C5.37004 5.75195 5.23003 5.75195 4.95 5.75195H3.3C3.01997 5.75195 2.87996 5.75195 2.773 5.69746C2.67892 5.64952 2.60243 5.57303 2.5545 5.47895C2.5 5.37199 2.5 5.23198 2.5 4.95195V3.30195ZM1 11.877C1 10.8275 1 10.3028 1.19202 9.89684C1.38986 9.47856 1.7266 9.14181 2.14489 8.94397C2.55088 8.75195 3.07559 8.75195 4.125 8.75195C5.17441 8.75195 5.69912 8.75195 6.10511 8.94397C6.5234 9.14181 6.86014 9.47856 7.05798 9.89684C7.25 10.3028 7.25 10.8275 7.25 11.877C7.25 12.9264 7.25 13.4511 7.05798 13.8571C6.86014 14.2753 6.5234 14.6121 6.10511 14.8099C5.69912 15.002 5.17441 15.002 4.125 15.002C3.07559 15.002 2.55088 15.002 2.14489 14.8099C1.7266 14.6121 1.38986 14.2753 1.19202 13.8571C1 13.4511 1 12.9264 1 11.877ZM2.5 11.052C2.5 10.7719 2.5 10.6319 2.5545 10.525C2.60243 10.4309 2.67892 10.3544 2.773 10.3064C2.87996 10.252 3.01997 10.252 3.3 10.252H4.95C5.23003 10.252 5.37004 10.252 5.477 10.3064C5.57108 10.3544 5.64757 10.4309 5.6955 10.525C5.75 10.6319 5.75 10.7719 5.75 11.052V12.702C5.75 12.982 5.75 13.122 5.6955 13.2289C5.64757 13.323 5.57108 13.3995 5.477 13.4475C5.37004 13.502 5.23003 13.502 4.95 13.502H3.3C3.01997 13.502 2.87996 13.502 2.773 13.4475C2.67892 13.3995 2.60243 13.323 2.5545 13.2289C2.5 13.122 2.5 12.982 2.5 12.702V11.052ZM8.94202 2.14684C8.75 2.55284 8.75 3.07754 8.75 4.12695C8.75 5.17636 8.75 5.70107 8.94202 6.10706C9.13986 6.52535 9.4766 6.8621 9.89489 7.05993C10.3009 7.25195 10.8256 7.25195 11.875 7.25195C12.9244 7.25195 13.4491 7.25195 13.8551 7.05993C14.2734 6.8621 14.6101 6.52535 14.808 6.10706C15 5.70107 15 5.17636 15 4.12695C15 3.07754 15 2.55284 14.808 2.14684C14.6101 1.72856 14.2734 1.39181 13.8551 1.19397C13.4491 1.00195 12.9244 1.00195 11.875 1.00195C10.8256 1.00195 10.3009 1.00195 9.89489 1.19397C9.4766 1.39181 9.13986 1.72856 8.94202 2.14684ZM10.3045 2.77496C10.25 2.88191 10.25 3.02193 10.25 3.30195V4.95195C10.25 5.23198 10.25 5.37199 10.3045 5.47895C10.3524 5.57303 10.4289 5.64952 10.523 5.69746C10.63 5.75195 10.77 5.75195 11.05 5.75195H12.7C12.98 5.75195 13.12 5.75195 13.227 5.69746C13.3211 5.64952 13.3976 5.57303 13.4455 5.47895C13.5 5.37199 13.5 5.23198 13.5 4.95195V3.30195C13.5 3.02193 13.5 2.88191 13.4455 2.77496C13.3976 2.68088 13.3211 2.60439 13.227 2.55645C13.12 2.50195 12.98 2.50195 12.7 2.50195H11.05C10.77 2.50195 10.63 2.50195 10.523 2.55645C10.4289 2.60439 10.3524 2.68088 10.3045 2.77496ZM8.80727 9.13518C8.75 9.26242 8.75 9.4256 8.75 9.75195C8.75 10.0783 8.75 10.2415 8.80727 10.3687C8.87245 10.5136 8.9884 10.6295 9.13323 10.6947C9.26047 10.752 9.42365 10.752 9.75 10.752C10.0764 10.752 10.2395 10.752 10.3668 10.6947C10.5116 10.6295 10.6276 10.5136 10.6927 10.3687C10.75 10.2415 10.75 10.0783 10.75 9.75195C10.75 9.4256 10.75 9.26242 10.6927 9.13518C10.6276 8.99035 10.5116 8.8744 10.3668 8.80922C10.2395 8.75195 10.0764 8.75195 9.75 8.75195C9.42365 8.75195 9.26047 8.75195 9.13323 8.80922C8.9884 8.8744 8.87245 8.99035 8.80727 9.13518ZM10.87 11.8771C10.87 11.546 10.87 11.3805 10.9289 11.2517C10.9938 11.1098 11.1077 10.9959 11.2497 10.931C11.3784 10.8721 11.5439 10.8721 11.875 10.8721C12.2061 10.8721 12.3716 10.8721 12.5003 10.931C12.6423 10.9959 12.7562 11.1098 12.8211 11.2517C12.88 11.3805 12.88 11.546 12.88 11.8771C12.88 12.2081 12.88 12.3737 12.8211 12.5024C12.7562 12.6444 12.6423 12.7583 12.5003 12.8232C12.3716 12.8821 12.2061 12.8821 11.875 12.8821C11.5439 12.8821 11.3784 12.8821 11.2497 12.8232C11.1077 12.7583 10.9938 12.6444 10.9289 12.5024C10.87 12.3737 10.87 12.2081 10.87 11.8771ZM8.80727 13.3852C8.75 13.5124 8.75 13.6756 8.75 14.002C8.75 14.3283 8.75 14.4915 8.80727 14.6187C8.87245 14.7636 8.9884 14.8795 9.13323 14.9447C9.26047 15.002 9.42365 15.002 9.75 15.002C10.0764 15.002 10.2395 15.002 10.3668 14.9447C10.5116 14.8795 10.6276 14.7636 10.6927 14.6187C10.75 14.4915 10.75 14.3283 10.75 14.002C10.75 13.6756 10.75 13.5124 10.6927 13.3852C10.6276 13.2404 10.5116 13.1244 10.3668 13.0592C10.2395 13.002 10.0764 13.002 9.75 13.002C9.42365 13.002 9.26047 13.002 9.13323 13.0592C8.9884 13.1244 8.87245 13.2404 8.80727 13.3852ZM13 9.75195C13 9.4256 13 9.26242 13.0573 9.13518C13.1224 8.99035 13.2384 8.8744 13.3832 8.80922C13.5105 8.75195 13.6736 8.75195 14 8.75195C14.3264 8.75195 14.4895 8.75195 14.6168 8.80922C14.7616 8.8744 14.8776 8.99035 14.9427 9.13518C15 9.26242 15 9.4256 15 9.75195C15 10.0783 15 10.2415 14.9427 10.3687C14.8776 10.5136 14.7616 10.6295 14.6168 10.6947C14.4895 10.752 14.3264 10.752 14 10.752C13.6736 10.752 13.5105 10.752 13.3832 10.6947C13.2384 10.6295 13.1224 10.5136 13.0573 10.3687C13 10.2415 13 10.0783 13 9.75195ZM13.0573 13.3852C13 13.5124 13 13.6756 13 14.002C13 14.3283 13 14.4915 13.0573 14.6187C13.1224 14.7636 13.2384 14.8795 13.3832 14.9447C13.5105 15.002 13.6736 15.002 14 15.002C14.3264 15.002 14.4895 15.002 14.6168 14.9447C14.7616 14.8795 14.8776 14.7636 14.9427 14.6187C15 14.4915 15 14.3283 15 14.002C15 13.6756 15 13.5124 14.9427 13.3852C14.8776 13.2404 14.7616 13.1244 14.6168 13.0592C14.4895 13.002 14.3264 13.002 14 13.002C13.6736 13.002 13.5105 13.002 13.3832 13.0592C13.2384 13.1244 13.1224 13.2404 13.0573 13.3852Z\">`);\nconst QRIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    var _el$ = _tmpl$$9(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nconst containerBorders = {\n  m: \"16px\",\n  s: \"12px\",\n  none: \"0\"\n};\nconst walletBorders = {\n  m: \"6px\",\n  s: \"6px\",\n  none: \"0\"\n};\nconst FourWalletsCard = styled.div`\n    width: 60px;\n    height: 60px;\n    padding: 8px;\n    margin-bottom: 8px;\n    border-radius: ${(props) => containerBorders[props.theme.borderRadius]};\n    background-color: ${(props) => props.theme.colors.background.tint};\n    display: grid;\n    grid-template: 1fr 1fr / 1fr 1fr;\n    gap: 4px;\n`;\nconst FourWalletsImage = styled(WalletImage)`\n    width: 20px;\n    height: 20px;\n    border-radius: ${(props) => walletBorders[props.theme.borderRadius]};\n`;\nconst FourWalletsItem = (props) => {\n  return createComponent(WalletItem, {\n    get name() {\n      return props.labelLine1;\n    },\n    get secondLine() {\n      return props.labelLine2;\n    },\n    get icon() {\n      return createComponent(FourWalletsCard, {\n        get children() {\n          return createComponent(For, {\n            each: [0, 1, 2, 3],\n            children: (index) => createComponent(FourWalletsImage, {\n              get src() {\n                return props.images[index];\n              }\n            })\n          });\n        }\n      });\n    },\n    onClick: () => props.onClick()\n  });\n};\nconst AT_WALLET_APP_NAME = \"telegram-wallet\";\nconst IMG = {\n  TON: \"https://raw.githubusercontent.com/ton-connect/sdk/main/assets/ton-icon-48.png\",\n  TG: \"https://raw.githubusercontent.com/ton-connect/sdk/main/assets/tg.png\",\n  WALLET_CONNECT: \"https://raw.githubusercontent.com/ton-connect/sdk/main/assets/walletconnect-icon-288.png\"\n};\nfunction isWalletUi(wallet) {\n  return !(\"type\" in wallet) || wallet.type !== \"wallet-connect\";\n}\nconst WalletLabeledItem = (props) => {\n  const [t2] = useI18n();\n  const walletsSecondLine = () => {\n    if (props.wallet.appName === AT_WALLET_APP_NAME) {\n      return void 0;\n    }\n    if (\"isPreferred\" in props.wallet && props.wallet.isPreferred) {\n      return t2(\"walletItem.recent\", {}, \"Recent\");\n    }\n    if (props.wallet.name === \"Tonkeeper\") {\n      return t2(\"walletItem.popular\", {}, \"Popular\");\n    }\n    if (isWalletUi(props.wallet) && (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyInjected)(props.wallet)) {\n      return t2(\"walletItem.installed\", {}, \"Installed\");\n    }\n    return void 0;\n  };\n  return memo(() => memo(() => props.wallet.appName === AT_WALLET_APP_NAME)() ? createComponent(WalletItem, {\n    get icon() {\n      return props.wallet.imageUrl;\n    },\n    get name() {\n      return t2(\"walletItem.walletOn\", {}, \"Wallet in\");\n    },\n    secondLine: \"Telegram\",\n    get badgeUrl() {\n      return IMG.TG;\n    },\n    onClick: () => props.onClick(),\n    get [\"class\"]() {\n      return props.class;\n    }\n  }) : createComponent(WalletItem, {\n    get icon() {\n      return props.wallet.imageUrl;\n    },\n    get name() {\n      return props.wallet.name;\n    },\n    get secondLine() {\n      return walletsSecondLine();\n    },\n    secondLineColorPrimary: false,\n    onClick: () => props.onClick(),\n    get [\"class\"]() {\n      return props.class;\n    }\n  }));\n};\nconst ScrollContainerStyled = styled.div`\n    width: 100%;\n    overflow-y: auto;\n    max-height: ${(props) => props.maxHeight};\n\n    scrollbar-width: none;\n    &&::-webkit-scrollbar {\n        display: none;\n    }\n\n    &&::-webkit-scrollbar-track {\n        background: transparent;\n    }\n\n    &&::-webkit-scrollbar-thumb {\n        display: none;\n    }\n`;\nconst ScrollDivider = styled.div`\n    height: 1px;\n    margin: 0 -24px;\n    width: calc(100% + 48px);\n    opacity: 0.08;\n    background: ${(props) => props.isShown ? props.theme.colors.icon.secondary : \"transparent\"};\n    transition: background 0.15s ease-in-out;\n\n    ${media(\"mobile\")} {\n        width: 100%;\n        margin: 0;\n    }\n`;\nconst [windowHeight, setWindowHeight] = createSignal(((_h = getWindow$1()) == null ? void 0 : _h.innerHeight) || 0);\nif (getWindow$1()) {\n  window.addEventListener(\"resize\", () => setWindowHeight(window.innerHeight));\n}\nconst [isMobile, setIsMobile] = createSignal(isDevice(\"mobile\"));\nconst updateIsMobile = () => setIsMobile(isDevice(\"mobile\"));\nif (getWindow$1()) {\n  window.addEventListener(\"resize\", () => updateIsMobile());\n  window.addEventListener(\"load\", () => updateIsMobile(), { once: true });\n}\nconst ScrollContainer = (props) => {\n  const [scrolled, setScrolled] = createSignal(false);\n  const onScroll = (e2) => {\n    setScrolled(e2.target.scrollTop > 0);\n  };\n  const offset = () => isMobile() ? 150 : 200;\n  const maxHeight = () => props.maxHeight !== void 0 ? `${props.maxHeight}px` : `${windowHeight() - offset()}px`;\n  return [createComponent(ScrollDivider, {\n    get isShown() {\n      return scrolled();\n    }\n  }), createComponent(ScrollContainerStyled, {\n    get maxHeight() {\n      return maxHeight();\n    },\n    onScroll,\n    get [\"class\"]() {\n      return props.class;\n    },\n    get children() {\n      return props.children;\n    }\n  })];\n};\nconst AStyled = styled.a`\n    display: block;\n    text-decoration: unset;\n`;\nconst Link = (props) => {\n  const attributes = () => props.blank ? {\n    rel: \"noreferrer noopener\"\n  } : {};\n  return createComponent(AStyled, mergeProps({\n    get href() {\n      return props.href;\n    },\n    get target() {\n      return props.blank ? \"_blank\" : \"_self\";\n    },\n    get [\"class\"]() {\n      return props.class;\n    }\n  }, attributes, {\n    get children() {\n      return props.children;\n    }\n  }));\n};\nconst TonConnectUiContext = createContext();\nvar _tmpl$$8 = /* @__PURE__ */ template$1(`<svg width=24 height=24 viewBox=\"0 0 24 24\"fill=none xmlns=http://www.w3.org/2000/svg><path fill-rule=evenodd clip-rule=evenodd d=\"M7.76228 2.09998H10.2378C11.0458 2.09997 11.7067 2.09996 12.2438 2.14384C12.7997 2.18926 13.3017 2.28614 13.7706 2.52505C14.5045 2.89896 15.1011 3.49558 15.475 4.22941C15.7139 4.6983 15.8108 5.20038 15.8562 5.75629C15.9001 6.29337 15.9001 6.95422 15.9001 7.76227V8.1H16.2377C17.0457 8.09999 17.7066 8.09998 18.2437 8.14386C18.7996 8.18928 19.3017 8.28616 19.7705 8.52507C20.5044 8.89898 21.101 9.4956 21.4749 10.2294C21.7138 10.6983 21.8107 11.2004 21.8561 11.7563C21.9 12.2934 21.9 12.9542 21.9 13.7623V16.2377C21.9 17.0458 21.9 17.7066 21.8561 18.2437C21.8107 18.7996 21.7138 19.3017 21.4749 19.7706C21.101 20.5044 20.5044 21.101 19.7705 21.4749C19.3017 21.7138 18.7996 21.8107 18.2437 21.8561C17.7066 21.9 17.0458 21.9 16.2378 21.9H13.7623C12.9543 21.9 12.2934 21.9 11.7563 21.8561C11.2004 21.8107 10.6983 21.7138 10.2294 21.4749C9.49561 21.101 8.89898 20.5044 8.52508 19.7706C8.28616 19.3017 8.18928 18.7996 8.14386 18.2437C8.09998 17.7066 8.09999 17.0458 8.1 16.2377V15.9H7.76227C6.95426 15.9 6.29335 15.9 5.75629 15.8561C5.20038 15.8107 4.6983 15.7138 4.22941 15.4749C3.49558 15.101 2.89896 14.5044 2.52505 13.7705C2.28614 13.3017 2.18926 12.7996 2.14384 12.2437C2.09996 11.7066 2.09997 11.0458 2.09998 10.2377V7.76228C2.09997 6.95424 2.09996 6.29336 2.14384 5.75629C2.18926 5.20038 2.28614 4.6983 2.52505 4.22941C2.89896 3.49558 3.49558 2.89896 4.22941 2.52505C4.6983 2.28614 5.20038 2.18926 5.75629 2.14384C6.29336 2.09996 6.95425 2.09997 7.76228 2.09998ZM8.1 14.1V13.7623C8.09999 12.9542 8.09998 12.2934 8.14386 11.7563C8.18928 11.2004 8.28616 10.6983 8.52508 10.2294C8.89898 9.4956 9.49561 8.89898 10.2294 8.52507C10.6983 8.28616 11.2004 8.18928 11.7563 8.14386C12.2934 8.09998 12.9542 8.09999 13.7623 8.1H14.1001V7.79998C14.1001 6.94505 14.0994 6.35798 14.0622 5.90287C14.0259 5.45827 13.9593 5.21944 13.8712 5.0466C13.6699 4.65146 13.3486 4.3302 12.9535 4.12886C12.7806 4.04079 12.5418 3.97419 12.0972 3.93786C11.6421 3.90068 11.055 3.89998 10.2001 3.89998H7.79998C6.94505 3.89998 6.35798 3.90068 5.90287 3.93786C5.45827 3.97419 5.21944 4.04079 5.0466 4.12886C4.65146 4.3302 4.3302 4.65146 4.12886 5.0466C4.04079 5.21944 3.97419 5.45827 3.93786 5.90287C3.90068 6.35798 3.89998 6.94505 3.89998 7.79998V10.2C3.89998 11.0549 3.90068 11.642 3.93786 12.0971C3.97419 12.5417 4.04079 12.7805 4.12886 12.9534C4.3302 13.3485 4.65146 13.6698 5.0466 13.8711C5.21944 13.9592 5.45827 14.0258 5.90287 14.0621C6.35798 14.0993 6.94505 14.1 7.79998 14.1H8.1ZM11.0466 10.1289C11.2195 10.0408 11.4583 9.97421 11.9029 9.93788C12.358 9.9007 12.9451 9.9 13.8 9.9H16.2C17.0549 9.9 17.642 9.9007 18.0971 9.93788C18.5417 9.97421 18.7805 10.0408 18.9534 10.1289C19.3485 10.3302 19.6698 10.6515 19.8711 11.0466C19.9592 11.2195 20.0258 11.4583 20.0621 11.9029C20.0993 12.358 20.1 12.9451 20.1 13.8V16.2C20.1 17.0549 20.0993 17.642 20.0621 18.0971C20.0258 18.5417 19.9592 18.7805 19.8711 18.9534C19.6698 19.3485 19.3485 19.6698 18.9534 19.8711C18.7805 19.9592 18.5417 20.0258 18.0971 20.0621C17.642 20.0993 17.0549 20.1 16.2 20.1H13.8C12.9451 20.1 12.358 20.0993 11.9029 20.0621C11.4583 20.0258 11.2195 19.9592 11.0466 19.8711C10.6515 19.6698 10.3302 19.3485 10.1289 18.9534C10.0408 18.7805 9.97421 18.5417 9.93788 18.0971C9.9007 17.642 9.9 17.0549 9.9 16.2V13.8C9.9 12.9451 9.9007 12.358 9.93788 11.9029C9.97421 11.4583 10.0408 11.2195 10.1289 11.0466C10.3302 10.6515 10.6515 10.3302 11.0466 10.1289Z\">`);\nconst CopyIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.primary;\n  return (() => {\n    var _el$ = _tmpl$$8(), _el$2 = _el$.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = props.class, _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })();\n};\nvar _tmpl$$7 = /* @__PURE__ */ template$1(`<svg width=24 height=24 viewBox=\"0 0 24 24\"fill=none xmlns=http://www.w3.org/2000/svg><path d=\"M8.7624 3.10001C7.95435 3.1 7.29349 3.09999 6.75642 3.14387C6.2005 3.18929 5.69842 3.28617 5.22954 3.52508C4.4957 3.89899 3.89908 4.49561 3.52517 5.22944C3.28626 5.69833 3.18938 6.20041 3.14396 6.75632C3.10008 7.2934 3.10009 7.95424 3.1001 8.76229V15.2377C3.10009 16.0458 3.10008 16.7066 3.14396 17.2437C3.18938 17.7996 3.28626 18.3017 3.52517 18.7706C3.89908 19.5044 4.4957 20.101 5.22954 20.4749C5.69842 20.7138 6.2005 20.8107 6.75642 20.8561C7.29349 20.9 7.95434 20.9 8.76239 20.9H12.0001C12.4972 20.9 12.9001 20.4971 12.9001 20C12.9001 19.503 12.4972 19.1 12.0001 19.1H8.8001C7.94517 19.1 7.3581 19.0993 6.90299 19.0621C6.45839 19.0258 6.21956 18.9592 6.04672 18.8711C5.65158 18.6698 5.33032 18.3485 5.12898 17.9534C5.04092 17.7805 4.97431 17.5417 4.93798 17.0971C4.9008 16.642 4.9001 16.0549 4.9001 15.2V8.80001C4.9001 7.94508 4.9008 7.35801 4.93798 6.9029C4.97431 6.4583 5.04092 6.21947 5.12898 6.04663C5.33032 5.65149 5.65158 5.33023 6.04672 5.12889C6.21956 5.04082 6.45839 4.97422 6.90299 4.93789C7.3581 4.90071 7.94517 4.90001 8.8001 4.90001H12.0001C12.4972 4.90001 12.9001 4.49706 12.9001 4.00001C12.9001 3.50295 12.4972 3.10001 12.0001 3.10001H8.7624Z\"></path><path d=\"M17.6364 7.3636C17.2849 7.01212 16.7151 7.01212 16.3636 7.3636C16.0121 7.71507 16.0121 8.28492 16.3636 8.63639L18.8272 11.1H9.00001C8.50295 11.1 8.10001 11.5029 8.10001 12C8.10001 12.497 8.50295 12.9 9.00001 12.9H18.8272L16.3636 15.3636C16.0121 15.7151 16.0121 16.2849 16.3636 16.6364C16.7151 16.9879 17.2849 16.9879 17.6364 16.6364L21.6364 12.6364C21.9879 12.2849 21.9879 11.7151 21.6364 11.3636L17.6364 7.3636Z\">`);\nconst DisconnectIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.primary;\n  return (() => {\n    var _el$ = _tmpl$$7(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$ = fill(), _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$2, \"fill\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$3, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })();\n};\nconst hoverBorders$1 = {\n  m: \"8px\",\n  s: \"4px\",\n  none: \"0\"\n};\nconst dropdownBorders = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst AccountButtonDropdownStyled = styled.div`\n    width: 256px;\n    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);\n    border-radius: ${(props) => dropdownBorders[props.theme.borderRadius]};\n\n    background-color: ${(props) => props.theme.colors.background.primary}\n           \n    color: ${(props) => props.theme.colors.text.primary}\n`;\nconst UlStyled = styled.ul`\n    background-color: ${(props) => props.theme.colors.background.primary};\n    padding: 8px;\n`;\nconst MenuButtonStyled = styled.button`\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    height: 40px;\n    padding-left: 8px;\n    width: 100%;\n\n    background-color: ${(props) => props.theme.colors.background.primary};\n    border: none;\n    border-radius: ${(props) => hoverBorders$1[props.theme.borderRadius]};\n    cursor: pointer;\n\n    transition:\n        background-color,\n        transform 0.1s ease-in-out;\n\n    &:hover {\n        background-color: ${(props) => props.theme.colors.background.secondary};\n    }\n\n    &:active {\n        transform: scale(0.96);\n    }\n`;\nvar _tmpl$$6 = /* @__PURE__ */ template$1(`<li>`);\nconst MenuItemText = (props) => createComponent(Text, {\n  get translationKey() {\n    return props.translationKey;\n  },\n  fontSize: \"15px\",\n  fontWeight: \"590\",\n  get children() {\n    return props.children;\n  }\n});\nconst AccountButtonDropdown = (props) => {\n  const tonConnectUi = useContext(TonConnectUiContext);\n  const [isCopiedShown, setIsCopiedShown] = createSignal(false);\n  const onCopy = () => __async(null, null, function* () {\n    const userFriendlyAddress = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.toUserFriendlyAddress)(tonConnectUi.account.address, tonConnectUi.account.chain === _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.CHAIN.TESTNET);\n    yield copyToClipboard(userFriendlyAddress);\n    setIsCopiedShown(true);\n    setTimeout(() => setIsCopiedShown(false), 1e3);\n  });\n  const onDisconnect = () => {\n    tonConnectUi.disconnect();\n    props.onClose();\n  };\n  return createComponent(AccountButtonDropdownStyled, {\n    ref(r$) {\n      var _ref$ = props.ref;\n      typeof _ref$ === \"function\" ? _ref$(r$) : props.ref = r$;\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-dropdown\": \"true\",\n    get children() {\n      return createComponent(UlStyled, {\n        get children() {\n          return [(() => {\n            var _el$ = _tmpl$$6();\n            insert(_el$, createComponent(MenuButtonStyled, {\n              onClick: () => onCopy(),\n              get children() {\n                return [createComponent(CopyIcon, {}), createComponent(Show, {\n                  get when() {\n                    return !isCopiedShown();\n                  },\n                  get children() {\n                    return createComponent(MenuItemText, {\n                      translationKey: \"button.dropdown.copy\",\n                      children: \"Copy address\"\n                    });\n                  }\n                }), createComponent(Show, {\n                  get when() {\n                    return isCopiedShown();\n                  },\n                  get children() {\n                    return createComponent(MenuItemText, {\n                      translationKey: \"button.dropdown.copied\",\n                      children: \"Address copied!\"\n                    });\n                  }\n                })];\n              }\n            }));\n            return _el$;\n          })(), (() => {\n            var _el$2 = _tmpl$$6();\n            insert(_el$2, createComponent(MenuButtonStyled, {\n              onClick: () => onDisconnect(),\n              get children() {\n                return [createComponent(DisconnectIcon, {}), createComponent(MenuItemText, {\n                  translationKey: \"button.dropdown.disconnect\",\n                  children: \"Disconnect\"\n                })];\n              }\n            }));\n            return _el$2;\n          })()];\n        }\n      });\n    }\n  });\n};\nconst borders$3 = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst NotificationStyled = styled.div`\n    width: 256px;\n    padding: 12px 16px;\n    display: flex;\n    gap: 9px;\n\n    background-color: ${(props) => props.theme.colors.background.primary};\n    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);\n    border-radius: ${(props) => borders$3[props.theme.borderRadius]};\n`;\nconst NotificationContentStyled = styled.div`\n    width: 192px;\n\n    > h3 {\n        font-size: 15px;\n    }\n`;\nconst TextStyled$3 = styled(Text)`\n    margin-top: 4px;\n    color: ${(props) => props.theme.colors.text.secondary};\n`;\nconst Notification = (props) => {\n  const dataAttrs = useDataAttributes(props);\n  return createComponent(NotificationStyled, mergeProps({\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-notification\": \"true\"\n  }, dataAttrs, {\n    get children() {\n      return [createComponent(NotificationContentStyled, {\n        get children() {\n          return [createComponent(H3, {\n            get translationKey() {\n              return props.header.translationKey;\n            },\n            get translationValues() {\n              return props.header.translationValues;\n            },\n            get children() {\n              return props.children;\n            }\n          }), createComponent(Show, {\n            get when() {\n              return props.text;\n            },\n            get children() {\n              return createComponent(TextStyled$3, {\n                get translationKey() {\n                  return props.text.translationKey;\n                },\n                get translationValues() {\n                  return props.text.translationValues;\n                }\n              });\n            }\n          })];\n        }\n      }), memo(() => props.icon)];\n    }\n  }));\n};\nconst LoaderIconStyled$2 = styled(LoaderIcon)`\n    align-self: center;\n`;\nconst ConfirmOperationNotification = (props) => {\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [t2] = useI18n();\n  const name = () => tonConnectUI.wallet && \"name\" in tonConnectUI.wallet ? tonConnectUI.wallet.name : t2(\"common.yourWallet\", {}, \"Your wallet\");\n  return createComponent(Notification, {\n    get header() {\n      return {\n        translationKey: \"notifications.confirm.header\",\n        translationValues: {\n          name: name()\n        }\n      };\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    get icon() {\n      return createComponent(LoaderIconStyled$2, {});\n    },\n    \"data-tc-notification-confirm\": \"true\",\n    children: \"Confirm operation in your wallet\"\n  });\n};\nconst ErrorIconStyled$4 = styled(ErrorIcon)`\n    margin-top: 2px;\n`;\nconst ErrorTransactionNotification = (props) => {\n  return createComponent(Notification, {\n    header: {\n      translationKey: \"notifications.transactionCanceled.header\"\n    },\n    text: {\n      translationKey: \"notifications.transactionCanceled.text\"\n    },\n    get icon() {\n      return createComponent(ErrorIconStyled$4, {\n        size: \"xs\"\n      });\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-notification-tx-cancelled\": \"true\",\n    children: \"Transaction cancelled\"\n  });\n};\nconst SuccessIconStyled = styled(SuccessIcon)`\n    margin-top: 2px;\n`;\nconst SuccessTransactionNotification = (props) => {\n  return createComponent(Notification, {\n    header: {\n      translationKey: \"notifications.transactionSent.header\"\n    },\n    text: {\n      translationKey: \"notifications.transactionSent.text\"\n    },\n    get icon() {\n      return createComponent(SuccessIconStyled, {});\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-notification-tx-sent\": \"true\",\n    children: \"Transaction sent\"\n  });\n};\nconst NotificationClass = u`\n    transform: translateY(-8px);\n    margin-bottom: 12px;\n`;\nconst defaultConfig = {\n  timeout: 4500\n};\nconst [latestAction, setLatestAction] = createSignal(null);\nfunction useOpenedNotifications(config) {\n  const { timeout } = __spreadValues(__spreadValues({}, defaultConfig), config);\n  const [openedNotifications, setOpenedNotifications] = createSignal([]);\n  const [timeoutIds, setTimeoutIds] = createSignal([]);\n  createEffect(\n    on(action, (action2) => {\n      var _a2, _b2;\n      if (!action2 || !action2.showNotification) {\n        setOpenedNotifications(\n          (openedNotifications2) => openedNotifications2.filter((n2) => n2.action !== \"confirm-transaction\")\n        );\n        return;\n      }\n      if (latestAction() === action2) {\n        return;\n      }\n      const isConfirmTransactionAction = ((_a2 = latestAction()) == null ? void 0 : _a2.name) === \"confirm-transaction\" && action2.name === \"confirm-transaction\";\n      const isConfirmSignDataAction = ((_b2 = latestAction()) == null ? void 0 : _b2.name) === \"confirm-sign-data\" && action2.name === \"confirm-sign-data\";\n      if (isConfirmTransactionAction || isConfirmSignDataAction) {\n        return;\n      }\n      setLatestAction(action2);\n      setOpenedNotifications(\n        (openedNotifications2) => openedNotifications2.filter(\n          (n2) => n2.action !== \"confirm-transaction\" && n2.action !== \"confirm-sign-data\"\n        )\n      );\n      const notification = { action: action2.name };\n      setOpenedNotifications((openedNotifications2) => [...openedNotifications2, notification]);\n      const timeoutId = setTimeout(() => {\n        setOpenedNotifications(\n          (openedNotifications2) => openedNotifications2.filter((n2) => n2 !== notification)\n        );\n        setTimeoutIds((timeoutIds2) => timeoutIds2.filter((id) => id !== timeoutId));\n      }, timeout);\n      setTimeoutIds((timeoutIds2) => [...timeoutIds2, timeoutId]);\n    })\n  );\n  onCleanup(() => {\n    timeoutIds().forEach((id) => clearTimeout(id));\n  });\n  return openedNotifications;\n}\nconst ErrorIconStyled$3 = styled(ErrorIcon)`\n    margin-top: 2px;\n`;\nconst ErrorSignDataNotification = (props) => {\n  return createComponent(Notification, {\n    header: {\n      translationKey: \"notifications.signDataCanceled.header\"\n    },\n    get icon() {\n      return createComponent(ErrorIconStyled$3, {\n        size: \"xs\"\n      });\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-notification-sign-data-cancelled\": \"true\",\n    children: \"Sign data canceled\"\n  });\n};\nconst SuccessSignDataNotification = (props) => {\n  return createComponent(Notification, {\n    header: {\n      translationKey: \"notifications.dataSigned.header\"\n    },\n    get icon() {\n      return createComponent(SuccessIconStyled, {});\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-notification-data-signed\": \"true\",\n    children: \"Data signed\"\n  });\n};\nvar _tmpl$$5 = /* @__PURE__ */ template$1(`<div data-tc-list-notifications=true>`);\nconst Notifications = (props) => {\n  const openedNotifications = useOpenedNotifications();\n  return (() => {\n    var _el$ = _tmpl$$5();\n    insert(_el$, createComponent(TransitionGroup, {\n      onBeforeEnter: (el) => {\n        animate(el, [{\n          opacity: 0,\n          transform: \"translateY(0)\"\n        }, {\n          opacity: 1,\n          transform: \"translateY(-8px)\"\n        }], {\n          duration: 200\n        });\n      },\n      onExit: (el, done) => {\n        const a2 = animate(el, [{\n          opacity: 1,\n          transform: \"translateY(-8px)\"\n        }, {\n          opacity: 0,\n          transform: \"translateY(-30px)\"\n        }], {\n          duration: 200\n        });\n        a2.finished.then(done);\n      },\n      get children() {\n        return createComponent(For, {\n          get each() {\n            return openedNotifications();\n          },\n          children: (openedNotification) => createComponent(Switch, {\n            get children() {\n              return [createComponent(Match, {\n                get when() {\n                  return openedNotification.action === \"transaction-sent\";\n                },\n                get children() {\n                  return createComponent(SuccessTransactionNotification, {\n                    \"class\": NotificationClass\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return openedNotification.action === \"transaction-canceled\";\n                },\n                get children() {\n                  return createComponent(ErrorTransactionNotification, {\n                    \"class\": NotificationClass\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return openedNotification.action === \"data-signed\";\n                },\n                get children() {\n                  return createComponent(SuccessSignDataNotification, {\n                    \"class\": NotificationClass\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return openedNotification.action === \"sign-data-canceled\";\n                },\n                get children() {\n                  return createComponent(ErrorSignDataNotification, {\n                    \"class\": NotificationClass\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return openedNotification.action === \"confirm-transaction\" || openedNotification.action === \"confirm-sign-data\";\n                },\n                get children() {\n                  return createComponent(ConfirmOperationNotification, {\n                    \"class\": NotificationClass\n                  });\n                }\n              })];\n            }\n          })\n        });\n      }\n    }));\n    createRenderEffect(() => className(_el$, props.class));\n    return _el$;\n  })();\n};\nconst AccountButtonStyled = styled(Button)`\n    background-color: ${(props) => props.theme.colors.connectButton.background};\n    color: ${(props) => props.theme.colors.connectButton.foreground};\n    box-shadow: ${(props) => `0 4px 24px ${rgba(props.theme.colors.constant.black, 0.16)}`};\n    padding: 8px 16px 8px 12px;\n\n    display: flex;\n    align-items: center;\n    gap: 4px;\n    height: 40px;\n`;\nconst DropdownButtonStyled = styled(AccountButtonStyled)`\n    padding: 12px 16px;\n    min-width: 148px;\n    justify-content: center;\n    background-color: ${(props) => props.theme.colors.background.primary};\n`;\nconst LoaderButtonStyled$1 = styled(Button)`\n    min-width: 148px;\n    height: 40px;\n\n    background-color: ${(props) => props.theme.colors.background.primary};\n    color: ${(props) => props.theme.colors.connectButton.foreground};\n    box-shadow: ${(props) => `0 4px 24px ${rgba(props.theme.colors.constant.black, 0.16)}`};\n\n    display: flex;\n    align-items: center;\n    justify-content: center;\n`;\nconst LoaderIconStyled$1 = styled(LoaderIcon)`\n    height: 18px;\n    width: 18px;\n`;\nconst DropdownContainerStyled = styled.div`\n    width: fit-content;\n    display: flex;\n    flex-direction: column;\n    align-items: flex-end;\n`;\nconst DropdownStyled = styled(AccountButtonDropdown)`\n    box-sizing: border-box;\n    overflow: hidden;\n    margin-top: 12px;\n`;\nconst NotificationsStyled = styled(Notifications)`\n    > div:first-child {\n        margin-top: 20px;\n    }\n`;\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = (v) => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nconst oppositeAlignmentMap = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === \"function\" ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split(\"-\")[0];\n}\nfunction getAlignment(placement) {\n  return placement.split(\"-\")[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === \"x\" ? \"y\" : \"x\";\n}\nfunction getAxisLength(axis) {\n  return axis === \"y\" ? \"height\" : \"width\";\n}\nconst yAxisSides = /* @__PURE__ */ new Set([\"top\", \"bottom\"]);\nfunction getSideAxis(placement) {\n  return yAxisSides.has(getSide(placement)) ? \"y\" : \"x\";\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === \"x\" ? alignment === (rtl ? \"end\" : \"start\") ? \"right\" : \"left\" : alignment === \"start\" ? \"bottom\" : \"top\";\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);\n}\nconst lrPlacement = [\"left\", \"right\"];\nconst rlPlacement = [\"right\", \"left\"];\nconst tbPlacement = [\"top\", \"bottom\"];\nconst btPlacement = [\"bottom\", \"top\"];\nfunction getSideList(side, isStart, rtl) {\n  switch (side) {\n    case \"top\":\n    case \"bottom\":\n      if (rtl) return isStart ? rlPlacement : lrPlacement;\n      return isStart ? lrPlacement : rlPlacement;\n    case \"left\":\n    case \"right\":\n      return isStart ? tbPlacement : btPlacement;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === \"start\", rtl);\n  if (alignment) {\n    list = list.map((side) => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return __spreadValues({\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  }, padding);\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== \"number\" ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === \"y\";\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case \"top\":\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case \"bottom\":\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case \"right\":\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case \"left\":\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case \"start\":\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case \"end\":\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\nconst computePosition$1 = (reference, floating, config) => __async(null, null, function* () {\n  const {\n    placement = \"bottom\",\n    strategy = \"absolute\",\n    middleware = [],\n    platform: platform2\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(floating);\n  let rects = yield platform2.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i2 = 0; i2 < validMiddleware.length; i2++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i2];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = yield fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform: platform2,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = __spreadProps(__spreadValues({}, middlewareData), {\n      [name]: __spreadValues(__spreadValues({}, middlewareData[name]), data)\n    });\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === \"object\") {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? yield platform2.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i2 = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n});\nfunction detectOverflow(state, options) {\n  return __async(this, null, function* () {\n    var _await$platform$isEle;\n    if (options === void 0) {\n      options = {};\n    }\n    const {\n      x,\n      y,\n      platform: platform2,\n      rects,\n      elements,\n      strategy\n    } = state;\n    const {\n      boundary = \"clippingAncestors\",\n      rootBoundary = \"viewport\",\n      elementContext = \"floating\",\n      altBoundary = false,\n      padding = 0\n    } = evaluate(options, state);\n    const paddingObject = getPaddingObject(padding);\n    const altContext = elementContext === \"floating\" ? \"reference\" : \"floating\";\n    const element = elements[altBoundary ? altContext : elementContext];\n    const clippingClientRect = rectToClientRect(yield platform2.getClippingRect({\n      element: ((_await$platform$isEle = yield platform2.isElement == null ? void 0 : platform2.isElement(element)) != null ? _await$platform$isEle : true) ? element : element.contextElement || (yield platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),\n      boundary,\n      rootBoundary,\n      strategy\n    }));\n    const rect = elementContext === \"floating\" ? {\n      x,\n      y,\n      width: rects.floating.width,\n      height: rects.floating.height\n    } : rects.reference;\n    const offsetParent = yield platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating);\n    const offsetScale = (yield platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? (yield platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {\n      x: 1,\n      y: 1\n    } : {\n      x: 1,\n      y: 1\n    };\n    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? yield platform2.convertOffsetParentRelativeRectToViewportRelativeRect({\n      elements,\n      rect,\n      offsetParent,\n      strategy\n    }) : rect);\n    return {\n      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n    };\n  });\n}\nconst flip$1 = function(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"flip\",\n    options,\n    fn(state) {\n      return __async(this, null, function* () {\n        var _middlewareData$arrow, _middlewareData$flip;\n        const {\n          placement,\n          middlewareData,\n          rects,\n          initialPlacement,\n          platform: platform2,\n          elements\n        } = state;\n        const _a3 = evaluate(options, state), {\n          mainAxis: checkMainAxis = true,\n          crossAxis: checkCrossAxis = true,\n          fallbackPlacements: specifiedFallbackPlacements,\n          fallbackStrategy = \"bestFit\",\n          fallbackAxisSideDirection = \"none\",\n          flipAlignment = true\n        } = _a3, detectOverflowOptions = __objRest(_a3, [\n          \"mainAxis\",\n          \"crossAxis\",\n          \"fallbackPlacements\",\n          \"fallbackStrategy\",\n          \"fallbackAxisSideDirection\",\n          \"flipAlignment\"\n        ]);\n        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n          return {};\n        }\n        const side = getSide(placement);\n        const initialSideAxis = getSideAxis(initialPlacement);\n        const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n        const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating);\n        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n        const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== \"none\";\n        if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n        }\n        const placements = [initialPlacement, ...fallbackPlacements];\n        const overflow = yield detectOverflow(state, detectOverflowOptions);\n        const overflows = [];\n        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n        if (checkMainAxis) {\n          overflows.push(overflow[side]);\n        }\n        if (checkCrossAxis) {\n          const sides = getAlignmentSides(placement, rects, rtl);\n          overflows.push(overflow[sides[0]], overflow[sides[1]]);\n        }\n        overflowsData = [...overflowsData, {\n          placement,\n          overflows\n        }];\n        if (!overflows.every((side2) => side2 <= 0)) {\n          var _middlewareData$flip2, _overflowsData$filter;\n          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n          const nextPlacement = placements[nextIndex];\n          if (nextPlacement) {\n            const ignoreCrossAxisOverflow = checkCrossAxis === \"alignment\" ? initialSideAxis !== getSideAxis(nextPlacement) : false;\n            if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis\n            // overflows the main axis.\n            overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {\n              return {\n                data: {\n                  index: nextIndex,\n                  overflows: overflowsData\n                },\n                reset: {\n                  placement: nextPlacement\n                }\n              };\n            }\n          }\n          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a2, b) => a2.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n          if (!resetPlacement) {\n            switch (fallbackStrategy) {\n              case \"bestFit\": {\n                var _overflowsData$filter2;\n                const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === \"y\";\n                  }\n                  return true;\n                }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b) => a2[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement2) {\n                  resetPlacement = placement2;\n                }\n                break;\n              }\n              case \"initialPlacement\":\n                resetPlacement = initialPlacement;\n                break;\n            }\n          }\n          if (placement !== resetPlacement) {\n            return {\n              reset: {\n                placement: resetPlacement\n              }\n            };\n          }\n        }\n        return {};\n      });\n    }\n  };\n};\nconst shift$1 = function(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"shift\",\n    options,\n    fn(state) {\n      return __async(this, null, function* () {\n        const {\n          x,\n          y,\n          placement\n        } = state;\n        const _a3 = evaluate(options, state), {\n          mainAxis: checkMainAxis = true,\n          crossAxis: checkCrossAxis = false,\n          limiter = {\n            fn: (_ref) => {\n              let {\n                x: x2,\n                y: y2\n              } = _ref;\n              return {\n                x: x2,\n                y: y2\n              };\n            }\n          }\n        } = _a3, detectOverflowOptions = __objRest(_a3, [\n          \"mainAxis\",\n          \"crossAxis\",\n          \"limiter\"\n        ]);\n        const coords = {\n          x,\n          y\n        };\n        const overflow = yield detectOverflow(state, detectOverflowOptions);\n        const crossAxis = getSideAxis(getSide(placement));\n        const mainAxis = getOppositeAxis(crossAxis);\n        let mainAxisCoord = coords[mainAxis];\n        let crossAxisCoord = coords[crossAxis];\n        if (checkMainAxis) {\n          const minSide = mainAxis === \"y\" ? \"top\" : \"left\";\n          const maxSide = mainAxis === \"y\" ? \"bottom\" : \"right\";\n          const min2 = mainAxisCoord + overflow[minSide];\n          const max2 = mainAxisCoord - overflow[maxSide];\n          mainAxisCoord = clamp(min2, mainAxisCoord, max2);\n        }\n        if (checkCrossAxis) {\n          const minSide = crossAxis === \"y\" ? \"top\" : \"left\";\n          const maxSide = crossAxis === \"y\" ? \"bottom\" : \"right\";\n          const min2 = crossAxisCoord + overflow[minSide];\n          const max2 = crossAxisCoord - overflow[maxSide];\n          crossAxisCoord = clamp(min2, crossAxisCoord, max2);\n        }\n        const limitedCoords = limiter.fn(__spreadProps(__spreadValues({}, state), {\n          [mainAxis]: mainAxisCoord,\n          [crossAxis]: crossAxisCoord\n        }));\n        return __spreadProps(__spreadValues({}, limitedCoords), {\n          data: {\n            x: limitedCoords.x - x,\n            y: limitedCoords.y - y,\n            enabled: {\n              [mainAxis]: checkMainAxis,\n              [crossAxis]: checkCrossAxis\n            }\n          }\n        });\n      });\n    }\n  };\n};\nfunction hasWindow() {\n  return typeof window !== \"undefined\";\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || \"\").toLowerCase();\n  }\n  return \"#document\";\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === \"undefined\") {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nconst invalidOverflowDisplayValues = /* @__PURE__ */ new Set([\"inline\", \"contents\"]);\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);\n}\nconst tableElements = /* @__PURE__ */ new Set([\"table\", \"td\", \"th\"]);\nfunction isTableElement(element) {\n  return tableElements.has(getNodeName(element));\n}\nconst topLayerSelectors = [\":popover-open\", \":modal\"];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some((selector) => {\n    try {\n      return element.matches(selector);\n    } catch (_e2) {\n      return false;\n    }\n  });\n}\nconst transformProperties = [\"transform\", \"translate\", \"scale\", \"rotate\", \"perspective\"];\nconst willChangeValues = [\"transform\", \"translate\", \"scale\", \"rotate\", \"perspective\", \"filter\"];\nconst containValues = [\"paint\", \"layout\", \"strict\", \"content\"];\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;\n  return transformProperties.some((value) => css[value] ? css[value] !== \"none\" : false) || (css.containerType ? css.containerType !== \"normal\" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== \"none\" : false) || !webkit && (css.filter ? css.filter !== \"none\" : false) || willChangeValues.some((value) => (css.willChange || \"\").includes(value)) || containValues.some((value) => (css.contain || \"\").includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === \"undefined\" || !CSS.supports) return false;\n  return CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nconst lastTraversableNodeNames = /* @__PURE__ */ new Set([\"html\", \"body\", \"#document\"]);\nfunction isLastTraversableNode(node) {\n  return lastTraversableNodeNames.has(getNodeName(node));\n}\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === \"html\") {\n    return node;\n  }\n  const result = (\n    // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot || // DOM Element detected.\n    node.parentNode || // ShadowRoot detected.\n    isShadowRoot(node) && node.host || // Fallback.\n    getDocumentElement(node)\n  );\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\nfunction getCssDimensions(element) {\n  const css = getComputedStyle$1(element);\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\nconst noOffsets = /* @__PURE__ */ createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle$1(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n  if (ignoreScrollbarX === void 0) {\n    ignoreScrollbarX = false;\n  }\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (\n    // RTL <body> scrollbar.\n    getWindowScrollBarX(documentElement, htmlRect)\n  ));\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === \"fixed\";\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle$1(body).direction === \"rtl\") {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === \"fixed\") {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nconst absoluteOrFixed = /* @__PURE__ */ new Set([\"absolute\", \"fixed\"]);\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === \"fixed\");\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === \"viewport\") {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === \"document\") {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle$1(parentNode).position === \"fixed\" || hasFixedPositionAncestor(parentNode, stopNode);\n}\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== \"body\");\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === \"fixed\";\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle$1(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === \"fixed\") {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === \"static\" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      result = result.filter((ancestor) => ancestor !== currentNode);\n    } else {\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === \"clippingAncestors\" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === \"fixed\";\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction isStaticPositioned(element) {\n  return getComputedStyle$1(element).position === \"static\";\n}\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === \"fixed\") {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\nconst getElementRects = function(data) {\n  return __async(this, null, function* () {\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    const floatingDimensions = yield getDimensionsFn(data.floating);\n    return {\n      reference: getRectRelativeToOffsetParent(data.reference, yield getOffsetParentFn(data.floating), data.strategy),\n      floating: {\n        x: 0,\n        y: 0,\n        width: floatingDimensions.width,\n        height: floatingDimensions.height\n      }\n    };\n  });\n};\nfunction isRTL(element) {\n  return getComputedStyle$1(element).direction === \"rtl\";\n}\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\nfunction rectsAreEqual(a2, b) {\n  return a2.x === b.x && a2.y === b.y && a2.width === b.width && a2.height === b.height;\n}\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1e3);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n    try {\n      io = new IntersectionObserver(handleObserve, __spreadProps(__spreadValues({}, options), {\n        // Handle <iframe>s\n        root: root.ownerDocument\n      }));\n    } catch (_e2) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === \"function\",\n    layoutShift = typeof IntersectionObserver === \"function\",\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach((ancestor) => {\n    ancestorScroll && ancestor.addEventListener(\"scroll\", update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener(\"resize\", update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver((_ref) => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach((ancestor) => {\n      ancestorScroll && ancestor.removeEventListener(\"scroll\", update);\n      ancestorResize && ancestor.removeEventListener(\"resize\", update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\nconst shift = shift$1;\nconst flip = flip$1;\nconst computePosition = (reference, floating, options) => {\n  const cache = /* @__PURE__ */ new Map();\n  const mergedOptions = __spreadValues({\n    platform\n  }, options);\n  const platformWithCache = __spreadProps(__spreadValues({}, mergedOptions.platform), {\n    _c: cache\n  });\n  return computePosition$1(reference, floating, __spreadProps(__spreadValues({}, mergedOptions), {\n    platform: platformWithCache\n  }));\n};\nfunction C(l2, u2, e2) {\n  let c2 = () => {\n    var t2;\n    return (t2 = e2 == null ? void 0 : e2.placement) != null ? t2 : \"bottom\";\n  }, d = () => {\n    var t2;\n    return (t2 = e2 == null ? void 0 : e2.strategy) != null ? t2 : \"absolute\";\n  }, [n2, o2] = createSignal({ x: null, y: null, placement: c2(), strategy: d(), middlewareData: {} }), [x, F] = createSignal();\n  createEffect(() => {\n    let t2 = x();\n    if (t2) throw t2.value;\n  });\n  let s2 = createMemo(() => (l2(), u2(), {}));\n  function m() {\n    let t2 = l2(), r = u2();\n    if (t2 && r) {\n      let a2 = s2();\n      computePosition(t2, r, { middleware: e2 == null ? void 0 : e2.middleware, placement: c2(), strategy: d() }).then((i2) => {\n        a2 === s2() && o2(i2);\n      }, (i2) => {\n        F(i2);\n      });\n    }\n  }\n  return createEffect(() => {\n    let t2 = l2(), r = u2();\n    if (c2(), d(), t2 && r) if (e2 != null && e2.whileElementsMounted) {\n      let a2 = e2.whileElementsMounted(t2, r, m);\n      a2 && onCleanup(a2);\n    } else m();\n  }), { get x() {\n    return n2().x;\n  }, get y() {\n    return n2().y;\n  }, get placement() {\n    return n2().placement;\n  }, get strategy() {\n    return n2().strategy;\n  }, get middlewareData() {\n    return n2().middlewareData;\n  }, update: m };\n}\nvar _tmpl$$4 = /* @__PURE__ */ template$1(`<tc-root data-tc-dropdown-container=true>`, true, false, false);\nconst AccountButton = () => {\n  const theme = useTheme();\n  const connector = useContext(ConnectorContext);\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [isOpened, setIsOpened] = createSignal(false);\n  const [account, setAccount] = createSignal(connector.account);\n  const [restoringProcess, setRestoringProcess] = createSignal(!connector.account);\n  let dropDownRef;\n  const [floating, setFloating] = createSignal();\n  const [anchor, setAnchor] = createSignal();\n  const position = C(anchor, floating, {\n    whileElementsMounted: autoUpdate,\n    placement: \"bottom-end\",\n    middleware: [flip(), shift()]\n  });\n  const normalizedAddress = () => {\n    const acc = account();\n    if (acc) {\n      const userFriendlyAddress = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.toUserFriendlyAddress)(acc.address, acc.chain === _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.CHAIN.TESTNET);\n      return userFriendlyAddress.slice(0, 4) + \"\" + userFriendlyAddress.slice(-4);\n    }\n    return \"\";\n  };\n  tonConnectUI.connectionRestored.then(() => setRestoringProcess(false));\n  const unsubscribe = connector.onStatusChange((wallet) => {\n    if (!wallet) {\n      setIsOpened(false);\n      setAccount(null);\n      setRestoringProcess(false);\n      return;\n    }\n    setAccount(wallet.account);\n    setRestoringProcess(false);\n  });\n  const onClick = (e2) => {\n    if (!account() || !isOpened()) {\n      return;\n    }\n    const clickToButton = anchor().contains(e2.target);\n    const clickToDropdown = dropDownRef.contains(e2.target);\n    if (!clickToButton && !clickToDropdown) {\n      setIsOpened(false);\n    }\n  };\n  onMount(() => {\n    document.body.addEventListener(\"click\", onClick);\n  });\n  onCleanup(() => {\n    document.body.removeEventListener(\"click\", onClick);\n    unsubscribe();\n  });\n  return createComponent(Dynamic, {\n    component: globalStylesTag,\n    get children() {\n      return [createComponent(Show, {\n        get when() {\n          return restoringProcess();\n        },\n        get children() {\n          return createComponent(LoaderButtonStyled$1, {\n            disabled: true,\n            \"data-tc-connect-button-loading\": \"true\",\n            get children() {\n              return createComponent(LoaderIconStyled$1, {});\n            }\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !restoringProcess();\n        },\n        get children() {\n          return [createComponent(Show, {\n            get when() {\n              return !account();\n            },\n            get children() {\n              return createComponent(AccountButtonStyled, {\n                onClick: () => tonConnectUI.openModal(),\n                \"data-tc-connect-button\": \"true\",\n                scale: \"s\",\n                get children() {\n                  return [createComponent(TonIcon, {\n                    get fill() {\n                      return theme.colors.connectButton.foreground;\n                    }\n                  }), createComponent(Text, {\n                    translationKey: \"button.connectWallet\",\n                    fontSize: \"15px\",\n                    lineHeight: \"18px\",\n                    fontWeight: \"590\",\n                    get color() {\n                      return theme.colors.connectButton.foreground;\n                    },\n                    children: \"Connect wallet\"\n                  })];\n                }\n              });\n            }\n          }), createComponent(Show, {\n            get when() {\n              return account();\n            },\n            get children() {\n              return createComponent(DropdownContainerStyled, {\n                get children() {\n                  return [createComponent(DropdownButtonStyled, {\n                    onClick: () => setIsOpened((v) => !v),\n                    ref: setAnchor,\n                    \"data-tc-dropdown-button\": \"true\",\n                    scale: \"s\",\n                    get children() {\n                      return [createComponent(Text, {\n                        fontSize: \"15px\",\n                        fontWeight: \"590\",\n                        lineHeight: \"18px\",\n                        get children() {\n                          return normalizedAddress();\n                        }\n                      }), createComponent(ArrowIcon, {\n                        direction: \"bottom\"\n                      })];\n                    }\n                  }), createComponent(Portal, {\n                    get children() {\n                      var _el$ = _tmpl$$4();\n                      use(setFloating, _el$);\n                      _el$.style.setProperty(\"z-index\", \"999\");\n                      _el$._$owner = getOwner();\n                      insert(_el$, createComponent(Transition, {\n                        onBeforeEnter: (el) => {\n                          animate(el, [{\n                            opacity: 0,\n                            transform: \"translateY(-8px)\"\n                          }, {\n                            opacity: 1,\n                            transform: \"translateY(0)\"\n                          }], {\n                            duration: 150\n                          });\n                        },\n                        onExit: (el, done) => {\n                          const a2 = animate(el, [{\n                            opacity: 1,\n                            transform: \"translateY(0)\"\n                          }, {\n                            opacity: 0,\n                            transform: \"translateY(-8px)\"\n                          }], {\n                            duration: 150\n                          });\n                          a2.finished.then(done);\n                        },\n                        get children() {\n                          return createComponent(Show, {\n                            get when() {\n                              return isOpened();\n                            },\n                            get children() {\n                              return createComponent(DropdownStyled, {\n                                get hidden() {\n                                  return !isOpened();\n                                },\n                                onClose: () => setIsOpened(false),\n                                ref(r$) {\n                                  var _ref$ = dropDownRef;\n                                  typeof _ref$ === \"function\" ? _ref$(r$) : dropDownRef = r$;\n                                }\n                              });\n                            }\n                          });\n                        }\n                      }), null);\n                      insert(_el$, createComponent(NotificationsStyled, {}), null);\n                      createRenderEffect((_p$) => {\n                        var _a2, _b2;\n                        var _v$ = position.strategy, _v$2 = `${(_a2 = position.y) != null ? _a2 : 0}px`, _v$3 = `${(_b2 = position.x) != null ? _b2 : 0}px`;\n                        _v$ !== _p$.e && ((_p$.e = _v$) != null ? _el$.style.setProperty(\"position\", _v$) : _el$.style.removeProperty(\"position\"));\n                        _v$2 !== _p$.t && ((_p$.t = _v$2) != null ? _el$.style.setProperty(\"top\", _v$2) : _el$.style.removeProperty(\"top\"));\n                        _v$3 !== _p$.a && ((_p$.a = _v$3) != null ? _el$.style.setProperty(\"left\", _v$3) : _el$.style.removeProperty(\"left\"));\n                        return _p$;\n                      }, {\n                        e: void 0,\n                        t: void 0,\n                        a: void 0\n                      });\n                      return _el$;\n                    }\n                  })];\n                }\n              });\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst StyledModal = styled(Modal)`\n    padding-left: 24px;\n    padding-right: 24px;\n    padding-top: 18px;\n    padding-bottom: 0;\n\n    ${media(\"mobile\")} {\n        padding-left: 0;\n        padding-right: 0;\n    }\n`;\nconst H1Styled$a = styled(H1)`\n    margin-top: 12px;\n\n    ${media(\"mobile\")} {\n        padding: 0 10px;\n    }\n`;\nconst LoaderContainerStyled = styled.div`\n    margin: 30px 0;\n    width: 100%;\n    display: flex;\n    justify-content: center;\n\n    ${media(\"mobile\")} {\n        height: 160px;\n        align-items: center;\n    }\n`;\nstyled(Text)`\n    min-width: 84px;\n    text-align: center;\n    font-weight: 590;\n`;\nstyled(TabBar)`\n    margin: 0 auto 22px;\n`;\nconst [appState, setAppState] = createStore({\n  buttonRootId: null,\n  language: \"en\",\n  returnStrategy: \"back\",\n  twaReturnUrl: void 0,\n  walletsListConfiguration: {},\n  enableAndroidBackHandler: true\n});\nfunction uniq(array) {\n  return [...new Set(array)];\n}\nfunction mergeConcat(idKey, array1, array2) {\n  return array1.map((item1) => {\n    const item2 = array2.find((elem) => elem[idKey] === item1[idKey]);\n    array2 = array2.filter((elem) => elem[idKey] !== item1[idKey]);\n    return item2 === void 0 ? item1 : item2;\n  }).concat(array2);\n}\nfunction uiWalletToWalletInfo(uiWallet) {\n  if (\"jsBridgeKey\" in uiWallet) {\n    return __spreadProps(__spreadValues({}, uiWallet), {\n      injected: _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnect.isWalletInjected(uiWallet.jsBridgeKey),\n      embedded: _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnect.isInsideWalletBrowser(uiWallet.jsBridgeKey)\n    });\n  }\n  return uiWallet;\n}\nfunction applyWalletsListConfiguration(walletsList, configuration) {\n  var _a2;\n  if (!configuration) {\n    return walletsList;\n  }\n  if ((_a2 = configuration.includeWallets) == null ? void 0 : _a2.length) {\n    walletsList = mergeConcat(\n      \"name\",\n      walletsList,\n      configuration.includeWallets.map(uiWalletToWalletInfo)\n    );\n  }\n  return walletsList;\n}\nfunction supportsDesktop(walletInfo) {\n  return walletInfo.platforms.some((w) => [\"macos\", \"linux\", \"windows\"].includes(w));\n}\nfunction supportsMobile(walletInfo) {\n  return walletInfo.platforms.some((w) => [\"ios\", \"android\"].includes(w));\n}\nfunction supportsExtension(walletInfo) {\n  return walletInfo.platforms.some((w) => [\"chrome\", \"firefox\", \"safari\"].includes(w));\n}\nfunction eqWalletName(wallet1, name) {\n  if (!name) {\n    return false;\n  }\n  return wallet1.name.toLowerCase() === name.toLowerCase() || wallet1.appName.toLowerCase() === name.toLowerCase();\n}\nconst DesktopSelectWalletModalStyled = styled.div`\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n`;\nconst H1Styled$9 = styled(H1)`\n    margin-bottom: 18px;\n`;\nstyled.div`\n    height: 1px;\n    margin: 0 -24px;\n    width: calc(100% + 48px);\n    opacity: 0.12;\n    background: ${(props) => props.isShown ? props.theme.colors.icon.secondary : \"transparent\"};\n    transition: background 0.15s ease-in-out;\n\n    ${media(\"mobile\")} {\n        width: 100%;\n    }\n`;\nconst WalletsUl = styled.ul`\n    display: grid;\n    grid-template-columns: repeat(auto-fit, 92px);\n    grid-template-rows: auto;\n    align-content: flex-start;\n    row-gap: 8px;\n    width: 100%;\n    padding: 0 0 16px;\n    align-self: flex-start;\n    max-width: 400px;\n    margin: 0 auto;\n    list-style: none;\n\n    > li {\n        display: block;\n        height: fit-content;\n    }\n\n    ${media(\"mobile\")} {\n        display: grid;\n        grid-template-columns: repeat(4, 1fr);\n        gap: 0;\n        padding: 8px 12px 16px;\n        max-width: none;\n\n        > li {\n            min-width: 78px;\n            display: flex;\n        }\n\n        > li > * {\n            width: 100%;\n        }\n    }\n`;\nstyled(Button)`\n    display: block;\n    margin: 0 auto 1px;\n    font-size: 15px;\n`;\nconst StyledIconButton$5 = styled(IconButton)`\n    position: absolute;\n    top: 16px;\n    left: 16px;\n`;\nconst WalletLabeledItemStyled = styled(WalletLabeledItem)`\n    opacity: ${(props) => props.withOpacity ? \"0.4\" : \"1\"};\n`;\nconst WalletsNotSupportedNotifier = styled.div`\n    display: grid;\n    grid-template-columns: auto 28px;\n    gap: 16px;\n    padding: 16px;\n    margin-bottom: 16px;\n    border-radius: 16px;\n    color: ${(props) => props.theme.colors.text.secondary};\n    background: ${(props) => props.theme.colors.background.tint};\n\n    ${media(\"mobile\")} {\n        margin-left: 16px;\n        margin-right: 16px;\n    }\n`;\nconst WalletsNotSupportedNotifierText = styled(H2)`\n    color: ${(props) => props.theme.colors.text.secondary};\n    text-align: left;\n    margin: 0;\n`;\nconst ErrorBoxStyled = styled.div`\n    position: absolute;\n    bottom: 14px;\n    left: 50%;\n    transform: translate(-50%, 0);\n\n    text-wrap: nowrap;\n    display: flex;\n    gap: 6px;\n    align-items: center;\n    border-radius: 18px;\n    min-width: 126px;\n    padding: 9px 16px 9px 10px;\n\n    filter: drop-shadow(0px 2px 8px rgba(0, 0, 0, 0.08));\n    background-color: ${(props) => props.theme.colors.background.segment};\n`;\nvar _tmpl$$3 = /* @__PURE__ */ template$1(`<svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none xmlns=http://www.w3.org/2000/svg><g clip-path=url(#clip0_5122_10355)><circle cx=8 cy=8 r=8></circle><circle cx=8 cy=11 r=1></circle><path d=\"M7.04994 4.99875C7.02277 4.45542 7.45598 4 8 4C8.54402 4 8.97723 4.45541 8.95006 4.99875L8.78745 8.25094C8.76647 8.67055 8.42014 9 8 9C7.57986 9 7.23353 8.67055 7.21255 8.25094L7.04994 4.99875Z\"></path></g><defs><clipPath id=clip0_5122_10355><rect width=16 height=16>`), _tmpl$2$1 = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=28 height=28 viewBox=\"0 0 28 28\"fill=none><circle cx=14 cy=14 r=12></circle><circle cx=14 cy=18.9 r=1.4></circle><path d=\"M12.6658 8.89845C12.63 8.13698 13.2377 7.5 14 7.5C14.7623 7.5 15.37 8.13698 15.3342 8.89845L15.047 15.0013C15.0207 15.5604 14.5597 16.0002 14 16.0002C13.4403 16.0002 12.9793 15.5604 12.953 15.0013L12.6658 8.89845Z\">`);\nconst ExclamationIcon = (props) => {\n  const theme = useTheme();\n  const size = () => props.size;\n  const fill = () => props.fill || theme.colors.icon.error;\n  return memo(() => memo(() => size() === \"16\")() ? (() => {\n    var _el$ = _tmpl$$3(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.nextSibling, _el$5 = _el$4.nextSibling, _el$6 = _el$2.nextSibling, _el$7 = _el$6.firstChild, _el$8 = _el$7.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = fill(), _v$2 = theme.colors.constant.white, _v$3 = theme.colors.constant.white, _v$4 = theme.colors.constant.white;\n      _v$ !== _p$.e && setAttribute(_el$3, \"fill\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$4, \"fill\", _p$.t = _v$2);\n      _v$3 !== _p$.a && setAttribute(_el$5, \"fill\", _p$.a = _v$3);\n      _v$4 !== _p$.o && setAttribute(_el$8, \"fill\", _p$.o = _v$4);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0,\n      o: void 0\n    });\n    return _el$;\n  })() : memo(() => size() === \"28\")() ? (() => {\n    var _el$9 = _tmpl$2$1(), _el$0 = _el$9.firstChild, _el$1 = _el$0.nextSibling, _el$10 = _el$1.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$5 = props.class, _v$6 = fill(), _v$7 = theme.colors.constant.white, _v$8 = theme.colors.constant.white;\n      _v$5 !== _p$.e && setAttribute(_el$9, \"class\", _p$.e = _v$5);\n      _v$6 !== _p$.t && setAttribute(_el$0, \"fill\", _p$.t = _v$6);\n      _v$7 !== _p$.a && setAttribute(_el$1, \"fill\", _p$.a = _v$7);\n      _v$8 !== _p$.o && setAttribute(_el$10, \"fill\", _p$.o = _v$8);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0,\n      o: void 0\n    });\n    return _el$9;\n  })() : null);\n};\nconst WALLET_CONNECT_APP_NAME = \"wallet_connect\";\nconst WALLET_CONNECT_WALLET_NAME = \"WalletConnect\";\nconst WALLET_CONNECT_ABOUT_URL = \"https://reown.com/\";\nvar _tmpl$$2 = /* @__PURE__ */ template$1(`<li>`);\nconst AllWalletsListModal = (props) => {\n  const maxHeight = () => isMobile() ? void 0 : 510;\n  const connector = appState.connector;\n  const additionalRequest = appState.connectRequestParameters;\n  const connectWalletConnect = () => {\n    connector.connect({\n      type: \"wallet-connect\"\n    }, (additionalRequest == null ? void 0 : additionalRequest.state) === \"ready\" ? additionalRequest.value : void 0);\n  };\n  const [errorSupportOpened, setErrorSupportOpened] = createSignal(null);\n  let timeoutId = null;\n  const onErrorClick = (wallet) => {\n    setErrorSupportOpened(wallet);\n    if (timeoutId != null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => setErrorSupportOpened(null), 1500);\n  };\n  const handleSelectWallet = (wallet) => {\n    if (!wallet.isSupportRequiredFeatures && props.featureCheckMode === \"strict\") {\n      onErrorClick(wallet);\n      return;\n    }\n    props.onSelect(wallet);\n  };\n  const walletsList = () => isMobile() ? props.walletsList.filter(supportsMobile) : props.walletsList;\n  const supportedWallets = () => walletsList().filter((wallet) => wallet.isSupportRequiredFeatures);\n  setLastVisibleWalletsInfo({\n    walletsMenu: \"other_wallets\",\n    wallets: supportedWallets()\n  });\n  const unsupportedWallets = () => walletsList().filter((wallet) => !wallet.isSupportRequiredFeatures);\n  return createComponent(DesktopSelectWalletModalStyled, {\n    \"data-tc-wallets-modal-list\": \"true\",\n    get children() {\n      return [createComponent(StyledIconButton$5, {\n        icon: \"arrow\",\n        onClick: () => props.onBack()\n      }), createComponent(H1Styled$9, {\n        translationKey: \"walletModal.wallets\",\n        children: \"Wallets\"\n      }), createComponent(ScrollContainer, {\n        get maxHeight() {\n          return maxHeight();\n        },\n        get children() {\n          return [createComponent(WalletsUl, {\n            get children() {\n              return [createComponent(For, {\n                get each() {\n                  return supportedWallets();\n                },\n                children: (wallet) => (() => {\n                  var _el$ = _tmpl$$2();\n                  insert(_el$, createComponent(WalletLabeledItemStyled, {\n                    wallet,\n                    onClick: () => props.onSelect(wallet)\n                  }));\n                  return _el$;\n                })()\n              }), createComponent(Show, {\n                get when() {\n                  return memo(() => !!!isInTMA())() && (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletConnectInitialized)();\n                },\n                get children() {\n                  return createComponent(WalletLabeledItemStyled, {\n                    get wallet() {\n                      return {\n                        type: \"wallet-connect\",\n                        name: WALLET_CONNECT_WALLET_NAME,\n                        appName: WALLET_CONNECT_APP_NAME,\n                        imageUrl: IMG.WALLET_CONNECT\n                      };\n                    },\n                    onClick: connectWalletConnect\n                  });\n                }\n              })];\n            }\n          }), createComponent(Show, {\n            get when() {\n              return unsupportedWallets().length > 0 && props.featureCheckMode !== \"hide\";\n            },\n            get children() {\n              return [createComponent(WalletsNotSupportedNotifier, {\n                get children() {\n                  return [createComponent(WalletsNotSupportedNotifierText, {\n                    translationKey: \"walletModal.allWallets.walletsBelowNotSupported\",\n                    children: \"The wallets below dont support all features of the connected service. You can use your recovery phrase in one of the supported wallets above.\"\n                  }), createComponent(ExclamationIcon, {\n                    size: \"28\"\n                  })];\n                }\n              }), createComponent(WalletsUl, {\n                get children() {\n                  return createComponent(For, {\n                    get each() {\n                      return unsupportedWallets();\n                    },\n                    children: (wallet) => (() => {\n                      var _el$2 = _tmpl$$2();\n                      insert(_el$2, createComponent(WalletLabeledItemStyled, {\n                        wallet,\n                        onClick: () => handleSelectWallet(wallet),\n                        get withOpacity() {\n                          return props.featureCheckMode === \"strict\";\n                        }\n                      }));\n                      return _el$2;\n                    })()\n                  });\n                }\n              }), createComponent(Transition, {\n                onBeforeEnter: (el) => {\n                  animate(el, [{\n                    opacity: 0,\n                    transform: \"translate(-50%, 44px)\"\n                  }, {\n                    opacity: 1,\n                    transform: \"translate(-50%, 0)\"\n                  }], {\n                    duration: 150,\n                    easing: \"ease-out\"\n                  });\n                },\n                onExit: (el, done) => {\n                  animate(el, [{\n                    opacity: 1,\n                    transform: \"translate(-50%, 0)\"\n                  }, {\n                    opacity: 0,\n                    transform: \"translate(-50%, 44px)\"\n                  }], {\n                    duration: 150,\n                    easing: \"ease-out\"\n                  }).finished.then(() => {\n                    done();\n                  });\n                },\n                get children() {\n                  return createComponent(Show, {\n                    get when() {\n                      return errorSupportOpened();\n                    },\n                    get children() {\n                      return createComponent(ErrorBoxStyled, {\n                        get children() {\n                          return [createComponent(ErrorIcon, {\n                            size: \"xs\"\n                          }), createComponent(Text, {\n                            translationKey: \"walletModal.allWallets.walletNotSupportService\",\n                            get translationValues() {\n                              return {\n                                name: errorSupportOpened().name\n                              };\n                            },\n                            get children() {\n                              return [memo(() => errorSupportOpened().name), \" doesnt support connected service\"];\n                            }\n                          })];\n                        }\n                      });\n                    }\n                  });\n                }\n              })];\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst tgButtonBorders = {\n  m: \"16px\",\n  s: \"12px\",\n  none: \"0\"\n};\nconst tgIconBorders = {\n  m: \"6px\",\n  s: \"6px\",\n  none: \"0\"\n};\nconst DesktopConnectionModalStyled = styled.div`\n    display: flex;\n    flex-direction: column;\n`;\nconst BodyStyled$1 = styled.div`\n    flex: 1;\n    margin-top: ${(props) => props.qr ? \"0\" : \"18px\"};\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    min-height: 232px;\n`;\nconst QRCodeStyled$1 = styled(QRCode)`\n    margin-bottom: 24px;\n`;\nconst H1Styled$8 = styled(H1)`\n    max-width: 288px;\n    margin: 0 auto 2px;\n`;\nconst H2Styled$4 = styled(H2)`\n    max-width: 288px;\n    text-align: center;\n    margin: 0 auto 20px;\n`;\nconst StyledIconButton$4 = styled(IconButton)`\n    position: absolute;\n    top: 16px;\n    left: 16px;\n`;\nconst ButtonsContainerStyled$2 = styled.div`\n    display: flex;\n    justify-content: center;\n    gap: 8px;\n    padding-bottom: 16px;\n`;\nconst BottomButtonsContainerStyled = styled(ButtonsContainerStyled$2)`\n    padding-bottom: 0;\n`;\nconst FooterButton$1 = styled(Button)`\n    margin-bottom: 24px;\n`;\nconst LoaderStyled$1 = styled(LoaderIcon)`\n    margin-bottom: 18px;\n    margin-top: 2px;\n`;\nconst ErrorIconStyled$2 = styled(ErrorIcon)`\n    margin-bottom: 16px;\n`;\nconst BodyTextStyled$2 = styled(H2)`\n    color: ${(props) => props.theme.colors.text.secondary};\n    text-align: center;\n    margin-bottom: 20px;\n`;\nconst TgButtonStyled = styled(Button)`\n    margin-top: -8px;\n    margin-bottom: 24px;\n    width: 100%;\n    padding: 12px 12px 12px 20px;\n    border-radius: ${(props) => tgButtonBorders[props.theme.borderRadius]};\n    font-size: 16px;\n    line-height: 20px;\n`;\nconst TgImageStyled = styled(Image)`\n    width: 32px;\n    height: 32px;\n    border-radius: ${(props) => tgIconBorders[props.theme.borderRadius]};\n`;\nconst Translation = (props) => {\n  const [t2] = useI18n();\n  return memo(() => {\n    var _a2;\n    return t2(props.translationKey, props.translationValues, (_a2 = props.children) == null ? void 0 : _a2.toString());\n  });\n};\nfunction addReturnStrategy(url, strategy) {\n  let returnStrategy;\n  if (typeof strategy === \"string\") {\n    returnStrategy = strategy;\n  } else {\n    returnStrategy = isInTMA() ? strategy.twaReturnUrl || strategy.returnStrategy : \"none\";\n  }\n  const newUrl = addQueryParameter(url, \"ret\", returnStrategy);\n  if (!(0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isTelegramUrl)(url)) {\n    return newUrl;\n  }\n  const lastParam = newUrl.slice(newUrl.lastIndexOf(\"&\") + 1);\n  return newUrl.slice(0, newUrl.lastIndexOf(\"&\")) + \"-\" + (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.encodeTelegramUrlParameters)(lastParam);\n}\nfunction redirectToTelegram(universalLink, options) {\n  options = __spreadValues({}, options);\n  const directLink = convertToTGDirectLink(universalLink);\n  const directLinkUrl = new URL(directLink);\n  if (!directLinkUrl.searchParams.has(\"startapp\")) {\n    directLinkUrl.searchParams.append(\"startapp\", \"tonconnect\");\n  }\n  if (isInTelegramBrowser()) {\n    options.returnStrategy = \"back\";\n    const linkWithStrategy = addReturnStrategy(\n      directLinkUrl.toString(),\n      options.returnStrategy\n    );\n    openLinkBlank(linkWithStrategy);\n  } else if (isInTMA()) {\n    if (isTmaPlatform(\"ios\", \"android\", \"macos\", \"tdesktop\", \"web\")) {\n      options.returnStrategy = \"back\";\n      const linkWithStrategy = addReturnStrategy(\n        directLinkUrl.toString(),\n        options.returnStrategy\n      );\n      sendOpenTelegramLink(linkWithStrategy);\n    } else if (isTmaPlatform(\"weba\")) {\n      sendOpenTelegramLink(addReturnStrategy(directLinkUrl.toString(), options));\n    } else {\n      openLinkBlank(addReturnStrategy(directLinkUrl.toString(), options));\n    }\n  } else {\n    if (isOS(\"ios\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"safari\")) {\n          options.returnStrategy = \"back\";\n        } else if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = location.href;\n        }\n      }\n      const isChrome = isBrowser(\"chrome\");\n      const isFirefox = isBrowser(\"firefox\");\n      const useDeepLink = (isChrome || isFirefox) && !options.forceRedirect;\n      if (useDeepLink) {\n        const linkWithStrategy = addReturnStrategy(\n          directLinkUrl.toString(),\n          options.returnStrategy\n        );\n        const deepLink = convertToTGDeepLink(linkWithStrategy);\n        openDeeplinkWithFallback(deepLink, () => openLinkBlank(linkWithStrategy));\n      } else {\n        const linkWithStrategy = addReturnStrategy(\n          directLinkUrl.toString(),\n          options.returnStrategy\n        );\n        openLinkBlank(linkWithStrategy);\n      }\n    } else if (isOS(\"android\")) {\n      options.returnStrategy = \"back\";\n      const isChrome = isBrowser(\"chrome\");\n      const isFirefox = isBrowser(\"firefox\");\n      const useDeepLink = (isChrome || isFirefox) && !options.forceRedirect;\n      if (useDeepLink) {\n        const linkWithStrategy = addReturnStrategy(\n          directLinkUrl.toString(),\n          options.returnStrategy\n        );\n        const deepLink = convertToTGDeepLink(linkWithStrategy);\n        openDeeplinkWithFallback(deepLink, () => openLinkBlank(linkWithStrategy));\n      } else {\n        const linkWithStrategy = addReturnStrategy(\n          directLinkUrl.toString(),\n          options.returnStrategy\n        );\n        openLinkBlank(linkWithStrategy);\n      }\n    } else if (isOS(\"ipad\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"safari\")) {\n          options.returnStrategy = \"back\";\n        } else if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = location.href;\n        }\n      }\n      const isChrome = isBrowser(\"chrome\");\n      const isFirefox = isBrowser(\"firefox\");\n      const useDeepLink = (isChrome || isFirefox) && !options.forceRedirect;\n      const linkWithStrategy = addReturnStrategy(\n        directLinkUrl.toString(),\n        options.returnStrategy\n      );\n      if (useDeepLink) {\n        const deepLink = convertToTGDeepLink(linkWithStrategy);\n        openDeeplinkWithFallback(deepLink, () => openLinkBlank(linkWithStrategy));\n      } else {\n        openLinkBlank(linkWithStrategy);\n      }\n    } else if (isOS(\"macos\", \"windows\", \"linux\")) {\n      options.returnStrategy = \"back\";\n      options.twaReturnUrl = void 0;\n      const linkWithStrategy = addReturnStrategy(\n        directLinkUrl.toString(),\n        options.returnStrategy\n      );\n      if (options.forceRedirect) {\n        openLinkBlank(linkWithStrategy);\n      } else {\n        const deepLink = convertToTGDeepLink(linkWithStrategy);\n        openDeeplinkWithFallback(deepLink, () => openLinkBlank(linkWithStrategy));\n      }\n    } else {\n      openLinkBlank(addReturnStrategy(directLinkUrl.toString(), options));\n    }\n  }\n}\nfunction redirectToWallet(universalLink, deepLink, options, setOpenMethod) {\n  options = __spreadValues({}, options);\n  if (isInTelegramBrowser()) {\n    if (isOS(\"ios\", \"android\")) {\n      if (options.returnStrategy === \"back\") {\n        options.returnStrategy = \"tg://resolve\";\n      }\n      setOpenMethod(\"universal-link\");\n      openLink(addReturnStrategy(universalLink, options.returnStrategy), \"_self\");\n    } else {\n      setOpenMethod(\"universal-link\");\n      const linkWithStrategy = addReturnStrategy(universalLink, options.returnStrategy);\n      openLinkBlank(linkWithStrategy);\n    }\n  } else if (isInTMA()) {\n    if (isTmaPlatform(\"ios\", \"android\")) {\n      if (options.returnStrategy === \"back\") {\n        options.returnStrategy = \"tg://resolve\";\n      }\n      setOpenMethod(\"universal-link\");\n      const linkWithStrategy = addReturnStrategy(universalLink, options.returnStrategy);\n      sendOpenTelegramLink(linkWithStrategy, () => {\n        setOpenMethod(\"universal-link\");\n        openLinkBlank(linkWithStrategy);\n      });\n    } else if (isTmaPlatform(\"macos\", \"tdesktop\")) {\n      if (options.returnStrategy === \"back\") {\n        options.returnStrategy = \"tg://resolve\";\n      }\n      const linkWithStrategy = addReturnStrategy(universalLink, options.returnStrategy);\n      const useDeepLink = !!deepLink && !options.forceRedirect;\n      if (useDeepLink) {\n        setOpenMethod(\"custom-deeplink\");\n        openDeeplinkWithFallback(toDeeplink(linkWithStrategy, deepLink), () => {\n          setOpenMethod(\"universal-link\");\n          openLinkBlank(linkWithStrategy);\n        });\n      } else {\n        setOpenMethod(\"universal-link\");\n        openLinkBlank(linkWithStrategy);\n      }\n    } else if (isTmaPlatform(\"weba\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"safari\")) {\n          options.returnStrategy = location.href;\n        } else if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = location.href;\n        }\n      }\n      const linkWithStrategy = addReturnStrategy(universalLink, options.returnStrategy);\n      const useDeepLink = !!deepLink && !options.forceRedirect;\n      if (useDeepLink) {\n        setOpenMethod(\"custom-deeplink\");\n        openDeeplinkWithFallback(toDeeplink(linkWithStrategy, deepLink), () => {\n          setOpenMethod(\"universal-link\");\n          openLinkBlank(linkWithStrategy);\n        });\n      } else {\n        setOpenMethod(\"universal-link\");\n        openLinkBlank(linkWithStrategy);\n      }\n    } else if (isTmaPlatform(\"web\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"safari\")) {\n          options.returnStrategy = location.href;\n        } else if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = location.href;\n        }\n      }\n      const linkWithStrategy = addReturnStrategy(universalLink, options.returnStrategy);\n      const useDeepLink = !!deepLink && !options.forceRedirect;\n      if (useDeepLink) {\n        setOpenMethod(\"custom-deeplink\");\n        openDeeplinkWithFallback(toDeeplink(linkWithStrategy, deepLink), () => {\n          setOpenMethod(\"universal-link\");\n          openLinkBlank(linkWithStrategy);\n        });\n      } else {\n        setOpenMethod(\"universal-link\");\n        openLinkBlank(linkWithStrategy);\n      }\n    } else {\n      setOpenMethod(\"universal-link\");\n      const linkWithStrategy = addReturnStrategy(universalLink, options.returnStrategy);\n      openLinkBlank(linkWithStrategy);\n    }\n  } else {\n    if (isOS(\"ios\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"safari\")) {\n          options.returnStrategy = \"none\";\n        } else if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = location.href;\n        }\n      }\n      if (isBrowser(\"chrome\")) {\n        setOpenMethod(\"universal-link\");\n        openLink(addReturnStrategy(universalLink, options.returnStrategy), \"_self\");\n      } else {\n        setOpenMethod(\"universal-link\");\n        openLinkBlank(addReturnStrategy(universalLink, options.returnStrategy));\n      }\n    } else if (isOS(\"android\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = location.href;\n        }\n      }\n      setOpenMethod(\"universal-link\");\n      openLinkBlank(addReturnStrategy(universalLink, options.returnStrategy));\n    } else if (isOS(\"ipad\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"safari\")) {\n          options.returnStrategy = \"none\";\n        } else if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = location.href;\n        }\n      }\n      if (isBrowser(\"chrome\")) {\n        setOpenMethod(\"universal-link\");\n        openLink(addReturnStrategy(universalLink, options.returnStrategy), \"_self\");\n      } else {\n        setOpenMethod(\"universal-link\");\n        openLinkBlank(addReturnStrategy(universalLink, options.returnStrategy));\n      }\n    } else if (isOS(\"macos\", \"windows\", \"linux\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"safari\")) {\n          options.returnStrategy = \"none\";\n        } else if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = \"none\";\n        }\n      }\n      const linkWithStrategy = addReturnStrategy(universalLink, options.returnStrategy);\n      const useDeepLink = !!deepLink && !options.forceRedirect;\n      if (useDeepLink) {\n        setOpenMethod(\"custom-deeplink\");\n        openDeeplinkWithFallback(toDeeplink(linkWithStrategy, deepLink), () => {\n          setOpenMethod(\"universal-link\");\n          openLinkBlank(linkWithStrategy);\n        });\n      } else {\n        setOpenMethod(\"universal-link\");\n        openLinkBlank(linkWithStrategy);\n      }\n    } else {\n      setOpenMethod(\"universal-link\");\n      openLinkBlank(addReturnStrategy(universalLink, options.returnStrategy));\n    }\n  }\n}\nfunction enrichUniversalLink(universalLink, params) {\n  var _a2, _b2;\n  if (!(0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isTelegramUrl)(universalLink)) {\n    return addQueryParametersIfNotPresented(universalLink, {\n      id: params.sessionId,\n      trace_id: params.traceId\n    });\n  }\n  const directLink = convertToTGDirectLink(universalLink);\n  const directLinkUrl = new URL(directLink);\n  const previousStartApp = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.decodeTelegramUrlParameters)(\n    (_a2 = directLinkUrl.searchParams.get(\"startapp\")) != null ? _a2 : \"\"\n  );\n  let searchParams = buildSearchParams(previousStartApp);\n  const sessionId = (_b2 = params.sessionId) != null ? _b2 : searchParams.get(\"id\");\n  const traceId = params.traceId;\n  const orderedKeys = [\"tonconnect\", \"v\", \"id\", \"trace_id\"];\n  const unorderedParams = Array.from(searchParams.entries()).filter(\n    ([key]) => !orderedKeys.includes(key)\n  );\n  const startApp = buildQueryParams(__spreadProps(__spreadValues({\n    tonconnect: \"\",\n    v: \"2\",\n    id: sessionId\n  }, Object.fromEntries(unorderedParams)), {\n    trace_id: traceId\n  })).replace(\"=&\", \"&\");\n  directLinkUrl.searchParams.set(\"startapp\", (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.encodeTelegramUrlParameters)(startApp));\n  return directLinkUrl.toString();\n}\nfunction addQueryParameter(url, key, value) {\n  const parsed = new URL(url);\n  parsed.searchParams.append(key, value);\n  return parsed.toString();\n}\nfunction addQueryParametersIfNotPresented(url, params) {\n  const parsed = new URL(url);\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      parsed.searchParams.set(key, value);\n    }\n  }\n  return parsed.toString();\n}\nfunction convertToTGDirectLink(universalLink) {\n  const url = new URL(universalLink);\n  if (url.searchParams.has(\"attach\")) {\n    url.searchParams.delete(\"attach\");\n    url.pathname += \"/start\";\n  }\n  return url.toString();\n}\nfunction buildSearchParams(search = \"\") {\n  const url = new URL(\"https://example.com\");\n  url.search = search;\n  return url.searchParams;\n}\nfunction buildQueryParams(params) {\n  const searchParams = buildSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      searchParams.append(key, value);\n    }\n  }\n  return searchParams.toString();\n}\nfunction convertToTGDeepLink(directLink) {\n  const parsed = new URL(directLink);\n  const [, domain, appname] = parsed.pathname.split(\"/\");\n  const startapp = parsed.searchParams.get(\"startapp\");\n  return `tg://resolve?domain=${domain}&appname=${appname}&startapp=${startapp}`;\n}\nconst DesktopConnectionModal = (props) => {\n  const [mode, setMode] = createSignal(\"mobile\");\n  const [connectionErrored, setConnectionErrored] = createSignal(null);\n  createEffect(() => {\n    var _a2;\n    setConnectionErrored((_a2 = props.defaultError) != null ? _a2 : null);\n  });\n  const [universalLink, setUniversalLink] = createSignal();\n  const [firstClick, setFirstClick] = createSignal(true);\n  const connector = useContext(ConnectorContext);\n  const unsubscribe = connector.onStatusChange(() => {\n  }, (error) => {\n    if (error instanceof _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletMissingRequiredFeaturesError) {\n      setConnectionErrored(\"missing-features\");\n      return;\n    }\n    if (error instanceof _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletWrongNetworkError) {\n      setConnectionErrored(\"wrong-network\");\n      return;\n    }\n    if (props.wallet.appName !== AT_WALLET_APP_NAME) {\n      setConnectionErrored(\"connection-declined\");\n    }\n  });\n  onCleanup(unsubscribe);\n  const generateUniversalLink = () => {\n    var _a2;\n    try {\n      const universalLink2 = connector.connect({\n        universalLink: props.wallet.universalLink,\n        bridgeUrl: props.wallet.bridgeUrl\n      }, props.additionalRequest, {\n        traceId: (_a2 = props.walletsModalState) == null ? void 0 : _a2.traceId\n      });\n      setUniversalLink(universalLink2);\n    } catch (e2) {\n    }\n  };\n  createEffect(() => {\n    if (untrack(mode) !== \"extension\" && (supportsMobile(props.wallet) || supportsDesktop(props.wallet))) {\n      generateUniversalLink();\n    }\n  });\n  const onClickMobile = () => {\n    setConnectionErrored(null);\n    if (mode() === \"extension\") {\n      generateUniversalLink();\n    }\n    setMode(\"mobile\");\n    setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, props.wallet), {\n      openMethod: \"qrcode\"\n    }));\n  };\n  const onClickDesktop = () => {\n    setConnectionErrored(null);\n    if (mode() === \"extension\") {\n      generateUniversalLink();\n    }\n    setMode(\"desktop\");\n    if ((0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isTelegramUrl)(universalLink())) {\n      onClickTelegram();\n    } else {\n      const forceRedirect = !firstClick();\n      setFirstClick(false);\n      redirectToWallet(universalLink(), props.wallet.deepLink, {\n        returnStrategy: appState.returnStrategy,\n        forceRedirect\n      }, (method) => {\n        setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, props.wallet), {\n          openMethod: method\n        }));\n      });\n    }\n  };\n  const onClickTelegram = () => {\n    const forceRedirect = !firstClick();\n    setFirstClick(false);\n    setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, props.wallet), {\n      openMethod: \"universal-link\"\n    }));\n    redirectToTelegram(universalLink(), {\n      returnStrategy: appState.returnStrategy,\n      twaReturnUrl: appState.twaReturnUrl,\n      forceRedirect\n    });\n  };\n  const onClickExtension = () => {\n    var _a2;\n    setConnectionErrored(null);\n    setMode(\"extension\");\n    if ((0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyInjected)(props.wallet)) {\n      setLastSelectedWalletInfo(props.wallet);\n      connector.connect({\n        jsBridgeKey: props.wallet.jsBridgeKey\n      }, props.additionalRequest, {\n        traceId: (_a2 = props.walletsModalState) == null ? void 0 : _a2.traceId\n      });\n    }\n  };\n  if (supportsMobile(props.wallet)) {\n    onClickMobile();\n  } else if (supportsExtension(props.wallet)) {\n    onClickExtension();\n  } else {\n    onClickDesktop();\n  }\n  return createComponent(DesktopConnectionModalStyled, {\n    \"data-tc-wallets-modal-connection-desktop\": \"true\",\n    get children() {\n      return [createComponent(Show, {\n        get when() {\n          return !props.backDisabled;\n        },\n        get children() {\n          return createComponent(StyledIconButton$4, {\n            icon: \"arrow\",\n            onClick: () => props.onBackClick()\n          });\n        }\n      }), createComponent(H1Styled$8, {\n        get children() {\n          return props.wallet.name;\n        }\n      }), createComponent(Show, {\n        get when() {\n          return memo(() => mode() === \"mobile\")() && !connectionErrored();\n        },\n        get children() {\n          return createComponent(H2Styled$4, {\n            translationKey: \"walletModal.desktopConnectionModal.scanQR\",\n            get translationValues() {\n              return {\n                name: props.wallet.name\n              };\n            },\n            get children() {\n              return [\"Scan the QR code below with your phones or \", memo(() => props.wallet.name), \"s camera\"];\n            }\n          });\n        }\n      }), createComponent(BodyStyled$1, {\n        get qr() {\n          return mode() === \"mobile\";\n        },\n        get children() {\n          return createComponent(Switch, {\n            get children() {\n              return [createComponent(Match, {\n                get when() {\n                  return connectionErrored();\n                },\n                get children() {\n                  return [createComponent(ErrorIconStyled$2, {\n                    size: \"s\"\n                  }), createComponent(Switch, {\n                    get children() {\n                      return [createComponent(Match, {\n                        get when() {\n                          return connectionErrored() === \"missing-features\";\n                        },\n                        get children() {\n                          return createComponent(BodyTextStyled$2, {\n                            translationKey: \"walletModal.desktopConnectionModal.missingFeatures\",\n                            get translationValues() {\n                              return {\n                                name: props.wallet.name\n                              };\n                            },\n                            children: \"Please update Wallet, your version does not support required features for this dApp\"\n                          });\n                        }\n                      }), createComponent(Match, {\n                        get when() {\n                          return connectionErrored() === \"connection-declined\";\n                        },\n                        get children() {\n                          return createComponent(BodyTextStyled$2, {\n                            translationKey: \"walletModal.desktopConnectionModal.connectionDeclined\",\n                            children: \"Connection declined\"\n                          });\n                        }\n                      }), createComponent(Match, {\n                        get when() {\n                          return connectionErrored() === \"not-supported\";\n                        },\n                        get children() {\n                          return createComponent(BodyTextStyled$2, {\n                            translationKey: \"walletModal.desktopConnectionModal.notSupportedWallet\",\n                            get translationValues() {\n                              return {\n                                name: props.wallet.name\n                              };\n                            },\n                            get children() {\n                              return [memo(() => props.wallet.name), \" doesnt support the requested action. Please connect another wallet that supports it.\"];\n                            }\n                          });\n                        }\n                      }), createComponent(Match, {\n                        get when() {\n                          return connectionErrored() === \"wrong-network\";\n                        },\n                        get children() {\n                          return createComponent(BodyTextStyled$2, {\n                            translationKey: \"walletModal.desktopConnectionModal.wrongNetwork\",\n                            get translationValues() {\n                              return {\n                                name: props.wallet.name\n                              };\n                            },\n                            get children() {\n                              return [\"Connected wallet is on a different network. Please switch network in \", memo(() => props.wallet.name), \" and try again.\"];\n                            }\n                          });\n                        }\n                      })];\n                    }\n                  }), createComponent(ButtonsContainerStyled$2, {\n                    get children() {\n                      return [createComponent(Show, {\n                        get when() {\n                          return connectionErrored() !== \"not-supported\";\n                        },\n                        get children() {\n                          return createComponent(Button, {\n                            get leftIcon() {\n                              return createComponent(RetryIcon, {});\n                            },\n                            get onClick() {\n                              return mode() === \"extension\" ? onClickExtension : onClickDesktop;\n                            },\n                            get children() {\n                              return createComponent(Translation, {\n                                translationKey: \"common.retry\",\n                                children: \"Retry\"\n                              });\n                            }\n                          });\n                        }\n                      }), createComponent(Show, {\n                        get when() {\n                          return connectionErrored() === \"missing-features\";\n                        },\n                        get children() {\n                          return createComponent(Link, {\n                            get href() {\n                              return props.wallet.aboutUrl;\n                            },\n                            blank: true,\n                            get children() {\n                              return createComponent(Button, {\n                                get leftIcon() {\n                                  return createComponent(LinkIcon, {});\n                                },\n                                get children() {\n                                  return createComponent(Translation, {\n                                    translationKey: \"walletModal.desktopConnectionModal.updateWallet\",\n                                    get translationValues() {\n                                      return {\n                                        name: props.wallet.name\n                                      };\n                                    },\n                                    get children() {\n                                      return [\"Update \", memo(() => props.wallet.name)];\n                                    }\n                                  });\n                                }\n                              });\n                            }\n                          });\n                        }\n                      }), createComponent(Show, {\n                        get when() {\n                          return connectionErrored() === \"not-supported\";\n                        },\n                        get children() {\n                          return createComponent(Button, {\n                            onClick: () => props.onBackClick(),\n                            get children() {\n                              return createComponent(Translation, {\n                                translationKey: \"walletModal.desktopConnectionModal.chooseAnotherWallet\",\n                                children: \"Choose Another Wallet\"\n                              });\n                            }\n                          });\n                        }\n                      })];\n                    }\n                  })];\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return mode() === \"mobile\";\n                },\n                get children() {\n                  return createComponent(QRCodeStyled$1, {\n                    disableCopy: false,\n                    get sourceUrl() {\n                      return addReturnStrategy(universalLink(), \"none\");\n                    },\n                    get imageUrl() {\n                      return props.wallet.imageUrl;\n                    }\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return mode() === \"extension\";\n                },\n                get children() {\n                  return [createComponent(Show, {\n                    get when() {\n                      return (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyInjected)(props.wallet);\n                    },\n                    get children() {\n                      return [createComponent(LoaderStyled$1, {\n                        size: \"s\"\n                      }), createComponent(BodyTextStyled$2, {\n                        translationKey: \"walletModal.desktopConnectionModal.continueInExtension\",\n                        get translationValues() {\n                          return {\n                            name: props.wallet.name\n                          };\n                        },\n                        get children() {\n                          return [\"Continue in \", memo(() => props.wallet.name), \" browser extension\"];\n                        }\n                      }), createComponent(ButtonsContainerStyled$2, {\n                        get children() {\n                          return createComponent(Button, {\n                            get leftIcon() {\n                              return createComponent(RetryIcon, {});\n                            },\n                            onClick: onClickExtension,\n                            get children() {\n                              return createComponent(Translation, {\n                                translationKey: \"common.retry\",\n                                children: \"Retry\"\n                              });\n                            }\n                          });\n                        }\n                      })];\n                    }\n                  }), createComponent(Show, {\n                    get when() {\n                      return !(0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyInjected)(props.wallet);\n                    },\n                    get children() {\n                      return [createComponent(BodyTextStyled$2, {\n                        translationKey: \"walletModal.desktopConnectionModal.dontHaveExtension\",\n                        get translationValues() {\n                          return {\n                            name: props.wallet.name\n                          };\n                        },\n                        get children() {\n                          return [\"Seems you don't have installed \", memo(() => props.wallet.name), \" browser extension\"];\n                        }\n                      }), createComponent(ButtonsContainerStyled$2, {\n                        get children() {\n                          return createComponent(Link, {\n                            get href() {\n                              return props.wallet.aboutUrl;\n                            },\n                            blank: true,\n                            get children() {\n                              return createComponent(Button, {\n                                get rightIcon() {\n                                  return createComponent(LinkIcon, {});\n                                },\n                                onClick: onClickExtension,\n                                get children() {\n                                  return createComponent(Translation, {\n                                    translationKey: \"walletModal.desktopConnectionModal.getWallet\",\n                                    get translationValues() {\n                                      return {\n                                        name: props.wallet.name\n                                      };\n                                    },\n                                    get children() {\n                                      return [\"Get \", memo(() => props.wallet.name)];\n                                    }\n                                  });\n                                }\n                              });\n                            }\n                          });\n                        }\n                      })];\n                    }\n                  })];\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return mode() === \"desktop\";\n                },\n                get children() {\n                  return [createComponent(LoaderIcon, {\n                    size: \"m\"\n                  }), createComponent(BodyTextStyled$2, {\n                    translationKey: \"walletModal.desktopConnectionModal.continueOnDesktop\",\n                    get translationValues() {\n                      return {\n                        name: props.wallet.name\n                      };\n                    },\n                    get children() {\n                      return [\"Continue in \", memo(() => props.wallet.name), \" on desktop\"];\n                    }\n                  }), createComponent(ButtonsContainerStyled$2, {\n                    get children() {\n                      return [createComponent(Button, {\n                        get leftIcon() {\n                          return createComponent(RetryIcon, {});\n                        },\n                        onClick: onClickDesktop,\n                        get children() {\n                          return createComponent(Translation, {\n                            translationKey: \"common.retry\",\n                            children: \"Retry\"\n                          });\n                        }\n                      }), createComponent(Link, {\n                        get href() {\n                          return props.wallet.aboutUrl;\n                        },\n                        blank: true,\n                        get children() {\n                          return createComponent(Button, {\n                            get rightIcon() {\n                              return createComponent(LinkIcon, {});\n                            },\n                            get children() {\n                              return createComponent(Translation, {\n                                translationKey: \"walletModal.desktopConnectionModal.getWallet\",\n                                get translationValues() {\n                                  return {\n                                    name: props.wallet.name\n                                  };\n                                },\n                                get children() {\n                                  return [\"Get \", memo(() => props.wallet.name)];\n                                }\n                              });\n                            }\n                          });\n                        }\n                      })];\n                    }\n                  })];\n                }\n              })];\n            }\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return props.wallet.appName === AT_WALLET_APP_NAME;\n        },\n        get children() {\n          return createComponent(TgButtonStyled, {\n            get rightIcon() {\n              return createComponent(TgImageStyled, {\n                get src() {\n                  return IMG.TG;\n                }\n              });\n            },\n            scale: \"s\",\n            onClick: onClickTelegram,\n            get children() {\n              return createComponent(Translation, {\n                translationKey: \"walletModal.desktopConnectionModal.openWalletOnTelegram\",\n                children: \"Open Wallet in Telegram on desktop\"\n              });\n            }\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return props.wallet.appName !== AT_WALLET_APP_NAME;\n        },\n        get children() {\n          return createComponent(BottomButtonsContainerStyled, {\n            get children() {\n              return [createComponent(Show, {\n                get when() {\n                  return memo(() => mode() !== \"mobile\")() && supportsMobile(props.wallet);\n                },\n                get children() {\n                  return createComponent(FooterButton$1, {\n                    appearance: \"secondary\",\n                    get leftIcon() {\n                      return createComponent(MobileIcon, {});\n                    },\n                    onClick: onClickMobile,\n                    get children() {\n                      return createComponent(Translation, {\n                        translationKey: \"common.mobile\",\n                        children: \"Mobile\"\n                      });\n                    }\n                  });\n                }\n              }), createComponent(Show, {\n                get when() {\n                  return memo(() => mode() !== \"extension\")() && supportsExtension(props.wallet);\n                },\n                get children() {\n                  return createComponent(FooterButton$1, {\n                    appearance: \"secondary\",\n                    get leftIcon() {\n                      return createComponent(BrowserIcon, {});\n                    },\n                    onClick: onClickExtension,\n                    get children() {\n                      return createComponent(Translation, {\n                        translationKey: \"common.browserExtension\",\n                        children: \"Browser Extension\"\n                      });\n                    }\n                  });\n                }\n              }), createComponent(Show, {\n                get when() {\n                  return memo(() => mode() !== \"desktop\")() && supportsDesktop(props.wallet);\n                },\n                get children() {\n                  return createComponent(FooterButton$1, {\n                    appearance: \"secondary\",\n                    get leftIcon() {\n                      return createComponent(DesktopIcon, {});\n                    },\n                    onClick: onClickDesktop,\n                    get children() {\n                      return createComponent(Translation, {\n                        translationKey: \"common.desktop\",\n                        children: \"Desktop\"\n                      });\n                    }\n                  });\n                }\n              })];\n            }\n          });\n        }\n      })];\n    }\n  });\n};\nconst InfoModalStyled = styled.div``;\nconst StyledIconButton$3 = styled(IconButton)`\n    position: absolute;\n    top: 16px;\n    left: 16px;\n`;\nconst H1Styled$7 = styled(H1)`\n    margin-bottom: 18px;\n`;\nconst InfoBlock = styled.div`\n    padding: 16px 0;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n`;\nconst InfoBlockIconClass = u`\n    margin-bottom: 12px;\n`;\nconst H3Styled$1 = styled(H3)`\n    text-align: center;\n    margin-bottom: 4px;\n`;\nconst TextStyled$2 = styled(Text)`\n    text-align: center;\n    max-width: 352px;\n    color: ${(props) => props.theme.colors.text.secondary};\n`;\nconst ButtonsBlock = styled.div`\n    padding: 16px 24px 24px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    gap: 8px;\n`;\nconst LINKS = {\n  GET_A_WALLET: \"https://ton.org/wallets?filters[wallet_features][slug][$in]=dapp-auth&pagination[limit]=-1\"\n};\nconst InfoModal = (props) => {\n  return createComponent(InfoModalStyled, {\n    \"data-tc-wallets-modal-info\": \"true\",\n    get children() {\n      return [createComponent(StyledIconButton$3, {\n        icon: \"arrow\",\n        onClick: () => props.onBackClick()\n      }), createComponent(H1Styled$7, {\n        translationKey: \"walletModal.infoModal.whatIsAWallet\",\n        children: \"What is a wallet\"\n      }), createComponent(ScrollContainer, {\n        get children() {\n          return [createComponent(InfoBlock, {\n            get children() {\n              return [createComponent(SecurityIcon, {\n                \"class\": InfoBlockIconClass\n              }), createComponent(H3Styled$1, {\n                translationKey: \"walletModal.infoModal.secureDigitalAssets\",\n                children: \"Secure digital assets storage\"\n              }), createComponent(TextStyled$2, {\n                translationKey: \"walletModal.infoModal.walletProtects\",\n                children: \"A wallet protects and manages your digital assets including TON, tokens and collectables.\"\n              })];\n            }\n          }), createComponent(InfoBlock, {\n            get children() {\n              return [createComponent(PersonalityIcon, {\n                \"class\": InfoBlockIconClass\n              }), createComponent(H3Styled$1, {\n                translationKey: \"walletModal.infoModal.controlIdentity\",\n                children: \"Control your Web3 identity\"\n              }), createComponent(TextStyled$2, {\n                translationKey: \"walletModal.infoModal.manageIdentity\",\n                children: \"Manage your digital identity and access decentralized applications with ease. Maintain control over your data and engage securely in the blockchain ecosystem.\"\n              })];\n            }\n          }), createComponent(InfoBlock, {\n            get children() {\n              return [createComponent(SwapIcon, {\n                \"class\": InfoBlockIconClass\n              }), createComponent(H3Styled$1, {\n                translationKey: \"walletModal.infoModal.effortlessCryptoTransactions\",\n                children: \"Effortless crypto transactions\"\n              }), createComponent(TextStyled$2, {\n                translationKey: \"walletModal.infoModal.easilySend\",\n                children: \"Easily send, receive, monitor your cryptocurrencies. Streamline your operations with decentralized applications.\"\n              })];\n            }\n          }), createComponent(ButtonsBlock, {\n            get children() {\n              return createComponent(Link, {\n                get href() {\n                  return LINKS.GET_A_WALLET;\n                },\n                blank: true,\n                get children() {\n                  return createComponent(Button, {\n                    get rightIcon() {\n                      return createComponent(WalletIcon, {});\n                    },\n                    get children() {\n                      return createComponent(Translation, {\n                        translationKey: \"walletModal.infoModal.getAWallet\",\n                        children: \"Get a Wallet\"\n                      });\n                    }\n                  });\n                }\n              });\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst MobileConnectionModalStyled = styled.div``;\nconst BodyStyled = styled.div`\n    flex: 1;\n    margin-top: 18px;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    min-height: 232px;\n`;\nconst H1Styled$6 = styled(H1)`\n    max-width: 262px;\n    margin: 0 auto 8px;\n`;\nconst StyledIconButton$2 = styled(IconButton)`\n    position: absolute;\n    top: 16px;\n    left: 16px;\n`;\nconst FooterStyled = styled.div`\n    padding: 16px;\n    display: flex;\n    align-items: center;\n    gap: 12px;\n    border-top: 0.5px solid ${(props) => rgba(props.theme.colors.icon.secondary, 0.2)};\n`;\nconst ImageStyled = styled(Image)`\n    width: 36px;\n    height: 36px;\n    border-radius: 10px;\n`;\nconst FooterButton = styled(Link)`\n    margin-left: auto;\n`;\nconst LoaderStyled = styled(LoaderIcon)`\n    margin-bottom: 18px;\n    margin-top: 2px;\n`;\nconst ErrorIconStyled$1 = styled(ErrorIcon)`\n    margin-bottom: 16px;\n`;\nconst BodyTextStyled$1 = styled(H2)`\n    color: ${(props) => props.theme.colors.text.secondary};\n    text-align: center;\n    margin-bottom: 20px;\n`;\nconst ButtonsContainerStyled$1 = styled.div`\n    display: flex;\n    justify-content: center;\n    gap: 8px;\n    padding-bottom: 16px;\n`;\nconst actionButtonBorderRadius$1 = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst H1Styled$5 = styled(H1)`\n    margin-bottom: 2px;\n    padding: 0 52px;\n`;\nconst H2Styled$3 = styled(H2)`\n    margin-bottom: 20px;\n    padding: 0 64px;\n`;\nconst QrCodeWrapper$1 = styled.div`\n    padding: 0 24px 16px;\n`;\nconst ButtonsWrapper$1 = styled.div`\n    display: flex;\n    flex-direction: row;\n    gap: 16px;\n    padding: 0 24px 24px;\n    margin-top: 0;\n`;\nconst ActionButton$1 = styled(Button)`\n    width: 100%;\n    height: 56px;\n    border-radius: ${(props) => actionButtonBorderRadius$1[props.theme.borderRadius]};\n    background-color: ${(props) => rgba(props.theme.colors.accent, 0.12)};\n    color: ${(props) => props.theme.colors.accent};\n    font-size: 16px;\n    line-height: 20px;\n    font-weight: 500;\n    padding: 17px 20px 19px 20px;\n`;\nconst MobileConnectionQR = (props) => {\n  return [createComponent(H1Styled$5, {\n    get children() {\n      return props.walletInfo.name;\n    }\n  }), createComponent(H2Styled$3, {\n    translationKey: \"walletModal.mobileConnectionModal.scanQR\",\n    get translationValues() {\n      return {\n        name: props.walletInfo.name\n      };\n    },\n    get children() {\n      return [\"Scan the QR code below with your phones or \", memo(() => props.walletInfo.name), \"s camera\"];\n    }\n  }), createComponent(QrCodeWrapper$1, {\n    get children() {\n      return createComponent(QRCode, {\n        get imageUrl() {\n          return props.walletInfo.imageUrl;\n        },\n        get sourceUrl() {\n          return addReturnStrategy(props.universalLink, \"none\");\n        },\n        disableCopy: true\n      });\n    }\n  }), createComponent(ButtonsWrapper$1, {\n    get children() {\n      return [createComponent(ActionButton$1, {\n        appearance: \"secondary\",\n        onClick: () => {\n          var _a2;\n          return (_a2 = props.onOpenLink) == null ? void 0 : _a2.call(props);\n        },\n        get children() {\n          return createComponent(Translation, {\n            translationKey: \"walletModal.mobileUniversalModal.openLink\",\n            children: \"Open Link\"\n          });\n        }\n      }), createComponent(ActionButton$1, {\n        appearance: \"secondary\",\n        onClick: () => {\n          var _a2;\n          return (_a2 = props.onCopy) == null ? void 0 : _a2.call(props);\n        },\n        get children() {\n          return createComponent(Translation, {\n            get translationKey() {\n              return props.isCopiedShown !== void 0 ? \"common.copied\" : \"common.copyLink\";\n            },\n            get children() {\n              return props.isCopiedShown !== void 0 ? \"Copied\" : \"Copy Link\";\n            }\n          });\n        }\n      })];\n    }\n  })];\n};\nconst MobileConnectionModal = (props) => {\n  const theme = useTheme();\n  const [firstClick, setFirstClick] = createSignal(true);\n  const [showQR, setShowQR] = createSignal(false);\n  const [connectionErrored, setConnectionErrored] = createSignal(null);\n  createEffect(() => {\n    var _a2;\n    setConnectionErrored((_a2 = props.defaultError) != null ? _a2 : null);\n  });\n  const connector = useContext(ConnectorContext);\n  const unsubscribe = connector.onStatusChange(() => {\n  }, (error) => {\n    if (error instanceof _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletMissingRequiredFeaturesError) {\n      setConnectionErrored(\"missing-features\");\n      return;\n    }\n    if (error instanceof _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletWrongNetworkError) {\n      setConnectionErrored(\"wrong-network\");\n      return;\n    }\n    setConnectionErrored(null);\n  });\n  const universalLink = createMemo(() => {\n    var _a2;\n    return connector.connect({\n      universalLink: props.wallet.universalLink,\n      bridgeUrl: props.wallet.bridgeUrl\n    }, props.additionalRequest, {\n      traceId: (_a2 = props.walletModalState) == null ? void 0 : _a2.traceId\n    });\n  });\n  const onClickTelegram = () => {\n    const alwaysForceRedirect = true;\n    setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, props.wallet), {\n      openMethod: \"universal-link\"\n    }));\n    redirectToTelegram(universalLink(), {\n      returnStrategy: appState.returnStrategy,\n      twaReturnUrl: appState.twaReturnUrl,\n      forceRedirect: alwaysForceRedirect\n    });\n  };\n  const onRetry = () => {\n    const currentUniversalLink = universalLink();\n    if ((0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isTelegramUrl)(currentUniversalLink)) {\n      return onClickTelegram();\n    }\n    setConnectionErrored(null);\n    const forceRedirect = !firstClick();\n    setFirstClick(false);\n    redirectToWallet(universalLink(), props.wallet.deepLink, {\n      returnStrategy: appState.returnStrategy,\n      forceRedirect\n    }, (method) => {\n      setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, props.wallet), {\n        openMethod: method\n      }));\n    });\n  };\n  const [isCopiedShown, setIsCopiedShown] = createSignal(void 0);\n  const onCopy = () => __async(null, null, function* () {\n    if (isCopiedShown() !== void 0) {\n      clearTimeout(isCopiedShown());\n    }\n    yield copyToClipboard(universalLink());\n    const timeoutId = setTimeout(() => setIsCopiedShown(void 0), 1500);\n    setIsCopiedShown(timeoutId);\n  });\n  const onOpenQR = () => {\n    setConnectionErrored(null);\n    setShowQR(true);\n    setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, props.wallet), {\n      openMethod: \"qrcode\"\n    }));\n  };\n  const onCloseQR = () => {\n    setShowQR(false);\n    setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, props.wallet), {\n      openMethod: \"universal-link\"\n    }));\n  };\n  const onBack = () => {\n    if (showQR()) {\n      onCloseQR();\n    } else {\n      props.onBackClick();\n    }\n  };\n  onCleanup(unsubscribe);\n  onRetry();\n  return createComponent(MobileConnectionModalStyled, {\n    \"data-tc-wallets-modal-connection-mobile\": \"true\",\n    get children() {\n      return [createComponent(Show, {\n        get when() {\n          return !props.backDisabled || showQR();\n        },\n        get children() {\n          return createComponent(StyledIconButton$2, {\n            icon: \"arrow\",\n            onClick: onBack\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return showQR();\n        },\n        get children() {\n          return createComponent(MobileConnectionQR, {\n            get universalLink() {\n              return universalLink();\n            },\n            get walletInfo() {\n              return props.wallet;\n            },\n            onOpenLink: onRetry,\n            onCopy,\n            get isCopiedShown() {\n              return isCopiedShown();\n            }\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !showQR();\n        },\n        get children() {\n          return [createComponent(H1Styled$6, {\n            get children() {\n              return props.wallet.name;\n            }\n          }), createComponent(BodyStyled, {\n            get children() {\n              return [createComponent(Show, {\n                get when() {\n                  return connectionErrored();\n                },\n                get children() {\n                  return [createComponent(ErrorIconStyled$1, {\n                    size: \"s\"\n                  }), createComponent(Switch, {\n                    get children() {\n                      return [createComponent(Match, {\n                        get when() {\n                          return connectionErrored() === \"missing-features\";\n                        },\n                        get children() {\n                          return createComponent(BodyTextStyled$1, {\n                            translationKey: \"walletModal.mobileConnectionModal.missingFeatures\",\n                            get translationValues() {\n                              return {\n                                name: props.wallet.name\n                              };\n                            },\n                            children: \"Please update Wallet, your version does not support required features for this dApp\"\n                          });\n                        }\n                      }), createComponent(Match, {\n                        get when() {\n                          return connectionErrored() === \"connection-declined\";\n                        },\n                        get children() {\n                          return createComponent(BodyTextStyled$1, {\n                            translationKey: \"walletModal.mobileConnectionModal.connectionDeclined\",\n                            children: \"Connection declined\"\n                          });\n                        }\n                      }), createComponent(Match, {\n                        get when() {\n                          return connectionErrored() === \"wrong-network\";\n                        },\n                        get children() {\n                          return createComponent(BodyTextStyled$1, {\n                            translationKey: \"walletModal.mobileConnectionModal.wrongNetwork\",\n                            get translationValues() {\n                              return {\n                                name: props.wallet.name\n                              };\n                            },\n                            get children() {\n                              return [\"Connected wallet is on a different network. Please switch network in \", memo(() => props.wallet.name), \" and try again.\"];\n                            }\n                          });\n                        }\n                      }), createComponent(Match, {\n                        get when() {\n                          return connectionErrored() === \"not-supported\";\n                        },\n                        get children() {\n                          return createComponent(BodyTextStyled$1, {\n                            translationKey: \"walletModal.mobileConnectionModal.notSupportedWallet\",\n                            get translationValues() {\n                              return {\n                                name: props.wallet.name\n                              };\n                            },\n                            get children() {\n                              return [memo(() => props.wallet.name), \" doesn't support the requested action. Please connect another wallet that supports it.\"];\n                            }\n                          });\n                        }\n                      })];\n                    }\n                  }), createComponent(ButtonsContainerStyled$1, {\n                    get children() {\n                      return createComponent(Switch, {\n                        get children() {\n                          return [createComponent(Match, {\n                            get when() {\n                              return connectionErrored() === \"missing-features\";\n                            },\n                            get children() {\n                              return [createComponent(Button, {\n                                get leftIcon() {\n                                  return createComponent(RetryIcon, {});\n                                },\n                                onClick: onRetry,\n                                get children() {\n                                  return createComponent(Translation, {\n                                    translationKey: \"common.retry\",\n                                    children: \"Retry\"\n                                  });\n                                }\n                              }), createComponent(Link, {\n                                get href() {\n                                  return props.wallet.aboutUrl;\n                                },\n                                blank: true,\n                                get children() {\n                                  return createComponent(Button, {\n                                    get leftIcon() {\n                                      return createComponent(LinkIcon, {});\n                                    },\n                                    get children() {\n                                      return createComponent(Translation, {\n                                        translationKey: \"walletModal.mobileConnectionModal.updateWallet\",\n                                        get translationValues() {\n                                          return {\n                                            name: props.wallet.name\n                                          };\n                                        },\n                                        get children() {\n                                          return [\"Update \", memo(() => props.wallet.name)];\n                                        }\n                                      });\n                                    }\n                                  });\n                                }\n                              })];\n                            }\n                          }), createComponent(Match, {\n                            get when() {\n                              return connectionErrored() === \"not-supported\";\n                            },\n                            get children() {\n                              return createComponent(Button, {\n                                onClick: () => props.onBackClick(),\n                                get children() {\n                                  return createComponent(Translation, {\n                                    translationKey: \"walletModal.mobileConnectionModal.chooseAnotherWallet\",\n                                    children: \"Choose Another Wallet\"\n                                  });\n                                }\n                              });\n                            }\n                          }), createComponent(Match, {\n                            get when() {\n                              return connectionErrored() === \"wrong-network\";\n                            },\n                            get children() {\n                              return createComponent(Button, {\n                                get leftIcon() {\n                                  return createComponent(RetryIcon, {});\n                                },\n                                onClick: onRetry,\n                                get children() {\n                                  return createComponent(Translation, {\n                                    translationKey: \"common.retry\",\n                                    children: \"Retry\"\n                                  });\n                                }\n                              });\n                            }\n                          }), createComponent(Match, {\n                            get when() {\n                              return connectionErrored() === \"connection-declined\";\n                            },\n                            get children() {\n                              return [createComponent(Button, {\n                                get leftIcon() {\n                                  return createComponent(RetryIcon, {});\n                                },\n                                onClick: onRetry,\n                                get children() {\n                                  return createComponent(Translation, {\n                                    translationKey: \"common.retry\",\n                                    children: \"Retry\"\n                                  });\n                                }\n                              }), createComponent(Button, {\n                                get leftIcon() {\n                                  return createComponent(QRIcon, {\n                                    get fill() {\n                                      return theme.colors.accent;\n                                    }\n                                  });\n                                },\n                                onClick: onOpenQR,\n                                get children() {\n                                  return createComponent(Translation, {\n                                    translationKey: \"walletModal.mobileConnectionModal.showQR\",\n                                    children: \"Show QR Code\"\n                                  });\n                                }\n                              })];\n                            }\n                          })];\n                        }\n                      });\n                    }\n                  })];\n                }\n              }), createComponent(Show, {\n                get when() {\n                  return !connectionErrored();\n                },\n                get children() {\n                  return [createComponent(LoaderStyled, {\n                    size: \"s\"\n                  }), createComponent(BodyTextStyled$1, {\n                    translationKey: \"walletModal.mobileConnectionModal.continueIn\",\n                    get translationValues() {\n                      return {\n                        name: props.wallet.name\n                      };\n                    },\n                    get children() {\n                      return [\"Continue in \", memo(() => props.wallet.name), \"\"];\n                    }\n                  }), createComponent(ButtonsContainerStyled$1, {\n                    get children() {\n                      return [createComponent(Button, {\n                        get leftIcon() {\n                          return createComponent(RetryIcon, {});\n                        },\n                        onClick: onRetry,\n                        get children() {\n                          return createComponent(Translation, {\n                            translationKey: \"common.retry\",\n                            children: \"Retry\"\n                          });\n                        }\n                      }), createComponent(Button, {\n                        get leftIcon() {\n                          return createComponent(QRIcon, {\n                            get fill() {\n                              return theme.colors.accent;\n                            }\n                          });\n                        },\n                        onClick: onOpenQR,\n                        get children() {\n                          return createComponent(Translation, {\n                            translationKey: \"walletModal.mobileConnectionModal.showQR\",\n                            children: \"Show QR Code\"\n                          });\n                        }\n                      })];\n                    }\n                  })];\n                }\n              })];\n            }\n          }), createComponent(FooterStyled, {\n            get children() {\n              return [createComponent(ImageStyled, {\n                get src() {\n                  return props.wallet.imageUrl;\n                }\n              }), createComponent(H3, {\n                get children() {\n                  return props.wallet.name;\n                }\n              }), createComponent(FooterButton, {\n                get href() {\n                  return props.wallet.aboutUrl;\n                },\n                blank: true,\n                get children() {\n                  return createComponent(Button, {\n                    get children() {\n                      return createComponent(Translation, {\n                        translationKey: \"common.get\",\n                        children: \"GET\"\n                      });\n                    }\n                  });\n                }\n              })];\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst borders$2 = {\n  m: \"16px\",\n  s: \"12px\",\n  none: \"0\"\n};\nconst tgBorders = {\n  m: \"6px\",\n  s: \"6px\",\n  none: \"0\"\n};\nstyled.li`\n    width: 82px;\n    min-width: 82px;\n    height: 124px;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    padding: 8px 4px;\n\n    text-align: center;\n    cursor: pointer;\n\n    transition: transform 0.1s ease-in-out;\n\n    ${mediaNotTouch} {\n        &:hover {\n            transform: scale(1.04);\n        }\n    }\n\n    &:active {\n        transform: scale(0.96);\n    }\n\n    ${mediaTouch} {\n        &:active {\n            transform: scale(0.92);\n        }\n    }\n`;\nconst H1Styled$4 = styled(H1)`\n    margin-top: 38px;\n    margin-bottom: 4px;\n    padding: 0 24px;\n`;\nconst H2Styled$2 = styled(H2)`\n    margin: ${(props) => {\n  var _a2;\n  return (_a2 = props.margin) != null ? _a2 : \"0 0 28px 0\";\n}};\n    padding: ${(props) => {\n  var _a2;\n  return (_a2 = props.padding) != null ? _a2 : \"0 24px\";\n}};\n    min-height: ${(props) => {\n  var _a2;\n  return (_a2 = props.padding) != null ? _a2 : \"44px\";\n}};\n    max-width: ${(props) => props.maxWidth}px;\n    margin-left: ${(props) => props.maxWidth ? \"auto\" : \"0px\"};\n    margin-right: ${(props) => props.maxWidth ? \"auto\" : \"0px\"};\n`;\nstyled(Button)`\n    display: block;\n    margin: 0 auto;\n`;\nconst TelegramButtonStyled = styled(Button)`\n    margin: 0 28px 24px;\n    width: calc(100% - 56px);\n    border-radius: ${(props) => borders$2[props.theme.borderRadius]};\n    padding: 14px 16px 14px 14px;\n    background-color: ${(props) => props.theme.colors.telegramButton};\n\n    color: ${(props) => props.theme.colors.constant.white};\n    font-weight: 500;\n    font-size: 16px;\n    line-height: 20px;\n\n    @media (max-width: 375px) {\n        margin: 0 16px 24px;\n        width: calc(100% - 32px);\n    }\n`;\nconst TGImageStyled = styled(Image)`\n    background-color: transparent;\n    border-radius: ${(props) => tgBorders[props.theme.borderRadius]};\n    width: 24px;\n    height: 24px;\n`;\nconst StyledLeftActionButton = styled(IconButton)`\n    position: absolute;\n    top: 16px;\n    left: 16px;\n`;\nconst actionButtonBorderRadius = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst H1Styled$3 = styled(H1)`\n    margin-bottom: 2px;\n    padding: 0 52px;\n`;\nconst H2Styled$1 = styled(H2)`\n    margin-bottom: 20px;\n    padding: 0 64px;\n`;\nconst QrCodeWrapper = styled.div`\n    padding: 0 24px 16px;\n`;\nconst ButtonsWrapper = styled.div`\n    display: flex;\n    flex-direction: row;\n    gap: 16px;\n    padding: 0 24px 24px;\n    margin-top: 0;\n`;\nconst ActionButton = styled(Button)`\n    width: 100%;\n    height: 56px;\n    border-radius: ${(props) => actionButtonBorderRadius[props.theme.borderRadius]};\n    background-color: ${(props) => rgba(props.theme.colors.accent, 0.12)};\n    color: ${(props) => props.theme.colors.accent};\n    font-size: 16px;\n    line-height: 20px;\n    font-weight: 500;\n    padding: 17px 20px 19px 20px;\n`;\nconst MobileUniversalQR = (props) => {\n  return [createComponent(H1Styled$3, {\n    translationKey: \"walletModal.mobileUniversalModal.connectYourWallet\",\n    children: \"Connect your TON wallet\"\n  }), createComponent(H2Styled$1, {\n    translationKey: \"walletModal.mobileUniversalModal.scan\",\n    children: \"Scan with your mobile wallet\"\n  }), createComponent(QrCodeWrapper, {\n    get children() {\n      return createComponent(QRCode, {\n        get imageUrl() {\n          return IMG.TON;\n        },\n        get sourceUrl() {\n          return addReturnStrategy(props.universalLink, \"none\");\n        },\n        disableCopy: true\n      });\n    }\n  }), createComponent(ButtonsWrapper, {\n    get children() {\n      return [createComponent(ActionButton, {\n        appearance: \"secondary\",\n        onClick: () => props.onOpenLink(),\n        get children() {\n          return createComponent(Translation, {\n            translationKey: \"walletModal.mobileUniversalModal.openLink\",\n            children: \"Open Link\"\n          });\n        }\n      }), createComponent(ActionButton, {\n        appearance: \"secondary\",\n        onClick: () => props.onCopy(),\n        get children() {\n          return createComponent(Translation, {\n            get translationKey() {\n              return props.isCopiedShown !== void 0 ? \"common.copied\" : \"common.copyLink\";\n            },\n            get children() {\n              return props.isCopiedShown !== void 0 ? \"Copied\" : \"Copy Link\";\n            }\n          });\n        }\n      })];\n    }\n  })];\n};\nfunction getUniqueBridges(walletsList) {\n  const uniqueBridges = new Set(\n    walletsList.filter(_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoRemote).map((item) => item.bridgeUrl)\n  );\n  return Array.from(uniqueBridges).map((bridgeUrl) => ({ bridgeUrl }));\n}\nfunction bridgesIsEqual(left, right) {\n  const leftSet = new Set(left == null ? void 0 : left.map((i2) => i2.bridgeUrl));\n  const rightSet = new Set(right == null ? void 0 : right.map((i2) => i2.bridgeUrl));\n  return leftSet.size === rightSet.size && [...leftSet].every((value) => rightSet.has(value));\n}\nvar _tmpl$$1 = /* @__PURE__ */ template$1(`<li>`), _tmpl$2 = /* @__PURE__ */ template$1(`<div data-tc-wallets-modal-universal-mobile=true>`);\nconst MobileUniversalModal = (props) => {\n  const [showQR, setShowQR] = createSignal(false);\n  const [firstClick, setFirstClick] = createSignal(true);\n  const [universalLink, setUniversalLink] = createSignal(null);\n  const connector = appState.connector;\n  const walletsList = () => props.walletsList.filter((w) => supportsMobile(w) && w.appName !== AT_WALLET_APP_NAME);\n  const shouldShowMoreButton = () => walletsList().length > 7;\n  const walletsBridges = createMemo(() => getUniqueBridges(props.walletsList), null, {\n    equals: bridgesIsEqual\n  });\n  const atWalletSupportFeatures = createMemo(() => {\n    var _a2, _b2;\n    return (_b2 = (_a2 = props.walletsList.find((wallet) => wallet.appName === AT_WALLET_APP_NAME)) == null ? void 0 : _a2.isSupportRequiredFeatures) != null ? _b2 : false;\n  }, null);\n  const getUniversalLink = () => {\n    if (!universalLink()) {\n      setUniversalLink(connector.connect(walletsBridges(), props.additionalRequest, {\n        traceId: props.walletModalState.traceId\n      }));\n    }\n    return universalLink();\n  };\n  setLastSelectedWalletInfo({\n    openMethod: \"universal-link\"\n  });\n  const [isCopiedShown, setIsCopiedShown] = createSignal(void 0);\n  const onCopy = () => __async(null, null, function* () {\n    if (isCopiedShown() !== void 0) {\n      clearTimeout(isCopiedShown());\n    }\n    yield copyToClipboard(getUniversalLink());\n    const timeoutId = setTimeout(() => setIsCopiedShown(void 0), 1500);\n    setIsCopiedShown(timeoutId);\n  });\n  const onSelectUniversal = () => {\n    const forceRedirect = !firstClick();\n    setFirstClick(false);\n    redirectToWallet(getUniversalLink(), void 0, {\n      returnStrategy: appState.returnStrategy,\n      forceRedirect\n    }, (method) => {\n      setLastSelectedWalletInfo({\n        openMethod: method\n      });\n    });\n  };\n  const onSelectTelegram = () => {\n    setUniversalLink(null);\n    const atWallet = props.walletsList.find((wallet) => wallet.appName === AT_WALLET_APP_NAME);\n    if (!atWallet || !(0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoRemote)(atWallet)) {\n      throw new TonConnectUIError(\"@wallet bot not found in the wallets list\");\n    }\n    const walletLink = connector.connect({\n      bridgeUrl: atWallet.bridgeUrl,\n      universalLink: atWallet.universalLink\n    }, props.additionalRequest, {\n      traceId: props.walletModalState.traceId\n    });\n    const forceRedirect = !firstClick();\n    setFirstClick(false);\n    redirectToTelegram(walletLink, {\n      returnStrategy: appState.returnStrategy,\n      twaReturnUrl: appState.twaReturnUrl,\n      forceRedirect\n    });\n  };\n  const onOpenQR = () => {\n    setShowQR(true);\n    setLastSelectedWalletInfo({\n      openMethod: \"qrcode\"\n    });\n  };\n  const onCloseQR = () => {\n    setShowQR(false);\n    setLastSelectedWalletInfo({\n      openMethod: \"universal-link\"\n    });\n  };\n  const supportedWallets = createMemo(() => walletsList().filter((wallet) => wallet.isSupportRequiredFeatures), null);\n  const visibleWallets = createMemo(() => supportedWallets().slice(0, 3), null);\n  setLastVisibleWalletsInfo({\n    walletsMenu: \"main_screen\",\n    wallets: atWalletSupportFeatures() ? [props.walletsList.find((wallet) => wallet.appName === AT_WALLET_APP_NAME), ...visibleWallets()] : visibleWallets()\n  });\n  const fourWalletsItem = createMemo(() => walletsList().filter((wallet) => !visibleWallets().find((w) => w.appName === wallet.appName)).slice(0, 4), null);\n  return (() => {\n    var _el$ = _tmpl$2();\n    insert(_el$, createComponent(Show, {\n      get when() {\n        return showQR();\n      },\n      get children() {\n        return [createComponent(StyledLeftActionButton, {\n          icon: \"arrow\",\n          onClick: onCloseQR\n        }), createComponent(MobileUniversalQR, {\n          get universalLink() {\n            return getUniversalLink();\n          },\n          get isCopiedShown() {\n            return isCopiedShown();\n          },\n          onOpenLink: onSelectUniversal,\n          onCopy\n        })];\n      }\n    }), null);\n    insert(_el$, createComponent(Show, {\n      get when() {\n        return !showQR();\n      },\n      get children() {\n        return [createComponent(StyledLeftActionButton, {\n          get icon() {\n            return createComponent(QRIcon, {});\n          },\n          onClick: onOpenQR\n        }), createComponent(H1Styled$4, {\n          translationKey: \"walletModal.mobileUniversalModal.connectYourWallet\",\n          children: \"Connect your TON wallet\"\n        }), createComponent(Show, {\n          get when() {\n            return atWalletSupportFeatures();\n          },\n          get children() {\n            return [createComponent(H2Styled$2, {\n              translationKey: \"walletModal.mobileUniversalModal.openWalletOnTelegramOrSelect\",\n              maxWidth: 320,\n              children: \"Use Wallet in Telegram or choose other application\"\n            }), createComponent(TelegramButtonStyled, {\n              get leftIcon() {\n                return createComponent(AtWalletIcon, {});\n              },\n              get rightIcon() {\n                return createComponent(TGImageStyled, {\n                  get src() {\n                    return IMG.TG;\n                  }\n                });\n              },\n              onClick: onSelectTelegram,\n              scale: \"s\",\n              get children() {\n                return createComponent(Translation, {\n                  translationKey: \"walletModal.mobileUniversalModal.openWalletOnTelegram\",\n                  children: \"Connect Wallet in Telegram\"\n                });\n              }\n            })];\n          }\n        }), createComponent(H2Styled$2, {\n          translationKey: \"walletModal.mobileUniversalModal.chooseOtherApplication\",\n          maxWidth: 342,\n          padding: \"0 24px 8px 24px\",\n          margin: \"0\",\n          children: \"Choose other application\"\n        }), createComponent(WalletUlContainer, {\n          get children() {\n            return [createComponent(For, {\n              get each() {\n                return memo(() => !!shouldShowMoreButton())() ? visibleWallets() : supportedWallets();\n              },\n              children: (wallet) => (() => {\n                var _el$3 = _tmpl$$1();\n                insert(_el$3, createComponent(WalletItem, {\n                  get icon() {\n                    return wallet.imageUrl;\n                  },\n                  get name() {\n                    return wallet.name;\n                  },\n                  onClick: () => props.onSelect(wallet)\n                }));\n                return _el$3;\n              })()\n            }), createComponent(Show, {\n              get when() {\n                return shouldShowMoreButton();\n              },\n              get children() {\n                var _el$2 = _tmpl$$1();\n                insert(_el$2, createComponent(FourWalletsItem, {\n                  labelLine1: \"View all\",\n                  labelLine2: \"wallets\",\n                  get images() {\n                    return fourWalletsItem().map((i2) => i2.imageUrl);\n                  },\n                  onClick: () => props.onSelectAllWallets()\n                }));\n                return _el$2;\n              }\n            })];\n          }\n        })];\n      }\n    }), null);\n    return _el$;\n  })();\n};\nconst borders$1 = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst hoverBorders = {\n  m: \"8px\",\n  s: \"4px\",\n  none: \"0\"\n};\nconst DesktopUniversalModalStyled = styled.div`\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    padding-bottom: 16px;\n`;\nconst H2Styled = styled(H2)`\n    max-width: 320px;\n    margin-top: 2px;\n    margin-bottom: 20px;\n`;\nconst H2AvailableWalletsStyled = styled(H2)`\n    margin-bottom: 16px;\n`;\nconst QRCodeStyled = styled(QRCode)`\n    margin-bottom: 24px;\n`;\nconst WalletsContainerStyled = styled.ul`\n    display: flex;\n`;\nstyled.div`\n    display: flex;\n    gap: 16px;\n    width: 100%;\n`;\nstyled(Button)`\n    position: relative;\n    font-size: 16px;\n    line-height: 20px;\n    width: 100%;\n    padding: 0 16px;\n    height: 56px;\n    border-radius: ${(props) => borders$1[props.theme.borderRadius]};\n\n    &:hover {\n        ${(props) => props.disableEventsAnimation ? \"transform: unset;\" : \"\"}\n    }\n\n    &:active {\n        ${(props) => props.disableEventsAnimation ? \"transform: unset;\" : \"\"}\n    }\n`;\nstyled.ul`\n    position: absolute;\n    bottom: 100%;\n    left: 0;\n    margin: 0;\n    padding: 8px;\n    width: 188px;\n    transform: translateY(-16px);\n\n    background-color: ${(props) => props.theme.colors.background.primary};\n    border-radius: ${(props) => borders$1[props.theme.borderRadius]};\n    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);\n`;\nstyled.li`\n    padding: 8px;\n\n    display: flex;\n    align-items: center;\n    gap: 8px;\n\n    cursor: pointer;\n    border-radius: ${(props) => hoverBorders[props.theme.borderRadius]};\n\n    transition:\n        background-color,\n        transform 0.1s ease-in-out;\n\n    &:hover {\n        background-color: ${(props) => props.theme.colors.background.secondary};\n    }\n\n    &:active {\n        transform: scale(0.96);\n    }\n`;\nstyled(Image)`\n    width: 24px;\n    height: 24px;\n\n    border-radius: 6px;\n`;\nstyled.div`\n    margin-top: 23px;\n    margin-bottom: 1px;\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n`;\nstyled(Text)`\n    color: ${(props) => props.theme.colors.text.secondary};\n    font-size: 16px;\n`;\nvar _tmpl$ = /* @__PURE__ */ template$1(`<li>`);\nconst DesktopUniversalModal = (props) => {\n  const [popupOpened, setPopupOpened] = createSignal(false);\n  const connector = appState.connector;\n  const walletsBridges = createMemo(() => getUniqueBridges(props.walletsList), null, {\n    equals: bridgesIsEqual\n  });\n  setLastSelectedWalletInfo({\n    openMethod: \"qrcode\"\n  });\n  const request = createMemo(() => connector.connect(walletsBridges(), props.additionalRequest, {\n    traceId: props.walletModalState.traceId\n  }));\n  const supportedWallets = createMemo(() => props.walletsList.filter((wallet) => wallet.isSupportRequiredFeatures), null);\n  const visibleWallets = createMemo(() => supportedWallets().slice(0, 3), null);\n  setLastVisibleWalletsInfo({\n    walletsMenu: \"main_screen\",\n    wallets: visibleWallets()\n  });\n  const fourWalletsItem = createMemo(() => props.walletsList.filter((wallet) => !visibleWallets().find((w) => w.appName === wallet.appName)).slice(0, 4), null);\n  return createComponent(DesktopUniversalModalStyled, {\n    onClick: () => setPopupOpened(false),\n    \"data-tc-wallets-modal-universal-desktop\": \"true\",\n    get children() {\n      return [createComponent(H1, {\n        translationKey: \"walletModal.desktopUniversalModal.connectYourWallet\",\n        children: \"Connect your wallet\"\n      }), createComponent(H2Styled, {\n        translationKey: \"walletModal.desktopUniversalModal.scan\",\n        children: \"Scan with your mobile wallet\"\n      }), createComponent(QRCodeStyled, {\n        get sourceUrl() {\n          return addReturnStrategy(request(), \"none\");\n        },\n        get disableCopy() {\n          return popupOpened();\n        },\n        get imageUrl() {\n          return IMG.TON;\n        }\n      }), createComponent(H2AvailableWalletsStyled, {\n        translationKey: \"walletModal.desktopUniversalModal.availableWallets\",\n        children: \"Available wallets\"\n      }), createComponent(WalletsContainerStyled, {\n        get children() {\n          return [createComponent(For, {\n            get each() {\n              return visibleWallets();\n            },\n            children: (wallet) => (() => {\n              var _el$ = _tmpl$();\n              insert(_el$, createComponent(WalletLabeledItem, {\n                wallet,\n                onClick: () => props.onSelect(wallet)\n              }));\n              return _el$;\n            })()\n          }), createComponent(FourWalletsItem, {\n            labelLine1: \"View all\",\n            labelLine2: \"wallets\",\n            get images() {\n              return fourWalletsItem().map((i2) => i2.imageUrl);\n            },\n            onClick: () => props.onSelectAllWallets()\n          })];\n        }\n      })];\n    }\n  });\n};\nconst borders = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst H1Styled$2 = styled(H1)`\n    max-width: 288px;\n    margin: 0 auto 38px;\n`;\nconst DesktopFeatureNotSupportModalStyled = styled.div`\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n`;\nconst StyledIconButton$1 = styled(IconButton)`\n    position: absolute;\n    top: 16px;\n    left: 16px;\n`;\nconst TitleStyled = styled(H1)`\n    text-align: center;\n    font-size: 20px;\n    line-height: 28px;\n`;\nconst DescriptionStyled = styled(Text)`\n    margin-top: 12px;\n    margin-bottom: 24px;\n    text-align: center;\n    max-width: 360px;\n    font-weight: 400;\n    color: ${(props) => props.theme.colors.text.secondary};\n`;\nstyled.button`\n    background: transparent;\n    border: none;\n    padding: 0;\n    margin: 0;\n    color: ${(props) => props.theme.colors.accent};\n    text-decoration: underline;\n    cursor: pointer;\n    font: inherit;\n`;\nconst Spacer = styled.div`\n    margin-bottom: 46px;\n`;\nconst ErrorIconStyled = styled(ErrorIcon)`\n    margin-bottom: 16px;\n`;\nstyled.ul`\n    display: flex;\n    gap: 8px;\n    margin-bottom: 24px;\n    list-style: none;\n    padding: 0;\n`;\nconst DisconnectButtonStyled = styled(Button)`\n    max-width: 320px;\n    width: 100%;\n    height: 48px;\n    font-size: 16px;\n    line-height: 20px;\n    border-radius: ${(props) => borders[props.theme.borderRadius]};\n    margin-bottom: 28px;\n`;\nconst BodyTextStyled = styled(H2)`\n    color: ${(props) => props.theme.colors.text.secondary};\n    text-align: center;\n    margin-bottom: 20px;\n`;\nconst ButtonsContainerStyled = styled.div`\n    display: flex;\n    justify-content: center;\n    gap: 8px;\n    padding-bottom: 31px;\n`;\nconst RestoreInfoModalStyled = styled.div`\n    margin: 0 8px 16px 8px;\n`;\nconst StyledIconButton = styled(IconButton)`\n    position: absolute;\n    top: 16px;\n    left: 16px;\n`;\nconst H1Styled$1 = styled(H1)`\n    margin-bottom: 18px;\n    text-align: center;\n`;\nconst StepBlock = styled.div`\n    padding: 16px 0;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n`;\nstyled.div`\n    margin-bottom: 12px;\n`;\nconst H3Styled = styled(H3)`\n    text-align: center;\n    margin-bottom: 4px;\n`;\nconst TextStyled$1 = styled(Text)`\n    text-align: center;\n    max-width: 352px;\n    color: ${(props) => props.theme.colors.text.secondary};\n`;\nconst CircleNumber = styled.div`\n    width: 44px;\n    height: 44px;\n    border-radius: 20px;\n    background-color: ${(props) => {\n  var _a2;\n  return (_a2 = props.theme) == null ? void 0 : _a2.colors.icon.secondary;\n}};\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    margin-bottom: 12px;\n    font-weight: 700;\n    font-size: 22px;\n    color: ${(props) => {\n  var _a2;\n  return (_a2 = props.theme) == null ? void 0 : _a2.colors.text.primary;\n}};\n`;\nconst RestoreInfoModal = (props) => {\n  return createComponent(RestoreInfoModalStyled, {\n    \"data-tc-wallets-modal-restore\": \"true\",\n    get children() {\n      return [createComponent(StyledIconButton, {\n        icon: \"arrow\",\n        get onClick() {\n          return props.onBackClick;\n        }\n      }), createComponent(H1Styled$1, {\n        translationKey: \"walletModal.restoreInfoModal.title\",\n        children: \"Restore\"\n      }), createComponent(ScrollContainer, {\n        get children() {\n          return [createComponent(StepBlock, {\n            get children() {\n              return [createComponent(CircleNumber, {\n                children: \"1\"\n              }), createComponent(H3Styled, {\n                translationKey: \"walletModal.restoreModal.step1.title\",\n                children: \"Find your current recovery phrase\"\n              }), createComponent(TextStyled$1, {\n                translationKey: \"walletModal.restoreModal.step1.text\",\n                children: \"Open your wallet settings and locate therecoveryphrase\"\n              })];\n            }\n          }), createComponent(StepBlock, {\n            get children() {\n              return [createComponent(CircleNumber, {\n                children: \"2\"\n              }), createComponent(H3Styled, {\n                translationKey: \"walletModal.restoreModal.step2.title\",\n                children: \"Copy your recovery phrase\"\n              }), createComponent(TextStyled$1, {\n                translationKey: \"walletModal.restoreModal.step2.text\",\n                children: \"Write it down or copy it to a safe place\"\n              })];\n            }\n          }), createComponent(StepBlock, {\n            get children() {\n              return [createComponent(CircleNumber, {\n                children: \"3\"\n              }), createComponent(H3Styled, {\n                translationKey: \"walletModal.restoreModal.step3.title\",\n                children: \"Restore in a supported wallet fromthelistbelow\"\n              }), createComponent(TextStyled$1, {\n                translationKey: \"walletModal.restoreModal.step3.text\",\n                children: \"Enter the recovery phrase to access your wallet\"\n              })];\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst DesktopFeatureNotSupportModal = (props) => {\n  const [selectedWallet, setSelectedWallet] = createSignal(null);\n  const [infoModalOpen, setInfoModalOpen] = createSignal(false);\n  const currentWalletUI = createMemo(() => props.walletsList.find((wallet) => wallet.appName === props.currentWallet.device.appName || wallet.name === props.currentWallet.device.appName));\n  const currentWalletName = createMemo(() => {\n    var _a2, _b2, _c2, _d2;\n    const appName = (_b2 = (_a2 = currentWalletUI()) == null ? void 0 : _a2.appName) != null ? _b2 : props.currentWallet.device.appName;\n    if (appName === AT_WALLET_APP_NAME) {\n      return \"Wallet in Telegram\";\n    }\n    return (_d2 = (_c2 = currentWalletUI()) == null ? void 0 : _c2.name) != null ? _d2 : props.currentWallet.device.appName;\n  });\n  const currentWalletVersionNotSupported = createMemo(() => {\n    const currentWalletUIVar = currentWalletUI();\n    if (!(currentWalletUIVar == null ? void 0 : currentWalletUIVar.features)) {\n      return false;\n    }\n    const requiredFeature = props.walletsModalState.requiredFeature;\n    const requiredFeatures = requiredFeature ? {\n      [requiredFeature.featureName]: requiredFeature.value\n    } : {};\n    const validInList = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.checkRequiredWalletFeatures)(currentWalletUIVar.features, requiredFeatures);\n    const validCurrentWallet = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.checkRequiredWalletFeatures)(props.currentWallet.device.features, requiredFeatures);\n    return validInList && !validCurrentWallet;\n  });\n  const handleDisconnect = () => __async(null, null, function* () {\n    yield props.onDisconnect();\n    props.onSelect(selectedWallet());\n  });\n  return createComponent(DesktopFeatureNotSupportModalStyled, {\n    get children() {\n      return createComponent(Switch, {\n        get children() {\n          return [createComponent(Match, {\n            get when() {\n              return infoModalOpen();\n            },\n            get children() {\n              return createComponent(RestoreInfoModal, {\n                onBackClick: () => setInfoModalOpen(false)\n              });\n            }\n          }), createComponent(Match, {\n            get when() {\n              return selectedWallet();\n            },\n            get children() {\n              return [createComponent(Spacer, {}), createComponent(DesktopFeatureNotSupportModalStyled, {\n                get children() {\n                  return [createComponent(StyledIconButton$1, {\n                    icon: \"arrow\",\n                    onClick: () => setSelectedWallet(null)\n                  }), createComponent(TitleStyled, {\n                    translationKey: \"walletModal.featureNotSupported.disconnect.title\",\n                    children: \"Confirm Disconnect\"\n                  }), createComponent(DescriptionStyled, {\n                    translationKey: \"walletModal.featureNotSupported.disconnect.description\",\n                    get translationValues() {\n                      return {\n                        name: selectedWallet().name\n                      };\n                    },\n                    get children() {\n                      return [\"You will be disconnected from your current wallet and redirected to connect \", memo(() => {\n                        var _a2;\n                        return (_a2 = selectedWallet()) == null ? void 0 : _a2.name;\n                      }), \".\"];\n                    }\n                  }), createComponent(DisconnectButtonStyled, {\n                    onClick: () => handleDisconnect(),\n                    get children() {\n                      return createComponent(Translation, {\n                        translationKey: \"walletModal.featureNotSupported.disconnect.button\",\n                        children: \"Disconnect\"\n                      });\n                    }\n                  })];\n                }\n              })];\n            }\n          }), createComponent(Match, {\n            get when() {\n              return currentWalletVersionNotSupported();\n            },\n            get children() {\n              return [createComponent(H1Styled$2, {\n                get children() {\n                  return currentWalletName();\n                }\n              }), createComponent(ErrorIconStyled, {\n                size: \"s\"\n              }), createComponent(BodyTextStyled, {\n                translationKey: \"walletModal.featureNotSupported.version.description\",\n                get translationValues() {\n                  return {\n                    name: currentWalletName()\n                  };\n                },\n                get children() {\n                  return [\"Your current version of \", memo(() => currentWalletName()), \" or wallet contract type doesn't support the required features. Please update it to continue.\"];\n                }\n              }), createComponent(ButtonsContainerStyled, {\n                get children() {\n                  return [createComponent(Link, {\n                    get href() {\n                      return currentWalletUI().aboutUrl;\n                    },\n                    blank: true,\n                    get children() {\n                      return createComponent(Button, {\n                        get leftIcon() {\n                          return createComponent(LinkIcon, {});\n                        },\n                        get children() {\n                          return createComponent(Translation, {\n                            translationKey: \"walletModal.featureNotSupported.version.updateButton\",\n                            get translationValues() {\n                              return {\n                                name: currentWalletName()\n                              };\n                            },\n                            get children() {\n                              return [\"Update \", memo(() => currentWalletName())];\n                            }\n                          });\n                        }\n                      });\n                    }\n                  }), createComponent(Link, {\n                    href: \"https://tonkeeper.helpscoutdocs.com/article/102-w5\",\n                    blank: true,\n                    get children() {\n                      return createComponent(Button, {\n                        get leftIcon() {\n                          return createComponent(LinkIcon, {});\n                        },\n                        get children() {\n                          return createComponent(Translation, {\n                            translationKey: \"walletModal.featureNotSupported.version.aboutW5\",\n                            children: \"About W5\"\n                          });\n                        }\n                      });\n                    }\n                  })];\n                }\n              })];\n            }\n          }), createComponent(Match, {\n            when: true,\n            get children() {\n              return [createComponent(Spacer, {}), createComponent(ErrorIconStyled, {\n                size: \"s\"\n              }), createComponent(TitleStyled, {\n                translationKey: \"walletModal.featureNotSupported.wallet.title\",\n                get translationValues() {\n                  return {\n                    name: currentWalletName()\n                  };\n                },\n                get children() {\n                  return [memo(() => currentWalletName()), \" doesnt support the requestedaction\"];\n                }\n              }), createComponent(Spacer, {})];\n            }\n          })];\n        }\n      });\n    }\n  });\n};\nconst WalletsModal = () => {\n  const {\n    locale\n  } = useI18n()[1];\n  createEffect(() => locale(appState.language));\n  createEffect(() => {\n    if (getWalletsModalIsOpened()) {\n      updateIsMobile();\n      refetchWallets();\n    } else {\n      setSelectedWalletInfo(null);\n      setSelectedTab(\"universal\");\n      setInfoTab(false);\n    }\n  });\n  const connector = useContext(ConnectorContext);\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [fetchedWalletsList, {\n    refetch: refetchWallets\n  }] = createResource(() => {\n    return tonConnectUI.getWallets();\n  });\n  const [selectedWalletInfo, setSelectedWalletInfo] = createSignal(null);\n  const [selectedWalletError, setSelectedWalletError] = createSignal(null);\n  const [selectedTab, setSelectedTab] = createSignal(\"universal\");\n  const [infoTab, setInfoTab] = createSignal(false);\n  const walletsModalIsWalletNotSupportFeature = createMemo(() => {\n    const state = walletsModalState();\n    return \"type\" in state && state.type === \"wallet-not-support-feature\";\n  });\n  const walletsList = createMemo(() => {\n    var _a2;\n    if (fetchedWalletsList.state !== \"ready\") {\n      return null;\n    }\n    let walletsList2 = applyWalletsListConfiguration(fetchedWalletsList(), appState.walletsListConfiguration);\n    const injectedWallets = walletsList2.filter(_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyInjected);\n    const notInjectedWallets = walletsList2.filter((w) => !(0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyInjected)(w));\n    walletsList2 = (injectedWallets || []).concat(notInjectedWallets);\n    const preferredWalletAppName = appState.preferredWalletAppName;\n    const preferredWallet = walletsList2.find((item) => eqWalletName(item, preferredWalletAppName));\n    const someWalletsWithSameName = walletsList2.filter((item) => eqWalletName(item, preferredWalletAppName)).length >= 2;\n    if (preferredWalletAppName && preferredWallet && !someWalletsWithSameName) {\n      walletsList2 = [__spreadProps(__spreadValues({}, preferredWallet), {\n        isPreferred: true\n      })].concat(walletsList2.filter((item) => !eqWalletName(item, preferredWalletAppName)));\n    }\n    const atWallet = walletsList2.find((item) => eqWalletName(item, AT_WALLET_APP_NAME));\n    if (atWallet) {\n      walletsList2 = [atWallet].concat(walletsList2.filter((item) => !eqWalletName(item, AT_WALLET_APP_NAME)));\n    }\n    const walletsFeaturesRequested = (_a2 = tonConnectUI == null ? void 0 : tonConnectUI.walletsRequiredFeatures) != null ? _a2 : tonConnectUI == null ? void 0 : tonConnectUI.walletsPreferredFeatures;\n    const uiWallets = walletsList2.map((wallet) => {\n      var _a3;\n      return __spreadProps(__spreadValues({}, wallet), {\n        isSupportRequiredFeatures: walletsFeaturesRequested ? (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.checkRequiredWalletFeatures)((_a3 = wallet.features) != null ? _a3 : [], walletsFeaturesRequested) : true\n      });\n    });\n    return uiWallets;\n  });\n  const additionalRequestLoading = () => {\n    var _a2;\n    return ((_a2 = appState.connectRequestParameters) == null ? void 0 : _a2.state) === \"loading\";\n  };\n  const additionalRequest = createMemo(() => {\n    var _a2;\n    if (additionalRequestLoading()) {\n      return void 0;\n    }\n    return (_a2 = appState.connectRequestParameters) == null ? void 0 : _a2.value;\n  });\n  const onClose = (closeReason) => {\n    tonConnectUI.closeModal(closeReason);\n  };\n  const unsubscribe = connector.onStatusChange((wallet) => {\n    if (wallet) {\n      onClose(\"wallet-selected\");\n    }\n  }, (err) => {\n    var _a2;\n    if (err instanceof _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletMissingRequiredFeaturesError) {\n      const errorAppName = err.cause.connectEvent.device.appName.toLowerCase();\n      const wallet = (_a2 = walletsList()) == null ? void 0 : _a2.find((w) => w.appName.toLowerCase() === errorAppName);\n      if (!wallet) {\n        throw new _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnectError(\"Wallet not found\");\n      }\n      const walletErrorType = wallet.isSupportRequiredFeatures ? \"missing-features\" : \"not-supported\";\n      setSelectedWalletError(walletErrorType);\n      setSelectedWalletInfo(wallet);\n    }\n  });\n  const onSelectAllWallets = () => {\n    setSelectedTab(\"all-wallets\");\n  };\n  const onSelectUniversal = () => {\n    setSelectedTab(\"universal\");\n  };\n  const onSelectWallet = (wallet) => {\n    setSelectedWalletInfo(wallet);\n    widgetController.openWalletsModal();\n  };\n  const clearSelectedWalletInfo = () => {\n    setSelectedWalletInfo(null);\n    setSelectedWalletError(null);\n  };\n  onCleanup(() => {\n    setSelectedWalletInfo(null);\n    setSelectedWalletError(null);\n    setInfoTab(false);\n  });\n  onCleanup(unsubscribe);\n  return createComponent(StyledModal, {\n    get opened() {\n      return getWalletsModalIsOpened();\n    },\n    get enableAndroidBackHandler() {\n      return appState.enableAndroidBackHandler;\n    },\n    onClose: () => onClose(\"action-cancelled\"),\n    onClickQuestion: () => setInfoTab((v) => !v),\n    get showFooter() {\n      return !walletsModalIsWalletNotSupportFeature();\n    },\n    \"data-tc-wallets-modal-container\": \"true\",\n    get children() {\n      return [createComponent(Show, {\n        get when() {\n          return infoTab();\n        },\n        get children() {\n          return createComponent(InfoModal, {\n            onBackClick: () => setInfoTab(false)\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !infoTab();\n        },\n        get children() {\n          return [createComponent(Show, {\n            get when() {\n              return additionalRequestLoading() || !walletsList();\n            },\n            get children() {\n              return [createComponent(H1Styled$a, {\n                translationKey: \"walletModal.loading\",\n                children: \"Wallets list is loading\"\n              }), createComponent(LoaderContainerStyled, {\n                get children() {\n                  return createComponent(LoaderIcon, {\n                    size: \"m\"\n                  });\n                }\n              })];\n            }\n          }), createComponent(Show, {\n            get when() {\n              return memo(() => !!!additionalRequestLoading())() && walletsList();\n            },\n            get children() {\n              return createComponent(Switch, {\n                get children() {\n                  return [createComponent(Match, {\n                    get when() {\n                      return walletsModalIsWalletNotSupportFeature();\n                    },\n                    get children() {\n                      return createComponent(DesktopFeatureNotSupportModal, {\n                        get walletsList() {\n                          return walletsList();\n                        },\n                        get currentWallet() {\n                          return tonConnectUI == null ? void 0 : tonConnectUI.wallet;\n                        },\n                        onSelect: onSelectWallet,\n                        onSelectAllWallets,\n                        onDisconnect: () => connector.disconnect(),\n                        get walletsModalState() {\n                          return walletsModalState();\n                        },\n                        onClose: () => onClose(\"action-cancelled\")\n                      });\n                    }\n                  }), createComponent(Match, {\n                    get when() {\n                      return selectedWalletInfo();\n                    },\n                    get children() {\n                      return createComponent(Dynamic, {\n                        get component() {\n                          return isMobile() ? MobileConnectionModal : DesktopConnectionModal;\n                        },\n                        get walletsModalState() {\n                          return walletsModalState();\n                        },\n                        get wallet() {\n                          return selectedWalletInfo();\n                        },\n                        get additionalRequest() {\n                          return additionalRequest();\n                        },\n                        onBackClick: clearSelectedWalletInfo,\n                        get defaultError() {\n                          return selectedWalletError();\n                        }\n                      });\n                    }\n                  }), createComponent(Match, {\n                    get when() {\n                      return selectedTab() === \"universal\";\n                    },\n                    get children() {\n                      return createComponent(Dynamic, {\n                        get component() {\n                          return isMobile() ? MobileUniversalModal : DesktopUniversalModal;\n                        },\n                        onSelect: setSelectedWalletInfo,\n                        get walletModalState() {\n                          return walletsModalState();\n                        },\n                        get walletsList() {\n                          return walletsList();\n                        },\n                        get additionalRequest() {\n                          return additionalRequest();\n                        },\n                        onSelectAllWallets\n                      });\n                    }\n                  }), createComponent(Match, {\n                    get when() {\n                      return selectedTab() === \"all-wallets\";\n                    },\n                    get children() {\n                      return createComponent(AllWalletsListModal, {\n                        get walletsList() {\n                          return walletsList();\n                        },\n                        get featureCheckMode() {\n                          return (tonConnectUI == null ? void 0 : tonConnectUI.walletsRequiredFeatures) ? \"strict\" : \"soft\";\n                        },\n                        onBack: onSelectUniversal,\n                        onSelect: setSelectedWalletInfo\n                      });\n                    }\n                  })];\n                }\n              });\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst ActionModalStyled = styled.div`\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    padding-bottom: 8px;\n`;\nconst H1Styled = styled(H1)`\n    margin-top: 16px;\n`;\nconst TextStyled = styled(Text)`\n    font-weight: 510;\n    font-size: 16px;\n    line-height: 20px;\n    text-align: center;\n    max-width: 250px;\n\n    color: ${(props) => props.theme.colors.text.secondary};\n`;\nconst LoaderButtonStyled = styled(Button)`\n    min-width: 112px;\n    margin-top: 32px;\n`;\nconst LoaderIconStyled = styled(LoaderIcon)`\n    height: 16px;\n    width: 16px;\n`;\nconst ButtonStyled = styled(Button)`\n    margin-top: 32px;\n`;\nconst ActionModal = (props) => {\n  const dataAttrs = useDataAttributes(props);\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [firstClick, setFirstClick] = createSignal(true);\n  const [sent, setSent] = createSignal(false);\n  const [signed, setSigned] = createSignal(false);\n  const [canceled, setCanceled] = createSignal(false);\n  createEffect(() => {\n    const currentAction = action();\n    setSent(!!currentAction && (\"sent\" in currentAction && currentAction.sent || currentAction.name === \"transaction-sent\"));\n    setSigned(!!currentAction && (\"signed\" in currentAction && currentAction.signed || currentAction.name === \"data-signed\"));\n    setCanceled(!!currentAction && (currentAction.name === \"transaction-canceled\" || currentAction.name === \"sign-data-canceled\"));\n  });\n  let universalLink;\n  if ((tonConnectUI == null ? void 0 : tonConnectUI.wallet) && \"universalLink\" in tonConnectUI.wallet && (tonConnectUI.wallet.openMethod === \"universal-link\" || (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isTelegramUrl)(tonConnectUI.wallet.universalLink) && isInTMA())) {\n    universalLink = tonConnectUI.wallet.universalLink;\n  }\n  let deepLink;\n  if ((tonConnectUI == null ? void 0 : tonConnectUI.wallet) && \"deepLink\" in tonConnectUI.wallet && (tonConnectUI.wallet.openMethod === \"custom-deeplink\" || (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isTelegramUrl)(tonConnectUI.wallet.deepLink) && isInTMA())) {\n    deepLink = tonConnectUI.wallet.deepLink;\n  }\n  const onOpenWallet = () => {\n    const currentAction = action();\n    const returnStrategy = \"returnStrategy\" in currentAction ? currentAction.returnStrategy : appState.returnStrategy;\n    const forceRedirect = !firstClick();\n    setFirstClick(false);\n    const linkWithSessionId = enrichUniversalLink(universalLink, {\n      sessionId: currentAction.sessionId,\n      traceId: currentAction.traceId\n    });\n    if ((0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isTelegramUrl)(universalLink)) {\n      redirectToTelegram(linkWithSessionId, {\n        returnStrategy,\n        twaReturnUrl: \"twaReturnUrl\" in currentAction ? currentAction.twaReturnUrl : appState.twaReturnUrl,\n        forceRedirect\n      });\n    } else {\n      redirectToWallet(linkWithSessionId, deepLink, {\n        returnStrategy,\n        forceRedirect\n      }, () => {\n      });\n    }\n  };\n  return createComponent(ActionModalStyled, mergeProps(dataAttrs, {\n    get children() {\n      return [memo(() => props.icon), createComponent(H1Styled, {\n        get translationKey() {\n          return props.headerTranslationKey;\n        },\n        get translationValues() {\n          return props.headerTranslationValues;\n        }\n      }), createComponent(TextStyled, {\n        get translationKey() {\n          return props.textTranslationKey;\n        },\n        get translationValues() {\n          return props.textTranslationValues;\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !sent() && !signed() && !canceled() && (props.showButton === \"open-wallet\" && universalLink || props.showButton !== \"open-wallet\");\n        },\n        get children() {\n          return createComponent(LoaderButtonStyled, {\n            disabled: true,\n            \"data-tc-connect-button-loading\": \"true\",\n            get children() {\n              return createComponent(LoaderIconStyled, {});\n            }\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return sent() || signed();\n        },\n        get children() {\n          return [createComponent(Show, {\n            get when() {\n              return props.showButton !== \"open-wallet\";\n            },\n            get children() {\n              return createComponent(ButtonStyled, {\n                onClick: () => props.onClose(),\n                get children() {\n                  return createComponent(Translation, {\n                    translationKey: \"common.close\",\n                    children: \"Close\"\n                  });\n                }\n              });\n            }\n          }), createComponent(Show, {\n            get when() {\n              return props.showButton === \"open-wallet\" && universalLink;\n            },\n            get children() {\n              return createComponent(ButtonStyled, {\n                onClick: onOpenWallet,\n                get children() {\n                  return createComponent(Translation, {\n                    translationKey: \"common.openWallet\",\n                    children: \"Open wallet\"\n                  });\n                }\n              });\n            }\n          })];\n        }\n      })];\n    }\n  }));\n};\nconst ConfirmTransactionModal = (props) => {\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [t2] = useI18n();\n  const name = () => tonConnectUI.wallet && \"name\" in tonConnectUI.wallet ? tonConnectUI.wallet.name : t2(\"common.yourWallet\", {}, \"Your wallet\");\n  return createComponent(ActionModal, {\n    headerTranslationKey: \"actionModal.confirmTransaction.header\",\n    get headerTranslationValues() {\n      return {\n        name: name()\n      };\n    },\n    textTranslationKey: \"actionModal.confirmTransaction.text\",\n    get icon() {\n      return createComponent(LoaderIcon, {\n        size: \"m\"\n      });\n    },\n    onClose: () => props.onClose(),\n    showButton: \"open-wallet\",\n    \"data-tc-confirm-modal\": \"true\"\n  });\n};\nconst TransactionCanceledModal = (props) => {\n  return createComponent(ActionModal, {\n    headerTranslationKey: \"actionModal.transactionCanceled.header\",\n    textTranslationKey: \"actionModal.transactionCanceled.text\",\n    get icon() {\n      return createComponent(ErrorIcon, {\n        size: \"m\"\n      });\n    },\n    onClose: () => props.onClose(),\n    \"data-tc-transaction-canceled-modal\": \"true\"\n  });\n};\nconst TransactionSentModal = (props) => {\n  return createComponent(ActionModal, {\n    headerTranslationKey: \"actionModal.transactionSent.header\",\n    textTranslationKey: \"actionModal.transactionSent.text\",\n    get icon() {\n      return createComponent(SuccessIcon, {\n        size: \"m\"\n      });\n    },\n    showButton: \"open-wallet\",\n    onClose: () => props.onClose(),\n    \"data-tc-transaction-sent-modal\": \"true\"\n  });\n};\nconst ConfirmSignDataModal = (props) => {\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [t2] = useI18n();\n  const name = () => tonConnectUI.wallet && \"name\" in tonConnectUI.wallet ? tonConnectUI.wallet.name : t2(\"common.yourWallet\", {}, \"Your wallet\");\n  return createComponent(ActionModal, {\n    headerTranslationKey: \"actionModal.signData.header\",\n    get headerTranslationValues() {\n      return {\n        name: name()\n      };\n    },\n    textTranslationKey: \"actionModal.signData.text\",\n    get icon() {\n      return createComponent(LoaderIcon, {\n        size: \"m\"\n      });\n    },\n    onClose: () => props.onClose(),\n    showButton: \"open-wallet\",\n    \"data-tc-sign-data-confirm-modal\": \"true\"\n  });\n};\nconst SignDataCanceledModal = (props) => {\n  return createComponent(ActionModal, {\n    headerTranslationKey: \"actionModal.signDataCanceled.header\",\n    get icon() {\n      return createComponent(ErrorIcon, {\n        size: \"m\"\n      });\n    },\n    onClose: () => props.onClose(),\n    \"data-tc-sign-data-canceled-modal\": \"true\"\n  });\n};\nconst DataSignedModal = (props) => {\n  return createComponent(ActionModal, {\n    headerTranslationKey: \"actionModal.dataSigned.header\",\n    get icon() {\n      return createComponent(SuccessIcon, {\n        size: \"m\"\n      });\n    },\n    onClose: () => props.onClose(),\n    \"data-tc-data-signed-modal\": \"true\"\n  });\n};\nconst ActionsModal = () => {\n  return createComponent(Modal, {\n    get opened() {\n      var _a2;\n      return memo(() => action() !== null)() && ((_a2 = action()) == null ? void 0 : _a2.openModal) === true;\n    },\n    get enableAndroidBackHandler() {\n      return appState.enableAndroidBackHandler;\n    },\n    onClose: () => setAction(null),\n    showFooter: false,\n    \"data-tc-actions-modal-container\": \"true\",\n    get children() {\n      return createComponent(Switch, {\n        get children() {\n          return [createComponent(Match, {\n            get when() {\n              return action().name === \"transaction-sent\";\n            },\n            get children() {\n              return createComponent(TransactionSentModal, {\n                onClose: () => setAction(null)\n              });\n            }\n          }), createComponent(Match, {\n            get when() {\n              return action().name === \"transaction-canceled\";\n            },\n            get children() {\n              return createComponent(TransactionCanceledModal, {\n                onClose: () => setAction(null)\n              });\n            }\n          }), createComponent(Match, {\n            get when() {\n              return action().name === \"confirm-transaction\";\n            },\n            get children() {\n              return createComponent(ConfirmTransactionModal, {\n                onClose: () => setAction(null)\n              });\n            }\n          }), createComponent(Match, {\n            get when() {\n              return action().name === \"data-signed\";\n            },\n            get children() {\n              return createComponent(DataSignedModal, {\n                onClose: () => setAction(null)\n              });\n            }\n          }), createComponent(Match, {\n            get when() {\n              return action().name === \"sign-data-canceled\";\n            },\n            get children() {\n              return createComponent(SignDataCanceledModal, {\n                onClose: () => setAction(null)\n              });\n            }\n          }), createComponent(Match, {\n            get when() {\n              return action().name === \"confirm-sign-data\";\n            },\n            get children() {\n              return createComponent(ConfirmSignDataModal, {\n                onClose: () => setAction(null)\n              });\n            }\n          })];\n        }\n      });\n    }\n  });\n};\nconst SingleWalletModal = () => {\n  const {\n    locale\n  } = useI18n()[1];\n  createEffect(() => locale(appState.language));\n  createEffect(() => {\n    if (getSingleWalletModalIsOpened()) {\n      updateIsMobile();\n    }\n  });\n  const connector = useContext(ConnectorContext);\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [infoTab, setInfoTab] = createSignal(false);\n  const additionalRequestLoading = () => {\n    var _a2;\n    return ((_a2 = appState.connectRequestParameters) == null ? void 0 : _a2.state) === \"loading\";\n  };\n  const additionalRequest = createMemo(() => {\n    var _a2;\n    if (additionalRequestLoading()) {\n      return void 0;\n    }\n    return (_a2 = appState.connectRequestParameters) == null ? void 0 : _a2.value;\n  });\n  const onClose = (closeReason) => {\n    tonConnectUI.closeSingleWalletModal(closeReason);\n  };\n  const unsubscribe = connector.onStatusChange((wallet) => {\n    if (wallet) {\n      onClose(\"wallet-selected\");\n    }\n  });\n  onCleanup(unsubscribe);\n  onCleanup(() => {\n    setInfoTab(false);\n  });\n  return createComponent(StyledModal, {\n    get opened() {\n      return getSingleWalletModalIsOpened();\n    },\n    get enableAndroidBackHandler() {\n      return appState.enableAndroidBackHandler;\n    },\n    onClose: () => onClose(\"action-cancelled\"),\n    onClickQuestion: () => setInfoTab((v) => !v),\n    showFooter: true,\n    \"data-tc-wallets-modal-container\": \"true\",\n    get children() {\n      return [createComponent(Show, {\n        get when() {\n          return infoTab();\n        },\n        get children() {\n          return createComponent(InfoModal, {\n            onBackClick: () => setInfoTab(false)\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !infoTab();\n        },\n        get children() {\n          return [createComponent(Show, {\n            get when() {\n              return additionalRequestLoading();\n            },\n            get children() {\n              return [createComponent(H1Styled$a, {\n                translationKey: \"walletModal.loading\",\n                children: \"Wallets list is loading\"\n              }), createComponent(LoaderContainerStyled, {\n                get children() {\n                  return createComponent(LoaderIcon, {\n                    size: \"m\"\n                  });\n                }\n              })];\n            }\n          }), createComponent(Show, {\n            get when() {\n              return !additionalRequestLoading();\n            },\n            get children() {\n              return createComponent(Dynamic, {\n                get component() {\n                  return isMobile() ? MobileConnectionModal : DesktopConnectionModal;\n                },\n                get wallet() {\n                  return getSingleWalletModalWalletInfo();\n                },\n                get additionalRequest() {\n                  return additionalRequest();\n                },\n                onBackClick: () => {\n                },\n                backDisabled: true\n              });\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst App = (props) => {\n  const translations = createI18nContext(i18nDictionary, appState.language);\n  defineStylesRoot();\n  fixMobileSafariActiveTransition();\n  return createComponent(I18nContext.Provider, {\n    value: translations,\n    get children() {\n      return createComponent(TonConnectUiContext.Provider, {\n        get value() {\n          return props.tonConnectUI;\n        },\n        get children() {\n          return createComponent(ConnectorContext.Provider, {\n            get value() {\n              return appState.connector;\n            },\n            get children() {\n              return [createComponent(GlobalStyles, {}), createComponent(ThemeProvider, {\n                theme: themeState,\n                get children() {\n                  return [createComponent(Show, {\n                    get when() {\n                      return appState.buttonRootId;\n                    },\n                    get children() {\n                      return createComponent(Portal, {\n                        get mount() {\n                          return document.getElementById(appState.buttonRootId);\n                        },\n                        get children() {\n                          return createComponent(AccountButton, {});\n                        }\n                      });\n                    }\n                  }), createComponent(Dynamic, {\n                    component: globalStylesTag,\n                    get children() {\n                      return [createComponent(WalletsModal, {}), createComponent(SingleWalletModal, {}), createComponent(ActionsModal, {})];\n                    }\n                  })];\n                }\n              })];\n            }\n          });\n        }\n      });\n    }\n  });\n};\nconst widgetController = {\n  openWalletsModal: (options) => void setTimeout(() => setWalletsModalState((prev) => {\n    var _a2;\n    return {\n      status: \"opened\",\n      traceId: (_a2 = options == null ? void 0 : options.traceId) != null ? _a2 : prev == null ? void 0 : prev.traceId,\n      closeReason: null\n    };\n  })),\n  closeWalletsModal: (reason) => void setTimeout(() => setWalletsModalState({\n    status: \"closed\",\n    closeReason: reason\n  })),\n  openSingleWalletModal: (walletInfo) => {\n    void setTimeout(() => setSingleWalletModalState({\n      status: \"opened\",\n      closeReason: null,\n      walletInfo\n    }));\n  },\n  closeSingleWalletModal: (reason) => void setTimeout(() => setSingleWalletModalState({\n    status: \"closed\",\n    closeReason: reason\n  })),\n  openWalletNotSupportFeatureModal: (cause, options) => void setTimeout(() => setWalletsModalState({\n    status: \"opened\",\n    traceId: options.traceId,\n    closeReason: null,\n    type: \"wallet-not-support-feature\",\n    requiredFeature: cause.requiredFeature\n  })),\n  setAction: (action2) => void setTimeout(() => setAction(action2)),\n  clearAction: () => void setTimeout(() => setAction(null)),\n  getSelectedWalletInfo: () => lastSelectedWalletInfo(),\n  getLastVisibleWallets: () => lastVisibleWalletsInfo(),\n  removeSelectedWalletInfo: () => setLastSelectedWalletInfo(null),\n  renderApp: (root, tonConnectUI) => render(() => createComponent(App, {\n    tonConnectUI\n  }), document.getElementById(root))\n};\nclass WalletsModalManager {\n  constructor(options) {\n    this.consumers = [];\n    this.state = walletsModalState();\n    this.connector = options.connector;\n    this.tracker = options.tracker;\n    this.setConnectRequestParametersCallback = options.setConnectRequestParametersCallback;\n    createEffect(() => {\n      const state = walletsModalState();\n      this.state = state;\n      this.consumers.forEach((consumer) => consumer(state));\n    });\n    createEffect(\n      on(lastSelectedWalletInfo, (selectedWallet, previousWallet) => __async(this, null, function* () {\n        try {\n          const { wallets, walletsMenu } = widgetController.getLastVisibleWallets();\n          if (selectedWallet && \"appName\" in selectedWallet) {\n            if (previousWallet && \"appName\" in previousWallet && previousWallet.appName === selectedWallet.appName) {\n              return;\n            }\n            const clientId = yield this.connector.getSessionId();\n            this.tracker.trackSelectedWallet(\n              wallets.map((wallet) => wallet.name),\n              selectedWallet,\n              walletsMenu,\n              \"\",\n              void 0,\n              clientId,\n              this.state.traceId\n            );\n          }\n        } catch (error) {\n          logError(error);\n        }\n      }))\n    );\n    createEffect(\n      on(lastOpenedLink, (openedLink) => __async(this, null, function* () {\n        try {\n          const { wallets, walletsMenu } = widgetController.getLastVisibleWallets();\n          if ((0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isConnectUrl)(openedLink.link)) {\n            const selectedWallet = lastSelectedWalletInfo();\n            const clientId = yield this.connector.getSessionId();\n            this.tracker.trackSelectedWallet(\n              wallets.map((wallet) => wallet.name),\n              selectedWallet && \"appName\" in selectedWallet ? selectedWallet : null,\n              walletsMenu,\n              openedLink.link,\n              openedLink.type,\n              clientId,\n              this.state.traceId\n            );\n          }\n        } catch (error) {\n          logError(error);\n        }\n      }))\n    );\n  }\n  /**\n   * Opens the modal window.\n   */\n  open(options) {\n    return __async(this, null, function* () {\n      var _a2;\n      const traceId = (_a2 = options == null ? void 0 : options.traceId) != null ? _a2 : (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.UUIDv7)();\n      this.tracker.trackConnectionStarted();\n      const walletsList = yield this.connector.getWallets();\n      const embeddedWallet = walletsList.find(_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyEmbedded);\n      if (embeddedWallet) {\n        return this.connectEmbeddedWallet(embeddedWallet, { traceId });\n      } else {\n        return this.openWalletsModal({ traceId });\n      }\n    });\n  }\n  /**\n   * Closes the modal window.\n   * @default 'action-cancelled'\n   */\n  close(reason = \"action-cancelled\") {\n    if (reason === \"action-cancelled\") {\n      this.tracker.trackConnectionError(\"Connection was cancelled\");\n    }\n    widgetController.closeWalletsModal(reason);\n  }\n  /**\n   * Subscribe to the modal window state changes, returns unsubscribe function.\n   */\n  onStateChange(onChange) {\n    this.consumers.push(onChange);\n    return () => {\n      this.consumers = this.consumers.filter((consumer) => consumer !== onChange);\n    };\n  }\n  /**\n   * Initiates a connection with an embedded wallet.\n   * @param embeddedWallet - Information about the embedded wallet to connect to.\n   * @internal\n   */\n  connectEmbeddedWallet(embeddedWallet, options) {\n    const connect = (parameters) => {\n      setLastSelectedWalletInfo(embeddedWallet);\n      this.connector.connect({ jsBridgeKey: embeddedWallet.jsBridgeKey }, parameters, {\n        traceId: options.traceId\n      });\n    };\n    const additionalRequest = appState.connectRequestParameters;\n    if ((additionalRequest == null ? void 0 : additionalRequest.state) === \"loading\") {\n      this.setConnectRequestParametersCallback(connect);\n    } else {\n      connect(additionalRequest == null ? void 0 : additionalRequest.value);\n    }\n  }\n  /**\n   * Opens the modal window to connect to an external wallet, and waits when modal window is opened.\n   * @internal\n   */\n  openWalletsModal(options) {\n    return __async(this, null, function* () {\n      if (isInTMA()) {\n        sendExpand();\n      }\n      widgetController.openWalletsModal({ traceId: options.traceId });\n      return new Promise((resolve) => {\n        const unsubscribe = this.onStateChange((state) => {\n          const { status } = state;\n          if (status === \"opened\") {\n            unsubscribe();\n            resolve();\n          }\n        });\n      });\n    });\n  }\n}\nclass TransactionModalManager {\n  constructor(options) {\n    this.consumers = [];\n    this.connector = options.connector;\n    createEffect(() => {\n      const currentAction = action();\n      this.consumers.forEach((consumer) => consumer(currentAction));\n    });\n  }\n  /**\n   * Subscribe to the modal window state changes, returns unsubscribe function.\n   */\n  onStateChange(consumer) {\n    this.consumers.push(consumer);\n    return () => {\n      this.consumers = this.consumers.filter((c2) => c2 !== consumer);\n    };\n  }\n}\nclass SingleWalletModalManager {\n  constructor(options) {\n    this.consumers = [];\n    this.state = singleWalletModalState();\n    this.connector = options.connector;\n    this.tracker = options.tracker;\n    this.setConnectRequestParametersCallback = options.setConnectRequestParametersCallback;\n    createEffect(() => {\n      const state = singleWalletModalState();\n      this.state = state;\n      this.consumers.forEach((consumer) => consumer(state));\n    });\n  }\n  /**\n   * Opens the modal window with the specified wallet.\n   * @param wallet - Wallet app name.\n   * @throws TonConnectUIError if the specified wallet is not found.\n   */\n  open(wallet) {\n    return __async(this, null, function* () {\n      this.tracker.trackConnectionStarted();\n      const fetchedWalletsList = yield this.connector.getWallets();\n      const walletsList = applyWalletsListConfiguration(\n        fetchedWalletsList,\n        appState.walletsListConfiguration\n      );\n      const embeddedWallet = walletsList.find(_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyEmbedded);\n      const isEmbeddedWalletExist = !!embeddedWallet;\n      if (isEmbeddedWalletExist) {\n        return this.connectEmbeddedWallet(embeddedWallet);\n      }\n      const externalWallets = walletsList.filter(_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoRemote);\n      const externalWallet = externalWallets.find((walletInfo) => eqWalletName(walletInfo, wallet));\n      const isExternalWalletExist = !!externalWallet;\n      if (isExternalWalletExist) {\n        return this.openSingleWalletModal(externalWallet);\n      }\n      const error = `Trying to open modal window with unknown wallet \"${wallet}\".`;\n      this.tracker.trackConnectionError(error);\n      throw new TonConnectUIError(error);\n    });\n  }\n  /**\n   * Closes the modal window.\n   * @default 'action-cancelled'\n   */\n  close(reason = \"action-cancelled\") {\n    if (reason === \"action-cancelled\") {\n      this.tracker.trackConnectionError(\"Connection was cancelled\");\n    }\n    widgetController.closeSingleWalletModal(\"action-cancelled\");\n  }\n  /**\n   * Subscribe to the modal window state changes, returns unsubscribe function.\n   */\n  onStateChange(onChange) {\n    this.consumers.push(onChange);\n    return () => {\n      this.consumers = this.consumers.filter((consumer) => consumer !== onChange);\n    };\n  }\n  /**\n   * Initiates a connection with an embedded wallet.\n   * @param embeddedWallet - Information about the embedded wallet to connect to.\n   * @internal\n   */\n  connectEmbeddedWallet(embeddedWallet) {\n    const connect = (parameters) => {\n      setLastSelectedWalletInfo(embeddedWallet);\n      this.connector.connect({ jsBridgeKey: embeddedWallet.jsBridgeKey }, parameters);\n    };\n    const additionalRequest = appState.connectRequestParameters;\n    if ((additionalRequest == null ? void 0 : additionalRequest.state) === \"loading\") {\n      this.setConnectRequestParametersCallback(connect);\n    } else {\n      connect(additionalRequest == null ? void 0 : additionalRequest.value);\n    }\n  }\n  /**\n   * Opens the modal window to connect to a specified wallet, and waits when modal window is opened.\n   */\n  openSingleWalletModal(wallet) {\n    return __async(this, null, function* () {\n      if (isInTMA()) {\n        sendExpand();\n      }\n      widgetController.openSingleWalletModal(wallet);\n      return new Promise((resolve) => {\n        const unsubscribe = this.onStateChange((state) => {\n          const { status } = state;\n          if (status === \"opened\") {\n            unsubscribe();\n            resolve();\n          }\n        });\n      });\n    });\n  }\n}\nclass TonConnectUITracker {\n  constructor(options) {\n    this.eventPrefix = \"ton-connect-ui-\";\n    this.tonConnectSdkVersion = null;\n    this.eventDispatcher = options == null ? void 0 : options.eventDispatcher;\n    this.tonConnectUiVersion = options.tonConnectUiVersion;\n    this.init().catch();\n  }\n  /**\n   * Version of the library.\n   */\n  get version() {\n    return (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createVersionInfo)({\n      ton_connect_sdk_lib: this.tonConnectSdkVersion,\n      ton_connect_ui_lib: this.tonConnectUiVersion\n    });\n  }\n  /**\n   * Called once when the tracker is created and request version other libraries.\n   */\n  init() {\n    return __async(this, null, function* () {\n      try {\n        yield this.setRequestVersionHandler();\n        this.tonConnectSdkVersion = yield this.requestTonConnectSdkVersion();\n      } catch (e2) {\n      }\n    });\n  }\n  /**\n   * Set request version handler.\n   * @private\n   */\n  setRequestVersionHandler() {\n    return __async(this, null, function* () {\n      yield this.eventDispatcher.addEventListener(\"ton-connect-ui-request-version\", () => __async(this, null, function* () {\n        yield this.eventDispatcher.dispatchEvent(\n          \"ton-connect-ui-response-version\",\n          (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createResponseVersionEvent)(this.tonConnectUiVersion)\n        );\n      }));\n    });\n  }\n  /**\n   * Request TonConnect SDK version.\n   * @private\n   */\n  requestTonConnectSdkVersion() {\n    return __async(this, null, function* () {\n      return new Promise((resolve, reject) => __async(this, null, function* () {\n        try {\n          yield this.eventDispatcher.addEventListener(\n            \"ton-connect-response-version\",\n            (event) => {\n              resolve(event.detail.version);\n            },\n            { once: true }\n          );\n          yield this.eventDispatcher.dispatchEvent(\n            \"ton-connect-request-version\",\n            (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createRequestVersionEvent)()\n          );\n        } catch (e2) {\n          reject(e2);\n        }\n      }));\n    });\n  }\n  /**\n   * Emit user action event to the window.\n   * @param eventDetails\n   * @private\n   */\n  dispatchUserActionEvent(eventDetails) {\n    var _a2;\n    try {\n      (_a2 = this.eventDispatcher) == null ? void 0 : _a2.dispatchEvent(`${this.eventPrefix}${eventDetails.type}`, eventDetails).catch();\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track wallet opened event.\n   * @param args\n   */\n  trackWalletModalOpened(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createWalletModalOpenedEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track wallet selected event.\n   * @param args\n   */\n  trackSelectedWallet(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createSelectedWalletEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n      logError(e2);\n    }\n  }\n  /**\n   * Track connection init event.\n   * @param args\n   */\n  trackConnectionStarted(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionStartedEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track connection success event.\n   * @param args\n   */\n  trackConnectionCompleted(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionCompletedEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track connection error event.\n   * @param args\n   */\n  trackConnectionError(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionErrorEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track connection restoring init event.\n   * @param args\n   */\n  trackConnectionRestoringStarted(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionRestoringStartedEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track connection restoring success event.\n   * @param args\n   */\n  trackConnectionRestoringCompleted(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionRestoringCompletedEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track connection restoring error event.\n   * @param args\n   */\n  trackConnectionRestoringError(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createConnectionRestoringErrorEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track disconnect event.\n   * @param args\n   */\n  trackDisconnection(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createDisconnectionEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track transaction init event.\n   * @param args\n   */\n  trackTransactionSentForSignature(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createTransactionSentForSignatureEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track transaction signed event.\n   * @param args\n   */\n  trackTransactionSigned(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createTransactionSignedEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track transaction error event.\n   * @param args\n   */\n  trackTransactionSigningFailed(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createTransactionSigningFailedEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track data sent for signature event.\n   * @param args\n   */\n  trackDataSentForSignature(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createDataSentForSignatureEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track data signed event.\n   * @param args\n   */\n  trackDataSigned(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createDataSignedEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track data signing error event.\n   * @param args\n   */\n  trackDataSigningFailed(...args) {\n    try {\n      const event = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.createDataSigningFailedEvent)(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n}\nconst tonConnectUiVersion = \"2.4.2\";\nclass TonConnectEnvironment {\n  constructor() {\n    this.userAgent = getUserAgent();\n  }\n  getLocale() {\n    var _a2;\n    return ((_a2 = navigator.languages) == null ? void 0 : _a2[0]) || navigator.language || \"\";\n  }\n  getBrowser() {\n    var _a2;\n    return (_a2 = this.userAgent.browser) != null ? _a2 : \"\";\n  }\n  getPlatform() {\n    var _a2;\n    return (_a2 = this.userAgent.os) != null ? _a2 : \"\";\n  }\n  getTelegramUser() {\n    return getTgUser();\n  }\n  getClientEnvironment() {\n    return isInTMA() ? \"miniapp\" : \"web\";\n  }\n}\nclass TonConnectUI {\n  // TODO: `actionsConfiguration.twaReturnUrl` is used only in `connectWallet` method, but it's not used in `sendTransaction` method, NEED TO FIX IT\n  constructor(options) {\n    var _a2;\n    this.walletInfoStorage = new WalletInfoStorage();\n    this.preferredWalletStorage = new PreferredWalletStorage();\n    this.walletInfo = null;\n    this.systemThemeChangeUnsubscribe = null;\n    this.connectionRestored = Promise.resolve(false);\n    let eventDispatcher = (_a2 = options == null ? void 0 : options.eventDispatcher) != null ? _a2 : new _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.BrowserEventDispatcher();\n    if (options && \"connector\" in options && options.connector) {\n      this.connector = options.connector;\n    } else if (options && \"manifestUrl\" in options && options.manifestUrl) {\n      this.connector = new _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnect({\n        manifestUrl: options.manifestUrl,\n        eventDispatcher,\n        walletsRequiredFeatures: options.walletsRequiredFeatures,\n        environment: new TonConnectEnvironment(),\n        analytics: options.analytics\n      });\n    } else {\n      throw new TonConnectUIError(\n        \"You have to specify a `manifestUrl` or a `connector` in the options.\"\n      );\n    }\n    this.tracker = new TonConnectUITracker({\n      eventDispatcher,\n      tonConnectUiVersion\n    });\n    this.modal = new WalletsModalManager({\n      connector: this.connector,\n      tracker: this.tracker,\n      setConnectRequestParametersCallback: (callback) => {\n        this.connectRequestParametersCallback = callback;\n      }\n    });\n    this.singleWalletModal = new SingleWalletModalManager({\n      connector: this.connector,\n      tracker: this.tracker,\n      setConnectRequestParametersCallback: (callback) => {\n        this.connectRequestParametersCallback = callback;\n      }\n    });\n    this.transactionModal = new TransactionModalManager({\n      connector: this.connector\n    });\n    this._walletsRequiredFeatures = options.walletsRequiredFeatures;\n    this._walletsPreferredFeatures = options.walletsPreferredFeatures;\n    this.walletsList = this.getWallets();\n    this.walletsList.then((list) => preloadImages(uniq(list.map((item) => item.imageUrl))));\n    const rootId = this.normalizeWidgetRoot(options == null ? void 0 : options.widgetRootId);\n    this.subscribeToWalletChange();\n    if ((options == null ? void 0 : options.restoreConnection) !== false) {\n      this.connectionRestored = createMacrotaskAsync(() => __async(this, null, function* () {\n        this.tracker.trackConnectionRestoringStarted();\n        yield this.connector.restoreConnection();\n        if (!this.connector.connected) {\n          this.tracker.trackConnectionRestoringError(\"Connection was not restored\");\n          this.walletInfoStorage.removeWalletInfo();\n        } else {\n          this.tracker.trackConnectionRestoringCompleted(this.wallet);\n        }\n        return this.connector.connected;\n      }));\n    }\n    this.uiOptions = mergeOptions(options, { uiPreferences: { theme: \"SYSTEM\" } });\n    const preferredWalletName = this.preferredWalletStorage.getPreferredWalletAppName();\n    setAppState({\n      connector: this.connector,\n      preferredWalletAppName: preferredWalletName\n    });\n    widgetController.renderApp(rootId, this);\n  }\n  static getWallets() {\n    return _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnect.getWallets();\n  }\n  get walletsRequiredFeatures() {\n    return this._walletsRequiredFeatures;\n  }\n  get walletsPreferredFeatures() {\n    return this._walletsPreferredFeatures;\n  }\n  /**\n   * Current connection status.\n   */\n  get connected() {\n    return this.connector.connected;\n  }\n  /**\n   * Current connected account or null.\n   */\n  get account() {\n    return this.connector.account;\n  }\n  /**\n   * Curren connected wallet app and its info or null.\n   */\n  get wallet() {\n    if (!this.connector.wallet) {\n      return null;\n    }\n    return __spreadValues(__spreadValues({}, this.connector.wallet), this.walletInfo);\n  }\n  /**\n   * Set and apply new UI options. Object with partial options should be passed. Passed options will be merged with current options.\n   * @param options\n   */\n  set uiOptions(options) {\n    var _a2, _b2, _c2, _d2, _e2;\n    this.checkButtonRootExist(options.buttonRootId);\n    this.actionsConfiguration = options.actionsConfiguration;\n    if (\"walletsRequiredFeatures\" in options) {\n      this._walletsRequiredFeatures = options.walletsRequiredFeatures;\n    }\n    if (\"walletsPreferredFeatures\" in options) {\n      this._walletsPreferredFeatures = options.walletsPreferredFeatures;\n    }\n    if ((_a2 = options.uiPreferences) == null ? void 0 : _a2.theme) {\n      if (((_b2 = options.uiPreferences) == null ? void 0 : _b2.theme) !== \"SYSTEM\") {\n        (_c2 = this.systemThemeChangeUnsubscribe) == null ? void 0 : _c2.call(this);\n        setTheme(options.uiPreferences.theme, options.uiPreferences.colorsSet);\n      } else {\n        setTheme(getSystemTheme(), options.uiPreferences.colorsSet);\n        if (!this.systemThemeChangeUnsubscribe) {\n          this.systemThemeChangeUnsubscribe = subscribeToThemeChange(setTheme);\n        }\n      }\n    } else {\n      if ((_d2 = options.uiPreferences) == null ? void 0 : _d2.colorsSet) {\n        setColors(options.uiPreferences.colorsSet);\n      }\n    }\n    if ((_e2 = options.uiPreferences) == null ? void 0 : _e2.borderRadius) {\n      setBorderRadius(options.uiPreferences.borderRadius);\n    }\n    setAppState((state) => {\n      var _a3, _b3;\n      const merged = mergeOptions(\n        __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, options.language && { language: options.language }), !!((_a3 = options.actionsConfiguration) == null ? void 0 : _a3.returnStrategy) && {\n          returnStrategy: options.actionsConfiguration.returnStrategy\n        }), !!((_b3 = options.actionsConfiguration) == null ? void 0 : _b3.twaReturnUrl) && {\n          twaReturnUrl: options.actionsConfiguration.twaReturnUrl\n        }), !!options.walletsListConfiguration && {\n          walletsListConfiguration: options.walletsListConfiguration\n        }),\n        unwrap(state)\n      );\n      if (options.buttonRootId !== void 0) {\n        merged.buttonRootId = options.buttonRootId;\n      }\n      if (options.enableAndroidBackHandler !== void 0) {\n        merged.enableAndroidBackHandler = options.enableAndroidBackHandler;\n      }\n      return merged;\n    });\n  }\n  /**\n   * Use it to customize ConnectRequest and add `tonProof` payload.\n   * You can call it multiply times to set updated tonProof payload if previous one is outdated.\n   * If `connectRequestParameters.state === 'loading'` loader will appear instead of the qr code in the wallets modal.\n   * If `connectRequestParameters.state` was changed to 'ready' or it's value has been changed, QR will be re-rendered.\n   */\n  setConnectRequestParameters(connectRequestParameters) {\n    var _a2;\n    setAppState({ connectRequestParameters });\n    if ((connectRequestParameters == null ? void 0 : connectRequestParameters.state) === \"ready\" || !connectRequestParameters) {\n      (_a2 = this.connectRequestParametersCallback) == null ? void 0 : _a2.call(this, connectRequestParameters == null ? void 0 : connectRequestParameters.value);\n    }\n  }\n  /**\n   * Set desired network for the connection. Can only be set before connecting.\n   * If wallet connects with a different chain, the SDK will throw an error and abort connection.\n   * @param network desired network id (e.g., '-239', '-3', or custom). Pass undefined to allow any network.\n   */\n  setConnectionNetwork(network) {\n    this.connector.setConnectionNetwork(network);\n  }\n  /**\n   * Returns available wallets list.\n   */\n  getWallets() {\n    return __async(this, null, function* () {\n      return this.connector.getWallets();\n    });\n  }\n  /**\n   * Subscribe to connection status change.\n   * @return function which has to be called to unsubscribe.\n   */\n  onStatusChange(callback, errorsHandler) {\n    return this.connector.onStatusChange((wallet) => __async(this, null, function* () {\n      if (wallet) {\n        const lastSelectedWalletInfo2 = yield this.getSelectedWalletInfo(wallet);\n        callback(__spreadValues(__spreadValues({}, wallet), lastSelectedWalletInfo2 || this.walletInfoStorage.getWalletInfo()));\n      } else {\n        callback(wallet);\n      }\n    }), errorsHandler);\n  }\n  /**\n   * Opens the modal window, returns a promise that resolves after the modal window is opened.\n   */\n  openModal(options) {\n    return __async(this, null, function* () {\n      var _a2;\n      const traceId = (_a2 = options == null ? void 0 : options.traceId) != null ? _a2 : (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.UUIDv7)();\n      yield this.modal.open({ traceId });\n      const sessionId = yield this.getSessionId();\n      const visibleWallets = widgetController.getLastVisibleWallets();\n      this.tracker.trackWalletModalOpened(\n        visibleWallets.wallets.map((wallet) => wallet.name),\n        sessionId,\n        options == null ? void 0 : options.traceId\n      );\n    });\n  }\n  /**\n   * Closes the modal window.\n   */\n  closeModal(reason) {\n    this.modal.close(reason);\n  }\n  /**\n   * Subscribe to the modal window state changes, returns a function which has to be called to unsubscribe.\n   */\n  onModalStateChange(onChange) {\n    return this.modal.onStateChange(onChange);\n  }\n  /**\n   * Returns current modal window state.\n   */\n  get modalState() {\n    return this.modal.state;\n  }\n  /**\n   * Opens the single wallet modal window, returns a promise that resolves after the modal window is opened.\n   * @experimental\n   */\n  openSingleWalletModal(wallet) {\n    return __async(this, null, function* () {\n      return this.singleWalletModal.open(wallet);\n    });\n  }\n  /**\n   * Close the single wallet modal window.\n   * @experimental\n   */\n  closeSingleWalletModal(closeReason) {\n    this.singleWalletModal.close(closeReason);\n  }\n  /**\n   * Subscribe to the single wallet modal window state changes, returns a function which has to be called to unsubscribe.\n   * @experimental\n   */\n  onSingleWalletModalStateChange(onChange) {\n    return this.singleWalletModal.onStateChange(onChange);\n  }\n  /**\n   * Returns current single wallet modal window state.\n   * @experimental\n   */\n  get singleWalletModalState() {\n    return this.singleWalletModal.state;\n  }\n  /**\n   * @deprecated Use `tonConnectUI.openModal()` instead. Will be removed in the next major version.\n   * Opens the modal window and handles a wallet connection.\n   * @return Connected wallet.\n   * @throws TonConnectUIError if connection was aborted.\n   */\n  connectWallet(options) {\n    return __async(this, null, function* () {\n      var _a2;\n      const traceId = (_a2 = options == null ? void 0 : options.traceId) != null ? _a2 : (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.UUIDv7)();\n      const walletsList = yield this.getWallets();\n      const embeddedWallet = walletsList.find(_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyEmbedded);\n      if (embeddedWallet) {\n        return yield this.connectEmbeddedWallet(embeddedWallet, { traceId });\n      } else {\n        return yield this.connectExternalWallet({ traceId });\n      }\n    });\n  }\n  /**\n   * Disconnect wallet and clean localstorage.\n   */\n  disconnect(options) {\n    var _a2;\n    const traceId = (_a2 = options == null ? void 0 : options.traceId) != null ? _a2 : (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.UUIDv7)();\n    this.tracker.trackDisconnection(this.wallet, \"dapp\");\n    widgetController.clearAction();\n    widgetController.removeSelectedWalletInfo();\n    this.walletInfoStorage.removeWalletInfo();\n    return this.connector.disconnect({ traceId });\n  }\n  /**\n   * Opens the modal window and handles the transaction sending.\n   * @param tx transaction to send.\n   * @param options modal and notifications behaviour settings. Default is show only 'before' modal and all notifications.\n   */\n  sendTransaction(tx, options) {\n    return __async(this, null, function* () {\n      var _a2;\n      const traceId = (_a2 = options == null ? void 0 : options.traceId) != null ? _a2 : (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.UUIDv7)();\n      this.tracker.trackTransactionSentForSignature(this.wallet, tx);\n      if (!this.connected) {\n        this.tracker.trackTransactionSigningFailed(this.wallet, tx, \"Wallet was not connected\");\n        throw new TonConnectUIError(\"Connect wallet to send a transaction.\");\n      }\n      if (isInTMA()) {\n        sendExpand();\n      }\n      const { notifications: notifications2, modals, returnStrategy, twaReturnUrl } = this.getModalsAndNotificationsConfiguration(options);\n      const sessionId = yield this.getSessionId();\n      widgetController.setAction({\n        name: \"confirm-transaction\",\n        showNotification: notifications2.includes(\"before\"),\n        openModal: modals.includes(\"before\"),\n        sent: false,\n        sessionId: sessionId || void 0,\n        traceId\n      });\n      const abortController = new AbortController();\n      const onRequestSent = () => {\n        var _a3;\n        if (abortController.signal.aborted) {\n          return;\n        }\n        widgetController.setAction({\n          name: \"confirm-transaction\",\n          showNotification: notifications2.includes(\"before\"),\n          openModal: modals.includes(\"before\"),\n          sent: true,\n          sessionId: sessionId || void 0,\n          traceId\n        });\n        this.redirectAfterRequestSent({\n          returnStrategy,\n          twaReturnUrl,\n          sessionId: sessionId || void 0,\n          traceId\n        });\n        let firstClick = true;\n        const redirectToWallet2 = () => __async(this, null, function* () {\n          if (abortController.signal.aborted) {\n            return;\n          }\n          const forceRedirect = !firstClick;\n          firstClick = false;\n          yield this.redirectAfterRequestSent({\n            returnStrategy,\n            twaReturnUrl,\n            forceRedirect,\n            sessionId: sessionId || void 0,\n            traceId\n          });\n        });\n        (_a3 = options == null ? void 0 : options.onRequestSent) == null ? void 0 : _a3.call(options, redirectToWallet2);\n      };\n      const unsubscribe = this.onTransactionModalStateChange((action2) => {\n        if (action2 == null ? void 0 : action2.openModal) {\n          return;\n        }\n        unsubscribe();\n        if (!action2) {\n          abortController.abort();\n        }\n      });\n      try {\n        const result = yield this.waitForSendTransaction(\n          {\n            transaction: tx,\n            signal: abortController.signal,\n            traceId\n          },\n          onRequestSent\n        );\n        this.tracker.trackTransactionSigned(this.wallet, tx, result);\n        widgetController.setAction({\n          name: \"transaction-sent\",\n          showNotification: notifications2.includes(\"success\"),\n          openModal: modals.includes(\"success\"),\n          traceId\n        });\n        return result;\n      } catch (e2) {\n        if (e2 instanceof _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletNotSupportFeatureError) {\n          widgetController.clearAction();\n          widgetController.openWalletNotSupportFeatureModal(e2.cause, { traceId });\n          throw e2;\n        }\n        widgetController.setAction({\n          name: \"transaction-canceled\",\n          showNotification: notifications2.includes(\"error\"),\n          openModal: modals.includes(\"error\"),\n          traceId\n        });\n        if (e2 instanceof _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnectError) {\n          throw e2;\n        } else {\n          console.error(e2);\n          throw new TonConnectUIError(\"Unhandled error:\" + e2);\n        }\n      } finally {\n        unsubscribe();\n      }\n    });\n  }\n  /**\n   * Signs the data and returns the signature.\n   * @param data data to sign.\n   */\n  signData(data, options) {\n    return __async(this, null, function* () {\n      var _a2;\n      const traceId = (_a2 = options == null ? void 0 : options.traceId) != null ? _a2 : (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.UUIDv7)();\n      this.tracker.trackDataSentForSignature(this.wallet, data);\n      if (!this.connected) {\n        this.tracker.trackDataSigningFailed(this.wallet, data, \"Wallet was not connected\");\n        throw new TonConnectUIError(\"Connect wallet to send a transaction.\");\n      }\n      if (isInTMA()) {\n        sendExpand();\n      }\n      const { notifications: notifications2, modals, returnStrategy, twaReturnUrl } = this.getModalsAndNotificationsConfiguration();\n      const sessionId = yield this.getSessionId();\n      widgetController.setAction({\n        name: \"confirm-sign-data\",\n        showNotification: notifications2.includes(\"before\"),\n        openModal: modals.includes(\"before\"),\n        signed: false,\n        sessionId: sessionId || void 0,\n        traceId\n      });\n      const abortController = new AbortController();\n      const onRequestSent = () => {\n        var _a3;\n        if (abortController.signal.aborted) {\n          return;\n        }\n        widgetController.setAction({\n          name: \"confirm-sign-data\",\n          showNotification: notifications2.includes(\"before\"),\n          openModal: modals.includes(\"before\"),\n          signed: true,\n          sessionId: sessionId || void 0,\n          traceId\n        });\n        this.redirectAfterRequestSent({\n          returnStrategy,\n          twaReturnUrl,\n          sessionId: sessionId || void 0,\n          traceId\n        });\n        let firstClick = true;\n        const redirectToWallet2 = () => {\n          if (abortController.signal.aborted) {\n            return;\n          }\n          const forceRedirect = !firstClick;\n          firstClick = false;\n          this.redirectAfterRequestSent({\n            returnStrategy,\n            twaReturnUrl,\n            forceRedirect,\n            sessionId: sessionId || void 0,\n            traceId\n          });\n        };\n        (_a3 = options == null ? void 0 : options.onRequestSent) == null ? void 0 : _a3.call(options, redirectToWallet2);\n      };\n      const unsubscribe = this.onTransactionModalStateChange((action2) => {\n        if (action2 == null ? void 0 : action2.openModal) {\n          return;\n        }\n        unsubscribe();\n        if (!action2) {\n          abortController.abort();\n        }\n      });\n      try {\n        const result = yield this.waitForSignData(\n          {\n            data,\n            signal: new AbortController().signal,\n            traceId\n          },\n          onRequestSent\n        );\n        this.tracker.trackDataSigned(this.wallet, data, result);\n        widgetController.setAction({\n          name: \"data-signed\",\n          showNotification: notifications2.includes(\"success\"),\n          openModal: modals.includes(\"success\"),\n          traceId\n        });\n        return result;\n      } catch (e2) {\n        if (e2 instanceof _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.WalletNotSupportFeatureError) {\n          widgetController.clearAction();\n          widgetController.openWalletNotSupportFeatureModal(e2.cause, { traceId });\n          throw e2;\n        }\n        widgetController.setAction({\n          name: \"sign-data-canceled\",\n          showNotification: notifications2.includes(\"error\"),\n          openModal: modals.includes(\"error\"),\n          traceId\n        });\n        if (e2 instanceof _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnectError) {\n          throw e2;\n        } else {\n          console.error(e2);\n          throw new TonConnectUIError(\"Unhandled error:\" + e2);\n        }\n      } finally {\n        unsubscribe();\n      }\n    });\n  }\n  /**\n   * Gets the current session ID if available.\n   * @returns session ID string or null if not available.\n   */\n  getSessionId() {\n    return __async(this, null, function* () {\n      var _a2, _b2;\n      try {\n        const storage = (_a2 = this.connector.dappSettings) == null ? void 0 : _a2.storage;\n        if (storage) {\n          const stored = yield storage.getItem(\"ton-connect-storage_bridge-connection\");\n          if (stored) {\n            const connection = JSON.parse(stored);\n            if (connection.type === \"http\" && connection.sessionCrypto) {\n              const sessionCrypto = new _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.SessionCrypto(connection.sessionCrypto);\n              const sessionId = sessionCrypto.sessionId;\n              return sessionId;\n            } else if (connection.type === \"http\" && ((_b2 = connection.session) == null ? void 0 : _b2.sessionKeyPair)) {\n              const sessionCrypto = new _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.SessionCrypto(connection.session.sessionKeyPair);\n              const sessionId = sessionCrypto.sessionId;\n              return sessionId;\n            }\n          }\n        }\n      } catch (e2) {\n      }\n      return null;\n    });\n  }\n  redirectAfterRequestSent({\n    returnStrategy,\n    twaReturnUrl,\n    forceRedirect,\n    sessionId,\n    traceId\n  }) {\n    if (this.walletInfo && \"universalLink\" in this.walletInfo && (this.walletInfo.openMethod === \"universal-link\" || this.walletInfo.openMethod === \"custom-deeplink\")) {\n      const linkWithSessionId = enrichUniversalLink(this.walletInfo.universalLink, {\n        sessionId,\n        traceId\n      });\n      if ((0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isTelegramUrl)(this.walletInfo.universalLink)) {\n        redirectToTelegram(linkWithSessionId, {\n          returnStrategy,\n          twaReturnUrl: twaReturnUrl || appState.twaReturnUrl,\n          forceRedirect: forceRedirect || false\n        });\n      } else {\n        redirectToWallet(\n          linkWithSessionId,\n          this.walletInfo.deepLink,\n          {\n            returnStrategy,\n            forceRedirect: forceRedirect || false\n          },\n          () => {\n          }\n        );\n      }\n    }\n  }\n  /**\n   * TODO: remove in the next major version.\n   * Initiates a connection with an embedded wallet, awaits its completion, and returns the connected wallet information.\n   * @param embeddedWallet - Information about the embedded wallet to connect to.\n   * @throws Error if the connection process fails.\n   * @internal\n   */\n  connectEmbeddedWallet(embeddedWallet, options) {\n    return __async(this, null, function* () {\n      const connect = (parameters) => {\n        setLastSelectedWalletInfo(embeddedWallet);\n        this.connector.connect({ jsBridgeKey: embeddedWallet.jsBridgeKey }, parameters, {\n          traceId: options.traceId\n        });\n      };\n      const additionalRequest = appState.connectRequestParameters;\n      if ((additionalRequest == null ? void 0 : additionalRequest.state) === \"loading\") {\n        this.connectRequestParametersCallback = connect;\n      } else {\n        connect(additionalRequest == null ? void 0 : additionalRequest.value);\n      }\n      return yield this.waitForWalletConnection({\n        ignoreErrors: false,\n        traceId: options.traceId\n      });\n    });\n  }\n  /**\n   * TODO: remove in the next major version.\n   * Initiates the connection process for an external wallet by opening the wallet modal\n   * and returns the connected wallet information upon successful connection.\n   * @throws Error if the user cancels the connection process or if the connection process fails.\n   * @internal\n   */\n  connectExternalWallet(options) {\n    return __async(this, null, function* () {\n      const abortController = new AbortController();\n      widgetController.openWalletsModal({ traceId: options.traceId });\n      const unsubscribe = this.onModalStateChange((state) => {\n        const { status, closeReason } = state;\n        if (status === \"opened\") {\n          return;\n        }\n        unsubscribe();\n        if (closeReason === \"action-cancelled\") {\n          abortController.abort();\n        }\n      });\n      return yield this.waitForWalletConnection({\n        ignoreErrors: true,\n        signal: abortController.signal,\n        traceId: options.traceId\n      });\n    });\n  }\n  /**\n   * TODO: remove in the next major version.\n   * Waits for a wallet connection based on provided options, returning connected wallet information.\n   * @param options - Configuration for connection statuses and errors handling.\n   * @options.ignoreErrors - If true, ignores errors during waiting, waiting continues until a valid wallet connects. Default is false.\n   * @options.abortSignal - Optional AbortSignal for external cancellation. Throws TonConnectUIError if aborted.\n   * @throws TonConnectUIError if waiting is aborted or no valid wallet connection is received and ignoreErrors is false.\n   * @internal\n   */\n  waitForWalletConnection(options) {\n    return __async(this, null, function* () {\n      return new Promise((resolve, reject) => {\n        this.tracker.trackConnectionStarted();\n        const { ignoreErrors = false, signal = null } = options;\n        if (signal && signal.aborted) {\n          this.tracker.trackConnectionError(\"Connection was cancelled\");\n          return reject(new TonConnectUIError(\"Wallet was not connected\"));\n        }\n        const onStatusChangeHandler = (wallet) => __async(this, null, function* () {\n          if (!wallet) {\n            this.tracker.trackConnectionError(\"Connection was cancelled\");\n            if (ignoreErrors) {\n              return;\n            }\n            unsubscribe();\n            reject(new TonConnectUIError(\"Wallet was not connected\"));\n          } else {\n            this.tracker.trackConnectionCompleted(wallet);\n            unsubscribe();\n            resolve(wallet);\n          }\n        });\n        const onErrorsHandler = (reason) => {\n          this.tracker.trackConnectionError(reason.message);\n          if (ignoreErrors) {\n            return;\n          }\n          unsubscribe();\n          reject(reason);\n        };\n        const unsubscribe = this.onStatusChange(\n          (wallet) => onStatusChangeHandler(wallet),\n          (reason) => onErrorsHandler(reason)\n        );\n        if (signal) {\n          signal.addEventListener(\n            \"abort\",\n            () => {\n              unsubscribe();\n              reject(new TonConnectUIError(\"Wallet was not connected\"));\n            },\n            { once: true }\n          );\n        }\n      });\n    });\n  }\n  /**\n   * Waits for a transaction to be sent based on provided options, returning the transaction response.\n   * @param options - Configuration for transaction statuses and errors handling.\n   * @options.transaction - Transaction to send.\n   * @options.ignoreErrors - If true, ignores errors during waiting, waiting continues until a valid transaction is sent. Default is false.\n   * @options.abortSignal - Optional AbortSignal for external cancellation. Throws TonConnectUIError if aborted.\n   * @param onRequestSent (optional) will be called after the transaction is sent to the wallet.\n   * @throws TonConnectUIError if waiting is aborted or no valid transaction response is received and ignoreErrors is false.\n   * @internal\n   */\n  waitForSendTransaction(options, onRequestSent) {\n    return __async(this, null, function* () {\n      return new Promise((resolve, reject) => {\n        const { transaction, signal } = options;\n        if (signal.aborted) {\n          this.tracker.trackTransactionSigningFailed(\n            this.wallet,\n            transaction,\n            \"Transaction was cancelled\"\n          );\n          return reject(new TonConnectUIError(\"Transaction was not sent\"));\n        }\n        const onTransactionHandler = (transaction2) => __async(this, null, function* () {\n          resolve(transaction2);\n        });\n        const onErrorsHandler = (reason) => {\n          reject(reason);\n        };\n        const onCanceledHandler = () => {\n          this.tracker.trackTransactionSigningFailed(\n            this.wallet,\n            transaction,\n            \"Transaction was cancelled\"\n          );\n          reject(new TonConnectUIError(\"Transaction was not sent\"));\n        };\n        signal.addEventListener(\"abort\", onCanceledHandler, { once: true });\n        this.connector.sendTransaction(transaction, {\n          onRequestSent,\n          signal,\n          traceId: options.traceId\n        }).then((result) => {\n          signal.removeEventListener(\"abort\", onCanceledHandler);\n          return onTransactionHandler(result);\n        }).catch((reason) => {\n          signal.removeEventListener(\"abort\", onCanceledHandler);\n          return onErrorsHandler(reason);\n        });\n      });\n    });\n  }\n  /**\n   * Waits for a transaction to be sent based on provided options, returning the transaction response.\n   * @param options - Configuration for transaction statuses and errors handling.\n   * @options.transaction - Transaction to send.\n   * @options.ignoreErrors - If true, ignores errors during waiting, waiting continues until a valid transaction is sent. Default is false.\n   * @options.abortSignal - Optional AbortSignal for external cancellation. Throws TonConnectUIError if aborted.\n   * @param onRequestSent (optional) will be called after the transaction is sent to the wallet.\n   * @throws TonConnectUIError if waiting is aborted or no valid transaction response is received and ignoreErrors is false.\n   * @internal\n   */\n  waitForSignData(options, onRequestSent) {\n    return __async(this, null, function* () {\n      return new Promise((resolve, reject) => {\n        const { data, signal } = options;\n        if (signal.aborted) {\n          this.tracker.trackDataSigningFailed(this.wallet, data, \"SignData was cancelled\");\n          return reject(new TonConnectUIError(\"SignData was not sent\"));\n        }\n        const onSignHandler = (data2) => __async(this, null, function* () {\n          resolve(data2);\n        });\n        const onErrorsHandler = (reason) => {\n          reject(reason);\n        };\n        const onCanceledHandler = () => {\n          this.tracker.trackDataSigningFailed(this.wallet, data, \"SignData was cancelled\");\n          reject(new TonConnectUIError(\"SignData was not sent\"));\n        };\n        signal.addEventListener(\"abort\", onCanceledHandler, { once: true });\n        this.connector.signData(data, { onRequestSent, signal }).then((result) => {\n          return onSignHandler(result);\n        }).catch((reason) => {\n          return onErrorsHandler(reason);\n        });\n      });\n    });\n  }\n  /**\n   * Subscribe to the transaction modal window state changes, returns a function which has to be called to unsubscribe.\n   * @internal\n   */\n  onTransactionModalStateChange(onChange) {\n    return this.transactionModal.onStateChange(onChange);\n  }\n  subscribeToWalletChange() {\n    this.connector.onStatusChange((wallet) => __async(this, null, function* () {\n      var _a2;\n      if (wallet) {\n        yield this.updateWalletInfo(wallet);\n        this.setPreferredWalletAppName(((_a2 = this.walletInfo) == null ? void 0 : _a2.appName) || wallet.device.appName);\n      } else {\n        this.walletInfoStorage.removeWalletInfo();\n      }\n    }));\n  }\n  setPreferredWalletAppName(value) {\n    this.preferredWalletStorage.setPreferredWalletAppName(value);\n    setAppState({ preferredWalletAppName: value });\n  }\n  getSelectedWalletInfo(wallet) {\n    return __async(this, null, function* () {\n      let lastSelectedWalletInfo2 = widgetController.getSelectedWalletInfo();\n      if (!lastSelectedWalletInfo2) {\n        return null;\n      }\n      if (!(\"name\" in lastSelectedWalletInfo2)) {\n        if (wallet.device.appName === WALLET_CONNECT_APP_NAME) {\n          return {\n            type: \"wallet-connect\",\n            name: WALLET_CONNECT_WALLET_NAME,\n            appName: WALLET_CONNECT_APP_NAME,\n            imageUrl: IMG.WALLET_CONNECT,\n            aboutUrl: WALLET_CONNECT_ABOUT_URL,\n            features: wallet.device.features,\n            platforms: []\n          };\n        }\n        const walletsList = applyWalletsListConfiguration(\n          yield this.walletsList,\n          appState.walletsListConfiguration\n        );\n        const walletInfo = walletsList.find((item) => eqWalletName(item, wallet.device.appName));\n        if (!walletInfo) {\n          throw new TonConnectUIError(\n            `Cannot find WalletInfo for the '${wallet.device.appName}' wallet`\n          );\n        }\n        return __spreadValues(__spreadValues({}, walletInfo), lastSelectedWalletInfo2);\n      }\n      return lastSelectedWalletInfo2;\n    });\n  }\n  updateWalletInfo(wallet) {\n    return __async(this, null, function* () {\n      const selectedWalletInfo = yield this.getSelectedWalletInfo(wallet);\n      if (selectedWalletInfo) {\n        this.walletInfo = selectedWalletInfo;\n        this.walletInfoStorage.setWalletInfo(selectedWalletInfo);\n        return;\n      }\n      const storedWalletInfo = this.walletInfoStorage.getWalletInfo();\n      if (storedWalletInfo) {\n        this.walletInfo = storedWalletInfo;\n        return;\n      }\n      this.walletInfo = (yield this.walletsList).find(\n        (walletInfo) => eqWalletName(walletInfo, wallet.device.appName)\n      ) || null;\n    });\n  }\n  normalizeWidgetRoot(rootId) {\n    if (!rootId || !document.getElementById(rootId)) {\n      rootId = \"tc-widget-root\";\n      const rootElement = document.createElement(\"div\");\n      rootElement.id = rootId;\n      document.body.appendChild(rootElement);\n    }\n    return rootId;\n  }\n  checkButtonRootExist(buttonRootId) {\n    if (buttonRootId == null) {\n      return;\n    }\n    if (!document.getElementById(buttonRootId)) {\n      throw new TonConnectUIError(`${buttonRootId} element not found in the document.`);\n    }\n  }\n  // eslint-disable-next-line complexity\n  getModalsAndNotificationsConfiguration(options) {\n    var _a2, _b2, _c2, _d2, _e2, _f2;\n    const allActions = [\n      \"before\",\n      \"success\",\n      \"error\"\n    ];\n    let notifications2 = allActions;\n    if (((_a2 = this.actionsConfiguration) == null ? void 0 : _a2.notifications) && ((_b2 = this.actionsConfiguration) == null ? void 0 : _b2.notifications) !== \"all\") {\n      notifications2 = this.actionsConfiguration.notifications;\n    }\n    if (options == null ? void 0 : options.notifications) {\n      if (options.notifications === \"all\") {\n        notifications2 = allActions;\n      } else {\n        notifications2 = options.notifications;\n      }\n    }\n    let modals = [\"before\"];\n    if ((_c2 = this.actionsConfiguration) == null ? void 0 : _c2.modals) {\n      if (this.actionsConfiguration.modals === \"all\") {\n        modals = allActions;\n      } else {\n        modals = this.actionsConfiguration.modals;\n      }\n    }\n    if (options == null ? void 0 : options.modals) {\n      if (options.modals === \"all\") {\n        modals = allActions;\n      } else {\n        modals = options.modals;\n      }\n    }\n    const returnStrategy = (options == null ? void 0 : options.returnStrategy) || ((_d2 = this.actionsConfiguration) == null ? void 0 : _d2.returnStrategy) || \"back\";\n    const twaReturnUrl = (options == null ? void 0 : options.twaReturnUrl) || ((_e2 = this.actionsConfiguration) == null ? void 0 : _e2.twaReturnUrl);\n    let skipRedirectToWallet = (options == null ? void 0 : options.skipRedirectToWallet) || ((_f2 = this.actionsConfiguration) == null ? void 0 : _f2.skipRedirectToWallet) || \"ios\";\n    if (isInTMA()) {\n      skipRedirectToWallet = \"never\";\n    }\n    return {\n      notifications: notifications2,\n      modals,\n      returnStrategy,\n      twaReturnUrl,\n      skipRedirectToWallet\n    };\n  }\n}\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdG9uY29ubmVjdC91aS9saWIvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDcS9CO0FBQ3I5QjtBQUNJO0FBQ0Y7QUFDTjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0QkFBNEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaURBQWlEO0FBQ3RHLGlEQUFpRCxvRUFBb0U7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsS0FBSztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047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QTtBQUNBLHNDQUFzQyx1REFBdUQ7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU8sb0JBQW9CLE9BQU8scUJBQXFCLE9BQU87QUFDOUU7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlDQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzQ0FBUztBQUNsQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtB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V0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCO0FBQ3hCLHFCQUFxQjs7QUFFckIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLFVBQVU7QUFDVjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5QkFBeUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQyw4QkFBOEIsbUJBQW1CO0FBQ2pEO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQsOEJBQThCLHVCQUF1QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0MsOEJBQThCLHVCQUF1QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQyw4QkFBOEIsdUJBQXVCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0MsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRCw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0JBQXdCO0FBQ25EO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGFBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQywwQkFBMEIsV0FBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1Q0FBRTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsaUJBQWlCLHVDQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQkFBaUIsdUNBQUU7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxvQ0FBb0MsOEVBQTZCO0FBQ2pFLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5Q0FBeUM7QUFDekMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsWUFBWTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxnQkFBZ0IsU0FBUywwQkFBMEI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCLHdCQUF3QjtBQUN4QjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzRUFBcUIsOERBQThELGtEQUFLO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlJQUFpSTtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtREFBbUQ7QUFDbkQsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtEQUFrRDtBQUNsRCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxVQUFVLGtDQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0RBQWtEO0FBQ2xELEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsYUFBYTtBQUNiLGtCQUFrQix5QkFBeUIsOENBQThDO0FBQ3pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEIsYUFBYTtBQUNiLGtCQUFrQix5QkFBeUIsOENBQThDOztBQUV6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2QkFBNkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsOENBQThDO0FBQzlDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0EsU0FBUztBQUNULDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7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QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDhEQUFhO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNEVBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILDZDQUE2Qyw0RUFBMkI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU8sV0FBVyxRQUFRLFlBQVksU0FBUztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsK0VBQWtDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvRUFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhEQUFhO0FBQ3JCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsaUVBQWlFO0FBQ2pFO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhFQUE2QjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckUsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLCtCQUErQjtBQUMvQjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEVBQTZCO0FBQzFELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsOEJBQThCLDhFQUE2QjtBQUMzRCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLCtCQUErQjtBQUMvQjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQix3QkFBd0I7QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsK0VBQWtDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvRUFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsK0RBQStEO0FBQy9EO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekUscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLG1DQUFtQztBQUNuQztBQUNBLCtCQUErQjtBQUMvQjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlELHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHdCQUF3Qjs7QUFFeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQix3QkFBd0I7QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrREFBa0I7QUFDekM7QUFDQSx5REFBeUQsV0FBVztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtRUFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx1REFBdUQ7QUFDdkQsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLFVBQVUsNERBQTREO0FBQ3RFOztBQUVBO0FBQ0EsVUFBVSw0REFBNEQ7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFD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Q0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0b25jb25uZWN0L3VpL2xpYi9pbmRleC5tanM/OTYwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhMiwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEyLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhMiwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTI7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYTIsIGIpID0+IF9fZGVmUHJvcHMoYTIsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbnZhciBfX29ialJlc3QgPSAoc291cmNlLCBleGNsdWRlKSA9PiB7XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkgJiYgZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMClcbiAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgaWYgKHNvdXJjZSAhPSBudWxsICYmIF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKHNvdXJjZSkpIHtcbiAgICAgIGlmIChleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwICYmIF9fcHJvcElzRW51bS5jYWxsKHNvdXJjZSwgcHJvcCkpXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fYXN5bmMgPSAoX190aGlzLCBfX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdmFyIGZ1bGZpbGxlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgcmVqZWN0KGUyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIHJlamVjdChlMik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3RlcCA9ICh4KSA9PiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xuICB9KTtcbn07XG52YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuaW1wb3J0IHsgVG9uQ29ubmVjdEVycm9yLCBpc1dhbGxldEluZm9DdXJyZW50bHlJbmplY3RlZCwgdG9Vc2VyRnJpZW5kbHlBZGRyZXNzLCBDSEFJTiwgVG9uQ29ubmVjdCwgaXNXYWxsZXRDb25uZWN0SW5pdGlhbGl6ZWQsIGlzVGVsZWdyYW1VcmwsIGRlY29kZVRlbGVncmFtVXJsUGFyYW1ldGVycywgZW5jb2RlVGVsZWdyYW1VcmxQYXJhbWV0ZXJzLCBXYWxsZXRNaXNzaW5nUmVxdWlyZWRGZWF0dXJlc0Vycm9yLCBXYWxsZXRXcm9uZ05ldHdvcmtFcnJvciwgaXNXYWxsZXRJbmZvUmVtb3RlLCBjaGVja1JlcXVpcmVkV2FsbGV0RmVhdHVyZXMsIGlzQ29ubmVjdFVybCwgVVVJRHY3LCBpc1dhbGxldEluZm9DdXJyZW50bHlFbWJlZGRlZCwgY3JlYXRlVmVyc2lvbkluZm8sIGNyZWF0ZVJlc3BvbnNlVmVyc2lvbkV2ZW50LCBjcmVhdGVSZXF1ZXN0VmVyc2lvbkV2ZW50LCBjcmVhdGVXYWxsZXRNb2RhbE9wZW5lZEV2ZW50LCBjcmVhdGVTZWxlY3RlZFdhbGxldEV2ZW50LCBjcmVhdGVDb25uZWN0aW9uU3RhcnRlZEV2ZW50LCBjcmVhdGVDb25uZWN0aW9uQ29tcGxldGVkRXZlbnQsIGNyZWF0ZUNvbm5lY3Rpb25FcnJvckV2ZW50LCBjcmVhdGVDb25uZWN0aW9uUmVzdG9yaW5nU3RhcnRlZEV2ZW50LCBjcmVhdGVDb25uZWN0aW9uUmVzdG9yaW5nQ29tcGxldGVkRXZlbnQsIGNyZWF0ZUNvbm5lY3Rpb25SZXN0b3JpbmdFcnJvckV2ZW50LCBjcmVhdGVEaXNjb25uZWN0aW9uRXZlbnQsIGNyZWF0ZVRyYW5zYWN0aW9uU2VudEZvclNpZ25hdHVyZUV2ZW50LCBjcmVhdGVUcmFuc2FjdGlvblNpZ25lZEV2ZW50LCBjcmVhdGVUcmFuc2FjdGlvblNpZ25pbmdGYWlsZWRFdmVudCwgY3JlYXRlRGF0YVNlbnRGb3JTaWduYXR1cmVFdmVudCwgY3JlYXRlRGF0YVNpZ25lZEV2ZW50LCBjcmVhdGVEYXRhU2lnbmluZ0ZhaWxlZEV2ZW50LCBCcm93c2VyRXZlbnREaXNwYXRjaGVyLCBXYWxsZXROb3RTdXBwb3J0RmVhdHVyZUVycm9yLCBTZXNzaW9uQ3J5cHRvIH0gZnJvbSBcIkB0b25jb25uZWN0L3Nka1wiO1xuZXhwb3J0ICogZnJvbSBcIkB0b25jb25uZWN0L3Nka1wiO1xuaW1wb3J0IFVBUGFyc2VyIGZyb20gXCJ1YS1wYXJzZXItanNcIjtcbmltcG9ydCBkZWVwbWVyZ2UgZnJvbSBcImRlZXBtZXJnZVwiO1xuaW1wb3J0IGNuIGZyb20gXCJjbGFzc25hbWVzXCI7XG5jb25zdCBJU19ERVYgPSBmYWxzZTtcbmNvbnN0IGVxdWFsRm4gPSAoYTIsIGIpID0+IGEyID09PSBiO1xuY29uc3QgJFBST1hZID0gU3ltYm9sKFwic29saWQtcHJveHlcIik7XG5jb25zdCBTVVBQT1JUU19QUk9YWSA9IHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgJFRSQUNLID0gU3ltYm9sKFwic29saWQtdHJhY2tcIik7XG5jb25zdCBzaWduYWxPcHRpb25zID0ge1xuICBlcXVhbHM6IGVxdWFsRm5cbn07XG5sZXQgcnVuRWZmZWN0cyA9IHJ1blF1ZXVlO1xuY29uc3QgU1RBTEUgPSAxO1xuY29uc3QgUEVORElORyA9IDI7XG5jb25zdCBVTk9XTkVEID0ge1xuICBvd25lZDogbnVsbCxcbiAgY2xlYW51cHM6IG51bGwsXG4gIGNvbnRleHQ6IG51bGwsXG4gIG93bmVyOiBudWxsXG59O1xuY29uc3QgTk9fSU5JVCA9IHt9O1xudmFyIE93bmVyID0gbnVsbDtcbmxldCBUcmFuc2l0aW9uJDEgPSBudWxsO1xubGV0IEV4dGVybmFsU291cmNlQ29uZmlnID0gbnVsbDtcbmxldCBMaXN0ZW5lciA9IG51bGw7XG5sZXQgVXBkYXRlcyA9IG51bGw7XG5sZXQgRWZmZWN0cyA9IG51bGw7XG5sZXQgRXhlY0NvdW50ID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZVJvb3QoZm4sIGRldGFjaGVkT3duZXIpIHtcbiAgY29uc3QgbGlzdGVuZXIgPSBMaXN0ZW5lciwgb3duZXIgPSBPd25lciwgdW5vd25lZCA9IGZuLmxlbmd0aCA9PT0gMCwgY3VycmVudCA9IGRldGFjaGVkT3duZXIgPT09IHZvaWQgMCA/IG93bmVyIDogZGV0YWNoZWRPd25lciwgcm9vdCA9IHVub3duZWQgPyBVTk9XTkVEIDoge1xuICAgIG93bmVkOiBudWxsLFxuICAgIGNsZWFudXBzOiBudWxsLFxuICAgIGNvbnRleHQ6IGN1cnJlbnQgPyBjdXJyZW50LmNvbnRleHQgOiBudWxsLFxuICAgIG93bmVyOiBjdXJyZW50XG4gIH0sIHVwZGF0ZUZuID0gdW5vd25lZCA/IGZuIDogKCkgPT4gZm4oKCkgPT4gdW50cmFjaygoKSA9PiBjbGVhbk5vZGUocm9vdCkpKTtcbiAgT3duZXIgPSByb290O1xuICBMaXN0ZW5lciA9IG51bGw7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHJ1blVwZGF0ZXModXBkYXRlRm4sIHRydWUpO1xuICB9IGZpbmFsbHkge1xuICAgIExpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgT3duZXIgPSBvd25lcjtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlU2lnbmFsKHZhbHVlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zID8gT2JqZWN0LmFzc2lnbih7fSwgc2lnbmFsT3B0aW9ucywgb3B0aW9ucykgOiBzaWduYWxPcHRpb25zO1xuICBjb25zdCBzMiA9IHtcbiAgICB2YWx1ZSxcbiAgICBvYnNlcnZlcnM6IG51bGwsXG4gICAgb2JzZXJ2ZXJTbG90czogbnVsbCxcbiAgICBjb21wYXJhdG9yOiBvcHRpb25zLmVxdWFscyB8fCB2b2lkIDBcbiAgfTtcbiAgY29uc3Qgc2V0dGVyID0gKHZhbHVlMikgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHZhbHVlMiA9IHZhbHVlMihzMi52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZVNpZ25hbChzMiwgdmFsdWUyKTtcbiAgfTtcbiAgcmV0dXJuIFtyZWFkU2lnbmFsLmJpbmQoczIpLCBzZXR0ZXJdO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWQoZm4sIHZhbHVlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGMyID0gY3JlYXRlQ29tcHV0YXRpb24oZm4sIHZhbHVlLCB0cnVlLCBTVEFMRSk7XG4gIHVwZGF0ZUNvbXB1dGF0aW9uKGMyKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlckVmZmVjdChmbiwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgYzIgPSBjcmVhdGVDb21wdXRhdGlvbihmbiwgdmFsdWUsIGZhbHNlLCBTVEFMRSk7XG4gIHVwZGF0ZUNvbXB1dGF0aW9uKGMyKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVmZmVjdChmbiwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgcnVuRWZmZWN0cyA9IHJ1blVzZXJFZmZlY3RzO1xuICBjb25zdCBjMiA9IGNyZWF0ZUNvbXB1dGF0aW9uKGZuLCB2YWx1ZSwgZmFsc2UsIFNUQUxFKTtcbiAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLnJlbmRlcikgYzIudXNlciA9IHRydWU7XG4gIEVmZmVjdHMgPyBFZmZlY3RzLnB1c2goYzIpIDogdXBkYXRlQ29tcHV0YXRpb24oYzIpO1xufVxuZnVuY3Rpb24gY3JlYXRlTWVtbyhmbiwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKHt9LCBzaWduYWxPcHRpb25zLCBvcHRpb25zKSA6IHNpZ25hbE9wdGlvbnM7XG4gIGNvbnN0IGMyID0gY3JlYXRlQ29tcHV0YXRpb24oZm4sIHZhbHVlLCB0cnVlLCAwKTtcbiAgYzIub2JzZXJ2ZXJzID0gbnVsbDtcbiAgYzIub2JzZXJ2ZXJTbG90cyA9IG51bGw7XG4gIGMyLmNvbXBhcmF0b3IgPSBvcHRpb25zLmVxdWFscyB8fCB2b2lkIDA7XG4gIHVwZGF0ZUNvbXB1dGF0aW9uKGMyKTtcbiAgcmV0dXJuIHJlYWRTaWduYWwuYmluZChjMik7XG59XG5mdW5jdGlvbiBpc1Byb21pc2Uodikge1xuICByZXR1cm4gdiAmJiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiBcInRoZW5cIiBpbiB2O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVzb3VyY2UocFNvdXJjZSwgcEZldGNoZXIsIHBPcHRpb25zKSB7XG4gIGxldCBzb3VyY2U7XG4gIGxldCBmZXRjaGVyO1xuICBsZXQgb3B0aW9ucztcbiAge1xuICAgIHNvdXJjZSA9IHRydWU7XG4gICAgZmV0Y2hlciA9IHBTb3VyY2U7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGxldCBwciA9IG51bGwsIGluaXRQID0gTk9fSU5JVCwgc2NoZWR1bGVkID0gZmFsc2UsIHJlc29sdmVkID0gXCJpbml0aWFsVmFsdWVcIiBpbiBvcHRpb25zLCBkeW5hbWljID0gdHlwZW9mIHNvdXJjZSA9PT0gXCJmdW5jdGlvblwiICYmIGNyZWF0ZU1lbW8oc291cmNlKTtcbiAgY29uc3QgY29udGV4dHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCBbdmFsdWUsIHNldFZhbHVlXSA9IChvcHRpb25zLnN0b3JhZ2UgfHwgY3JlYXRlU2lnbmFsKShvcHRpb25zLmluaXRpYWxWYWx1ZSksIFtlcnJvciwgc2V0RXJyb3JdID0gY3JlYXRlU2lnbmFsKHZvaWQgMCksIFt0cmFjaywgdHJpZ2dlcl0gPSBjcmVhdGVTaWduYWwodm9pZCAwLCB7XG4gICAgZXF1YWxzOiBmYWxzZVxuICB9KSwgW3N0YXRlLCBzZXRTdGF0ZV0gPSBjcmVhdGVTaWduYWwocmVzb2x2ZWQgPyBcInJlYWR5XCIgOiBcInVucmVzb2x2ZWRcIik7XG4gIGZ1bmN0aW9uIGxvYWRFbmQocDIsIHYsIGVycm9yMiwga2V5KSB7XG4gICAgaWYgKHByID09PSBwMikge1xuICAgICAgcHIgPSBudWxsO1xuICAgICAga2V5ICE9PSB2b2lkIDAgJiYgKHJlc29sdmVkID0gdHJ1ZSk7XG4gICAgICBpZiAoKHAyID09PSBpbml0UCB8fCB2ID09PSBpbml0UCkgJiYgb3B0aW9ucy5vbkh5ZHJhdGVkKSBxdWV1ZU1pY3JvdGFzaygoKSA9PiBvcHRpb25zLm9uSHlkcmF0ZWQoa2V5LCB7XG4gICAgICAgIHZhbHVlOiB2XG4gICAgICB9KSk7XG4gICAgICBpbml0UCA9IE5PX0lOSVQ7XG4gICAgICBjb21wbGV0ZUxvYWQodiwgZXJyb3IyKTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgZnVuY3Rpb24gY29tcGxldGVMb2FkKHYsIGVycikge1xuICAgIHJ1blVwZGF0ZXMoKCkgPT4ge1xuICAgICAgaWYgKGVyciA9PT0gdm9pZCAwKSBzZXRWYWx1ZSgoKSA9PiB2KTtcbiAgICAgIHNldFN0YXRlKGVyciAhPT0gdm9pZCAwID8gXCJlcnJvcmVkXCIgOiByZXNvbHZlZCA/IFwicmVhZHlcIiA6IFwidW5yZXNvbHZlZFwiKTtcbiAgICAgIHNldEVycm9yKGVycik7XG4gICAgICBmb3IgKGNvbnN0IGMyIG9mIGNvbnRleHRzLmtleXMoKSkgYzIuZGVjcmVtZW50KCk7XG4gICAgICBjb250ZXh0cy5jbGVhcigpO1xuICAgIH0sIGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiByZWFkKCkge1xuICAgIGNvbnN0IGMyID0gU3VzcGVuc2VDb250ZXh0LCB2ID0gdmFsdWUoKSwgZXJyID0gZXJyb3IoKTtcbiAgICBpZiAoZXJyICE9PSB2b2lkIDAgJiYgIXByKSB0aHJvdyBlcnI7XG4gICAgaWYgKExpc3RlbmVyICYmICFMaXN0ZW5lci51c2VyICYmIGMyKSA7XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgZnVuY3Rpb24gbG9hZChyZWZldGNoaW5nID0gdHJ1ZSkge1xuICAgIGlmIChyZWZldGNoaW5nICE9PSBmYWxzZSAmJiBzY2hlZHVsZWQpIHJldHVybjtcbiAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBjb25zdCBsb29rdXAgPSBkeW5hbWljID8gZHluYW1pYygpIDogc291cmNlO1xuICAgIGlmIChsb29rdXAgPT0gbnVsbCB8fCBsb29rdXAgPT09IGZhbHNlKSB7XG4gICAgICBsb2FkRW5kKHByLCB1bnRyYWNrKHZhbHVlKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBlcnJvcjI7XG4gICAgY29uc3QgcDIgPSBpbml0UCAhPT0gTk9fSU5JVCA/IGluaXRQIDogdW50cmFjaygoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZmV0Y2hlcihsb29rdXAsIHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWUoKSxcbiAgICAgICAgICByZWZldGNoaW5nXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZmV0Y2hlckVycm9yKSB7XG4gICAgICAgIGVycm9yMiA9IGZldGNoZXJFcnJvcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZXJyb3IyICE9PSB2b2lkIDApIHtcbiAgICAgIGxvYWRFbmQocHIsIHZvaWQgMCwgY2FzdEVycm9yKGVycm9yMiksIGxvb2t1cCk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICghaXNQcm9taXNlKHAyKSkge1xuICAgICAgbG9hZEVuZChwciwgcDIsIHZvaWQgMCwgbG9va3VwKTtcbiAgICAgIHJldHVybiBwMjtcbiAgICB9XG4gICAgcHIgPSBwMjtcbiAgICBpZiAoXCJ2XCIgaW4gcDIpIHtcbiAgICAgIGlmIChwMi5zID09PSAxKSBsb2FkRW5kKHByLCBwMi52LCB2b2lkIDAsIGxvb2t1cCk7XG4gICAgICBlbHNlIGxvYWRFbmQocHIsIHZvaWQgMCwgY2FzdEVycm9yKHAyLnYpLCBsb29rdXApO1xuICAgICAgcmV0dXJuIHAyO1xuICAgIH1cbiAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHNjaGVkdWxlZCA9IGZhbHNlKTtcbiAgICBydW5VcGRhdGVzKCgpID0+IHtcbiAgICAgIHNldFN0YXRlKHJlc29sdmVkID8gXCJyZWZyZXNoaW5nXCIgOiBcInBlbmRpbmdcIik7XG4gICAgICB0cmlnZ2VyKCk7XG4gICAgfSwgZmFsc2UpO1xuICAgIHJldHVybiBwMi50aGVuKCh2KSA9PiBsb2FkRW5kKHAyLCB2LCB2b2lkIDAsIGxvb2t1cCksIChlMikgPT4gbG9hZEVuZChwMiwgdm9pZCAwLCBjYXN0RXJyb3IoZTIpLCBsb29rdXApKTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhyZWFkLCB7XG4gICAgc3RhdGU6IHtcbiAgICAgIGdldDogKCkgPT4gc3RhdGUoKVxuICAgIH0sXG4gICAgZXJyb3I6IHtcbiAgICAgIGdldDogKCkgPT4gZXJyb3IoKVxuICAgIH0sXG4gICAgbG9hZGluZzoge1xuICAgICAgZ2V0KCkge1xuICAgICAgICBjb25zdCBzMiA9IHN0YXRlKCk7XG4gICAgICAgIHJldHVybiBzMiA9PT0gXCJwZW5kaW5nXCIgfHwgczIgPT09IFwicmVmcmVzaGluZ1wiO1xuICAgICAgfVxuICAgIH0sXG4gICAgbGF0ZXN0OiB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIGlmICghcmVzb2x2ZWQpIHJldHVybiByZWFkKCk7XG4gICAgICAgIGNvbnN0IGVyciA9IGVycm9yKCk7XG4gICAgICAgIGlmIChlcnIgJiYgIXByKSB0aHJvdyBlcnI7XG4gICAgICAgIHJldHVybiB2YWx1ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGxldCBvd25lciA9IE93bmVyO1xuICBpZiAoZHluYW1pYykgY3JlYXRlQ29tcHV0ZWQoKCkgPT4gKG93bmVyID0gT3duZXIsIGxvYWQoZmFsc2UpKSk7XG4gIGVsc2UgbG9hZChmYWxzZSk7XG4gIHJldHVybiBbcmVhZCwge1xuICAgIHJlZmV0Y2g6IChpbmZvKSA9PiBydW5XaXRoT3duZXIob3duZXIsICgpID0+IGxvYWQoaW5mbykpLFxuICAgIG11dGF0ZTogc2V0VmFsdWVcbiAgfV07XG59XG5mdW5jdGlvbiBiYXRjaChmbikge1xuICByZXR1cm4gcnVuVXBkYXRlcyhmbiwgZmFsc2UpO1xufVxuZnVuY3Rpb24gdW50cmFjayhmbikge1xuICBpZiAoTGlzdGVuZXIgPT09IG51bGwpIHJldHVybiBmbigpO1xuICBjb25zdCBsaXN0ZW5lciA9IExpc3RlbmVyO1xuICBMaXN0ZW5lciA9IG51bGw7XG4gIHRyeSB7XG4gICAgaWYgKEV4dGVybmFsU291cmNlQ29uZmlnKSA7XG4gICAgcmV0dXJuIGZuKCk7XG4gIH0gZmluYWxseSB7XG4gICAgTGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgfVxufVxuZnVuY3Rpb24gb24oZGVwcywgZm4sIG9wdGlvbnMpIHtcbiAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoZGVwcyk7XG4gIGxldCBwcmV2SW5wdXQ7XG4gIHJldHVybiAocHJldlZhbHVlKSA9PiB7XG4gICAgbGV0IGlucHV0O1xuICAgIGlmIChpc0FycmF5KSB7XG4gICAgICBpbnB1dCA9IEFycmF5KGRlcHMubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBkZXBzLmxlbmd0aDsgaTIrKykgaW5wdXRbaTJdID0gZGVwc1tpMl0oKTtcbiAgICB9IGVsc2UgaW5wdXQgPSBkZXBzKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gdW50cmFjaygoKSA9PiBmbihpbnB1dCwgcHJldklucHV0LCBwcmV2VmFsdWUpKTtcbiAgICBwcmV2SW5wdXQgPSBpbnB1dDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuZnVuY3Rpb24gb25Nb3VudChmbikge1xuICBjcmVhdGVFZmZlY3QoKCkgPT4gdW50cmFjayhmbikpO1xufVxuZnVuY3Rpb24gb25DbGVhbnVwKGZuKSB7XG4gIGlmIChPd25lciA9PT0gbnVsbCkgO1xuICBlbHNlIGlmIChPd25lci5jbGVhbnVwcyA9PT0gbnVsbCkgT3duZXIuY2xlYW51cHMgPSBbZm5dO1xuICBlbHNlIE93bmVyLmNsZWFudXBzLnB1c2goZm4pO1xuICByZXR1cm4gZm47XG59XG5mdW5jdGlvbiBnZXRMaXN0ZW5lcigpIHtcbiAgcmV0dXJuIExpc3RlbmVyO1xufVxuZnVuY3Rpb24gZ2V0T3duZXIoKSB7XG4gIHJldHVybiBPd25lcjtcbn1cbmZ1bmN0aW9uIHJ1bldpdGhPd25lcihvMiwgZm4pIHtcbiAgY29uc3QgcHJldiA9IE93bmVyO1xuICBjb25zdCBwcmV2TGlzdGVuZXIgPSBMaXN0ZW5lcjtcbiAgT3duZXIgPSBvMjtcbiAgTGlzdGVuZXIgPSBudWxsO1xuICB0cnkge1xuICAgIHJldHVybiBydW5VcGRhdGVzKGZuLCB0cnVlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBPd25lciA9IHByZXY7XG4gICAgTGlzdGVuZXIgPSBwcmV2TGlzdGVuZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihmbikge1xuICBjb25zdCBsMiA9IExpc3RlbmVyO1xuICBjb25zdCBvMiA9IE93bmVyO1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgTGlzdGVuZXIgPSBsMjtcbiAgICBPd25lciA9IG8yO1xuICAgIHJ1blVwZGF0ZXMoZm4sIGZhbHNlKTtcbiAgICBMaXN0ZW5lciA9IE93bmVyID0gbnVsbDtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9KTtcbn1cbmNvbnN0IFt0cmFuc1BlbmRpbmcsIHNldFRyYW5zUGVuZGluZ10gPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlU2lnbmFsKGZhbHNlKTtcbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb24oKSB7XG4gIHJldHVybiBbdHJhbnNQZW5kaW5nLCBzdGFydFRyYW5zaXRpb25dO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgaWQgPSBTeW1ib2woXCJjb250ZXh0XCIpO1xuICByZXR1cm4ge1xuICAgIGlkLFxuICAgIFByb3ZpZGVyOiBjcmVhdGVQcm92aWRlcihpZCksXG4gICAgZGVmYXVsdFZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiB1c2VDb250ZXh0KGNvbnRleHQpIHtcbiAgbGV0IHZhbHVlO1xuICByZXR1cm4gT3duZXIgJiYgT3duZXIuY29udGV4dCAmJiAodmFsdWUgPSBPd25lci5jb250ZXh0W2NvbnRleHQuaWRdKSAhPT0gdm9pZCAwID8gdmFsdWUgOiBjb250ZXh0LmRlZmF1bHRWYWx1ZTtcbn1cbmZ1bmN0aW9uIGNoaWxkcmVuKGZuKSB7XG4gIGNvbnN0IGNoaWxkcmVuMiA9IGNyZWF0ZU1lbW8oZm4pO1xuICBjb25zdCBtZW1vMiA9IGNyZWF0ZU1lbW8oKCkgPT4gcmVzb2x2ZUNoaWxkcmVuKGNoaWxkcmVuMigpKSk7XG4gIG1lbW8yLnRvQXJyYXkgPSAoKSA9PiB7XG4gICAgY29uc3QgYzIgPSBtZW1vMigpO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGMyKSA/IGMyIDogYzIgIT0gbnVsbCA/IFtjMl0gOiBbXTtcbiAgfTtcbiAgcmV0dXJuIG1lbW8yO1xufVxubGV0IFN1c3BlbnNlQ29udGV4dDtcbmZ1bmN0aW9uIHJlYWRTaWduYWwoKSB7XG4gIGlmICh0aGlzLnNvdXJjZXMgJiYgdGhpcy5zdGF0ZSkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTVEFMRSkgdXBkYXRlQ29tcHV0YXRpb24odGhpcyk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCB1cGRhdGVzID0gVXBkYXRlcztcbiAgICAgIFVwZGF0ZXMgPSBudWxsO1xuICAgICAgcnVuVXBkYXRlcygoKSA9PiBsb29rVXBzdHJlYW0odGhpcyksIGZhbHNlKTtcbiAgICAgIFVwZGF0ZXMgPSB1cGRhdGVzO1xuICAgIH1cbiAgfVxuICBpZiAoTGlzdGVuZXIpIHtcbiAgICBjb25zdCBzU2xvdCA9IHRoaXMub2JzZXJ2ZXJzID8gdGhpcy5vYnNlcnZlcnMubGVuZ3RoIDogMDtcbiAgICBpZiAoIUxpc3RlbmVyLnNvdXJjZXMpIHtcbiAgICAgIExpc3RlbmVyLnNvdXJjZXMgPSBbdGhpc107XG4gICAgICBMaXN0ZW5lci5zb3VyY2VTbG90cyA9IFtzU2xvdF07XG4gICAgfSBlbHNlIHtcbiAgICAgIExpc3RlbmVyLnNvdXJjZXMucHVzaCh0aGlzKTtcbiAgICAgIExpc3RlbmVyLnNvdXJjZVNsb3RzLnB1c2goc1Nsb3QpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMub2JzZXJ2ZXJzKSB7XG4gICAgICB0aGlzLm9ic2VydmVycyA9IFtMaXN0ZW5lcl07XG4gICAgICB0aGlzLm9ic2VydmVyU2xvdHMgPSBbTGlzdGVuZXIuc291cmNlcy5sZW5ndGggLSAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChMaXN0ZW5lcik7XG4gICAgICB0aGlzLm9ic2VydmVyU2xvdHMucHVzaChMaXN0ZW5lci5zb3VyY2VzLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy52YWx1ZTtcbn1cbmZ1bmN0aW9uIHdyaXRlU2lnbmFsKG5vZGUsIHZhbHVlLCBpc0NvbXApIHtcbiAgbGV0IGN1cnJlbnQgPSBub2RlLnZhbHVlO1xuICBpZiAoIW5vZGUuY29tcGFyYXRvciB8fCAhbm9kZS5jb21wYXJhdG9yKGN1cnJlbnQsIHZhbHVlKSkge1xuICAgIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAobm9kZS5vYnNlcnZlcnMgJiYgbm9kZS5vYnNlcnZlcnMubGVuZ3RoKSB7XG4gICAgICBydW5VcGRhdGVzKCgpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG5vZGUub2JzZXJ2ZXJzLmxlbmd0aDsgaTIgKz0gMSkge1xuICAgICAgICAgIGNvbnN0IG8yID0gbm9kZS5vYnNlcnZlcnNbaTJdO1xuICAgICAgICAgIGNvbnN0IFRyYW5zaXRpb25SdW5uaW5nID0gVHJhbnNpdGlvbiQxICYmIFRyYW5zaXRpb24kMS5ydW5uaW5nO1xuICAgICAgICAgIGlmIChUcmFuc2l0aW9uUnVubmluZyAmJiBUcmFuc2l0aW9uJDEuZGlzcG9zZWQuaGFzKG8yKSkgO1xuICAgICAgICAgIGlmIChUcmFuc2l0aW9uUnVubmluZyA/ICFvMi50U3RhdGUgOiAhbzIuc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChvMi5wdXJlKSBVcGRhdGVzLnB1c2gobzIpO1xuICAgICAgICAgICAgZWxzZSBFZmZlY3RzLnB1c2gobzIpO1xuICAgICAgICAgICAgaWYgKG8yLm9ic2VydmVycykgbWFya0Rvd25zdHJlYW0obzIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIVRyYW5zaXRpb25SdW5uaW5nKSBvMi5zdGF0ZSA9IFNUQUxFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChVcGRhdGVzLmxlbmd0aCA+IDFlNikge1xuICAgICAgICAgIFVwZGF0ZXMgPSBbXTtcbiAgICAgICAgICBpZiAoSVNfREVWKSA7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gdXBkYXRlQ29tcHV0YXRpb24obm9kZSkge1xuICBpZiAoIW5vZGUuZm4pIHJldHVybjtcbiAgY2xlYW5Ob2RlKG5vZGUpO1xuICBjb25zdCB0aW1lID0gRXhlY0NvdW50O1xuICBydW5Db21wdXRhdGlvbihub2RlLCBub2RlLnZhbHVlLCB0aW1lKTtcbn1cbmZ1bmN0aW9uIHJ1bkNvbXB1dGF0aW9uKG5vZGUsIHZhbHVlLCB0aW1lKSB7XG4gIGxldCBuZXh0VmFsdWU7XG4gIGNvbnN0IG93bmVyID0gT3duZXIsIGxpc3RlbmVyID0gTGlzdGVuZXI7XG4gIExpc3RlbmVyID0gT3duZXIgPSBub2RlO1xuICB0cnkge1xuICAgIG5leHRWYWx1ZSA9IG5vZGUuZm4odmFsdWUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAobm9kZS5wdXJlKSB7XG4gICAgICB7XG4gICAgICAgIG5vZGUuc3RhdGUgPSBTVEFMRTtcbiAgICAgICAgbm9kZS5vd25lZCAmJiBub2RlLm93bmVkLmZvckVhY2goY2xlYW5Ob2RlKTtcbiAgICAgICAgbm9kZS5vd25lZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGUudXBkYXRlZEF0ID0gdGltZSArIDE7XG4gICAgcmV0dXJuIGhhbmRsZUVycm9yKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgTGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICBPd25lciA9IG93bmVyO1xuICB9XG4gIGlmICghbm9kZS51cGRhdGVkQXQgfHwgbm9kZS51cGRhdGVkQXQgPD0gdGltZSkge1xuICAgIGlmIChub2RlLnVwZGF0ZWRBdCAhPSBudWxsICYmIFwib2JzZXJ2ZXJzXCIgaW4gbm9kZSkge1xuICAgICAgd3JpdGVTaWduYWwobm9kZSwgbmV4dFZhbHVlKTtcbiAgICB9IGVsc2Ugbm9kZS52YWx1ZSA9IG5leHRWYWx1ZTtcbiAgICBub2RlLnVwZGF0ZWRBdCA9IHRpbWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGF0aW9uKGZuLCBpbml0LCBwdXJlLCBzdGF0ZSA9IFNUQUxFLCBvcHRpb25zKSB7XG4gIGNvbnN0IGMyID0ge1xuICAgIGZuLFxuICAgIHN0YXRlLFxuICAgIHVwZGF0ZWRBdDogbnVsbCxcbiAgICBvd25lZDogbnVsbCxcbiAgICBzb3VyY2VzOiBudWxsLFxuICAgIHNvdXJjZVNsb3RzOiBudWxsLFxuICAgIGNsZWFudXBzOiBudWxsLFxuICAgIHZhbHVlOiBpbml0LFxuICAgIG93bmVyOiBPd25lcixcbiAgICBjb250ZXh0OiBPd25lciA/IE93bmVyLmNvbnRleHQgOiBudWxsLFxuICAgIHB1cmVcbiAgfTtcbiAgaWYgKE93bmVyID09PSBudWxsKSA7XG4gIGVsc2UgaWYgKE93bmVyICE9PSBVTk9XTkVEKSB7XG4gICAge1xuICAgICAgaWYgKCFPd25lci5vd25lZCkgT3duZXIub3duZWQgPSBbYzJdO1xuICAgICAgZWxzZSBPd25lci5vd25lZC5wdXNoKGMyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGMyO1xufVxuZnVuY3Rpb24gcnVuVG9wKG5vZGUpIHtcbiAgaWYgKG5vZGUuc3RhdGUgPT09IDApIHJldHVybjtcbiAgaWYgKG5vZGUuc3RhdGUgPT09IFBFTkRJTkcpIHJldHVybiBsb29rVXBzdHJlYW0obm9kZSk7XG4gIGlmIChub2RlLnN1c3BlbnNlICYmIHVudHJhY2sobm9kZS5zdXNwZW5zZS5pbkZhbGxiYWNrKSkgcmV0dXJuIG5vZGUuc3VzcGVuc2UuZWZmZWN0cy5wdXNoKG5vZGUpO1xuICBjb25zdCBhbmNlc3RvcnMgPSBbbm9kZV07XG4gIHdoaWxlICgobm9kZSA9IG5vZGUub3duZXIpICYmICghbm9kZS51cGRhdGVkQXQgfHwgbm9kZS51cGRhdGVkQXQgPCBFeGVjQ291bnQpKSB7XG4gICAgaWYgKG5vZGUuc3RhdGUpIGFuY2VzdG9ycy5wdXNoKG5vZGUpO1xuICB9XG4gIGZvciAobGV0IGkyID0gYW5jZXN0b3JzLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pIHtcbiAgICBub2RlID0gYW5jZXN0b3JzW2kyXTtcbiAgICBpZiAobm9kZS5zdGF0ZSA9PT0gU1RBTEUpIHtcbiAgICAgIHVwZGF0ZUNvbXB1dGF0aW9uKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5zdGF0ZSA9PT0gUEVORElORykge1xuICAgICAgY29uc3QgdXBkYXRlcyA9IFVwZGF0ZXM7XG4gICAgICBVcGRhdGVzID0gbnVsbDtcbiAgICAgIHJ1blVwZGF0ZXMoKCkgPT4gbG9va1Vwc3RyZWFtKG5vZGUsIGFuY2VzdG9yc1swXSksIGZhbHNlKTtcbiAgICAgIFVwZGF0ZXMgPSB1cGRhdGVzO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcnVuVXBkYXRlcyhmbiwgaW5pdCkge1xuICBpZiAoVXBkYXRlcykgcmV0dXJuIGZuKCk7XG4gIGxldCB3YWl0ID0gZmFsc2U7XG4gIGlmICghaW5pdCkgVXBkYXRlcyA9IFtdO1xuICBpZiAoRWZmZWN0cykgd2FpdCA9IHRydWU7XG4gIGVsc2UgRWZmZWN0cyA9IFtdO1xuICBFeGVjQ291bnQrKztcbiAgdHJ5IHtcbiAgICBjb25zdCByZXMgPSBmbigpO1xuICAgIGNvbXBsZXRlVXBkYXRlcyh3YWl0KTtcbiAgICByZXR1cm4gcmVzO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoIXdhaXQpIEVmZmVjdHMgPSBudWxsO1xuICAgIFVwZGF0ZXMgPSBudWxsO1xuICAgIGhhbmRsZUVycm9yKGVycik7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBsZXRlVXBkYXRlcyh3YWl0KSB7XG4gIGlmIChVcGRhdGVzKSB7XG4gICAgcnVuUXVldWUoVXBkYXRlcyk7XG4gICAgVXBkYXRlcyA9IG51bGw7XG4gIH1cbiAgaWYgKHdhaXQpIHJldHVybjtcbiAgY29uc3QgZTIgPSBFZmZlY3RzO1xuICBFZmZlY3RzID0gbnVsbDtcbiAgaWYgKGUyLmxlbmd0aCkgcnVuVXBkYXRlcygoKSA9PiBydW5FZmZlY3RzKGUyKSwgZmFsc2UpO1xufVxuZnVuY3Rpb24gcnVuUXVldWUocXVldWUpIHtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHF1ZXVlLmxlbmd0aDsgaTIrKykgcnVuVG9wKHF1ZXVlW2kyXSk7XG59XG5mdW5jdGlvbiBydW5Vc2VyRWZmZWN0cyhxdWV1ZSkge1xuICBsZXQgaTIsIHVzZXJMZW5ndGggPSAwO1xuICBmb3IgKGkyID0gMDsgaTIgPCBxdWV1ZS5sZW5ndGg7IGkyKyspIHtcbiAgICBjb25zdCBlMiA9IHF1ZXVlW2kyXTtcbiAgICBpZiAoIWUyLnVzZXIpIHJ1blRvcChlMik7XG4gICAgZWxzZSBxdWV1ZVt1c2VyTGVuZ3RoKytdID0gZTI7XG4gIH1cbiAgZm9yIChpMiA9IDA7IGkyIDwgdXNlckxlbmd0aDsgaTIrKykgcnVuVG9wKHF1ZXVlW2kyXSk7XG59XG5mdW5jdGlvbiBsb29rVXBzdHJlYW0obm9kZSwgaWdub3JlKSB7XG4gIG5vZGUuc3RhdGUgPSAwO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbm9kZS5zb3VyY2VzLmxlbmd0aDsgaTIgKz0gMSkge1xuICAgIGNvbnN0IHNvdXJjZSA9IG5vZGUuc291cmNlc1tpMl07XG4gICAgaWYgKHNvdXJjZS5zb3VyY2VzKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHNvdXJjZS5zdGF0ZTtcbiAgICAgIGlmIChzdGF0ZSA9PT0gU1RBTEUpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gaWdub3JlICYmICghc291cmNlLnVwZGF0ZWRBdCB8fCBzb3VyY2UudXBkYXRlZEF0IDwgRXhlY0NvdW50KSkgcnVuVG9wKHNvdXJjZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBQRU5ESU5HKSBsb29rVXBzdHJlYW0oc291cmNlLCBpZ25vcmUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0Rvd25zdHJlYW0obm9kZSkge1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbm9kZS5vYnNlcnZlcnMubGVuZ3RoOyBpMiArPSAxKSB7XG4gICAgY29uc3QgbzIgPSBub2RlLm9ic2VydmVyc1tpMl07XG4gICAgaWYgKCFvMi5zdGF0ZSkge1xuICAgICAgbzIuc3RhdGUgPSBQRU5ESU5HO1xuICAgICAgaWYgKG8yLnB1cmUpIFVwZGF0ZXMucHVzaChvMik7XG4gICAgICBlbHNlIEVmZmVjdHMucHVzaChvMik7XG4gICAgICBvMi5vYnNlcnZlcnMgJiYgbWFya0Rvd25zdHJlYW0obzIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2xlYW5Ob2RlKG5vZGUpIHtcbiAgbGV0IGkyO1xuICBpZiAobm9kZS5zb3VyY2VzKSB7XG4gICAgd2hpbGUgKG5vZGUuc291cmNlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG5vZGUuc291cmNlcy5wb3AoKSwgaW5kZXggPSBub2RlLnNvdXJjZVNsb3RzLnBvcCgpLCBvYnMgPSBzb3VyY2Uub2JzZXJ2ZXJzO1xuICAgICAgaWYgKG9icyAmJiBvYnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG4yID0gb2JzLnBvcCgpLCBzMiA9IHNvdXJjZS5vYnNlcnZlclNsb3RzLnBvcCgpO1xuICAgICAgICBpZiAoaW5kZXggPCBvYnMubGVuZ3RoKSB7XG4gICAgICAgICAgbjIuc291cmNlU2xvdHNbczJdID0gaW5kZXg7XG4gICAgICAgICAgb2JzW2luZGV4XSA9IG4yO1xuICAgICAgICAgIHNvdXJjZS5vYnNlcnZlclNsb3RzW2luZGV4XSA9IHMyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChub2RlLnRPd25lZCkge1xuICAgIGZvciAoaTIgPSBub2RlLnRPd25lZC5sZW5ndGggLSAxOyBpMiA+PSAwOyBpMi0tKSBjbGVhbk5vZGUobm9kZS50T3duZWRbaTJdKTtcbiAgICBkZWxldGUgbm9kZS50T3duZWQ7XG4gIH1cbiAgaWYgKG5vZGUub3duZWQpIHtcbiAgICBmb3IgKGkyID0gbm9kZS5vd25lZC5sZW5ndGggLSAxOyBpMiA+PSAwOyBpMi0tKSBjbGVhbk5vZGUobm9kZS5vd25lZFtpMl0pO1xuICAgIG5vZGUub3duZWQgPSBudWxsO1xuICB9XG4gIGlmIChub2RlLmNsZWFudXBzKSB7XG4gICAgZm9yIChpMiA9IG5vZGUuY2xlYW51cHMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkgbm9kZS5jbGVhbnVwc1tpMl0oKTtcbiAgICBub2RlLmNsZWFudXBzID0gbnVsbDtcbiAgfVxuICBub2RlLnN0YXRlID0gMDtcbn1cbmZ1bmN0aW9uIGNhc3RFcnJvcihlcnIpIHtcbiAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gZXJyO1xuICByZXR1cm4gbmV3IEVycm9yKHR5cGVvZiBlcnIgPT09IFwic3RyaW5nXCIgPyBlcnIgOiBcIlVua25vd24gZXJyb3JcIiwge1xuICAgIGNhdXNlOiBlcnJcbiAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVFcnJvcihlcnIsIG93bmVyID0gT3duZXIpIHtcbiAgY29uc3QgZXJyb3IgPSBjYXN0RXJyb3IoZXJyKTtcbiAgdGhyb3cgZXJyb3I7XG59XG5mdW5jdGlvbiByZXNvbHZlQ2hpbGRyZW4oY2hpbGRyZW4yKSB7XG4gIGlmICh0eXBlb2YgY2hpbGRyZW4yID09PSBcImZ1bmN0aW9uXCIgJiYgIWNoaWxkcmVuMi5sZW5ndGgpIHJldHVybiByZXNvbHZlQ2hpbGRyZW4oY2hpbGRyZW4yKCkpO1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbjIpKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBjaGlsZHJlbjIubGVuZ3RoOyBpMisrKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSByZXNvbHZlQ2hpbGRyZW4oY2hpbGRyZW4yW2kyXSk7XG4gICAgICBBcnJheS5pc0FycmF5KHJlc3VsdCkgPyByZXN1bHRzLnB1c2guYXBwbHkocmVzdWx0cywgcmVzdWx0KSA6IHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICByZXR1cm4gY2hpbGRyZW4yO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJvdmlkZXIoaWQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByb3ZpZGVyKHByb3BzKSB7XG4gICAgbGV0IHJlcztcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKCkgPT4gcmVzID0gdW50cmFjaygoKSA9PiB7XG4gICAgICBPd25lci5jb250ZXh0ID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgT3duZXIuY29udGV4dCksIHtcbiAgICAgICAgW2lkXTogcHJvcHMudmFsdWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNoaWxkcmVuKCgpID0+IHByb3BzLmNoaWxkcmVuKTtcbiAgICB9KSwgdm9pZCAwKTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xufVxuY29uc3QgRkFMTEJBQ0sgPSBTeW1ib2woXCJmYWxsYmFja1wiKTtcbmZ1bmN0aW9uIGRpc3Bvc2UoZCkge1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgZC5sZW5ndGg7IGkyKyspIGRbaTJdKCk7XG59XG5mdW5jdGlvbiBtYXBBcnJheShsaXN0LCBtYXBGbiwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCBpdGVtcyA9IFtdLCBtYXBwZWQgPSBbXSwgZGlzcG9zZXJzID0gW10sIGxlbiA9IDAsIGluZGV4ZXMgPSBtYXBGbi5sZW5ndGggPiAxID8gW10gOiBudWxsO1xuICBvbkNsZWFudXAoKCkgPT4gZGlzcG9zZShkaXNwb3NlcnMpKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsZXQgbmV3SXRlbXMgPSBsaXN0KCkgfHwgW10sIG5ld0xlbiA9IG5ld0l0ZW1zLmxlbmd0aCwgaTIsIGo7XG4gICAgbmV3SXRlbXNbJFRSQUNLXTtcbiAgICByZXR1cm4gdW50cmFjaygoKSA9PiB7XG4gICAgICBsZXQgbmV3SW5kaWNlcywgbmV3SW5kaWNlc05leHQsIHRlbXAsIHRlbXBkaXNwb3NlcnMsIHRlbXBJbmRleGVzLCBzdGFydCwgZW5kLCBuZXdFbmQsIGl0ZW07XG4gICAgICBpZiAobmV3TGVuID09PSAwKSB7XG4gICAgICAgIGlmIChsZW4gIT09IDApIHtcbiAgICAgICAgICBkaXNwb3NlKGRpc3Bvc2Vycyk7XG4gICAgICAgICAgZGlzcG9zZXJzID0gW107XG4gICAgICAgICAgaXRlbXMgPSBbXTtcbiAgICAgICAgICBtYXBwZWQgPSBbXTtcbiAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgIGluZGV4ZXMgJiYgKGluZGV4ZXMgPSBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZmFsbGJhY2spIHtcbiAgICAgICAgICBpdGVtcyA9IFtGQUxMQkFDS107XG4gICAgICAgICAgbWFwcGVkWzBdID0gY3JlYXRlUm9vdCgoZGlzcG9zZXIpID0+IHtcbiAgICAgICAgICAgIGRpc3Bvc2Vyc1swXSA9IGRpc3Bvc2VyO1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZmFsbGJhY2soKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsZW4gPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICBtYXBwZWQgPSBuZXcgQXJyYXkobmV3TGVuKTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IG5ld0xlbjsgaisrKSB7XG4gICAgICAgICAgaXRlbXNbal0gPSBuZXdJdGVtc1tqXTtcbiAgICAgICAgICBtYXBwZWRbal0gPSBjcmVhdGVSb290KG1hcHBlcik7XG4gICAgICAgIH1cbiAgICAgICAgbGVuID0gbmV3TGVuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcCA9IG5ldyBBcnJheShuZXdMZW4pO1xuICAgICAgICB0ZW1wZGlzcG9zZXJzID0gbmV3IEFycmF5KG5ld0xlbik7XG4gICAgICAgIGluZGV4ZXMgJiYgKHRlbXBJbmRleGVzID0gbmV3IEFycmF5KG5ld0xlbikpO1xuICAgICAgICBmb3IgKHN0YXJ0ID0gMCwgZW5kID0gTWF0aC5taW4obGVuLCBuZXdMZW4pOyBzdGFydCA8IGVuZCAmJiBpdGVtc1tzdGFydF0gPT09IG5ld0l0ZW1zW3N0YXJ0XTsgc3RhcnQrKykgO1xuICAgICAgICBmb3IgKGVuZCA9IGxlbiAtIDEsIG5ld0VuZCA9IG5ld0xlbiAtIDE7IGVuZCA+PSBzdGFydCAmJiBuZXdFbmQgPj0gc3RhcnQgJiYgaXRlbXNbZW5kXSA9PT0gbmV3SXRlbXNbbmV3RW5kXTsgZW5kLS0sIG5ld0VuZC0tKSB7XG4gICAgICAgICAgdGVtcFtuZXdFbmRdID0gbWFwcGVkW2VuZF07XG4gICAgICAgICAgdGVtcGRpc3Bvc2Vyc1tuZXdFbmRdID0gZGlzcG9zZXJzW2VuZF07XG4gICAgICAgICAgaW5kZXhlcyAmJiAodGVtcEluZGV4ZXNbbmV3RW5kXSA9IGluZGV4ZXNbZW5kXSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3SW5kaWNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIG5ld0luZGljZXNOZXh0ID0gbmV3IEFycmF5KG5ld0VuZCArIDEpO1xuICAgICAgICBmb3IgKGogPSBuZXdFbmQ7IGogPj0gc3RhcnQ7IGotLSkge1xuICAgICAgICAgIGl0ZW0gPSBuZXdJdGVtc1tqXTtcbiAgICAgICAgICBpMiA9IG5ld0luZGljZXMuZ2V0KGl0ZW0pO1xuICAgICAgICAgIG5ld0luZGljZXNOZXh0W2pdID0gaTIgPT09IHZvaWQgMCA/IC0xIDogaTI7XG4gICAgICAgICAgbmV3SW5kaWNlcy5zZXQoaXRlbSwgaik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpMiA9IHN0YXJ0OyBpMiA8PSBlbmQ7IGkyKyspIHtcbiAgICAgICAgICBpdGVtID0gaXRlbXNbaTJdO1xuICAgICAgICAgIGogPSBuZXdJbmRpY2VzLmdldChpdGVtKTtcbiAgICAgICAgICBpZiAoaiAhPT0gdm9pZCAwICYmIGogIT09IC0xKSB7XG4gICAgICAgICAgICB0ZW1wW2pdID0gbWFwcGVkW2kyXTtcbiAgICAgICAgICAgIHRlbXBkaXNwb3NlcnNbal0gPSBkaXNwb3NlcnNbaTJdO1xuICAgICAgICAgICAgaW5kZXhlcyAmJiAodGVtcEluZGV4ZXNbal0gPSBpbmRleGVzW2kyXSk7XG4gICAgICAgICAgICBqID0gbmV3SW5kaWNlc05leHRbal07XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnNldChpdGVtLCBqKTtcbiAgICAgICAgICB9IGVsc2UgZGlzcG9zZXJzW2kyXSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IHN0YXJ0OyBqIDwgbmV3TGVuOyBqKyspIHtcbiAgICAgICAgICBpZiAoaiBpbiB0ZW1wKSB7XG4gICAgICAgICAgICBtYXBwZWRbal0gPSB0ZW1wW2pdO1xuICAgICAgICAgICAgZGlzcG9zZXJzW2pdID0gdGVtcGRpc3Bvc2Vyc1tqXTtcbiAgICAgICAgICAgIGlmIChpbmRleGVzKSB7XG4gICAgICAgICAgICAgIGluZGV4ZXNbal0gPSB0ZW1wSW5kZXhlc1tqXTtcbiAgICAgICAgICAgICAgaW5kZXhlc1tqXShqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgbWFwcGVkW2pdID0gY3JlYXRlUm9vdChtYXBwZXIpO1xuICAgICAgICB9XG4gICAgICAgIG1hcHBlZCA9IG1hcHBlZC5zbGljZSgwLCBsZW4gPSBuZXdMZW4pO1xuICAgICAgICBpdGVtcyA9IG5ld0l0ZW1zLnNsaWNlKDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcHBlZDtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBtYXBwZXIoZGlzcG9zZXIpIHtcbiAgICAgIGRpc3Bvc2Vyc1tqXSA9IGRpc3Bvc2VyO1xuICAgICAgaWYgKGluZGV4ZXMpIHtcbiAgICAgICAgY29uc3QgW3MyLCBzZXRdID0gY3JlYXRlU2lnbmFsKGopO1xuICAgICAgICBpbmRleGVzW2pdID0gc2V0O1xuICAgICAgICByZXR1cm4gbWFwRm4obmV3SXRlbXNbal0sIHMyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXBGbihuZXdJdGVtc1tqXSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KENvbXAsIHByb3BzKSB7XG4gIHJldHVybiB1bnRyYWNrKCgpID0+IENvbXAocHJvcHMgfHwge30pKTtcbn1cbmZ1bmN0aW9uIHRydWVGbigpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBwcm9wVHJhcHMgPSB7XG4gIGdldChfLCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAocHJvcGVydHkgPT09ICRQUk9YWSkgcmV0dXJuIHJlY2VpdmVyO1xuICAgIHJldHVybiBfLmdldChwcm9wZXJ0eSk7XG4gIH0sXG4gIGhhcyhfLCBwcm9wZXJ0eSkge1xuICAgIGlmIChwcm9wZXJ0eSA9PT0gJFBST1hZKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gXy5oYXMocHJvcGVydHkpO1xuICB9LFxuICBzZXQ6IHRydWVGbixcbiAgZGVsZXRlUHJvcGVydHk6IHRydWVGbixcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF8sIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfLmdldChwcm9wZXJ0eSk7XG4gICAgICB9LFxuICAgICAgc2V0OiB0cnVlRm4sXG4gICAgICBkZWxldGVQcm9wZXJ0eTogdHJ1ZUZuXG4gICAgfTtcbiAgfSxcbiAgb3duS2V5cyhfKSB7XG4gICAgcmV0dXJuIF8ua2V5cygpO1xuICB9XG59O1xuZnVuY3Rpb24gcmVzb2x2ZVNvdXJjZShzMikge1xuICByZXR1cm4gIShzMiA9IHR5cGVvZiBzMiA9PT0gXCJmdW5jdGlvblwiID8gczIoKSA6IHMyKSA/IHt9IDogczI7XG59XG5mdW5jdGlvbiByZXNvbHZlU291cmNlcygpIHtcbiAgZm9yIChsZXQgaTIgPSAwLCBsZW5ndGggPSB0aGlzLmxlbmd0aDsgaTIgPCBsZW5ndGg7ICsraTIpIHtcbiAgICBjb25zdCB2ID0gdGhpc1tpMl0oKTtcbiAgICBpZiAodiAhPT0gdm9pZCAwKSByZXR1cm4gdjtcbiAgfVxufVxuZnVuY3Rpb24gbWVyZ2VQcm9wcyguLi5zb3VyY2VzKSB7XG4gIGxldCBwcm94eSA9IGZhbHNlO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgc291cmNlcy5sZW5ndGg7IGkyKyspIHtcbiAgICBjb25zdCBzMiA9IHNvdXJjZXNbaTJdO1xuICAgIHByb3h5ID0gcHJveHkgfHwgISFzMiAmJiAkUFJPWFkgaW4gczI7XG4gICAgc291cmNlc1tpMl0gPSB0eXBlb2YgczIgPT09IFwiZnVuY3Rpb25cIiA/IChwcm94eSA9IHRydWUsIGNyZWF0ZU1lbW8oczIpKSA6IHMyO1xuICB9XG4gIGlmIChTVVBQT1JUU19QUk9YWSAmJiBwcm94eSkge1xuICAgIHJldHVybiBuZXcgUHJveHkoe1xuICAgICAgZ2V0KHByb3BlcnR5KSB7XG4gICAgICAgIGZvciAobGV0IGkyID0gc291cmNlcy5sZW5ndGggLSAxOyBpMiA+PSAwOyBpMi0tKSB7XG4gICAgICAgICAgY29uc3QgdiA9IHJlc29sdmVTb3VyY2Uoc291cmNlc1tpMl0pW3Byb3BlcnR5XTtcbiAgICAgICAgICBpZiAodiAhPT0gdm9pZCAwKSByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhhcyhwcm9wZXJ0eSkge1xuICAgICAgICBmb3IgKGxldCBpMiA9IHNvdXJjZXMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkge1xuICAgICAgICAgIGlmIChwcm9wZXJ0eSBpbiByZXNvbHZlU291cmNlKHNvdXJjZXNbaTJdKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIGtleXMoKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHNvdXJjZXMubGVuZ3RoOyBpMisrKSBrZXlzLnB1c2goLi4uT2JqZWN0LmtleXMocmVzb2x2ZVNvdXJjZShzb3VyY2VzW2kyXSkpKTtcbiAgICAgICAgcmV0dXJuIFsuLi5uZXcgU2V0KGtleXMpXTtcbiAgICAgIH1cbiAgICB9LCBwcm9wVHJhcHMpO1xuICB9XG4gIGNvbnN0IHNvdXJjZXNNYXAgPSB7fTtcbiAgY29uc3QgZGVmaW5lZCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGxldCBpMiA9IHNvdXJjZXMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkge1xuICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaTJdO1xuICAgIGlmICghc291cmNlKSBjb250aW51ZTtcbiAgICBjb25zdCBzb3VyY2VLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlKTtcbiAgICBmb3IgKGxldCBpMyA9IHNvdXJjZUtleXMubGVuZ3RoIC0gMTsgaTMgPj0gMDsgaTMtLSkge1xuICAgICAgY29uc3Qga2V5ID0gc291cmNlS2V5c1tpM107XG4gICAgICBpZiAoa2V5ID09PSBcIl9fcHJvdG9fX1wiIHx8IGtleSA9PT0gXCJjb25zdHJ1Y3RvclwiKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KTtcbiAgICAgIGlmICghZGVmaW5lZFtrZXldKSB7XG4gICAgICAgIGRlZmluZWRba2V5XSA9IGRlc2MuZ2V0ID8ge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogcmVzb2x2ZVNvdXJjZXMuYmluZChzb3VyY2VzTWFwW2tleV0gPSBbZGVzYy5nZXQuYmluZChzb3VyY2UpXSlcbiAgICAgICAgfSA6IGRlc2MudmFsdWUgIT09IHZvaWQgMCA/IGRlc2MgOiB2b2lkIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzb3VyY2VzMiA9IHNvdXJjZXNNYXBba2V5XTtcbiAgICAgICAgaWYgKHNvdXJjZXMyKSB7XG4gICAgICAgICAgaWYgKGRlc2MuZ2V0KSBzb3VyY2VzMi5wdXNoKGRlc2MuZ2V0LmJpbmQoc291cmNlKSk7XG4gICAgICAgICAgZWxzZSBpZiAoZGVzYy52YWx1ZSAhPT0gdm9pZCAwKSBzb3VyY2VzMi5wdXNoKCgpID0+IGRlc2MudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHRhcmdldCA9IHt9O1xuICBjb25zdCBkZWZpbmVkS2V5cyA9IE9iamVjdC5rZXlzKGRlZmluZWQpO1xuICBmb3IgKGxldCBpMiA9IGRlZmluZWRLZXlzLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pIHtcbiAgICBjb25zdCBrZXkgPSBkZWZpbmVkS2V5c1tpMl0sIGRlc2MgPSBkZWZpbmVkW2tleV07XG4gICAgaWYgKGRlc2MgJiYgZGVzYy5nZXQpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSB0YXJnZXRba2V5XSA9IGRlc2MgPyBkZXNjLnZhbHVlIDogdm9pZCAwO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBzcGxpdFByb3BzKHByb3BzLCAuLi5rZXlzKSB7XG4gIGlmIChTVVBQT1JUU19QUk9YWSAmJiAkUFJPWFkgaW4gcHJvcHMpIHtcbiAgICBjb25zdCBibG9ja2VkID0gbmV3IFNldChrZXlzLmxlbmd0aCA+IDEgPyBrZXlzLmZsYXQoKSA6IGtleXNbMF0pO1xuICAgIGNvbnN0IHJlcyA9IGtleXMubWFwKChrKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb3h5KHtcbiAgICAgICAgZ2V0KHByb3BlcnR5KSB7XG4gICAgICAgICAgcmV0dXJuIGsuaW5jbHVkZXMocHJvcGVydHkpID8gcHJvcHNbcHJvcGVydHldIDogdm9pZCAwO1xuICAgICAgICB9LFxuICAgICAgICBoYXMocHJvcGVydHkpIHtcbiAgICAgICAgICByZXR1cm4gay5pbmNsdWRlcyhwcm9wZXJ0eSkgJiYgcHJvcGVydHkgaW4gcHJvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIGtleXMoKSB7XG4gICAgICAgICAgcmV0dXJuIGsuZmlsdGVyKChwcm9wZXJ0eSkgPT4gcHJvcGVydHkgaW4gcHJvcHMpO1xuICAgICAgICB9XG4gICAgICB9LCBwcm9wVHJhcHMpO1xuICAgIH0pO1xuICAgIHJlcy5wdXNoKG5ldyBQcm94eSh7XG4gICAgICBnZXQocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrZWQuaGFzKHByb3BlcnR5KSA/IHZvaWQgMCA6IHByb3BzW3Byb3BlcnR5XTtcbiAgICAgIH0sXG4gICAgICBoYXMocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrZWQuaGFzKHByb3BlcnR5KSA/IGZhbHNlIDogcHJvcGVydHkgaW4gcHJvcHM7XG4gICAgICB9LFxuICAgICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHByb3BzKS5maWx0ZXIoKGspID0+ICFibG9ja2VkLmhhcyhrKSk7XG4gICAgICB9XG4gICAgfSwgcHJvcFRyYXBzKSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBjb25zdCBvdGhlck9iamVjdCA9IHt9O1xuICBjb25zdCBvYmplY3RzID0ga2V5cy5tYXAoKCkgPT4gKHt9KSk7XG4gIGZvciAoY29uc3QgcHJvcE5hbWUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcHMpKSB7XG4gICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvcHMsIHByb3BOYW1lKTtcbiAgICBjb25zdCBpc0RlZmF1bHREZXNjID0gIWRlc2MuZ2V0ICYmICFkZXNjLnNldCAmJiBkZXNjLmVudW1lcmFibGUgJiYgZGVzYy53cml0YWJsZSAmJiBkZXNjLmNvbmZpZ3VyYWJsZTtcbiAgICBsZXQgYmxvY2tlZCA9IGZhbHNlO1xuICAgIGxldCBvYmplY3RJbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBrIG9mIGtleXMpIHtcbiAgICAgIGlmIChrLmluY2x1ZGVzKHByb3BOYW1lKSkge1xuICAgICAgICBibG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgaXNEZWZhdWx0RGVzYyA/IG9iamVjdHNbb2JqZWN0SW5kZXhdW3Byb3BOYW1lXSA9IGRlc2MudmFsdWUgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0c1tvYmplY3RJbmRleF0sIHByb3BOYW1lLCBkZXNjKTtcbiAgICAgIH1cbiAgICAgICsrb2JqZWN0SW5kZXg7XG4gICAgfVxuICAgIGlmICghYmxvY2tlZCkge1xuICAgICAgaXNEZWZhdWx0RGVzYyA/IG90aGVyT2JqZWN0W3Byb3BOYW1lXSA9IGRlc2MudmFsdWUgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkob3RoZXJPYmplY3QsIHByb3BOYW1lLCBkZXNjKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFsuLi5vYmplY3RzLCBvdGhlck9iamVjdF07XG59XG5jb25zdCBuYXJyb3dlZEVycm9yID0gKG5hbWUpID0+IGBTdGFsZSByZWFkIGZyb20gPCR7bmFtZX0+LmA7XG5mdW5jdGlvbiBGb3IocHJvcHMpIHtcbiAgY29uc3QgZmFsbGJhY2sgPSBcImZhbGxiYWNrXCIgaW4gcHJvcHMgJiYge1xuICAgIGZhbGxiYWNrOiAoKSA9PiBwcm9wcy5mYWxsYmFja1xuICB9O1xuICByZXR1cm4gY3JlYXRlTWVtbyhtYXBBcnJheSgoKSA9PiBwcm9wcy5lYWNoLCBwcm9wcy5jaGlsZHJlbiwgZmFsbGJhY2sgfHwgdm9pZCAwKSk7XG59XG5mdW5jdGlvbiBTaG93KHByb3BzKSB7XG4gIGNvbnN0IGtleWVkID0gcHJvcHMua2V5ZWQ7XG4gIGNvbnN0IGNvbmRpdGlvblZhbHVlID0gY3JlYXRlTWVtbygoKSA9PiBwcm9wcy53aGVuLCB2b2lkIDAsIHZvaWQgMCk7XG4gIGNvbnN0IGNvbmRpdGlvbiA9IGtleWVkID8gY29uZGl0aW9uVmFsdWUgOiBjcmVhdGVNZW1vKGNvbmRpdGlvblZhbHVlLCB2b2lkIDAsIHtcbiAgICBlcXVhbHM6IChhMiwgYikgPT4gIWEyID09PSAhYlxuICB9KTtcbiAgcmV0dXJuIGNyZWF0ZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGMyID0gY29uZGl0aW9uKCk7XG4gICAgaWYgKGMyKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgY29uc3QgZm4gPSB0eXBlb2YgY2hpbGQgPT09IFwiZnVuY3Rpb25cIiAmJiBjaGlsZC5sZW5ndGggPiAwO1xuICAgICAgcmV0dXJuIGZuID8gdW50cmFjaygoKSA9PiBjaGlsZChrZXllZCA/IGMyIDogKCkgPT4ge1xuICAgICAgICBpZiAoIXVudHJhY2soY29uZGl0aW9uKSkgdGhyb3cgbmFycm93ZWRFcnJvcihcIlNob3dcIik7XG4gICAgICAgIHJldHVybiBjb25kaXRpb25WYWx1ZSgpO1xuICAgICAgfSkpIDogY2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiBwcm9wcy5mYWxsYmFjaztcbiAgfSwgdm9pZCAwLCB2b2lkIDApO1xufVxuZnVuY3Rpb24gU3dpdGNoKHByb3BzKSB7XG4gIGNvbnN0IGNocyA9IGNoaWxkcmVuKCgpID0+IHByb3BzLmNoaWxkcmVuKTtcbiAgY29uc3Qgc3dpdGNoRnVuYyA9IGNyZWF0ZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGNoID0gY2hzKCk7XG4gICAgY29uc3QgbXBzID0gQXJyYXkuaXNBcnJheShjaCkgPyBjaCA6IFtjaF07XG4gICAgbGV0IGZ1bmMgPSAoKSA9PiB2b2lkIDA7XG4gICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG1wcy5sZW5ndGg7IGkyKyspIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gaTI7XG4gICAgICBjb25zdCBtcCA9IG1wc1tpMl07XG4gICAgICBjb25zdCBwcmV2RnVuYyA9IGZ1bmM7XG4gICAgICBjb25zdCBjb25kaXRpb25WYWx1ZSA9IGNyZWF0ZU1lbW8oKCkgPT4gcHJldkZ1bmMoKSA/IHZvaWQgMCA6IG1wLndoZW4sIHZvaWQgMCwgdm9pZCAwKTtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IG1wLmtleWVkID8gY29uZGl0aW9uVmFsdWUgOiBjcmVhdGVNZW1vKGNvbmRpdGlvblZhbHVlLCB2b2lkIDAsIHtcbiAgICAgICAgZXF1YWxzOiAoYTIsIGIpID0+ICFhMiA9PT0gIWJcbiAgICAgIH0pO1xuICAgICAgZnVuYyA9ICgpID0+IHByZXZGdW5jKCkgfHwgKGNvbmRpdGlvbigpID8gW2luZGV4LCBjb25kaXRpb25WYWx1ZSwgbXBdIDogdm9pZCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0pO1xuICByZXR1cm4gY3JlYXRlTWVtbygoKSA9PiB7XG4gICAgY29uc3Qgc2VsID0gc3dpdGNoRnVuYygpKCk7XG4gICAgaWYgKCFzZWwpIHJldHVybiBwcm9wcy5mYWxsYmFjaztcbiAgICBjb25zdCBbaW5kZXgsIGNvbmRpdGlvblZhbHVlLCBtcF0gPSBzZWw7XG4gICAgY29uc3QgY2hpbGQgPSBtcC5jaGlsZHJlbjtcbiAgICBjb25zdCBmbiA9IHR5cGVvZiBjaGlsZCA9PT0gXCJmdW5jdGlvblwiICYmIGNoaWxkLmxlbmd0aCA+IDA7XG4gICAgcmV0dXJuIGZuID8gdW50cmFjaygoKSA9PiBjaGlsZChtcC5rZXllZCA/IGNvbmRpdGlvblZhbHVlKCkgOiAoKSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgaWYgKCgoX2EyID0gdW50cmFjayhzd2l0Y2hGdW5jKSgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyWzBdKSAhPT0gaW5kZXgpIHRocm93IG5hcnJvd2VkRXJyb3IoXCJNYXRjaFwiKTtcbiAgICAgIHJldHVybiBjb25kaXRpb25WYWx1ZSgpO1xuICAgIH0pKSA6IGNoaWxkO1xuICB9LCB2b2lkIDAsIHZvaWQgMCk7XG59XG5mdW5jdGlvbiBNYXRjaChwcm9wcykge1xuICByZXR1cm4gcHJvcHM7XG59XG5jb25zdCBib29sZWFucyA9IFtcImFsbG93ZnVsbHNjcmVlblwiLCBcImFzeW5jXCIsIFwiYXV0b2ZvY3VzXCIsIFwiYXV0b3BsYXlcIiwgXCJjaGVja2VkXCIsIFwiY29udHJvbHNcIiwgXCJkZWZhdWx0XCIsIFwiZGlzYWJsZWRcIiwgXCJmb3Jtbm92YWxpZGF0ZVwiLCBcImhpZGRlblwiLCBcImluZGV0ZXJtaW5hdGVcIiwgXCJpbmVydFwiLCBcImlzbWFwXCIsIFwibG9vcFwiLCBcIm11bHRpcGxlXCIsIFwibXV0ZWRcIiwgXCJub21vZHVsZVwiLCBcIm5vdmFsaWRhdGVcIiwgXCJvcGVuXCIsIFwicGxheXNpbmxpbmVcIiwgXCJyZWFkb25seVwiLCBcInJlcXVpcmVkXCIsIFwicmV2ZXJzZWRcIiwgXCJzZWFtbGVzc1wiLCBcInNlbGVjdGVkXCJdO1xuY29uc3QgUHJvcGVydGllcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImNsYXNzTmFtZVwiLCBcInZhbHVlXCIsIFwicmVhZE9ubHlcIiwgXCJub1ZhbGlkYXRlXCIsIFwiZm9ybU5vVmFsaWRhdGVcIiwgXCJpc01hcFwiLCBcIm5vTW9kdWxlXCIsIFwicGxheXNJbmxpbmVcIiwgLi4uYm9vbGVhbnNdKTtcbmNvbnN0IENoaWxkUHJvcGVydGllcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImlubmVySFRNTFwiLCBcInRleHRDb250ZW50XCIsIFwiaW5uZXJUZXh0XCIsIFwiY2hpbGRyZW5cIl0pO1xuY29uc3QgQWxpYXNlcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuYXNzaWduKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gIGNsYXNzTmFtZTogXCJjbGFzc1wiLFxuICBodG1sRm9yOiBcImZvclwiXG59KTtcbmNvbnN0IFByb3BBbGlhc2VzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5hc3NpZ24oLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgY2xhc3M6IFwiY2xhc3NOYW1lXCIsXG4gIG5vdmFsaWRhdGU6IHtcbiAgICAkOiBcIm5vVmFsaWRhdGVcIixcbiAgICBGT1JNOiAxXG4gIH0sXG4gIGZvcm1ub3ZhbGlkYXRlOiB7XG4gICAgJDogXCJmb3JtTm9WYWxpZGF0ZVwiLFxuICAgIEJVVFRPTjogMSxcbiAgICBJTlBVVDogMVxuICB9LFxuICBpc21hcDoge1xuICAgICQ6IFwiaXNNYXBcIixcbiAgICBJTUc6IDFcbiAgfSxcbiAgbm9tb2R1bGU6IHtcbiAgICAkOiBcIm5vTW9kdWxlXCIsXG4gICAgU0NSSVBUOiAxXG4gIH0sXG4gIHBsYXlzaW5saW5lOiB7XG4gICAgJDogXCJwbGF5c0lubGluZVwiLFxuICAgIFZJREVPOiAxXG4gIH0sXG4gIHJlYWRvbmx5OiB7XG4gICAgJDogXCJyZWFkT25seVwiLFxuICAgIElOUFVUOiAxLFxuICAgIFRFWFRBUkVBOiAxXG4gIH1cbn0pO1xuZnVuY3Rpb24gZ2V0UHJvcEFsaWFzKHByb3AsIHRhZ05hbWUpIHtcbiAgY29uc3QgYTIgPSBQcm9wQWxpYXNlc1twcm9wXTtcbiAgcmV0dXJuIHR5cGVvZiBhMiA9PT0gXCJvYmplY3RcIiA/IGEyW3RhZ05hbWVdID8gYTJbXCIkXCJdIDogdm9pZCAwIDogYTI7XG59XG5jb25zdCBEZWxlZ2F0ZWRFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJiZWZvcmVpbnB1dFwiLCBcImNsaWNrXCIsIFwiZGJsY2xpY2tcIiwgXCJjb250ZXh0bWVudVwiLCBcImZvY3VzaW5cIiwgXCJmb2N1c291dFwiLCBcImlucHV0XCIsIFwia2V5ZG93blwiLCBcImtleXVwXCIsIFwibW91c2Vkb3duXCIsIFwibW91c2Vtb3ZlXCIsIFwibW91c2VvdXRcIiwgXCJtb3VzZW92ZXJcIiwgXCJtb3VzZXVwXCIsIFwicG9pbnRlcmRvd25cIiwgXCJwb2ludGVybW92ZVwiLCBcInBvaW50ZXJvdXRcIiwgXCJwb2ludGVyb3ZlclwiLCBcInBvaW50ZXJ1cFwiLCBcInRvdWNoZW5kXCIsIFwidG91Y2htb3ZlXCIsIFwidG91Y2hzdGFydFwiXSk7XG5jb25zdCBTVkdFbGVtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJhbHRHbHlwaFwiLFxuICBcImFsdEdseXBoRGVmXCIsXG4gIFwiYWx0R2x5cGhJdGVtXCIsXG4gIFwiYW5pbWF0ZVwiLFxuICBcImFuaW1hdGVDb2xvclwiLFxuICBcImFuaW1hdGVNb3Rpb25cIixcbiAgXCJhbmltYXRlVHJhbnNmb3JtXCIsXG4gIFwiY2lyY2xlXCIsXG4gIFwiY2xpcFBhdGhcIixcbiAgXCJjb2xvci1wcm9maWxlXCIsXG4gIFwiY3Vyc29yXCIsXG4gIFwiZGVmc1wiLFxuICBcImRlc2NcIixcbiAgXCJlbGxpcHNlXCIsXG4gIFwiZmVCbGVuZFwiLFxuICBcImZlQ29sb3JNYXRyaXhcIixcbiAgXCJmZUNvbXBvbmVudFRyYW5zZmVyXCIsXG4gIFwiZmVDb21wb3NpdGVcIixcbiAgXCJmZUNvbnZvbHZlTWF0cml4XCIsXG4gIFwiZmVEaWZmdXNlTGlnaHRpbmdcIixcbiAgXCJmZURpc3BsYWNlbWVudE1hcFwiLFxuICBcImZlRGlzdGFudExpZ2h0XCIsXG4gIFwiZmVEcm9wU2hhZG93XCIsXG4gIFwiZmVGbG9vZFwiLFxuICBcImZlRnVuY0FcIixcbiAgXCJmZUZ1bmNCXCIsXG4gIFwiZmVGdW5jR1wiLFxuICBcImZlRnVuY1JcIixcbiAgXCJmZUdhdXNzaWFuQmx1clwiLFxuICBcImZlSW1hZ2VcIixcbiAgXCJmZU1lcmdlXCIsXG4gIFwiZmVNZXJnZU5vZGVcIixcbiAgXCJmZU1vcnBob2xvZ3lcIixcbiAgXCJmZU9mZnNldFwiLFxuICBcImZlUG9pbnRMaWdodFwiLFxuICBcImZlU3BlY3VsYXJMaWdodGluZ1wiLFxuICBcImZlU3BvdExpZ2h0XCIsXG4gIFwiZmVUaWxlXCIsXG4gIFwiZmVUdXJidWxlbmNlXCIsXG4gIFwiZmlsdGVyXCIsXG4gIFwiZm9udFwiLFxuICBcImZvbnQtZmFjZVwiLFxuICBcImZvbnQtZmFjZS1mb3JtYXRcIixcbiAgXCJmb250LWZhY2UtbmFtZVwiLFxuICBcImZvbnQtZmFjZS1zcmNcIixcbiAgXCJmb250LWZhY2UtdXJpXCIsXG4gIFwiZm9yZWlnbk9iamVjdFwiLFxuICBcImdcIixcbiAgXCJnbHlwaFwiLFxuICBcImdseXBoUmVmXCIsXG4gIFwiaGtlcm5cIixcbiAgXCJpbWFnZVwiLFxuICBcImxpbmVcIixcbiAgXCJsaW5lYXJHcmFkaWVudFwiLFxuICBcIm1hcmtlclwiLFxuICBcIm1hc2tcIixcbiAgXCJtZXRhZGF0YVwiLFxuICBcIm1pc3NpbmctZ2x5cGhcIixcbiAgXCJtcGF0aFwiLFxuICBcInBhdGhcIixcbiAgXCJwYXR0ZXJuXCIsXG4gIFwicG9seWdvblwiLFxuICBcInBvbHlsaW5lXCIsXG4gIFwicmFkaWFsR3JhZGllbnRcIixcbiAgXCJyZWN0XCIsXG4gIFwic2V0XCIsXG4gIFwic3RvcFwiLFxuICBcInN2Z1wiLFxuICBcInN3aXRjaFwiLFxuICBcInN5bWJvbFwiLFxuICBcInRleHRcIixcbiAgXCJ0ZXh0UGF0aFwiLFxuICBcInRyZWZcIixcbiAgXCJ0c3BhblwiLFxuICBcInVzZVwiLFxuICBcInZpZXdcIixcbiAgXCJ2a2VyblwiXG5dKTtcbmNvbnN0IFNWR05hbWVzcGFjZSA9IHtcbiAgeGxpbms6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICB4bWw6IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCJcbn07XG5jb25zdCBtZW1vID0gKGZuKSA9PiBjcmVhdGVNZW1vKCgpID0+IGZuKCkpO1xuZnVuY3Rpb24gcmVjb25jaWxlQXJyYXlzKHBhcmVudE5vZGUsIGEyLCBiKSB7XG4gIGxldCBiTGVuZ3RoID0gYi5sZW5ndGgsIGFFbmQgPSBhMi5sZW5ndGgsIGJFbmQgPSBiTGVuZ3RoLCBhU3RhcnQgPSAwLCBiU3RhcnQgPSAwLCBhZnRlciA9IGEyW2FFbmQgLSAxXS5uZXh0U2libGluZywgbWFwID0gbnVsbDtcbiAgd2hpbGUgKGFTdGFydCA8IGFFbmQgfHwgYlN0YXJ0IDwgYkVuZCkge1xuICAgIGlmIChhMlthU3RhcnRdID09PSBiW2JTdGFydF0pIHtcbiAgICAgIGFTdGFydCsrO1xuICAgICAgYlN0YXJ0Kys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgd2hpbGUgKGEyW2FFbmQgLSAxXSA9PT0gYltiRW5kIC0gMV0pIHtcbiAgICAgIGFFbmQtLTtcbiAgICAgIGJFbmQtLTtcbiAgICB9XG4gICAgaWYgKGFFbmQgPT09IGFTdGFydCkge1xuICAgICAgY29uc3Qgbm9kZSA9IGJFbmQgPCBiTGVuZ3RoID8gYlN0YXJ0ID8gYltiU3RhcnQgLSAxXS5uZXh0U2libGluZyA6IGJbYkVuZCAtIGJTdGFydF0gOiBhZnRlcjtcbiAgICAgIHdoaWxlIChiU3RhcnQgPCBiRW5kKSBwYXJlbnROb2RlLmluc2VydEJlZm9yZShiW2JTdGFydCsrXSwgbm9kZSk7XG4gICAgfSBlbHNlIGlmIChiRW5kID09PSBiU3RhcnQpIHtcbiAgICAgIHdoaWxlIChhU3RhcnQgPCBhRW5kKSB7XG4gICAgICAgIGlmICghbWFwIHx8ICFtYXAuaGFzKGEyW2FTdGFydF0pKSBhMlthU3RhcnRdLnJlbW92ZSgpO1xuICAgICAgICBhU3RhcnQrKztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGEyW2FTdGFydF0gPT09IGJbYkVuZCAtIDFdICYmIGJbYlN0YXJ0XSA9PT0gYTJbYUVuZCAtIDFdKSB7XG4gICAgICBjb25zdCBub2RlID0gYTJbLS1hRW5kXS5uZXh0U2libGluZztcbiAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGJbYlN0YXJ0KytdLCBhMlthU3RhcnQrK10ubmV4dFNpYmxpbmcpO1xuICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYlstLWJFbmRdLCBub2RlKTtcbiAgICAgIGEyW2FFbmRdID0gYltiRW5kXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IGkyID0gYlN0YXJ0O1xuICAgICAgICB3aGlsZSAoaTIgPCBiRW5kKSBtYXAuc2V0KGJbaTJdLCBpMisrKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluZGV4ID0gbWFwLmdldChhMlthU3RhcnRdKTtcbiAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChiU3RhcnQgPCBpbmRleCAmJiBpbmRleCA8IGJFbmQpIHtcbiAgICAgICAgICBsZXQgaTIgPSBhU3RhcnQsIHNlcXVlbmNlID0gMSwgdDI7XG4gICAgICAgICAgd2hpbGUgKCsraTIgPCBhRW5kICYmIGkyIDwgYkVuZCkge1xuICAgICAgICAgICAgaWYgKCh0MiA9IG1hcC5nZXQoYTJbaTJdKSkgPT0gbnVsbCB8fCB0MiAhPT0gaW5kZXggKyBzZXF1ZW5jZSkgYnJlYWs7XG4gICAgICAgICAgICBzZXF1ZW5jZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2VxdWVuY2UgPiBpbmRleCAtIGJTdGFydCkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGEyW2FTdGFydF07XG4gICAgICAgICAgICB3aGlsZSAoYlN0YXJ0IDwgaW5kZXgpIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGJbYlN0YXJ0KytdLCBub2RlKTtcbiAgICAgICAgICB9IGVsc2UgcGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoYltiU3RhcnQrK10sIGEyW2FTdGFydCsrXSk7XG4gICAgICAgIH0gZWxzZSBhU3RhcnQrKztcbiAgICAgIH0gZWxzZSBhMlthU3RhcnQrK10ucmVtb3ZlKCk7XG4gICAgfVxuICB9XG59XG5jb25zdCAkJEVWRU5UUyA9IFwiXyREWF9ERUxFR0FURVwiO1xuZnVuY3Rpb24gcmVuZGVyKGNvZGUsIGVsZW1lbnQsIGluaXQsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgZGlzcG9zZXI7XG4gIGNyZWF0ZVJvb3QoKGRpc3Bvc2UyKSA9PiB7XG4gICAgZGlzcG9zZXIgPSBkaXNwb3NlMjtcbiAgICBlbGVtZW50ID09PSBkb2N1bWVudCA/IGNvZGUoKSA6IGluc2VydChlbGVtZW50LCBjb2RlKCksIGVsZW1lbnQuZmlyc3RDaGlsZCA/IG51bGwgOiB2b2lkIDAsIGluaXQpO1xuICB9LCBvcHRpb25zLm93bmVyKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBkaXNwb3NlcigpO1xuICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuICB9O1xufVxuZnVuY3Rpb24gdGVtcGxhdGUkMShodG1sLCBpc0ltcG9ydE5vZGUsIGlzU1ZHLCBpc01hdGhNTCkge1xuICBsZXQgbm9kZTtcbiAgY29uc3QgY3JlYXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IHQyID0gaXNNYXRoTUwgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCIsIFwidGVtcGxhdGVcIikgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG4gICAgdDIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gaXNTVkcgPyB0Mi5jb250ZW50LmZpcnN0Q2hpbGQuZmlyc3RDaGlsZCA6IGlzTWF0aE1MID8gdDIuZmlyc3RDaGlsZCA6IHQyLmNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgfTtcbiAgY29uc3QgZm4gPSBpc0ltcG9ydE5vZGUgPyAoKSA9PiB1bnRyYWNrKCgpID0+IGRvY3VtZW50LmltcG9ydE5vZGUobm9kZSB8fCAobm9kZSA9IGNyZWF0ZSgpKSwgdHJ1ZSkpIDogKCkgPT4gKG5vZGUgfHwgKG5vZGUgPSBjcmVhdGUoKSkpLmNsb25lTm9kZSh0cnVlKTtcbiAgZm4uY2xvbmVOb2RlID0gZm47XG4gIHJldHVybiBmbjtcbn1cbmZ1bmN0aW9uIGRlbGVnYXRlRXZlbnRzKGV2ZW50TmFtZXMsIGRvY3VtZW50MiA9IHdpbmRvdy5kb2N1bWVudCkge1xuICBjb25zdCBlMiA9IGRvY3VtZW50MlskJEVWRU5UU10gfHwgKGRvY3VtZW50MlskJEVWRU5UU10gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgZm9yIChsZXQgaTIgPSAwLCBsMiA9IGV2ZW50TmFtZXMubGVuZ3RoOyBpMiA8IGwyOyBpMisrKSB7XG4gICAgY29uc3QgbmFtZSA9IGV2ZW50TmFtZXNbaTJdO1xuICAgIGlmICghZTIuaGFzKG5hbWUpKSB7XG4gICAgICBlMi5hZGQobmFtZSk7XG4gICAgICBkb2N1bWVudDIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBldmVudEhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgZWxzZSBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVOUyhub2RlLCBuYW1lc3BhY2UsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSBub2RlLnJlbW92ZUF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgbmFtZSk7XG4gIGVsc2Ugbm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHNldEJvb2xBdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgdmFsdWUgPyBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCBcIlwiKSA6IG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xufVxuZnVuY3Rpb24gY2xhc3NOYW1lKG5vZGUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSBub2RlLnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICBlbHNlIG5vZGUuY2xhc3NOYW1lID0gdmFsdWU7XG59XG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIG5hbWUsIGhhbmRsZXIsIGRlbGVnYXRlKSB7XG4gIGlmIChkZWxlZ2F0ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBub2RlW2AkJCR7bmFtZX1gXSA9IGhhbmRsZXJbMF07XG4gICAgICBub2RlW2AkJCR7bmFtZX1EYXRhYF0gPSBoYW5kbGVyWzFdO1xuICAgIH0gZWxzZSBub2RlW2AkJCR7bmFtZX1gXSA9IGhhbmRsZXI7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgIGNvbnN0IGhhbmRsZXJGbiA9IGhhbmRsZXJbMF07XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXJbMF0gPSAoZTIpID0+IGhhbmRsZXJGbi5jYWxsKG5vZGUsIGhhbmRsZXJbMV0sIGUyKSk7XG4gIH0gZWxzZSBub2RlLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgdHlwZW9mIGhhbmRsZXIgIT09IFwiZnVuY3Rpb25cIiAmJiBoYW5kbGVyKTtcbn1cbmZ1bmN0aW9uIGNsYXNzTGlzdChub2RlLCB2YWx1ZSwgcHJldiA9IHt9KSB7XG4gIGNvbnN0IGNsYXNzS2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlIHx8IHt9KSwgcHJldktleXMgPSBPYmplY3Qua2V5cyhwcmV2KTtcbiAgbGV0IGkyLCBsZW47XG4gIGZvciAoaTIgPSAwLCBsZW4gPSBwcmV2S2V5cy5sZW5ndGg7IGkyIDwgbGVuOyBpMisrKSB7XG4gICAgY29uc3Qga2V5ID0gcHJldktleXNbaTJdO1xuICAgIGlmICgha2V5IHx8IGtleSA9PT0gXCJ1bmRlZmluZWRcIiB8fCB2YWx1ZVtrZXldKSBjb250aW51ZTtcbiAgICB0b2dnbGVDbGFzc0tleShub2RlLCBrZXksIGZhbHNlKTtcbiAgICBkZWxldGUgcHJldltrZXldO1xuICB9XG4gIGZvciAoaTIgPSAwLCBsZW4gPSBjbGFzc0tleXMubGVuZ3RoOyBpMiA8IGxlbjsgaTIrKykge1xuICAgIGNvbnN0IGtleSA9IGNsYXNzS2V5c1tpMl0sIGNsYXNzVmFsdWUgPSAhIXZhbHVlW2tleV07XG4gICAgaWYgKCFrZXkgfHwga2V5ID09PSBcInVuZGVmaW5lZFwiIHx8IHByZXZba2V5XSA9PT0gY2xhc3NWYWx1ZSB8fCAhY2xhc3NWYWx1ZSkgY29udGludWU7XG4gICAgdG9nZ2xlQ2xhc3NLZXkobm9kZSwga2V5LCB0cnVlKTtcbiAgICBwcmV2W2tleV0gPSBjbGFzc1ZhbHVlO1xuICB9XG4gIHJldHVybiBwcmV2O1xufVxuZnVuY3Rpb24gc3R5bGUobm9kZSwgdmFsdWUsIHByZXYpIHtcbiAgaWYgKCF2YWx1ZSkgcmV0dXJuIHByZXYgPyBzZXRBdHRyaWJ1dGUobm9kZSwgXCJzdHlsZVwiKSA6IHZhbHVlO1xuICBjb25zdCBub2RlU3R5bGUgPSBub2RlLnN0eWxlO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSByZXR1cm4gbm9kZVN0eWxlLmNzc1RleHQgPSB2YWx1ZTtcbiAgdHlwZW9mIHByZXYgPT09IFwic3RyaW5nXCIgJiYgKG5vZGVTdHlsZS5jc3NUZXh0ID0gcHJldiA9IHZvaWQgMCk7XG4gIHByZXYgfHwgKHByZXYgPSB7fSk7XG4gIHZhbHVlIHx8ICh2YWx1ZSA9IHt9KTtcbiAgbGV0IHYsIHMyO1xuICBmb3IgKHMyIGluIHByZXYpIHtcbiAgICB2YWx1ZVtzMl0gPT0gbnVsbCAmJiBub2RlU3R5bGUucmVtb3ZlUHJvcGVydHkoczIpO1xuICAgIGRlbGV0ZSBwcmV2W3MyXTtcbiAgfVxuICBmb3IgKHMyIGluIHZhbHVlKSB7XG4gICAgdiA9IHZhbHVlW3MyXTtcbiAgICBpZiAodiAhPT0gcHJldltzMl0pIHtcbiAgICAgIG5vZGVTdHlsZS5zZXRQcm9wZXJ0eShzMiwgdik7XG4gICAgICBwcmV2W3MyXSA9IHY7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcmV2O1xufVxuZnVuY3Rpb24gc3ByZWFkKG5vZGUsIHByb3BzID0ge30sIGlzU1ZHLCBza2lwQ2hpbGRyZW4pIHtcbiAgY29uc3QgcHJldlByb3BzID0ge307XG4gIHtcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKCkgPT4gcHJldlByb3BzLmNoaWxkcmVuID0gaW5zZXJ0RXhwcmVzc2lvbihub2RlLCBwcm9wcy5jaGlsZHJlbiwgcHJldlByb3BzLmNoaWxkcmVuKSk7XG4gIH1cbiAgY3JlYXRlUmVuZGVyRWZmZWN0KCgpID0+IHR5cGVvZiBwcm9wcy5yZWYgPT09IFwiZnVuY3Rpb25cIiAmJiB1c2UocHJvcHMucmVmLCBub2RlKSk7XG4gIGNyZWF0ZVJlbmRlckVmZmVjdCgoKSA9PiBhc3NpZ24obm9kZSwgcHJvcHMsIGlzU1ZHLCB0cnVlLCBwcmV2UHJvcHMsIHRydWUpKTtcbiAgcmV0dXJuIHByZXZQcm9wcztcbn1cbmZ1bmN0aW9uIHVzZShmbiwgZWxlbWVudCwgYXJnKSB7XG4gIHJldHVybiB1bnRyYWNrKCgpID0+IGZuKGVsZW1lbnQsIGFyZykpO1xufVxuZnVuY3Rpb24gaW5zZXJ0KHBhcmVudCwgYWNjZXNzb3IsIG1hcmtlciwgaW5pdGlhbCkge1xuICBpZiAobWFya2VyICE9PSB2b2lkIDAgJiYgIWluaXRpYWwpIGluaXRpYWwgPSBbXTtcbiAgaWYgKHR5cGVvZiBhY2Nlc3NvciAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gaW5zZXJ0RXhwcmVzc2lvbihwYXJlbnQsIGFjY2Vzc29yLCBpbml0aWFsLCBtYXJrZXIpO1xuICBjcmVhdGVSZW5kZXJFZmZlY3QoKGN1cnJlbnQpID0+IGluc2VydEV4cHJlc3Npb24ocGFyZW50LCBhY2Nlc3NvcigpLCBjdXJyZW50LCBtYXJrZXIpLCBpbml0aWFsKTtcbn1cbmZ1bmN0aW9uIGFzc2lnbihub2RlLCBwcm9wcywgaXNTVkcsIHNraXBDaGlsZHJlbiwgcHJldlByb3BzID0ge30sIHNraXBSZWYgPSBmYWxzZSkge1xuICBwcm9wcyB8fCAocHJvcHMgPSB7fSk7XG4gIGZvciAoY29uc3QgcHJvcCBpbiBwcmV2UHJvcHMpIHtcbiAgICBpZiAoIShwcm9wIGluIHByb3BzKSkge1xuICAgICAgaWYgKHByb3AgPT09IFwiY2hpbGRyZW5cIikgY29udGludWU7XG4gICAgICBwcmV2UHJvcHNbcHJvcF0gPSBhc3NpZ25Qcm9wKG5vZGUsIHByb3AsIG51bGwsIHByZXZQcm9wc1twcm9wXSwgaXNTVkcsIHNraXBSZWYsIHByb3BzKTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBwcm9wIGluIHByb3BzKSB7XG4gICAgaWYgKHByb3AgPT09IFwiY2hpbGRyZW5cIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gcHJvcHNbcHJvcF07XG4gICAgcHJldlByb3BzW3Byb3BdID0gYXNzaWduUHJvcChub2RlLCBwcm9wLCB2YWx1ZSwgcHJldlByb3BzW3Byb3BdLCBpc1NWRywgc2tpcFJlZiwgcHJvcHMpO1xuICB9XG59XG5mdW5jdGlvbiB0b1Byb3BlcnR5TmFtZShuYW1lKSB7XG4gIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLShbYS16XSkvZywgKF8sIHcpID0+IHcudG9VcHBlckNhc2UoKSk7XG59XG5mdW5jdGlvbiB0b2dnbGVDbGFzc0tleShub2RlLCBrZXksIHZhbHVlKSB7XG4gIGNvbnN0IGNsYXNzTmFtZXMgPSBrZXkudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG4gIGZvciAobGV0IGkyID0gMCwgbmFtZUxlbiA9IGNsYXNzTmFtZXMubGVuZ3RoOyBpMiA8IG5hbWVMZW47IGkyKyspIG5vZGUuY2xhc3NMaXN0LnRvZ2dsZShjbGFzc05hbWVzW2kyXSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gYXNzaWduUHJvcChub2RlLCBwcm9wLCB2YWx1ZSwgcHJldiwgaXNTVkcsIHNraXBSZWYsIHByb3BzKSB7XG4gIGxldCBpc0NFLCBpc1Byb3AsIGlzQ2hpbGRQcm9wLCBwcm9wQWxpYXMsIGZvcmNlUHJvcDtcbiAgaWYgKHByb3AgPT09IFwic3R5bGVcIikgcmV0dXJuIHN0eWxlKG5vZGUsIHZhbHVlLCBwcmV2KTtcbiAgaWYgKHByb3AgPT09IFwiY2xhc3NMaXN0XCIpIHJldHVybiBjbGFzc0xpc3Qobm9kZSwgdmFsdWUsIHByZXYpO1xuICBpZiAodmFsdWUgPT09IHByZXYpIHJldHVybiBwcmV2O1xuICBpZiAocHJvcCA9PT0gXCJyZWZcIikge1xuICAgIGlmICghc2tpcFJlZikgdmFsdWUobm9kZSk7XG4gIH0gZWxzZSBpZiAocHJvcC5zbGljZSgwLCAzKSA9PT0gXCJvbjpcIikge1xuICAgIGNvbnN0IGUyID0gcHJvcC5zbGljZSgzKTtcbiAgICBwcmV2ICYmIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihlMiwgcHJldiwgdHlwZW9mIHByZXYgIT09IFwiZnVuY3Rpb25cIiAmJiBwcmV2KTtcbiAgICB2YWx1ZSAmJiBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZTIsIHZhbHVlLCB0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIiAmJiB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAocHJvcC5zbGljZSgwLCAxMCkgPT09IFwib25jYXB0dXJlOlwiKSB7XG4gICAgY29uc3QgZTIgPSBwcm9wLnNsaWNlKDEwKTtcbiAgICBwcmV2ICYmIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihlMiwgcHJldiwgdHJ1ZSk7XG4gICAgdmFsdWUgJiYgbm9kZS5hZGRFdmVudExpc3RlbmVyKGUyLCB2YWx1ZSwgdHJ1ZSk7XG4gIH0gZWxzZSBpZiAocHJvcC5zbGljZSgwLCAyKSA9PT0gXCJvblwiKSB7XG4gICAgY29uc3QgbmFtZSA9IHByb3Auc2xpY2UoMikudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBkZWxlZ2F0ZSA9IERlbGVnYXRlZEV2ZW50cy5oYXMobmFtZSk7XG4gICAgaWYgKCFkZWxlZ2F0ZSAmJiBwcmV2KSB7XG4gICAgICBjb25zdCBoMiA9IEFycmF5LmlzQXJyYXkocHJldikgPyBwcmV2WzBdIDogcHJldjtcbiAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoMik7XG4gICAgfVxuICAgIGlmIChkZWxlZ2F0ZSB8fCB2YWx1ZSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBuYW1lLCB2YWx1ZSwgZGVsZWdhdGUpO1xuICAgICAgZGVsZWdhdGUgJiYgZGVsZWdhdGVFdmVudHMoW25hbWVdKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvcC5zbGljZSgwLCA1KSA9PT0gXCJhdHRyOlwiKSB7XG4gICAgc2V0QXR0cmlidXRlKG5vZGUsIHByb3Auc2xpY2UoNSksIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChwcm9wLnNsaWNlKDAsIDUpID09PSBcImJvb2w6XCIpIHtcbiAgICBzZXRCb29sQXR0cmlidXRlKG5vZGUsIHByb3Auc2xpY2UoNSksIHZhbHVlKTtcbiAgfSBlbHNlIGlmICgoZm9yY2VQcm9wID0gcHJvcC5zbGljZSgwLCA1KSA9PT0gXCJwcm9wOlwiKSB8fCAoaXNDaGlsZFByb3AgPSBDaGlsZFByb3BlcnRpZXMuaGFzKHByb3ApKSB8fCAhaXNTVkcgJiYgKChwcm9wQWxpYXMgPSBnZXRQcm9wQWxpYXMocHJvcCwgbm9kZS50YWdOYW1lKSkgfHwgKGlzUHJvcCA9IFByb3BlcnRpZXMuaGFzKHByb3ApKSkgfHwgKGlzQ0UgPSBub2RlLm5vZGVOYW1lLmluY2x1ZGVzKFwiLVwiKSB8fCBcImlzXCIgaW4gcHJvcHMpKSB7XG4gICAgaWYgKGZvcmNlUHJvcCkge1xuICAgICAgcHJvcCA9IHByb3Auc2xpY2UoNSk7XG4gICAgICBpc1Byb3AgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJvcCA9PT0gXCJjbGFzc1wiIHx8IHByb3AgPT09IFwiY2xhc3NOYW1lXCIpIGNsYXNzTmFtZShub2RlLCB2YWx1ZSk7XG4gICAgZWxzZSBpZiAoaXNDRSAmJiAhaXNQcm9wICYmICFpc0NoaWxkUHJvcCkgbm9kZVt0b1Byb3BlcnR5TmFtZShwcm9wKV0gPSB2YWx1ZTtcbiAgICBlbHNlIG5vZGVbcHJvcEFsaWFzIHx8IHByb3BdID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbnMgPSBpc1NWRyAmJiBwcm9wLmluZGV4T2YoXCI6XCIpID4gLTEgJiYgU1ZHTmFtZXNwYWNlW3Byb3Auc3BsaXQoXCI6XCIpWzBdXTtcbiAgICBpZiAobnMpIHNldEF0dHJpYnV0ZU5TKG5vZGUsIG5zLCBwcm9wLCB2YWx1ZSk7XG4gICAgZWxzZSBzZXRBdHRyaWJ1dGUobm9kZSwgQWxpYXNlc1twcm9wXSB8fCBwcm9wLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZXZlbnRIYW5kbGVyKGUyKSB7XG4gIGxldCBub2RlID0gZTIudGFyZ2V0O1xuICBjb25zdCBrZXkgPSBgJCQke2UyLnR5cGV9YDtcbiAgY29uc3Qgb3JpVGFyZ2V0ID0gZTIudGFyZ2V0O1xuICBjb25zdCBvcmlDdXJyZW50VGFyZ2V0ID0gZTIuY3VycmVudFRhcmdldDtcbiAgY29uc3QgcmV0YXJnZXQgPSAodmFsdWUpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlMiwgXCJ0YXJnZXRcIiwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZVxuICB9KTtcbiAgY29uc3QgaGFuZGxlTm9kZSA9ICgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVyID0gbm9kZVtrZXldO1xuICAgIGlmIChoYW5kbGVyICYmICFub2RlLmRpc2FibGVkKSB7XG4gICAgICBjb25zdCBkYXRhID0gbm9kZVtgJHtrZXl9RGF0YWBdO1xuICAgICAgZGF0YSAhPT0gdm9pZCAwID8gaGFuZGxlci5jYWxsKG5vZGUsIGRhdGEsIGUyKSA6IGhhbmRsZXIuY2FsbChub2RlLCBlMik7XG4gICAgICBpZiAoZTIuY2FuY2VsQnViYmxlKSByZXR1cm47XG4gICAgfVxuICAgIG5vZGUuaG9zdCAmJiB0eXBlb2Ygbm9kZS5ob3N0ICE9PSBcInN0cmluZ1wiICYmICFub2RlLmhvc3QuXyRob3N0ICYmIG5vZGUuY29udGFpbnMoZTIudGFyZ2V0KSAmJiByZXRhcmdldChub2RlLmhvc3QpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBjb25zdCB3YWxrVXBUcmVlID0gKCkgPT4ge1xuICAgIHdoaWxlIChoYW5kbGVOb2RlKCkgJiYgKG5vZGUgPSBub2RlLl8kaG9zdCB8fCBub2RlLnBhcmVudE5vZGUgfHwgbm9kZS5ob3N0KSkgO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZTIsIFwiY3VycmVudFRhcmdldFwiLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBub2RlIHx8IGRvY3VtZW50O1xuICAgIH1cbiAgfSk7XG4gIGlmIChlMi5jb21wb3NlZFBhdGgpIHtcbiAgICBjb25zdCBwYXRoID0gZTIuY29tcG9zZWRQYXRoKCk7XG4gICAgcmV0YXJnZXQocGF0aFswXSk7XG4gICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHBhdGgubGVuZ3RoIC0gMjsgaTIrKykge1xuICAgICAgbm9kZSA9IHBhdGhbaTJdO1xuICAgICAgaWYgKCFoYW5kbGVOb2RlKCkpIGJyZWFrO1xuICAgICAgaWYgKG5vZGUuXyRob3N0KSB7XG4gICAgICAgIG5vZGUgPSBub2RlLl8kaG9zdDtcbiAgICAgICAgd2Fsa1VwVHJlZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLnBhcmVudE5vZGUgPT09IG9yaUN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Ugd2Fsa1VwVHJlZSgpO1xuICByZXRhcmdldChvcmlUYXJnZXQpO1xufVxuZnVuY3Rpb24gaW5zZXJ0RXhwcmVzc2lvbihwYXJlbnQsIHZhbHVlLCBjdXJyZW50LCBtYXJrZXIsIHVud3JhcEFycmF5KSB7XG4gIHdoaWxlICh0eXBlb2YgY3VycmVudCA9PT0gXCJmdW5jdGlvblwiKSBjdXJyZW50ID0gY3VycmVudCgpO1xuICBpZiAodmFsdWUgPT09IGN1cnJlbnQpIHJldHVybiBjdXJyZW50O1xuICBjb25zdCB0MiA9IHR5cGVvZiB2YWx1ZSwgbXVsdGkgPSBtYXJrZXIgIT09IHZvaWQgMDtcbiAgcGFyZW50ID0gbXVsdGkgJiYgY3VycmVudFswXSAmJiBjdXJyZW50WzBdLnBhcmVudE5vZGUgfHwgcGFyZW50O1xuICBpZiAodDIgPT09IFwic3RyaW5nXCIgfHwgdDIgPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAodDIgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gY3VycmVudCkgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGlmIChtdWx0aSkge1xuICAgICAgbGV0IG5vZGUgPSBjdXJyZW50WzBdO1xuICAgICAgaWYgKG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICBub2RlLmRhdGEgIT09IHZhbHVlICYmIChub2RlLmRhdGEgPSB2YWx1ZSk7XG4gICAgICB9IGVsc2Ugbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKTtcbiAgICAgIGN1cnJlbnQgPSBjbGVhbkNoaWxkcmVuKHBhcmVudCwgY3VycmVudCwgbWFya2VyLCBub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGN1cnJlbnQgIT09IFwiXCIgJiYgdHlwZW9mIGN1cnJlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY3VycmVudCA9IHBhcmVudC5maXJzdENoaWxkLmRhdGEgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBjdXJyZW50ID0gcGFyZW50LnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwgfHwgdDIgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgY3VycmVudCA9IGNsZWFuQ2hpbGRyZW4ocGFyZW50LCBjdXJyZW50LCBtYXJrZXIpO1xuICB9IGVsc2UgaWYgKHQyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgbGV0IHYgPSB2YWx1ZSgpO1xuICAgICAgd2hpbGUgKHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCIpIHYgPSB2KCk7XG4gICAgICBjdXJyZW50ID0gaW5zZXJ0RXhwcmVzc2lvbihwYXJlbnQsIHYsIGN1cnJlbnQsIG1hcmtlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IGN1cnJlbnQ7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCBhcnJheSA9IFtdO1xuICAgIGNvbnN0IGN1cnJlbnRBcnJheSA9IGN1cnJlbnQgJiYgQXJyYXkuaXNBcnJheShjdXJyZW50KTtcbiAgICBpZiAobm9ybWFsaXplSW5jb21pbmdBcnJheShhcnJheSwgdmFsdWUsIGN1cnJlbnQsIHVud3JhcEFycmF5KSkge1xuICAgICAgY3JlYXRlUmVuZGVyRWZmZWN0KCgpID0+IGN1cnJlbnQgPSBpbnNlcnRFeHByZXNzaW9uKHBhcmVudCwgYXJyYXksIGN1cnJlbnQsIG1hcmtlciwgdHJ1ZSkpO1xuICAgICAgcmV0dXJuICgpID0+IGN1cnJlbnQ7XG4gICAgfVxuICAgIGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIGN1cnJlbnQgPSBjbGVhbkNoaWxkcmVuKHBhcmVudCwgY3VycmVudCwgbWFya2VyKTtcbiAgICAgIGlmIChtdWx0aSkgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50QXJyYXkpIHtcbiAgICAgIGlmIChjdXJyZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhcHBlbmROb2RlcyhwYXJlbnQsIGFycmF5LCBtYXJrZXIpO1xuICAgICAgfSBlbHNlIHJlY29uY2lsZUFycmF5cyhwYXJlbnQsIGN1cnJlbnQsIGFycmF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudCAmJiBjbGVhbkNoaWxkcmVuKHBhcmVudCk7XG4gICAgICBhcHBlbmROb2RlcyhwYXJlbnQsIGFycmF5KTtcbiAgICB9XG4gICAgY3VycmVudCA9IGFycmF5O1xuICB9IGVsc2UgaWYgKHZhbHVlLm5vZGVUeXBlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICAgIGlmIChtdWx0aSkgcmV0dXJuIGN1cnJlbnQgPSBjbGVhbkNoaWxkcmVuKHBhcmVudCwgY3VycmVudCwgbWFya2VyLCB2YWx1ZSk7XG4gICAgICBjbGVhbkNoaWxkcmVuKHBhcmVudCwgY3VycmVudCwgbnVsbCwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudCA9PSBudWxsIHx8IGN1cnJlbnQgPT09IFwiXCIgfHwgIXBhcmVudC5maXJzdENoaWxkKSB7XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQodmFsdWUpO1xuICAgIH0gZWxzZSBwYXJlbnQucmVwbGFjZUNoaWxkKHZhbHVlLCBwYXJlbnQuZmlyc3RDaGlsZCk7XG4gICAgY3VycmVudCA9IHZhbHVlO1xuICB9IGVsc2UgO1xuICByZXR1cm4gY3VycmVudDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUluY29taW5nQXJyYXkobm9ybWFsaXplZCwgYXJyYXksIGN1cnJlbnQsIHVud3JhcDIpIHtcbiAgbGV0IGR5bmFtaWMgPSBmYWxzZTtcbiAgZm9yIChsZXQgaTIgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkyIDwgbGVuOyBpMisrKSB7XG4gICAgbGV0IGl0ZW0gPSBhcnJheVtpMl0sIHByZXYgPSBjdXJyZW50ICYmIGN1cnJlbnRbbm9ybWFsaXplZC5sZW5ndGhdLCB0MjtcbiAgICBpZiAoaXRlbSA9PSBudWxsIHx8IGl0ZW0gPT09IHRydWUgfHwgaXRlbSA9PT0gZmFsc2UpIDtcbiAgICBlbHNlIGlmICgodDIgPSB0eXBlb2YgaXRlbSkgPT09IFwib2JqZWN0XCIgJiYgaXRlbS5ub2RlVHlwZSkge1xuICAgICAgbm9ybWFsaXplZC5wdXNoKGl0ZW0pO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgZHluYW1pYyA9IG5vcm1hbGl6ZUluY29taW5nQXJyYXkobm9ybWFsaXplZCwgaXRlbSwgcHJldikgfHwgZHluYW1pYztcbiAgICB9IGVsc2UgaWYgKHQyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmICh1bndyYXAyKSB7XG4gICAgICAgIHdoaWxlICh0eXBlb2YgaXRlbSA9PT0gXCJmdW5jdGlvblwiKSBpdGVtID0gaXRlbSgpO1xuICAgICAgICBkeW5hbWljID0gbm9ybWFsaXplSW5jb21pbmdBcnJheShub3JtYWxpemVkLCBBcnJheS5pc0FycmF5KGl0ZW0pID8gaXRlbSA6IFtpdGVtXSwgQXJyYXkuaXNBcnJheShwcmV2KSA/IHByZXYgOiBbcHJldl0pIHx8IGR5bmFtaWM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtYWxpemVkLnB1c2goaXRlbSk7XG4gICAgICAgIGR5bmFtaWMgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IFN0cmluZyhpdGVtKTtcbiAgICAgIGlmIChwcmV2ICYmIHByZXYubm9kZVR5cGUgPT09IDMgJiYgcHJldi5kYXRhID09PSB2YWx1ZSkgbm9ybWFsaXplZC5wdXNoKHByZXYpO1xuICAgICAgZWxzZSBub3JtYWxpemVkLnB1c2goZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGR5bmFtaWM7XG59XG5mdW5jdGlvbiBhcHBlbmROb2RlcyhwYXJlbnQsIGFycmF5LCBtYXJrZXIgPSBudWxsKSB7XG4gIGZvciAobGV0IGkyID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpMiA8IGxlbjsgaTIrKykgcGFyZW50Lmluc2VydEJlZm9yZShhcnJheVtpMl0sIG1hcmtlcik7XG59XG5mdW5jdGlvbiBjbGVhbkNoaWxkcmVuKHBhcmVudCwgY3VycmVudCwgbWFya2VyLCByZXBsYWNlbWVudCkge1xuICBpZiAobWFya2VyID09PSB2b2lkIDApIHJldHVybiBwYXJlbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuICBjb25zdCBub2RlID0gcmVwbGFjZW1lbnQgfHwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7XG4gIGlmIChjdXJyZW50Lmxlbmd0aCkge1xuICAgIGxldCBpbnNlcnRlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkyID0gY3VycmVudC5sZW5ndGggLSAxOyBpMiA+PSAwOyBpMi0tKSB7XG4gICAgICBjb25zdCBlbCA9IGN1cnJlbnRbaTJdO1xuICAgICAgaWYgKG5vZGUgIT09IGVsKSB7XG4gICAgICAgIGNvbnN0IGlzUGFyZW50ID0gZWwucGFyZW50Tm9kZSA9PT0gcGFyZW50O1xuICAgICAgICBpZiAoIWluc2VydGVkICYmICFpMikgaXNQYXJlbnQgPyBwYXJlbnQucmVwbGFjZUNoaWxkKG5vZGUsIGVsKSA6IHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgbWFya2VyKTtcbiAgICAgICAgZWxzZSBpc1BhcmVudCAmJiBlbC5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSBpbnNlcnRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBtYXJrZXIpO1xuICByZXR1cm4gW25vZGVdO1xufVxuY29uc3QgU1ZHX05BTUVTUEFDRSA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSwgaXNTVkcgPSBmYWxzZSkge1xuICByZXR1cm4gaXNTVkcgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05BTUVTUEFDRSwgdGFnTmFtZSkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xufVxuZnVuY3Rpb24gUG9ydGFsKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICB1c2VTaGFkb3dcbiAgfSA9IHByb3BzLCBtYXJrZXIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKSwgbW91bnQgPSAoKSA9PiBwcm9wcy5tb3VudCB8fCBkb2N1bWVudC5ib2R5LCBvd25lciA9IGdldE93bmVyKCk7XG4gIGxldCBjb250ZW50O1xuICBjcmVhdGVFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnRlbnQgfHwgKGNvbnRlbnQgPSBydW5XaXRoT3duZXIob3duZXIsICgpID0+IGNyZWF0ZU1lbW8oKCkgPT4gcHJvcHMuY2hpbGRyZW4pKSk7XG4gICAgY29uc3QgZWwgPSBtb3VudCgpO1xuICAgIGlmIChlbCBpbnN0YW5jZW9mIEhUTUxIZWFkRWxlbWVudCkge1xuICAgICAgY29uc3QgW2NsZWFuLCBzZXRDbGVhbl0gPSBjcmVhdGVTaWduYWwoZmFsc2UpO1xuICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHNldENsZWFuKHRydWUpO1xuICAgICAgY3JlYXRlUm9vdCgoZGlzcG9zZTIpID0+IGluc2VydChlbCwgKCkgPT4gIWNsZWFuKCkgPyBjb250ZW50KCkgOiBkaXNwb3NlMigpLCBudWxsKSk7XG4gICAgICBvbkNsZWFudXAoY2xlYW51cCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQocHJvcHMuaXNTVkcgPyBcImdcIiA6IFwiZGl2XCIsIHByb3BzLmlzU1ZHKSwgcmVuZGVyUm9vdCA9IHVzZVNoYWRvdyAmJiBjb250YWluZXIuYXR0YWNoU2hhZG93ID8gY29udGFpbmVyLmF0dGFjaFNoYWRvdyh7XG4gICAgICAgIG1vZGU6IFwib3BlblwiXG4gICAgICB9KSA6IGNvbnRhaW5lcjtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb250YWluZXIsIFwiXyRob3N0XCIsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBtYXJrZXIucGFyZW50Tm9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGluc2VydChyZW5kZXJSb290LCBjb250ZW50KTtcbiAgICAgIGVsLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICBwcm9wcy5yZWYgJiYgcHJvcHMucmVmKGNvbnRhaW5lcik7XG4gICAgICBvbkNsZWFudXAoKCkgPT4gZWwucmVtb3ZlQ2hpbGQoY29udGFpbmVyKSk7XG4gICAgfVxuICB9LCB2b2lkIDAsIHtcbiAgICByZW5kZXI6IHRydWVcbiAgfSk7XG4gIHJldHVybiBtYXJrZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVEeW5hbWljKGNvbXBvbmVudCwgcHJvcHMpIHtcbiAgY29uc3QgY2FjaGVkID0gY3JlYXRlTWVtbyhjb21wb25lbnQpO1xuICByZXR1cm4gY3JlYXRlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgY29tcG9uZW50MiA9IGNhY2hlZCgpO1xuICAgIHN3aXRjaCAodHlwZW9mIGNvbXBvbmVudDIpIHtcbiAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICByZXR1cm4gdW50cmFjaygoKSA9PiBjb21wb25lbnQyKHByb3BzKSk7XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIGNvbnN0IGlzU3ZnID0gU1ZHRWxlbWVudHMuaGFzKGNvbXBvbmVudDIpO1xuICAgICAgICBjb25zdCBlbCA9IGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50MiwgaXNTdmcpO1xuICAgICAgICBzcHJlYWQoZWwsIHByb3BzLCBpc1N2Zyk7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gRHluYW1pYyhwcm9wcykge1xuICBjb25zdCBbLCBvdGhlcnNdID0gc3BsaXRQcm9wcyhwcm9wcywgW1wiY29tcG9uZW50XCJdKTtcbiAgcmV0dXJuIGNyZWF0ZUR5bmFtaWMoKCkgPT4gcHJvcHMuY29tcG9uZW50LCBvdGhlcnMpO1xufVxudmFyIFRIRU1FID0gLyogQF9fUFVSRV9fICovICgoVEhFTUUyKSA9PiB7XG4gIFRIRU1FMltcIkRBUktcIl0gPSBcIkRBUktcIjtcbiAgVEhFTUUyW1wiTElHSFRcIl0gPSBcIkxJR0hUXCI7XG4gIHJldHVybiBUSEVNRTI7XG59KShUSEVNRSB8fCB7fSk7XG5sZXQgZSA9IHsgZGF0YTogXCJcIiB9LCB0ID0gKHQyKSA9PiBcIm9iamVjdFwiID09IHR5cGVvZiB3aW5kb3cgPyAoKHQyID8gdDIucXVlcnlTZWxlY3RvcihcIiNfZ29vYmVyXCIpIDogd2luZG93Ll9nb29iZXIpIHx8IE9iamVjdC5hc3NpZ24oKHQyIHx8IGRvY3VtZW50LmhlYWQpLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKSksIHsgaW5uZXJIVE1MOiBcIiBcIiwgaWQ6IFwiX2dvb2JlclwiIH0pKS5maXJzdENoaWxkIDogdDIgfHwgZSwgbCA9IC8oPzooW1xcdTAwODAtXFx1RkZGRlxcdy0lQF0rKSAqOj8gKihbXns7XSs/KTt8KFteO317XSo/KSAqeyl8KH1cXHMqKS9nLCBhID0gL1xcL1xcKlteXSo/XFwqXFwvfCAgKy9nLCBuID0gL1xcbisvZywgbyA9IChlMiwgdDIpID0+IHtcbiAgbGV0IHIgPSBcIlwiLCBsMiA9IFwiXCIsIGEyID0gXCJcIjtcbiAgZm9yIChsZXQgbjIgaW4gZTIpIHtcbiAgICBsZXQgYzIgPSBlMltuMl07XG4gICAgXCJAXCIgPT0gbjJbMF0gPyBcImlcIiA9PSBuMlsxXSA/IHIgPSBuMiArIFwiIFwiICsgYzIgKyBcIjtcIiA6IGwyICs9IFwiZlwiID09IG4yWzFdID8gbyhjMiwgbjIpIDogbjIgKyBcIntcIiArIG8oYzIsIFwia1wiID09IG4yWzFdID8gXCJcIiA6IHQyKSArIFwifVwiIDogXCJvYmplY3RcIiA9PSB0eXBlb2YgYzIgPyBsMiArPSBvKGMyLCB0MiA/IHQyLnJlcGxhY2UoLyhbXixdKSsvZywgKGUzKSA9PiBuMi5yZXBsYWNlKC8oXjouKil8KFteLF0pKy9nLCAodDMpID0+IC8mLy50ZXN0KHQzKSA/IHQzLnJlcGxhY2UoLyYvZywgZTMpIDogZTMgPyBlMyArIFwiIFwiICsgdDMgOiB0MykpIDogbjIpIDogbnVsbCAhPSBjMiAmJiAobjIgPSAvXi0tLy50ZXN0KG4yKSA/IG4yIDogbjIucmVwbGFjZSgvW0EtWl0vZywgXCItJCZcIikudG9Mb3dlckNhc2UoKSwgYTIgKz0gby5wID8gby5wKG4yLCBjMikgOiBuMiArIFwiOlwiICsgYzIgKyBcIjtcIik7XG4gIH1cbiAgcmV0dXJuIHIgKyAodDIgJiYgYTIgPyB0MiArIFwie1wiICsgYTIgKyBcIn1cIiA6IGEyKSArIGwyO1xufSwgYyA9IHt9LCBzID0gKGUyKSA9PiB7XG4gIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBlMikge1xuICAgIGxldCB0MiA9IFwiXCI7XG4gICAgZm9yIChsZXQgciBpbiBlMikgdDIgKz0gciArIHMoZTJbcl0pO1xuICAgIHJldHVybiB0MjtcbiAgfVxuICByZXR1cm4gZTI7XG59LCBpID0gKGUyLCB0MiwgciwgaTIsIHAyKSA9PiB7XG4gIGxldCB1MiA9IHMoZTIpLCBkID0gY1t1Ml0gfHwgKGNbdTJdID0gKChlMykgPT4ge1xuICAgIGxldCB0MyA9IDAsIHIyID0gMTE7XG4gICAgZm9yICg7IHQzIDwgZTMubGVuZ3RoOyApIHIyID0gMTAxICogcjIgKyBlMy5jaGFyQ29kZUF0KHQzKyspID4+PiAwO1xuICAgIHJldHVybiBcImdvXCIgKyByMjtcbiAgfSkodTIpKTtcbiAgaWYgKCFjW2RdKSB7XG4gICAgbGV0IHQzID0gdTIgIT09IGUyID8gZTIgOiAoKGUzKSA9PiB7XG4gICAgICBsZXQgdDQsIHIyLCBvMiA9IFt7fV07XG4gICAgICBmb3IgKDsgdDQgPSBsLmV4ZWMoZTMucmVwbGFjZShhLCBcIlwiKSk7ICkgdDRbNF0gPyBvMi5zaGlmdCgpIDogdDRbM10gPyAocjIgPSB0NFszXS5yZXBsYWNlKG4sIFwiIFwiKS50cmltKCksIG8yLnVuc2hpZnQobzJbMF1bcjJdID0gbzJbMF1bcjJdIHx8IHt9KSkgOiBvMlswXVt0NFsxXV0gPSB0NFsyXS5yZXBsYWNlKG4sIFwiIFwiKS50cmltKCk7XG4gICAgICByZXR1cm4gbzJbMF07XG4gICAgfSkoZTIpO1xuICAgIGNbZF0gPSBvKHAyID8geyBbXCJAa2V5ZnJhbWVzIFwiICsgZF06IHQzIH0gOiB0MywgciA/IFwiXCIgOiBcIi5cIiArIGQpO1xuICB9XG4gIGxldCBmID0gciAmJiBjLmcgPyBjLmcgOiBudWxsO1xuICByZXR1cm4gciAmJiAoYy5nID0gY1tkXSksICgoZTMsIHQzLCByMiwgbDIpID0+IHtcbiAgICBsMiA/IHQzLmRhdGEgPSB0My5kYXRhLnJlcGxhY2UobDIsIGUzKSA6IC0xID09PSB0My5kYXRhLmluZGV4T2YoZTMpICYmICh0My5kYXRhID0gcjIgPyBlMyArIHQzLmRhdGEgOiB0My5kYXRhICsgZTMpO1xuICB9KShjW2RdLCB0MiwgaTIsIGYpLCBkO1xufSwgcCA9IChlMiwgdDIsIHIpID0+IGUyLnJlZHVjZSgoZTMsIGwyLCBhMikgPT4ge1xuICBsZXQgbjIgPSB0MlthMl07XG4gIGlmIChuMiAmJiBuMi5jYWxsKSB7XG4gICAgbGV0IGU0ID0gbjIociksIHQzID0gZTQgJiYgZTQucHJvcHMgJiYgZTQucHJvcHMuY2xhc3NOYW1lIHx8IC9eZ28vLnRlc3QoZTQpICYmIGU0O1xuICAgIG4yID0gdDMgPyBcIi5cIiArIHQzIDogZTQgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgZTQgPyBlNC5wcm9wcyA/IFwiXCIgOiBvKGU0LCBcIlwiKSA6IGZhbHNlID09PSBlNCA/IFwiXCIgOiBlNDtcbiAgfVxuICByZXR1cm4gZTMgKyBsMiArIChudWxsID09IG4yID8gXCJcIiA6IG4yKTtcbn0sIFwiXCIpO1xuZnVuY3Rpb24gdShlMikge1xuICBsZXQgciA9IHRoaXMgfHwge30sIGwyID0gZTIuY2FsbCA/IGUyKHIucCkgOiBlMjtcbiAgcmV0dXJuIGkobDIudW5zaGlmdCA/IGwyLnJhdyA/IHAobDIsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgci5wKSA6IGwyLnJlZHVjZSgoZTMsIHQyKSA9PiBPYmplY3QuYXNzaWduKGUzLCB0MiAmJiB0Mi5jYWxsID8gdDIoci5wKSA6IHQyKSwge30pIDogbDIsIHQoci50YXJnZXQpLCByLmcsIHIubywgci5rKTtcbn1cbnUuYmluZCh7IGc6IDEgfSk7XG5sZXQgaCA9IHUuYmluZCh7IGs6IDEgfSk7XG5jb25zdCBUaGVtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KCk7XG5mdW5jdGlvbiBUaGVtZVByb3ZpZGVyKHByb3BzKSB7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoVGhlbWVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHByb3BzLnRoZW1lLFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdXNlVGhlbWUoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KFRoZW1lQ29udGV4dCk7XG59XG5mdW5jdGlvbiBtYWtlU3R5bGVkKHRhZykge1xuICBsZXQgX2N0eCA9IHRoaXMgfHwge307XG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IFN0eWxlZCA9IChwcm9wcykgPT4ge1xuICAgICAgY29uc3QgdGhlbWUgPSB1c2VDb250ZXh0KFRoZW1lQ29udGV4dCk7XG4gICAgICBjb25zdCB3aXRoVGhlbWUgPSBtZXJnZVByb3BzKHByb3BzLCB7IHRoZW1lIH0pO1xuICAgICAgY29uc3QgY2xvbmUgPSBtZXJnZVByb3BzKHdpdGhUaGVtZSwge1xuICAgICAgICBnZXQgY2xhc3MoKSB7XG4gICAgICAgICAgY29uc3QgcENsYXNzID0gd2l0aFRoZW1lLmNsYXNzLCBhcHBlbmQgPSBcImNsYXNzXCIgaW4gd2l0aFRoZW1lICYmIC9eZ29bMC05XSsvLnRlc3QocENsYXNzKTtcbiAgICAgICAgICBsZXQgY2xhc3NOYW1lMiA9IHUuYXBwbHkoXG4gICAgICAgICAgICB7IHRhcmdldDogX2N0eC50YXJnZXQsIG86IGFwcGVuZCwgcDogd2l0aFRoZW1lLCBnOiBfY3R4LmcgfSxcbiAgICAgICAgICAgIGFyZ3NcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBbcENsYXNzLCBjbGFzc05hbWUyXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgW2xvY2FsLCBuZXdQcm9wc10gPSBzcGxpdFByb3BzKGNsb25lLCBbXCJhc1wiLCBcInRoZW1lXCJdKTtcbiAgICAgIGNvbnN0IGh0bWxQcm9wcyA9IG5ld1Byb3BzO1xuICAgICAgY29uc3QgY3JlYXRlVGFnID0gbG9jYWwuYXMgfHwgdGFnO1xuICAgICAgbGV0IGVsO1xuICAgICAgaWYgKHR5cGVvZiBjcmVhdGVUYWcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBlbCA9IGNyZWF0ZVRhZyhodG1sUHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmIChfY3R4LmcgPT0gMSkge1xuICAgICAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGNyZWF0ZVRhZyk7XG4gICAgICAgICAgICBzcHJlYWQoZWwsIGh0bWxQcm9wcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsID0gRHluYW1pYyhtZXJnZVByb3BzKHsgY29tcG9uZW50OiBjcmVhdGVUYWcgfSwgaHRtbFByb3BzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZWw7XG4gICAgfTtcbiAgICBTdHlsZWQuY2xhc3MgPSAocHJvcHMpID0+IHtcbiAgICAgIHJldHVybiB1bnRyYWNrKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHUuYXBwbHkoeyB0YXJnZXQ6IF9jdHgudGFyZ2V0LCBwOiBwcm9wcywgZzogX2N0eC5nIH0sIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3R5bGVkO1xuICB9O1xufVxuY29uc3Qgc3R5bGVkID0gbmV3IFByb3h5KG1ha2VTdHlsZWQsIHtcbiAgZ2V0KHRhcmdldCwgdGFnKSB7XG4gICAgcmV0dXJuIHRhcmdldCh0YWcpO1xuICB9XG59KTtcbmZ1bmN0aW9uIGNyZWF0ZUdsb2JhbFN0eWxlcygpIHtcbiAgY29uc3QgZm4gPSBtYWtlU3R5bGVkLmNhbGwoeyBnOiAxIH0sIFwiZGl2XCIpLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIHJldHVybiBmdW5jdGlvbiBHbG9iYWxTdHlsZXMyKHByb3BzKSB7XG4gICAgZm4ocHJvcHMpO1xuICAgIHJldHVybiBudWxsO1xuICB9O1xufVxuY29uc3QgZ2xvYmFsU3R5bGVzVGFnID0gXCJ0Yy1yb290XCI7XG5jb25zdCBkaXNhYmxlU2Nyb2xsQ2xhc3MgPSBcInRjLWRpc2FibGUtc2Nyb2xsXCI7XG5jb25zdCB1c2luZ01vdXNlQ2xhc3MgPSBcInRjLXVzaW5nLW1vdXNlXCI7XG5jb25zdCBHbG9iYWxTdHlsZXMgPSAoKSA9PiB7XG4gIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAoKSA9PiBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQodXNpbmdNb3VzZUNsYXNzKSk7XG4gIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gXCJUYWJcIikge1xuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKHVzaW5nTW91c2VDbGFzcyk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgU3R5bGVzID0gY3JlYXRlR2xvYmFsU3R5bGVzYFxuICAgICR7Z2xvYmFsU3R5bGVzVGFnfSAqIHtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICBcbiAgICAgICAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgJ1JvYm90bycsICdIZWx2ZXRpY2EgTmV1ZScsIEFyaWFsLCBUYWhvbWEsIFZlcmRhbmEsIHNhbnMtc2VyaWY7XG4gICAgICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xuICAgICAgICAtbW96LW9zeC1mb250LXNtb290aGluZzogZ3JheXNjYWxlOyAgICAgICAgXG4gICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgfVxuICAgIFxuICAgICR7Z2xvYmFsU3R5bGVzVGFnfSBpbWcge1xuICAgICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTtcbiAgICB9ICAgXG4gXG4gICAgJHtnbG9iYWxTdHlsZXNUYWd9ICo6Zm9jdXMge1xuICAgICAgICBvdXRsaW5lOiAjMDhmIGF1dG8gMnB4O1xuICAgIH1cbiAgICBcbiAgICAke2dsb2JhbFN0eWxlc1RhZ30gbGkge1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIH1cbiAgICBcbiAgICAke2dsb2JhbFN0eWxlc1RhZ30gYnV0dG9uIHtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICB9XG4gICAgXG4gICAgYm9keS4ke2Rpc2FibGVTY3JvbGxDbGFzc30ge1xuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7IFxuICAgICAgICBvdmVyZmxvdy15OiBzY3JvbGw7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgIH1cbiAgICBcbiAgICBib2R5LiR7dXNpbmdNb3VzZUNsYXNzfSAke2dsb2JhbFN0eWxlc1RhZ30gKjpmb2N1cyB7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgfVxuYDtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChTdHlsZXMsIHt9KTtcbn07XG5mdW5jdGlvbiBoZXhUb1JnYihoZXgpIHtcbiAgaWYgKGhleFswXSA9PT0gXCIjXCIpIHtcbiAgICBoZXggPSBoZXguc2xpY2UoMSk7XG4gIH1cbiAgY29uc3QgYmlnaW50ID0gcGFyc2VJbnQoaGV4LCAxNik7XG4gIGNvbnN0IHIgPSBiaWdpbnQgPj4gMTYgJiAyNTU7XG4gIGNvbnN0IGcgPSBiaWdpbnQgPj4gOCAmIDI1NTtcbiAgY29uc3QgYiA9IGJpZ2ludCAmIDI1NTtcbiAgcmV0dXJuIFtyLCBnLCBiXS5qb2luKFwiLFwiKTtcbn1cbmZ1bmN0aW9uIHJnYmEoY29sb3IsIG9wYWNpdHkpIHtcbiAgaWYgKGNvbG9yWzBdID09PSBcIiNcIikge1xuICAgIGNvbG9yID0gaGV4VG9SZ2IoY29sb3IpO1xuICB9XG4gIHJldHVybiBgcmdiYSgke2NvbG9yfSwgJHtvcGFjaXR5fSlgO1xufVxuZnVuY3Rpb24gdG9QeCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKSArIFwicHhcIjtcbn1cbmNsYXNzIEluTWVtb3J5U3RvcmFnZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RvcmFnZSA9IHt9O1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcbiAgICBpZiAoIUluTWVtb3J5U3RvcmFnZS5pbnN0YW5jZSkge1xuICAgICAgSW5NZW1vcnlTdG9yYWdlLmluc3RhbmNlID0gbmV3IEluTWVtb3J5U3RvcmFnZSgpO1xuICAgIH1cbiAgICByZXR1cm4gSW5NZW1vcnlTdG9yYWdlLmluc3RhbmNlO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc3RvcmFnZSkubGVuZ3RoO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuc3RvcmFnZSA9IHt9O1xuICB9XG4gIGdldEl0ZW0oa2V5KSB7XG4gICAgdmFyIF9hMjtcbiAgICByZXR1cm4gKF9hMiA9IHRoaXMuc3RvcmFnZVtrZXldKSAhPSBudWxsID8gX2EyIDogbnVsbDtcbiAgfVxuICBrZXkoaW5kZXgpIHtcbiAgICB2YXIgX2EyO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLnN0b3JhZ2UpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0ga2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKF9hMiA9IGtleXNbaW5kZXhdKSAhPSBudWxsID8gX2EyIDogbnVsbDtcbiAgfVxuICByZW1vdmVJdGVtKGtleSkge1xuICAgIGRlbGV0ZSB0aGlzLnN0b3JhZ2Vba2V5XTtcbiAgfVxuICBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLnN0b3JhZ2Vba2V5XSA9IHZhbHVlO1xuICB9XG59XG5jbGFzcyBUb25Db25uZWN0VUlFcnJvciBleHRlbmRzIFRvbkNvbm5lY3RFcnJvciB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgVG9uQ29ubmVjdFVJRXJyb3IucHJvdG90eXBlKTtcbiAgfVxufVxuZnVuY3Rpb24gbG9nRGVidWcoLi4uYXJncykge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUuZGVidWcoXCJbVE9OX0NPTk5FQ1RfVUldXCIsIC4uLmFyZ3MpO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBsb2dFcnJvciguLi5hcmdzKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5lcnJvcihcIltUT05fQ09OTkVDVF9VSV1cIiwgLi4uYXJncyk7XG4gICAgfSBjYXRjaCAoZTIpIHtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGxvZ1dhcm5pbmcoLi4uYXJncykge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUud2FybihcIltUT05fQ09OTkVDVF9VSV1cIiwgLi4uYXJncyk7XG4gICAgfSBjYXRjaCAoZTIpIHtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG9wZW5MaW5rKGhyZWYsIHRhcmdldCA9IFwiX3NlbGZcIikge1xuICBzZXRMYXN0T3BlbmVkTGluayh7IGxpbms6IGhyZWYgfSk7XG4gIGxvZ0RlYnVnKFwib3BlbkxpbmtcIiwgaHJlZiwgdGFyZ2V0KTtcbiAgd2luZG93Lm9wZW4oaHJlZiwgdGFyZ2V0LCBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIik7XG59XG5mdW5jdGlvbiBvcGVuTGlua0JsYW5rKGhyZWYpIHtcbiAgb3BlbkxpbmsoaHJlZiwgXCJfYmxhbmtcIik7XG59XG5mdW5jdGlvbiBvcGVuRGVlcGxpbmtXaXRoRmFsbGJhY2soaHJlZiwgZmFsbGJhY2spIHtcbiAgY29uc3QgZG9GYWxsYmFjayA9ICgpID0+IHtcbiAgICBpZiAoaXNCcm93c2VyKFwic2FmYXJpXCIpIHx8IGlzT1MoXCJhbmRyb2lkXCIpICYmIGlzQnJvd3NlcihcImZpcmVmb3hcIikgfHwgaXNPUyhcIndpbmRvd3NcIikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmFsbGJhY2soKTtcbiAgfTtcbiAgY29uc3QgZmFsbGJhY2tUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBkb0ZhbGxiYWNrKCksIDIwMCk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCAoKSA9PiBjbGVhclRpbWVvdXQoZmFsbGJhY2tUaW1lb3V0KSwgeyBvbmNlOiB0cnVlIH0pO1xuICBvcGVuTGluayhocmVmLCBcIl9zZWxmXCIpO1xufVxuZnVuY3Rpb24gZ2V0U3lzdGVtVGhlbWUoKSB7XG4gIGlmICh3aW5kb3cubWF0Y2hNZWRpYSAmJiB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogbGlnaHQpXCIpLm1hdGNoZXMpIHtcbiAgICByZXR1cm4gVEhFTUUuTElHSFQ7XG4gIH1cbiAgcmV0dXJuIFRIRU1FLkRBUks7XG59XG5mdW5jdGlvbiBzdWJzY3JpYmVUb1RoZW1lQ2hhbmdlKGNhbGxiYWNrKSB7XG4gIGNvbnN0IGhhbmRsZXIgPSAoZXZlbnQpID0+IGNhbGxiYWNrKGV2ZW50Lm1hdGNoZXMgPyBUSEVNRS5EQVJLIDogVEhFTUUuTElHSFQpO1xuICB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaylcIikuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVyKTtcbiAgcmV0dXJuICgpID0+IHdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZXIpO1xufVxuZnVuY3Rpb24gZGlzYWJsZVNjcm9sbCgpIHtcbiAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZG9jdW1lbnQuYm9keS5zdHlsZS50b3AgPSB0b1B4KC1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKTtcbiAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKGRpc2FibGVTY3JvbGxDbGFzcyk7XG59XG5mdW5jdGlvbiBlbmFibGVTY3JvbGwoKSB7XG4gIGlmICghZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuY29udGFpbnMoZGlzYWJsZVNjcm9sbENsYXNzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoZGlzYWJsZVNjcm9sbENsYXNzKTtcbiAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvKHsgdG9wOiAtcGFyc2VGbG9hdChnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHkpLnRvcCkgfSk7XG4gIGRvY3VtZW50LmJvZHkuc3R5bGUudG9wID0gXCJhdXRvXCI7XG59XG5mdW5jdGlvbiBmaXhNb2JpbGVTYWZhcmlBY3RpdmVUcmFuc2l0aW9uKCkge1xuICBpZiAoIWRvY3VtZW50LmJvZHkuaGFzQXR0cmlidXRlKFwib250b3VjaHN0YXJ0XCIpKSB7XG4gICAgZG9jdW1lbnQuYm9keS5zZXRBdHRyaWJ1dGUoXCJvbnRvdWNoc3RhcnRcIiwgXCJcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZmluZVN0eWxlc1Jvb3QoKSB7XG4gIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KFwidGMtcm9vdFwiKSkge1xuICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZShnbG9iYWxTdHlsZXNUYWcsIGNsYXNzIFRjUm9vdEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZU1hY3JvdGFzayhjYWxsYmFjaykge1xuICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIHlpZWxkIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVzb2x2ZSkpO1xuICAgIGNhbGxiYWNrKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlTWFjcm90YXNrQXN5bmMoY2FsbGJhY2spIHtcbiAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICB5aWVsZCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc29sdmUpKTtcbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwcmVsb2FkSW1hZ2VzKGltYWdlcykge1xuICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IGNyZWF0ZU1hY3JvdGFzaygoKSA9PiBwcmVsb2FkSW1hZ2VzKGltYWdlcykpLCB7XG4gICAgICBvbmNlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaW1hZ2VzLmZvckVhY2goKGltZykgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IG5ldyB3aW5kb3cuSW1hZ2UoKTtcbiAgICAgIG5vZGUuc3JjID0gaW1nO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBnZXRXaW5kb3ckMSgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiB0cnlHZXRMb2NhbFN0b3JhZ2UoKSB7XG4gIGlmIChpc0xvY2FsU3RvcmFnZUF2YWlsYWJsZSgpKSB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZTtcbiAgfVxuICBpZiAoaXNOb2RlSnMoKSkge1xuICAgIHRocm93IG5ldyBUb25Db25uZWN0VUlFcnJvcihcbiAgICAgIFwiYGxvY2FsU3RvcmFnZWAgaXMgdW5hdmFpbGFibGUsIGJ1dCBpdCBpcyByZXF1aXJlZCBmb3IgVG9uQ29ubmVjdC4gRm9yIG1vcmUgZGV0YWlscywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90b24tY29ubmVjdC9zZGsvdHJlZS9tYWluL3BhY2thZ2VzL3NkayNpbml0LWNvbm5lY3RvclwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gSW5NZW1vcnlTdG9yYWdlLmdldEluc3RhbmNlKCk7XG59XG5mdW5jdGlvbiBpc0xvY2FsU3RvcmFnZUF2YWlsYWJsZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgfSBjYXRjaCAoZTIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTm9kZUpzKCkge1xuICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy52ZXJzaW9ucyAhPSBudWxsICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSAhPSBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VXNlckFnZW50KCkge1xuICB2YXIgX2EyLCBfYjIsIF9jMjtcbiAgY29uc3QgcmVzdWx0cyA9IG5ldyBVQVBhcnNlcigpLmdldFJlc3VsdCgpO1xuICBjb25zdCBvc05hbWUgPSAoX2EyID0gcmVzdWx0cy5vcy5uYW1lKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGRldmljZU1vZGVsID0gKF9iMiA9IHJlc3VsdHMuZGV2aWNlLm1vZGVsKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLnRvTG93ZXJDYXNlKCk7XG4gIGxldCBvcztcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBkZXZpY2VNb2RlbCA9PT0gXCJpcGFkXCI6XG4gICAgICBvcyA9IFwiaXBhZFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBvc05hbWUgPT09IFwiaW9zXCI6XG4gICAgICBvcyA9IFwiaW9zXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIG9zTmFtZSA9PT0gXCJhbmRyb2lkXCI6XG4gICAgICBvcyA9IFwiYW5kcm9pZFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBvc05hbWUgPT09IFwibWFjIG9zXCI6XG4gICAgICBvcyA9IFwibWFjb3NcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2Ugb3NOYW1lID09PSBcImxpbnV4XCI6XG4gICAgICBvcyA9IFwibGludXhcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgKG9zTmFtZSA9PSBudWxsID8gdm9pZCAwIDogb3NOYW1lLmluY2x1ZGVzKFwid2luZG93c1wiKSk6XG4gICAgICBvcyA9IFwid2luZG93c1wiO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgY29uc3QgYnJvd3Nlck5hbWUgPSAoX2MyID0gcmVzdWx0cy5icm93c2VyLm5hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfYzIudG9Mb3dlckNhc2UoKTtcbiAgbGV0IGJyb3dzZXI7XG4gIHN3aXRjaCAodHJ1ZSkge1xuICAgIGNhc2UgYnJvd3Nlck5hbWUgPT09IFwiY2hyb21lXCI6XG4gICAgICBicm93c2VyID0gXCJjaHJvbWVcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYnJvd3Nlck5hbWUgPT09IFwiZmlyZWZveFwiOlxuICAgICAgYnJvd3NlciA9IFwiZmlyZWZveFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAoYnJvd3Nlck5hbWUgPT0gbnVsbCA/IHZvaWQgMCA6IGJyb3dzZXJOYW1lLmluY2x1ZGVzKFwic2FmYXJpXCIpKTpcbiAgICAgIGJyb3dzZXIgPSBcInNhZmFyaVwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAoYnJvd3Nlck5hbWUgPT0gbnVsbCA/IHZvaWQgMCA6IGJyb3dzZXJOYW1lLmluY2x1ZGVzKFwib3BlcmFcIikpOlxuICAgICAgYnJvd3NlciA9IFwib3BlcmFcIjtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB7XG4gICAgb3MsXG4gICAgYnJvd3NlclxuICB9O1xufVxuZnVuY3Rpb24gaXNPUyguLi5vcykge1xuICByZXR1cm4gb3MuaW5jbHVkZXMoZ2V0VXNlckFnZW50KCkub3MpO1xufVxuZnVuY3Rpb24gaXNCcm93c2VyKC4uLmJyb3dzZXIpIHtcbiAgcmV0dXJuIGJyb3dzZXIuaW5jbHVkZXMoZ2V0VXNlckFnZW50KCkuYnJvd3Nlcik7XG59XG5mdW5jdGlvbiB0b0RlZXBsaW5rKHVuaXZlcnNhbExpbmssIGRlZXBsaW5rKSB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwodW5pdmVyc2FsTGluayk7XG4gIHJldHVybiBkZWVwbGluayArIHVybC5zZWFyY2g7XG59XG5jbGFzcyBXYWxsZXRJbmZvU3RvcmFnZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RvcmFnZUtleSA9IFwidG9uLWNvbm5lY3QtdWlfd2FsbGV0LWluZm9cIjtcbiAgICB0aGlzLmxvY2FsU3RvcmFnZSA9IHRyeUdldExvY2FsU3RvcmFnZSgpO1xuICB9XG4gIHNldFdhbGxldEluZm8od2FsbGV0SW5mbykge1xuICAgIHRoaXMubG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yYWdlS2V5LCBKU09OLnN0cmluZ2lmeSh3YWxsZXRJbmZvKSk7XG4gIH1cbiAgZ2V0V2FsbGV0SW5mbygpIHtcbiAgICBjb25zdCB3YWxsZXRJbmZvU3RyaW5nID0gdGhpcy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICAgIGlmICghd2FsbGV0SW5mb1N0cmluZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnBhcnNlKHdhbGxldEluZm9TdHJpbmcpO1xuICB9XG4gIHJlbW92ZVdhbGxldEluZm8oKSB7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICB9XG59XG5jbGFzcyBQcmVmZXJyZWRXYWxsZXRTdG9yYWdlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdG9yYWdlS2V5ID0gXCJ0b24tY29ubmVjdC11aV9wcmVmZXJyZWQtd2FsbGV0XCI7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UgPSB0cnlHZXRMb2NhbFN0b3JhZ2UoKTtcbiAgfVxuICBzZXRQcmVmZXJyZWRXYWxsZXRBcHBOYW1lKG5hbWUpIHtcbiAgICB0aGlzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmFnZUtleSwgbmFtZSk7XG4gIH1cbiAgZ2V0UHJlZmVycmVkV2FsbGV0QXBwTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXkpIHx8IHZvaWQgMDtcbiAgfVxufVxuY2xhc3MgTGFzdFNlbGVjdGVkV2FsbGV0SW5mb1N0b3JhZ2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0b3JhZ2VLZXkgPSBcInRvbi1jb25uZWN0LXVpX2xhc3Qtc2VsZWN0ZWQtd2FsbGV0LWluZm9cIjtcbiAgICB0aGlzLmxvY2FsU3RvcmFnZSA9IHRyeUdldExvY2FsU3RvcmFnZSgpO1xuICB9XG4gIHNldExhc3RTZWxlY3RlZFdhbGxldEluZm8od2FsbGV0SW5mbykge1xuICAgIHRoaXMubG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yYWdlS2V5LCBKU09OLnN0cmluZ2lmeSh3YWxsZXRJbmZvKSk7XG4gIH1cbiAgZ2V0TGFzdFNlbGVjdGVkV2FsbGV0SW5mbygpIHtcbiAgICBjb25zdCB3YWxsZXRJbmZvU3RyaW5nID0gdGhpcy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICAgIGlmICghd2FsbGV0SW5mb1N0cmluZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnBhcnNlKHdhbGxldEluZm9TdHJpbmcpO1xuICB9XG4gIHJlbW92ZUxhc3RTZWxlY3RlZFdhbGxldEluZm8oKSB7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICB9XG59XG5jb25zdCBbd2FsbGV0c01vZGFsU3RhdGUsIHNldFdhbGxldHNNb2RhbFN0YXRlXSA9IGNyZWF0ZVNpZ25hbCh7XG4gIHN0YXR1czogXCJjbG9zZWRcIixcbiAgY2xvc2VSZWFzb246IG51bGxcbn0pO1xuY29uc3QgZ2V0V2FsbGV0c01vZGFsSXNPcGVuZWQgPSBjcmVhdGVNZW1vKCgpID0+IHdhbGxldHNNb2RhbFN0YXRlKCkuc3RhdHVzID09PSBcIm9wZW5lZFwiKTtcbmNvbnN0IFtzaW5nbGVXYWxsZXRNb2RhbFN0YXRlLCBzZXRTaW5nbGVXYWxsZXRNb2RhbFN0YXRlXSA9IGNyZWF0ZVNpZ25hbCh7XG4gIHN0YXR1czogXCJjbG9zZWRcIixcbiAgY2xvc2VSZWFzb246IG51bGxcbn0pO1xuY29uc3QgZ2V0U2luZ2xlV2FsbGV0TW9kYWxJc09wZW5lZCA9IGNyZWF0ZU1lbW8oXG4gICgpID0+IHNpbmdsZVdhbGxldE1vZGFsU3RhdGUoKS5zdGF0dXMgPT09IFwib3BlbmVkXCJcbik7XG5jb25zdCBnZXRTaW5nbGVXYWxsZXRNb2RhbFdhbGxldEluZm8gPSBjcmVhdGVNZW1vKCgpID0+IHtcbiAgY29uc3Qgc3RhdGUgPSBzaW5nbGVXYWxsZXRNb2RhbFN0YXRlKCk7XG4gIGlmIChzdGF0ZS5zdGF0dXMgPT09IFwib3BlbmVkXCIpIHtcbiAgICByZXR1cm4gc3RhdGUud2FsbGV0SW5mbztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn0pO1xubGV0IGxhc3RTZWxlY3RlZFdhbGxldEluZm9TdG9yYWdlID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IG5ldyBMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvU3RvcmFnZSgpIDogdm9pZCAwO1xuY29uc3QgW2xhc3RTZWxlY3RlZFdhbGxldEluZm8sIF9zZXRMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvXSA9IGNyZWF0ZVNpZ25hbCgobGFzdFNlbGVjdGVkV2FsbGV0SW5mb1N0b3JhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RTZWxlY3RlZFdhbGxldEluZm9TdG9yYWdlLmdldExhc3RTZWxlY3RlZFdhbGxldEluZm8oKSkgfHwgbnVsbCk7XG5jb25zdCBzZXRMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvID0gKHdhbGxldEluZm8pID0+IHtcbiAgaWYgKCFsYXN0U2VsZWN0ZWRXYWxsZXRJbmZvU3RvcmFnZSkge1xuICAgIGxhc3RTZWxlY3RlZFdhbGxldEluZm9TdG9yYWdlID0gbmV3IExhc3RTZWxlY3RlZFdhbGxldEluZm9TdG9yYWdlKCk7XG4gIH1cbiAgaWYgKHdhbGxldEluZm8pIHtcbiAgICBsYXN0U2VsZWN0ZWRXYWxsZXRJbmZvU3RvcmFnZS5zZXRMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvKHdhbGxldEluZm8pO1xuICB9IGVsc2Uge1xuICAgIGxhc3RTZWxlY3RlZFdhbGxldEluZm9TdG9yYWdlLnJlbW92ZUxhc3RTZWxlY3RlZFdhbGxldEluZm8oKTtcbiAgfVxuICBfc2V0TGFzdFNlbGVjdGVkV2FsbGV0SW5mbyh3YWxsZXRJbmZvKTtcbn07XG5jb25zdCBbYWN0aW9uLCBzZXRBY3Rpb25dID0gY3JlYXRlU2lnbmFsKG51bGwpO1xuY29uc3QgW2xhc3RWaXNpYmxlV2FsbGV0c0luZm8sIHNldExhc3RWaXNpYmxlV2FsbGV0c0luZm9dID0gY3JlYXRlU2lnbmFsKHtcbiAgd2FsbGV0c01lbnU6IFwiZXhwbGljaXRfd2FsbGV0XCIsXG4gIHdhbGxldHM6IFtdXG59KTtcbmNvbnN0IFtsYXN0T3BlbmVkTGluaywgc2V0TGFzdE9wZW5lZExpbmtdID0gY3JlYXRlU2lnbmFsKHtcbiAgbGluazogXCJcIlxufSk7XG5jb25zdCBjb21tb24kMSA9IHsgXCJjbG9zZVwiOiBcIkNsb3NlXCIsIFwib3BlbldhbGxldFwiOiBcIk9wZW4gd2FsbGV0XCIsIFwiY29weUxpbmtcIjogXCJDb3B5IExpbmtcIiwgXCJsaW5rQ29waWVkXCI6IFwiTGluayBDb3BpZWRcIiwgXCJjb3BpZWRcIjogXCJDb3BpZWRcIiwgXCJ5b3VyV2FsbGV0XCI6IFwiWW91ciBXYWxsZXRcIiwgXCJyZXRyeVwiOiBcIlJldHJ5XCIsIFwiZ2V0XCI6IFwiR0VUXCIsIFwibW9iaWxlXCI6IFwiTW9iaWxlXCIsIFwiYnJvd3NlckV4dGVuc2lvblwiOiBcIkJyb3dzZXIgRXh0ZW5zaW9uXCIsIFwiZGVza3RvcFwiOiBcIkRlc2t0b3BcIiB9O1xuY29uc3QgYnV0dG9uJDEgPSB7IFwiY29ubmVjdFdhbGxldFwiOiBcIkNvbm5lY3QgV2FsbGV0XCIsIFwiZHJvcGRvd25cIjogeyBcImNvcHlcIjogXCJDb3B5IGFkZHJlc3NcIiwgXCJjb3BpZWRcIjogXCJBZGRyZXNzIGNvcGllZCFcIiwgXCJkaXNjb25uZWN0XCI6IFwiRGlzY29ubmVjdFwiIH0gfTtcbmNvbnN0IG5vdGlmaWNhdGlvbnMkMSA9IHsgXCJjb25maXJtXCI6IHsgXCJoZWFkZXJcIjogXCJPcGVuIHt7IG5hbWUgfX0gdG/CoGNvbmZpcm0gdGhlwqB0cmFuc2FjdGlvbi5cIiB9LCBcInRyYW5zYWN0aW9uU2VudFwiOiB7IFwiaGVhZGVyXCI6IFwiVHJhbnNhY3Rpb24gc2VudFwiLCBcInRleHRcIjogXCJZb3VyIHRyYW5zYWN0aW9uwqB3aWxsIGJlwqBwcm9jZXNzZWQgaW7CoGHCoGZldyBzZWNvbmRzLlwiIH0sIFwidHJhbnNhY3Rpb25DYW5jZWxlZFwiOiB7IFwiaGVhZGVyXCI6IFwiVHJhbnNhY3Rpb24gY2FuY2VsZWRcIiwgXCJ0ZXh0XCI6IFwiVGhlcmUgd2lsbCBiZSBubyBjaGFuZ2VzIHRvwqB5b3VyIGFjY291bnQuXCIgfSwgXCJkYXRhU2lnbmVkXCI6IHsgXCJoZWFkZXJcIjogXCJEYXRhIHNpZ25lZFwiIH0sIFwic2lnbkRhdGFDYW5jZWxlZFwiOiB7IFwiaGVhZGVyXCI6IFwiU2lnbiBkYXRhIGNhbmNlbGVkXCIgfSB9O1xuY29uc3Qgd2FsbGV0SXRlbSQxID0geyBcIndhbGxldE9uXCI6IFwiV2FsbGV0IGluXCIsIFwicmVjZW50XCI6IFwiUmVjZW50XCIsIFwiaW5zdGFsbGVkXCI6IFwiSW5zdGFsbGVkXCIsIFwicG9wdWxhclwiOiBcIlBvcHVsYXJcIiB9O1xuY29uc3Qgd2FsbGV0TW9kYWwkMSA9IHsgXCJsb2FkaW5nXCI6IFwiTG9hZGluZyB3YWxsZXRzXCIsIFwid2FsbGV0c1wiOiBcIldhbGxldHNcIiwgXCJtb2JpbGVVbml2ZXJzYWxNb2RhbFwiOiB7IFwiY29ubmVjdFlvdXJXYWxsZXRcIjogXCJDb25uZWN0IHlvdXIgVE9OwqB3YWxsZXRcIiwgXCJvcGVuV2FsbGV0T25UZWxlZ3JhbU9yU2VsZWN0XCI6IFwiVXNlIFdhbGxldCBpbiBUZWxlZ3JhbSBvciBjaG9vc2Ugb3RoZXIgYXBwbGljYXRpb25cIiwgXCJvcGVuV2FsbGV0T25UZWxlZ3JhbVwiOiBcIkNvbm5lY3QgV2FsbGV0IGluIFRlbGVncmFtXCIsIFwiY2hvb3NlT3RoZXJBcHBsaWNhdGlvblwiOiBcIkNob29zZSBvdGhlciBhcHBsaWNhdGlvblwiLCBcIm9wZW5MaW5rXCI6IFwiT3BlbiBMaW5rXCIsIFwic2NhblwiOiBcIlNjYW4gd2l0aCB5b3VyIG1vYmlsZcKgd2FsbGV0XCIgfSwgXCJkZXNrdG9wVW5pdmVyc2FsTW9kYWxcIjogeyBcImNvbm5lY3RZb3VyV2FsbGV0XCI6IFwiQ29ubmVjdCB5b3VyIFRPTiB3YWxsZXRcIiwgXCJzY2FuXCI6IFwiU2NhbiB3aXRoIHlvdXIgbW9iaWxlIHdhbGxldFwiLCBcImF2YWlsYWJsZVdhbGxldHNcIjogXCJBdmFpbGFibGUgd2FsbGV0c1wiIH0sIFwibW9iaWxlQ29ubmVjdGlvbk1vZGFsXCI6IHsgXCJzaG93UVJcIjogXCJTaG93IFFSIENvZGVcIiwgXCJzY2FuUVJcIjogXCJTY2FuIHRoZcKgUVIgY29kZSBiZWxvdyB3aXRoIHlvdXIgcGhvbmXigJlzwqBvcsKge3sgbmFtZSB9feKAmXMgY2FtZXJhXCIsIFwibWlzc2luZ0ZlYXR1cmVzXCI6IFwiUGxlYXNlIHVwZGF0ZSB7eyBuYW1lIH19LCB5b3VyIHZlcnNpb24gZG9lcyBub3Qgc3VwcG9ydCByZXF1aXJlZCBmZWF0dXJlcyBmb3IgdGhpcyBkQXBwXCIsIFwid3JvbmdOZXR3b3JrXCI6IFwiQ29ubmVjdGVkIHdhbGxldCBpcyBvbiBhIGRpZmZlcmVudCBuZXR3b3JrLiBQbGVhc2Ugc3dpdGNoIG5ldHdvcmsgaW4ge3sgbmFtZSB9fSBhbmQgdHJ5IGFnYWluXCIsIFwibm90U3VwcG9ydGVkV2FsbGV0XCI6IFwie3sgbmFtZSB9fSBkb2VzbuKAmXQgc3VwcG9ydCB0aGUgcmVxdWVzdGVkIGFjdGlvbi4gUGxlYXNlIGNvbm5lY3QgYW5vdGhlciB3YWxsZXQgdGhhdCBzdXBwb3J0cyBpdFwiLCBcImNvbnRpbnVlSW5cIjogXCJDb250aW51ZSBpbiB7eyBuYW1lIH194oCmXCIsIFwidXBkYXRlV2FsbGV0XCI6IFwiVXBkYXRlIHt7IG5hbWUgfX1cIiwgXCJjaG9vc2VBbm90aGVyV2FsbGV0XCI6IFwiQ2hvb3NlIEFub3RoZXIgV2FsbGV0XCIsIFwiY29ubmVjdGlvbkRlY2xpbmVkXCI6IFwiQ29ubmVjdGlvbiBkZWNsaW5lZFwiIH0sIFwiZGVza3RvcENvbm5lY3Rpb25Nb2RhbFwiOiB7IFwic2NhblFSXCI6IFwiU2NhbiB0aGXCoFFSIGNvZGUgYmVsb3cgd2l0aCB5b3VyIHBob25l4oCZc8Kgb3LCoHt7IG5hbWUgfX3igJlzIGNhbWVyYVwiLCBcImNvbnRpbnVlSW5FeHRlbnNpb25cIjogXCJDb250aW51ZSBpbsKge3sgbmFtZSB9fSBicm93c2VyIGV4dGVuc2lvbuKAplwiLCBcImRvbnRIYXZlRXh0ZW5zaW9uXCI6IFwiU2VlbXMgeW91IGRvbid0IGhhdmUgaW5zdGFsbGVkIHt7IG5hbWUgfX3CoGJyb3dzZXLCoGV4dGVuc2lvblwiLCBcIm1pc3NpbmdGZWF0dXJlc1wiOiBcIlBsZWFzZSB1cGRhdGUge3sgbmFtZSB9fSwgeW91ciB2ZXJzaW9uIGRvZXMgbm90IHN1cHBvcnQgcmVxdWlyZWQgZmVhdHVyZXMgZm9yIHRoaXMgZEFwcFwiLCBcIndyb25nTmV0d29ya1wiOiBcIkNvbm5lY3RlZCB3YWxsZXQgaXMgb24gYSBkaWZmZXJlbnQgbmV0d29yay4gUGxlYXNlIHN3aXRjaCBuZXR3b3JrIGluIHt7IG5hbWUgfX0gYW5kIHRyeSBhZ2FpblwiLCBcIm5vdFN1cHBvcnRlZFdhbGxldFwiOiBcInt7IG5hbWUgfX0gZG9lc27igJl0IHN1cHBvcnQgdGhlIHJlcXVlc3RlZCBhY3Rpb24uIFBsZWFzZSBjb25uZWN0IGFub3RoZXIgd2FsbGV0IHRoYXQgc3VwcG9ydHMgaXRcIiwgXCJnZXRXYWxsZXRcIjogXCJHZXQge3sgbmFtZSB9fVwiLCBcInVwZGF0ZVdhbGxldFwiOiBcIlVwZGF0ZSB7eyBuYW1lIH19XCIsIFwiY2hvb3NlQW5vdGhlcldhbGxldFwiOiBcIkNob29zZSBBbm90aGVyIFdhbGxldFwiLCBcImNvbnRpbnVlT25EZXNrdG9wXCI6IFwiQ29udGludWUgaW7CoHt7IG5hbWUgfX0gb24gZGVza3RvcOKAplwiLCBcIm9wZW5XYWxsZXRPblRlbGVncmFtXCI6IFwiQ29ubmVjdCBXYWxsZXQgaW4gVGVsZWdyYW0gb24gZGVza3RvcFwiLCBcImNvbm5lY3Rpb25EZWNsaW5lZFwiOiBcIkNvbm5lY3Rpb24gZGVjbGluZWRcIiB9LCBcImluZm9Nb2RhbFwiOiB7IFwid2hhdElzQVdhbGxldFwiOiBcIldoYXQgaXMgYSB3YWxsZXRcIiwgXCJzZWN1cmVEaWdpdGFsQXNzZXRzXCI6IFwiU2VjdXJlIGRpZ2l0YWwgYXNzZXRzIHN0b3JhZ2VcIiwgXCJ3YWxsZXRQcm90ZWN0c1wiOiBcIkEgd2FsbGV0IHByb3RlY3RzIGFuZCBtYW5hZ2VzIHlvdXIgZGlnaXRhbCBhc3NldHPCoGluY2x1ZGluZyBUT04sIHRva2VucyBhbmQgY29sbGVjdGFibGVzLlwiLCBcImNvbnRyb2xJZGVudGl0eVwiOiBcIkNvbnRyb2wgeW91ciBXZWIzIGlkZW50aXR5XCIsIFwibWFuYWdlSWRlbnRpdHlcIjogXCJNYW5hZ2UgeW91ciBkaWdpdGFsIGlkZW50aXR5IGFuZCBhY2Nlc3MgZGVjZW50cmFsaXplZCBhcHBsaWNhdGlvbnMgd2l0aCBlYXNlLiBNYWludGFpbiBjb250cm9sIG92ZXIgeW91ciBkYXRhIGFuZCBlbmdhZ2Ugc2VjdXJlbHkgaW7CoHRoZcKgYmxvY2tjaGFpbiBlY29zeXN0ZW0uXCIsIFwiZWZmb3J0bGVzc0NyeXB0b1RyYW5zYWN0aW9uc1wiOiBcIkVmZm9ydGxlc3MgY3J5cHRvIHRyYW5zYWN0aW9uc1wiLCBcImVhc2lseVNlbmRcIjogXCJFYXNpbHkgc2VuZCwgcmVjZWl2ZSwgbW9uaXRvciB5b3VyIGNyeXB0b2N1cnJlbmNpZXMuwqBTdHJlYW1saW5lIHlvdXIgb3BlcmF0aW9ucyB3aXRowqBkZWNlbnRyYWxpemVkIGFwcGxpY2F0aW9ucy5cIiwgXCJnZXRBV2FsbGV0XCI6IFwiR2V0IGEgV2FsbGV0XCIgfSwgXCJyZXN0b3JlTW9kYWxcIjogeyBcInRpdGxlXCI6IFwiUmVzdG9yZVwiLCBcInN0ZXAxXCI6IHsgXCJ0aXRsZVwiOiBcIkZpbmQgeW91ciBjdXJyZW50IHJlY292ZXJ5IHBocmFzZVwiLCBcInRleHRcIjogXCJPcGVuIHlvdXIgd2FsbGV0IHNldHRpbmdzIGFuZCBsb2NhdGUgdGhlwqByZWNvdmVyecKgcGhyYXNlXCIgfSwgXCJzdGVwMlwiOiB7IFwidGl0bGVcIjogXCJDb3B5IHlvdXIgcmVjb3ZlcnkgcGhyYXNlXCIsIFwidGV4dFwiOiBcIldyaXRlIGl0IGRvd24gb3IgY29weSBpdCB0byBhIHNhZmUgcGxhY2VcIiB9LCBcInN0ZXAzXCI6IHsgXCJ0aXRsZVwiOiBcIlJlc3RvcmUgaW4gYSBzdXBwb3J0ZWQgd2FsbGV0XCIsIFwidGV4dFwiOiBcIkVudGVyIHRoZSByZWNvdmVyeSBwaHJhc2UgdG8gYWNjZXNzIHlvdXIgd2FsbGV0XCIgfSB9LCBcImFsbFdhbGxldHNcIjogeyBcIndhbGxldHNCZWxvd05vdFN1cHBvcnRlZFwiOiBcIlRoZSB3YWxsZXRzIGJlbG93IGRvbuKAmXQgc3VwcG9ydCBhbGwgZmVhdHVyZXMgb2bCoHRoZSBjb25uZWN0ZWQgc2VydmljZS4gWW91IGNhbiB1c2UgeW91ciByZWNvdmVyeSBwaHJhc2UgaW4gb25lIG9mIHRoZSBzdXBwb3J0ZWQgd2FsbGV0cyBhYm92ZS5cIiwgXCJ3YWxsZXROb3RTdXBwb3J0U2VydmljZVwiOiBcInt7IG5hbWUgfX0gZG9lc27igJl0IHN1cHBvcnQgY29ubmVjdGVkIHNlcnZpY2VcIiB9LCBcImZlYXR1cmVOb3RTdXBwb3J0ZWRcIjogeyBcIndhbGxldFwiOiB7IFwidGl0bGVcIjogXCJ7eyBuYW1lIH19IGRvZXNu4oCZdCBzdXBwb3J0IHRoZSByZXF1ZXN0ZWTCoGFjdGlvblwiLCBcImRlc2NyaXB0aW9uXCI6IFwiSW5zdGFsbCBhIHN1cHBvcnRlZCB3YWxsZXQgZnJvbSB0aGUgbGlzdCBiZWxvdywgcmVzdG9yZSBpdCB3aXRoIHlvdXIgcmVjb3ZlcnkgcGhyYXNlLCB0aGVuIGNvbm5lY3QgaXQgYW5kIHRyeSBhZ2Fpbi5cIiwgXCJpbmZvXCI6IFwiTGVhcm4gaG93IHRvIHJlc3RvcmUgeW91ciB3YWxsZXRcIiB9LCBcInZlcnNpb25cIjogeyBcImRlc2NyaXB0aW9uXCI6IFwiWW91ciBjdXJyZW50IHZlcnNpb24gb2Yge3sgbmFtZSB9fSBvciB3YWxsZXQgY29udHJhY3QgdHlwZSBkb2Vzbid0IHN1cHBvcnQgdGhlIHJlcXVpcmVkIGZlYXR1cmVzLiBQbGVhc2UgdXBkYXRlIGl0IHRvIGNvbnRpbnVlLlwiLCBcInVwZGF0ZUJ1dHRvblwiOiBcIlVwZGF0ZSB7eyBuYW1lIH19XCIsIFwiYWJvdXRXNVwiOiBcIkFib3V0IFc1XCIgfSwgXCJkaXNjb25uZWN0XCI6IHsgXCJ0aXRsZVwiOiBcIkNvbmZpcm0gRGlzY29ubmVjdFwiLCBcImRlc2NyaXB0aW9uXCI6IFwiWW91IHdpbGwgYmUgZGlzY29ubmVjdGVkIGZyb20geW91ciBjdXJyZW50IHdhbGxldCBhbmQgcmVkaXJlY3RlZCB0byBjb25uZWN0IHt7IG5hbWUgfX0uXCIsIFwiYnV0dG9uXCI6IFwiRGlzY29ubmVjdFwiIH0gfSB9O1xuY29uc3QgYWN0aW9uTW9kYWwkMSA9IHsgXCJjb25maXJtVHJhbnNhY3Rpb25cIjogeyBcImhlYWRlclwiOiBcIkNvbmZpcm0gdGhlwqB0cmFuc2FjdGlvbiBpbsKge3sgbmFtZSB9fVwiLCBcInRleHRcIjogXCJJdCB3aWxsIG9ubHkgdGFrZSBhwqBtb21lbnQuXCIgfSwgXCJzaWduRGF0YVwiOiB7IFwiaGVhZGVyXCI6IFwiU2lnbiB0aGXCoGRhdGEgaW7CoHt7IG5hbWUgfX1cIiwgXCJ0ZXh0XCI6IFwiSXQgd2lsbCBvbmx5IHRha2UgYcKgbW9tZW50LlwiIH0sIFwidHJhbnNhY3Rpb25TZW50XCI6IFwiJG5vdGlmaWNhdGlvbnMudHJhbnNhY3Rpb25TZW50XCIsIFwidHJhbnNhY3Rpb25DYW5jZWxlZFwiOiBcIiRub3RpZmljYXRpb25zLnRyYW5zYWN0aW9uQ2FuY2VsZWRcIiwgXCJkYXRhU2lnbmVkXCI6IFwiJG5vdGlmaWNhdGlvbnMuZGF0YVNpZ25lZFwiLCBcInNpZ25EYXRhQ2FuY2VsZWRcIjogXCIkbm90aWZpY2F0aW9ucy5zaWduRGF0YUNhbmNlbGVkXCIgfTtcbmNvbnN0IGVuID0ge1xuICBjb21tb246IGNvbW1vbiQxLFxuICBidXR0b246IGJ1dHRvbiQxLFxuICBub3RpZmljYXRpb25zOiBub3RpZmljYXRpb25zJDEsXG4gIHdhbGxldEl0ZW06IHdhbGxldEl0ZW0kMSxcbiAgd2FsbGV0TW9kYWw6IHdhbGxldE1vZGFsJDEsXG4gIGFjdGlvbk1vZGFsOiBhY3Rpb25Nb2RhbCQxXG59O1xuY29uc3QgY29tbW9uID0geyBcImNsb3NlXCI6IFwi0JfQsNC60YDRi9GC0YxcIiwgXCJvcGVuV2FsbGV0XCI6IFwi0J7RgtC60YDRi9GC0Ywg0LrQvtGI0LXQu9GR0LpcIiwgXCJjb3B5TGlua1wiOiBcItCh0LrQvtC/0LjRgNC+0LLQsNGC0YxcIiwgXCJsaW5rQ29waWVkXCI6IFwi0KHRgdGL0LvQutCwINGB0LrQvtC/0LjRgNC+0LLQsNC90LBcIiwgXCJjb3BpZWRcIjogXCLQodC60L7Qv9C40YDQvtCy0LDQvdC+XCIsIFwieW91cldhbGxldFwiOiBcItCS0LDRiCDQutC+0YjQtdC70ZHQulwiLCBcInJldHJ5XCI6IFwi0J/QvtCy0YLQvtGA0LjRgtGMXCIsIFwiZ2V0XCI6IFwi0KHQutCw0YfQsNGC0YxcIiwgXCJtb2JpbGVcIjogXCLQnNC+0LHQuNC70YzQvdGL0LlcIiwgXCJicm93c2VyRXh0ZW5zaW9uXCI6IFwi0KDQsNGB0YjQuNGA0LXQvdC40LVcIiwgXCJkZXNrdG9wXCI6IFwi0JTQtdGB0LrRgtC+0L9cIiB9O1xuY29uc3QgYnV0dG9uID0geyBcImNvbm5lY3RXYWxsZXRcIjogXCLQn9C+0LTQutC70Y7Rh9C40YLRjCDQutC+0YjQtdC70ZHQulwiLCBcImRyb3Bkb3duXCI6IHsgXCJjb3B5XCI6IFwi0KHQutC+0L/QuNGA0L7QstCw0YLRjCDQsNC00YDQtdGBXCIsIFwiY29waWVkXCI6IFwi0JDQtNGA0LXRgSDRgdC60L7Qv9C40YDQvtCy0LDQvSFcIiwgXCJkaXNjb25uZWN0XCI6IFwi0J7RgtC60LvRjtGH0LjRgtGMINC60L7RiNC10LvRkdC6XCIgfSB9O1xuY29uc3Qgbm90aWZpY2F0aW9ucyA9IHsgXCJjb25maXJtXCI6IHsgXCJoZWFkZXJcIjogXCLQntGC0LrRgNC+0LnRgtC1IHt7IG5hbWUgfX0sINGH0YLQvtCx0YvCoNC/0L7QtNGC0LLQtdGA0LTQuNGC0Ywg0YLRgNCw0L3Qt9Cw0LrRhtC40Y4uXCIgfSwgXCJ0cmFuc2FjdGlvblNlbnRcIjogeyBcImhlYWRlclwiOiBcItCi0YDQsNC90LfQsNC60YbQuNGPINC+0YLQv9GA0LDQstC70LXQvdCwXCIsIFwidGV4dFwiOiBcItCS0LDRiNCwINGC0YDQsNC90LfQsNC60YbQuNGPwqDQsdGD0LTQtdGCINC+0LHRgNCw0LHQvtGC0LDQvdCwINGH0LXRgNC10LfCoNC90LXRgdC60L7Qu9GM0LrQviDRgdC10LrRg9C90LQuXCIgfSwgXCJ0cmFuc2FjdGlvbkNhbmNlbGVkXCI6IHsgXCJoZWFkZXJcIjogXCLQotGA0LDQvdC30LDQutGG0LjRjyDQvtGC0LzQtdC90LXQvdCwXCIsIFwidGV4dFwiOiBcItCh0L7RgdGC0L7Rj9C90LjQtSDQstCw0YjQtdCz0L4g0YHRh9GR0YLQsCDQvdC1wqDQuNC30LzQtdC90LjRgtGB0Y8uXCIgfSwgXCJkYXRhU2lnbmVkXCI6IHsgXCJoZWFkZXJcIjogXCLQlNCw0L3QvdGL0LUg0L/QvtC00L/QuNGB0LDQvdGLXCIgfSwgXCJzaWduRGF0YUNhbmNlbGVkXCI6IHsgXCJoZWFkZXJcIjogXCLQn9C+0LTQv9C40YHRjCDQtNCw0L3QvdGL0YUg0L7RgtC80LXQvdC10L3QsFwiIH0gfTtcbmNvbnN0IHdhbGxldEl0ZW0gPSB7IFwid2FsbGV0T25cIjogXCJXYWxsZXQg0LJcIiwgXCJyZWNlbnRcIjogXCLQndC10LTQsNCy0L3QuNC5XCIsIFwiaW5zdGFsbGVkXCI6IFwi0KPRgdGC0LDQvdC+0LLQu9C10L1cIiwgXCJwb3B1bGFyXCI6IFwi0J/QvtC/0YPQu9GP0YDQtdC9XCIgfTtcbmNvbnN0IHdhbGxldE1vZGFsID0geyBcImxvYWRpbmdcIjogXCLQmtC+0YjQtdC70YzQutC4INC30LDQs9GA0YPQttCw0Y7RgtGB0Y9cIiwgXCJ3YWxsZXRzXCI6IFwi0JrQvtGI0LXQu9GM0LrQuFwiLCBcIm1vYmlsZVVuaXZlcnNhbE1vZGFsXCI6IHsgXCJjb25uZWN0WW91cldhbGxldFwiOiBcItCf0L7QtNC60LvRjtGH0LjRgtC1IFRPTsKg0LrQvtGI0LXQu9GR0LpcIiwgXCJvcGVuV2FsbGV0T25UZWxlZ3JhbU9yU2VsZWN0XCI6IFwi0J/QvtC00LrQu9GO0YfQuNGC0LUgV2FsbGV0INCywqBUZWxlZ3JhbSDQuNC70LjCoNCy0YvQsdC10YDQtdGC0LUg0LTRgNGD0LPQvtC1INC/0YDQuNC70L7QttC10L3QuNC1XCIsIFwib3BlbldhbGxldE9uVGVsZWdyYW1cIjogXCLQntGC0LrRgNGL0YLRjCBXYWxsZXQg0LIgVGVsZWdyYW1cIiwgXCJjaG9vc2VPdGhlckFwcGxpY2F0aW9uXCI6IFwi0JLRi9Cx0LXRgNC40YLQtSDQtNGA0YPQs9C+0LUg0L/RgNC40LvQvtC20LXQvdC40LVcIiwgXCJvcGVuTGlua1wiOiBcItCe0YLQutGA0YvRgtGMXCIsIFwic2NhblwiOiBcItCe0YLRgdC60LDQvdC40YDRg9C50YLQtSDQutCw0LzQtdGA0L7QuSDQstCw0YjQtdCz0L7CoNGC0LXQu9C10YTQvtC90LBcIiB9LCBcImRlc2t0b3BVbml2ZXJzYWxNb2RhbFwiOiB7IFwiY29ubmVjdFlvdXJXYWxsZXRcIjogXCLQn9C+0LTQutC70Y7Rh9C40YLQtSBUT04g0LrQvtGI0LXQu9GR0LpcIiwgXCJzY2FuXCI6IFwi0J7RgtGB0LrQsNC90LjRgNGD0LnRgtC1IFFSLdC60L7QtCDQutCw0LzQtdGA0L7QuSDQstCw0YjQtdCz0L7CoNGC0LXQu9C10YTQvtC90LBcIiwgXCJhdmFpbGFibGVXYWxsZXRzXCI6IFwi0JTQvtGB0YLRg9C/0L3Ri9C1INC60L7RiNC10LvRjNC60LhcIiB9LCBcIm1vYmlsZUNvbm5lY3Rpb25Nb2RhbFwiOiB7IFwic2hvd1FSXCI6IFwi0J/QvtC60LDQt9Cw0YLRjCBRUi3QutC+0LRcIiwgXCJzY2FuUVJcIjogXCLQntGC0YHQutCw0L3QuNGA0YPQudGC0LUgUVIt0LrQvtC0INC90LjQttC1INC60LDQvNC10YDQvtC5INCywqDQv9GA0LjQu9C+0LbQtdC90LjQuCB7eyBuYW1lIH19LCDQuNC70LjCoNC60LDQvNC10YDQvtC5INGC0LXQu9C10YTQvtC90LBcIiwgXCJtaXNzaW5nRmVhdHVyZXNcIjogXCLQntCx0L3QvtCy0LjRgtC1IHt7IG5hbWUgfX0sINCy0LDRiNCwINCy0LXRgNGB0LjRjyDQvdC1INC/0L7QtNC00LXRgNC20LjQstCw0LXRgiDQvdC10L7QsdGF0L7QtNC40LzRi9C1INGE0YPQvdC60YbQuNC4INC00LvRjyDRjdGC0L7Qs9C+IGRBcHBcIiwgXCJ3cm9uZ05ldHdvcmtcIjogXCLQn9C+0LTQutC70Y7Rh9GR0L3QvdGL0Lkg0LrQvtGI0LXQu9GR0Log0L3QsNGF0L7QtNC40YLRgdGPINCyINC00YDRg9Cz0L7QuSDRgdC10YLQuC4g0J/QvtC20LDQu9GD0LnRgdGC0LAsINC/0LXRgNC10LrQu9GO0YfQuNGC0LUg0YHQtdGC0Ywg0LIge3sgbmFtZSB9fSDQuCDQv9C+0L/RgNC+0LHRg9C50YLQtSDRgdC90L7QstCwXCIsIFwibm90U3VwcG9ydGVkV2FsbGV0XCI6IFwie3sgbmFtZSB9fSDQvdC1INC/0L7QtNC00LXRgNC20LjQstCw0LXRgiDQt9Cw0L/RgNC+0YjQtdC90L3QvtC1INC00LXQudGB0YLQstC40LUuINCf0L7QttCw0LvRg9C50YHRgtCwLCDQv9C+0LTQutC70Y7Rh9C40YLQtSDQtNGA0YPQs9C+0Lkg0LrQvtGI0LXQu9GR0LosINC60L7RgtC+0YDRi9C5INC/0L7QtNC00LXRgNC20LjQstCw0LXRgiDRjdGC0L5cIiwgXCJjb250aW51ZUluXCI6IFwi0J/RgNC+0LTQvtC70LbQuNGC0LUg0LIge3sgbmFtZSB9feKAplwiLCBcInVwZGF0ZVdhbGxldFwiOiBcItCe0LHQvdC+0LLQuNGC0Ywge3sgbmFtZSB9fVwiLCBcImNob29zZUFub3RoZXJXYWxsZXRcIjogXCLQktGL0LHRgNCw0YLRjCDQtNGA0YPQs9C+0Lkg0LrQvtGI0LXQu9GR0LpcIiwgXCJjb25uZWN0aW9uRGVjbGluZWRcIjogXCLQn9C+0LTQutC70Y7Rh9C10L3QuNC1INC+0YLQutC70L7QvdC10L3QvlwiIH0sIFwiZGVza3RvcENvbm5lY3Rpb25Nb2RhbFwiOiB7IFwic2NhblFSXCI6IFwi0J7RgtGB0LrQsNC90LjRgNGD0LnRgtC1IFFSLdC60L7QtCDQvdC40LbQtSDQutCw0LzQtdGA0L7QuSDQssKg0L/RgNC40LvQvtC20LXQvdC40Lgge3sgbmFtZSB9fSwg0LjQu9C4wqDQutCw0LzQtdGA0L7QuSDRgtC10LvQtdGE0L7QvdCwXCIsIFwiY29udGludWVJbkV4dGVuc2lvblwiOiBcItCe0YLQutGA0L7QudGC0LUg0LHRgNCw0YPQt9C10YDQvdC+0LUg0YDQsNGB0YjQuNGA0LXQvdC40LUge3sgbmFtZSB9fVwiLCBcImRvbnRIYXZlRXh0ZW5zaW9uXCI6IFwi0J/QvtGF0L7QttC1LCDRgyDQstCw0YEg0L3QtcKg0YPRgdGC0LDQvdC+0LLQu9C10L3QviDQsdGA0LDRg9C30LXRgNC90L7QtcKg0YDQsNGB0YjQuNGA0LXQvdC40LXCoHt7IG5hbWUgfX1cIiwgXCJtaXNzaW5nRmVhdHVyZXNcIjogXCLQntCx0L3QvtCy0LjRgtC1IHt7IG5hbWUgfX0sINCy0LDRiNCwINCy0LXRgNGB0LjRjyDQvdC1INC/0L7QtNC00LXRgNC20LjQstCw0LXRgiDQvdC10L7QsdGF0L7QtNC40LzRi9C1INGE0YPQvdC60YbQuNC4INC00LvRjyDRjdGC0L7Qs9C+IGRBcHBcIiwgXCJ3cm9uZ05ldHdvcmtcIjogXCLQn9C+0LTQutC70Y7Rh9GR0L3QvdGL0Lkg0LrQvtGI0LXQu9GR0Log0L3QsNGF0L7QtNC40YLRgdGPINCyINC00YDRg9Cz0L7QuSDRgdC10YLQuC4g0J/QvtC20LDQu9GD0LnRgdGC0LAsINC/0LXRgNC10LrQu9GO0YfQuNGC0LUg0YHQtdGC0Ywg0LIge3sgbmFtZSB9fSDQuCDQv9C+0L/RgNC+0LHRg9C50YLQtSDRgdC90L7QstCwXCIsIFwibm90U3VwcG9ydGVkV2FsbGV0XCI6IFwie3sgbmFtZSB9fSDQvdC1INC/0L7QtNC00LXRgNC20LjQstCw0LXRgiDQt9Cw0L/RgNC+0YjQtdC90L3QvtC1INC00LXQudGB0YLQstC40LUuINCf0L7QttCw0LvRg9C50YHRgtCwLCDQv9C+0LTQutC70Y7Rh9C40YLQtSDQtNGA0YPQs9C+0Lkg0LrQvtGI0LXQu9GR0LosINC60L7RgtC+0YDRi9C5INC/0L7QtNC00LXRgNC20LjQstCw0LXRgiDRjdGC0L5cIiwgXCJnZXRXYWxsZXRcIjogXCLQodC60LDRh9Cw0YLRjCB7eyBuYW1lIH19XCIsIFwidXBkYXRlV2FsbGV0XCI6IFwi0J7QsdC90L7QstC40YLRjCB7eyBuYW1lIH19XCIsIFwiY2hvb3NlQW5vdGhlcldhbGxldFwiOiBcItCS0YvQsdGA0LDRgtGMINC00YDRg9Cz0L7QuSDQutC+0YjQtdC70ZHQulwiLCBcImNvbnRpbnVlT25EZXNrdG9wXCI6IFwi0J7RgtC60YDQvtC50YLQtSB7eyBuYW1lIH19INC90LDCoNC60L7QvNC/0YzRjtGC0LXRgNC14oCmXCIsIFwib3BlbldhbGxldE9uVGVsZWdyYW1cIjogXCLQntGC0LrRgNGL0YLRjCBXYWxsZXQg0LLCoFRlbGVncmFtXCIsIFwiY29ubmVjdGlvbkRlY2xpbmVkXCI6IFwi0J/QvtC00LrQu9GO0YfQtdC90LjQtSDQvtGC0LrQu9C+0L3QtdC90L5cIiB9LCBcImluZm9Nb2RhbFwiOiB7IFwid2hhdElzQVdhbGxldFwiOiBcItCn0YLQviDRgtCw0LrQvtC1INC60L7RiNC10LvRkdC6P1wiLCBcInNlY3VyZURpZ2l0YWxBc3NldHNcIjogXCLQndCw0LTQtdC20L3QvtC1INGF0YDQsNC90LjQu9C40YnQtSDRhtC40YTRgNC+0LLRi9GFINCw0LrRgtC40LLQvtCyXCIsIFwid2FsbGV0UHJvdGVjdHNcIjogXCLQmtC+0YjQtdC70ZHQuiDQt9Cw0YnQuNGJ0LDQtdGCINCy0LDRiNC4INGG0LjRhNGA0L7QstGL0LUg0LDQutGC0LjQstGLLCDQstC60LvRjtGH0LDRjyBUT04sINGC0L7QutC10L3RiyDQuMKg0L/RgNC10LTQvNC10YLRiyDQutC+0LvQu9C10LrRhtC40L7QvdC40YDQvtCy0LDQvdC40Y8sINC4wqDRg9C/0YDQsNCy0LvRj9C10YIg0LjQvNC4LlwiLCBcImNvbnRyb2xJZGVudGl0eVwiOiBcItCa0L7QvdGC0YDQvtC70Ywg0YHQstC+0LXQuSDQu9C40YfQvdC+0YHRgtC4IFdlYjNcIiwgXCJtYW5hZ2VJZGVudGl0eVwiOiBcItCj0L/RgNCw0LLQu9GP0LnRgtC1INGB0LLQvtC10Lkg0YbQuNGE0YDQvtCy0L7QuSDQuNC00LXQvdGC0LjRhNC40LrQsNGG0LjQtdC5INC4wqDRgcKg0LvQtdCz0LrQvtGB0YLRjNGOINC/0L7Qu9GD0YfQsNC50YLQtSDQtNC+0YHRgtGD0L8g0LrCoNC00LXRhtC10L3RgtGA0LDQu9C40LfQvtCy0LDQvdC90YvQvCDQv9GA0LjQu9C+0LbQtdC90LjRj9C8LiDQodC+0YXRgNCw0L3Rj9C50YLQtSDQutC+0L3RgtGA0L7Qu9GMINC90LDQtMKg0YHQstC+0LjQvNC4INC00LDQvdC90YvQvNC4INC4wqDQsdC10LfQvtC/0LDRgdC90L4g0YPRh9Cw0YHRgtCy0YPQudGC0LUg0LLCoNGN0LrQvtGB0LjRgdGC0LXQvNC1wqDQsdC70L7QutGH0LXQudC90LAuXCIsIFwiZWZmb3J0bGVzc0NyeXB0b1RyYW5zYWN0aW9uc1wiOiBcItCf0YDQvtGB0YLRi9C1INC60YDQuNC/0YLQvtGC0YDQsNC90LfQsNC60YbQuNC4XCIsIFwiZWFzaWx5U2VuZFwiOiBcItCb0LXQs9C60L4g0L7RgtC/0YDQsNCy0LvRj9C50YLQtSwg0L/QvtC70YPRh9Cw0LnRgtC1INC4wqDQvtGC0YHQu9C10LbQuNCy0LDQudGC0LUg0YHQstC+0Lgg0LrRgNC40L/RgtC+0LLQsNC70Y7RgtGLLiDQntC/0YLQuNC80LjQt9C40YDRg9C50YLQtSDRgdCy0L7QuCDQvtC/0LXRgNCw0YbQuNC4INGBwqDQv9C+0LzQvtGJ0YzRjiDQtNC10YbQtdC90YLRgNCw0LvQuNC30L7QstCw0L3QvdGL0YUg0L/RgNC40LvQvtC20LXQvdC40LkuXCIsIFwiZ2V0QVdhbGxldFwiOiBcItCh0LrQsNGH0LDRgtGMINC60L7RiNC10LvRkdC6XCIgfSwgXCJyZXN0b3JlTW9kYWxcIjogeyBcInRpdGxlXCI6IFwi0JLQvtGB0YHRgtCw0L3QvtCy0LvQtdC90LjQtVwiLCBcInN0ZXAxXCI6IHsgXCJ0aXRsZVwiOiBcItCd0LDQudC00LjRgtC1INCy0LDRiNGDINGC0LXQutGD0YnRg9GOINGE0YDQsNC30YMg0LLQvtGB0YHRgtCw0L3QvtCy0LvQtdC90LjRj1wiLCBcInRleHRcIjogXCLQntGC0LrRgNC+0LnRgtC1INC90LDRgdGC0YDQvtC50LrQuCDQutC+0YjQtdC70YzQutCwINC4INC90LDQudC00LjRgtC1INGE0YDQsNC30YPCoNCy0L7RgdGB0YLQsNC90L7QstC70LXQvdC40Y9cIiB9LCBcInN0ZXAyXCI6IHsgXCJ0aXRsZVwiOiBcItCh0LrQvtC/0LjRgNGD0LnRgtC1INCy0LDRiNGDINGE0YDQsNC30YMg0LLQvtGB0YHRgtCw0L3QvtCy0LvQtdC90LjRj1wiLCBcInRleHRcIjogXCLQl9Cw0L/QuNGI0LjRgtC1INC10ZEg0LjQu9C4INGB0L7RhdGA0LDQvdC40YLQtSDQsiDQsdC10LfQvtC/0LDRgdC90L7QvCDQvNC10YHRgtC1XCIgfSwgXCJzdGVwM1wiOiB7IFwidGl0bGVcIjogXCLQktC+0YHRgdGC0LDQvdC+0LLQuNGC0LUg0LIg0L/QvtC00LTQtdGA0LbQuNCy0LDQtdC80L7QvCDQutC+0YjQtdC70YzQutC1XCIsIFwidGV4dFwiOiBcItCS0LLQtdC00LjRgtC1INGE0YDQsNC30YMg0LLQvtGB0YHRgtCw0L3QvtCy0LvQtdC90LjRjyDQtNC70Y8g0LTQvtGB0YLRg9C/0LDCoNC6wqDQstCw0YjQtdC80YPCoNC60L7RiNC10LvRjNC60YNcIiB9IH0sIFwiYWxsV2FsbGV0c1wiOiB7IFwid2FsbGV0c0JlbG93Tm90U3VwcG9ydGVkXCI6IFwi0JrQvtGI0LXQu9GM0LrQuCDQvdC40LbQtSDQvdC1INC/0L7QtNC00LXRgNC20LjQstCw0Y7RgiDQstGB0LUg0YTRg9C90LrRhtC40Lgg0L/QvtC00LrQu9GO0YfRkdC90L3QvtCz0L4g0YHQtdGA0LLQuNGB0LAuINCS0Ysg0LzQvtC20LXRgtC1INC40YHQv9C+0LvRjNC30L7QstCw0YLRjCDRgdCy0L7RjiDRhNGA0LDQt9GDINCy0L7RgdGB0YLQsNC90L7QstC70LXQvdC40Y8g0LIg0L7QtNC90L7QvCDQuNC3INC/0L7QtNC00LXRgNC20LjQstCw0LXQvNGL0YUg0LLRi9GI0LUg0LrQvtGI0LXQu9GM0LrQvtCyLlwiLCBcIndhbGxldE5vdFN1cHBvcnRTZXJ2aWNlXCI6IFwie3sgbmFtZSB9fSDQvdC1INC/0L7QtNC00LXRgNC20LjQstCw0LXRgiDQv9C+0LTQutC70Y7Rh9GR0L3QvdGL0Lkg0YHQtdGA0LLQuNGBXCIgfSwgXCJmZWF0dXJlTm90U3VwcG9ydGVkXCI6IHsgXCJ3YWxsZXRcIjogeyBcInRpdGxlXCI6IFwie3sgbmFtZSB9fSDQvdC1INC/0L7QtNC00LXRgNC20LjQstCw0LXRgiDQt9Cw0L/RgNC+0YjQtdC90L3QvtC1wqDQtNC10LnRgdGC0LLQuNC1XCIsIFwiZGVzY3JpcHRpb25cIjogXCLQo9GB0YLQsNC90L7QstC40YLQtSDQv9C+0LTQtNC10YDQttC40LLQsNC10LzRi9C5INC60L7RiNC10LvRkdC6INC40Lcg0YHQv9C40YHQutCwINC90LjQttC1LCDQstC+0YHRgdGC0LDQvdC+0LLQuNGC0LUg0LXQs9C+INGBINC/0L7QvNC+0YnRjNGOINGE0YDQsNC30Ysg0LLQvtGB0YHRgtCw0L3QvtCy0LvQtdC90LjRjywg0LfQsNGC0LXQvCDQv9C+0LTQutC70Y7Rh9C40YLQtdGB0Ywg0Lgg0L/QvtC/0YDQvtCx0YPQudGC0LUg0YHQvdC+0LLQsC5cIiwgXCJpbmZvXCI6IFwi0KPQt9C90LDRgtGMLCDQutCw0Log0LLQvtGB0YHRgtCw0L3QvtCy0LjRgtGMINC60L7RiNC10LvRkdC6XCIgfSwgXCJ2ZXJzaW9uXCI6IHsgXCJkZXNjcmlwdGlvblwiOiBcItCi0LXQutGD0YnQsNGPINCy0LXRgNGB0LjRjyB7eyBuYW1lIH19INC40LvQuCDRgtC40L8g0LrQvtC90YLRgNCw0LrRgtCwINC60L7RiNC10LvRjNC60LAg0L3QtSDQv9C+0LTQtNC10YDQttC40LLQsNC10YIg0L3QtdC+0LHRhdC+0LTQuNC80YvQtSDRhNGD0L3QutGG0LjQuC4g0J7QsdC90L7QstC40YLQtSDQutC+0YjQtdC70ZHQuiwg0YfRgtC+0LHRiyDQv9GA0L7QtNC+0LvQttC40YLRjC5cIiwgXCJ1cGRhdGVCdXR0b25cIjogXCLQntCx0L3QvtCy0LjRgtGMIHt7IG5hbWUgfX1cIiwgXCJhYm91dFc1XCI6IFwi0J/RgNC+IFc1XCIgfSwgXCJkaXNjb25uZWN0XCI6IHsgXCJ0aXRsZVwiOiBcItCf0L7QtNGC0LLQtdGA0LTQuNGC0LUg0L7RgtC60LvRjtGH0LXQvdC40LVcIiwgXCJkZXNjcmlwdGlvblwiOiBcItCS0Ysg0LHRg9C00LXRgtC1INC+0YLQutC70Y7Rh9C10L3RiyDQvtGCINGC0LXQutGD0YnQtdCz0L4g0LrQvtGI0LXQu9GM0LrQsCDQuCDQv9C10YDQtdC90LDQv9GA0LDQstC70LXQvdGLINC90LAg0L/QvtC00LrQu9GO0YfQtdC90LjQtSB7eyBuYW1lIH19LlwiLCBcImJ1dHRvblwiOiBcItCe0YLQutC70Y7Rh9C40YLRjNGB0Y9cIiB9IH0gfTtcbmNvbnN0IGFjdGlvbk1vZGFsID0geyBcImNvbmZpcm1UcmFuc2FjdGlvblwiOiB7IFwiaGVhZGVyXCI6IFwi0J/QvtC00YLQstC10YDQtNC40YLQtSDQtNC10LnRgdGC0LLQuNC1INCywqB7eyBuYW1lIH19XCIsIFwidGV4dFwiOiBcItCt0YLQviDQt9Cw0LnQvNC10YIg0L/QsNGA0YMg0YHQtdC60YPQvdC0LlwiIH0sIFwic2lnbkRhdGFcIjogeyBcImhlYWRlclwiOiBcItCf0L7QtNC/0LjRiNC40YLQtSDQtNCw0L3QvdGL0LUg0LLCoHt7IG5hbWUgfX1cIiwgXCJ0ZXh0XCI6IFwi0K3RgtC+INC30LDQudC80LXRgiDQv9Cw0YDRgyDRgdC10LrRg9C90LQuXCIgfSwgXCJ0cmFuc2FjdGlvblNlbnRcIjogXCIkbm90aWZpY2F0aW9ucy50cmFuc2FjdGlvblNlbnRcIiwgXCJ0cmFuc2FjdGlvbkNhbmNlbGVkXCI6IFwiJG5vdGlmaWNhdGlvbnMudHJhbnNhY3Rpb25DYW5jZWxlZFwiLCBcImRhdGFTaWduZWRcIjogXCIkbm90aWZpY2F0aW9ucy5kYXRhU2lnbmVkXCIsIFwic2lnbkRhdGFDYW5jZWxlZFwiOiBcIiRub3RpZmljYXRpb25zLnNpZ25EYXRhQ2FuY2VsZWRcIiB9O1xuY29uc3QgcnUgPSB7XG4gIGNvbW1vbixcbiAgYnV0dG9uLFxuICBub3RpZmljYXRpb25zLFxuICB3YWxsZXRJdGVtLFxuICB3YWxsZXRNb2RhbCxcbiAgYWN0aW9uTW9kYWxcbn07XG5jb25zdCBpMThuRGljdGlvbmFyeSA9IHtcbiAgZW46IHBhcnNlRGljdGlvbmFyeShlbiksXG4gIHJ1OiBwYXJzZURpY3Rpb25hcnkocnUpXG59O1xuZnVuY3Rpb24gcGFyc2VEaWN0aW9uYXJ5KGRpY3Rpb25hcnkpIHtcbiAgY29uc3QgcmVmU3ltYm9sID0gXCIkXCI7XG4gIGNvbnN0IGl0ZXJhdGUgPSAoc3ViRGljdGlvbmFyeSkgPT4ge1xuICAgIE9iamVjdC5lbnRyaWVzKHN1YkRpY3Rpb25hcnkpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXRlcmF0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh2YWx1ZVswXSA9PT0gcmVmU3ltYm9sKSB7XG4gICAgICAgICAgY29uc3QgcGF0aCA9IHZhbHVlLnNsaWNlKDEpLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICBsZXQgb2JqID0gZGljdGlvbmFyeTtcbiAgICAgICAgICBwYXRoLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtIGluIG9iaikge1xuICAgICAgICAgICAgICBvYmogPSBvYmpbaXRlbV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYENhbm5vdCBwYXJzZSB0cmFuc2xhdGlvbnM6IHRoZXJlIGlzIG5vIHByb3BlcnR5ICR7aXRlbX0gaW4gdHJhbnNsYXRpb25gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3ViRGljdGlvbmFyeVtrZXldID0gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5zbGljZSgwLCAyKSA9PT0gYFxcXFwke3JlZlN5bWJvbH1gKSB7XG4gICAgICAgICAgc3ViRGljdGlvbmFyeVtrZXldID0gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgaXRlcmF0ZShkaWN0aW9uYXJ5KTtcbiAgcmV0dXJuIGRpY3Rpb25hcnk7XG59XG5jb25zdCBDb25uZWN0b3JDb250ZXh0ID0gY3JlYXRlQ29udGV4dCgpO1xuY29uc3QgJFJBVyA9IFN5bWJvbChcInN0b3JlLXJhd1wiKSwgJE5PREUgPSBTeW1ib2woXCJzdG9yZS1ub2RlXCIpLCAkSEFTID0gU3ltYm9sKFwic3RvcmUtaGFzXCIpLCAkU0VMRiA9IFN5bWJvbChcInN0b3JlLXNlbGZcIik7XG5mdW5jdGlvbiB3cmFwJDEodmFsdWUpIHtcbiAgbGV0IHAyID0gdmFsdWVbJFBST1hZXTtcbiAgaWYgKCFwMikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZSwgJFBST1hZLCB7XG4gICAgICB2YWx1ZTogcDIgPSBuZXcgUHJveHkodmFsdWUsIHByb3h5VHJhcHMkMSlcbiAgICB9KTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpLCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModmFsdWUpO1xuICAgICAgZm9yIChsZXQgaTIgPSAwLCBsMiA9IGtleXMubGVuZ3RoOyBpMiA8IGwyOyBpMisrKSB7XG4gICAgICAgIGNvbnN0IHByb3AgPSBrZXlzW2kyXTtcbiAgICAgICAgaWYgKGRlc2NbcHJvcF0uZ2V0KSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlLCBwcm9wLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjW3Byb3BdLmVudW1lcmFibGUsXG4gICAgICAgICAgICBnZXQ6IGRlc2NbcHJvcF0uZ2V0LmJpbmQocDIpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHAyO1xufVxuZnVuY3Rpb24gaXNXcmFwcGFibGUob2JqKSB7XG4gIGxldCBwcm90bztcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgKG9ialskUFJPWFldIHx8ICEocHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSkgfHwgcHJvdG8gPT09IE9iamVjdC5wcm90b3R5cGUgfHwgQXJyYXkuaXNBcnJheShvYmopKTtcbn1cbmZ1bmN0aW9uIHVud3JhcChpdGVtLCBzZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSB7XG4gIGxldCByZXN1bHQsIHVud3JhcHBlZCwgdiwgcHJvcDtcbiAgaWYgKHJlc3VsdCA9IGl0ZW0gIT0gbnVsbCAmJiBpdGVtWyRSQVddKSByZXR1cm4gcmVzdWx0O1xuICBpZiAoIWlzV3JhcHBhYmxlKGl0ZW0pIHx8IHNldC5oYXMoaXRlbSkpIHJldHVybiBpdGVtO1xuICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgIGlmIChPYmplY3QuaXNGcm96ZW4oaXRlbSkpIGl0ZW0gPSBpdGVtLnNsaWNlKDApO1xuICAgIGVsc2Ugc2V0LmFkZChpdGVtKTtcbiAgICBmb3IgKGxldCBpMiA9IDAsIGwyID0gaXRlbS5sZW5ndGg7IGkyIDwgbDI7IGkyKyspIHtcbiAgICAgIHYgPSBpdGVtW2kyXTtcbiAgICAgIGlmICgodW53cmFwcGVkID0gdW53cmFwKHYsIHNldCkpICE9PSB2KSBpdGVtW2kyXSA9IHVud3JhcHBlZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKE9iamVjdC5pc0Zyb3plbihpdGVtKSkgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pO1xuICAgIGVsc2Ugc2V0LmFkZChpdGVtKTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaXRlbSksIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhpdGVtKTtcbiAgICBmb3IgKGxldCBpMiA9IDAsIGwyID0ga2V5cy5sZW5ndGg7IGkyIDwgbDI7IGkyKyspIHtcbiAgICAgIHByb3AgPSBrZXlzW2kyXTtcbiAgICAgIGlmIChkZXNjW3Byb3BdLmdldCkgY29udGludWU7XG4gICAgICB2ID0gaXRlbVtwcm9wXTtcbiAgICAgIGlmICgodW53cmFwcGVkID0gdW53cmFwKHYsIHNldCkpICE9PSB2KSBpdGVtW3Byb3BdID0gdW53cmFwcGVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVzKHRhcmdldCwgc3ltYm9sKSB7XG4gIGxldCBub2RlcyA9IHRhcmdldFtzeW1ib2xdO1xuICBpZiAoIW5vZGVzKSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBzeW1ib2wsIHtcbiAgICB2YWx1ZTogbm9kZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKVxuICB9KTtcbiAgcmV0dXJuIG5vZGVzO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZShub2RlcywgcHJvcGVydHksIHZhbHVlKSB7XG4gIGlmIChub2Rlc1twcm9wZXJ0eV0pIHJldHVybiBub2Rlc1twcm9wZXJ0eV07XG4gIGNvbnN0IFtzMiwgc2V0XSA9IGNyZWF0ZVNpZ25hbCh2YWx1ZSwge1xuICAgIGVxdWFsczogZmFsc2UsXG4gICAgaW50ZXJuYWw6IHRydWVcbiAgfSk7XG4gIHMyLiQgPSBzZXQ7XG4gIHJldHVybiBub2Rlc1twcm9wZXJ0eV0gPSBzMjtcbn1cbmZ1bmN0aW9uIHByb3h5RGVzY3JpcHRvciQxKHRhcmdldCwgcHJvcGVydHkpIHtcbiAgY29uc3QgZGVzYyA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHkpO1xuICBpZiAoIWRlc2MgfHwgZGVzYy5nZXQgfHwgIWRlc2MuY29uZmlndXJhYmxlIHx8IHByb3BlcnR5ID09PSAkUFJPWFkgfHwgcHJvcGVydHkgPT09ICROT0RFKSByZXR1cm4gZGVzYztcbiAgZGVsZXRlIGRlc2MudmFsdWU7XG4gIGRlbGV0ZSBkZXNjLndyaXRhYmxlO1xuICBkZXNjLmdldCA9ICgpID0+IHRhcmdldFskUFJPWFldW3Byb3BlcnR5XTtcbiAgcmV0dXJuIGRlc2M7XG59XG5mdW5jdGlvbiB0cmFja1NlbGYodGFyZ2V0KSB7XG4gIGdldExpc3RlbmVyKCkgJiYgZ2V0Tm9kZShnZXROb2Rlcyh0YXJnZXQsICROT0RFKSwgJFNFTEYpKCk7XG59XG5mdW5jdGlvbiBvd25LZXlzKHRhcmdldCkge1xuICB0cmFja1NlbGYodGFyZ2V0KTtcbiAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xufVxuY29uc3QgcHJveHlUcmFwcyQxID0ge1xuICBnZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAocHJvcGVydHkgPT09ICRSQVcpIHJldHVybiB0YXJnZXQ7XG4gICAgaWYgKHByb3BlcnR5ID09PSAkUFJPWFkpIHJldHVybiByZWNlaXZlcjtcbiAgICBpZiAocHJvcGVydHkgPT09ICRUUkFDSykge1xuICAgICAgdHJhY2tTZWxmKHRhcmdldCk7XG4gICAgICByZXR1cm4gcmVjZWl2ZXI7XG4gICAgfVxuICAgIGNvbnN0IG5vZGVzID0gZ2V0Tm9kZXModGFyZ2V0LCAkTk9ERSk7XG4gICAgY29uc3QgdHJhY2tlZCA9IG5vZGVzW3Byb3BlcnR5XTtcbiAgICBsZXQgdmFsdWUgPSB0cmFja2VkID8gdHJhY2tlZCgpIDogdGFyZ2V0W3Byb3BlcnR5XTtcbiAgICBpZiAocHJvcGVydHkgPT09ICROT0RFIHx8IHByb3BlcnR5ID09PSAkSEFTIHx8IHByb3BlcnR5ID09PSBcIl9fcHJvdG9fX1wiKSByZXR1cm4gdmFsdWU7XG4gICAgaWYgKCF0cmFja2VkKSB7XG4gICAgICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgIGlmIChnZXRMaXN0ZW5lcigpICYmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIiB8fCB0YXJnZXQuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSAmJiAhKGRlc2MgJiYgZGVzYy5nZXQpKSB2YWx1ZSA9IGdldE5vZGUobm9kZXMsIHByb3BlcnR5LCB2YWx1ZSkoKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzV3JhcHBhYmxlKHZhbHVlKSA/IHdyYXAkMSh2YWx1ZSkgOiB2YWx1ZTtcbiAgfSxcbiAgaGFzKHRhcmdldCwgcHJvcGVydHkpIHtcbiAgICBpZiAocHJvcGVydHkgPT09ICRSQVcgfHwgcHJvcGVydHkgPT09ICRQUk9YWSB8fCBwcm9wZXJ0eSA9PT0gJFRSQUNLIHx8IHByb3BlcnR5ID09PSAkTk9ERSB8fCBwcm9wZXJ0eSA9PT0gJEhBUyB8fCBwcm9wZXJ0eSA9PT0gXCJfX3Byb3RvX19cIikgcmV0dXJuIHRydWU7XG4gICAgZ2V0TGlzdGVuZXIoKSAmJiBnZXROb2RlKGdldE5vZGVzKHRhcmdldCwgJEhBUyksIHByb3BlcnR5KSgpO1xuICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0YXJnZXQ7XG4gIH0sXG4gIHNldCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZGVsZXRlUHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIG93bktleXMsXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogcHJveHlEZXNjcmlwdG9yJDFcbn07XG5mdW5jdGlvbiBzZXRQcm9wZXJ0eShzdGF0ZSwgcHJvcGVydHksIHZhbHVlLCBkZWxldGluZyA9IGZhbHNlKSB7XG4gIGlmICghZGVsZXRpbmcgJiYgc3RhdGVbcHJvcGVydHldID09PSB2YWx1ZSkgcmV0dXJuO1xuICBjb25zdCBwcmV2ID0gc3RhdGVbcHJvcGVydHldLCBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgZGVsZXRlIHN0YXRlW3Byb3BlcnR5XTtcbiAgICBpZiAoc3RhdGVbJEhBU10gJiYgc3RhdGVbJEhBU11bcHJvcGVydHldICYmIHByZXYgIT09IHZvaWQgMCkgc3RhdGVbJEhBU11bcHJvcGVydHldLiQoKTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICBpZiAoc3RhdGVbJEhBU10gJiYgc3RhdGVbJEhBU11bcHJvcGVydHldICYmIHByZXYgPT09IHZvaWQgMCkgc3RhdGVbJEhBU11bcHJvcGVydHldLiQoKTtcbiAgfVxuICBsZXQgbm9kZXMgPSBnZXROb2RlcyhzdGF0ZSwgJE5PREUpLCBub2RlO1xuICBpZiAobm9kZSA9IGdldE5vZGUobm9kZXMsIHByb3BlcnR5LCBwcmV2KSkgbm9kZS4kKCgpID0+IHZhbHVlKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RhdGUpICYmIHN0YXRlLmxlbmd0aCAhPT0gbGVuKSB7XG4gICAgZm9yIChsZXQgaTIgPSBzdGF0ZS5sZW5ndGg7IGkyIDwgbGVuOyBpMisrKSAobm9kZSA9IG5vZGVzW2kyXSkgJiYgbm9kZS4kKCk7XG4gICAgKG5vZGUgPSBnZXROb2RlKG5vZGVzLCBcImxlbmd0aFwiLCBsZW4pKSAmJiBub2RlLiQoc3RhdGUubGVuZ3RoKTtcbiAgfVxuICAobm9kZSA9IG5vZGVzWyRTRUxGXSkgJiYgbm9kZS4kKCk7XG59XG5mdW5jdGlvbiBtZXJnZVN0b3JlTm9kZShzdGF0ZSwgdmFsdWUpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGtleXMubGVuZ3RoOyBpMiArPSAxKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpMl07XG4gICAgc2V0UHJvcGVydHkoc3RhdGUsIGtleSwgdmFsdWVba2V5XSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUFycmF5KGN1cnJlbnQsIG5leHQpIHtcbiAgaWYgKHR5cGVvZiBuZXh0ID09PSBcImZ1bmN0aW9uXCIpIG5leHQgPSBuZXh0KGN1cnJlbnQpO1xuICBuZXh0ID0gdW53cmFwKG5leHQpO1xuICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIGlmIChjdXJyZW50ID09PSBuZXh0KSByZXR1cm47XG4gICAgbGV0IGkyID0gMCwgbGVuID0gbmV4dC5sZW5ndGg7XG4gICAgZm9yICg7IGkyIDwgbGVuOyBpMisrKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG5leHRbaTJdO1xuICAgICAgaWYgKGN1cnJlbnRbaTJdICE9PSB2YWx1ZSkgc2V0UHJvcGVydHkoY3VycmVudCwgaTIsIHZhbHVlKTtcbiAgICB9XG4gICAgc2V0UHJvcGVydHkoY3VycmVudCwgXCJsZW5ndGhcIiwgbGVuKTtcbiAgfSBlbHNlIG1lcmdlU3RvcmVOb2RlKGN1cnJlbnQsIG5leHQpO1xufVxuZnVuY3Rpb24gdXBkYXRlUGF0aChjdXJyZW50LCBwYXRoLCB0cmF2ZXJzZWQgPSBbXSkge1xuICBsZXQgcGFydCwgcHJldiA9IGN1cnJlbnQ7XG4gIGlmIChwYXRoLmxlbmd0aCA+IDEpIHtcbiAgICBwYXJ0ID0gcGF0aC5zaGlmdCgpO1xuICAgIGNvbnN0IHBhcnRUeXBlID0gdHlwZW9mIHBhcnQsIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGN1cnJlbnQpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnQpKSB7XG4gICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgcGFydC5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgdXBkYXRlUGF0aChjdXJyZW50LCBbcGFydFtpMl1dLmNvbmNhdChwYXRoKSwgdHJhdmVyc2VkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkgJiYgcGFydFR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGN1cnJlbnQubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIGlmIChwYXJ0KGN1cnJlbnRbaTJdLCBpMikpIHVwZGF0ZVBhdGgoY3VycmVudCwgW2kyXS5jb25jYXQocGF0aCksIHRyYXZlcnNlZCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChpc0FycmF5ICYmIHBhcnRUeXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZyb20gPSAwLFxuICAgICAgICB0byA9IGN1cnJlbnQubGVuZ3RoIC0gMSxcbiAgICAgICAgYnkgPSAxXG4gICAgICB9ID0gcGFydDtcbiAgICAgIGZvciAobGV0IGkyID0gZnJvbTsgaTIgPD0gdG87IGkyICs9IGJ5KSB7XG4gICAgICAgIHVwZGF0ZVBhdGgoY3VycmVudCwgW2kyXS5jb25jYXQocGF0aCksIHRyYXZlcnNlZCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChwYXRoLmxlbmd0aCA+IDEpIHtcbiAgICAgIHVwZGF0ZVBhdGgoY3VycmVudFtwYXJ0XSwgcGF0aCwgW3BhcnRdLmNvbmNhdCh0cmF2ZXJzZWQpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJldiA9IGN1cnJlbnRbcGFydF07XG4gICAgdHJhdmVyc2VkID0gW3BhcnRdLmNvbmNhdCh0cmF2ZXJzZWQpO1xuICB9XG4gIGxldCB2YWx1ZSA9IHBhdGhbMF07XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhbHVlID0gdmFsdWUocHJldiwgdHJhdmVyc2VkKTtcbiAgICBpZiAodmFsdWUgPT09IHByZXYpIHJldHVybjtcbiAgfVxuICBpZiAocGFydCA9PT0gdm9pZCAwICYmIHZhbHVlID09IHZvaWQgMCkgcmV0dXJuO1xuICB2YWx1ZSA9IHVud3JhcCh2YWx1ZSk7XG4gIGlmIChwYXJ0ID09PSB2b2lkIDAgfHwgaXNXcmFwcGFibGUocHJldikgJiYgaXNXcmFwcGFibGUodmFsdWUpICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIG1lcmdlU3RvcmVOb2RlKHByZXYsIHZhbHVlKTtcbiAgfSBlbHNlIHNldFByb3BlcnR5KGN1cnJlbnQsIHBhcnQsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKC4uLltzdG9yZSwgb3B0aW9uc10pIHtcbiAgY29uc3QgdW53cmFwcGVkU3RvcmUgPSB1bndyYXAoc3RvcmUgfHwge30pO1xuICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSh1bndyYXBwZWRTdG9yZSk7XG4gIGNvbnN0IHdyYXBwZWRTdG9yZSA9IHdyYXAkMSh1bndyYXBwZWRTdG9yZSk7XG4gIGZ1bmN0aW9uIHNldFN0b3JlKC4uLmFyZ3MpIHtcbiAgICBiYXRjaCgoKSA9PiB7XG4gICAgICBpc0FycmF5ICYmIGFyZ3MubGVuZ3RoID09PSAxID8gdXBkYXRlQXJyYXkodW53cmFwcGVkU3RvcmUsIGFyZ3NbMF0pIDogdXBkYXRlUGF0aCh1bndyYXBwZWRTdG9yZSwgYXJncyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFt3cmFwcGVkU3RvcmUsIHNldFN0b3JlXTtcbn1cbmNvbnN0IGRlZmF1bHRMaWdodENvbG9yc1NldCA9IHtcbiAgY29uc3RhbnQ6IHtcbiAgICBibGFjazogXCIjMDAwMDAwXCIsXG4gICAgd2hpdGU6IFwiI0ZGRkZGRlwiXG4gIH0sXG4gIGNvbm5lY3RCdXR0b246IHtcbiAgICBiYWNrZ3JvdW5kOiBcIiMwMDk4RUFcIixcbiAgICBmb3JlZ3JvdW5kOiBcIiNGRkZGRkZcIlxuICB9LFxuICBhY2NlbnQ6IFwiIzAwOThFQVwiLFxuICB0ZWxlZ3JhbUJ1dHRvbjogXCIjMDA5OEVBXCIsXG4gIGljb246IHtcbiAgICBwcmltYXJ5OiBcIiMwRjBGMEZcIixcbiAgICBzZWNvbmRhcnk6IFwiIzdBODk5OVwiLFxuICAgIHRlcnRpYXJ5OiBcIiNDMUNBRDJcIixcbiAgICBzdWNjZXNzOiBcIiMyOUNDNkFcIixcbiAgICBlcnJvcjogXCIjRjVBNzNCXCJcbiAgfSxcbiAgYmFja2dyb3VuZDoge1xuICAgIHByaW1hcnk6IFwiI0ZGRkZGRlwiLFxuICAgIHNlY29uZGFyeTogXCIjRjFGM0Y1XCIsXG4gICAgc2VnbWVudDogXCIjRkZGRkZGXCIsXG4gICAgdGludDogXCIjRjFGM0Y1XCIsXG4gICAgcXI6IFwiI0YxRjNGNVwiXG4gIH0sXG4gIHRleHQ6IHtcbiAgICBwcmltYXJ5OiBcIiMwRjBGMEZcIixcbiAgICBzZWNvbmRhcnk6IFwiIzZBNzc4NVwiXG4gIH1cbn07XG5jb25zdCBkZWZhdWx0RGFya0NvbG9yc1NldCA9IHtcbiAgY29uc3RhbnQ6IHtcbiAgICBibGFjazogXCIjMDAwMDAwXCIsXG4gICAgd2hpdGU6IFwiI0ZGRkZGRlwiXG4gIH0sXG4gIGNvbm5lY3RCdXR0b246IHtcbiAgICBiYWNrZ3JvdW5kOiBcIiMwMDk4RUFcIixcbiAgICBmb3JlZ3JvdW5kOiBcIiNGRkZGRkZcIlxuICB9LFxuICBhY2NlbnQ6IFwiI0U1RTVFQVwiLFxuICB0ZWxlZ3JhbUJ1dHRvbjogXCIjMzFBNkY1XCIsXG4gIGljb246IHtcbiAgICBwcmltYXJ5OiBcIiNFNUU1RUFcIixcbiAgICBzZWNvbmRhcnk6IFwiIzkwOTA5OVwiLFxuICAgIHRlcnRpYXJ5OiBcIiM0MzQzNDdcIixcbiAgICBzdWNjZXNzOiBcIiMyOUNDNkFcIixcbiAgICBlcnJvcjogXCIjRjVBNzNCXCJcbiAgfSxcbiAgYmFja2dyb3VuZDoge1xuICAgIHByaW1hcnk6IFwiIzEyMTIxNFwiLFxuICAgIHNlY29uZGFyeTogXCIjMTgxODFBXCIsXG4gICAgc2VnbWVudDogXCIjMjYyNjI5XCIsXG4gICAgdGludDogXCIjMjIyMjI0XCIsXG4gICAgcXI6IFwiI0ZGRkZGRlwiXG4gIH0sXG4gIHRleHQ6IHtcbiAgICBwcmltYXJ5OiBcIiNFNUU1RUFcIixcbiAgICBzZWNvbmRhcnk6IFwiIzdEN0Q4NVwiXG4gIH1cbn07XG4vKiFcbiAqIGlzLXBsYWluLW9iamVjdCA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtcGxhaW4tb2JqZWN0PlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QobzIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvMikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG8yKSB7XG4gIHZhciBjdG9yLCBwcm90O1xuICBpZiAoaXNPYmplY3QobzIpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICBjdG9yID0gbzIuY29uc3RydWN0b3I7XG4gIGlmIChjdG9yID09PSB2b2lkIDApIHJldHVybiB0cnVlO1xuICBwcm90ID0gY3Rvci5wcm90b3R5cGU7XG4gIGlmIChpc09iamVjdChwcm90KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgaWYgKHByb3QuaGFzT3duUHJvcGVydHkoXCJpc1Byb3RvdHlwZU9mXCIpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25zLCBkZWZhdWx0T3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICByZXR1cm4gZGVmYXVsdE9wdGlvbnM7XG4gIH1cbiAgY29uc3Qgb3ZlcndyaXRlTWVyZ2UgPSAoXywgc291cmNlQXJyYXksIF9fKSA9PiBzb3VyY2VBcnJheTtcbiAgcmV0dXJuIGRlZXBtZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0aW9ucywge1xuICAgIGFycmF5TWVyZ2U6IG92ZXJ3cml0ZU1lcmdlLFxuICAgIGlzTWVyZ2VhYmxlT2JqZWN0OiBpc1BsYWluT2JqZWN0XG4gIH0pO1xufVxuY29uc3QgW3RoZW1lU3RhdGUsIHNldFRoZW1lU3RhdGVdID0gY3JlYXRlU3RvcmUoe1xuICB0aGVtZTogVEhFTUUuTElHSFQsXG4gIGNvbG9yczogZGVmYXVsdExpZ2h0Q29sb3JzU2V0LFxuICBib3JkZXJSYWRpdXM6IFwibVwiXG59KTtcbmNvbnN0IHRoZW1lQ29sb3JzTWFwcGluZ0RlZmF1bHQgPSB7XG4gIFtUSEVNRS5MSUdIVF06IGRlZmF1bHRMaWdodENvbG9yc1NldCxcbiAgW1RIRU1FLkRBUktdOiBkZWZhdWx0RGFya0NvbG9yc1NldFxufTtcbmNvbnN0IHRoZW1lQ3VzdG9tQ29sb3JzID0ge1xuICBbVEhFTUUuTElHSFRdOiB2b2lkIDAsXG4gIFtUSEVNRS5EQVJLXTogdm9pZCAwXG59O1xuZnVuY3Rpb24gc2V0VGhlbWUodGhlbWUsIGNvbG9yc1NldCkge1xuICBpZiAoY29sb3JzU2V0KSB7XG4gICAgdGhlbWVDdXN0b21Db2xvcnNbVEhFTUUuREFSS10gPSBtZXJnZU9wdGlvbnMoXG4gICAgICBjb2xvcnNTZXRbVEhFTUUuREFSS10sXG4gICAgICB0aGVtZUN1c3RvbUNvbG9yc1tUSEVNRS5EQVJLXVxuICAgICk7XG4gICAgdGhlbWVDdXN0b21Db2xvcnNbVEhFTUUuTElHSFRdID0gbWVyZ2VPcHRpb25zKFxuICAgICAgY29sb3JzU2V0W1RIRU1FLkxJR0hUXSxcbiAgICAgIHRoZW1lQ3VzdG9tQ29sb3JzW1RIRU1FLkxJR0hUXVxuICAgICk7XG4gIH1cbiAgc2V0VGhlbWVTdGF0ZSh7XG4gICAgdGhlbWUsXG4gICAgY29sb3JzOiBtZXJnZU9wdGlvbnModGhlbWVDdXN0b21Db2xvcnNbdGhlbWVdLCB0aGVtZUNvbG9yc01hcHBpbmdEZWZhdWx0W3RoZW1lXSlcbiAgfSk7XG59XG5mdW5jdGlvbiBzZXRCb3JkZXJSYWRpdXMoYm9yZGVyUmFkaXVzKSB7XG4gIHNldFRoZW1lU3RhdGUoeyBib3JkZXJSYWRpdXMgfSk7XG59XG5mdW5jdGlvbiBzZXRDb2xvcnMoY29sb3JzU2V0KSB7XG4gIHRoZW1lQ3VzdG9tQ29sb3JzW1RIRU1FLkRBUktdID0gbWVyZ2VPcHRpb25zKFxuICAgIGNvbG9yc1NldFtUSEVNRS5EQVJLXSxcbiAgICB0aGVtZUN1c3RvbUNvbG9yc1tUSEVNRS5EQVJLXVxuICApO1xuICB0aGVtZUN1c3RvbUNvbG9yc1tUSEVNRS5MSUdIVF0gPSBtZXJnZU9wdGlvbnMoXG4gICAgY29sb3JzU2V0W1RIRU1FLkxJR0hUXSxcbiAgICB0aGVtZUN1c3RvbUNvbG9yc1tUSEVNRS5MSUdIVF1cbiAgKTtcbiAgc2V0VGhlbWVTdGF0ZSgoc3RhdGUpID0+ICh7XG4gICAgY29sb3JzOiBtZXJnZU9wdGlvbnMoXG4gICAgICB0aGVtZUN1c3RvbUNvbG9yc1tzdGF0ZS50aGVtZV0sXG4gICAgICB0aGVtZUNvbG9yc01hcHBpbmdEZWZhdWx0W3N0YXRlLnRoZW1lXVxuICAgIClcbiAgfSkpO1xufVxuY29uc3QgSW1hZ2VQbGFjZWhvbGRlciA9IHN0eWxlZC5kaXZgXG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnNlY29uZGFyeX07XG5gO1xuY29uc3QgSW1hZ2UgPSAocHJvcHMpID0+IHtcbiAgbGV0IGltZ1JlZjtcbiAgY29uc3QgW2ltYWdlLCBzZXRJbWFnZV0gPSBjcmVhdGVTaWduYWwobnVsbCk7XG4gIGNyZWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaW1nID0gbmV3IHdpbmRvdy5JbWFnZSgpO1xuICAgIGltZy5zcmMgPSBwcm9wcy5zcmM7XG4gICAgaW1nLmFsdCA9IHByb3BzLmFsdCB8fCBcIlwiO1xuICAgIGltZy5zZXRBdHRyaWJ1dGUoXCJkcmFnZ2FibGVcIiwgXCJmYWxzZVwiKTtcbiAgICBpZiAocHJvcHMuY2xhc3MpIHtcbiAgICAgIGltZy5jbGFzc0xpc3QuYWRkKHByb3BzLmNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGltZy5jb21wbGV0ZSkge1xuICAgICAgcmV0dXJuIHNldEltYWdlKGltZyk7XG4gICAgfVxuICAgIGltZy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiBzZXRJbWFnZShpbWcpKTtcbiAgICByZXR1cm4gKCkgPT4gaW1nLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHNldEltYWdlKGltZykpO1xuICB9KTtcbiAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgIGdldCB3aGVuKCkge1xuICAgICAgcmV0dXJuIGltYWdlKCk7XG4gICAgfSxcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gaW1hZ2UoKTtcbiAgICB9XG4gIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgIGdldCB3aGVuKCkge1xuICAgICAgcmV0dXJuICFpbWFnZSgpO1xuICAgIH0sXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChJbWFnZVBsYWNlaG9sZGVyLCB7XG4gICAgICAgIGdldCBbXCJjbGFzc1wiXSgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcHMuY2xhc3M7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZihyJCkge1xuICAgICAgICAgIHZhciBfcmVmJCA9IGltZ1JlZjtcbiAgICAgICAgICB0eXBlb2YgX3JlZiQgPT09IFwiZnVuY3Rpb25cIiA/IF9yZWYkKHIkKSA6IGltZ1JlZiA9IHIkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pXTtcbn07XG5sZXQgaW5pdFBhcmFtcyA9IHt9O1xudHJ5IHtcbiAgbGV0IGxvY2F0aW9uSGFzaCA9IGxvY2F0aW9uLmhhc2gudG9TdHJpbmcoKTtcbiAgaW5pdFBhcmFtcyA9IHVybFBhcnNlSGFzaFBhcmFtcyhsb2NhdGlvbkhhc2gpO1xufSBjYXRjaCAoZTIpIHtcbn1cbnRyeSB7XG4gIGNvbnN0IGxhdW5jaFBhcmFtc1N0b3JhZ2VLZXkgPSBcInRvbi1jb25uZWN0LXNlc3Npb25fc3RvcmFnZV9sYXVuY2hQYXJhbXNcIjtcbiAgaWYgKE9iamVjdC5lbnRyaWVzKGluaXRQYXJhbXMpLmxlbmd0aCA+IDApIHtcbiAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKGxhdW5jaFBhcmFtc1N0b3JhZ2VLZXksIEpTT04uc3RyaW5naWZ5KGluaXRQYXJhbXMpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzYXZlZEluaXRQYXJhbXMgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKGxhdW5jaFBhcmFtc1N0b3JhZ2VLZXkpO1xuICAgIGlmIChzYXZlZEluaXRQYXJhbXMpIHtcbiAgICAgIGluaXRQYXJhbXMgPSBKU09OLnBhcnNlKHNhdmVkSW5pdFBhcmFtcyk7XG4gICAgfVxuICB9XG59IGNhdGNoIChlMikge1xufVxubGV0IHRtYVBsYXRmb3JtID0gXCJ1bmtub3duXCI7XG5pZiAoaW5pdFBhcmFtcyA9PSBudWxsID8gdm9pZCAwIDogaW5pdFBhcmFtcy50Z1dlYkFwcFBsYXRmb3JtKSB7XG4gIHRtYVBsYXRmb3JtID0gKF9hID0gaW5pdFBhcmFtcy50Z1dlYkFwcFBsYXRmb3JtKSAhPSBudWxsID8gX2EgOiBcInVua25vd25cIjtcbn1cbmlmICh0bWFQbGF0Zm9ybSA9PT0gXCJ1bmtub3duXCIpIHtcbiAgY29uc3Qgd2luZG93MiA9IGdldFdpbmRvdyQxKCk7XG4gIHRtYVBsYXRmb3JtID0gKF9kID0gKF9jID0gKF9iID0gd2luZG93MiA9PSBudWxsID8gdm9pZCAwIDogd2luZG93Mi5UZWxlZ3JhbSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLldlYkFwcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnBsYXRmb3JtKSAhPSBudWxsID8gX2QgOiBcInVua25vd25cIjtcbn1cbmxldCB3ZWJBcHBWZXJzaW9uID0gXCI2LjBcIjtcbmlmIChpbml0UGFyYW1zID09IG51bGwgPyB2b2lkIDAgOiBpbml0UGFyYW1zLnRnV2ViQXBwVmVyc2lvbikge1xuICB3ZWJBcHBWZXJzaW9uID0gaW5pdFBhcmFtcy50Z1dlYkFwcFZlcnNpb247XG59XG5pZiAoIXdlYkFwcFZlcnNpb24pIHtcbiAgY29uc3Qgd2luZG93MiA9IGdldFdpbmRvdyQxKCk7XG4gIHdlYkFwcFZlcnNpb24gPSAoX2cgPSAoX2YgPSAoX2UgPSB3aW5kb3cyID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cyLlRlbGVncmFtKSA9PSBudWxsID8gdm9pZCAwIDogX2UuV2ViQXBwKSA9PSBudWxsID8gdm9pZCAwIDogX2YudmVyc2lvbikgIT0gbnVsbCA/IF9nIDogXCI2LjBcIjtcbn1cbmNvbnN0IGluaXREYXRhUmF3ID0gaW5pdFBhcmFtcyA9PSBudWxsID8gdm9pZCAwIDogaW5pdFBhcmFtcy50Z1dlYkFwcERhdGE7XG5sZXQgdGVsZWdyYW1Vc2VyID0gdm9pZCAwO1xudHJ5IHtcbiAgaWYgKGluaXREYXRhUmF3KSB7XG4gICAgbGV0IGluaXREYXRhID0gdXJsUGFyc2VRdWVyeVN0cmluZyhpbml0RGF0YVJhdyk7XG4gICAgbGV0IHVzZXJSYXcgPSBpbml0RGF0YS51c2VyO1xuICAgIGlmICh1c2VyUmF3KSB7XG4gICAgICBsZXQgdXNlciA9IEpTT04ucGFyc2UodXNlclJhdyk7XG4gICAgICBpZiAodHlwZW9mIHVzZXIuaWQgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHVzZXIuaXNfcHJlbWl1bSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgdGVsZWdyYW1Vc2VyID0ge1xuICAgICAgICAgIGlkOiB1c2VyLmlkLFxuICAgICAgICAgIGlzUHJlbWl1bTogdXNlci5pc19wcmVtaXVtXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59IGNhdGNoIChlMikge1xufVxuZnVuY3Rpb24gZ2V0VGdVc2VyKCkge1xuICByZXR1cm4gdGVsZWdyYW1Vc2VyO1xufVxuZnVuY3Rpb24gaXNUbWFQbGF0Zm9ybSguLi5wbGF0Zm9ybXMpIHtcbiAgcmV0dXJuIHBsYXRmb3Jtcy5pbmNsdWRlcyh0bWFQbGF0Zm9ybSk7XG59XG5mdW5jdGlvbiBpc0luVE1BKCkge1xuICB2YXIgX2EyO1xuICByZXR1cm4gdG1hUGxhdGZvcm0gIT09IFwidW5rbm93blwiIHx8ICEhKChfYTIgPSBnZXRXaW5kb3ckMSgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLlRlbGVncmFtV2Vidmlld1Byb3h5KTtcbn1cbmZ1bmN0aW9uIGlzSW5UZWxlZ3JhbUJyb3dzZXIoKSB7XG4gIHZhciBfYTI7XG4gIGNvbnN0IGlzVGVsZWdyYW1XZWJ2aWV3ID0gISEoKF9hMiA9IGdldFdpbmRvdyQxKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuVGVsZWdyYW1XZWJ2aWV3KTtcbiAgcmV0dXJuIChpc0luVE1BKCkgfHwgaXNUZWxlZ3JhbVdlYnZpZXcpICYmIHRtYVBsYXRmb3JtID09PSBcInVua25vd25cIjtcbn1cbmZ1bmN0aW9uIHNlbmRFeHBhbmQoKSB7XG4gIHBvc3RFdmVudChcIndlYl9hcHBfZXhwYW5kXCIsIHt9KTtcbn1cbmZ1bmN0aW9uIHNlbmRPcGVuVGVsZWdyYW1MaW5rKGxpbmssIGZhbGxiYWNrKSB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwobGluayk7XG4gIGlmICh1cmwucHJvdG9jb2wgIT09IFwiaHR0cDpcIiAmJiB1cmwucHJvdG9jb2wgIT09IFwiaHR0cHM6XCIpIHtcbiAgICBpZiAoZmFsbGJhY2spIHtcbiAgICAgIHJldHVybiBmYWxsYmFjaygpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdFVJRXJyb3IoYFVybCBwcm90b2NvbCBpcyBub3Qgc3VwcG9ydGVkOiAke3VybH1gKTtcbiAgfVxuICBpZiAodXJsLmhvc3RuYW1lICE9PSBcInQubWVcIikge1xuICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGZhbGxiYWNrKCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBUb25Db25uZWN0VUlFcnJvcihgVXJsIGhvc3QgaXMgbm90IHN1cHBvcnRlZDogJHt1cmx9YCk7XG4gIH1cbiAgY29uc3QgcGF0aEZ1bGwgPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoO1xuICBpZiAoaXNJZnJhbWUoKSB8fCB2ZXJzaW9uQXRMZWFzdChcIjYuMVwiKSkge1xuICAgIHNldExhc3RPcGVuZWRMaW5rKHsgbGluazogcGF0aEZ1bGwsIHR5cGU6IFwidGdfbGlua1wiIH0pO1xuICAgIHBvc3RFdmVudChcIndlYl9hcHBfb3Blbl90Z19saW5rXCIsIHsgcGF0aF9mdWxsOiBwYXRoRnVsbCB9KTtcbiAgfSBlbHNlIHtcbiAgICBvcGVuTGlua0JsYW5rKFwiaHR0cHM6Ly90Lm1lXCIgKyBwYXRoRnVsbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzSWZyYW1lKCkge1xuICB0cnkge1xuICAgIGNvbnN0IHdpbmRvdzIgPSBnZXRXaW5kb3ckMSgpO1xuICAgIGlmICghd2luZG93Mikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gd2luZG93Mi5wYXJlbnQgIT0gbnVsbCAmJiB3aW5kb3cyICE9PSB3aW5kb3cyLnBhcmVudDtcbiAgfSBjYXRjaCAoZTIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHBvc3RFdmVudChldmVudFR5cGUsIGV2ZW50RGF0YSkge1xuICB0cnkge1xuICAgIGNvbnN0IHdpbmRvdzIgPSBnZXRXaW5kb3ckMSgpO1xuICAgIGlmICghd2luZG93Mikge1xuICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RVSUVycm9yKGBDYW4ndCBwb3N0IGV2ZW50IHRvIHBhcmVudCB3aW5kb3c6IHdpbmRvdyBpcyBub3QgZGVmaW5lZGApO1xuICAgIH1cbiAgICBpZiAod2luZG93Mi5UZWxlZ3JhbVdlYnZpZXdQcm94eSAhPT0gdm9pZCAwKSB7XG4gICAgICBsb2dEZWJ1ZyhcInBvc3RFdmVudFwiLCBldmVudFR5cGUsIGV2ZW50RGF0YSk7XG4gICAgICB3aW5kb3cyLlRlbGVncmFtV2Vidmlld1Byb3h5LnBvc3RFdmVudChldmVudFR5cGUsIEpTT04uc3RyaW5naWZ5KGV2ZW50RGF0YSkpO1xuICAgIH0gZWxzZSBpZiAod2luZG93Mi5leHRlcm5hbCAmJiBcIm5vdGlmeVwiIGluIHdpbmRvdzIuZXh0ZXJuYWwpIHtcbiAgICAgIGxvZ0RlYnVnKFwicG9zdEV2ZW50XCIsIGV2ZW50VHlwZSwgZXZlbnREYXRhKTtcbiAgICAgIHdpbmRvdzIuZXh0ZXJuYWwubm90aWZ5KEpTT04uc3RyaW5naWZ5KHsgZXZlbnRUeXBlLCBldmVudERhdGEgfSkpO1xuICAgIH0gZWxzZSBpZiAoaXNJZnJhbWUoKSkge1xuICAgICAgY29uc3QgdHJ1c3RlZFRhcmdldCA9IFwiKlwiO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KHsgZXZlbnRUeXBlLCBldmVudERhdGEgfSk7XG4gICAgICBsb2dEZWJ1ZyhcInBvc3RFdmVudFwiLCBldmVudFR5cGUsIGV2ZW50RGF0YSk7XG4gICAgICB3aW5kb3cyLnBhcmVudC5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cnVzdGVkVGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RVSUVycm9yKGBDYW4ndCBwb3N0IGV2ZW50IHRvIFRNQWApO1xuICAgIH1cbiAgfSBjYXRjaCAoZTIpIHtcbiAgICBsb2dFcnJvcihgQ2FuJ3QgcG9zdCBldmVudCB0byBwYXJlbnQgd2luZG93OiAke2UyfWApO1xuICB9XG59XG5mdW5jdGlvbiB1cmxQYXJzZUhhc2hQYXJhbXMobG9jYXRpb25IYXNoKSB7XG4gIGxvY2F0aW9uSGFzaCA9IGxvY2F0aW9uSGFzaC5yZXBsYWNlKC9eIy8sIFwiXCIpO1xuICBsZXQgcGFyYW1zID0ge307XG4gIGlmICghbG9jYXRpb25IYXNoLmxlbmd0aCkge1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbiAgaWYgKGxvY2F0aW9uSGFzaC5pbmRleE9mKFwiPVwiKSA8IDAgJiYgbG9jYXRpb25IYXNoLmluZGV4T2YoXCI/XCIpIDwgMCkge1xuICAgIHBhcmFtcy5fcGF0aCA9IHVybFNhZmVEZWNvZGUobG9jYXRpb25IYXNoKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG4gIGxldCBxSW5kZXggPSBsb2NhdGlvbkhhc2guaW5kZXhPZihcIj9cIik7XG4gIGlmIChxSW5kZXggPj0gMCkge1xuICAgIGxldCBwYXRoUGFyYW0gPSBsb2NhdGlvbkhhc2guc3Vic3RyKDAsIHFJbmRleCk7XG4gICAgcGFyYW1zLl9wYXRoID0gdXJsU2FmZURlY29kZShwYXRoUGFyYW0pO1xuICAgIGxvY2F0aW9uSGFzaCA9IGxvY2F0aW9uSGFzaC5zdWJzdHIocUluZGV4ICsgMSk7XG4gIH1cbiAgbGV0IHF1ZXJ5X3BhcmFtcyA9IHVybFBhcnNlUXVlcnlTdHJpbmcobG9jYXRpb25IYXNoKTtcbiAgZm9yIChsZXQgayBpbiBxdWVyeV9wYXJhbXMpIHtcbiAgICBwYXJhbXNba10gPSBxdWVyeV9wYXJhbXNba107XG4gIH1cbiAgcmV0dXJuIHBhcmFtcztcbn1cbmZ1bmN0aW9uIHVybFNhZmVEZWNvZGUodXJsZW5jb2RlZCkge1xuICB0cnkge1xuICAgIHVybGVuY29kZWQgPSB1cmxlbmNvZGVkLnJlcGxhY2UoL1xcKy9nLCBcIiUyMFwiKTtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHVybGVuY29kZWQpO1xuICB9IGNhdGNoIChlMikge1xuICAgIHJldHVybiB1cmxlbmNvZGVkO1xuICB9XG59XG5mdW5jdGlvbiB1cmxQYXJzZVF1ZXJ5U3RyaW5nKHF1ZXJ5U3RyaW5nKSB7XG4gIGxldCBwYXJhbXMgPSB7fTtcbiAgaWYgKCFxdWVyeVN0cmluZy5sZW5ndGgpIHtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG4gIGxldCBxdWVyeVN0cmluZ1BhcmFtcyA9IHF1ZXJ5U3RyaW5nLnNwbGl0KFwiJlwiKTtcbiAgbGV0IGkyLCBwYXJhbSwgcGFyYW1OYW1lLCBwYXJhbVZhbHVlO1xuICBmb3IgKGkyID0gMDsgaTIgPCBxdWVyeVN0cmluZ1BhcmFtcy5sZW5ndGg7IGkyKyspIHtcbiAgICBwYXJhbSA9IHF1ZXJ5U3RyaW5nUGFyYW1zW2kyXS5zcGxpdChcIj1cIik7XG4gICAgcGFyYW1OYW1lID0gdXJsU2FmZURlY29kZShwYXJhbVswXSk7XG4gICAgcGFyYW1WYWx1ZSA9IHBhcmFtWzFdID09IG51bGwgPyBudWxsIDogdXJsU2FmZURlY29kZShwYXJhbVsxXSk7XG4gICAgcGFyYW1zW3BhcmFtTmFtZV0gPSBwYXJhbVZhbHVlO1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59XG5mdW5jdGlvbiB2ZXJzaW9uQ29tcGFyZSh2MSwgdjIpIHtcbiAgaWYgKHR5cGVvZiB2MSAhPT0gXCJzdHJpbmdcIikgdjEgPSBcIlwiO1xuICBsZXQgdjFMaXN0ID0gdjEucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgXCJcIikuc3BsaXQoXCIuXCIpO1xuICBsZXQgdjJMaXN0ID0gdjIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgXCJcIikuc3BsaXQoXCIuXCIpO1xuICBsZXQgYTIsIGkyLCBwMSwgcDI7XG4gIGEyID0gTWF0aC5tYXgodjFMaXN0Lmxlbmd0aCwgdjJMaXN0Lmxlbmd0aCk7XG4gIGZvciAoaTIgPSAwOyBpMiA8IGEyOyBpMisrKSB7XG4gICAgcDEgPSBwYXJzZUludCh2MUxpc3RbaTJdKSB8fCAwO1xuICAgIHAyID0gcGFyc2VJbnQodjJMaXN0W2kyXSkgfHwgMDtcbiAgICBpZiAocDEgPT09IHAyKSBjb250aW51ZTtcbiAgICBpZiAocDEgPiBwMikgcmV0dXJuIDE7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gdmVyc2lvbkF0TGVhc3QodmVyKSB7XG4gIHJldHVybiB2ZXJzaW9uQ29tcGFyZSh3ZWJBcHBWZXJzaW9uLCB2ZXIpID49IDA7XG59XG5jb25zdCBtYXhXaWR0aCA9IHtcbiAgbW9iaWxlOiA0NDAsXG4gIHRhYmxldDogMTAyMFxufTtcbmZ1bmN0aW9uIGlzRGV2aWNlKGRldmljZSkge1xuICBjb25zdCB3aW5kb3cyID0gZ2V0V2luZG93JDEoKTtcbiAgaWYgKCF3aW5kb3cyKSB7XG4gICAgcmV0dXJuIGRldmljZSA9PT0gXCJkZXNrdG9wXCI7XG4gIH1cbiAgaWYgKGlzVG1hUGxhdGZvcm0oXCJ3ZWJhXCIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qgd2lkdGggPSB3aW5kb3cyLmlubmVyV2lkdGg7XG4gIHN3aXRjaCAoZGV2aWNlKSB7XG4gICAgY2FzZSBcImRlc2t0b3BcIjpcbiAgICAgIHJldHVybiB3aWR0aCA+IG1heFdpZHRoLnRhYmxldDtcbiAgICBjYXNlIFwidGFibGV0XCI6XG4gICAgICByZXR1cm4gd2lkdGggPiBtYXhXaWR0aC5tb2JpbGU7XG4gICAgZGVmYXVsdDpcbiAgICBjYXNlIFwibW9iaWxlXCI6XG4gICAgICByZXR1cm4gd2lkdGggPD0gbWF4V2lkdGgubW9iaWxlIHx8IGlzT1MoXCJpb3NcIiwgXCJhbmRyb2lkXCIsIFwiaXBhZFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gbWVkaWEoZGV2aWNlKSB7XG4gIHN3aXRjaCAoZGV2aWNlKSB7XG4gICAgY2FzZSBcIm1vYmlsZVwiOlxuICAgICAgcmV0dXJuIGBAbWVkaWEgKG1heC13aWR0aDogJHttYXhXaWR0aC5tb2JpbGV9cHgpYDtcbiAgICBjYXNlIFwidGFibGV0XCI6XG4gICAgICByZXR1cm4gYEBtZWRpYSAobWF4LXdpZHRoOiAke21heFdpZHRoLnRhYmxldH1weCkgKG1pbi13aWR0aDogJHttYXhXaWR0aC5tb2JpbGV9cHgpYDtcbiAgICBkZWZhdWx0OlxuICAgIGNhc2UgXCJkZXNrdG9wXCI6XG4gICAgICByZXR1cm4gYEBtZWRpYSAobWluLXdpZHRoOiAke21heFdpZHRoLnRhYmxldH1weClgO1xuICB9XG59XG5jb25zdCBtZWRpYVRvdWNoID0gXCJAbWVkaWEgKGhvdmVyOiBub25lKVwiO1xuY29uc3QgbWVkaWFOb3RUb3VjaCA9IFwiQG1lZGlhIG5vdCBhbGwgYW5kIChob3Zlcjogbm9uZSlcIjtcbmNvbnN0IGJvcmRlcnMkNiA9IHtcbiAgbTogXCIxMDB2aFwiLFxuICBzOiBcIjhweFwiLFxuICBub25lOiBcIjBcIlxufTtcbmNvbnN0IHNjYWxlVmFsdWVzID0ge1xuICBzOiAwLjAyLFxuICBtOiAwLjA0XG59O1xuY29uc3QgQnV0dG9uU3R5bGVkJDEgPSBzdHlsZWQuYnV0dG9uYFxuICAgIGRpc3BsYXk6ICR7KHByb3BzKSA9PiBwcm9wcy5sZWZ0SWNvbiB8fCBwcm9wcy5yaWdodEljb24gPyBcImZsZXhcIiA6IFwiaW5saW5lLWJsb2NrXCJ9O1xuICAgIGdhcDogJHsocHJvcHMpID0+IHByb3BzLmxlZnRJY29uIHx8IHByb3BzLnJpZ2h0SWNvbiA/IFwiNnB4XCIgOiBcInVuc2V0XCJ9O1xuICAgIGFsaWduLWl0ZW1zOiAkeyhwcm9wcykgPT4gcHJvcHMubGVmdEljb24gfHwgcHJvcHMucmlnaHRJY29uID8gXCJjZW50ZXJcIiA6IFwidW5zZXRcIn07XG4gICAganVzdGlmeS1jb250ZW50OiAkeyhwcm9wcykgPT4gcHJvcHMubGVmdEljb24gfHwgcHJvcHMucmlnaHRJY29uID8gXCJzcGFjZS1iZXR3ZWVuXCIgOiBcInVuc2V0XCJ9O1xuICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy5hcHBlYXJhbmNlID09PSBcImZsYXRcIiA/IFwidHJhbnNwYXJlbnRcIiA6IHByb3BzLmFwcGVhcmFuY2UgPT09IFwic2Vjb25kYXJ5XCIgPyBwcm9wcy50aGVtZS5jb2xvcnMuYmFja2dyb3VuZC50aW50IDogcmdiYShwcm9wcy50aGVtZS5jb2xvcnMuYWNjZW50LCAwLjEyKX07XG4gICAgY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy5hcHBlYXJhbmNlID09PSBcInNlY29uZGFyeVwiID8gcHJvcHMudGhlbWUuY29sb3JzLnRleHQucHJpbWFyeSA6IHByb3BzLnRoZW1lLmNvbG9ycy5hY2NlbnR9O1xuXG4gICAgcGFkZGluZzogJHsocHJvcHMpID0+IHByb3BzLmFwcGVhcmFuY2UgPT09IFwiZmxhdFwiID8gXCIwXCIgOiBcIjlweCAxNnB4XCJ9O1xuICAgIHBhZGRpbmctbGVmdDogJHsocHJvcHMpID0+IHByb3BzLmxlZnRJY29uICYmIHByb3BzLmFwcGVhcmFuY2UgIT09IFwiZmxhdFwiID8gXCIxMnB4XCIgOiBcIjE2cHhcIn07XG4gICAgcGFkZGluZy1yaWdodDogJHsocHJvcHMpID0+IHByb3BzLnJpZ2h0SWNvbiAmJiBwcm9wcy5hcHBlYXJhbmNlICE9PSBcImZsYXRcIiA/IFwiMTJweFwiIDogXCIxNnB4XCJ9O1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBib3JkZXItcmFkaXVzOiAkeyhwcm9wcykgPT4gYm9yZGVycyQ2W3Byb3BzLnRoZW1lLmJvcmRlclJhZGl1c119O1xuICAgIGN1cnNvcjogJHsocHJvcHMpID0+IHByb3BzLmRpc2FibGVkID8gXCJub3QtYWxsb3dlZFwiIDogXCJwb2ludGVyXCJ9O1xuXG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGZvbnQtd2VpZ2h0OiA1MTA7XG4gICAgbGluZS1oZWlnaHQ6IDE4cHg7XG5cbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4xMjVzIGVhc2UtaW4tb3V0O1xuXG4gICAgJHttZWRpYU5vdFRvdWNofSB7XG4gICAgICAgICY6aG92ZXIge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAkeyhwcm9wcykgPT4gcHJvcHMuZGlzYWJsZWQgPyBcInVuc2V0XCIgOiBgc2NhbGUoJHsxICsgc2NhbGVWYWx1ZXNbcHJvcHMuc2NhbGVdfSlgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICY6YWN0aXZlIHtcbiAgICAgICAgdHJhbnNmb3JtOiAkeyhwcm9wcykgPT4gcHJvcHMuZGlzYWJsZWQgPyBcInVuc2V0XCIgOiBgc2NhbGUoJHsxIC0gc2NhbGVWYWx1ZXNbcHJvcHMuc2NhbGVdfSlgfTtcbiAgICB9XG5cbiAgICAke21lZGlhVG91Y2h9IHtcbiAgICAgICAgJjphY3RpdmUge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAkeyhwcm9wcykgPT4gcHJvcHMuZGlzYWJsZWQgPyBcInVuc2V0XCIgOiBgc2NhbGUoJHsxIC0gc2NhbGVWYWx1ZXNbcHJvcHMuc2NhbGVdICogMn0pYH07XG4gICAgICAgIH1cbiAgICB9XG5gO1xuZnVuY3Rpb24gdXNlRGF0YUF0dHJpYnV0ZXMocHJvcHMpIHtcbiAgY29uc3Qga2V5cyA9IHVudHJhY2soKCkgPT4gT2JqZWN0LmtleXMocHJvcHMpLmZpbHRlcigoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aChcImRhdGEtXCIpKSk7XG4gIGNvbnN0IFtkYXRhQXR0cnNdID0gc3BsaXRQcm9wcyhwcm9wcywga2V5cyk7XG4gIHJldHVybiBkYXRhQXR0cnM7XG59XG5jb25zdCBCdXR0b24gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgZGF0YUF0dHJzID0gdXNlRGF0YUF0dHJpYnV0ZXMocHJvcHMpO1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEJ1dHRvblN0eWxlZCQxLCBtZXJnZVByb3BzKHtcbiAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgIGdldCBhcHBlYXJhbmNlKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmFwcGVhcmFuY2UgfHwgXCJwcmltYXJ5XCI7XG4gICAgfSxcbiAgICBnZXQgW1wiY2xhc3NcIl0oKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2xhc3M7XG4gICAgfSxcbiAgICBvbkNsaWNrOiAoZTIpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICByZXR1cm4gKF9hMiA9IHByb3BzLm9uQ2xpY2spID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChwcm9wcywgZTIpO1xuICAgIH0sXG4gICAgb25Nb3VzZUVudGVyOiAoZTIpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICByZXR1cm4gKF9hMiA9IHByb3BzLm9uTW91c2VFbnRlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYWxsKHByb3BzLCBlMik7XG4gICAgfSxcbiAgICBvbk1vdXNlTGVhdmU6IChlMikgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIHJldHVybiAoX2EyID0gcHJvcHMub25Nb3VzZUxlYXZlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwocHJvcHMsIGUyKTtcbiAgICB9LFxuICAgIHJlZihyJCkge1xuICAgICAgdmFyIF9yZWYkID0gcHJvcHMucmVmO1xuICAgICAgdHlwZW9mIF9yZWYkID09PSBcImZ1bmN0aW9uXCIgPyBfcmVmJChyJCkgOiBwcm9wcy5yZWYgPSByJDtcbiAgICB9LFxuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5kaXNhYmxlZDtcbiAgICB9LFxuICAgIGdldCBzY2FsZSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5zY2FsZSB8fCBcIm1cIjtcbiAgICB9LFxuICAgIGdldCBsZWZ0SWNvbigpIHtcbiAgICAgIHJldHVybiAhIXByb3BzLmxlZnRJY29uO1xuICAgIH0sXG4gICAgZ2V0IHJpZ2h0SWNvbigpIHtcbiAgICAgIHJldHVybiAhIXByb3BzLnJpZ2h0SWNvbjtcbiAgICB9LFxuICAgIFwiZGF0YS10Yy1idXR0b25cIjogXCJ0cnVlXCJcbiAgfSwgZGF0YUF0dHJzLCB7XG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIFttZW1vKCgpID0+IHByb3BzLmxlZnRJY29uKSwgbWVtbygoKSA9PiBwcm9wcy5jaGlsZHJlbiksIG1lbW8oKCkgPT4gcHJvcHMucmlnaHRJY29uKV07XG4gICAgfVxuICB9KSk7XG59O1xuY29uc3Qgbm9vcCA9ICgpID0+IHtcbn07XG5jb25zdCBub29wVHJhbnNpdGlvbiA9IChlbCwgZG9uZSkgPT4gZG9uZSgpO1xuZnVuY3Rpb24gY3JlYXRlU3dpdGNoVHJhbnNpdGlvbihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgY29uc3QgaW5pdFNvdXJjZSA9IHVudHJhY2soc291cmNlKTtcbiAgY29uc3QgaW5pdFJldHVybmVkID0gaW5pdFNvdXJjZSA/IFtpbml0U291cmNlXSA6IFtdO1xuICBjb25zdCB7IG9uRW50ZXIgPSBub29wVHJhbnNpdGlvbiwgb25FeGl0ID0gbm9vcFRyYW5zaXRpb24gfSA9IG9wdGlvbnM7XG4gIGNvbnN0IFtyZXR1cm5lZCwgc2V0UmV0dXJuZWRdID0gY3JlYXRlU2lnbmFsKG9wdGlvbnMuYXBwZWFyID8gW10gOiBpbml0UmV0dXJuZWQpO1xuICBjb25zdCBbaXNUcmFuc2l0aW9uUGVuZGluZ10gPSB1c2VUcmFuc2l0aW9uKCk7XG4gIGxldCBuZXh0O1xuICBsZXQgaXNFeGl0aW5nID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGV4aXRUcmFuc2l0aW9uMihlbCwgYWZ0ZXIpIHtcbiAgICBpZiAoIWVsKVxuICAgICAgcmV0dXJuIGFmdGVyICYmIGFmdGVyKCk7XG4gICAgaXNFeGl0aW5nID0gdHJ1ZTtcbiAgICBvbkV4aXQoZWwsICgpID0+IHtcbiAgICAgIGJhdGNoKCgpID0+IHtcbiAgICAgICAgaXNFeGl0aW5nID0gZmFsc2U7XG4gICAgICAgIHNldFJldHVybmVkKChwMikgPT4gcDIuZmlsdGVyKChlMikgPT4gZTIgIT09IGVsKSk7XG4gICAgICAgIGFmdGVyICYmIGFmdGVyKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBlbnRlclRyYW5zaXRpb24yKGFmdGVyKSB7XG4gICAgY29uc3QgZWwgPSBuZXh0O1xuICAgIGlmICghZWwpXG4gICAgICByZXR1cm4gYWZ0ZXIgJiYgYWZ0ZXIoKTtcbiAgICBuZXh0ID0gdm9pZCAwO1xuICAgIHNldFJldHVybmVkKChwMikgPT4gW2VsLCAuLi5wMl0pO1xuICAgIG9uRW50ZXIoZWwsIGFmdGVyICE9IG51bGwgPyBhZnRlciA6IG5vb3ApO1xuICB9XG4gIGNvbnN0IHRyaWdnZXJUcmFuc2l0aW9ucyA9IG9wdGlvbnMubW9kZSA9PT0gXCJvdXQtaW5cIiA/IChcbiAgICAvLyBleGl0IC0+IGVudGVyXG4gICAgLy8gZXhpdCAtPiBlbnRlclxuICAgIChwcmV2KSA9PiBpc0V4aXRpbmcgfHwgZXhpdFRyYW5zaXRpb24yKHByZXYsIGVudGVyVHJhbnNpdGlvbjIpXG4gICkgOiBvcHRpb25zLm1vZGUgPT09IFwiaW4tb3V0XCIgPyAoXG4gICAgLy8gZW50ZXIgLT4gZXhpdFxuICAgIC8vIGVudGVyIC0+IGV4aXRcbiAgICAocHJldikgPT4gZW50ZXJUcmFuc2l0aW9uMigoKSA9PiBleGl0VHJhbnNpdGlvbjIocHJldikpXG4gICkgOiAoXG4gICAgLy8gZXhpdCAmIGVudGVyXG4gICAgLy8gZXhpdCAmIGVudGVyXG4gICAgKHByZXYpID0+IHtcbiAgICAgIGV4aXRUcmFuc2l0aW9uMihwcmV2KTtcbiAgICAgIGVudGVyVHJhbnNpdGlvbjIoKTtcbiAgICB9XG4gICk7XG4gIGNyZWF0ZUNvbXB1dGVkKChwcmV2KSA9PiB7XG4gICAgY29uc3QgZWwgPSBzb3VyY2UoKTtcbiAgICBpZiAodW50cmFjayhpc1RyYW5zaXRpb25QZW5kaW5nKSkge1xuICAgICAgaXNUcmFuc2l0aW9uUGVuZGluZygpO1xuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfVxuICAgIGlmIChlbCAhPT0gcHJldikge1xuICAgICAgbmV4dCA9IGVsO1xuICAgICAgYmF0Y2goKCkgPT4gdW50cmFjaygoKSA9PiB0cmlnZ2VyVHJhbnNpdGlvbnMocHJldikpKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsO1xuICB9LCBvcHRpb25zLmFwcGVhciA/IHZvaWQgMCA6IGluaXRTb3VyY2UpO1xuICByZXR1cm4gcmV0dXJuZWQ7XG59XG5mdW5jdGlvbiBjcmVhdGVMaXN0VHJhbnNpdGlvbihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgY29uc3QgaW5pdFNvdXJjZSA9IHVudHJhY2soc291cmNlKTtcbiAgY29uc3QgeyBvbkNoYW5nZSB9ID0gb3B0aW9ucztcbiAgbGV0IHByZXZTZXQgPSBuZXcgU2V0KG9wdGlvbnMuYXBwZWFyID8gdm9pZCAwIDogaW5pdFNvdXJjZSk7XG4gIGNvbnN0IGV4aXRpbmcgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgY29uc3QgW3RvUmVtb3ZlLCBzZXRUb1JlbW92ZV0gPSBjcmVhdGVTaWduYWwoW10sIHsgZXF1YWxzOiBmYWxzZSB9KTtcbiAgY29uc3QgW2lzVHJhbnNpdGlvblBlbmRpbmddID0gdXNlVHJhbnNpdGlvbigpO1xuICBjb25zdCBmaW5pc2hSZW1vdmVkID0gKGVscykgPT4ge1xuICAgIHNldFRvUmVtb3ZlKChwMikgPT4gKHAyLnB1c2guYXBwbHkocDIsIGVscyksIHAyKSk7XG4gICAgZm9yIChjb25zdCBlbCBvZiBlbHMpXG4gICAgICBleGl0aW5nLmRlbGV0ZShlbCk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZVJlbW92ZWQgPSAoZWxzLCBlbCwgaTIpID0+IGVscy5zcGxpY2UoaTIsIDAsIGVsKTtcbiAgcmV0dXJuIGNyZWF0ZU1lbW8oKHByZXYpID0+IHtcbiAgICBjb25zdCBlbHNUb1JlbW92ZSA9IHRvUmVtb3ZlKCk7XG4gICAgY29uc3Qgc291cmNlTGlzdCA9IHNvdXJjZSgpO1xuICAgIHNvdXJjZUxpc3RbJFRSQUNLXTtcbiAgICBpZiAodW50cmFjayhpc1RyYW5zaXRpb25QZW5kaW5nKSkge1xuICAgICAgaXNUcmFuc2l0aW9uUGVuZGluZygpO1xuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfVxuICAgIGlmIChlbHNUb1JlbW92ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG5leHQgPSBwcmV2LmZpbHRlcigoZTIpID0+ICFlbHNUb1JlbW92ZS5pbmNsdWRlcyhlMikpO1xuICAgICAgZWxzVG9SZW1vdmUubGVuZ3RoID0gMDtcbiAgICAgIG9uQ2hhbmdlKHsgbGlzdDogbmV4dCwgYWRkZWQ6IFtdLCByZW1vdmVkOiBbXSwgdW5jaGFuZ2VkOiBuZXh0LCBmaW5pc2hSZW1vdmVkIH0pO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICAgIHJldHVybiB1bnRyYWNrKCgpID0+IHtcbiAgICAgIGNvbnN0IG5leHRTZXQgPSBuZXcgU2V0KHNvdXJjZUxpc3QpO1xuICAgICAgY29uc3QgbmV4dCA9IHNvdXJjZUxpc3Quc2xpY2UoKTtcbiAgICAgIGNvbnN0IGFkZGVkID0gW107XG4gICAgICBjb25zdCByZW1vdmVkID0gW107XG4gICAgICBjb25zdCB1bmNoYW5nZWQgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZWwgb2Ygc291cmNlTGlzdCkge1xuICAgICAgICAocHJldlNldC5oYXMoZWwpID8gdW5jaGFuZ2VkIDogYWRkZWQpLnB1c2goZWwpO1xuICAgICAgfVxuICAgICAgbGV0IG5vdGhpbmdDaGFuZ2VkID0gIWFkZGVkLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBwcmV2Lmxlbmd0aDsgaTIrKykge1xuICAgICAgICBjb25zdCBlbCA9IHByZXZbaTJdO1xuICAgICAgICBpZiAoIW5leHRTZXQuaGFzKGVsKSkge1xuICAgICAgICAgIGlmICghZXhpdGluZy5oYXMoZWwpKSB7XG4gICAgICAgICAgICByZW1vdmVkLnB1c2goZWwpO1xuICAgICAgICAgICAgZXhpdGluZy5hZGQoZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYW5kbGVSZW1vdmVkKG5leHQsIGVsLCBpMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdGhpbmdDaGFuZ2VkICYmIGVsICE9PSBuZXh0W2kyXSlcbiAgICAgICAgICBub3RoaW5nQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFyZW1vdmVkLmxlbmd0aCAmJiBub3RoaW5nQ2hhbmdlZClcbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICBvbkNoYW5nZSh7IGxpc3Q6IG5leHQsIGFkZGVkLCByZW1vdmVkLCB1bmNoYW5nZWQsIGZpbmlzaFJlbW92ZWQgfSk7XG4gICAgICBwcmV2U2V0ID0gbmV4dFNldDtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH0pO1xuICB9LCBvcHRpb25zLmFwcGVhciA/IFtdIDogaW5pdFNvdXJjZS5zbGljZSgpKTtcbn1cbmNvbnN0IGRlZmF1bHRFbGVtZW50UHJlZGljYXRlID0gKGl0ZW0pID0+IGl0ZW0gaW5zdGFuY2VvZiBFbGVtZW50O1xuZnVuY3Rpb24gZ2V0UmVzb2x2ZWRFbGVtZW50cyh2YWx1ZSwgcHJlZGljYXRlKSB7XG4gIGlmIChwcmVkaWNhdGUodmFsdWUpKVxuICAgIHJldHVybiB2YWx1ZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiICYmICF2YWx1ZS5sZW5ndGgpXG4gICAgcmV0dXJuIGdldFJlc29sdmVkRWxlbWVudHModmFsdWUoKSwgcHJlZGljYXRlKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0UmVzb2x2ZWRFbGVtZW50cyhpdGVtLCBwcmVkaWNhdGUpO1xuICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgQXJyYXkuaXNBcnJheShyZXN1bHQpID8gcmVzdWx0cy5wdXNoLmFwcGx5KHJlc3VsdHMsIHJlc3VsdCkgOiByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHMubGVuZ3RoID8gcmVzdWx0cyA6IG51bGw7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiByZXNvbHZlRWxlbWVudHMoZm4sIHByZWRpY2F0ZSA9IGRlZmF1bHRFbGVtZW50UHJlZGljYXRlLCBzZXJ2ZXJQcmVkaWNhdGUgPSBkZWZhdWx0RWxlbWVudFByZWRpY2F0ZSkge1xuICBjb25zdCBjaGlsZHJlbjIgPSBjcmVhdGVNZW1vKGZuKTtcbiAgY29uc3QgbWVtbzIgPSBjcmVhdGVNZW1vKCgpID0+IGdldFJlc29sdmVkRWxlbWVudHMoY2hpbGRyZW4yKCksIHByZWRpY2F0ZSkpO1xuICBtZW1vMi50b0FycmF5ID0gKCkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gbWVtbzIoKTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IHZhbHVlID8gW3ZhbHVlXSA6IFtdO1xuICB9O1xuICByZXR1cm4gbWVtbzI7XG59XG5mdW5jdGlvbiBnZXRGaXJzdENoaWxkKHZhbHVlLCBwcmVkaWNhdGUpIHtcbiAgaWYgKHByZWRpY2F0ZSh2YWx1ZSkpXG4gICAgcmV0dXJuIHZhbHVlO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiYgIXZhbHVlLmxlbmd0aClcbiAgICByZXR1cm4gZ2V0Rmlyc3RDaGlsZCh2YWx1ZSgpLCBwcmVkaWNhdGUpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGdldEZpcnN0Q2hpbGQoaXRlbSwgcHJlZGljYXRlKTtcbiAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUZpcnN0KGZuLCBwcmVkaWNhdGUgPSBkZWZhdWx0RWxlbWVudFByZWRpY2F0ZSwgc2VydmVyUHJlZGljYXRlID0gZGVmYXVsdEVsZW1lbnRQcmVkaWNhdGUpIHtcbiAgY29uc3QgY2hpbGRyZW4yID0gY3JlYXRlTWVtbyhmbik7XG4gIHJldHVybiBjcmVhdGVNZW1vKCgpID0+IGdldEZpcnN0Q2hpbGQoY2hpbGRyZW4yKCksIHByZWRpY2F0ZSkpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2xhc3NuYW1lcyhwcm9wcykge1xuICByZXR1cm4gY3JlYXRlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgbmFtZSA9IHByb3BzLm5hbWUgfHwgXCJzXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVudGVyQWN0aXZlOiAocHJvcHMuZW50ZXJBY3RpdmVDbGFzcyB8fCBuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLnNwbGl0KFwiIFwiKSxcbiAgICAgIGVudGVyOiAocHJvcHMuZW50ZXJDbGFzcyB8fCBuYW1lICsgXCItZW50ZXJcIikuc3BsaXQoXCIgXCIpLFxuICAgICAgZW50ZXJUbzogKHByb3BzLmVudGVyVG9DbGFzcyB8fCBuYW1lICsgXCItZW50ZXItdG9cIikuc3BsaXQoXCIgXCIpLFxuICAgICAgZXhpdEFjdGl2ZTogKHByb3BzLmV4aXRBY3RpdmVDbGFzcyB8fCBuYW1lICsgXCItZXhpdC1hY3RpdmVcIikuc3BsaXQoXCIgXCIpLFxuICAgICAgZXhpdDogKHByb3BzLmV4aXRDbGFzcyB8fCBuYW1lICsgXCItZXhpdFwiKS5zcGxpdChcIiBcIiksXG4gICAgICBleGl0VG86IChwcm9wcy5leGl0VG9DbGFzcyB8fCBuYW1lICsgXCItZXhpdC10b1wiKS5zcGxpdChcIiBcIiksXG4gICAgICBtb3ZlOiAocHJvcHMubW92ZUNsYXNzIHx8IG5hbWUgKyBcIi1tb3ZlXCIpLnNwbGl0KFwiIFwiKVxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gbmV4dEZyYW1lKGZuKSB7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pKTtcbn1cbmZ1bmN0aW9uIGVudGVyVHJhbnNpdGlvbihjbGFzc2VzLCBldmVudHMsIGVsLCBkb25lKSB7XG4gIGNvbnN0IHsgb25CZWZvcmVFbnRlciwgb25FbnRlciwgb25BZnRlckVudGVyIH0gPSBldmVudHM7XG4gIG9uQmVmb3JlRW50ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQmVmb3JlRW50ZXIoZWwpO1xuICBlbC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXMuZW50ZXIpO1xuICBlbC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXMuZW50ZXJBY3RpdmUpO1xuICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgaWYgKCFlbC5wYXJlbnROb2RlKVxuICAgICAgcmV0dXJuIGRvbmUgPT0gbnVsbCA/IHZvaWQgMCA6IGRvbmUoKTtcbiAgICBvbkVudGVyID09IG51bGwgPyB2b2lkIDAgOiBvbkVudGVyKGVsLCAoKSA9PiBlbmRUcmFuc2l0aW9uKCkpO1xuICB9KTtcbiAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzZXMuZW50ZXIpO1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3Nlcy5lbnRlclRvKTtcbiAgICBpZiAoIW9uRW50ZXIgfHwgb25FbnRlci5sZW5ndGggPCAyKSB7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCBlbmRUcmFuc2l0aW9uKTtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgZW5kVHJhbnNpdGlvbik7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gZW5kVHJhbnNpdGlvbihlMikge1xuICAgIGlmICghZTIgfHwgZTIudGFyZ2V0ID09PSBlbCkge1xuICAgICAgZG9uZSA9PSBudWxsID8gdm9pZCAwIDogZG9uZSgpO1xuICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgZW5kVHJhbnNpdGlvbik7XG4gICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsIGVuZFRyYW5zaXRpb24pO1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc2VzLmVudGVyQWN0aXZlKTtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3Nlcy5lbnRlclRvKTtcbiAgICAgIG9uQWZ0ZXJFbnRlciA9PSBudWxsID8gdm9pZCAwIDogb25BZnRlckVudGVyKGVsKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGV4aXRUcmFuc2l0aW9uKGNsYXNzZXMsIGV2ZW50cywgZWwsIGRvbmUpIHtcbiAgY29uc3QgeyBvbkJlZm9yZUV4aXQsIG9uRXhpdCwgb25BZnRlckV4aXQgfSA9IGV2ZW50cztcbiAgaWYgKCFlbC5wYXJlbnROb2RlKVxuICAgIHJldHVybiBkb25lID09IG51bGwgPyB2b2lkIDAgOiBkb25lKCk7XG4gIG9uQmVmb3JlRXhpdCA9PSBudWxsID8gdm9pZCAwIDogb25CZWZvcmVFeGl0KGVsKTtcbiAgZWwuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzLmV4aXQpO1xuICBlbC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXMuZXhpdEFjdGl2ZSk7XG4gIG9uRXhpdCA9PSBudWxsID8gdm9pZCAwIDogb25FeGl0KGVsLCAoKSA9PiBlbmRUcmFuc2l0aW9uKCkpO1xuICBuZXh0RnJhbWUoKCkgPT4ge1xuICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3Nlcy5leGl0KTtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXMuZXhpdFRvKTtcbiAgICBpZiAoIW9uRXhpdCB8fCBvbkV4aXQubGVuZ3RoIDwgMikge1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgZW5kVHJhbnNpdGlvbik7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsIGVuZFRyYW5zaXRpb24pO1xuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIGVuZFRyYW5zaXRpb24oZTIpIHtcbiAgICBpZiAoIWUyIHx8IGUyLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGRvbmUgPT0gbnVsbCA/IHZvaWQgMCA6IGRvbmUoKTtcbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIGVuZFRyYW5zaXRpb24pO1xuICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLCBlbmRUcmFuc2l0aW9uKTtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3Nlcy5leGl0QWN0aXZlKTtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3Nlcy5leGl0VG8pO1xuICAgICAgb25BZnRlckV4aXQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQWZ0ZXJFeGl0KGVsKTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IFRSQU5TSVRJT05fTU9ERV9NQVAgPSB7XG4gIGlub3V0OiBcImluLW91dFwiLFxuICBvdXRpbjogXCJvdXQtaW5cIlxufTtcbmNvbnN0IFRyYW5zaXRpb24gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgY2xhc3NuYW1lcyA9IGNyZWF0ZUNsYXNzbmFtZXMocHJvcHMpO1xuICByZXR1cm4gY3JlYXRlU3dpdGNoVHJhbnNpdGlvbihyZXNvbHZlRmlyc3QoKCkgPT4gcHJvcHMuY2hpbGRyZW4pLCB7XG4gICAgbW9kZTogVFJBTlNJVElPTl9NT0RFX01BUFtwcm9wcy5tb2RlXSxcbiAgICBhcHBlYXI6IHByb3BzLmFwcGVhcixcbiAgICBvbkVudGVyKGVsLCBkb25lKSB7XG4gICAgICBlbnRlclRyYW5zaXRpb24oY2xhc3NuYW1lcygpLCBwcm9wcywgZWwsIGRvbmUpO1xuICAgIH0sXG4gICAgb25FeGl0KGVsLCBkb25lKSB7XG4gICAgICBleGl0VHJhbnNpdGlvbihjbGFzc25hbWVzKCksIHByb3BzLCBlbCwgZG9uZSk7XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBUcmFuc2l0aW9uR3JvdXAgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgY2xhc3NuYW1lcyA9IGNyZWF0ZUNsYXNzbmFtZXMocHJvcHMpO1xuICByZXR1cm4gY3JlYXRlTGlzdFRyYW5zaXRpb24ocmVzb2x2ZUVsZW1lbnRzKCgpID0+IHByb3BzLmNoaWxkcmVuKS50b0FycmF5LCB7XG4gICAgYXBwZWFyOiBwcm9wcy5hcHBlYXIsXG4gICAgb25DaGFuZ2UoeyBhZGRlZCwgcmVtb3ZlZCwgZmluaXNoUmVtb3ZlZCwgbGlzdCB9KSB7XG4gICAgICBjb25zdCBjbGFzc2VzID0gY2xhc3NuYW1lcygpO1xuICAgICAgZm9yIChjb25zdCBlbCBvZiBhZGRlZCkge1xuICAgICAgICBlbnRlclRyYW5zaXRpb24oY2xhc3NlcywgcHJvcHMsIGVsKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRvTW92ZSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBlbCBvZiBsaXN0KSB7XG4gICAgICAgIGlmIChlbC5pc0Nvbm5lY3RlZCAmJiAoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBlbCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpKSB7XG4gICAgICAgICAgdG9Nb3ZlLnB1c2goeyBlbCwgcmVjdDogZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgbW92ZWQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IGVsLCByZWN0IH0gb2YgdG9Nb3ZlKSB7XG4gICAgICAgICAgaWYgKGVsLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGRYID0gcmVjdC5sZWZ0IC0gbmV3UmVjdC5sZWZ0LCBkWSA9IHJlY3QudG9wIC0gbmV3UmVjdC50b3A7XG4gICAgICAgICAgICBpZiAoZFggfHwgZFkpIHtcbiAgICAgICAgICAgICAgZWwuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2RYfXB4LCAke2RZfXB4KWA7XG4gICAgICAgICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IFwiMHNcIjtcbiAgICAgICAgICAgICAgbW92ZWQucHVzaChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIG1vdmVkKSB7XG4gICAgICAgICAgbGV0IGVuZFRyYW5zaXRpb24gPSBmdW5jdGlvbihlMikge1xuICAgICAgICAgICAgaWYgKGUyLnRhcmdldCA9PT0gZWwgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZTIucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCBlbmRUcmFuc2l0aW9uKTtcbiAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc2VzLm1vdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzLm1vdmUpO1xuICAgICAgICAgIGVsLnN0eWxlLnRyYW5zZm9ybSA9IGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IFwiXCI7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgZW5kVHJhbnNpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZm9yIChjb25zdCBlbCBvZiByZW1vdmVkKSB7XG4gICAgICAgIGV4aXRUcmFuc2l0aW9uKGNsYXNzZXMsIHByb3BzLCBlbCwgKCkgPT4gZmluaXNoUmVtb3ZlZChbZWxdKSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5mdW5jdGlvbiBjbGlja091dHNpZGUkMShlbCwgYWNjZXNzb3IpIHtcbiAgY29uc3Qgb25DbGljayA9IChlMikgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgcmV0dXJuICFlbC5jb250YWlucyhlMi50YXJnZXQpICYmICgoX2EyID0gYWNjZXNzb3IoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMigpKTtcbiAgfTtcbiAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb25DbGljayk7XG4gIG9uQ2xlYW51cCgoKSA9PiBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBvbkNsaWNrKSk7XG59XG5mdW5jdGlvbiBlc2NQcmVzc2VkKF8sIGFjY2Vzc29yKSB7XG4gIGNvbnN0IG9uS2V5UHJlc3MgPSAoZTIpID0+IHtcbiAgICB2YXIgX2EyLCBfYjI7XG4gICAgaWYgKGUyLmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgKF9hMiA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuYmx1cigpO1xuICAgICAgKF9iMiA9IGFjY2Vzc29yKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYjIoKTtcbiAgICB9XG4gIH07XG4gIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgb25LZXlQcmVzcyk7XG4gIG9uQ2xlYW51cCgoKSA9PiBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5UHJlc3MpKTtcbn1cbmZ1bmN0aW9uIGFuZHJvaWRCYWNrSGFuZGxlciQxKF8sIGNvbmZpZykge1xuICBjb25zdCB7XG4gICAgaXNFbmFibGVkLFxuICAgIG9uQ2xvc2VcbiAgfSA9IGNvbmZpZygpO1xuICBpZiAoIWlzRW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB1c2VyT1NJc0FuZHJvaWQgPSBnZXRVc2VyQWdlbnQoKS5vcyA9PT0gXCJhbmRyb2lkXCI7XG4gIGlmICghdXNlck9TSXNBbmRyb2lkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShST1VURV9TVEFURSwgXCJcIik7XG4gIGNvbnN0IHBvcHN0YXRlSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgb25DbG9zZSgpO1xuICB9O1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHBvcHN0YXRlSGFuZGxlciwge1xuICAgIG9uY2U6IHRydWVcbiAgfSk7XG4gIG9uQ2xlYW51cCgoKSA9PiB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCBwb3BzdGF0ZUhhbmRsZXIpO1xuICAgIGNyZWF0ZU1hY3JvdGFzaygoKSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgaWYgKCgoX2EyID0gd2luZG93Lmhpc3Rvcnkuc3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTJbUk9VVEVfU1RBVEVfS0VZXSkgPT09IHRydWUpIHtcbiAgICAgICAgd2luZG93Lmhpc3RvcnkuYmFjaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cbmNvbnN0IFJPVVRFX1NUQVRFX0tFWSA9IFwiYW5kcm9pZEJhY2tIYW5kbGVyXCI7XG5jb25zdCBST1VURV9TVEFURSA9IHtcbiAgW1JPVVRFX1NUQVRFX0tFWV06IHRydWVcbn07XG52YXIgX3RtcGwkJHYgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2Zz48cGF0aCBmaWxsLXJ1bGU9ZXZlbm9kZCBjbGlwLXJ1bGU9ZXZlbm9kZCBkPVwiTTEwLjIxMjIgMTQuMzQwN0MxMC41Mzg0IDE0LjA4NTQgMTAuNTk1OSAxMy42MTQgMTAuMzQwNiAxMy4yODc4TDYuMjAyMzcgOC4wMDAwM0wxMC4zNDA2IDIuNzEyMjdDMTAuNTk1OSAyLjM4NjA3IDEwLjUzODQgMS45MTQ2OSAxMC4yMTIyIDEuNjU5NEM5Ljg4NjA0IDEuNDA0MTIgOS40MTQ2NSAxLjQ2MTYxIDkuMTU5MzcgMS43ODc4TDQuNjU5MzcgNy41Mzc4QzQuNDQ2ODggNy44MDkzMiA0LjQ0Njg4IDguMTkwNzQgNC42NTkzNyA4LjQ2MjI2TDkuMTU5MzcgMTQuMjEyM0M5LjQxNDY1IDE0LjUzODUgOS44ODYwNCAxNC41OTU5IDEwLjIxMjIgMTQuMzQwN1pcIj48L3N2Zz5gLCBmYWxzZSwgdHJ1ZSwgZmFsc2UpO1xuY29uc3Qgcm90YXRpb25EZWdyZWVzID0ge1xuICBsZWZ0OiAwLFxuICB0b3A6IDkwLFxuICByaWdodDogMTgwLFxuICBib3R0b206IDI3MFxufTtcbmNvbnN0IEFycm93SWNvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IGZpbGwgPSAoKSA9PiBwcm9wcy5maWxsIHx8IHRoZW1lLmNvbG9ycy5pY29uLnNlY29uZGFyeTtcbiAgY29uc3QgZGlyZWN0aW9uID0gKCkgPT4gcHJvcHMuZGlyZWN0aW9uIHx8IFwibGVmdFwiO1xuICBjb25zdCBTdmcgPSBzdHlsZWQoXCJzdmdcIilgXG4gICAgICAgIHRyYW5zZm9ybTogcm90YXRlKCR7KHByb3BzMikgPT4gcm90YXRpb25EZWdyZWVzW3Byb3BzMi5zdmdEaXJlY3Rpb25dfWRlZyk7XG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjFzIGVhc2UtaW4tb3V0O1xuICAgIGA7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoU3ZnLCB7XG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICB3aWR0aDogXCIxNlwiLFxuICAgIGhlaWdodDogXCIxNlwiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDE2IDE2XCIsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgZ2V0IHN2Z0RpcmVjdGlvbigpIHtcbiAgICAgIHJldHVybiBkaXJlY3Rpb24oKTtcbiAgICB9LFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHZhciBfZWwkID0gX3RtcGwkJHYoKTtcbiAgICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoKSA9PiBzZXRBdHRyaWJ1dGUoX2VsJCwgXCJmaWxsXCIsIGZpbGwoKSkpO1xuICAgICAgcmV0dXJuIF9lbCQ7XG4gICAgfVxuICB9KTtcbn07XG52YXIgX3RtcGwkJHUgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyB3aWR0aD0xNiBoZWlnaHQ9MTYgdmlld0JveD1cIjAgMCAxNiAxNlwiZmlsbD1ub25lPjxwYXRoIGZpbGwtcnVsZT1ldmVub2RkIGNsaXAtcnVsZT1ldmVub2RkIGQ9XCJNMi43MTk2NiAyLjcxOTY4QzMuMDEyNTUgMi40MjY3OCAzLjQ4NzQzIDIuNDI2NzcgMy43ODAzMiAyLjcxOTY2TDguMDAwMDIgNi45MzkyNUwxMi4yMTk3IDIuNzE5NjdDMTIuNTEyNiAyLjQyNjc3IDEyLjk4NzQgMi40MjY3OCAxMy4yODAzIDIuNzE5NjdDMTMuNTczMiAzLjAxMjU3IDEzLjU3MzIgMy40ODc0NCAxMy4yODAzIDMuNzgwMzNMOS4wNjA2OCA3Ljk5OTkxTDEzLjI4MDMgMTIuMjE5N0MxMy41NzMyIDEyLjUxMjYgMTMuNTczMiAxMi45ODc0IDEzLjI4MDMgMTMuMjgwM0MxMi45ODc0IDEzLjU3MzIgMTIuNTEyNiAxMy41NzMyIDEyLjIxOTcgMTMuMjgwM0w4LjAwMDAyIDkuMDYwNTdMMy43ODAzMyAxMy4yODAzQzMuNDg3NDQgMTMuNTczMiAzLjAxMjU3IDEzLjU3MzIgMi43MTk2NyAxMy4yODAzQzIuNDI2NzggMTIuOTg3NCAyLjQyNjc3IDEyLjUxMjYgMi43MTk2NyAxMi4yMTk3TDYuOTM5MzYgNy45OTk5MUwyLjcxOTY4IDMuNzgwMzRDMi40MjY3OCAzLjQ4NzQ1IDIuNDI2NzcgMy4wMTI1NyAyLjcxOTY2IDIuNzE5NjhaXCI+YCk7XG5jb25zdCBDbG9zZUljb24gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCBmaWxsID0gKCkgPT4gcHJvcHMuZmlsbCB8fCB0aGVtZS5jb2xvcnMuaWNvbi5zZWNvbmRhcnk7XG4gIHJldHVybiAoKCkgPT4ge1xuICAgIHZhciBfZWwkID0gX3RtcGwkJHUoKSwgX2VsJDIgPSBfZWwkLmZpcnN0Q2hpbGQ7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KCgpID0+IHNldEF0dHJpYnV0ZShfZWwkMiwgXCJmaWxsXCIsIGZpbGwoKSkpO1xuICAgIHJldHVybiBfZWwkO1xuICB9KSgpO1xufTtcbmNvbnN0IEljb25CdXR0b25TdHlsZWQgPSBzdHlsZWQuYnV0dG9uYFxuICAgIHBhZGRpbmc6IDA7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIHdpZHRoOiAzMnB4O1xuICAgIGhlaWdodDogMzJweDtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnRpbnR9O1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4xMjVzIGVhc2UtaW4tb3V0O1xuXG4gICAgJHttZWRpYU5vdFRvdWNofSB7XG4gICAgICAgICY6aG92ZXIge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLjA0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICY6YWN0aXZlIHtcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjk2KTtcbiAgICB9XG5cbiAgICAke21lZGlhVG91Y2h9IHtcbiAgICAgICAgJjphY3RpdmUge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjkyKTtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5jb25zdCBJY29uQnV0dG9uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IGRhdGFBdHRycyA9IHVzZURhdGFBdHRyaWJ1dGVzKHByb3BzKTtcbiAgY29uc3QgaWNvbiA9ICgpID0+IHByb3BzLmljb24gfHwgXCJjbG9zZVwiO1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEljb25CdXR0b25TdHlsZWQsIG1lcmdlUHJvcHMoe1xuICAgIGdldCBbXCJjbGFzc1wiXSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5jbGFzcztcbiAgICB9LFxuICAgIG9uQ2xpY2s6ICgpID0+IHByb3BzLm9uQ2xpY2soKSxcbiAgICBcImRhdGEtdGMtaWNvbi1idXR0b25cIjogXCJ0cnVlXCJcbiAgfSwgZGF0YUF0dHJzLCB7XG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICByZXR1cm4gISFwcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgIHJldHVybiAhcHJvcHMuY2hpbGRyZW47XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFN3aXRjaCwge1xuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGljb24oKSA9PT0gXCJjbG9zZVwiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChDbG9zZUljb24sIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGZpbGwoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLmZpbGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGljb24oKSA9PT0gXCJhcnJvd1wiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChBcnJvd0ljb24sIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGZpbGwoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLmZpbGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGljb24oKSA9PT0gXCJxdWVzdGlvblwiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChRdWVzdGlvbkljb24sIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGZpbGwoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLmZpbGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBpY29uKCkgIT09IFwic3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaWNvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KV07XG4gICAgfVxuICB9KSk7XG59O1xuY29uc3QgYm9yZGVycyQ1ID0ge1xuICBtOiBcIjI0cHhcIixcbiAgczogXCIxNnB4XCIsXG4gIG5vbmU6IFwiMFwiXG59O1xuY29uc3QgTW9kYWxCYWNrZ3JvdW5kU3R5bGVkID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICB6LWluZGV4OiAxMDAwO1xuICAgIGxlZnQ6IDA7XG4gICAgdG9wOiAwO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNCk7XG4gICAgcGFkZGluZzogMjBweCAwO1xuICAgIG92ZXJmbG93LXk6IGF1dG87XG5cbiAgICAke21lZGlhKFwibW9iaWxlXCIpfSB7XG4gICAgICAgIHBhZGRpbmctYm90dG9tOiAwO1xuICAgIH1cbmA7XG5jb25zdCBNb2RhbFdyYXBwZXJDbGFzcyA9IHVgXG4gICAgYm94LXNoYWRvdzpcbiAgICAgICAgMCA0cHggMTZweCByZ2JhKDAsIDAsIDAsIDAuMDgpLFxuICAgICAgICAwIDE2cHggNjRweCByZ2JhKDAsIDAsIDAsIDAuMTYpO1xuICAgIHdpZHRoOiBmaXQtY29udGVudDtcbiAgICBtYXJnaW46IGF1dG87XG5cbiAgICAke21lZGlhKFwibW9iaWxlXCIpfSB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IGZpdC1jb250ZW50O1xuICAgICAgICBtYXJnaW46IGF1dG8gMCAwIDA7XG4gICAgfVxuYDtcbmNvbnN0IE1vZGFsQm9keVN0eWxlZCA9IHN0eWxlZC5kaXZgXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIG1pbi1oZWlnaHQ6IDEwMHB4O1xuICAgIHdpZHRoOiA0MTZweDtcbiAgICBwYWRkaW5nOiA0NHB4IDU2cHggMjRweDtcblxuICAgIGJveC1zaGFkb3c6IDAgMnB4IDhweCAwIHJnYmEoMCwgMCwgMCwgMC4wNCk7XG5cbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmJhY2tncm91bmQucHJpbWFyeX07XG4gICAgYm9yZGVyLXJhZGl1czogJHsocHJvcHMpID0+IGJvcmRlcnMkNVtwcm9wcy50aGVtZS5ib3JkZXJSYWRpdXNdfTtcblxuICAgICR7bWVkaWEoXCJtb2JpbGVcIil9IHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgfVxuYDtcbmNvbnN0IENsb3NlQnV0dG9uU3R5bGVkID0gc3R5bGVkKEljb25CdXR0b24pYFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICByaWdodDogMTZweDtcbiAgICB0b3A6IDE2cHg7XG5gO1xuY29uc3QgTW9kYWxGb290ZXJTdHlsZWQgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgcGFkZGluZzogMTZweCAxNnB4IDE2cHggMThweDtcbiAgICBib3JkZXItcmFkaXVzOiAwIDAgJHsocHJvcHMpID0+IGJvcmRlcnMkNVtwcm9wcy50aGVtZS5ib3JkZXJSYWRpdXNdfVxuICAgICAgICAkeyhwcm9wcykgPT4gYm9yZGVycyQ1W3Byb3BzLnRoZW1lLmJvcmRlclJhZGl1c119O1xuYDtcbmNvbnN0IFF1ZXN0aW9uQnV0dG9uU3R5bGVkID0gc3R5bGVkKEljb25CdXR0b24pYFxuICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiByZ2JhKHByb3BzLnRoZW1lLmNvbG9ycy5pY29uLnNlY29uZGFyeSwgMC4xMil9O1xuYDtcbmNsYXNzIEFuaW1hdGlvblRpbWVsaW5lTm9vcCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICB9XG59XG5jb25zdCBfQW5pbWF0aW9uTm9vcCA9IGNsYXNzIF9BbmltYXRpb25Ob29wIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IDA7XG4gICAgdGhpcy5wbGF5YmFja1JhdGUgPSAxO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgICB0aGlzLnRpbWVsaW5lID0gbmV3IEFuaW1hdGlvblRpbWVsaW5lTm9vcCgpO1xuICAgIHRoaXMuZmluaXNoZWQgPSBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgdGhpcy5lZmZlY3QgPSBudWxsO1xuICAgIHRoaXMuaWQgPSBcIlwiO1xuICAgIHRoaXMucGVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMucGxheVN0YXRlID0gXCJmaW5pc2hlZFwiO1xuICAgIHRoaXMucmVwbGFjZVN0YXRlID0gXCJhY3RpdmVcIjtcbiAgICB0aGlzLnJlYWR5ID0gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuICAgIHRoaXMub25jYW5jZWwgPSBudWxsO1xuICAgIHRoaXMub25maW5pc2ggPSBudWxsO1xuICAgIHRoaXMub25yZW1vdmUgPSBudWxsO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUoKSB7XG4gICAgaWYgKCFfQW5pbWF0aW9uTm9vcC5faW5zdGFuY2UpIHtcbiAgICAgIGxvZ1dhcm5pbmcoXG4gICAgICAgIFwiQW5pbWF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudDogcGxlYXNlIGNvbnNpZGVyIHVzaW5nIHRoZSBgd2ViLWFuaW1hdGlvbnMtanNgIHBvbHlmaWxsIHRvIHByb3ZpZGUgYSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgV2ViIEFuaW1hdGlvbnMgQVBJLlwiXG4gICAgICApO1xuICAgICAgX0FuaW1hdGlvbk5vb3AuX2luc3RhbmNlID0gbmV3IF9BbmltYXRpb25Ob29wKCk7XG4gICAgfVxuICAgIHJldHVybiBfQW5pbWF0aW9uTm9vcC5faW5zdGFuY2U7XG4gIH1cbiAgY2FuY2VsKCkge1xuICB9XG4gIGZpbmlzaCgpIHtcbiAgfVxuICBwYXVzZSgpIHtcbiAgfVxuICBwbGF5KCkge1xuICB9XG4gIHJldmVyc2UoKSB7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcihfdHlwZSwgX2xpc3RlbmVyLCBfb3B0aW9ucykge1xuICB9XG4gIGRpc3BhdGNoRXZlbnQoX2V2ZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoX3R5cGUsIF9jYWxsYmFjaywgX29wdGlvbnMpIHtcbiAgfVxuICB1cGRhdGVQbGF5YmFja1JhdGUoX3BsYXliYWNrUmF0ZSkge1xuICB9XG4gIGNvbW1pdFN0eWxlcygpIHtcbiAgfVxuICBwZXJzaXN0KCkge1xuICB9XG59O1xuX0FuaW1hdGlvbk5vb3AuX2luc3RhbmNlID0gbnVsbDtcbmxldCBBbmltYXRpb25Ob29wID0gX0FuaW1hdGlvbk5vb3A7XG5mdW5jdGlvbiBhbmltYXRlKGVsZW1lbnQsIGtleWZyYW1lcywgb3B0aW9ucykge1xuICBpZiAoXCJhbmltYXRlXCIgaW4gZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LmFuaW1hdGUoa2V5ZnJhbWVzLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gQW5pbWF0aW9uTm9vcC5jcmVhdGUoKTtcbn1cbnZhciBfdG1wbCQkdCA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8ZGl2PmApO1xuY29uc3QgY2xpY2tPdXRzaWRlID0gY2xpY2tPdXRzaWRlJDE7XG5jb25zdCBrZXlQcmVzc2VkID0gZXNjUHJlc3NlZDtcbmNvbnN0IGFuZHJvaWRCYWNrSGFuZGxlciA9IGFuZHJvaWRCYWNrSGFuZGxlciQxO1xuY29uc3QgTW9kYWwgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCBkYXRhQXR0cnMgPSB1c2VEYXRhQXR0cmlidXRlcyhwcm9wcyk7XG4gIGNyZWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHByb3BzLm9wZW5lZCkge1xuICAgICAgZGlzYWJsZVNjcm9sbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmFibGVTY3JvbGwoKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zaXRpb24sIHtcbiAgICBvbkJlZm9yZUVudGVyOiAoZWwpID0+IHtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gaXNEZXZpY2UoXCJtb2JpbGVcIikgPyAyMDAgOiAxMDA7XG4gICAgICBhbmltYXRlKGVsLCBbe1xuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9LCB7XG4gICAgICAgIG9wYWNpdHk6IDFcbiAgICAgIH1dLCB7XG4gICAgICAgIGR1cmF0aW9uXG4gICAgICB9KTtcbiAgICAgIGlmIChpc0RldmljZShcIm1vYmlsZVwiKSkge1xuICAgICAgICBhbmltYXRlKGVsLmZpcnN0RWxlbWVudENoaWxkLCBbe1xuICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVZKDM5MHB4KVwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSgwKVwiXG4gICAgICAgIH1dLCB7XG4gICAgICAgICAgZHVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkV4aXQ6IChlbCwgZG9uZSkgPT4ge1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBpc0RldmljZShcIm1vYmlsZVwiKSA/IDIwMCA6IDEwMDtcbiAgICAgIGNvbnN0IGJhY2tncm91bmRBbmltYXRpb24gPSBhbmltYXRlKGVsLCBbe1xuICAgICAgICBvcGFjaXR5OiAxXG4gICAgICB9LCB7XG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH1dLCB7XG4gICAgICAgIGR1cmF0aW9uXG4gICAgICB9KTtcbiAgICAgIGlmIChpc0RldmljZShcIm1vYmlsZVwiKSkge1xuICAgICAgICBjb25zdCBjb250ZW50QW5pbWF0aW9uID0gYW5pbWF0ZShlbC5maXJzdEVsZW1lbnRDaGlsZCwgW3tcbiAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSgwKVwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSgzOTBweClcIlxuICAgICAgICB9XSwge1xuICAgICAgICAgIGR1cmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBQcm9taXNlLmFsbChbYmFja2dyb3VuZEFuaW1hdGlvbi5maW5pc2hlZCwgY29udGVudEFuaW1hdGlvbi5maW5pc2hlZF0pLnRoZW4oZG9uZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYWNrZ3JvdW5kQW5pbWF0aW9uLmZpbmlzaGVkLnRoZW4oZG9uZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLm9wZW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoTW9kYWxCYWNrZ3JvdW5kU3R5bGVkLCBtZXJnZVByb3BzKHtcbiAgICAgICAgICAgIFwiZGF0YS10Yy1tb2RhbFwiOiBcInRydWVcIlxuICAgICAgICAgIH0sIGRhdGFBdHRycywge1xuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICB2YXIgX2VsJCA9IF90bXBsJCR0KCk7XG4gICAgICAgICAgICAgIHVzZShhbmRyb2lkQmFja0hhbmRsZXIsIF9lbCQsICgpID0+ICh7XG4gICAgICAgICAgICAgICAgaXNFbmFibGVkOiBwcm9wcy5lbmFibGVBbmRyb2lkQmFja0hhbmRsZXIsXG4gICAgICAgICAgICAgICAgb25DbG9zZTogKCkgPT4gcHJvcHMub25DbG9zZSgpXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgdXNlKGtleVByZXNzZWQsIF9lbCQsICgpID0+ICgpID0+IHByb3BzLm9uQ2xvc2UoKSk7XG4gICAgICAgICAgICAgIHVzZShjbGlja091dHNpZGUsIF9lbCQsICgpID0+ICgpID0+IHByb3BzLm9uQ2xvc2UoKSk7XG4gICAgICAgICAgICAgIGluc2VydChfZWwkLCBjcmVhdGVDb21wb25lbnQoTW9kYWxCb2R5U3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgZ2V0IFtcImNsYXNzXCJdKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoQ2xvc2VCdXR0b25TdHlsZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogXCJjbG9zZVwiLFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBwcm9wcy5vbkNsb3NlKClcbiAgICAgICAgICAgICAgICAgIH0pLCBtZW1vKCgpID0+IHByb3BzLmNoaWxkcmVuKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSwgbnVsbCk7XG4gICAgICAgICAgICAgIGluc2VydChfZWwkLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLm9uQ2xpY2tRdWVzdGlvbiAmJiBwcm9wcy5zaG93Rm9vdGVyO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChNb2RhbEZvb3RlclN0eWxlZCwge1xuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoVG9uQ29ubmVjdEJyYW5kLCB7fSksIGNyZWF0ZUNvbXBvbmVudChRdWVzdGlvbkJ1dHRvblN0eWxlZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IG9uQ2xpY2soKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy5vbkNsaWNrUXVlc3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogXCJxdWVzdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLCBudWxsKTtcbiAgICAgICAgICAgICAgY3JlYXRlUmVuZGVyRWZmZWN0KCgpID0+IGNsYXNzTmFtZShfZWwkLCBjbihNb2RhbFdyYXBwZXJDbGFzcywgdWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogJHtib3JkZXJzJDVbdGhlbWUuYm9yZGVyUmFkaXVzXX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWUuY29sb3JzLmJhY2tncm91bmQudGludH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHttZWRpYShcIm1vYmlsZVwiKX0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogJHtib3JkZXJzJDVbdGhlbWUuYm9yZGVyUmFkaXVzXX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAke2JvcmRlcnMkNVt0aGVtZS5ib3JkZXJSYWRpdXNdfSAwIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgKSkpO1xuICAgICAgICAgICAgICByZXR1cm4gX2VsJDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3Qgd3JhcHBlckJvcmRlclJhZGl1cyA9IHtcbiAgbTogXCIyMnB4XCIsXG4gIHM6IFwiMTJweFwiLFxuICBub25lOiBcIjBcIlxufTtcbmNvbnN0IHNsaWRlckJvcmRlclJhZGl1cyA9IHtcbiAgbTogXCIxOHB4XCIsXG4gIHM6IFwiOHB4XCIsXG4gIG5vbmU6IFwiMFwiXG59O1xuY29uc3QgVGFiQmFyU3R5bGVkID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBncmlkO1xuICAgIGdyaWQtdGVtcGxhdGU6IDFmciAvIDFmciAxZnI7XG4gICAgd2lkdGg6IGZpdC1jb250ZW50O1xuICAgIGp1c3RpZnktaXRlbXM6IGNlbnRlcjtcbiAgICBnYXA6IDRweDtcblxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBwYWRkaW5nOiA0cHg7XG4gICAgYm9yZGVyLXJhZGl1czogJHsocHJvcHMpID0+IHdyYXBwZXJCb3JkZXJSYWRpdXNbcHJvcHMudGhlbWUuYm9yZGVyUmFkaXVzXX07XG5cbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmJhY2tncm91bmQuc2Vjb25kYXJ5fTtcbmA7XG5jb25zdCBTbGlkZXJTdHlsZWQgPSBzdHlsZWQuZGl2YFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDRweDtcbiAgICBsZWZ0OiA0cHg7XG5cbiAgICBoZWlnaHQ6IGNhbGMoMTAwJSAtIDhweCk7XG4gICAgd2lkdGg6IGNhbGMoNTAlIC0gNHB4KTtcblxuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiBzbGlkZXJCb3JkZXJSYWRpdXNbcHJvcHMudGhlbWUuYm9yZGVyUmFkaXVzXX07XG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnNlZ21lbnR9O1xuXG4gICAgdHJhbnNmb3JtOiAkeyhwcm9wcykgPT4gcHJvcHMucmlnaHQgPyBcInRyYW5zbGF0ZVgoMTAwJSlcIiA6IFwidHJhbnNsYXRlWCgwKVwifTtcblxuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjEzcyBlYXNlLWluLW91dDtcbmA7XG5jb25zdCBJbnB1dFN0eWxlZCA9IHN0eWxlZC5pbnB1dGBcbiAgICBkaXNwbGF5OiBub25lO1xuYDtcbmNvbnN0IExhYmVsU3R5bGVkID0gc3R5bGVkLmxhYmVsYFxuICAgIHBhZGRpbmc6IDlweCAxMnB4O1xuICAgIHotaW5kZXg6IDE7XG5cbiAgICBjdXJzb3I6ICR7KHByb3BzKSA9PiBwcm9wcy5pc0FjdGl2ZSA/IFwiZGVmYXVsdFwiIDogXCJwb2ludGVyXCJ9O1xuXG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMTNzIGVhc2UtaW4tb3V0O1xuXG4gICAgJjpob3ZlciB7XG4gICAgICAgIHRyYW5zZm9ybTogJHsocHJvcHMpID0+IHByb3BzLmlzQWN0aXZlID8gXCJub25lXCIgOiBcInNjYWxlKDEuMDI1KVwifTtcbiAgICB9XG5cbiAgICA+ICoge1xuICAgICAgICAkeyhwcm9wcykgPT4gIXByb3BzLmlzQWN0aXZlID8gYGNvbG9yOiAke3Byb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeX07YCA6IFwiXCJ9XG4gICAgfVxuYDtcbmNvbnN0IFRhYkJhciA9IChwcm9wcykgPT4ge1xuICBjb25zdCBncm91cE5hbWUgPSBcInRhYkJhclwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMWU0KTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUYWJCYXJTdHlsZWQsIHtcbiAgICBnZXQgW1wiY2xhc3NcIl0oKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2xhc3M7XG4gICAgfSxcbiAgICBcImRhdGEtdGMtdGFiLWJhclwiOiBcInRydWVcIixcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTbGlkZXJTdHlsZWQsIHtcbiAgICAgICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICAgIHJldHVybiBwcm9wcy5zZWxlY3RlZFRhYkluZGV4ID09PSAxO1xuICAgICAgICB9XG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KExhYmVsU3R5bGVkLCB7XG4gICAgICAgIGdldCBpc0FjdGl2ZSgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcHMuc2VsZWN0ZWRUYWJJbmRleCA9PT0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KElucHV0U3R5bGVkLCB7XG4gICAgICAgICAgICB0eXBlOiBcInJhZGlvXCIsXG4gICAgICAgICAgICBuYW1lOiBncm91cE5hbWUsXG4gICAgICAgICAgICBnZXQgY2hlY2tlZCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLnNlbGVjdGVkVGFiSW5kZXggPT09IDA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25JbnB1dDogKCkgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgICAgICByZXR1cm4gKF9hMiA9IHByb3BzLm9uU2VsZWN0ZWRUYWJJbmRleENoYW5nZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYWxsKHByb3BzLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgbWVtbygoKSA9PiBwcm9wcy50YWIxKV07XG4gICAgICAgIH1cbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTGFiZWxTdHlsZWQsIHtcbiAgICAgICAgZ2V0IGlzQWN0aXZlKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wcy5zZWxlY3RlZFRhYkluZGV4ID09PSAxO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoSW5wdXRTdHlsZWQsIHtcbiAgICAgICAgICAgIHR5cGU6IFwicmFkaW9cIixcbiAgICAgICAgICAgIGdldCBjaGVja2VkKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuc2VsZWN0ZWRUYWJJbmRleCA9PT0gMTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiBncm91cE5hbWUsXG4gICAgICAgICAgICBvbklucHV0OiAoKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgICAgIHJldHVybiAoX2EyID0gcHJvcHMub25TZWxlY3RlZFRhYkluZGV4Q2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwocHJvcHMsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBtZW1vKCgpID0+IHByb3BzLnRhYjIpXTtcbiAgICAgICAgfVxuICAgICAgfSldO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3QgYmFja2dyb3VuZEJvcmRlcnMgPSB7XG4gIG06IFwiMTZweFwiLFxuICBzOiBcIjEycHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCBpbWFnZUJvcmRlcnMgPSB7XG4gIG06IFwiMTJweFwiLFxuICBzOiBcIjhweFwiLFxuICBub25lOiBcIjBcIlxufTtcbmNvbnN0IHFyTm9ybWFsU2l6ZSA9IDI1NjtcbmNvbnN0IGltZ1NpemVEZWZhdWx0ID0gNjA7XG5jb25zdCBwaWNTaXplRGVmYXVsdCA9IDQ4O1xuY29uc3QgcXJQYWRkaW5nVG9wID0gMjQ7XG5jb25zdCBDb3B5SWNvbkJ1dHRvbiA9IHN0eWxlZC5kaXZgXG4gICAgd2lkdGg6IDUycHg7XG4gICAgaGVpZ2h0OiA1MnB4O1xuICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICByaWdodDogMDtcbiAgICBib3R0b206IDA7XG5cbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMTI1cyBlYXNlLWluLW91dDtcbmA7XG5jb25zdCBRckNvZGVCYWNrZ3JvdW5kID0gc3R5bGVkLmJ1dHRvbmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5xcn07XG4gICAgYm9yZGVyLXJhZGl1czogJHsocHJvcHMpID0+IGJhY2tncm91bmRCb3JkZXJzW3Byb3BzLnRoZW1lLmJvcmRlclJhZGl1c119O1xuICAgIHBhZGRpbmc6ICR7dG9QeChxclBhZGRpbmdUb3ApfSAwO1xuICAgIGhlaWdodDogJHt0b1B4KHFyTm9ybWFsU2l6ZSArIHFyUGFkZGluZ1RvcCAqIDIpfTtcbiAgICB3aWR0aDogMTAwJTtcblxuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGJvcmRlcjogbm9uZTtcblxuICAgICR7bWVkaWFOb3RUb3VjaH0ge1xuICAgICAgICAmOmhvdmVyIHtcbiAgICAgICAgICAgICR7Q29weUljb25CdXR0b24uY2xhc3N9IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgJjphY3RpdmUge1xuICAgICAgICAke0NvcHlJY29uQnV0dG9uLmNsYXNzfSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuOTYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJHttZWRpYVRvdWNofSB7XG4gICAgICAgICY6YWN0aXZlIHtcbiAgICAgICAgICAgICR7Q29weUljb25CdXR0b24uY2xhc3N9IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuOTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuYDtcbmNvbnN0IFFyQ29kZVdyYXBwZXIkMiA9IHN0eWxlZC5kaXZgXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBtYXJnaW46IDAgYXV0bztcblxuICAgID4gZGl2OmZpcnN0LWNoaWxkIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgfVxuXG4gICAgcmVjdCB7XG4gICAgICAgIGZpbGw6IHRyYW5zcGFyZW50O1xuICAgIH1cblxuICAgIHBhdGgge1xuICAgICAgICBmaWxsOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmNvbnN0YW50LmJsYWNrfTtcbiAgICB9XG5gO1xuY29uc3QgSW1hZ2VCYWNrZ3JvdW5kID0gc3R5bGVkLmRpdmBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgd2lkdGg6ICR7dG9QeChpbWdTaXplRGVmYXVsdCl9O1xuICAgIGhlaWdodDogJHt0b1B4KGltZ1NpemVEZWZhdWx0KX07XG4gICAgYmFja2dyb3VuZDogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnFyfTtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbmA7XG5jb25zdCBJbWFnZVN0eWxlZCQzID0gc3R5bGVkKEltYWdlKWBcbiAgICB3aWR0aDogJHsocHJvcHMpID0+IHRvUHgocHJvcHMuc2l6ZSl9O1xuICAgIGhlaWdodDogJHsocHJvcHMpID0+IHRvUHgocHJvcHMuc2l6ZSl9O1xuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiBpbWFnZUJvcmRlcnNbcHJvcHMudGhlbWUuYm9yZGVyUmFkaXVzXX07XG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnFyfTtcbmA7XG5jb25zdCBDb3BpZWRCb3hTdHlsZWQgPSBzdHlsZWQuZGl2YFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBib3R0b206IDE0cHg7XG4gICAgbGVmdDogNTAlO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIDApO1xuXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBnYXA6IDZweDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGJvcmRlci1yYWRpdXM6IDE4cHg7XG4gICAgbWluLXdpZHRoOiAxMjZweDtcbiAgICBwYWRkaW5nOiA5cHggMTZweCA5cHggMTBweDtcblxuICAgIGZpbHRlcjogZHJvcC1zaGFkb3coMHB4IDJweCA4cHggcmdiYSgwLCAwLCAwLCAwLjA4KSk7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnNlZ21lbnR9O1xuYDtcbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHgpIHtcbiAgcmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCBcImRlZmF1bHRcIikgPyB4W1wiZGVmYXVsdFwiXSA6IHg7XG59XG52YXIgcXJjb2RlJDEgPSB7IGV4cG9ydHM6IHt9IH07XG52YXIgaGFzUmVxdWlyZWRRcmNvZGU7XG5mdW5jdGlvbiByZXF1aXJlUXJjb2RlKCkge1xuICBpZiAoaGFzUmVxdWlyZWRRcmNvZGUpIHJldHVybiBxcmNvZGUkMS5leHBvcnRzO1xuICBoYXNSZXF1aXJlZFFyY29kZSA9IDE7XG4gIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICB2YXIgcXJjb2RlMiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHFyY29kZTMgPSBmdW5jdGlvbih0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3Rpb25MZXZlbCkge1xuICAgICAgICB2YXIgUEFEMCA9IDIzNjtcbiAgICAgICAgdmFyIFBBRDEgPSAxNztcbiAgICAgICAgdmFyIF90eXBlTnVtYmVyID0gdHlwZU51bWJlcjtcbiAgICAgICAgdmFyIF9lcnJvckNvcnJlY3Rpb25MZXZlbCA9IFFSRXJyb3JDb3JyZWN0aW9uTGV2ZWxbZXJyb3JDb3JyZWN0aW9uTGV2ZWxdO1xuICAgICAgICB2YXIgX21vZHVsZXMgPSBudWxsO1xuICAgICAgICB2YXIgX21vZHVsZUNvdW50ID0gMDtcbiAgICAgICAgdmFyIF9kYXRhQ2FjaGUgPSBudWxsO1xuICAgICAgICB2YXIgX2RhdGFMaXN0ID0gW107XG4gICAgICAgIHZhciBfdGhpcyA9IHt9O1xuICAgICAgICB2YXIgbWFrZUltcGwgPSBmdW5jdGlvbih0ZXN0LCBtYXNrUGF0dGVybikge1xuICAgICAgICAgIF9tb2R1bGVDb3VudCA9IF90eXBlTnVtYmVyICogNCArIDE3O1xuICAgICAgICAgIF9tb2R1bGVzID0gZnVuY3Rpb24obW9kdWxlQ291bnQpIHtcbiAgICAgICAgICAgIHZhciBtb2R1bGVzID0gbmV3IEFycmF5KG1vZHVsZUNvdW50KTtcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vZHVsZUNvdW50OyByb3cgKz0gMSkge1xuICAgICAgICAgICAgICBtb2R1bGVzW3Jvd10gPSBuZXcgQXJyYXkobW9kdWxlQ291bnQpO1xuICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVzW3Jvd11bY29sXSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVzO1xuICAgICAgICAgIH0oX21vZHVsZUNvdW50KTtcbiAgICAgICAgICBzZXR1cFBvc2l0aW9uUHJvYmVQYXR0ZXJuKDAsIDApO1xuICAgICAgICAgIHNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4oX21vZHVsZUNvdW50IC0gNywgMCk7XG4gICAgICAgICAgc2V0dXBQb3NpdGlvblByb2JlUGF0dGVybigwLCBfbW9kdWxlQ291bnQgLSA3KTtcbiAgICAgICAgICBzZXR1cFBvc2l0aW9uQWRqdXN0UGF0dGVybigpO1xuICAgICAgICAgIHNldHVwVGltaW5nUGF0dGVybigpO1xuICAgICAgICAgIHNldHVwVHlwZUluZm8odGVzdCwgbWFza1BhdHRlcm4pO1xuICAgICAgICAgIGlmIChfdHlwZU51bWJlciA+PSA3KSB7XG4gICAgICAgICAgICBzZXR1cFR5cGVOdW1iZXIodGVzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfZGF0YUNhY2hlID09IG51bGwpIHtcbiAgICAgICAgICAgIF9kYXRhQ2FjaGUgPSBjcmVhdGVEYXRhKF90eXBlTnVtYmVyLCBfZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIF9kYXRhTGlzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcERhdGEoX2RhdGFDYWNoZSwgbWFza1BhdHRlcm4pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgc2V0dXBQb3NpdGlvblByb2JlUGF0dGVybiA9IGZ1bmN0aW9uKHJvdywgY29sKSB7XG4gICAgICAgICAgZm9yICh2YXIgciA9IC0xOyByIDw9IDc7IHIgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHJvdyArIHIgPD0gLTEgfHwgX21vZHVsZUNvdW50IDw9IHJvdyArIHIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgYzIgPSAtMTsgYzIgPD0gNzsgYzIgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAoY29sICsgYzIgPD0gLTEgfHwgX21vZHVsZUNvdW50IDw9IGNvbCArIGMyKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgaWYgKDAgPD0gciAmJiByIDw9IDYgJiYgKGMyID09IDAgfHwgYzIgPT0gNikgfHwgMCA8PSBjMiAmJiBjMiA8PSA2ICYmIChyID09IDAgfHwgciA9PSA2KSB8fCAyIDw9IHIgJiYgciA8PSA0ICYmIDIgPD0gYzIgJiYgYzIgPD0gNCkge1xuICAgICAgICAgICAgICAgIF9tb2R1bGVzW3JvdyArIHJdW2NvbCArIGMyXSA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX21vZHVsZXNbcm93ICsgcl1bY29sICsgYzJdID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXRCZXN0TWFza1BhdHRlcm4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgbWluTG9zdFBvaW50ID0gMDtcbiAgICAgICAgICB2YXIgcGF0dGVybiA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IDg7IGkyICs9IDEpIHtcbiAgICAgICAgICAgIG1ha2VJbXBsKHRydWUsIGkyKTtcbiAgICAgICAgICAgIHZhciBsb3N0UG9pbnQgPSBRUlV0aWwuZ2V0TG9zdFBvaW50KF90aGlzKTtcbiAgICAgICAgICAgIGlmIChpMiA9PSAwIHx8IG1pbkxvc3RQb2ludCA+IGxvc3RQb2ludCkge1xuICAgICAgICAgICAgICBtaW5Mb3N0UG9pbnQgPSBsb3N0UG9pbnQ7XG4gICAgICAgICAgICAgIHBhdHRlcm4gPSBpMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzZXR1cFRpbWluZ1BhdHRlcm4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmb3IgKHZhciByID0gODsgciA8IF9tb2R1bGVDb3VudCAtIDg7IHIgKz0gMSkge1xuICAgICAgICAgICAgaWYgKF9tb2R1bGVzW3JdWzZdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfbW9kdWxlc1tyXVs2XSA9IHIgJSAyID09IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGMyID0gODsgYzIgPCBfbW9kdWxlQ291bnQgLSA4OyBjMiArPSAxKSB7XG4gICAgICAgICAgICBpZiAoX21vZHVsZXNbNl1bYzJdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfbW9kdWxlc1s2XVtjMl0gPSBjMiAlIDIgPT0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzZXR1cFBvc2l0aW9uQWRqdXN0UGF0dGVybiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwb3MgPSBRUlV0aWwuZ2V0UGF0dGVyblBvc2l0aW9uKF90eXBlTnVtYmVyKTtcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgcG9zLmxlbmd0aDsgaTIgKz0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb3MubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIHJvdyA9IHBvc1tpMl07XG4gICAgICAgICAgICAgIHZhciBjb2wgPSBwb3Nbal07XG4gICAgICAgICAgICAgIGlmIChfbW9kdWxlc1tyb3ddW2NvbF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAodmFyIHIgPSAtMjsgciA8PSAyOyByICs9IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjMiA9IC0yOyBjMiA8PSAyOyBjMiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICBpZiAociA9PSAtMiB8fCByID09IDIgfHwgYzIgPT0gLTIgfHwgYzIgPT0gMiB8fCByID09IDAgJiYgYzIgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBfbW9kdWxlc1tyb3cgKyByXVtjb2wgKyBjMl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX21vZHVsZXNbcm93ICsgcl1bY29sICsgYzJdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgc2V0dXBUeXBlTnVtYmVyID0gZnVuY3Rpb24odGVzdCkge1xuICAgICAgICAgIHZhciBiaXRzID0gUVJVdGlsLmdldEJDSFR5cGVOdW1iZXIoX3R5cGVOdW1iZXIpO1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCAxODsgaTIgKz0gMSkge1xuICAgICAgICAgICAgdmFyIG1vZCA9ICF0ZXN0ICYmIChiaXRzID4+IGkyICYgMSkgPT0gMTtcbiAgICAgICAgICAgIF9tb2R1bGVzW01hdGguZmxvb3IoaTIgLyAzKV1baTIgJSAzICsgX21vZHVsZUNvdW50IC0gOCAtIDNdID0gbW9kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgMTg7IGkyICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBtb2QgPSAhdGVzdCAmJiAoYml0cyA+PiBpMiAmIDEpID09IDE7XG4gICAgICAgICAgICBfbW9kdWxlc1tpMiAlIDMgKyBfbW9kdWxlQ291bnQgLSA4IC0gM11bTWF0aC5mbG9vcihpMiAvIDMpXSA9IG1vZDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzZXR1cFR5cGVJbmZvID0gZnVuY3Rpb24odGVzdCwgbWFza1BhdHRlcm4pIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IF9lcnJvckNvcnJlY3Rpb25MZXZlbCA8PCAzIHwgbWFza1BhdHRlcm47XG4gICAgICAgICAgdmFyIGJpdHMgPSBRUlV0aWwuZ2V0QkNIVHlwZUluZm8oZGF0YSk7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IDE1OyBpMiArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbW9kID0gIXRlc3QgJiYgKGJpdHMgPj4gaTIgJiAxKSA9PSAxO1xuICAgICAgICAgICAgaWYgKGkyIDwgNikge1xuICAgICAgICAgICAgICBfbW9kdWxlc1tpMl1bOF0gPSBtb2Q7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkyIDwgOCkge1xuICAgICAgICAgICAgICBfbW9kdWxlc1tpMiArIDFdWzhdID0gbW9kO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX21vZHVsZXNbX21vZHVsZUNvdW50IC0gMTUgKyBpMl1bOF0gPSBtb2Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCAxNTsgaTIgKz0gMSkge1xuICAgICAgICAgICAgdmFyIG1vZCA9ICF0ZXN0ICYmIChiaXRzID4+IGkyICYgMSkgPT0gMTtcbiAgICAgICAgICAgIGlmIChpMiA8IDgpIHtcbiAgICAgICAgICAgICAgX21vZHVsZXNbOF1bX21vZHVsZUNvdW50IC0gaTIgLSAxXSA9IG1vZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaTIgPCA5KSB7XG4gICAgICAgICAgICAgIF9tb2R1bGVzWzhdWzE1IC0gaTIgLSAxICsgMV0gPSBtb2Q7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfbW9kdWxlc1s4XVsxNSAtIGkyIC0gMV0gPSBtb2Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIF9tb2R1bGVzW19tb2R1bGVDb3VudCAtIDhdWzhdID0gIXRlc3Q7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtYXBEYXRhID0gZnVuY3Rpb24oZGF0YSwgbWFza1BhdHRlcm4pIHtcbiAgICAgICAgICB2YXIgaW5jID0gLTE7XG4gICAgICAgICAgdmFyIHJvdyA9IF9tb2R1bGVDb3VudCAtIDE7XG4gICAgICAgICAgdmFyIGJpdEluZGV4ID0gNztcbiAgICAgICAgICB2YXIgYnl0ZUluZGV4ID0gMDtcbiAgICAgICAgICB2YXIgbWFza0Z1bmMgPSBRUlV0aWwuZ2V0TWFza0Z1bmN0aW9uKG1hc2tQYXR0ZXJuKTtcbiAgICAgICAgICBmb3IgKHZhciBjb2wgPSBfbW9kdWxlQ291bnQgLSAxOyBjb2wgPiAwOyBjb2wgLT0gMikge1xuICAgICAgICAgICAgaWYgKGNvbCA9PSA2KSBjb2wgLT0gMTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGMyID0gMDsgYzIgPCAyOyBjMiArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9tb2R1bGVzW3Jvd11bY29sIC0gYzJdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBkYXJrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBpZiAoYnl0ZUluZGV4IDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGFyayA9IChkYXRhW2J5dGVJbmRleF0gPj4+IGJpdEluZGV4ICYgMSkgPT0gMTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhciBtYXNrID0gbWFza0Z1bmMocm93LCBjb2wgLSBjMik7XG4gICAgICAgICAgICAgICAgICBpZiAobWFzaykge1xuICAgICAgICAgICAgICAgICAgICBkYXJrID0gIWRhcms7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfbW9kdWxlc1tyb3ddW2NvbCAtIGMyXSA9IGRhcms7XG4gICAgICAgICAgICAgICAgICBiaXRJbmRleCAtPSAxO1xuICAgICAgICAgICAgICAgICAgaWYgKGJpdEluZGV4ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVJbmRleCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBiaXRJbmRleCA9IDc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJvdyArPSBpbmM7XG4gICAgICAgICAgICAgIGlmIChyb3cgPCAwIHx8IF9tb2R1bGVDb3VudCA8PSByb3cpIHtcbiAgICAgICAgICAgICAgICByb3cgLT0gaW5jO1xuICAgICAgICAgICAgICAgIGluYyA9IC1pbmM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjcmVhdGVCeXRlcyA9IGZ1bmN0aW9uKGJ1ZmZlciwgcnNCbG9ja3MpIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICB2YXIgbWF4RGNDb3VudCA9IDA7XG4gICAgICAgICAgdmFyIG1heEVjQ291bnQgPSAwO1xuICAgICAgICAgIHZhciBkY2RhdGEgPSBuZXcgQXJyYXkocnNCbG9ja3MubGVuZ3RoKTtcbiAgICAgICAgICB2YXIgZWNkYXRhID0gbmV3IEFycmF5KHJzQmxvY2tzLmxlbmd0aCk7XG4gICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCByc0Jsb2Nrcy5sZW5ndGg7IHIgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGRjQ291bnQgPSByc0Jsb2Nrc1tyXS5kYXRhQ291bnQ7XG4gICAgICAgICAgICB2YXIgZWNDb3VudCA9IHJzQmxvY2tzW3JdLnRvdGFsQ291bnQgLSBkY0NvdW50O1xuICAgICAgICAgICAgbWF4RGNDb3VudCA9IE1hdGgubWF4KG1heERjQ291bnQsIGRjQ291bnQpO1xuICAgICAgICAgICAgbWF4RWNDb3VudCA9IE1hdGgubWF4KG1heEVjQ291bnQsIGVjQ291bnQpO1xuICAgICAgICAgICAgZGNkYXRhW3JdID0gbmV3IEFycmF5KGRjQ291bnQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGRjZGF0YVtyXS5sZW5ndGg7IGkyICs9IDEpIHtcbiAgICAgICAgICAgICAgZGNkYXRhW3JdW2kyXSA9IDI1NSAmIGJ1ZmZlci5nZXRCdWZmZXIoKVtpMiArIG9mZnNldF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gZGNDb3VudDtcbiAgICAgICAgICAgIHZhciByc1BvbHkgPSBRUlV0aWwuZ2V0RXJyb3JDb3JyZWN0UG9seW5vbWlhbChlY0NvdW50KTtcbiAgICAgICAgICAgIHZhciByYXdQb2x5ID0gcXJQb2x5bm9taWFsKGRjZGF0YVtyXSwgcnNQb2x5LmdldExlbmd0aCgpIC0gMSk7XG4gICAgICAgICAgICB2YXIgbW9kUG9seSA9IHJhd1BvbHkubW9kKHJzUG9seSk7XG4gICAgICAgICAgICBlY2RhdGFbcl0gPSBuZXcgQXJyYXkocnNQb2x5LmdldExlbmd0aCgpIC0gMSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgZWNkYXRhW3JdLmxlbmd0aDsgaTIgKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgbW9kSW5kZXggPSBpMiArIG1vZFBvbHkuZ2V0TGVuZ3RoKCkgLSBlY2RhdGFbcl0ubGVuZ3RoO1xuICAgICAgICAgICAgICBlY2RhdGFbcl1baTJdID0gbW9kSW5kZXggPj0gMCA/IG1vZFBvbHkuZ2V0QXQobW9kSW5kZXgpIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRvdGFsQ29kZUNvdW50ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgcnNCbG9ja3MubGVuZ3RoOyBpMiArPSAxKSB7XG4gICAgICAgICAgICB0b3RhbENvZGVDb3VudCArPSByc0Jsb2Nrc1tpMl0udG90YWxDb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRhdGEgPSBuZXcgQXJyYXkodG90YWxDb2RlQ291bnQpO1xuICAgICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IG1heERjQ291bnQ7IGkyICs9IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcnNCbG9ja3MubGVuZ3RoOyByICs9IDEpIHtcbiAgICAgICAgICAgICAgaWYgKGkyIDwgZGNkYXRhW3JdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gZGNkYXRhW3JdW2kyXTtcbiAgICAgICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBtYXhFY0NvdW50OyBpMiArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHJzQmxvY2tzLmxlbmd0aDsgciArPSAxKSB7XG4gICAgICAgICAgICAgIGlmIChpMiA8IGVjZGF0YVtyXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkYXRhW2luZGV4XSA9IGVjZGF0YVtyXVtpMl07XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNyZWF0ZURhdGEgPSBmdW5jdGlvbih0eXBlTnVtYmVyMiwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwyLCBkYXRhTGlzdCkge1xuICAgICAgICAgIHZhciByc0Jsb2NrcyA9IFFSUlNCbG9jay5nZXRSU0Jsb2Nrcyh0eXBlTnVtYmVyMiwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwyKTtcbiAgICAgICAgICB2YXIgYnVmZmVyID0gcXJCaXRCdWZmZXIoKTtcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgZGF0YUxpc3QubGVuZ3RoOyBpMiArPSAxKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGRhdGFMaXN0W2kyXTtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXQoZGF0YS5nZXRNb2RlKCksIDQpO1xuICAgICAgICAgICAgYnVmZmVyLnB1dChkYXRhLmdldExlbmd0aCgpLCBRUlV0aWwuZ2V0TGVuZ3RoSW5CaXRzKGRhdGEuZ2V0TW9kZSgpLCB0eXBlTnVtYmVyMikpO1xuICAgICAgICAgICAgZGF0YS53cml0ZShidWZmZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdG90YWxEYXRhQ291bnQgPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCByc0Jsb2Nrcy5sZW5ndGg7IGkyICs9IDEpIHtcbiAgICAgICAgICAgIHRvdGFsRGF0YUNvdW50ICs9IHJzQmxvY2tzW2kyXS5kYXRhQ291bnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgPiB0b3RhbERhdGFDb3VudCAqIDgpIHtcbiAgICAgICAgICAgIHRocm93IFwiY29kZSBsZW5ndGggb3ZlcmZsb3cuIChcIiArIGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSArIFwiPlwiICsgdG90YWxEYXRhQ291bnQgKiA4ICsgXCIpXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgKyA0IDw9IHRvdGFsRGF0YUNvdW50ICogOCkge1xuICAgICAgICAgICAgYnVmZmVyLnB1dCgwLCA0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSAlIDggIT0gMCkge1xuICAgICAgICAgICAgYnVmZmVyLnB1dEJpdChmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpID49IHRvdGFsRGF0YUNvdW50ICogOCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5wdXQoUEFEMCwgOCk7XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpID49IHRvdGFsRGF0YUNvdW50ICogOCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5wdXQoUEFEMSwgOCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjcmVhdGVCeXRlcyhidWZmZXIsIHJzQmxvY2tzKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuYWRkRGF0YSA9IGZ1bmN0aW9uKGRhdGEsIG1vZGUpIHtcbiAgICAgICAgICBtb2RlID0gbW9kZSB8fCBcIkJ5dGVcIjtcbiAgICAgICAgICB2YXIgbmV3RGF0YSA9IG51bGw7XG4gICAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICBjYXNlIFwiTnVtZXJpY1wiOlxuICAgICAgICAgICAgICBuZXdEYXRhID0gcXJOdW1iZXIoZGF0YSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkFscGhhbnVtZXJpY1wiOlxuICAgICAgICAgICAgICBuZXdEYXRhID0gcXJBbHBoYU51bShkYXRhKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQnl0ZVwiOlxuICAgICAgICAgICAgICBuZXdEYXRhID0gcXI4Qml0Qnl0ZShkYXRhKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiS2FuamlcIjpcbiAgICAgICAgICAgICAgbmV3RGF0YSA9IHFyS2FuamkoZGF0YSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgXCJtb2RlOlwiICsgbW9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2RhdGFMaXN0LnB1c2gobmV3RGF0YSk7XG4gICAgICAgICAgX2RhdGFDYWNoZSA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzRGFyayA9IGZ1bmN0aW9uKHJvdywgY29sKSB7XG4gICAgICAgICAgaWYgKHJvdyA8IDAgfHwgX21vZHVsZUNvdW50IDw9IHJvdyB8fCBjb2wgPCAwIHx8IF9tb2R1bGVDb3VudCA8PSBjb2wpIHtcbiAgICAgICAgICAgIHRocm93IHJvdyArIFwiLFwiICsgY29sO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX21vZHVsZXNbcm93XVtjb2xdO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRNb2R1bGVDb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfbW9kdWxlQ291bnQ7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm1ha2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoX3R5cGVOdW1iZXIgPCAxKSB7XG4gICAgICAgICAgICB2YXIgdHlwZU51bWJlcjIgPSAxO1xuICAgICAgICAgICAgZm9yICg7IHR5cGVOdW1iZXIyIDwgNDA7IHR5cGVOdW1iZXIyKyspIHtcbiAgICAgICAgICAgICAgdmFyIHJzQmxvY2tzID0gUVJSU0Jsb2NrLmdldFJTQmxvY2tzKHR5cGVOdW1iZXIyLCBfZXJyb3JDb3JyZWN0aW9uTGV2ZWwpO1xuICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gcXJCaXRCdWZmZXIoKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IF9kYXRhTGlzdC5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IF9kYXRhTGlzdFtpMl07XG4gICAgICAgICAgICAgICAgYnVmZmVyLnB1dChkYXRhLmdldE1vZGUoKSwgNCk7XG4gICAgICAgICAgICAgICAgYnVmZmVyLnB1dChkYXRhLmdldExlbmd0aCgpLCBRUlV0aWwuZ2V0TGVuZ3RoSW5CaXRzKGRhdGEuZ2V0TW9kZSgpLCB0eXBlTnVtYmVyMikpO1xuICAgICAgICAgICAgICAgIGRhdGEud3JpdGUoYnVmZmVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgdG90YWxEYXRhQ291bnQgPSAwO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgcnNCbG9ja3MubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgICAgICAgdG90YWxEYXRhQ291bnQgKz0gcnNCbG9ja3NbaTJdLmRhdGFDb3VudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpIDw9IHRvdGFsRGF0YUNvdW50ICogOCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdHlwZU51bWJlciA9IHR5cGVOdW1iZXIyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYWtlSW1wbChmYWxzZSwgZ2V0QmVzdE1hc2tQYXR0ZXJuKCkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5jcmVhdGVUYWJsZVRhZyA9IGZ1bmN0aW9uKGNlbGxTaXplLCBtYXJnaW4pIHtcbiAgICAgICAgICBjZWxsU2l6ZSA9IGNlbGxTaXplIHx8IDI7XG4gICAgICAgICAgbWFyZ2luID0gdHlwZW9mIG1hcmdpbiA9PSBcInVuZGVmaW5lZFwiID8gY2VsbFNpemUgKiA0IDogbWFyZ2luO1xuICAgICAgICAgIHZhciBxckh0bWwgPSBcIlwiO1xuICAgICAgICAgIHFySHRtbCArPSAnPHRhYmxlIHN0eWxlPVwiJztcbiAgICAgICAgICBxckh0bWwgKz0gXCIgYm9yZGVyLXdpZHRoOiAwcHg7IGJvcmRlci1zdHlsZTogbm9uZTtcIjtcbiAgICAgICAgICBxckh0bWwgKz0gXCIgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcIjtcbiAgICAgICAgICBxckh0bWwgKz0gXCIgcGFkZGluZzogMHB4OyBtYXJnaW46IFwiICsgbWFyZ2luICsgXCJweDtcIjtcbiAgICAgICAgICBxckh0bWwgKz0gJ1wiPic7XG4gICAgICAgICAgcXJIdG1sICs9IFwiPHRib2R5PlwiO1xuICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgX3RoaXMuZ2V0TW9kdWxlQ291bnQoKTsgciArPSAxKSB7XG4gICAgICAgICAgICBxckh0bWwgKz0gXCI8dHI+XCI7XG4gICAgICAgICAgICBmb3IgKHZhciBjMiA9IDA7IGMyIDwgX3RoaXMuZ2V0TW9kdWxlQ291bnQoKTsgYzIgKz0gMSkge1xuICAgICAgICAgICAgICBxckh0bWwgKz0gJzx0ZCBzdHlsZT1cIic7XG4gICAgICAgICAgICAgIHFySHRtbCArPSBcIiBib3JkZXItd2lkdGg6IDBweDsgYm9yZGVyLXN0eWxlOiBub25lO1wiO1xuICAgICAgICAgICAgICBxckh0bWwgKz0gXCIgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcIjtcbiAgICAgICAgICAgICAgcXJIdG1sICs9IFwiIHBhZGRpbmc6IDBweDsgbWFyZ2luOiAwcHg7XCI7XG4gICAgICAgICAgICAgIHFySHRtbCArPSBcIiB3aWR0aDogXCIgKyBjZWxsU2l6ZSArIFwicHg7XCI7XG4gICAgICAgICAgICAgIHFySHRtbCArPSBcIiBoZWlnaHQ6IFwiICsgY2VsbFNpemUgKyBcInB4O1wiO1xuICAgICAgICAgICAgICBxckh0bWwgKz0gXCIgYmFja2dyb3VuZC1jb2xvcjogXCI7XG4gICAgICAgICAgICAgIHFySHRtbCArPSBfdGhpcy5pc0RhcmsociwgYzIpID8gXCIjMDAwMDAwXCIgOiBcIiNmZmZmZmZcIjtcbiAgICAgICAgICAgICAgcXJIdG1sICs9IFwiO1wiO1xuICAgICAgICAgICAgICBxckh0bWwgKz0gJ1wiLz4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXJIdG1sICs9IFwiPC90cj5cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcXJIdG1sICs9IFwiPC90Ym9keT5cIjtcbiAgICAgICAgICBxckh0bWwgKz0gXCI8L3RhYmxlPlwiO1xuICAgICAgICAgIHJldHVybiBxckh0bWw7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmNyZWF0ZVN2Z1RhZyA9IGZ1bmN0aW9uKGNlbGxTaXplLCBtYXJnaW4sIGFsdCwgdGl0bGUpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IHt9O1xuICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIG9wdHMgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBjZWxsU2l6ZSA9IG9wdHMuY2VsbFNpemU7XG4gICAgICAgICAgICBtYXJnaW4gPSBvcHRzLm1hcmdpbjtcbiAgICAgICAgICAgIGFsdCA9IG9wdHMuYWx0O1xuICAgICAgICAgICAgdGl0bGUgPSBvcHRzLnRpdGxlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjZWxsU2l6ZSA9IGNlbGxTaXplIHx8IDI7XG4gICAgICAgICAgbWFyZ2luID0gdHlwZW9mIG1hcmdpbiA9PSBcInVuZGVmaW5lZFwiID8gY2VsbFNpemUgKiA0IDogbWFyZ2luO1xuICAgICAgICAgIGFsdCA9IHR5cGVvZiBhbHQgPT09IFwic3RyaW5nXCIgPyB7IHRleHQ6IGFsdCB9IDogYWx0IHx8IHt9O1xuICAgICAgICAgIGFsdC50ZXh0ID0gYWx0LnRleHQgfHwgbnVsbDtcbiAgICAgICAgICBhbHQuaWQgPSBhbHQudGV4dCA/IGFsdC5pZCB8fCBcInFyY29kZS1kZXNjcmlwdGlvblwiIDogbnVsbDtcbiAgICAgICAgICB0aXRsZSA9IHR5cGVvZiB0aXRsZSA9PT0gXCJzdHJpbmdcIiA/IHsgdGV4dDogdGl0bGUgfSA6IHRpdGxlIHx8IHt9O1xuICAgICAgICAgIHRpdGxlLnRleHQgPSB0aXRsZS50ZXh0IHx8IG51bGw7XG4gICAgICAgICAgdGl0bGUuaWQgPSB0aXRsZS50ZXh0ID8gdGl0bGUuaWQgfHwgXCJxcmNvZGUtdGl0bGVcIiA6IG51bGw7XG4gICAgICAgICAgdmFyIHNpemUgPSBfdGhpcy5nZXRNb2R1bGVDb3VudCgpICogY2VsbFNpemUgKyBtYXJnaW4gKiAyO1xuICAgICAgICAgIHZhciBjMiwgbWMsIHIsIG1yLCBxclN2ZyA9IFwiXCIsIHJlY3Q7XG4gICAgICAgICAgcmVjdCA9IFwibFwiICsgY2VsbFNpemUgKyBcIiwwIDAsXCIgKyBjZWxsU2l6ZSArIFwiIC1cIiArIGNlbGxTaXplICsgXCIsMCAwLC1cIiArIGNlbGxTaXplICsgXCJ6IFwiO1xuICAgICAgICAgIHFyU3ZnICs9ICc8c3ZnIHZlcnNpb249XCIxLjFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCInO1xuICAgICAgICAgIHFyU3ZnICs9ICFvcHRzLnNjYWxhYmxlID8gJyB3aWR0aD1cIicgKyBzaXplICsgJ3B4XCIgaGVpZ2h0PVwiJyArIHNpemUgKyAncHhcIicgOiBcIlwiO1xuICAgICAgICAgIHFyU3ZnICs9ICcgdmlld0JveD1cIjAgMCAnICsgc2l6ZSArIFwiIFwiICsgc2l6ZSArICdcIiAnO1xuICAgICAgICAgIHFyU3ZnICs9ICcgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaW5ZTWluIG1lZXRcIic7XG4gICAgICAgICAgcXJTdmcgKz0gdGl0bGUudGV4dCB8fCBhbHQudGV4dCA/ICcgcm9sZT1cImltZ1wiIGFyaWEtbGFiZWxsZWRieT1cIicgKyBlc2NhcGVYbWwoW3RpdGxlLmlkLCBhbHQuaWRdLmpvaW4oXCIgXCIpLnRyaW0oKSkgKyAnXCInIDogXCJcIjtcbiAgICAgICAgICBxclN2ZyArPSBcIj5cIjtcbiAgICAgICAgICBxclN2ZyArPSB0aXRsZS50ZXh0ID8gJzx0aXRsZSBpZD1cIicgKyBlc2NhcGVYbWwodGl0bGUuaWQpICsgJ1wiPicgKyBlc2NhcGVYbWwodGl0bGUudGV4dCkgKyBcIjwvdGl0bGU+XCIgOiBcIlwiO1xuICAgICAgICAgIHFyU3ZnICs9IGFsdC50ZXh0ID8gJzxkZXNjcmlwdGlvbiBpZD1cIicgKyBlc2NhcGVYbWwoYWx0LmlkKSArICdcIj4nICsgZXNjYXBlWG1sKGFsdC50ZXh0KSArIFwiPC9kZXNjcmlwdGlvbj5cIiA6IFwiXCI7XG4gICAgICAgICAgcXJTdmcgKz0gJzxyZWN0IHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiBmaWxsPVwid2hpdGVcIiBjeD1cIjBcIiBjeT1cIjBcIi8+JztcbiAgICAgICAgICBxclN2ZyArPSAnPHBhdGggZD1cIic7XG4gICAgICAgICAgZm9yIChyID0gMDsgciA8IF90aGlzLmdldE1vZHVsZUNvdW50KCk7IHIgKz0gMSkge1xuICAgICAgICAgICAgbXIgPSByICogY2VsbFNpemUgKyBtYXJnaW47XG4gICAgICAgICAgICBmb3IgKGMyID0gMDsgYzIgPCBfdGhpcy5nZXRNb2R1bGVDb3VudCgpOyBjMiArPSAxKSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5pc0RhcmsociwgYzIpKSB7XG4gICAgICAgICAgICAgICAgbWMgPSBjMiAqIGNlbGxTaXplICsgbWFyZ2luO1xuICAgICAgICAgICAgICAgIHFyU3ZnICs9IFwiTVwiICsgbWMgKyBcIixcIiArIG1yICsgcmVjdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBxclN2ZyArPSAnXCIgc3Ryb2tlPVwidHJhbnNwYXJlbnRcIiBmaWxsPVwiYmxhY2tcIi8+JztcbiAgICAgICAgICBxclN2ZyArPSBcIjwvc3ZnPlwiO1xuICAgICAgICAgIHJldHVybiBxclN2ZztcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuY3JlYXRlRGF0YVVSTCA9IGZ1bmN0aW9uKGNlbGxTaXplLCBtYXJnaW4pIHtcbiAgICAgICAgICBjZWxsU2l6ZSA9IGNlbGxTaXplIHx8IDI7XG4gICAgICAgICAgbWFyZ2luID0gdHlwZW9mIG1hcmdpbiA9PSBcInVuZGVmaW5lZFwiID8gY2VsbFNpemUgKiA0IDogbWFyZ2luO1xuICAgICAgICAgIHZhciBzaXplID0gX3RoaXMuZ2V0TW9kdWxlQ291bnQoKSAqIGNlbGxTaXplICsgbWFyZ2luICogMjtcbiAgICAgICAgICB2YXIgbWluMiA9IG1hcmdpbjtcbiAgICAgICAgICB2YXIgbWF4MiA9IHNpemUgLSBtYXJnaW47XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZURhdGFVUkwoc2l6ZSwgc2l6ZSwgZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgaWYgKG1pbjIgPD0geCAmJiB4IDwgbWF4MiAmJiBtaW4yIDw9IHkgJiYgeSA8IG1heDIpIHtcbiAgICAgICAgICAgICAgdmFyIGMyID0gTWF0aC5mbG9vcigoeCAtIG1pbjIpIC8gY2VsbFNpemUpO1xuICAgICAgICAgICAgICB2YXIgciA9IE1hdGguZmxvb3IoKHkgLSBtaW4yKSAvIGNlbGxTaXplKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmlzRGFyayhyLCBjMikgPyAwIDogMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5jcmVhdGVJbWdUYWcgPSBmdW5jdGlvbihjZWxsU2l6ZSwgbWFyZ2luLCBhbHQpIHtcbiAgICAgICAgICBjZWxsU2l6ZSA9IGNlbGxTaXplIHx8IDI7XG4gICAgICAgICAgbWFyZ2luID0gdHlwZW9mIG1hcmdpbiA9PSBcInVuZGVmaW5lZFwiID8gY2VsbFNpemUgKiA0IDogbWFyZ2luO1xuICAgICAgICAgIHZhciBzaXplID0gX3RoaXMuZ2V0TW9kdWxlQ291bnQoKSAqIGNlbGxTaXplICsgbWFyZ2luICogMjtcbiAgICAgICAgICB2YXIgaW1nID0gXCJcIjtcbiAgICAgICAgICBpbWcgKz0gXCI8aW1nXCI7XG4gICAgICAgICAgaW1nICs9ICcgc3JjPVwiJztcbiAgICAgICAgICBpbWcgKz0gX3RoaXMuY3JlYXRlRGF0YVVSTChjZWxsU2l6ZSwgbWFyZ2luKTtcbiAgICAgICAgICBpbWcgKz0gJ1wiJztcbiAgICAgICAgICBpbWcgKz0gJyB3aWR0aD1cIic7XG4gICAgICAgICAgaW1nICs9IHNpemU7XG4gICAgICAgICAgaW1nICs9ICdcIic7XG4gICAgICAgICAgaW1nICs9ICcgaGVpZ2h0PVwiJztcbiAgICAgICAgICBpbWcgKz0gc2l6ZTtcbiAgICAgICAgICBpbWcgKz0gJ1wiJztcbiAgICAgICAgICBpZiAoYWx0KSB7XG4gICAgICAgICAgICBpbWcgKz0gJyBhbHQ9XCInO1xuICAgICAgICAgICAgaW1nICs9IGVzY2FwZVhtbChhbHQpO1xuICAgICAgICAgICAgaW1nICs9ICdcIic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGltZyArPSBcIi8+XCI7XG4gICAgICAgICAgcmV0dXJuIGltZztcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGVzY2FwZVhtbCA9IGZ1bmN0aW9uKHMyKSB7XG4gICAgICAgICAgdmFyIGVzY2FwZWQgPSBcIlwiO1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBzMi5sZW5ndGg7IGkyICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBjMiA9IHMyLmNoYXJBdChpMik7XG4gICAgICAgICAgICBzd2l0Y2ggKGMyKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgICAgICAgICAgZXNjYXBlZCArPSBcIiZsdDtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICAgICAgICBlc2NhcGVkICs9IFwiJmd0O1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiJlwiOlxuICAgICAgICAgICAgICAgIGVzY2FwZWQgKz0gXCImYW1wO1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICAgICAgZXNjYXBlZCArPSBcIiZxdW90O1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGVzY2FwZWQgKz0gYzI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlc2NhcGVkO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgX2NyZWF0ZUhhbGZBU0NJSSA9IGZ1bmN0aW9uKG1hcmdpbikge1xuICAgICAgICAgIHZhciBjZWxsU2l6ZSA9IDE7XG4gICAgICAgICAgbWFyZ2luID0gdHlwZW9mIG1hcmdpbiA9PSBcInVuZGVmaW5lZFwiID8gY2VsbFNpemUgKiAyIDogbWFyZ2luO1xuICAgICAgICAgIHZhciBzaXplID0gX3RoaXMuZ2V0TW9kdWxlQ291bnQoKSAqIGNlbGxTaXplICsgbWFyZ2luICogMjtcbiAgICAgICAgICB2YXIgbWluMiA9IG1hcmdpbjtcbiAgICAgICAgICB2YXIgbWF4MiA9IHNpemUgLSBtYXJnaW47XG4gICAgICAgICAgdmFyIHksIHgsIHIxLCByMiwgcDI7XG4gICAgICAgICAgdmFyIGJsb2NrcyA9IHtcbiAgICAgICAgICAgIFwi4paI4paIXCI6IFwi4paIXCIsXG4gICAgICAgICAgICBcIuKWiCBcIjogXCLiloBcIixcbiAgICAgICAgICAgIFwiIOKWiFwiOiBcIuKWhFwiLFxuICAgICAgICAgICAgXCIgIFwiOiBcIiBcIlxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGJsb2Nrc0xhc3RMaW5lTm9NYXJnaW4gPSB7XG4gICAgICAgICAgICBcIuKWiOKWiFwiOiBcIuKWgFwiLFxuICAgICAgICAgICAgXCLiloggXCI6IFwi4paAXCIsXG4gICAgICAgICAgICBcIiDilohcIjogXCIgXCIsXG4gICAgICAgICAgICBcIiAgXCI6IFwiIFwiXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgYXNjaWkgPSBcIlwiO1xuICAgICAgICAgIGZvciAoeSA9IDA7IHkgPCBzaXplOyB5ICs9IDIpIHtcbiAgICAgICAgICAgIHIxID0gTWF0aC5mbG9vcigoeSAtIG1pbjIpIC8gY2VsbFNpemUpO1xuICAgICAgICAgICAgcjIgPSBNYXRoLmZsb29yKCh5ICsgMSAtIG1pbjIpIC8gY2VsbFNpemUpO1xuICAgICAgICAgICAgZm9yICh4ID0gMDsgeCA8IHNpemU7IHggKz0gMSkge1xuICAgICAgICAgICAgICBwMiA9IFwi4paIXCI7XG4gICAgICAgICAgICAgIGlmIChtaW4yIDw9IHggJiYgeCA8IG1heDIgJiYgbWluMiA8PSB5ICYmIHkgPCBtYXgyICYmIF90aGlzLmlzRGFyayhyMSwgTWF0aC5mbG9vcigoeCAtIG1pbjIpIC8gY2VsbFNpemUpKSkge1xuICAgICAgICAgICAgICAgIHAyID0gXCIgXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1pbjIgPD0geCAmJiB4IDwgbWF4MiAmJiBtaW4yIDw9IHkgKyAxICYmIHkgKyAxIDwgbWF4MiAmJiBfdGhpcy5pc0RhcmsocjIsIE1hdGguZmxvb3IoKHggLSBtaW4yKSAvIGNlbGxTaXplKSkpIHtcbiAgICAgICAgICAgICAgICBwMiArPSBcIiBcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwMiArPSBcIuKWiFwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFzY2lpICs9IG1hcmdpbiA8IDEgJiYgeSArIDEgPj0gbWF4MiA/IGJsb2Nrc0xhc3RMaW5lTm9NYXJnaW5bcDJdIDogYmxvY2tzW3AyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzY2lpICs9IFwiXFxuXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaXplICUgMiAmJiBtYXJnaW4gPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXNjaWkuc3Vic3RyaW5nKDAsIGFzY2lpLmxlbmd0aCAtIHNpemUgLSAxKSArIEFycmF5KHNpemUgKyAxKS5qb2luKFwi4paAXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXNjaWkuc3Vic3RyaW5nKDAsIGFzY2lpLmxlbmd0aCAtIDEpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5jcmVhdGVBU0NJSSA9IGZ1bmN0aW9uKGNlbGxTaXplLCBtYXJnaW4pIHtcbiAgICAgICAgICBjZWxsU2l6ZSA9IGNlbGxTaXplIHx8IDE7XG4gICAgICAgICAgaWYgKGNlbGxTaXplIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVIYWxmQVNDSUkobWFyZ2luKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2VsbFNpemUgLT0gMTtcbiAgICAgICAgICBtYXJnaW4gPSB0eXBlb2YgbWFyZ2luID09IFwidW5kZWZpbmVkXCIgPyBjZWxsU2l6ZSAqIDIgOiBtYXJnaW47XG4gICAgICAgICAgdmFyIHNpemUgPSBfdGhpcy5nZXRNb2R1bGVDb3VudCgpICogY2VsbFNpemUgKyBtYXJnaW4gKiAyO1xuICAgICAgICAgIHZhciBtaW4yID0gbWFyZ2luO1xuICAgICAgICAgIHZhciBtYXgyID0gc2l6ZSAtIG1hcmdpbjtcbiAgICAgICAgICB2YXIgeSwgeCwgciwgcDI7XG4gICAgICAgICAgdmFyIHdoaXRlID0gQXJyYXkoY2VsbFNpemUgKyAxKS5qb2luKFwi4paI4paIXCIpO1xuICAgICAgICAgIHZhciBibGFjayA9IEFycmF5KGNlbGxTaXplICsgMSkuam9pbihcIiAgXCIpO1xuICAgICAgICAgIHZhciBhc2NpaSA9IFwiXCI7XG4gICAgICAgICAgdmFyIGxpbmUgPSBcIlwiO1xuICAgICAgICAgIGZvciAoeSA9IDA7IHkgPCBzaXplOyB5ICs9IDEpIHtcbiAgICAgICAgICAgIHIgPSBNYXRoLmZsb29yKCh5IC0gbWluMikgLyBjZWxsU2l6ZSk7XG4gICAgICAgICAgICBsaW5lID0gXCJcIjtcbiAgICAgICAgICAgIGZvciAoeCA9IDA7IHggPCBzaXplOyB4ICs9IDEpIHtcbiAgICAgICAgICAgICAgcDIgPSAxO1xuICAgICAgICAgICAgICBpZiAobWluMiA8PSB4ICYmIHggPCBtYXgyICYmIG1pbjIgPD0geSAmJiB5IDwgbWF4MiAmJiBfdGhpcy5pc0RhcmsociwgTWF0aC5mbG9vcigoeCAtIG1pbjIpIC8gY2VsbFNpemUpKSkge1xuICAgICAgICAgICAgICAgIHAyID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsaW5lICs9IHAyID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAociA9IDA7IHIgPCBjZWxsU2l6ZTsgciArPSAxKSB7XG4gICAgICAgICAgICAgIGFzY2lpICs9IGxpbmUgKyBcIlxcblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXNjaWkuc3Vic3RyaW5nKDAsIGFzY2lpLmxlbmd0aCAtIDEpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJUbzJkQ29udGV4dCA9IGZ1bmN0aW9uKGNvbnRleHQsIGNlbGxTaXplKSB7XG4gICAgICAgICAgY2VsbFNpemUgPSBjZWxsU2l6ZSB8fCAyO1xuICAgICAgICAgIHZhciBsZW5ndGggPSBfdGhpcy5nZXRNb2R1bGVDb3VudCgpO1xuICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IGxlbmd0aDsgcm93KyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGxlbmd0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBfdGhpcy5pc0Rhcmsocm93LCBjb2wpID8gXCJibGFja1wiIDogXCJ3aGl0ZVwiO1xuICAgICAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHJvdyAqIGNlbGxTaXplLCBjb2wgKiBjZWxsU2l6ZSwgY2VsbFNpemUsIGNlbGxTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH07XG4gICAgICBxcmNvZGUzLnN0cmluZ1RvQnl0ZXNGdW5jcyA9IHtcbiAgICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uKHMyKSB7XG4gICAgICAgICAgdmFyIGJ5dGVzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHMyLmxlbmd0aDsgaTIgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGMyID0gczIuY2hhckNvZGVBdChpMik7XG4gICAgICAgICAgICBieXRlcy5wdXNoKGMyICYgMjU1KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcXJjb2RlMy5zdHJpbmdUb0J5dGVzID0gcXJjb2RlMy5zdHJpbmdUb0J5dGVzRnVuY3NbXCJkZWZhdWx0XCJdO1xuICAgICAgcXJjb2RlMy5jcmVhdGVTdHJpbmdUb0J5dGVzID0gZnVuY3Rpb24odW5pY29kZURhdGEsIG51bUNoYXJzKSB7XG4gICAgICAgIHZhciB1bmljb2RlTWFwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGJpbiA9IGJhc2U2NERlY29kZUlucHV0U3RyZWFtKHVuaWNvZGVEYXRhKTtcbiAgICAgICAgICB2YXIgcmVhZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGIgPSBiaW4ucmVhZCgpO1xuICAgICAgICAgICAgaWYgKGIgPT0gLTEpIHRocm93IFwiZW9mXCI7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgdmFyIHVuaWNvZGVNYXAyID0ge307XG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciBiMCA9IGJpbi5yZWFkKCk7XG4gICAgICAgICAgICBpZiAoYjAgPT0gLTEpIGJyZWFrO1xuICAgICAgICAgICAgdmFyIGIxID0gcmVhZCgpO1xuICAgICAgICAgICAgdmFyIGIyID0gcmVhZCgpO1xuICAgICAgICAgICAgdmFyIGIzID0gcmVhZCgpO1xuICAgICAgICAgICAgdmFyIGsgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGIwIDw8IDggfCBiMSk7XG4gICAgICAgICAgICB2YXIgdiA9IGIyIDw8IDggfCBiMztcbiAgICAgICAgICAgIHVuaWNvZGVNYXAyW2tdID0gdjtcbiAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3VudCAhPSBudW1DaGFycykge1xuICAgICAgICAgICAgdGhyb3cgY291bnQgKyBcIiAhPSBcIiArIG51bUNoYXJzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdW5pY29kZU1hcDI7XG4gICAgICAgIH0oKTtcbiAgICAgICAgdmFyIHVua25vd25DaGFyID0gXCI/XCIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHMyKSB7XG4gICAgICAgICAgdmFyIGJ5dGVzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHMyLmxlbmd0aDsgaTIgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGMyID0gczIuY2hhckNvZGVBdChpMik7XG4gICAgICAgICAgICBpZiAoYzIgPCAxMjgpIHtcbiAgICAgICAgICAgICAgYnl0ZXMucHVzaChjMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgYiA9IHVuaWNvZGVNYXBbczIuY2hhckF0KGkyKV07XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgYiA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKChiICYgMjU1KSA9PSBiKSB7XG4gICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKGIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKGIgPj4+IDgpO1xuICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaChiICYgMjU1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaCh1bmtub3duQ2hhcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHZhciBRUk1vZGUgPSB7XG4gICAgICAgIE1PREVfTlVNQkVSOiAxIDw8IDAsXG4gICAgICAgIE1PREVfQUxQSEFfTlVNOiAxIDw8IDEsXG4gICAgICAgIE1PREVfOEJJVF9CWVRFOiAxIDw8IDIsXG4gICAgICAgIE1PREVfS0FOSkk6IDEgPDwgM1xuICAgICAgfTtcbiAgICAgIHZhciBRUkVycm9yQ29ycmVjdGlvbkxldmVsID0ge1xuICAgICAgICBMOiAxLFxuICAgICAgICBNOiAwLFxuICAgICAgICBROiAzLFxuICAgICAgICBIOiAyXG4gICAgICB9O1xuICAgICAgdmFyIFFSTWFza1BhdHRlcm4gPSB7XG4gICAgICAgIFBBVFRFUk4wMDA6IDAsXG4gICAgICAgIFBBVFRFUk4wMDE6IDEsXG4gICAgICAgIFBBVFRFUk4wMTA6IDIsXG4gICAgICAgIFBBVFRFUk4wMTE6IDMsXG4gICAgICAgIFBBVFRFUk4xMDA6IDQsXG4gICAgICAgIFBBVFRFUk4xMDE6IDUsXG4gICAgICAgIFBBVFRFUk4xMTA6IDYsXG4gICAgICAgIFBBVFRFUk4xMTE6IDdcbiAgICAgIH07XG4gICAgICB2YXIgUVJVdGlsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBQQVRURVJOX1BPU0lUSU9OX1RBQkxFID0gW1xuICAgICAgICAgIFtdLFxuICAgICAgICAgIFs2LCAxOF0sXG4gICAgICAgICAgWzYsIDIyXSxcbiAgICAgICAgICBbNiwgMjZdLFxuICAgICAgICAgIFs2LCAzMF0sXG4gICAgICAgICAgWzYsIDM0XSxcbiAgICAgICAgICBbNiwgMjIsIDM4XSxcbiAgICAgICAgICBbNiwgMjQsIDQyXSxcbiAgICAgICAgICBbNiwgMjYsIDQ2XSxcbiAgICAgICAgICBbNiwgMjgsIDUwXSxcbiAgICAgICAgICBbNiwgMzAsIDU0XSxcbiAgICAgICAgICBbNiwgMzIsIDU4XSxcbiAgICAgICAgICBbNiwgMzQsIDYyXSxcbiAgICAgICAgICBbNiwgMjYsIDQ2LCA2Nl0sXG4gICAgICAgICAgWzYsIDI2LCA0OCwgNzBdLFxuICAgICAgICAgIFs2LCAyNiwgNTAsIDc0XSxcbiAgICAgICAgICBbNiwgMzAsIDU0LCA3OF0sXG4gICAgICAgICAgWzYsIDMwLCA1NiwgODJdLFxuICAgICAgICAgIFs2LCAzMCwgNTgsIDg2XSxcbiAgICAgICAgICBbNiwgMzQsIDYyLCA5MF0sXG4gICAgICAgICAgWzYsIDI4LCA1MCwgNzIsIDk0XSxcbiAgICAgICAgICBbNiwgMjYsIDUwLCA3NCwgOThdLFxuICAgICAgICAgIFs2LCAzMCwgNTQsIDc4LCAxMDJdLFxuICAgICAgICAgIFs2LCAyOCwgNTQsIDgwLCAxMDZdLFxuICAgICAgICAgIFs2LCAzMiwgNTgsIDg0LCAxMTBdLFxuICAgICAgICAgIFs2LCAzMCwgNTgsIDg2LCAxMTRdLFxuICAgICAgICAgIFs2LCAzNCwgNjIsIDkwLCAxMThdLFxuICAgICAgICAgIFs2LCAyNiwgNTAsIDc0LCA5OCwgMTIyXSxcbiAgICAgICAgICBbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjZdLFxuICAgICAgICAgIFs2LCAyNiwgNTIsIDc4LCAxMDQsIDEzMF0sXG4gICAgICAgICAgWzYsIDMwLCA1NiwgODIsIDEwOCwgMTM0XSxcbiAgICAgICAgICBbNiwgMzQsIDYwLCA4NiwgMTEyLCAxMzhdLFxuICAgICAgICAgIFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0Ml0sXG4gICAgICAgICAgWzYsIDM0LCA2MiwgOTAsIDExOCwgMTQ2XSxcbiAgICAgICAgICBbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYsIDE1MF0sXG4gICAgICAgICAgWzYsIDI0LCA1MCwgNzYsIDEwMiwgMTI4LCAxNTRdLFxuICAgICAgICAgIFs2LCAyOCwgNTQsIDgwLCAxMDYsIDEzMiwgMTU4XSxcbiAgICAgICAgICBbNiwgMzIsIDU4LCA4NCwgMTEwLCAxMzYsIDE2Ml0sXG4gICAgICAgICAgWzYsIDI2LCA1NCwgODIsIDExMCwgMTM4LCAxNjZdLFxuICAgICAgICAgIFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0MiwgMTcwXVxuICAgICAgICBdO1xuICAgICAgICB2YXIgRzE1ID0gMSA8PCAxMCB8IDEgPDwgOCB8IDEgPDwgNSB8IDEgPDwgNCB8IDEgPDwgMiB8IDEgPDwgMSB8IDEgPDwgMDtcbiAgICAgICAgdmFyIEcxOCA9IDEgPDwgMTIgfCAxIDw8IDExIHwgMSA8PCAxMCB8IDEgPDwgOSB8IDEgPDwgOCB8IDEgPDwgNSB8IDEgPDwgMiB8IDEgPDwgMDtcbiAgICAgICAgdmFyIEcxNV9NQVNLID0gMSA8PCAxNCB8IDEgPDwgMTIgfCAxIDw8IDEwIHwgMSA8PCA0IHwgMSA8PCAxO1xuICAgICAgICB2YXIgX3RoaXMgPSB7fTtcbiAgICAgICAgdmFyIGdldEJDSERpZ2l0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgIHZhciBkaWdpdCA9IDA7XG4gICAgICAgICAgd2hpbGUgKGRhdGEgIT0gMCkge1xuICAgICAgICAgICAgZGlnaXQgKz0gMTtcbiAgICAgICAgICAgIGRhdGEgPj4+PSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGlnaXQ7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldEJDSFR5cGVJbmZvID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgIHZhciBkID0gZGF0YSA8PCAxMDtcbiAgICAgICAgICB3aGlsZSAoZ2V0QkNIRGlnaXQoZCkgLSBnZXRCQ0hEaWdpdChHMTUpID49IDApIHtcbiAgICAgICAgICAgIGQgXj0gRzE1IDw8IGdldEJDSERpZ2l0KGQpIC0gZ2V0QkNIRGlnaXQoRzE1KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIChkYXRhIDw8IDEwIHwgZCkgXiBHMTVfTUFTSztcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0QkNIVHlwZU51bWJlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICB2YXIgZCA9IGRhdGEgPDwgMTI7XG4gICAgICAgICAgd2hpbGUgKGdldEJDSERpZ2l0KGQpIC0gZ2V0QkNIRGlnaXQoRzE4KSA+PSAwKSB7XG4gICAgICAgICAgICBkIF49IEcxOCA8PCBnZXRCQ0hEaWdpdChkKSAtIGdldEJDSERpZ2l0KEcxOCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkYXRhIDw8IDEyIHwgZDtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0UGF0dGVyblBvc2l0aW9uID0gZnVuY3Rpb24odHlwZU51bWJlcikge1xuICAgICAgICAgIHJldHVybiBQQVRURVJOX1BPU0lUSU9OX1RBQkxFW3R5cGVOdW1iZXIgLSAxXTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0TWFza0Z1bmN0aW9uID0gZnVuY3Rpb24obWFza1BhdHRlcm4pIHtcbiAgICAgICAgICBzd2l0Y2ggKG1hc2tQYXR0ZXJuKSB7XG4gICAgICAgICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjAwMDpcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGkyLCBqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpMiArIGopICUgMiA9PSAwO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4wMDE6XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihpMiwgaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpMiAlIDIgPT0gMDtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMDEwOlxuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oaTIsIGopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaiAlIDMgPT0gMDtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMDExOlxuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oaTIsIGopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGkyICsgaikgJSAzID09IDA7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjEwMDpcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGkyLCBqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChNYXRoLmZsb29yKGkyIC8gMikgKyBNYXRoLmZsb29yKGogLyAzKSkgJSAyID09IDA7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjEwMTpcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGkyLCBqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkyICogaiAlIDIgKyBpMiAqIGogJSAzID09IDA7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjExMDpcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGkyLCBqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpMiAqIGogJSAyICsgaTIgKiBqICUgMykgJSAyID09IDA7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjExMTpcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGkyLCBqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpMiAqIGogJSAzICsgKGkyICsgaikgJSAyKSAlIDIgPT0gMDtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IFwiYmFkIG1hc2tQYXR0ZXJuOlwiICsgbWFza1BhdHRlcm47XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRFcnJvckNvcnJlY3RQb2x5bm9taWFsID0gZnVuY3Rpb24oZXJyb3JDb3JyZWN0TGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGEyID0gcXJQb2x5bm9taWFsKFsxXSwgMCk7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGVycm9yQ29ycmVjdExlbmd0aDsgaTIgKz0gMSkge1xuICAgICAgICAgICAgYTIgPSBhMi5tdWx0aXBseShxclBvbHlub21pYWwoWzEsIFFSTWF0aC5nZXhwKGkyKV0sIDApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGEyO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRMZW5ndGhJbkJpdHMgPSBmdW5jdGlvbihtb2RlLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKDEgPD0gdHlwZSAmJiB0eXBlIDwgMTApIHtcbiAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX05VTUJFUjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMTA7XG4gICAgICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfQUxQSEFfTlVNOlxuICAgICAgICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFXzhCSVRfQllURTpcbiAgICAgICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9LQU5KSTpcbiAgICAgICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBcIm1vZGU6XCIgKyBtb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA8IDI3KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9OVU1CRVI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEyO1xuICAgICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX0FMUEhBX05VTTpcbiAgICAgICAgICAgICAgICByZXR1cm4gMTE7XG4gICAgICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfOEJJVF9CWVRFOlxuICAgICAgICAgICAgICAgIHJldHVybiAxNjtcbiAgICAgICAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9LQU5KSTpcbiAgICAgICAgICAgICAgICByZXR1cm4gMTA7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJtb2RlOlwiICsgbW9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPCA0MSkge1xuICAgICAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfTlVNQkVSOlxuICAgICAgICAgICAgICAgIHJldHVybiAxNDtcbiAgICAgICAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9BTFBIQV9OVU06XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEzO1xuICAgICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFXzhCSVRfQllURTpcbiAgICAgICAgICAgICAgICByZXR1cm4gMTY7XG4gICAgICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfS0FOSkk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEyO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IFwibW9kZTpcIiArIG1vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IFwidHlwZTpcIiArIHR5cGU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRMb3N0UG9pbnQgPSBmdW5jdGlvbihxcmNvZGU0KSB7XG4gICAgICAgICAgdmFyIG1vZHVsZUNvdW50ID0gcXJjb2RlNC5nZXRNb2R1bGVDb3VudCgpO1xuICAgICAgICAgIHZhciBsb3N0UG9pbnQgPSAwO1xuICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vZHVsZUNvdW50OyByb3cgKz0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBzYW1lQ291bnQgPSAwO1xuICAgICAgICAgICAgICB2YXIgZGFyayA9IHFyY29kZTQuaXNEYXJrKHJvdywgY29sKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgciA9IC0xOyByIDw9IDE7IHIgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChyb3cgKyByIDwgMCB8fCBtb2R1bGVDb3VudCA8PSByb3cgKyByKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYzIgPSAtMTsgYzIgPD0gMTsgYzIgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGNvbCArIGMyIDwgMCB8fCBtb2R1bGVDb3VudCA8PSBjb2wgKyBjMikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChyID09IDAgJiYgYzIgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChkYXJrID09IHFyY29kZTQuaXNEYXJrKHJvdyArIHIsIGNvbCArIGMyKSkge1xuICAgICAgICAgICAgICAgICAgICBzYW1lQ291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHNhbWVDb3VudCA+IDUpIHtcbiAgICAgICAgICAgICAgICBsb3N0UG9pbnQgKz0gMyArIHNhbWVDb3VudCAtIDU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQgLSAxOyByb3cgKz0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQgLSAxOyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgICBpZiAocXJjb2RlNC5pc0Rhcmsocm93LCBjb2wpKSBjb3VudCArPSAxO1xuICAgICAgICAgICAgICBpZiAocXJjb2RlNC5pc0Rhcmsocm93ICsgMSwgY29sKSkgY291bnQgKz0gMTtcbiAgICAgICAgICAgICAgaWYgKHFyY29kZTQuaXNEYXJrKHJvdywgY29sICsgMSkpIGNvdW50ICs9IDE7XG4gICAgICAgICAgICAgIGlmIChxcmNvZGU0LmlzRGFyayhyb3cgKyAxLCBjb2wgKyAxKSkgY291bnQgKz0gMTtcbiAgICAgICAgICAgICAgaWYgKGNvdW50ID09IDAgfHwgY291bnQgPT0gNCkge1xuICAgICAgICAgICAgICAgIGxvc3RQb2ludCArPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vZHVsZUNvdW50OyByb3cgKz0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQgLSA2OyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAocXJjb2RlNC5pc0Rhcmsocm93LCBjb2wpICYmICFxcmNvZGU0LmlzRGFyayhyb3csIGNvbCArIDEpICYmIHFyY29kZTQuaXNEYXJrKHJvdywgY29sICsgMikgJiYgcXJjb2RlNC5pc0Rhcmsocm93LCBjb2wgKyAzKSAmJiBxcmNvZGU0LmlzRGFyayhyb3csIGNvbCArIDQpICYmICFxcmNvZGU0LmlzRGFyayhyb3csIGNvbCArIDUpICYmIHFyY29kZTQuaXNEYXJrKHJvdywgY29sICsgNikpIHtcbiAgICAgICAgICAgICAgICBsb3N0UG9pbnQgKz0gNDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudCAtIDY7IHJvdyArPSAxKSB7XG4gICAgICAgICAgICAgIGlmIChxcmNvZGU0LmlzRGFyayhyb3csIGNvbCkgJiYgIXFyY29kZTQuaXNEYXJrKHJvdyArIDEsIGNvbCkgJiYgcXJjb2RlNC5pc0Rhcmsocm93ICsgMiwgY29sKSAmJiBxcmNvZGU0LmlzRGFyayhyb3cgKyAzLCBjb2wpICYmIHFyY29kZTQuaXNEYXJrKHJvdyArIDQsIGNvbCkgJiYgIXFyY29kZTQuaXNEYXJrKHJvdyArIDUsIGNvbCkgJiYgcXJjb2RlNC5pc0Rhcmsocm93ICsgNiwgY29sKSkge1xuICAgICAgICAgICAgICAgIGxvc3RQb2ludCArPSA0MDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGFya0NvdW50ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vZHVsZUNvdW50OyByb3cgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAocXJjb2RlNC5pc0Rhcmsocm93LCBjb2wpKSB7XG4gICAgICAgICAgICAgICAgZGFya0NvdW50ICs9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJhdGlvID0gTWF0aC5hYnMoMTAwICogZGFya0NvdW50IC8gbW9kdWxlQ291bnQgLyBtb2R1bGVDb3VudCAtIDUwKSAvIDU7XG4gICAgICAgICAgbG9zdFBvaW50ICs9IHJhdGlvICogMTA7XG4gICAgICAgICAgcmV0dXJuIGxvc3RQb2ludDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfSgpO1xuICAgICAgdmFyIFFSTWF0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgRVhQX1RBQkxFID0gbmV3IEFycmF5KDI1Nik7XG4gICAgICAgIHZhciBMT0dfVEFCTEUgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IDg7IGkyICs9IDEpIHtcbiAgICAgICAgICBFWFBfVEFCTEVbaTJdID0gMSA8PCBpMjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpMiA9IDg7IGkyIDwgMjU2OyBpMiArPSAxKSB7XG4gICAgICAgICAgRVhQX1RBQkxFW2kyXSA9IEVYUF9UQUJMRVtpMiAtIDRdIF4gRVhQX1RBQkxFW2kyIC0gNV0gXiBFWFBfVEFCTEVbaTIgLSA2XSBeIEVYUF9UQUJMRVtpMiAtIDhdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCAyNTU7IGkyICs9IDEpIHtcbiAgICAgICAgICBMT0dfVEFCTEVbRVhQX1RBQkxFW2kyXV0gPSBpMjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX3RoaXMgPSB7fTtcbiAgICAgICAgX3RoaXMuZ2xvZyA9IGZ1bmN0aW9uKG4yKSB7XG4gICAgICAgICAgaWYgKG4yIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgXCJnbG9nKFwiICsgbjIgKyBcIilcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIExPR19UQUJMRVtuMl07XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdleHAgPSBmdW5jdGlvbihuMikge1xuICAgICAgICAgIHdoaWxlIChuMiA8IDApIHtcbiAgICAgICAgICAgIG4yICs9IDI1NTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKG4yID49IDI1Nikge1xuICAgICAgICAgICAgbjIgLT0gMjU1O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gRVhQX1RBQkxFW24yXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfSgpO1xuICAgICAgZnVuY3Rpb24gcXJQb2x5bm9taWFsKG51bSwgc2hpZnQyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnVtLmxlbmd0aCA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgdGhyb3cgbnVtLmxlbmd0aCArIFwiL1wiICsgc2hpZnQyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfbnVtID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgd2hpbGUgKG9mZnNldCA8IG51bS5sZW5ndGggJiYgbnVtW29mZnNldF0gPT0gMCkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfbnVtMiA9IG5ldyBBcnJheShudW0ubGVuZ3RoIC0gb2Zmc2V0ICsgc2hpZnQyKTtcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgbnVtLmxlbmd0aCAtIG9mZnNldDsgaTIgKz0gMSkge1xuICAgICAgICAgICAgX251bTJbaTJdID0gbnVtW2kyICsgb2Zmc2V0XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9udW0yO1xuICAgICAgICB9KCk7XG4gICAgICAgIHZhciBfdGhpcyA9IHt9O1xuICAgICAgICBfdGhpcy5nZXRBdCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIF9udW1baW5kZXhdO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX251bS5sZW5ndGg7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm11bHRpcGx5ID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICB2YXIgbnVtMiA9IG5ldyBBcnJheShfdGhpcy5nZXRMZW5ndGgoKSArIGUyLmdldExlbmd0aCgpIC0gMSk7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IF90aGlzLmdldExlbmd0aCgpOyBpMiArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGUyLmdldExlbmd0aCgpOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgbnVtMltpMiArIGpdIF49IFFSTWF0aC5nZXhwKFFSTWF0aC5nbG9nKF90aGlzLmdldEF0KGkyKSkgKyBRUk1hdGguZ2xvZyhlMi5nZXRBdChqKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcXJQb2x5bm9taWFsKG51bTIsIDApO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5tb2QgPSBmdW5jdGlvbihlMikge1xuICAgICAgICAgIGlmIChfdGhpcy5nZXRMZW5ndGgoKSAtIGUyLmdldExlbmd0aCgpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmF0aW8gPSBRUk1hdGguZ2xvZyhfdGhpcy5nZXRBdCgwKSkgLSBRUk1hdGguZ2xvZyhlMi5nZXRBdCgwKSk7XG4gICAgICAgICAgdmFyIG51bTIgPSBuZXcgQXJyYXkoX3RoaXMuZ2V0TGVuZ3RoKCkpO1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBfdGhpcy5nZXRMZW5ndGgoKTsgaTIgKz0gMSkge1xuICAgICAgICAgICAgbnVtMltpMl0gPSBfdGhpcy5nZXRBdChpMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBlMi5nZXRMZW5ndGgoKTsgaTIgKz0gMSkge1xuICAgICAgICAgICAgbnVtMltpMl0gXj0gUVJNYXRoLmdleHAoUVJNYXRoLmdsb2coZTIuZ2V0QXQoaTIpKSArIHJhdGlvKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHFyUG9seW5vbWlhbChudW0yLCAwKS5tb2QoZTIpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9XG4gICAgICB2YXIgUVJSU0Jsb2NrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBSU19CTE9DS19UQUJMRSA9IFtcbiAgICAgICAgICAvLyBMXG4gICAgICAgICAgLy8gTVxuICAgICAgICAgIC8vIFFcbiAgICAgICAgICAvLyBIXG4gICAgICAgICAgLy8gMVxuICAgICAgICAgIFsxLCAyNiwgMTldLFxuICAgICAgICAgIFsxLCAyNiwgMTZdLFxuICAgICAgICAgIFsxLCAyNiwgMTNdLFxuICAgICAgICAgIFsxLCAyNiwgOV0sXG4gICAgICAgICAgLy8gMlxuICAgICAgICAgIFsxLCA0NCwgMzRdLFxuICAgICAgICAgIFsxLCA0NCwgMjhdLFxuICAgICAgICAgIFsxLCA0NCwgMjJdLFxuICAgICAgICAgIFsxLCA0NCwgMTZdLFxuICAgICAgICAgIC8vIDNcbiAgICAgICAgICBbMSwgNzAsIDU1XSxcbiAgICAgICAgICBbMSwgNzAsIDQ0XSxcbiAgICAgICAgICBbMiwgMzUsIDE3XSxcbiAgICAgICAgICBbMiwgMzUsIDEzXSxcbiAgICAgICAgICAvLyA0XG4gICAgICAgICAgWzEsIDEwMCwgODBdLFxuICAgICAgICAgIFsyLCA1MCwgMzJdLFxuICAgICAgICAgIFsyLCA1MCwgMjRdLFxuICAgICAgICAgIFs0LCAyNSwgOV0sXG4gICAgICAgICAgLy8gNVxuICAgICAgICAgIFsxLCAxMzQsIDEwOF0sXG4gICAgICAgICAgWzIsIDY3LCA0M10sXG4gICAgICAgICAgWzIsIDMzLCAxNSwgMiwgMzQsIDE2XSxcbiAgICAgICAgICBbMiwgMzMsIDExLCAyLCAzNCwgMTJdLFxuICAgICAgICAgIC8vIDZcbiAgICAgICAgICBbMiwgODYsIDY4XSxcbiAgICAgICAgICBbNCwgNDMsIDI3XSxcbiAgICAgICAgICBbNCwgNDMsIDE5XSxcbiAgICAgICAgICBbNCwgNDMsIDE1XSxcbiAgICAgICAgICAvLyA3XG4gICAgICAgICAgWzIsIDk4LCA3OF0sXG4gICAgICAgICAgWzQsIDQ5LCAzMV0sXG4gICAgICAgICAgWzIsIDMyLCAxNCwgNCwgMzMsIDE1XSxcbiAgICAgICAgICBbNCwgMzksIDEzLCAxLCA0MCwgMTRdLFxuICAgICAgICAgIC8vIDhcbiAgICAgICAgICBbMiwgMTIxLCA5N10sXG4gICAgICAgICAgWzIsIDYwLCAzOCwgMiwgNjEsIDM5XSxcbiAgICAgICAgICBbNCwgNDAsIDE4LCAyLCA0MSwgMTldLFxuICAgICAgICAgIFs0LCA0MCwgMTQsIDIsIDQxLCAxNV0sXG4gICAgICAgICAgLy8gOVxuICAgICAgICAgIFsyLCAxNDYsIDExNl0sXG4gICAgICAgICAgWzMsIDU4LCAzNiwgMiwgNTksIDM3XSxcbiAgICAgICAgICBbNCwgMzYsIDE2LCA0LCAzNywgMTddLFxuICAgICAgICAgIFs0LCAzNiwgMTIsIDQsIDM3LCAxM10sXG4gICAgICAgICAgLy8gMTBcbiAgICAgICAgICBbMiwgODYsIDY4LCAyLCA4NywgNjldLFxuICAgICAgICAgIFs0LCA2OSwgNDMsIDEsIDcwLCA0NF0sXG4gICAgICAgICAgWzYsIDQzLCAxOSwgMiwgNDQsIDIwXSxcbiAgICAgICAgICBbNiwgNDMsIDE1LCAyLCA0NCwgMTZdLFxuICAgICAgICAgIC8vIDExXG4gICAgICAgICAgWzQsIDEwMSwgODFdLFxuICAgICAgICAgIFsxLCA4MCwgNTAsIDQsIDgxLCA1MV0sXG4gICAgICAgICAgWzQsIDUwLCAyMiwgNCwgNTEsIDIzXSxcbiAgICAgICAgICBbMywgMzYsIDEyLCA4LCAzNywgMTNdLFxuICAgICAgICAgIC8vIDEyXG4gICAgICAgICAgWzIsIDExNiwgOTIsIDIsIDExNywgOTNdLFxuICAgICAgICAgIFs2LCA1OCwgMzYsIDIsIDU5LCAzN10sXG4gICAgICAgICAgWzQsIDQ2LCAyMCwgNiwgNDcsIDIxXSxcbiAgICAgICAgICBbNywgNDIsIDE0LCA0LCA0MywgMTVdLFxuICAgICAgICAgIC8vIDEzXG4gICAgICAgICAgWzQsIDEzMywgMTA3XSxcbiAgICAgICAgICBbOCwgNTksIDM3LCAxLCA2MCwgMzhdLFxuICAgICAgICAgIFs4LCA0NCwgMjAsIDQsIDQ1LCAyMV0sXG4gICAgICAgICAgWzEyLCAzMywgMTEsIDQsIDM0LCAxMl0sXG4gICAgICAgICAgLy8gMTRcbiAgICAgICAgICBbMywgMTQ1LCAxMTUsIDEsIDE0NiwgMTE2XSxcbiAgICAgICAgICBbNCwgNjQsIDQwLCA1LCA2NSwgNDFdLFxuICAgICAgICAgIFsxMSwgMzYsIDE2LCA1LCAzNywgMTddLFxuICAgICAgICAgIFsxMSwgMzYsIDEyLCA1LCAzNywgMTNdLFxuICAgICAgICAgIC8vIDE1XG4gICAgICAgICAgWzUsIDEwOSwgODcsIDEsIDExMCwgODhdLFxuICAgICAgICAgIFs1LCA2NSwgNDEsIDUsIDY2LCA0Ml0sXG4gICAgICAgICAgWzUsIDU0LCAyNCwgNywgNTUsIDI1XSxcbiAgICAgICAgICBbMTEsIDM2LCAxMiwgNywgMzcsIDEzXSxcbiAgICAgICAgICAvLyAxNlxuICAgICAgICAgIFs1LCAxMjIsIDk4LCAxLCAxMjMsIDk5XSxcbiAgICAgICAgICBbNywgNzMsIDQ1LCAzLCA3NCwgNDZdLFxuICAgICAgICAgIFsxNSwgNDMsIDE5LCAyLCA0NCwgMjBdLFxuICAgICAgICAgIFszLCA0NSwgMTUsIDEzLCA0NiwgMTZdLFxuICAgICAgICAgIC8vIDE3XG4gICAgICAgICAgWzEsIDEzNSwgMTA3LCA1LCAxMzYsIDEwOF0sXG4gICAgICAgICAgWzEwLCA3NCwgNDYsIDEsIDc1LCA0N10sXG4gICAgICAgICAgWzEsIDUwLCAyMiwgMTUsIDUxLCAyM10sXG4gICAgICAgICAgWzIsIDQyLCAxNCwgMTcsIDQzLCAxNV0sXG4gICAgICAgICAgLy8gMThcbiAgICAgICAgICBbNSwgMTUwLCAxMjAsIDEsIDE1MSwgMTIxXSxcbiAgICAgICAgICBbOSwgNjksIDQzLCA0LCA3MCwgNDRdLFxuICAgICAgICAgIFsxNywgNTAsIDIyLCAxLCA1MSwgMjNdLFxuICAgICAgICAgIFsyLCA0MiwgMTQsIDE5LCA0MywgMTVdLFxuICAgICAgICAgIC8vIDE5XG4gICAgICAgICAgWzMsIDE0MSwgMTEzLCA0LCAxNDIsIDExNF0sXG4gICAgICAgICAgWzMsIDcwLCA0NCwgMTEsIDcxLCA0NV0sXG4gICAgICAgICAgWzE3LCA0NywgMjEsIDQsIDQ4LCAyMl0sXG4gICAgICAgICAgWzksIDM5LCAxMywgMTYsIDQwLCAxNF0sXG4gICAgICAgICAgLy8gMjBcbiAgICAgICAgICBbMywgMTM1LCAxMDcsIDUsIDEzNiwgMTA4XSxcbiAgICAgICAgICBbMywgNjcsIDQxLCAxMywgNjgsIDQyXSxcbiAgICAgICAgICBbMTUsIDU0LCAyNCwgNSwgNTUsIDI1XSxcbiAgICAgICAgICBbMTUsIDQzLCAxNSwgMTAsIDQ0LCAxNl0sXG4gICAgICAgICAgLy8gMjFcbiAgICAgICAgICBbNCwgMTQ0LCAxMTYsIDQsIDE0NSwgMTE3XSxcbiAgICAgICAgICBbMTcsIDY4LCA0Ml0sXG4gICAgICAgICAgWzE3LCA1MCwgMjIsIDYsIDUxLCAyM10sXG4gICAgICAgICAgWzE5LCA0NiwgMTYsIDYsIDQ3LCAxN10sXG4gICAgICAgICAgLy8gMjJcbiAgICAgICAgICBbMiwgMTM5LCAxMTEsIDcsIDE0MCwgMTEyXSxcbiAgICAgICAgICBbMTcsIDc0LCA0Nl0sXG4gICAgICAgICAgWzcsIDU0LCAyNCwgMTYsIDU1LCAyNV0sXG4gICAgICAgICAgWzM0LCAzNywgMTNdLFxuICAgICAgICAgIC8vIDIzXG4gICAgICAgICAgWzQsIDE1MSwgMTIxLCA1LCAxNTIsIDEyMl0sXG4gICAgICAgICAgWzQsIDc1LCA0NywgMTQsIDc2LCA0OF0sXG4gICAgICAgICAgWzExLCA1NCwgMjQsIDE0LCA1NSwgMjVdLFxuICAgICAgICAgIFsxNiwgNDUsIDE1LCAxNCwgNDYsIDE2XSxcbiAgICAgICAgICAvLyAyNFxuICAgICAgICAgIFs2LCAxNDcsIDExNywgNCwgMTQ4LCAxMThdLFxuICAgICAgICAgIFs2LCA3MywgNDUsIDE0LCA3NCwgNDZdLFxuICAgICAgICAgIFsxMSwgNTQsIDI0LCAxNiwgNTUsIDI1XSxcbiAgICAgICAgICBbMzAsIDQ2LCAxNiwgMiwgNDcsIDE3XSxcbiAgICAgICAgICAvLyAyNVxuICAgICAgICAgIFs4LCAxMzIsIDEwNiwgNCwgMTMzLCAxMDddLFxuICAgICAgICAgIFs4LCA3NSwgNDcsIDEzLCA3NiwgNDhdLFxuICAgICAgICAgIFs3LCA1NCwgMjQsIDIyLCA1NSwgMjVdLFxuICAgICAgICAgIFsyMiwgNDUsIDE1LCAxMywgNDYsIDE2XSxcbiAgICAgICAgICAvLyAyNlxuICAgICAgICAgIFsxMCwgMTQyLCAxMTQsIDIsIDE0MywgMTE1XSxcbiAgICAgICAgICBbMTksIDc0LCA0NiwgNCwgNzUsIDQ3XSxcbiAgICAgICAgICBbMjgsIDUwLCAyMiwgNiwgNTEsIDIzXSxcbiAgICAgICAgICBbMzMsIDQ2LCAxNiwgNCwgNDcsIDE3XSxcbiAgICAgICAgICAvLyAyN1xuICAgICAgICAgIFs4LCAxNTIsIDEyMiwgNCwgMTUzLCAxMjNdLFxuICAgICAgICAgIFsyMiwgNzMsIDQ1LCAzLCA3NCwgNDZdLFxuICAgICAgICAgIFs4LCA1MywgMjMsIDI2LCA1NCwgMjRdLFxuICAgICAgICAgIFsxMiwgNDUsIDE1LCAyOCwgNDYsIDE2XSxcbiAgICAgICAgICAvLyAyOFxuICAgICAgICAgIFszLCAxNDcsIDExNywgMTAsIDE0OCwgMTE4XSxcbiAgICAgICAgICBbMywgNzMsIDQ1LCAyMywgNzQsIDQ2XSxcbiAgICAgICAgICBbNCwgNTQsIDI0LCAzMSwgNTUsIDI1XSxcbiAgICAgICAgICBbMTEsIDQ1LCAxNSwgMzEsIDQ2LCAxNl0sXG4gICAgICAgICAgLy8gMjlcbiAgICAgICAgICBbNywgMTQ2LCAxMTYsIDcsIDE0NywgMTE3XSxcbiAgICAgICAgICBbMjEsIDczLCA0NSwgNywgNzQsIDQ2XSxcbiAgICAgICAgICBbMSwgNTMsIDIzLCAzNywgNTQsIDI0XSxcbiAgICAgICAgICBbMTksIDQ1LCAxNSwgMjYsIDQ2LCAxNl0sXG4gICAgICAgICAgLy8gMzBcbiAgICAgICAgICBbNSwgMTQ1LCAxMTUsIDEwLCAxNDYsIDExNl0sXG4gICAgICAgICAgWzE5LCA3NSwgNDcsIDEwLCA3NiwgNDhdLFxuICAgICAgICAgIFsxNSwgNTQsIDI0LCAyNSwgNTUsIDI1XSxcbiAgICAgICAgICBbMjMsIDQ1LCAxNSwgMjUsIDQ2LCAxNl0sXG4gICAgICAgICAgLy8gMzFcbiAgICAgICAgICBbMTMsIDE0NSwgMTE1LCAzLCAxNDYsIDExNl0sXG4gICAgICAgICAgWzIsIDc0LCA0NiwgMjksIDc1LCA0N10sXG4gICAgICAgICAgWzQyLCA1NCwgMjQsIDEsIDU1LCAyNV0sXG4gICAgICAgICAgWzIzLCA0NSwgMTUsIDI4LCA0NiwgMTZdLFxuICAgICAgICAgIC8vIDMyXG4gICAgICAgICAgWzE3LCAxNDUsIDExNV0sXG4gICAgICAgICAgWzEwLCA3NCwgNDYsIDIzLCA3NSwgNDddLFxuICAgICAgICAgIFsxMCwgNTQsIDI0LCAzNSwgNTUsIDI1XSxcbiAgICAgICAgICBbMTksIDQ1LCAxNSwgMzUsIDQ2LCAxNl0sXG4gICAgICAgICAgLy8gMzNcbiAgICAgICAgICBbMTcsIDE0NSwgMTE1LCAxLCAxNDYsIDExNl0sXG4gICAgICAgICAgWzE0LCA3NCwgNDYsIDIxLCA3NSwgNDddLFxuICAgICAgICAgIFsyOSwgNTQsIDI0LCAxOSwgNTUsIDI1XSxcbiAgICAgICAgICBbMTEsIDQ1LCAxNSwgNDYsIDQ2LCAxNl0sXG4gICAgICAgICAgLy8gMzRcbiAgICAgICAgICBbMTMsIDE0NSwgMTE1LCA2LCAxNDYsIDExNl0sXG4gICAgICAgICAgWzE0LCA3NCwgNDYsIDIzLCA3NSwgNDddLFxuICAgICAgICAgIFs0NCwgNTQsIDI0LCA3LCA1NSwgMjVdLFxuICAgICAgICAgIFs1OSwgNDYsIDE2LCAxLCA0NywgMTddLFxuICAgICAgICAgIC8vIDM1XG4gICAgICAgICAgWzEyLCAxNTEsIDEyMSwgNywgMTUyLCAxMjJdLFxuICAgICAgICAgIFsxMiwgNzUsIDQ3LCAyNiwgNzYsIDQ4XSxcbiAgICAgICAgICBbMzksIDU0LCAyNCwgMTQsIDU1LCAyNV0sXG4gICAgICAgICAgWzIyLCA0NSwgMTUsIDQxLCA0NiwgMTZdLFxuICAgICAgICAgIC8vIDM2XG4gICAgICAgICAgWzYsIDE1MSwgMTIxLCAxNCwgMTUyLCAxMjJdLFxuICAgICAgICAgIFs2LCA3NSwgNDcsIDM0LCA3NiwgNDhdLFxuICAgICAgICAgIFs0NiwgNTQsIDI0LCAxMCwgNTUsIDI1XSxcbiAgICAgICAgICBbMiwgNDUsIDE1LCA2NCwgNDYsIDE2XSxcbiAgICAgICAgICAvLyAzN1xuICAgICAgICAgIFsxNywgMTUyLCAxMjIsIDQsIDE1MywgMTIzXSxcbiAgICAgICAgICBbMjksIDc0LCA0NiwgMTQsIDc1LCA0N10sXG4gICAgICAgICAgWzQ5LCA1NCwgMjQsIDEwLCA1NSwgMjVdLFxuICAgICAgICAgIFsyNCwgNDUsIDE1LCA0NiwgNDYsIDE2XSxcbiAgICAgICAgICAvLyAzOFxuICAgICAgICAgIFs0LCAxNTIsIDEyMiwgMTgsIDE1MywgMTIzXSxcbiAgICAgICAgICBbMTMsIDc0LCA0NiwgMzIsIDc1LCA0N10sXG4gICAgICAgICAgWzQ4LCA1NCwgMjQsIDE0LCA1NSwgMjVdLFxuICAgICAgICAgIFs0MiwgNDUsIDE1LCAzMiwgNDYsIDE2XSxcbiAgICAgICAgICAvLyAzOVxuICAgICAgICAgIFsyMCwgMTQ3LCAxMTcsIDQsIDE0OCwgMTE4XSxcbiAgICAgICAgICBbNDAsIDc1LCA0NywgNywgNzYsIDQ4XSxcbiAgICAgICAgICBbNDMsIDU0LCAyNCwgMjIsIDU1LCAyNV0sXG4gICAgICAgICAgWzEwLCA0NSwgMTUsIDY3LCA0NiwgMTZdLFxuICAgICAgICAgIC8vIDQwXG4gICAgICAgICAgWzE5LCAxNDgsIDExOCwgNiwgMTQ5LCAxMTldLFxuICAgICAgICAgIFsxOCwgNzUsIDQ3LCAzMSwgNzYsIDQ4XSxcbiAgICAgICAgICBbMzQsIDU0LCAyNCwgMzQsIDU1LCAyNV0sXG4gICAgICAgICAgWzIwLCA0NSwgMTUsIDYxLCA0NiwgMTZdXG4gICAgICAgIF07XG4gICAgICAgIHZhciBxclJTQmxvY2sgPSBmdW5jdGlvbih0b3RhbENvdW50LCBkYXRhQ291bnQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMyID0ge307XG4gICAgICAgICAgX3RoaXMyLnRvdGFsQ291bnQgPSB0b3RhbENvdW50O1xuICAgICAgICAgIF90aGlzMi5kYXRhQ291bnQgPSBkYXRhQ291bnQ7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMjtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF90aGlzID0ge307XG4gICAgICAgIHZhciBnZXRSc0Jsb2NrVGFibGUgPSBmdW5jdGlvbih0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3Rpb25MZXZlbCkge1xuICAgICAgICAgIHN3aXRjaCAoZXJyb3JDb3JyZWN0aW9uTGV2ZWwpIHtcbiAgICAgICAgICAgIGNhc2UgUVJFcnJvckNvcnJlY3Rpb25MZXZlbC5MOlxuICAgICAgICAgICAgICByZXR1cm4gUlNfQkxPQ0tfVEFCTEVbKHR5cGVOdW1iZXIgLSAxKSAqIDQgKyAwXTtcbiAgICAgICAgICAgIGNhc2UgUVJFcnJvckNvcnJlY3Rpb25MZXZlbC5NOlxuICAgICAgICAgICAgICByZXR1cm4gUlNfQkxPQ0tfVEFCTEVbKHR5cGVOdW1iZXIgLSAxKSAqIDQgKyAxXTtcbiAgICAgICAgICAgIGNhc2UgUVJFcnJvckNvcnJlY3Rpb25MZXZlbC5ROlxuICAgICAgICAgICAgICByZXR1cm4gUlNfQkxPQ0tfVEFCTEVbKHR5cGVOdW1iZXIgLSAxKSAqIDQgKyAyXTtcbiAgICAgICAgICAgIGNhc2UgUVJFcnJvckNvcnJlY3Rpb25MZXZlbC5IOlxuICAgICAgICAgICAgICByZXR1cm4gUlNfQkxPQ0tfVEFCTEVbKHR5cGVOdW1iZXIgLSAxKSAqIDQgKyAzXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRSU0Jsb2NrcyA9IGZ1bmN0aW9uKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdGlvbkxldmVsKSB7XG4gICAgICAgICAgdmFyIHJzQmxvY2sgPSBnZXRSc0Jsb2NrVGFibGUodHlwZU51bWJlciwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpO1xuICAgICAgICAgIGlmICh0eXBlb2YgcnNCbG9jayA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBcImJhZCBycyBibG9jayBAIHR5cGVOdW1iZXI6XCIgKyB0eXBlTnVtYmVyICsgXCIvZXJyb3JDb3JyZWN0aW9uTGV2ZWw6XCIgKyBlcnJvckNvcnJlY3Rpb25MZXZlbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IHJzQmxvY2subGVuZ3RoIC8gMztcbiAgICAgICAgICB2YXIgbGlzdCA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBsZW5ndGg7IGkyICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IHJzQmxvY2tbaTIgKiAzICsgMF07XG4gICAgICAgICAgICB2YXIgdG90YWxDb3VudCA9IHJzQmxvY2tbaTIgKiAzICsgMV07XG4gICAgICAgICAgICB2YXIgZGF0YUNvdW50ID0gcnNCbG9ja1tpMiAqIDMgKyAyXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY291bnQ7IGogKz0gMSkge1xuICAgICAgICAgICAgICBsaXN0LnB1c2gocXJSU0Jsb2NrKHRvdGFsQ291bnQsIGRhdGFDb3VudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfSgpO1xuICAgICAgdmFyIHFyQml0QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfYnVmZmVyID0gW107XG4gICAgICAgIHZhciBfbGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIF90aGlzID0ge307XG4gICAgICAgIF90aGlzLmdldEJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfYnVmZmVyO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRBdCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgdmFyIGJ1ZkluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIDgpO1xuICAgICAgICAgIHJldHVybiAoX2J1ZmZlcltidWZJbmRleF0gPj4+IDcgLSBpbmRleCAlIDggJiAxKSA9PSAxO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5wdXQgPSBmdW5jdGlvbihudW0sIGxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBsZW5ndGg7IGkyICs9IDEpIHtcbiAgICAgICAgICAgIF90aGlzLnB1dEJpdCgobnVtID4+PiBsZW5ndGggLSBpMiAtIDEgJiAxKSA9PSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldExlbmd0aEluQml0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfbGVuZ3RoO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5wdXRCaXQgPSBmdW5jdGlvbihiaXQpIHtcbiAgICAgICAgICB2YXIgYnVmSW5kZXggPSBNYXRoLmZsb29yKF9sZW5ndGggLyA4KTtcbiAgICAgICAgICBpZiAoX2J1ZmZlci5sZW5ndGggPD0gYnVmSW5kZXgpIHtcbiAgICAgICAgICAgIF9idWZmZXIucHVzaCgwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgX2J1ZmZlcltidWZJbmRleF0gfD0gMTI4ID4+PiBfbGVuZ3RoICUgODtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2xlbmd0aCArPSAxO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9O1xuICAgICAgdmFyIHFyTnVtYmVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgX21vZGUgPSBRUk1vZGUuTU9ERV9OVU1CRVI7XG4gICAgICAgIHZhciBfZGF0YSA9IGRhdGE7XG4gICAgICAgIHZhciBfdGhpcyA9IHt9O1xuICAgICAgICBfdGhpcy5nZXRNb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF9tb2RlO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gX2RhdGEubGVuZ3RoO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICAgIHZhciBkYXRhMiA9IF9kYXRhO1xuICAgICAgICAgIHZhciBpMiA9IDA7XG4gICAgICAgICAgd2hpbGUgKGkyICsgMiA8IGRhdGEyLmxlbmd0aCkge1xuICAgICAgICAgICAgYnVmZmVyLnB1dChzdHJUb051bShkYXRhMi5zdWJzdHJpbmcoaTIsIGkyICsgMykpLCAxMCk7XG4gICAgICAgICAgICBpMiArPSAzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaTIgPCBkYXRhMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChkYXRhMi5sZW5ndGggLSBpMiA9PSAxKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlci5wdXQoc3RyVG9OdW0oZGF0YTIuc3Vic3RyaW5nKGkyLCBpMiArIDEpKSwgNCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEyLmxlbmd0aCAtIGkyID09IDIpIHtcbiAgICAgICAgICAgICAgYnVmZmVyLnB1dChzdHJUb051bShkYXRhMi5zdWJzdHJpbmcoaTIsIGkyICsgMikpLCA3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdHJUb051bSA9IGZ1bmN0aW9uKHMyKSB7XG4gICAgICAgICAgdmFyIG51bSA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHMyLmxlbmd0aDsgaTIgKz0gMSkge1xuICAgICAgICAgICAgbnVtID0gbnVtICogMTAgKyBjaGF0VG9OdW0oczIuY2hhckF0KGkyKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudW07XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjaGF0VG9OdW0gPSBmdW5jdGlvbihjMikge1xuICAgICAgICAgIGlmIChcIjBcIiA8PSBjMiAmJiBjMiA8PSBcIjlcIikge1xuICAgICAgICAgICAgcmV0dXJuIGMyLmNoYXJDb2RlQXQoMCkgLSBcIjBcIi5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBcImlsbGVnYWwgY2hhciA6XCIgKyBjMjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfTtcbiAgICAgIHZhciBxckFscGhhTnVtID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgX21vZGUgPSBRUk1vZGUuTU9ERV9BTFBIQV9OVU07XG4gICAgICAgIHZhciBfZGF0YSA9IGRhdGE7XG4gICAgICAgIHZhciBfdGhpcyA9IHt9O1xuICAgICAgICBfdGhpcy5nZXRNb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF9tb2RlO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gX2RhdGEubGVuZ3RoO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICAgIHZhciBzMiA9IF9kYXRhO1xuICAgICAgICAgIHZhciBpMiA9IDA7XG4gICAgICAgICAgd2hpbGUgKGkyICsgMSA8IHMyLmxlbmd0aCkge1xuICAgICAgICAgICAgYnVmZmVyLnB1dChcbiAgICAgICAgICAgICAgZ2V0Q29kZShzMi5jaGFyQXQoaTIpKSAqIDQ1ICsgZ2V0Q29kZShzMi5jaGFyQXQoaTIgKyAxKSksXG4gICAgICAgICAgICAgIDExXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaTIgKz0gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkyIDwgczIubGVuZ3RoKSB7XG4gICAgICAgICAgICBidWZmZXIucHV0KGdldENvZGUoczIuY2hhckF0KGkyKSksIDYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldENvZGUgPSBmdW5jdGlvbihjMikge1xuICAgICAgICAgIGlmIChcIjBcIiA8PSBjMiAmJiBjMiA8PSBcIjlcIikge1xuICAgICAgICAgICAgcmV0dXJuIGMyLmNoYXJDb2RlQXQoMCkgLSBcIjBcIi5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXCJBXCIgPD0gYzIgJiYgYzIgPD0gXCJaXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjMi5jaGFyQ29kZUF0KDApIC0gXCJBXCIuY2hhckNvZGVBdCgwKSArIDEwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGMyKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCIgXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDM2O1xuICAgICAgICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAzNztcbiAgICAgICAgICAgICAgY2FzZSBcIiVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMzg7XG4gICAgICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDM5O1xuICAgICAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiA0MDtcbiAgICAgICAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gNDE7XG4gICAgICAgICAgICAgIGNhc2UgXCIuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDQyO1xuICAgICAgICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiA0MztcbiAgICAgICAgICAgICAgY2FzZSBcIjpcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gNDQ7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJpbGxlZ2FsIGNoYXIgOlwiICsgYzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9O1xuICAgICAgdmFyIHFyOEJpdEJ5dGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBfbW9kZSA9IFFSTW9kZS5NT0RFXzhCSVRfQllURTtcbiAgICAgICAgdmFyIF9ieXRlcyA9IHFyY29kZTMuc3RyaW5nVG9CeXRlcyhkYXRhKTtcbiAgICAgICAgdmFyIF90aGlzID0ge307XG4gICAgICAgIF90aGlzLmdldE1vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX21vZGU7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldExlbmd0aCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBfYnl0ZXMubGVuZ3RoO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBfYnl0ZXMubGVuZ3RoOyBpMiArPSAxKSB7XG4gICAgICAgICAgICBidWZmZXIucHV0KF9ieXRlc1tpMl0sIDgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfTtcbiAgICAgIHZhciBxckthbmppID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgX21vZGUgPSBRUk1vZGUuTU9ERV9LQU5KSTtcbiAgICAgICAgdmFyIHN0cmluZ1RvQnl0ZXMgPSBxcmNvZGUzLnN0cmluZ1RvQnl0ZXNGdW5jc1tcIlNKSVNcIl07XG4gICAgICAgIGlmICghc3RyaW5nVG9CeXRlcykge1xuICAgICAgICAgIHRocm93IFwic2ppcyBub3Qgc3VwcG9ydGVkLlwiO1xuICAgICAgICB9XG4gICAgICAgICFmdW5jdGlvbihjMiwgY29kZSkge1xuICAgICAgICAgIHZhciB0ZXN0ID0gc3RyaW5nVG9CeXRlcyhjMik7XG4gICAgICAgICAgaWYgKHRlc3QubGVuZ3RoICE9IDIgfHwgKHRlc3RbMF0gPDwgOCB8IHRlc3RbMV0pICE9IGNvZGUpIHtcbiAgICAgICAgICAgIHRocm93IFwic2ppcyBub3Qgc3VwcG9ydGVkLlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfShcIuWPi1wiLCAzODcyNik7XG4gICAgICAgIHZhciBfYnl0ZXMgPSBzdHJpbmdUb0J5dGVzKGRhdGEpO1xuICAgICAgICB2YXIgX3RoaXMgPSB7fTtcbiAgICAgICAgX3RoaXMuZ2V0TW9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfbW9kZTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIH5+KF9ieXRlcy5sZW5ndGggLyAyKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgICAgICB2YXIgZGF0YTIgPSBfYnl0ZXM7XG4gICAgICAgICAgdmFyIGkyID0gMDtcbiAgICAgICAgICB3aGlsZSAoaTIgKyAxIDwgZGF0YTIubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYzIgPSAoMjU1ICYgZGF0YTJbaTJdKSA8PCA4IHwgMjU1ICYgZGF0YTJbaTIgKyAxXTtcbiAgICAgICAgICAgIGlmICgzMzA4OCA8PSBjMiAmJiBjMiA8PSA0MDk1Nikge1xuICAgICAgICAgICAgICBjMiAtPSAzMzA4ODtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoNTc0MDggPD0gYzIgJiYgYzIgPD0gNjAzNTEpIHtcbiAgICAgICAgICAgICAgYzIgLT0gNDk0NzI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBcImlsbGVnYWwgY2hhciBhdCBcIiArIChpMiArIDEpICsgXCIvXCIgKyBjMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMyID0gKGMyID4+PiA4ICYgMjU1KSAqIDE5MiArIChjMiAmIDI1NSk7XG4gICAgICAgICAgICBidWZmZXIucHV0KGMyLCAxMyk7XG4gICAgICAgICAgICBpMiArPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaTIgPCBkYXRhMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IFwiaWxsZWdhbCBjaGFyIGF0IFwiICsgKGkyICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9O1xuICAgICAgdmFyIGJ5dGVBcnJheU91dHB1dFN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2J5dGVzID0gW107XG4gICAgICAgIHZhciBfdGhpcyA9IHt9O1xuICAgICAgICBfdGhpcy53cml0ZUJ5dGUgPSBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgX2J5dGVzLnB1c2goYiAmIDI1NSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLndyaXRlU2hvcnQgPSBmdW5jdGlvbihpMikge1xuICAgICAgICAgIF90aGlzLndyaXRlQnl0ZShpMik7XG4gICAgICAgICAgX3RoaXMud3JpdGVCeXRlKGkyID4+PiA4KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMud3JpdGVCeXRlcyA9IGZ1bmN0aW9uKGIsIG9mZiwgbGVuKSB7XG4gICAgICAgICAgb2ZmID0gb2ZmIHx8IDA7XG4gICAgICAgICAgbGVuID0gbGVuIHx8IGIubGVuZ3RoO1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBsZW47IGkyICs9IDEpIHtcbiAgICAgICAgICAgIF90aGlzLndyaXRlQnl0ZShiW2kyICsgb2ZmXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy53cml0ZVN0cmluZyA9IGZ1bmN0aW9uKHMyKSB7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHMyLmxlbmd0aDsgaTIgKz0gMSkge1xuICAgICAgICAgICAgX3RoaXMud3JpdGVCeXRlKHMyLmNoYXJDb2RlQXQoaTIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnRvQnl0ZUFycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF9ieXRlcztcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgczIgPSBcIlwiO1xuICAgICAgICAgIHMyICs9IFwiW1wiO1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBfYnl0ZXMubGVuZ3RoOyBpMiArPSAxKSB7XG4gICAgICAgICAgICBpZiAoaTIgPiAwKSB7XG4gICAgICAgICAgICAgIHMyICs9IFwiLFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgczIgKz0gX2J5dGVzW2kyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgczIgKz0gXCJdXCI7XG4gICAgICAgICAgcmV0dXJuIHMyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9O1xuICAgICAgdmFyIGJhc2U2NEVuY29kZU91dHB1dFN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2J1ZmZlciA9IDA7XG4gICAgICAgIHZhciBfYnVmbGVuID0gMDtcbiAgICAgICAgdmFyIF9sZW5ndGggPSAwO1xuICAgICAgICB2YXIgX2Jhc2U2NCA9IFwiXCI7XG4gICAgICAgIHZhciBfdGhpcyA9IHt9O1xuICAgICAgICB2YXIgd3JpdGVFbmNvZGVkID0gZnVuY3Rpb24oYikge1xuICAgICAgICAgIF9iYXNlNjQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShlbmNvZGUoYiAmIDYzKSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBlbmNvZGUgPSBmdW5jdGlvbihuMikge1xuICAgICAgICAgIGlmIChuMiA8IDApIDtcbiAgICAgICAgICBlbHNlIGlmIChuMiA8IDI2KSB7XG4gICAgICAgICAgICByZXR1cm4gNjUgKyBuMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG4yIDwgNTIpIHtcbiAgICAgICAgICAgIHJldHVybiA5NyArIChuMiAtIDI2KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG4yIDwgNjIpIHtcbiAgICAgICAgICAgIHJldHVybiA0OCArIChuMiAtIDUyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG4yID09IDYyKSB7XG4gICAgICAgICAgICByZXR1cm4gNDM7XG4gICAgICAgICAgfSBlbHNlIGlmIChuMiA9PSA2Mykge1xuICAgICAgICAgICAgcmV0dXJuIDQ3O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBcIm46XCIgKyBuMjtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMud3JpdGVCeXRlID0gZnVuY3Rpb24objIpIHtcbiAgICAgICAgICBfYnVmZmVyID0gX2J1ZmZlciA8PCA4IHwgbjIgJiAyNTU7XG4gICAgICAgICAgX2J1ZmxlbiArPSA4O1xuICAgICAgICAgIF9sZW5ndGggKz0gMTtcbiAgICAgICAgICB3aGlsZSAoX2J1ZmxlbiA+PSA2KSB7XG4gICAgICAgICAgICB3cml0ZUVuY29kZWQoX2J1ZmZlciA+Pj4gX2J1ZmxlbiAtIDYpO1xuICAgICAgICAgICAgX2J1ZmxlbiAtPSA2O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoX2J1ZmxlbiA+IDApIHtcbiAgICAgICAgICAgIHdyaXRlRW5jb2RlZChfYnVmZmVyIDw8IDYgLSBfYnVmbGVuKTtcbiAgICAgICAgICAgIF9idWZmZXIgPSAwO1xuICAgICAgICAgICAgX2J1ZmxlbiA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfbGVuZ3RoICUgMyAhPSAwKSB7XG4gICAgICAgICAgICB2YXIgcGFkbGVuID0gMyAtIF9sZW5ndGggJSAzO1xuICAgICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHBhZGxlbjsgaTIgKz0gMSkge1xuICAgICAgICAgICAgICBfYmFzZTY0ICs9IFwiPVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX2Jhc2U2NDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfTtcbiAgICAgIHZhciBiYXNlNjREZWNvZGVJbnB1dFN0cmVhbSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICB2YXIgX3N0ciA9IHN0cjtcbiAgICAgICAgdmFyIF9wb3MgPSAwO1xuICAgICAgICB2YXIgX2J1ZmZlciA9IDA7XG4gICAgICAgIHZhciBfYnVmbGVuID0gMDtcbiAgICAgICAgdmFyIF90aGlzID0ge307XG4gICAgICAgIF90aGlzLnJlYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB3aGlsZSAoX2J1ZmxlbiA8IDgpIHtcbiAgICAgICAgICAgIGlmIChfcG9zID49IF9zdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmIChfYnVmbGVuID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgXCJ1bmV4cGVjdGVkIGVuZCBvZiBmaWxlLi9cIiArIF9idWZsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYzIgPSBfc3RyLmNoYXJBdChfcG9zKTtcbiAgICAgICAgICAgIF9wb3MgKz0gMTtcbiAgICAgICAgICAgIGlmIChjMiA9PSBcIj1cIikge1xuICAgICAgICAgICAgICBfYnVmbGVuID0gMDtcbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjMi5tYXRjaCgvXlxccyQvKSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9idWZmZXIgPSBfYnVmZmVyIDw8IDYgfCBkZWNvZGUoYzIuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgICAgICBfYnVmbGVuICs9IDY7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuMiA9IF9idWZmZXIgPj4+IF9idWZsZW4gLSA4ICYgMjU1O1xuICAgICAgICAgIF9idWZsZW4gLT0gODtcbiAgICAgICAgICByZXR1cm4gbjI7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBkZWNvZGUgPSBmdW5jdGlvbihjMikge1xuICAgICAgICAgIGlmICg2NSA8PSBjMiAmJiBjMiA8PSA5MCkge1xuICAgICAgICAgICAgcmV0dXJuIGMyIC0gNjU7XG4gICAgICAgICAgfSBlbHNlIGlmICg5NyA8PSBjMiAmJiBjMiA8PSAxMjIpIHtcbiAgICAgICAgICAgIHJldHVybiBjMiAtIDk3ICsgMjY7XG4gICAgICAgICAgfSBlbHNlIGlmICg0OCA8PSBjMiAmJiBjMiA8PSA1Nykge1xuICAgICAgICAgICAgcmV0dXJuIGMyIC0gNDggKyA1MjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGMyID09IDQzKSB7XG4gICAgICAgICAgICByZXR1cm4gNjI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjMiA9PSA0Nykge1xuICAgICAgICAgICAgcmV0dXJuIDYzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBcImM6XCIgKyBjMjtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH07XG4gICAgICB2YXIgZ2lmSW1hZ2UgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBfd2lkdGggPSB3aWR0aDtcbiAgICAgICAgdmFyIF9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHZhciBfZGF0YSA9IG5ldyBBcnJheSh3aWR0aCAqIGhlaWdodCk7XG4gICAgICAgIHZhciBfdGhpcyA9IHt9O1xuICAgICAgICBfdGhpcy5zZXRQaXhlbCA9IGZ1bmN0aW9uKHgsIHksIHBpeGVsKSB7XG4gICAgICAgICAgX2RhdGFbeSAqIF93aWR0aCArIHhdID0gcGl4ZWw7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLndyaXRlID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgICAgICAgb3V0LndyaXRlU3RyaW5nKFwiR0lGODdhXCIpO1xuICAgICAgICAgIG91dC53cml0ZVNob3J0KF93aWR0aCk7XG4gICAgICAgICAgb3V0LndyaXRlU2hvcnQoX2hlaWdodCk7XG4gICAgICAgICAgb3V0LndyaXRlQnl0ZSgxMjgpO1xuICAgICAgICAgIG91dC53cml0ZUJ5dGUoMCk7XG4gICAgICAgICAgb3V0LndyaXRlQnl0ZSgwKTtcbiAgICAgICAgICBvdXQud3JpdGVCeXRlKDApO1xuICAgICAgICAgIG91dC53cml0ZUJ5dGUoMCk7XG4gICAgICAgICAgb3V0LndyaXRlQnl0ZSgwKTtcbiAgICAgICAgICBvdXQud3JpdGVCeXRlKDI1NSk7XG4gICAgICAgICAgb3V0LndyaXRlQnl0ZSgyNTUpO1xuICAgICAgICAgIG91dC53cml0ZUJ5dGUoMjU1KTtcbiAgICAgICAgICBvdXQud3JpdGVTdHJpbmcoXCIsXCIpO1xuICAgICAgICAgIG91dC53cml0ZVNob3J0KDApO1xuICAgICAgICAgIG91dC53cml0ZVNob3J0KDApO1xuICAgICAgICAgIG91dC53cml0ZVNob3J0KF93aWR0aCk7XG4gICAgICAgICAgb3V0LndyaXRlU2hvcnQoX2hlaWdodCk7XG4gICAgICAgICAgb3V0LndyaXRlQnl0ZSgwKTtcbiAgICAgICAgICB2YXIgbHp3TWluQ29kZVNpemUgPSAyO1xuICAgICAgICAgIHZhciByYXN0ZXIgPSBnZXRMWldSYXN0ZXIobHp3TWluQ29kZVNpemUpO1xuICAgICAgICAgIG91dC53cml0ZUJ5dGUobHp3TWluQ29kZVNpemUpO1xuICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgIHdoaWxlIChyYXN0ZXIubGVuZ3RoIC0gb2Zmc2V0ID4gMjU1KSB7XG4gICAgICAgICAgICBvdXQud3JpdGVCeXRlKDI1NSk7XG4gICAgICAgICAgICBvdXQud3JpdGVCeXRlcyhyYXN0ZXIsIG9mZnNldCwgMjU1KTtcbiAgICAgICAgICAgIG9mZnNldCArPSAyNTU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dC53cml0ZUJ5dGUocmFzdGVyLmxlbmd0aCAtIG9mZnNldCk7XG4gICAgICAgICAgb3V0LndyaXRlQnl0ZXMocmFzdGVyLCBvZmZzZXQsIHJhc3Rlci5sZW5ndGggLSBvZmZzZXQpO1xuICAgICAgICAgIG91dC53cml0ZUJ5dGUoMCk7XG4gICAgICAgICAgb3V0LndyaXRlU3RyaW5nKFwiO1wiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJpdE91dHB1dFN0cmVhbSA9IGZ1bmN0aW9uKG91dCkge1xuICAgICAgICAgIHZhciBfb3V0ID0gb3V0O1xuICAgICAgICAgIHZhciBfYml0TGVuZ3RoID0gMDtcbiAgICAgICAgICB2YXIgX2JpdEJ1ZmZlciA9IDA7XG4gICAgICAgICAgdmFyIF90aGlzMiA9IHt9O1xuICAgICAgICAgIF90aGlzMi53cml0ZSA9IGZ1bmN0aW9uKGRhdGEsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGRhdGEgPj4+IGxlbmd0aCAhPSAwKSB7XG4gICAgICAgICAgICAgIHRocm93IFwibGVuZ3RoIG92ZXJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChfYml0TGVuZ3RoICsgbGVuZ3RoID49IDgpIHtcbiAgICAgICAgICAgICAgX291dC53cml0ZUJ5dGUoMjU1ICYgKGRhdGEgPDwgX2JpdExlbmd0aCB8IF9iaXRCdWZmZXIpKTtcbiAgICAgICAgICAgICAgbGVuZ3RoIC09IDggLSBfYml0TGVuZ3RoO1xuICAgICAgICAgICAgICBkYXRhID4+Pj0gOCAtIF9iaXRMZW5ndGg7XG4gICAgICAgICAgICAgIF9iaXRCdWZmZXIgPSAwO1xuICAgICAgICAgICAgICBfYml0TGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9iaXRCdWZmZXIgPSBkYXRhIDw8IF9iaXRMZW5ndGggfCBfYml0QnVmZmVyO1xuICAgICAgICAgICAgX2JpdExlbmd0aCA9IF9iaXRMZW5ndGggKyBsZW5ndGg7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBfdGhpczIuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChfYml0TGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBfb3V0LndyaXRlQnl0ZShfYml0QnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBfdGhpczI7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXRMWldSYXN0ZXIgPSBmdW5jdGlvbihsendNaW5Db2RlU2l6ZSkge1xuICAgICAgICAgIHZhciBjbGVhckNvZGUgPSAxIDw8IGx6d01pbkNvZGVTaXplO1xuICAgICAgICAgIHZhciBlbmRDb2RlID0gKDEgPDwgbHp3TWluQ29kZVNpemUpICsgMTtcbiAgICAgICAgICB2YXIgYml0TGVuZ3RoID0gbHp3TWluQ29kZVNpemUgKyAxO1xuICAgICAgICAgIHZhciB0YWJsZSA9IGx6d1RhYmxlKCk7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGNsZWFyQ29kZTsgaTIgKz0gMSkge1xuICAgICAgICAgICAgdGFibGUuYWRkKFN0cmluZy5mcm9tQ2hhckNvZGUoaTIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFibGUuYWRkKFN0cmluZy5mcm9tQ2hhckNvZGUoY2xlYXJDb2RlKSk7XG4gICAgICAgICAgdGFibGUuYWRkKFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kQ29kZSkpO1xuICAgICAgICAgIHZhciBieXRlT3V0ID0gYnl0ZUFycmF5T3V0cHV0U3RyZWFtKCk7XG4gICAgICAgICAgdmFyIGJpdE91dCA9IGJpdE91dHB1dFN0cmVhbShieXRlT3V0KTtcbiAgICAgICAgICBiaXRPdXQud3JpdGUoY2xlYXJDb2RlLCBiaXRMZW5ndGgpO1xuICAgICAgICAgIHZhciBkYXRhSW5kZXggPSAwO1xuICAgICAgICAgIHZhciBzMiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoX2RhdGFbZGF0YUluZGV4XSk7XG4gICAgICAgICAgZGF0YUluZGV4ICs9IDE7XG4gICAgICAgICAgd2hpbGUgKGRhdGFJbmRleCA8IF9kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGMyID0gU3RyaW5nLmZyb21DaGFyQ29kZShfZGF0YVtkYXRhSW5kZXhdKTtcbiAgICAgICAgICAgIGRhdGFJbmRleCArPSAxO1xuICAgICAgICAgICAgaWYgKHRhYmxlLmNvbnRhaW5zKHMyICsgYzIpKSB7XG4gICAgICAgICAgICAgIHMyID0gczIgKyBjMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJpdE91dC53cml0ZSh0YWJsZS5pbmRleE9mKHMyKSwgYml0TGVuZ3RoKTtcbiAgICAgICAgICAgICAgaWYgKHRhYmxlLnNpemUoKSA8IDQwOTUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFibGUuc2l6ZSgpID09IDEgPDwgYml0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBiaXRMZW5ndGggKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFibGUuYWRkKHMyICsgYzIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHMyID0gYzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJpdE91dC53cml0ZSh0YWJsZS5pbmRleE9mKHMyKSwgYml0TGVuZ3RoKTtcbiAgICAgICAgICBiaXRPdXQud3JpdGUoZW5kQ29kZSwgYml0TGVuZ3RoKTtcbiAgICAgICAgICBiaXRPdXQuZmx1c2goKTtcbiAgICAgICAgICByZXR1cm4gYnl0ZU91dC50b0J5dGVBcnJheSgpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbHp3VGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgX21hcCA9IHt9O1xuICAgICAgICAgIHZhciBfc2l6ZSA9IDA7XG4gICAgICAgICAgdmFyIF90aGlzMiA9IHt9O1xuICAgICAgICAgIF90aGlzMi5hZGQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczIuY29udGFpbnMoa2V5KSkge1xuICAgICAgICAgICAgICB0aHJvdyBcImR1cCBrZXk6XCIgKyBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfbWFwW2tleV0gPSBfc2l6ZTtcbiAgICAgICAgICAgIF9zaXplICs9IDE7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBfdGhpczIuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zaXplO1xuICAgICAgICAgIH07XG4gICAgICAgICAgX3RoaXMyLmluZGV4T2YgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBfbWFwW2tleV07XG4gICAgICAgICAgfTtcbiAgICAgICAgICBfdGhpczIuY29udGFpbnMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgX21hcFtrZXldICE9IFwidW5kZWZpbmVkXCI7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9O1xuICAgICAgdmFyIGNyZWF0ZURhdGFVUkwgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBnZXRQaXhlbCkge1xuICAgICAgICB2YXIgZ2lmID0gZ2lmSW1hZ2Uod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyB5ICs9IDEpIHtcbiAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4ICs9IDEpIHtcbiAgICAgICAgICAgIGdpZi5zZXRQaXhlbCh4LCB5LCBnZXRQaXhlbCh4LCB5KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBiID0gYnl0ZUFycmF5T3V0cHV0U3RyZWFtKCk7XG4gICAgICAgIGdpZi53cml0ZShiKTtcbiAgICAgICAgdmFyIGJhc2U2NCA9IGJhc2U2NEVuY29kZU91dHB1dFN0cmVhbSgpO1xuICAgICAgICB2YXIgYnl0ZXMgPSBiLnRvQnl0ZUFycmF5KCk7XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBieXRlcy5sZW5ndGg7IGkyICs9IDEpIHtcbiAgICAgICAgICBiYXNlNjQud3JpdGVCeXRlKGJ5dGVzW2kyXSk7XG4gICAgICAgIH1cbiAgICAgICAgYmFzZTY0LmZsdXNoKCk7XG4gICAgICAgIHJldHVybiBcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxcIiArIGJhc2U2NDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcXJjb2RlMztcbiAgICB9KCk7XG4gICAgIWZ1bmN0aW9uKCkge1xuICAgICAgcXJjb2RlMi5zdHJpbmdUb0J5dGVzRnVuY3NbXCJVVEYtOFwiXSA9IGZ1bmN0aW9uKHMyKSB7XG4gICAgICAgIGZ1bmN0aW9uIHRvVVRGOEFycmF5KHN0cikge1xuICAgICAgICAgIHZhciB1dGY4ID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHN0ci5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkyKTtcbiAgICAgICAgICAgIGlmIChjaGFyY29kZSA8IDEyOCkgdXRmOC5wdXNoKGNoYXJjb2RlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJjb2RlIDwgMjA0OCkge1xuICAgICAgICAgICAgICB1dGY4LnB1c2goXG4gICAgICAgICAgICAgICAgMTkyIHwgY2hhcmNvZGUgPj4gNixcbiAgICAgICAgICAgICAgICAxMjggfCBjaGFyY29kZSAmIDYzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJjb2RlIDwgNTUyOTYgfHwgY2hhcmNvZGUgPj0gNTczNDQpIHtcbiAgICAgICAgICAgICAgdXRmOC5wdXNoKFxuICAgICAgICAgICAgICAgIDIyNCB8IGNoYXJjb2RlID4+IDEyLFxuICAgICAgICAgICAgICAgIDEyOCB8IGNoYXJjb2RlID4+IDYgJiA2MyxcbiAgICAgICAgICAgICAgICAxMjggfCBjaGFyY29kZSAmIDYzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpMisrO1xuICAgICAgICAgICAgICBjaGFyY29kZSA9IDY1NTM2ICsgKChjaGFyY29kZSAmIDEwMjMpIDw8IDEwIHwgc3RyLmNoYXJDb2RlQXQoaTIpICYgMTAyMyk7XG4gICAgICAgICAgICAgIHV0ZjgucHVzaChcbiAgICAgICAgICAgICAgICAyNDAgfCBjaGFyY29kZSA+PiAxOCxcbiAgICAgICAgICAgICAgICAxMjggfCBjaGFyY29kZSA+PiAxMiAmIDYzLFxuICAgICAgICAgICAgICAgIDEyOCB8IGNoYXJjb2RlID4+IDYgJiA2MyxcbiAgICAgICAgICAgICAgICAxMjggfCBjaGFyY29kZSAmIDYzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB1dGY4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b1VURjhBcnJheShzMik7XG4gICAgICB9O1xuICAgIH0oKTtcbiAgICAoZnVuY3Rpb24oZmFjdG9yeSkge1xuICAgICAge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICAgIH1cbiAgICB9KShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBxcmNvZGUyO1xuICAgIH0pO1xuICB9KShxcmNvZGUkMSk7XG4gIHJldHVybiBxcmNvZGUkMS5leHBvcnRzO1xufVxudmFyIHFyY29kZUV4cG9ydHMgPSByZXF1aXJlUXJjb2RlKCk7XG5jb25zdCBxcmNvZGUgPSAvKiBAX19QVVJFX18gKi8gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMocXJjb2RlRXhwb3J0cyk7XG5mdW5jdGlvbiBjb3B5VG9DbGlwYm9hcmQodGV4dCkge1xuICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIShuYXZpZ2F0b3IgPT0gbnVsbCA/IHZvaWQgMCA6IG5hdmlnYXRvci5jbGlwYm9hcmQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0VUlFcnJvcihcIkNsaXBib2FyZCBBUEkgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB5aWVsZCBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0KTtcbiAgICB9IGNhdGNoIChlMikge1xuICAgIH1cbiAgICBmYWxsYmFja0NvcHlUZXh0VG9DbGlwYm9hcmQodGV4dCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZmFsbGJhY2tDb3B5VGV4dFRvQ2xpcGJvYXJkKHRleHQpIHtcbiAgY29uc3QgdGV4dEFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7XG4gIHRleHRBcmVhLnZhbHVlID0gdGV4dDtcbiAgdGV4dEFyZWEuc3R5bGUudG9wID0gXCIwXCI7XG4gIHRleHRBcmVhLnN0eWxlLmxlZnQgPSBcIjBcIjtcbiAgdGV4dEFyZWEuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGV4dEFyZWEpO1xuICB0ZXh0QXJlYS5mb2N1cygpO1xuICB0ZXh0QXJlYS5zZWxlY3QoKTtcbiAgdHJ5IHtcbiAgICBkb2N1bWVudC5leGVjQ29tbWFuZChcImNvcHlcIik7XG4gIH0gZmluYWxseSB7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0ZXh0QXJlYSk7XG4gIH1cbn1cbnZhciBfdG1wbCQkcyA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8ZGl2PmApO1xuY29uc3QgUVJDb2RlID0gKHByb3BzKSA9PiB7XG4gIGxldCBxckNvZGVDYW52YXNSZWY7XG4gIGxldCBxckNvZGVXcmFwcGVyUmVmO1xuICBsZXQgaW1hZ2VSZWY7XG4gIGNvbnN0IFtjb3B5QnV0dG9uT3BlbmVkLCBzZXRDb3B5QnV0dG9uT3BlbmVkXSA9IGNyZWF0ZVNpZ25hbChmYWxzZSk7XG4gIGNvbnN0IFtwaWNTaXplLCBzZXRQaWNTaXplXSA9IGNyZWF0ZVNpZ25hbChwaWNTaXplRGVmYXVsdCk7XG4gIGNyZWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBcIkxcIjtcbiAgICBjb25zdCBjZWxsU2l6ZSA9IDQ7XG4gICAgY29uc3QgcXIgPSBxcmNvZGUoMCwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpO1xuICAgIHFyLmFkZERhdGEocHJvcHMuc291cmNlVXJsKTtcbiAgICBxci5tYWtlKCk7XG4gICAgcXJDb2RlQ2FudmFzUmVmLmlubmVySFRNTCA9IHFyLmNyZWF0ZVN2Z1RhZyhjZWxsU2l6ZSwgMCk7XG4gICAgY29uc3QgcXJTaXplID0gcXJDb2RlQ2FudmFzUmVmLmZpcnN0RWxlbWVudENoaWxkLmNsaWVudFdpZHRoO1xuICAgIGNvbnN0IHNjYWxlID0gTWF0aC5yb3VuZChxck5vcm1hbFNpemUgLyBxclNpemUgKiAxZTUpIC8gMWU1O1xuICAgIGlmIChpbWFnZVJlZikge1xuICAgICAgY29uc3QgaW1nU2l6ZSA9IE1hdGguY2VpbChpbWdTaXplRGVmYXVsdCAvIChzY2FsZSAqIGNlbGxTaXplKSkgKiBjZWxsU2l6ZTtcbiAgICAgIGNvbnN0IGltZ09mZnNldCA9IHRvUHgoTWF0aC5jZWlsKChxclNpemUgLSBpbWdTaXplKSAvICgyICogY2VsbFNpemUpKSAqIGNlbGxTaXplKTtcbiAgICAgIGltYWdlUmVmLnN0eWxlLnRvcCA9IGltZ09mZnNldDtcbiAgICAgIGltYWdlUmVmLnN0eWxlLmxlZnQgPSBpbWdPZmZzZXQ7XG4gICAgICBpbWFnZVJlZi5zdHlsZS5oZWlnaHQgPSB0b1B4KGltZ1NpemUpO1xuICAgICAgaW1hZ2VSZWYuc3R5bGUud2lkdGggPSB0b1B4KGltZ1NpemUpO1xuICAgICAgc2V0UGljU2l6ZShNYXRoLnJvdW5kKHBpY1NpemVEZWZhdWx0IC8gc2NhbGUpKTtcbiAgICB9XG4gICAgcXJDb2RlV3JhcHBlclJlZi5zdHlsZS50cmFuc2Zvcm0gPSBgc2NhbGUoJHtzY2FsZX0pYDtcbiAgfSk7XG4gIGxldCB0aW1lb3V0SWQgPSBudWxsO1xuICBjb25zdCBvbkNvcHlDbGljayA9ICgpID0+IHtcbiAgICBzZXRDb3B5QnV0dG9uT3BlbmVkKHRydWUpO1xuICAgIGNvcHlUb0NsaXBib2FyZChwcm9wcy5zb3VyY2VVcmwpO1xuICAgIGlmICh0aW1lb3V0SWQgIT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfVxuICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gc2V0Q29weUJ1dHRvbk9wZW5lZChmYWxzZSksIDE1MDApO1xuICB9O1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFFyQ29kZUJhY2tncm91bmQsIHtcbiAgICBnZXQgW1wiY2xhc3NcIl0oKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2xhc3M7XG4gICAgfSxcbiAgICBvbkNsaWNrOiBvbkNvcHlDbGljayxcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChRckNvZGVXcmFwcGVyJDIsIHtcbiAgICAgICAgcmVmKHIkKSB7XG4gICAgICAgICAgdmFyIF9yZWYkID0gcXJDb2RlV3JhcHBlclJlZjtcbiAgICAgICAgICB0eXBlb2YgX3JlZiQgPT09IFwiZnVuY3Rpb25cIiA/IF9yZWYkKHIkKSA6IHFyQ29kZVdyYXBwZXJSZWYgPSByJDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBbKCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfZWwkID0gX3RtcGwkJHMoKTtcbiAgICAgICAgICAgIHZhciBfcmVmJDIgPSBxckNvZGVDYW52YXNSZWY7XG4gICAgICAgICAgICB0eXBlb2YgX3JlZiQyID09PSBcImZ1bmN0aW9uXCIgPyB1c2UoX3JlZiQyLCBfZWwkKSA6IHFyQ29kZUNhbnZhc1JlZiA9IF9lbCQ7XG4gICAgICAgICAgICByZXR1cm4gX2VsJDtcbiAgICAgICAgICB9KSgpLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wcy5pbWFnZVVybDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoSW1hZ2VCYWNrZ3JvdW5kLCB7XG4gICAgICAgICAgICAgICAgcmVmKHIkKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3JlZiQzID0gaW1hZ2VSZWY7XG4gICAgICAgICAgICAgICAgICB0eXBlb2YgX3JlZiQzID09PSBcImZ1bmN0aW9uXCIgPyBfcmVmJDMociQpIDogaW1hZ2VSZWYgPSByJDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoSW1hZ2VTdHlsZWQkMywge1xuICAgICAgICAgICAgICAgICAgICBnZXQgc3JjKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy5pbWFnZVVybDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYWx0OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGljU2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXTtcbiAgICAgICAgfVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChUcmFuc2l0aW9uLCB7XG4gICAgICAgIG9uQmVmb3JlRW50ZXI6IChlbCkgPT4ge1xuICAgICAgICAgIGFuaW1hdGUoZWwsIFt7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgtNTAlLCA0NHB4KVwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoLTUwJSwgMClcIlxuICAgICAgICAgIH1dLCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogMTUwLFxuICAgICAgICAgICAgZWFzaW5nOiBcImVhc2Utb3V0XCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FeGl0OiAoZWwsIGRvbmUpID0+IHtcbiAgICAgICAgICBhbmltYXRlKGVsLCBbe1xuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoLTUwJSwgMClcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKC01MCUsIDQ0cHgpXCJcbiAgICAgICAgICB9XSwge1xuICAgICAgICAgICAgZHVyYXRpb246IDE1MCxcbiAgICAgICAgICAgIGVhc2luZzogXCJlYXNlLW91dFwiXG4gICAgICAgICAgfSkuZmluaXNoZWQudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY29weUJ1dHRvbk9wZW5lZCgpICYmICFwcm9wcy5kaXNhYmxlQ29weTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQ29waWVkQm94U3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoU3VjY2Vzc0ljb24sIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogXCJ4c1wiXG4gICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwiY29tbW9uLmxpbmtDb3BpZWRcIixcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiTGluayBDb3BpZWRcIlxuICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICByZXR1cm4gIXByb3BzLmRpc2FibGVDb3B5O1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChDb3B5SWNvbkJ1dHRvbiwge1xuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KENvcHlMaWdodEljb24sIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSldO1xuICAgIH1cbiAgfSk7XG59O1xudmFyIGRlZXBSZWFkT2JqZWN0ID0gKG9iaiwgcGF0aCwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gIGNvbnN0IHZhbHVlID0gcGF0aC50cmltKCkuc3BsaXQoXCIuXCIpLnJlZHVjZSgoYTIsIGIpID0+IGEyID8gYTJbYl0gOiB2b2lkIDAsIG9iaik7XG4gIHJldHVybiB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59O1xudmFyIHRlbXBsYXRlID0gKHN0ciwgcGFyYW1zLCByZWcgPSAve3soLio/KX19L2cpID0+IHN0ci5yZXBsYWNlKHJlZywgKF8sIGtleSkgPT4gZGVlcFJlYWRPYmplY3QocGFyYW1zLCBrZXksIFwiXCIpKTtcbnZhciBjcmVhdGVJMThuQ29udGV4dCA9IChpbml0ID0ge30sIGxhbmcgPSBuYXZpZ2F0b3IubGFuZ3VhZ2UgaW4gaW5pdCA/IG5hdmlnYXRvci5sYW5ndWFnZSA6IE9iamVjdC5rZXlzKGluaXQpWzBdKSA9PiB7XG4gIGNvbnN0IFtsb2NhbGUsIHNldExvY2FsZV0gPSBjcmVhdGVTaWduYWwobGFuZyk7XG4gIGNvbnN0IFtkaWN0LCBzZXREaWN0XSA9IGNyZWF0ZVN0b3JlKGluaXQpO1xuICBjb25zdCB0cmFuc2xhdGUgPSAoa2V5LCBwYXJhbXMsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICAgIGNvbnN0IHZhbCA9IGRlZXBSZWFkT2JqZWN0KGRpY3RbbG9jYWxlKCldLCBrZXksIGRlZmF1bHRWYWx1ZSB8fCBcIlwiKTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgcmV0dXJuIHZhbChwYXJhbXMpO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIHRlbXBsYXRlKHZhbCwgcGFyYW1zIHx8IHt9KTtcbiAgICByZXR1cm4gdmFsO1xuICB9O1xuICBjb25zdCBhY3Rpb25zID0ge1xuICAgIGFkZChsYW5nMiwgdGFibGUpIHtcbiAgICAgIHNldERpY3QobGFuZzIsICh0MikgPT4gT2JqZWN0LmFzc2lnbih0MiB8fCB7fSwgdGFibGUpKTtcbiAgICB9LFxuICAgIGxvY2FsZTogKGxhbmcyKSA9PiBsYW5nMiA/IHNldExvY2FsZShsYW5nMikgOiBsb2NhbGUoKSxcbiAgICBkaWN0OiAobGFuZzIpID0+IGRlZXBSZWFkT2JqZWN0KGRpY3QsIGxhbmcyKVxuICB9O1xuICByZXR1cm4gW3RyYW5zbGF0ZSwgYWN0aW9uc107XG59O1xudmFyIEkxOG5Db250ZXh0ID0gY3JlYXRlQ29udGV4dCh7fSk7XG52YXIgdXNlSTE4biA9ICgpID0+IHVzZUNvbnRleHQoSTE4bkNvbnRleHQpO1xuY29uc3QgVGV4dFN0eWxlZCQ0ID0gc3R5bGVkLmRpdmBcbiAgICBmb250LXN0eWxlOiBub3JtYWw7XG4gICAgZm9udC13ZWlnaHQ6ICR7KHByb3BzKSA9PiBwcm9wcy5mb250V2VpZ2h0fTtcbiAgICBmb250LXNpemU6ICR7KHByb3BzKSA9PiBwcm9wcy5mb250U2l6ZX07XG4gICAgbGluZS1oZWlnaHQ6ICR7KHByb3BzKSA9PiBwcm9wcy5saW5lSGVpZ2h0fTtcblxuICAgIGNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMuY29sb3J9O1xuYDtcbmNvbnN0IFRleHQgPSAoaW5wdXRzKSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3QgW3QyXSA9IHVzZUkxOG4oKTtcbiAgbGV0IHRleHRSZWY7XG4gIGNvbnN0IGNvbG9yID0gKCkgPT4gaW5wdXRzLmNvbG9yIHx8IHRoZW1lLmNvbG9ycy50ZXh0LnByaW1hcnk7XG4gIGNvbnN0IHByb3BzID0gbWVyZ2VQcm9wcyh7XG4gICAgZm9udFNpemU6IFwiMTRweFwiLFxuICAgIGZvbnRXZWlnaHQ6IFwiNTEwXCIsXG4gICAgbGluZUhlaWdodDogXCIxMzAlXCJcbiAgfSwgaW5wdXRzKTtcbiAgY3JlYXRlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXRleHRSZWYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmN1cnNvciA9PT0gXCJ1bnNldFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKHRleHRSZWYpLmN1cnNvciAhPT0gXCJwb2ludGVyXCIpIHtcbiAgICAgIHRleHRSZWYuc3R5bGUuY3Vyc29yID0gXCJkZWZhdWx0XCI7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUZXh0U3R5bGVkJDQsIHtcbiAgICBnZXQgZm9udFNpemUoKSB7XG4gICAgICByZXR1cm4gcHJvcHMuZm9udFNpemU7XG4gICAgfSxcbiAgICBnZXQgZm9udFdlaWdodCgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5mb250V2VpZ2h0O1xuICAgIH0sXG4gICAgZ2V0IGxpbmVIZWlnaHQoKSB7XG4gICAgICByZXR1cm4gcHJvcHMubGluZUhlaWdodDtcbiAgICB9LFxuICAgIGdldCBjb2xvcigpIHtcbiAgICAgIHJldHVybiBjb2xvcigpO1xuICAgIH0sXG4gICAgZ2V0IFtcImNsYXNzXCJdKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgIH0sXG4gICAgcmVmKHIkKSB7XG4gICAgICB2YXIgX3JlZiQgPSB0ZXh0UmVmO1xuICAgICAgdHlwZW9mIF9yZWYkID09PSBcImZ1bmN0aW9uXCIgPyBfcmVmJChyJCkgOiB0ZXh0UmVmID0gciQ7XG4gICAgfSxcbiAgICBcImRhdGEtdGMtdGV4dFwiOiBcInRydWVcIixcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgcmV0dXJuIG1lbW8oKCkgPT4gISFwcm9wcy50cmFuc2xhdGlvbktleSkoKSA/IHQyKHByb3BzLnRyYW5zbGF0aW9uS2V5LCBwcm9wcy50cmFuc2xhdGlvblZhbHVlcywgKF9hMiA9IHByb3BzLmNoaWxkcmVuKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnRvU3RyaW5nKCkpIDogcHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBJbWFnZUNvbnRhaW5lciA9IHN0eWxlZC5kaXZgXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgJjo6YWZ0ZXIge1xuICAgICAgICBjb250ZW50OiAnJztcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBib3R0b206IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBib3JkZXI6IDAuNXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4wOCk7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XG4gICAgfVxuYDtcbmNvbnN0IEltYWdlU3R5bGVkJDIgPSBzdHlsZWQoSW1hZ2UpYFxuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBib3JkZXItcmFkaXVzOiBpbmhlcml0O1xuYDtcbmNvbnN0IFdhbGxldEltYWdlID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoSW1hZ2VDb250YWluZXIsIHtcbiAgICBnZXQgW1wiY2xhc3NcIl0oKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2xhc3M7XG4gICAgfSxcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChJbWFnZVN0eWxlZCQyLCB7XG4gICAgICAgIGdldCBzcmMoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLnNyYztcbiAgICAgICAgfVxuICAgICAgfSksIG1lbW8oKCkgPT4gcHJvcHMuYmFkZ2UpXTtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IGJvcmRlcnMkNCA9IHtcbiAgbTogXCIxNnB4XCIsXG4gIHM6IFwiMTJweFwiLFxuICBub25lOiBcIjBcIlxufTtcbmNvbnN0IGJhZGdlQm9yZGVycyA9IHtcbiAgbTogXCI2cHhcIixcbiAgczogXCI2cHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCBXYWxsZXRVbENvbnRhaW5lciA9IHN0eWxlZC51bGBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGdhcDogMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBvdmVyZmxvdy14OiBhdXRvO1xuICAgIHBhZGRpbmc6IDhweCAxMnB4IDE2cHggMTJweDtcbiAgICBtYXJnaW46IDA7XG4gICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICBmbGV4LXdyYXA6IG5vd3JhcDtcblxuICAgICYmOjotd2Via2l0LXNjcm9sbGJhciB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuICAgIC1tcy1vdmVyZmxvdy1zdHlsZTogbm9uZTtcbiAgICBzY3JvbGxiYXItd2lkdGg6IG5vbmU7XG5cbiAgICA+IGxpIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleDogMTtcbiAgICAgICAgbWluLXdpZHRoOiA3OHB4O1xuICAgICAgICBoZWlnaHQ6IGZpdC1jb250ZW50O1xuICAgIH1cblxuICAgID4gbGkgPiBidXR0b24ge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICB9XG5gO1xuY29uc3QgV2FsbGV0SXRlbVN0eWxlZCA9IHN0eWxlZC5idXR0b25gXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBib3JkZXI6IG5vbmU7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdW5zZXQ7XG4gICAgcGFkZGluZzogOHB4IDRweDtcbiAgICBtaW4td2lkdGg6IDc4cHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4xMjVzIGVhc2UtaW4tb3V0O1xuXG4gICAgJHttZWRpYU5vdFRvdWNofSB7XG4gICAgICAgICY6aG92ZXIge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLjA0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICY6YWN0aXZlIHtcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjk2KTtcbiAgICB9XG5cbiAgICAke21lZGlhVG91Y2h9IHtcbiAgICAgICAgJjphY3RpdmUge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjkyKTtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5jb25zdCBJbWFnZVN0eWxlZCQxID0gc3R5bGVkKFdhbGxldEltYWdlKWBcbiAgICB3aWR0aDogNjBweDtcbiAgICBoZWlnaHQ6IDYwcHg7XG4gICAgYm9yZGVyLXJhZGl1czogJHsocHJvcHMpID0+IGJvcmRlcnMkNFtwcm9wcy50aGVtZS5ib3JkZXJSYWRpdXNdfTtcbiAgICBtYXJnaW4tYm90dG9tOiA4cHg7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuYDtcbmNvbnN0IEJhZGdlU3R5bGVkID0gc3R5bGVkKEltYWdlKWBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgcmlnaHQ6IC02cHg7XG4gICAgYm90dG9tOiAtNnB4O1xuICAgIHdpZHRoOiAyNHB4O1xuICAgIGhlaWdodDogMjRweDtcbiAgICBib3JkZXItcmFkaXVzOiAkeyhwcm9wcykgPT4gYmFkZ2VCb3JkZXJzW3Byb3BzLnRoZW1lLmJvcmRlclJhZGl1c119O1xuICAgIGJveC1zaGFkb3c6IDAgMnB4IDhweCAwIHJnYmEoMCwgMCwgMCwgMC4wOCk7XG5gO1xuY29uc3QgU3R5bGVkVGV4dCA9IHN0eWxlZChUZXh0KWBcbiAgICBtYXgtd2lkdGg6IDkwcHg7XG4gICAgZm9udC13ZWlnaHQ6IDUxMDtcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG5cbiAgICAke21lZGlhKFwibW9iaWxlXCIpfSB7XG4gICAgICAgIG1heC13aWR0aDogODBweDtcbiAgICB9XG5gO1xuY29uc3QgU3R5bGVkU2Vjb25kTGluZSA9IHN0eWxlZChUZXh0KWBcbiAgICBmb250LXdlaWdodDogJHsocHJvcHMpID0+IHByb3BzLmNvbG9yUHJpbWFyeSA/IFwiNTEwXCIgOiBcIjQwMFwifTtcbiAgICBtYXgtd2lkdGg6IDkwcHg7XG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIGNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMuY29sb3JQcmltYXJ5ID8gcHJvcHMudGhlbWUuY29sb3JzLnRleHQucHJpbWFyeSA6IHByb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeX07XG5cbiAgICAke21lZGlhKFwibW9iaWxlXCIpfSB7XG4gICAgICAgIG1heC13aWR0aDogODBweDtcbiAgICB9XG5gO1xudmFyIF90bXBsJCRyID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxkaXY+YCk7XG5jb25zdCBXYWxsZXRJdGVtID0gKHByb3BzKSA9PiB7XG4gIGxldCBjdHhSZWYgPSBudWxsO1xuICBjb25zdCBhZGp1c3RMZXR0ZXJTcGFjaW5nID0gKCkgPT4ge1xuICAgIGNvbnN0IG5hbWUgPSBjdHhSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IGN0eFJlZi5xdWVyeVNlbGVjdG9yKFwiZGl2XCIpO1xuICAgIGlmIChuYW1lICYmIG5hbWUuc2Nyb2xsV2lkdGggPiBuYW1lLmNsaWVudFdpZHRoKSB7XG4gICAgICBsZXQgc3BhY2luZyA9IDA7XG4gICAgICBjb25zdCBtaW5TcGFjaW5nID0gLTAuNDtcbiAgICAgIGNvbnN0IHN0ZXAgPSAwLjA1O1xuICAgICAgd2hpbGUgKG5hbWUuc2Nyb2xsV2lkdGggPiBuYW1lLmNsaWVudFdpZHRoICYmIHNwYWNpbmcgPj0gbWluU3BhY2luZykge1xuICAgICAgICBzcGFjaW5nIC09IHN0ZXA7XG4gICAgICAgIG5hbWUuc3R5bGUubGV0dGVyU3BhY2luZyA9IGAke3NwYWNpbmd9cHhgO1xuICAgICAgfVxuICAgICAgaWYgKHNwYWNpbmcgIT09IDApIHtcbiAgICAgICAgc3BhY2luZyAtPSBzdGVwO1xuICAgICAgICBuYW1lLnN0eWxlLmxldHRlclNwYWNpbmcgPSBgJHtzcGFjaW5nfXB4YDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIG9uTW91bnQoKCkgPT4gYWRqdXN0TGV0dGVyU3BhY2luZygpKTtcbiAgY3JlYXRlRWZmZWN0KCgpID0+IHtcbiAgICBhZGp1c3RMZXR0ZXJTcGFjaW5nKCk7XG4gIH0pO1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFdhbGxldEl0ZW1TdHlsZWQsIHtcbiAgICBnZXQgW1wiY2xhc3NcIl0oKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2xhc3M7XG4gICAgfSxcbiAgICBvbkNsaWNrOiAoKSA9PiBwcm9wcy5vbkNsaWNrKCksXG4gICAgXCJkYXRhLXRjLXdhbGxldC1pdGVtXCI6IFwidHJ1ZVwiLFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBbbWVtbygoKSA9PiBtZW1vKCgpID0+IHR5cGVvZiBwcm9wcy5pY29uID09PSBcInN0cmluZ1wiKSgpID8gY3JlYXRlQ29tcG9uZW50KEltYWdlU3R5bGVkJDEsIHtcbiAgICAgICAgZ2V0IHNyYygpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcHMuaWNvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGJhZGdlKCkge1xuICAgICAgICAgIHJldHVybiBtZW1vKCgpID0+ICEhcHJvcHMuYmFkZ2VVcmwpKCkgJiYgY3JlYXRlQ29tcG9uZW50KEJhZGdlU3R5bGVkLCB7XG4gICAgICAgICAgICBnZXQgc3JjKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuYmFkZ2VVcmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pIDogcHJvcHMuaWNvbiksICgoKSA9PiB7XG4gICAgICAgIHZhciBfZWwkID0gX3RtcGwkJHIoKTtcbiAgICAgICAgdXNlKChlbCkgPT4gY3R4UmVmID0gZWwsIF9lbCQpO1xuICAgICAgICBpbnNlcnQoX2VsJCwgY3JlYXRlQ29tcG9uZW50KFN0eWxlZFRleHQsIHtcbiAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcHMubmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIF9lbCQ7XG4gICAgICB9KSgpLCBtZW1vKCgpID0+IG1lbW8oKCkgPT4gISFwcm9wcy5zZWNvbmRMaW5lKSgpICYmIGNyZWF0ZUNvbXBvbmVudChTdHlsZWRTZWNvbmRMaW5lLCB7XG4gICAgICAgIGdldCBjb2xvclByaW1hcnkoKSB7XG4gICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICByZXR1cm4gKF9hMiA9IHByb3BzLnNlY29uZExpbmVDb2xvclByaW1hcnkpICE9IG51bGwgPyBfYTIgOiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLnNlY29uZExpbmU7XG4gICAgICAgIH1cbiAgICAgIH0pKV07XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBIMVN0eWxlZCRiID0gc3R5bGVkLmgxYFxuICAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcbiAgICBmb250LXdlaWdodDogNTkwO1xuICAgIGZvbnQtc2l6ZTogMjBweDtcbiAgICBsaW5lLWhlaWdodDogMjhweDtcblxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcblxuICAgIGNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLnRleHQucHJpbWFyeX07XG5cbiAgICBtYXJnaW4tdG9wOiAwO1xuICAgIG1hcmdpbi1ib3R0b206IDA7XG5cbiAgICBjdXJzb3I6IGRlZmF1bHQ7XG5gO1xuY29uc3QgSDEgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgW3QyXSA9IHVzZUkxOG4oKTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChIMVN0eWxlZCRiLCB7XG4gICAgZ2V0IFtcImNsYXNzXCJdKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgIH0sXG4gICAgXCJkYXRhLXRjLWgxXCI6IFwidHJ1ZVwiLFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHZhciBfYTI7XG4gICAgICByZXR1cm4gbWVtbygoKSA9PiAhIXByb3BzLnRyYW5zbGF0aW9uS2V5KSgpID8gdDIocHJvcHMudHJhbnNsYXRpb25LZXksIHByb3BzLnRyYW5zbGF0aW9uVmFsdWVzLCAoX2EyID0gcHJvcHMuY2hpbGRyZW4pID09IG51bGwgPyB2b2lkIDAgOiBfYTIudG9TdHJpbmcoKSkgOiBwcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IEgyU3R5bGVkJDUgPSBzdHlsZWQuaDJgXG4gICAgZm9udC1zdHlsZTogbm9ybWFsO1xuICAgIGZvbnQtd2VpZ2h0OiA0MDA7XG4gICAgZm9udC1zaXplOiAxNnB4O1xuICAgIGxpbmUtaGVpZ2h0OiAyMnB4O1xuXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuXG4gICAgY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnl9O1xuXG4gICAgbWFyZ2luLXRvcDogMDtcbiAgICBtYXJnaW4tYm90dG9tOiAzMnB4O1xuXG4gICAgY3Vyc29yOiBkZWZhdWx0O1xuYDtcbmNvbnN0IEgyID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IFt0Ml0gPSB1c2VJMThuKCk7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoSDJTdHlsZWQkNSwge1xuICAgIGdldCBbXCJjbGFzc1wiXSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5jbGFzcztcbiAgICB9LFxuICAgIFwiZGF0YS10Yy1oMlwiOiBcInRydWVcIixcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgcmV0dXJuIG1lbW8oKCkgPT4gISFwcm9wcy50cmFuc2xhdGlvbktleSkoKSA/IHQyKHByb3BzLnRyYW5zbGF0aW9uS2V5LCBwcm9wcy50cmFuc2xhdGlvblZhbHVlcywgKF9hMiA9IHByb3BzLmNoaWxkcmVuKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnRvU3RyaW5nKCkpIDogcHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBIM1N0eWxlZCQyID0gc3R5bGVkLmgzYFxuICAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcbiAgICBmb250LXdlaWdodDogNTEwO1xuICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICBsaW5lLWhlaWdodDogMjBweDtcblxuICAgIGNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLnRleHQucHJpbWFyeX07XG5cbiAgICBtYXJnaW4tdG9wOiAwO1xuICAgIG1hcmdpbi1ib3R0b206IDA7XG5cbiAgICBjdXJzb3I6IGRlZmF1bHQ7XG5gO1xuY29uc3QgSDMgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgW3QyXSA9IHVzZUkxOG4oKTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChIM1N0eWxlZCQyLCB7XG4gICAgXCJkYXRhLXRjLWgzXCI6IFwidHJ1ZVwiLFxuICAgIGdldCBbXCJjbGFzc1wiXSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5jbGFzcztcbiAgICB9LFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHZhciBfYTI7XG4gICAgICByZXR1cm4gbWVtbygoKSA9PiAhIXByb3BzLnRyYW5zbGF0aW9uS2V5KSgpID8gdDIocHJvcHMudHJhbnNsYXRpb25LZXksIHByb3BzLnRyYW5zbGF0aW9uVmFsdWVzLCAoX2EyID0gcHJvcHMuY2hpbGRyZW4pID09IG51bGwgPyB2b2lkIDAgOiBfYTIudG9TdHJpbmcoKSkgOiBwcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gIH0pO1xufTtcbnZhciBfdG1wbCQkcSA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8c3ZnIHdpZHRoPTI0IGhlaWdodD0yNCB2aWV3Qm94PVwiMCAwIDI0IDI0XCJmaWxsPW5vbmUgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmc+PHBhdGggZmlsbC1ydWxlPWV2ZW5vZGQgY2xpcC1ydWxlPWV2ZW5vZGQgZD1cIk0xNC4xODM5IDE3LjcwNjlDMTMuNjQwNSAxOC42NTA3IDEzLjM2ODggMTkuMTIyNiAxMy4wNTkxIDE5LjM0OEMxMi40Mjc4IDE5LjgwNzQgMTEuNTcyMyAxOS44MDc0IDEwLjk0MSAxOS4zNDhDMTAuNjMxMiAxOS4xMjI2IDEwLjM1OTUgMTguNjUwNyA5LjgxNjEzIDE3LjcwNjlMNS41MjA2NiAxMC4yNDY0QzQuNzY4NjQgOC45NDAyNCA0LjM5MjYzIDguMjg3MTcgNC4zMzc2MiA3Ljc1ODk0QzQuMjI1NSA2LjY4MjM2IDQuODE4OTQgNS42NTU5MSA1LjgwNzg4IDUuMjE1ODlDNi4yOTMwOSA1IDcuMDQ2NjcgNSA4LjU1MzgzIDVIMTUuNDQ2MkMxNi45NTM0IDUgMTcuNzA2OSA1IDE4LjE5MjIgNS4yMTU4OUMxOS4xODExIDUuNjU1OTEgMTkuNzc0NSA2LjY4MjM2IDE5LjY2MjQgNy43NTg5NEMxOS42MDc0IDguMjg3MTcgMTkuMjMxNCA4Ljk0MDI0IDE4LjQ3OTQgMTAuMjQ2NEwxNC4xODM5IDE3LjcwNjlaTTExLjEgMTYuMzQxMkw2LjU2MTM5IDguNDgwMDJDNi4zMTk5NSA4LjA2MTg1IDYuMTk5MjQgNy44NTI3NiA2LjE4MTQ2IDcuNjgzNjVDNi4xNDUyMyA3LjMzODk2IDYuMzM1MDcgNy4wMTAxNSA2LjY1MTY5IDYuODY5MTlDNi44MDcwMyA2LjgwMDAyIDcuMDQ4NDcgNi44MDAwMiA3LjUzMTMzIDYuODAwMDJINy41MzEzNEwxMS4xIDYuODAwMDJWMTYuMzQxMlpNMTIuOSAxNi4zNDEyTDE3LjQzODcgOC40ODAwMkMxNy42ODAxIDguMDYxODUgMTcuODAwOCA3Ljg1Mjc2IDE3LjgxODYgNy42ODM2NUMxNy44NTQ4IDcuMzM4OTYgMTcuNjY1IDcuMDEwMTUgMTcuMzQ4NCA2Ljg2OTE5QzE3LjE5MyA2LjgwMDAyIDE2Ljk1MTYgNi44MDAwMiAxNi40Njg3IDYuODAwMDJMMTIuOSA2LjgwMDAyVjE2LjM0MTJaXCI+YCk7XG5jb25zdCBUb25JY29uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3QgZmlsbCA9ICgpID0+IHByb3BzLmZpbGwgfHwgdGhlbWUuY29sb3JzLmljb24ucHJpbWFyeTtcbiAgcmV0dXJuICgoKSA9PiB7XG4gICAgdmFyIF9lbCQgPSBfdG1wbCQkcSgpLCBfZWwkMiA9IF9lbCQuZmlyc3RDaGlsZDtcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKCkgPT4gc2V0QXR0cmlidXRlKF9lbCQyLCBcImZpbGxcIiwgZmlsbCgpKSk7XG4gICAgcmV0dXJuIF9lbCQ7XG4gIH0pKCk7XG59O1xudmFyIF90bXBsJCRwID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcgd2lkdGg9MTYgaGVpZ2h0PTE2IHZpZXdCb3g9XCIwIDAgMTYgMTZcImZpbGw9bm9uZT48ZyBjbGlwLXBhdGg9dXJsKCNjbGlwMF8zNzgzXzIwNDUpPjxjaXJjbGUgY3g9OCBjeT04LjAwMDk4IHI9OD48L2NpcmNsZT48cGF0aCBkPVwiTTQuNzUgOC41MDA5OEw3IDEwLjc1MUwxMS43NSA2LjAwMDk4XCJzdHJva2Utd2lkdGg9MS41IHN0cm9rZS1saW5lY2FwPXJvdW5kIHN0cm9rZS1saW5lam9pbj1yb3VuZD48L3BhdGg+PC9nPjxkZWZzPjxjbGlwUGF0aCBpZD1jbGlwMF8zNzgzXzIwNDU+PHJlY3Qgd2lkdGg9MTYgaGVpZ2h0PTE2IGZpbGw9d2hpdGUgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAgMC4wMDA5NzY1NjIpXCI+YCksIF90bXBsJDIkNCA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8c3ZnIHdpZHRoPTI0IGhlaWdodD0yNCB2aWV3Qm94PVwiMCAwIDI0IDI0XCJmaWxsPW5vbmUgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmc+PGNpcmNsZSBjeD0xMiBjeT0xMiByPTExPjwvY2lyY2xlPjxwYXRoIGQ9XCJNMTcuMTM2NCA5LjYzNjRDMTcuNDg3OSA5LjI4NDkzIDE3LjQ4NzkgOC43MTUwOCAxNy4xMzY0IDguMzYzNjFDMTYuNzg0OSA4LjAxMjE0IDE2LjIxNTEgOC4wMTIxNCAxNS44NjM2IDguMzYzNjFMMTAgMTQuMjI3Mkw4LjEzNjQgMTIuMzYzNkM3Ljc4NDkzIDEyLjAxMjEgNy4yMTUwOCAxMi4wMTIxIDYuODYzNjEgMTIuMzYzNkM2LjUxMjE0IDEyLjcxNTEgNi41MTIxNCAxMy4yODQ5IDYuODYzNjEgMTMuNjM2NEw5LjM2MzYxIDE2LjEzNjRDOS43MTUwOCAxNi40ODc5IDEwLjI4NDkgMTYuNDg3OSAxMC42MzY0IDE2LjEzNjRMMTcuMTM2NCA5LjYzNjRaXCI+YCksIF90bXBsJDMkMiA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8c3ZnIHdpZHRoPTcyIGhlaWdodD03MiB2aWV3Qm94PVwiMCAwIDcyIDcyXCJmaWxsPW5vbmUgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmc+PGNpcmNsZSBjeD0zNiBjeT0zNiByPTMzPjwvY2lyY2xlPjxwYXRoIGQ9XCJNNTAuOTE0MiAyOC40MTQyQzUxLjY5NTMgMjcuNjMzMiA1MS42OTUzIDI2LjM2NjggNTAuOTE0MiAyNS41ODU4QzUwLjEzMzIgMjQuODA0NyA0OC44NjY4IDI0LjgwNDcgNDguMDg1OCAyNS41ODU4TDMwIDQzLjY3MTZMMjMuOTE0MiAzNy41ODU4QzIzLjEzMzIgMzYuODA0NyAyMS44NjY4IDM2LjgwNDcgMjEuMDg1OCAzNy41ODU4QzIwLjMwNDcgMzguMzY2OCAyMC4zMDQ3IDM5LjYzMzIgMjEuMDg1OCA0MC40MTQyTDI4LjU4NTggNDcuOTE0MkMyOS4zNjY4IDQ4LjY5NTMgMzAuNjMzMiA0OC42OTUzIDMxLjQxNDIgNDcuOTE0Mkw1MC45MTQyIDI4LjQxNDJaXCI+YCk7XG5jb25zdCBTdWNjZXNzSWNvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IHNpemUgPSAoKSA9PiBwcm9wcy5zaXplIHx8IFwic1wiO1xuICBjb25zdCBmaWxsID0gKCkgPT4gcHJvcHMuZmlsbCB8fCB0aGVtZS5jb2xvcnMuaWNvbi5zdWNjZXNzO1xuICByZXR1cm4gbWVtbygoKSA9PiBtZW1vKCgpID0+IHNpemUoKSA9PT0gXCJ4c1wiKSgpID8gKCgpID0+IHtcbiAgICB2YXIgX2VsJCA9IF90bXBsJCRwKCksIF9lbCQyID0gX2VsJC5maXJzdENoaWxkLCBfZWwkMyA9IF9lbCQyLmZpcnN0Q2hpbGQsIF9lbCQ0ID0gX2VsJDMubmV4dFNpYmxpbmc7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KChfcCQpID0+IHtcbiAgICAgIHZhciBfdiQgPSBwcm9wcy5jbGFzcywgX3YkMiA9IGZpbGwoKSwgX3YkMyA9IHRoZW1lLmNvbG9ycy5jb25zdGFudC53aGl0ZTtcbiAgICAgIF92JCAhPT0gX3AkLmUgJiYgc2V0QXR0cmlidXRlKF9lbCQsIFwiY2xhc3NcIiwgX3AkLmUgPSBfdiQpO1xuICAgICAgX3YkMiAhPT0gX3AkLnQgJiYgc2V0QXR0cmlidXRlKF9lbCQzLCBcImZpbGxcIiwgX3AkLnQgPSBfdiQyKTtcbiAgICAgIF92JDMgIT09IF9wJC5hICYmIHNldEF0dHJpYnV0ZShfZWwkNCwgXCJzdHJva2VcIiwgX3AkLmEgPSBfdiQzKTtcbiAgICAgIHJldHVybiBfcCQ7XG4gICAgfSwge1xuICAgICAgZTogdm9pZCAwLFxuICAgICAgdDogdm9pZCAwLFxuICAgICAgYTogdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIF9lbCQ7XG4gIH0pKCkgOiBtZW1vKCgpID0+IHNpemUoKSA9PT0gXCJzXCIpKCkgPyAoKCkgPT4ge1xuICAgIHZhciBfZWwkNSA9IF90bXBsJDIkNCgpLCBfZWwkNiA9IF9lbCQ1LmZpcnN0Q2hpbGQsIF9lbCQ3ID0gX2VsJDYubmV4dFNpYmxpbmc7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KChfcCQpID0+IHtcbiAgICAgIHZhciBfdiQ0ID0gcHJvcHMuY2xhc3MsIF92JDUgPSBmaWxsKCksIF92JDYgPSB0aGVtZS5jb2xvcnMuY29uc3RhbnQud2hpdGU7XG4gICAgICBfdiQ0ICE9PSBfcCQuZSAmJiBzZXRBdHRyaWJ1dGUoX2VsJDUsIFwiY2xhc3NcIiwgX3AkLmUgPSBfdiQ0KTtcbiAgICAgIF92JDUgIT09IF9wJC50ICYmIHNldEF0dHJpYnV0ZShfZWwkNiwgXCJmaWxsXCIsIF9wJC50ID0gX3YkNSk7XG4gICAgICBfdiQ2ICE9PSBfcCQuYSAmJiBzZXRBdHRyaWJ1dGUoX2VsJDcsIFwiZmlsbFwiLCBfcCQuYSA9IF92JDYpO1xuICAgICAgcmV0dXJuIF9wJDtcbiAgICB9LCB7XG4gICAgICBlOiB2b2lkIDAsXG4gICAgICB0OiB2b2lkIDAsXG4gICAgICBhOiB2b2lkIDBcbiAgICB9KTtcbiAgICByZXR1cm4gX2VsJDU7XG4gIH0pKCkgOiAoKCkgPT4ge1xuICAgIHZhciBfZWwkOCA9IF90bXBsJDMkMigpLCBfZWwkOSA9IF9lbCQ4LmZpcnN0Q2hpbGQsIF9lbCQwID0gX2VsJDkubmV4dFNpYmxpbmc7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KChfcCQpID0+IHtcbiAgICAgIHZhciBfdiQ3ID0gcHJvcHMuY2xhc3MsIF92JDggPSBmaWxsKCksIF92JDkgPSB0aGVtZS5jb2xvcnMuY29uc3RhbnQud2hpdGU7XG4gICAgICBfdiQ3ICE9PSBfcCQuZSAmJiBzZXRBdHRyaWJ1dGUoX2VsJDgsIFwiY2xhc3NcIiwgX3AkLmUgPSBfdiQ3KTtcbiAgICAgIF92JDggIT09IF9wJC50ICYmIHNldEF0dHJpYnV0ZShfZWwkOSwgXCJmaWxsXCIsIF9wJC50ID0gX3YkOCk7XG4gICAgICBfdiQ5ICE9PSBfcCQuYSAmJiBzZXRBdHRyaWJ1dGUoX2VsJDAsIFwiZmlsbFwiLCBfcCQuYSA9IF92JDkpO1xuICAgICAgcmV0dXJuIF9wJDtcbiAgICB9LCB7XG4gICAgICBlOiB2b2lkIDAsXG4gICAgICB0OiB2b2lkIDAsXG4gICAgICBhOiB2b2lkIDBcbiAgICB9KTtcbiAgICByZXR1cm4gX2VsJDg7XG4gIH0pKCkpO1xufTtcbnZhciBfdG1wbCQkbyA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8c3ZnIHdpZHRoPTcyIGhlaWdodD03MiB2aWV3Qm94PVwiMCAwIDcyIDcyXCJmaWxsPW5vbmUgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmc+PGNpcmNsZSBjeD0zNiBjeT0zNiByPTMzPjwvY2lyY2xlPjxwYXRoIGQ9XCJNMjQuMDg1OCAyNi45MTQyQzIzLjMwNDcgMjYuMTMzMiAyMy4zMDQ3IDI0Ljg2NjggMjQuMDg1OCAyNC4wODU4QzI0Ljg2NjggMjMuMzA0NyAyNi4xMzMyIDIzLjMwNDcgMjYuOTE0MiAyNC4wODU4TDM2IDMzLjE3MTZMNDUuMDg1OCAyNC4wODU4QzQ1Ljg2NjggMjMuMzA0NyA0Ny4xMzMyIDIzLjMwNDcgNDcuOTE0MiAyNC4wODU4QzQ4LjY5NTMgMjQuODY2OCA0OC42OTUzIDI2LjEzMzIgNDcuOTE0MiAyNi45MTQyTDM4LjgyODQgMzZMNDcuOTE0MiA0NS4wODU4QzQ4LjY5NTMgNDUuODY2OCA0OC42OTUzIDQ3LjEzMzIgNDcuOTE0MiA0Ny45MTQyQzQ3LjEzMzIgNDguNjk1MyA0NS44NjY4IDQ4LjY5NTMgNDUuMDg1OCA0Ny45MTQyTDM2IDM4LjgyODRMMjYuOTE0MiA0Ny45MTQyQzI2LjEzMzIgNDguNjk1MyAyNC44NjY4IDQ4LjY5NTMgMjQuMDg1OCA0Ny45MTQyQzIzLjMwNDcgNDcuMTMzMiAyMy4zMDQ3IDQ1Ljg2NjggMjQuMDg1OCA0NS4wODU4TDMzLjE3MTYgMzZMMjQuMDg1OCAyNi45MTQyWlwiPmApLCBfdG1wbCQyJDMgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyB3aWR0aD00OCBoZWlnaHQ9NDggdmlld0JveD1cIjAgMCA0OCA0OFwiZmlsbD1ub25lPjxjaXJjbGUgY3g9MjQgY3k9MjQuMDAxIHI9MjI+PC9jaXJjbGU+PHBhdGggZD1cIk0yNCAyNC4wMDFMMzEuNSAxNi41MDFNMjQgMjQuMDAxTDE2LjUgMTYuNTAxTTI0IDI0LjAwMUwxNi41IDMxLjUwMU0yNCAyNC4wMDFMMzEuNSAzMS41MDFcInN0cm9rZS13aWR0aD0zIHN0cm9rZS1saW5lY2FwPXJvdW5kIHN0cm9rZS1saW5lam9pbj1yb3VuZD5gKSwgX3RtcGwkMyQxID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgd2lkdGg9MjQgaGVpZ2h0PTI0IHZpZXdCb3g9XCIwIDAgMjQgMjRcImZpbGw9bm9uZSB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zz48Y2lyY2xlIGN4PTEyIGN5PTEyIHI9MTE+PC9jaXJjbGU+PHBhdGggZD1cIk03Ljg2MzYxIDkuMTM2NEM3LjUxMjE0IDguNzg0OTMgNy41MTIxNCA4LjIxNTA4IDcuODYzNjEgNy44NjM2MUM4LjIxNTA4IDcuNTEyMTQgOC43ODQ5MyA3LjUxMjE0IDkuMTM2NCA3Ljg2MzYxTDEyIDEwLjcyNzJMMTQuODYzNiA3Ljg2MzYxQzE1LjIxNTEgNy41MTIxNCAxNS43ODQ5IDcuNTEyMTQgMTYuMTM2NCA3Ljg2MzYxQzE2LjQ4NzkgOC4yMTUwOCAxNi40ODc5IDguNzg0OTMgMTYuMTM2NCA5LjEzNjRMMTMuMjcyOCAxMkwxNi4xMzY0IDE0Ljg2MzZDMTYuNDg3OSAxNS4yMTUxIDE2LjQ4NzkgMTUuNzg0OSAxNi4xMzY0IDE2LjEzNjRDMTUuNzg0OSAxNi40ODc5IDE1LjIxNTEgMTYuNDg3OSAxNC44NjM2IDE2LjEzNjRMMTIgMTMuMjcyOEw5LjEzNjQgMTYuMTM2NEM4Ljc4NDkzIDE2LjQ4NzkgOC4yMTUwOCAxNi40ODc5IDcuODYzNjEgMTYuMTM2NEM3LjUxMjE0IDE1Ljc4NDkgNy41MTIxNCAxNS4yMTUxIDcuODYzNjEgMTQuODYzNkwxMC43MjcyIDEyTDcuODYzNjEgOS4xMzY0WlwiPmApO1xuY29uc3QgRXJyb3JJY29uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3Qgc2l6ZSA9ICgpID0+IHByb3BzLnNpemUgfHwgXCJtXCI7XG4gIGNvbnN0IGZpbGwgPSAoKSA9PiBwcm9wcy5maWxsIHx8IHRoZW1lLmNvbG9ycy5pY29uLmVycm9yO1xuICByZXR1cm4gbWVtbygoKSA9PiBtZW1vKCgpID0+IHNpemUoKSA9PT0gXCJtXCIpKCkgPyAoKCkgPT4ge1xuICAgIHZhciBfZWwkID0gX3RtcGwkJG8oKSwgX2VsJDIgPSBfZWwkLmZpcnN0Q2hpbGQsIF9lbCQzID0gX2VsJDIubmV4dFNpYmxpbmc7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KChfcCQpID0+IHtcbiAgICAgIHZhciBfdiQgPSBwcm9wcy5jbGFzcywgX3YkMiA9IGZpbGwoKSwgX3YkMyA9IHRoZW1lLmNvbG9ycy5jb25zdGFudC53aGl0ZTtcbiAgICAgIF92JCAhPT0gX3AkLmUgJiYgc2V0QXR0cmlidXRlKF9lbCQsIFwiY2xhc3NcIiwgX3AkLmUgPSBfdiQpO1xuICAgICAgX3YkMiAhPT0gX3AkLnQgJiYgc2V0QXR0cmlidXRlKF9lbCQyLCBcImZpbGxcIiwgX3AkLnQgPSBfdiQyKTtcbiAgICAgIF92JDMgIT09IF9wJC5hICYmIHNldEF0dHJpYnV0ZShfZWwkMywgXCJmaWxsXCIsIF9wJC5hID0gX3YkMyk7XG4gICAgICByZXR1cm4gX3AkO1xuICAgIH0sIHtcbiAgICAgIGU6IHZvaWQgMCxcbiAgICAgIHQ6IHZvaWQgMCxcbiAgICAgIGE6IHZvaWQgMFxuICAgIH0pO1xuICAgIHJldHVybiBfZWwkO1xuICB9KSgpIDogbWVtbygoKSA9PiBzaXplKCkgPT09IFwic1wiKSgpID8gKCgpID0+IHtcbiAgICB2YXIgX2VsJDQgPSBfdG1wbCQyJDMoKSwgX2VsJDUgPSBfZWwkNC5maXJzdENoaWxkLCBfZWwkNiA9IF9lbCQ1Lm5leHRTaWJsaW5nO1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoX3AkKSA9PiB7XG4gICAgICB2YXIgX3YkNCA9IHByb3BzLmNsYXNzLCBfdiQ1ID0gZmlsbCgpLCBfdiQ2ID0gdGhlbWUuY29sb3JzLmNvbnN0YW50LndoaXRlO1xuICAgICAgX3YkNCAhPT0gX3AkLmUgJiYgc2V0QXR0cmlidXRlKF9lbCQ0LCBcImNsYXNzXCIsIF9wJC5lID0gX3YkNCk7XG4gICAgICBfdiQ1ICE9PSBfcCQudCAmJiBzZXRBdHRyaWJ1dGUoX2VsJDUsIFwiZmlsbFwiLCBfcCQudCA9IF92JDUpO1xuICAgICAgX3YkNiAhPT0gX3AkLmEgJiYgc2V0QXR0cmlidXRlKF9lbCQ2LCBcInN0cm9rZVwiLCBfcCQuYSA9IF92JDYpO1xuICAgICAgcmV0dXJuIF9wJDtcbiAgICB9LCB7XG4gICAgICBlOiB2b2lkIDAsXG4gICAgICB0OiB2b2lkIDAsXG4gICAgICBhOiB2b2lkIDBcbiAgICB9KTtcbiAgICByZXR1cm4gX2VsJDQ7XG4gIH0pKCkgOiAoKCkgPT4ge1xuICAgIHZhciBfZWwkNyA9IF90bXBsJDMkMSgpLCBfZWwkOCA9IF9lbCQ3LmZpcnN0Q2hpbGQsIF9lbCQ5ID0gX2VsJDgubmV4dFNpYmxpbmc7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KChfcCQpID0+IHtcbiAgICAgIHZhciBfdiQ3ID0gcHJvcHMuY2xhc3MsIF92JDggPSBmaWxsKCksIF92JDkgPSB0aGVtZS5jb2xvcnMuY29uc3RhbnQud2hpdGU7XG4gICAgICBfdiQ3ICE9PSBfcCQuZSAmJiBzZXRBdHRyaWJ1dGUoX2VsJDcsIFwiY2xhc3NcIiwgX3AkLmUgPSBfdiQ3KTtcbiAgICAgIF92JDggIT09IF9wJC50ICYmIHNldEF0dHJpYnV0ZShfZWwkOCwgXCJmaWxsXCIsIF9wJC50ID0gX3YkOCk7XG4gICAgICBfdiQ5ICE9PSBfcCQuYSAmJiBzZXRBdHRyaWJ1dGUoX2VsJDksIFwiZmlsbFwiLCBfcCQuYSA9IF92JDkpO1xuICAgICAgcmV0dXJuIF9wJDtcbiAgICB9LCB7XG4gICAgICBlOiB2b2lkIDAsXG4gICAgICB0OiB2b2lkIDAsXG4gICAgICBhOiB2b2lkIDBcbiAgICB9KTtcbiAgICByZXR1cm4gX2VsJDc7XG4gIH0pKCkpO1xufTtcbnZhciBfdG1wbCQkbiA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8c3ZnIHdpZHRoPTI0IGhlaWdodD0yNCB2aWV3Qm94PVwiMCAwIDI0IDI0XCJmaWxsPW5vbmUgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmc+PHBhdGggZD1cIk0xNS41NSA1Ljg1MTIzQzE4Ljk0NTkgNy44MTE4NCAyMC4xMDk0IDEyLjE1NDEgMTguMTQ4OCAxNS41NUMxNi4xODgyIDE4Ljk0NTkgMTEuODQ1OSAyMC4xMDk0IDguNDQ5OTggMTguMTQ4OEM4LjAxOTUyIDE3LjkwMDMgNy40NjkwOSAxOC4wNDc4IDcuMjIwNTYgMTguNDc4MkM2Ljk3MjAzIDE4LjkwODcgNy4xMTk1MiAxOS40NTkxIDcuNTQ5OTggMTkuNzA3NkMxMS44MDY4IDIyLjE2NTMgMTcuMjQ5OSAyMC43MDY4IDE5LjcwNzYgMTYuNDVDMjIuMTY1MyAxMi4xOTMyIDIwLjcwNjggNi43NTAwNSAxNi40NSA0LjI5MjM5QzEyLjE5MzIgMS44MzQ3MiA2Ljc1MDAzIDMuMjkzMjEgNC4yOTIzNiA3LjU1MDAxQzQuMDQzODMgNy45ODA0NyA0LjE5MTMyIDguNTMwOTEgNC42MjE3OCA4Ljc3OTQzQzUuMDUyMjQgOS4wMjc5NiA1LjYwMjY4IDguODgwNDggNS44NTEyIDguNDUwMDFDNy44MTE4MSA1LjA1NDEzIDEyLjE1NDEgMy44OTA2MiAxNS41NSA1Ljg1MTIzWlwiPmApLCBfdG1wbCQyJDIgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyB3aWR0aD00NCBoZWlnaHQ9NDQgdmlld0JveD1cIjAgMCA0NCA0NFwiZmlsbD1ub25lPjxwYXRoIGZpbGwtcnVsZT1ldmVub2RkIGNsaXAtcnVsZT1ldmVub2RkIGQ9XCJNMjIgMi45OTk1MUMxMS41MDY2IDIuOTk5NTEgMyAxMS41MDYxIDMgMjEuOTk5NUMzIDMyLjQ5MjkgMTEuNTA2NiA0MC45OTk1IDIyIDQwLjk5OTVDMjIuODI4NCA0MC45OTk1IDIzLjUgNDEuNjcxMSAyMy41IDQyLjQ5OTVDMjMuNSA0My4zMjc5IDIyLjgyODQgNDMuOTk5NSAyMiA0My45OTk1QzkuODQ5NzQgNDMuOTk5NSAwIDM0LjE0OTggMCAyMS45OTk1QzAgOS44NDkyNSA5Ljg0OTc0IC0wLjAwMDQ4ODI4MSAyMiAtMC4wMDA0ODgyODFDMzQuMTUwMyAtMC4wMDA0ODgyODEgNDQgOS44NDkyNSA0NCAyMS45OTk1QzQ0IDIyLjgyNzkgNDMuMzI4NCAyMy40OTk1IDQyLjUgMjMuNDk5NUM0MS42NzE2IDIzLjQ5OTUgNDEgMjIuODI3OSA0MSAyMS45OTk1QzQxIDExLjUwNjEgMzIuNDkzNCAyLjk5OTUxIDIyIDIuOTk5NTFaXCI+YCksIF90bXBsJDMgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB3aWR0aD03MiBoZWlnaHQ9NzIgdmlld0JveD1cIjAgMCA3MiA3MlwiZmlsbD1ub25lIHhtbG5zPWh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnPjxwYXRoIGQ9XCJNMjQgNTYuNzg0NkMzNS40NzkgNjMuNDEyIDUwLjE1NzIgNTkuNDc5IDU2Ljc4NDYgNDcuOTk5OUM2My40MTIgMzYuNTIwOSA1OS40NzkgMjEuODQyNyA0OCAxNS4yMTUzQzM2LjUyMSA4LjU4NzkxIDIxLjg0MjggMTIuNTIwOSAxNS4yMTU0IDIzLjk5OTlcInN0cm9rZS13aWR0aD00IHN0cm9rZS1saW5lY2FwPXJvdW5kIHN0cm9rZS1saW5lam9pbj1yb3VuZD5gKTtcbmNvbnN0IExvYWRlckljb24gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCBzaXplID0gKCkgPT4gcHJvcHMuc2l6ZSB8fCBcInhzXCI7XG4gIGNvbnN0IGZpbGwgPSAoKSA9PiBwcm9wcy5maWxsIHx8IHRoZW1lLmNvbG9ycy5pY29uLnRlcnRpYXJ5O1xuICBjb25zdCByb3RhdGVBbmltYXRpb24gPSBoYFxuICAgICAgICAwJSB7XG4gICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XG4gICAgICAgIH1cbiAgICAgICAgMTAwJSB7XG4gICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcbiAgICAgICAgfVxuICAgIGA7XG4gIGNvbnN0IHN2Z0NsYXNzID0gdWBcbiAgICAgICAgYW5pbWF0aW9uOiAke3JvdGF0ZUFuaW1hdGlvbn0gMXMgbGluZWFyIGluZmluaXRlO1xuICAgIGA7XG4gIHJldHVybiBtZW1vKCgpID0+IG1lbW8oKCkgPT4gc2l6ZSgpID09PSBcInhzXCIpKCkgPyAoKCkgPT4ge1xuICAgIHZhciBfZWwkID0gX3RtcGwkJG4oKSwgX2VsJDIgPSBfZWwkLmZpcnN0Q2hpbGQ7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KChfcCQpID0+IHtcbiAgICAgIHZhciBfdiQgPSBjbihzdmdDbGFzcywgcHJvcHMuY2xhc3MpLCBfdiQyID0gZmlsbCgpO1xuICAgICAgX3YkICE9PSBfcCQuZSAmJiBzZXRBdHRyaWJ1dGUoX2VsJCwgXCJjbGFzc1wiLCBfcCQuZSA9IF92JCk7XG4gICAgICBfdiQyICE9PSBfcCQudCAmJiBzZXRBdHRyaWJ1dGUoX2VsJDIsIFwiZmlsbFwiLCBfcCQudCA9IF92JDIpO1xuICAgICAgcmV0dXJuIF9wJDtcbiAgICB9LCB7XG4gICAgICBlOiB2b2lkIDAsXG4gICAgICB0OiB2b2lkIDBcbiAgICB9KTtcbiAgICByZXR1cm4gX2VsJDtcbiAgfSkoKSA6IG1lbW8oKCkgPT4gc2l6ZSgpID09PSBcInNcIikoKSA/ICgoKSA9PiB7XG4gICAgdmFyIF9lbCQzID0gX3RtcGwkMiQyKCksIF9lbCQ0ID0gX2VsJDMuZmlyc3RDaGlsZDtcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKF9wJCkgPT4ge1xuICAgICAgdmFyIF92JDMgPSBjbihzdmdDbGFzcywgcHJvcHMuY2xhc3MpLCBfdiQ0ID0gZmlsbCgpO1xuICAgICAgX3YkMyAhPT0gX3AkLmUgJiYgc2V0QXR0cmlidXRlKF9lbCQzLCBcImNsYXNzXCIsIF9wJC5lID0gX3YkMyk7XG4gICAgICBfdiQ0ICE9PSBfcCQudCAmJiBzZXRBdHRyaWJ1dGUoX2VsJDQsIFwiZmlsbFwiLCBfcCQudCA9IF92JDQpO1xuICAgICAgcmV0dXJuIF9wJDtcbiAgICB9LCB7XG4gICAgICBlOiB2b2lkIDAsXG4gICAgICB0OiB2b2lkIDBcbiAgICB9KTtcbiAgICByZXR1cm4gX2VsJDM7XG4gIH0pKCkgOiAoKCkgPT4ge1xuICAgIHZhciBfZWwkNSA9IF90bXBsJDMoKSwgX2VsJDYgPSBfZWwkNS5maXJzdENoaWxkO1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoX3AkKSA9PiB7XG4gICAgICB2YXIgX3YkNSA9IGNuKHN2Z0NsYXNzLCBwcm9wcy5jbGFzcyksIF92JDYgPSBmaWxsKCk7XG4gICAgICBfdiQ1ICE9PSBfcCQuZSAmJiBzZXRBdHRyaWJ1dGUoX2VsJDUsIFwiY2xhc3NcIiwgX3AkLmUgPSBfdiQ1KTtcbiAgICAgIF92JDYgIT09IF9wJC50ICYmIHNldEF0dHJpYnV0ZShfZWwkNiwgXCJzdHJva2VcIiwgX3AkLnQgPSBfdiQ2KTtcbiAgICAgIHJldHVybiBfcCQ7XG4gICAgfSwge1xuICAgICAgZTogdm9pZCAwLFxuICAgICAgdDogdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIF9lbCQ1O1xuICB9KSgpKTtcbn07XG52YXIgX3RtcGwkJG0gPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB3aWR0aD0xNTggaGVpZ2h0PTI4IHZpZXdCb3g9XCIwIDAgMTU4IDI4XCJmaWxsPW5vbmUgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmc+PHBhdGggZmlsbC1ydWxlPWV2ZW5vZGQgY2xpcC1ydWxlPWV2ZW5vZGQgZD1cIk0yOCAxNC4wMDFDMjggMjEuNzMzIDIxLjczMiAyOC4wMDEgMTQgMjguMDAxQzYuMjY4MDEgMjguMDAxIDAgMjEuNzMzIDAgMTQuMDAxQzAgNi4yNjg5OSA2LjI2ODAxIDAuMDAwOTc2NTYyIDE0IDAuMDAwOTc2NTYyQzIxLjczMiAwLjAwMDk3NjU2MiAyOCA2LjI2ODk5IDI4IDE0LjAwMVpNOS4yMTkzMSA4LjAwMDk4SDE4Ljc4MDFIMTguNzgxM0MyMC41MzggOC4wMDA5OCAyMS42NTIyIDkuODk5NjYgMjAuNzY5MSAxMS40MzAyTDE0Ljg2NzIgMjEuNjU3NkMxNC40ODIyIDIyLjMyNTQgMTMuNTE3MiAyMi4zMjU0IDEzLjEzMjIgMjEuNjU3Nkw3LjIzMTU4IDExLjQzMDJDNi4zNDcyMSA5Ljg5NzI2IDcuNDYxNCA4LjAwMDk4IDkuMjE5MzEgOC4wMDA5OFpNMTMuMTI2MiAxOC41ODgyVjkuNzQ4MDZIOS4yMTgxMUM4Ljc4OTc2IDkuNzQ4MDYgOC41MzcwOCAxMC4yMDI5IDguNzQxNjMgMTAuNTU3OEwxMS44NDIzIDE2LjEwMzVMMTMuMTI2MiAxOC41ODgyWk0xNi4xNTU5IDE2LjEwNDdMMTkuMjU1NCAxMC41NTY2QzE5LjQ1OTkgMTAuMjAxNyAxOS4yMDczIDkuNzQ2ODUgMTguNzc4OSA5Ljc0Njg1SDE0Ljg3MDlWMTguNTkwNkwxNi4xNTU5IDE2LjEwNDdaXCJmaWxsPSMwMDk4RUE+PC9wYXRoPjxwYXRoIGQ9XCJNMTguNzgwMiA4LjAwMDk4SDkuMjE5MzZDNy40NjE0NSA4LjAwMDk4IDYuMzQ3MjcgOS44OTcyNiA3LjIzMTY0IDExLjQzMDJMMTMuMTMyMiAyMS42NTc2QzEzLjUxNzMgMjIuMzI1NCAxNC40ODIzIDIyLjMyNTQgMTQuODY3MyAyMS42NTc2TDIwLjc2OTEgMTEuNDMwMkMyMS42NTIzIDkuODk5NjYgMjAuNTM4MSA4LjAwMDk4IDE4Ljc4MTQgOC4wMDA5OEgxOC43ODAyWk0xMy4xMjc0IDE4LjU5MDZMMTEuODQyNCAxNi4xMDM1TDguNzQxNjggMTAuNTU3OEM4LjUzNzE0IDEwLjIwMjkgOC43ODk4MSA5Ljc0ODA2IDkuMjE4MTYgOS43NDgwNkgxMy4xMjYyVjE4LjU5MThMMTMuMTI3NCAxOC41OTA2Wk0xOS4yNTU1IDEwLjU1NjZMMTYuMTU2IDE2LjEwNDdMMTQuODcwOSAxOC41OTA2VjkuNzQ2ODVIMTguNzc5QzE5LjIwNzMgOS43NDY4NSAxOS40NiAxMC4yMDE3IDE5LjI1NTUgMTAuNTU2NlpcImZpbGw9d2hpdGU+PC9wYXRoPjxwYXRoIGZpbGwtcnVsZT1ldmVub2RkIGNsaXAtcnVsZT1ldmVub2RkIGQ9XCJNNTEuNzQ4MyAyMi4xOTY3QzU1LjcxODIgMjIuMTk2NyA1OC45NjA5IDE4Ljk1NCA1OC45NjA5IDE0Ljk4NDFDNTguOTYwOSAxMS4wMTQyIDU1LjcxODIgNy43NzE0OCA1MS43NDgzIDcuNzcxNDhDNDcuNzU4OCA3Ljc3MTQ4IDQ0LjUzNTcgMTEuMDE0MiA0NC41MzU3IDE0Ljk4NDFDNDQuNTM1NyAxOC45NTQgNDcuNzU4OCAyMi4xOTY3IDUxLjc0ODMgMjIuMTk2N1pNNTEuNzQ4MyAxOS4xNzAyQzQ5LjQ2ODYgMTkuMTcwMiA0Ny42ODAyIDE3LjI0NDIgNDcuNjgwMiAxNC45ODQxQzQ3LjY4MDIgMTIuNzI0IDQ5LjQ2ODYgMTAuNzk4IDUxLjc0ODMgMTAuNzk4QzU0LjAwODQgMTAuNzk4IDU1Ljc5NjggMTIuNzI0IDU1Ljc5NjggMTQuOTg0MUM1NS43OTY4IDE3LjI0NDIgNTQuMDA4NCAxOS4xNzAyIDUxLjc0ODMgMTkuMTcwMlpNMzcuMDY5OCAyMS45NjA5SDQwLjIxNDJWMTAuOTk0Nkg0NC4yODQzVjguMDA3MzJIMzNWMTAuOTk0NkgzNy4wNjk4VjIxLjk2MDlaTTY5LjkzNzkgOC4wMDczMkg3My4wODIzVjIxLjk2MDlINzAuMzg5OUw2My41OSAxMy4zMzMzVjIxLjk2MDlINjAuNDY1MlY4LjAwNzMySDYzLjE1NzZMNjkuOTM3OSAxNi42MTUzVjguMDA3MzJaTTc5LjIyNTkgMTQuOTg4N0M3OS4yMjU5IDEwLjkyMDIgODIuMzUxIDcuNzc1MzkgODYuNDk4MiA3Ljc3NTM5Qzg5Ljg1OTIgNy43NzUzOSA5Mi41NTE5IDkuOTU3MDkgOTMuMjIwMiAxMi42ODkxSDkwLjc0MzdDOTAuMTU0IDExLjA5NzEgODguNDYzNyA5Ljk5NjQgODYuNDk4MiA5Ljk5NjRDODMuNTg5MyA5Ljk5NjQgODEuNTQ1MiAxMi4xNzgxIDgxLjU0NTIgMTQuOTg4N0M4MS41NDUyIDE3Ljc5OTQgODMuNTg5MyAxOS45ODExIDg2LjQ5ODIgMTkuOTgxMUM4OC40NjM3IDE5Ljk4MTEgOTAuMTU0IDE4Ljg4MDQgOTAuNzQzNyAxNy4yODg0SDkzLjIyMDJDOTIuNTUxOSAyMC4wMjA0IDg5Ljg1OTIgMjIuMjAyMSA4Ni40OTgyIDIyLjIwMjFDODIuMzUxIDIyLjIwMjEgNzkuMjI1OSAxOS4wNTczIDc5LjIyNTkgMTQuOTg4N1pNMTA0LjU4NCAxNy4wNTI1QzEwNC41ODQgMTkuOTAyNSAxMDIuMzQzIDIyLjE2MjggOTkuNDM0MiAyMi4xNjI4Qzk2LjUyNTMgMjIuMTYyOCA5NC4yODQ2IDE5LjkwMjUgOTQuMjg0NiAxNy4wNTI1Qzk0LjI4NDYgMTQuMjAyNSA5Ni41MjUzIDExLjk0MjIgOTkuNDM0MiAxMS45NDIyQzEwMi4zNDMgMTEuOTQyMiAxMDQuNTg0IDE0LjIwMjUgMTA0LjU4NCAxNy4wNTI1Wk05Ni40NjYzIDE3LjA1MjVDOTYuNDY2MyAxOC44MDE4IDk3LjY4NDkgMjAuMTU4IDk5LjQzNDIgMjAuMTU4QzEwMS4xNjQgMjAuMTU4IDEwMi4zODIgMTguODAxOCAxMDIuMzgyIDE3LjA1MjVDMTAyLjM4MiAxNS4zMDMyIDEwMS4xNjQgMTMuOTQ3IDk5LjQzNDIgMTMuOTQ3Qzk3LjY4NDkgMTMuOTQ3IDk2LjQ2NjMgMTUuMzAzMiA5Ni40NjYzIDE3LjA1MjVaTTEwOC42MjYgMTIuMTM4OEgxMDYuNDYzVjIxLjk2NjJIMTA4LjYyNlYxNy4xMzExQzEwOC42MjYgMTUuMDI4MSAxMDkuNzI2IDEzLjkwNzcgMTExLjE2MSAxMy45MDc3QzExMi40MTkgMTMuOTA3NyAxMTMuMjA1IDE0Ljg1MTIgMTEzLjIwNSAxNi40MDM5VjIxLjk2NjJIMTE1LjM2N1YxNi4wNTAxQzExNS4zNjcgMTMuNTUzOSAxMTMuODkzIDExLjk0MjIgMTExLjYxMyAxMS45NDIyQzExMC4zMzUgMTEuOTQyMiAxMDkuMjE1IDEyLjQ5MjYgMTA4LjYyNiAxMy40NzUzVjEyLjEzODhaTTExNy44MzkgMTIuMTM4OEgxMjAuMDAxVjEzLjQ3NTNDMTIwLjU5IDEyLjQ5MjYgMTIxLjcxMSAxMS45NDIyIDEyMi45ODggMTEuOTQyMkMxMjUuMjY4IDExLjk0MjIgMTI2Ljc0MiAxMy41NTM5IDEyNi43NDIgMTYuMDUwMVYyMS45NjYySDEyNC41OFYxNi40MDM5QzEyNC41OCAxNC44NTEyIDEyMy43OTQgMTMuOTA3NyAxMjIuNTM2IDEzLjkwNzdDMTIxLjEwMSAxMy45MDc3IDEyMC4wMDEgMTUuMDI4MSAxMjAuMDAxIDE3LjEzMTFWMjEuOTY2MkgxMTcuODM5VjEyLjEzODhaTTEzMy41NTggMjIuMTYyOEMxMzYuMDU0IDIyLjE2MjggMTM3LjgyMyAyMC43MjggMTM4LjM3MyAxOC44ODA0SDEzNi4xMTNDMTM1LjY2MSAxOS44MjM4IDEzNC43MTcgMjAuMjU2MyAxMzMuNjM2IDIwLjI1NjNDMTMxLjg4NyAyMC4yNTYzIDEzMC43NDcgMTkuMDc3IDEzMC42NjggMTcuNTgzMkgxMzguNDkxQzEzOC42ODggMTQuMjQxOSAxMzYuNTg1IDExLjk0MjIgMTMzLjU3NyAxMS45NDIyQzEzMC41NTEgMTEuOTQyMiAxMjguNTI2IDE0LjE0MzYgMTI4LjUyNiAxNy4wNTI1QzEyOC41MjYgMjAuMDAwNyAxMzAuNjI5IDIyLjE2MjggMTMzLjU1OCAyMi4xNjI4Wk0xMzAuNzQ3IDE2LjA1MDFDMTMxLjA0MiAxNC41MzY3IDEzMi4xNjIgMTMuNzUwNSAxMzMuNTE4IDEzLjc1MDVDMTM0LjcxNyAxMy43NTA1IDEzNS44MzggMTQuNDU4MSAxMzYuMTcyIDE2LjA1MDFIMTMwLjc0N1pNMTQ5Ljg1MSAxOC4zNjk0QzE0OS4zMiAyMC41NTExIDE0Ny40NTMgMjIuMTYyOCAxNDQuODU5IDIyLjE2MjhDMTQxLjg3MSAyMi4xNjI4IDEzOS43MDkgMTkuODgyOCAxMzkuNzA5IDE3LjA1MjVDMTM5LjcwOSAxNC4yMjIyIDE0MS44NzEgMTEuOTQyMiAxNDQuODU5IDExLjk0MjJDMTQ3LjQ1MyAxMS45NDIyIDE0OS4zMiAxMy41NTM5IDE0OS44NTEgMTUuNzM1NkgxNDcuNTcxQzE0Ny4xNzggMTQuNjc0MyAxNDYuMjE1IDEzLjkwNzcgMTQ0Ljg1OSAxMy45MDc3QzE0My4xMDkgMTMuOTA3NyAxNDEuOTEgMTUuMjI0NiAxNDEuOTEgMTcuMDUyNUMxNDEuOTEgMTguODgwNCAxNDMuMTA5IDIwLjE5NzMgMTQ0Ljg1OSAyMC4xOTczQzE0Ni4yMTUgMjAuMTk3MyAxNDcuMTc4IDE5LjQzMDcgMTQ3LjU3MSAxOC4zNjk0SDE0OS44NTFaTTE1NS43NSAyMi4wNjQ1QzE1Ni40MTggMjIuMDY0NSAxNTYuOTI5IDIxLjk4NTkgMTU3LjM2MiAyMS44NDgzVjE5LjkyMjFDMTU3LjA0NyAyMC4wNDAxIDE1Ni42MTUgMjAuMTE4NyAxNTYuMjAyIDIwLjExODdDMTU1LjA4MiAyMC4xMTg3IDE1NC41NTEgMTkuNjY2NiAxNTQuNTUxIDE4LjQ0OFYxNC4wNjVIMTU3LjM2MlYxMi4xMzg4SDE1NC41NTFWOS40MDY3NUgxNTIuMzg5VjEyLjEzODhIMTUwLjM0NVYxNC4wNjVIMTUyLjM4OVYxOC44MDE4QzE1Mi4zODkgMjEuMDIyOCAxNTMuODYzIDIyLjA2NDUgMTU1Ljc1IDIyLjA2NDVaXCI+YCk7XG5jb25zdCBUb25Db25uZWN0QnJhbmQgPSAoKSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3QgZmlsbCA9ICgpID0+IHRoZW1lLnRoZW1lID09PSBUSEVNRS5EQVJLID8gdGhlbWUuY29sb3JzLmNvbnN0YW50LndoaXRlIDogdGhlbWUuY29sb3JzLmNvbnN0YW50LmJsYWNrO1xuICByZXR1cm4gKCgpID0+IHtcbiAgICB2YXIgX2VsJCA9IF90bXBsJCRtKCksIF9lbCQyID0gX2VsJC5maXJzdENoaWxkLCBfZWwkMyA9IF9lbCQyLm5leHRTaWJsaW5nLCBfZWwkNCA9IF9lbCQzLm5leHRTaWJsaW5nO1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoKSA9PiBzZXRBdHRyaWJ1dGUoX2VsJDQsIFwiZmlsbFwiLCBmaWxsKCkpKTtcbiAgICByZXR1cm4gX2VsJDtcbiAgfSkoKTtcbn07XG52YXIgX3RtcGwkJGwgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyB3aWR0aD0xNiBoZWlnaHQ9MTYgdmlld0JveD1cIjAgMCAxNiAxNlwiZmlsbD1ub25lPjxwYXRoIGZpbGwtcnVsZT1ldmVub2RkIGNsaXAtcnVsZT1ldmVub2RkIGQ9XCJNNS41NjYwOCA0LjQyNTg0QzUuODI1MjcgMy4zMjE1OCA2LjgxNzYgMi41IDguMDAwMDEgMi41QzkuMzgwNzIgMi41IDEwLjUgMy42MTkyOSAxMC41IDVDMTAuNSA1LjYzMDI2IDEwLjMzOTEgNi4wMzg2IDEwLjEyNjQgNi4zNDQ1NUM5LjkwMDE4IDYuNjY5OTMgOS41ODU2MSA2LjkyNDc4IDkuMTg4NjQgNy4yMDg3N0M5LjEyNTc5IDcuMjUzNzIgOS4wNTg3MyA3LjMwMDI1IDguOTg4NyA3LjM0ODgzQzguMjczOTIgNy44NDQ3MiA3LjI1MDAxIDguNTU1MDcgNy4yNTAwMSAxMFYxMC4yNUM3LjI1MDAxIDEwLjY2NDIgNy41ODU4IDExIDguMDAwMDEgMTFDOC40MTQyMiAxMSA4Ljc1MDAxIDEwLjY2NDIgOC43NTAwMSAxMC4yNVYxMEM4Ljc1MDAxIDkuMzY1MDIgOS4xMDc3NyA5LjEwOTYgOS45NDU1NCA4LjUxMTQ5TDEwLjA2MTQgOC40Mjg3M0MxMC40NzY5IDguMTMxNDcgMTAuOTc0OCA3Ljc1MTk0IDExLjM1OCA3LjIwMDc2QzExLjc1NDcgNi42MzAxNSAxMiA1LjkxOTczIDEyIDVDMTIgMi43OTA4NiAxMC4yMDkxIDEgOC4wMDAwMSAxQzYuMTA1NjQgMSA0LjUyMDUgMi4zMTYxNSA0LjEwNTc3IDQuMDgzMDhDNC4wMTExMiA0LjQ4NjM0IDQuMjYxMjkgNC44ODk5NyA0LjY2NDU0IDQuOTg0NjJDNS4wNjc4IDUuMDc5MjcgNS40NzE0MyA0LjgyOTEgNS41NjYwOCA0LjQyNTg0Wk04LjAwMDAxIDE1QzguNjA3NTIgMTUgOS4xMDAwMSAxNC41MDc1IDkuMTAwMDEgMTMuOUM5LjEwMDAxIDEzLjI5MjUgOC42MDc1MiAxMi44IDguMDAwMDEgMTIuOEM3LjM5MjQ5IDEyLjggNi45MDAwMSAxMy4yOTI1IDYuOTAwMDEgMTMuOUM2LjkwMDAxIDE0LjUwNzUgNy4zOTI0OSAxNSA4LjAwMDAxIDE1WlwiPmApO1xuY29uc3QgUXVlc3Rpb25JY29uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3QgZmlsbCA9ICgpID0+IHByb3BzLmZpbGwgfHwgdGhlbWUuY29sb3JzLmljb24uc2Vjb25kYXJ5O1xuICByZXR1cm4gKCgpID0+IHtcbiAgICB2YXIgX2VsJCA9IF90bXBsJCRsKCksIF9lbCQyID0gX2VsJC5maXJzdENoaWxkO1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoKSA9PiBzZXRBdHRyaWJ1dGUoX2VsJDIsIFwiZmlsbFwiLCBmaWxsKCkpKTtcbiAgICByZXR1cm4gX2VsJDtcbiAgfSkoKTtcbn07XG52YXIgX3RtcGwkJGsgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyB3aWR0aD0xNiBoZWlnaHQ9MTYgdmlld0JveD1cIjAgMCAxNiAxNlwiZmlsbD1ub25lPjxwYXRoIGZpbGwtcnVsZT1ldmVub2RkIGNsaXAtcnVsZT1ldmVub2RkIGQ9XCJNOS45ODE1NiA4Ljc1QzkuODQ4NTQgMTEuNDMyOCA5LjAxMjA2IDEzLjUgOCAxMy41QzYuOTg3OTQgMTMuNSA2LjE1MTQ2IDExLjQzMjggNi4wMTg0NCA4Ljc1SDkuOTgxNTZaTTExLjQ4MzIgOC43NUMxMS40MjE3IDEwLjExNTUgMTEuMTkyOSAxMS4zODY5IDEwLjgyMzkgMTIuNDAxN0MxMC43NzM0IDEyLjU0MDUgMTAuNzE4OCAxMi42Nzg5IDEwLjY1OTUgMTIuODE1NEMxMi4xNDU0IDExLjk5MyAxMy4yMTAzIDEwLjUwMjkgMTMuNDQ5MyA4Ljc1SDExLjQ4MzJaTTEzLjQ0OTMgNy4yNUgxMS40ODMyQzExLjQyMTcgNS44ODQ1MyAxMS4xOTI5IDQuNjEzMTQgMTAuODIzOSAzLjU5ODNDMTAuNzczNCAzLjQ1OTUgMTAuNzE4OCAzLjMyMTExIDEwLjY1OTUgMy4xODQ1OUMxMi4xNDU0IDQuMDA2OTcgMTMuMjEwMyA1LjQ5NzA5IDEzLjQ0OTMgNy4yNVpNOS45ODE1NiA3LjI1SDYuMDE4NDRDNi4xNTE0NCA0LjU2NzY0IDYuOTg3NjkgMi41MDA2MiA3Ljk5OTU1IDIuNUg4QzkuMDEyMDYgMi41IDkuODQ4NTQgNC41NjcyNCA5Ljk4MTU2IDcuMjVaTTQuNTE2NzggNy4yNUM0LjU3ODI2IDUuODg0NTMgNC44MDcwNiA0LjYxMzE0IDUuMTc2MSAzLjU5ODNDNS4yMjY1NyAzLjQ1OTUgNS4yODEyNCAzLjMyMTExIDUuMzQwNSAzLjE4NDU5QzMuODU0NjMgNC4wMDY5NyAyLjc4OTcyIDUuNDk3MDkgMi41NTA3MSA3LjI1SDQuNTE2NzhaTTIuNTUwNzEgOC43NUMyLjc4OTcyIDEwLjUwMjkgMy44NTQ2MyAxMS45OTMgNS4zNDA1IDEyLjgxNTRDNS4yODEyNCAxMi42Nzg5IDUuMjI2NTcgMTIuNTQwNSA1LjE3NjEgMTIuNDAxN0M0LjgwNzA2IDExLjM4NjkgNC41NzgyNiAxMC4xMTU1IDQuNTE2NzggOC43NUgyLjU1MDcxWk0xNSA4QzE1IDExLjg2NiAxMS44NjYgMTUgOCAxNUM0LjEzNDAxIDE1IDEgMTEuODY2IDEgOEMxIDQuMTM0MDEgNC4xMzQwMSAxIDggMUMxMS44NjYgMSAxNSA0LjEzNDAxIDE1IDhaXCI+YCk7XG5jb25zdCBCcm93c2VySWNvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IGZpbGwgPSAoKSA9PiBwcm9wcy5maWxsIHx8IHRoZW1lLmNvbG9ycy5pY29uLnByaW1hcnk7XG4gIHJldHVybiAoKCkgPT4ge1xuICAgIHZhciBfZWwkID0gX3RtcGwkJGsoKSwgX2VsJDIgPSBfZWwkLmZpcnN0Q2hpbGQ7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KCgpID0+IHNldEF0dHJpYnV0ZShfZWwkMiwgXCJmaWxsXCIsIGZpbGwoKSkpO1xuICAgIHJldHVybiBfZWwkO1xuICB9KSgpO1xufTtcbnZhciBfdG1wbCQkaiA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8c3ZnIHhtbG5zPWh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIHdpZHRoPTE2IGhlaWdodD0xNiB2aWV3Qm94PVwiMCAwIDE2IDE2XCJmaWxsPW5vbmU+PHBhdGggZmlsbC1ydWxlPWV2ZW5vZGQgY2xpcC1ydWxlPWV2ZW5vZGQgZD1cIk0yLjUgNC44QzIuNSAzLjExOTg0IDIuNSAyLjI3OTc2IDIuODI2OTggMS42MzgwM0MzLjExNDYgMS4wNzM1NCAzLjU3MzU0IDAuNjE0NjAxIDQuMTM4MDMgMC4zMjY5OEM0Ljc3OTc2IDAgNS42MTk4NCAwIDcuMyAwSDguN0MxMC4zODAyIDAgMTEuMjIwMiAwIDExLjg2MiAwLjMyNjk4QzEyLjQyNjUgMC42MTQ2MDEgMTIuODg1NCAxLjA3MzU0IDEzLjE3MyAxLjYzODAzQzEzLjUgMi4yNzk3NiAxMy41IDMuMTE5ODQgMTMuNSA0LjhWMTEuMkMxMy41IDEyLjg4MDIgMTMuNSAxMy43MjAyIDEzLjE3MyAxNC4zNjJDMTIuODg1NCAxNC45MjY1IDEyLjQyNjUgMTUuMzg1NCAxMS44NjIgMTUuNjczQzExLjIyMDIgMTYgMTAuMzgwMiAxNiA4LjcgMTZINy4zQzUuNjE5ODQgMTYgNC43Nzk3NiAxNiA0LjEzODAzIDE1LjY3M0MzLjU3MzU0IDE1LjM4NTQgMy4xMTQ2IDE0LjkyNjUgMi44MjY5OCAxNC4zNjJDMi41IDEzLjcyMDIgMi41IDEyLjg4MDIgMi41IDExLjJWNC44Wk00IDMuOUM0IDMuMDU5OTIgNCAyLjYzOTg4IDQuMTYzNDkgMi4zMTkwMUM0LjMwNzMgMi4wMzY3NyA0LjUzNjc3IDEuODA3MyA0LjgxOTAxIDEuNjYzNDlDNS4xMzk4OCAxLjUgNS41NTk5MiAxLjUgNi40IDEuNUg5LjZDMTAuNDQwMSAxLjUgMTAuODYwMSAxLjUgMTEuMTgxIDEuNjYzNDlDMTEuNDYzMiAxLjgwNzMgMTEuNjkyNyAyLjAzNjc3IDExLjgzNjUgMi4zMTkwMUMxMiAyLjYzOTg4IDEyIDMuMDU5OTIgMTIgMy45VjEyLjFDMTIgMTIuOTQwMSAxMiAxMy4zNjAxIDExLjgzNjUgMTMuNjgxQzExLjY5MjcgMTMuOTYzMiAxMS40NjMyIDE0LjE5MjcgMTEuMTgxIDE0LjMzNjVDMTAuODYwMSAxNC41IDEwLjQ0MDEgMTQuNSA5LjYgMTQuNUg2LjRDNS41NTk5MiAxNC41IDUuMTM5ODggMTQuNSA0LjgxOTAxIDE0LjMzNjVDNC41MzY3NyAxNC4xOTI3IDQuMzA3MyAxMy45NjMyIDQuMTYzNDkgMTMuNjgxQzQgMTMuMzYwMSA0IDEyLjk0MDEgNCAxMi4xVjMuOVpNNyAyLjVDNi41ODU3OSAyLjUgNi4yNSAyLjgzNTc5IDYuMjUgMy4yNUM2LjI1IDMuNjY0MjEgNi41ODU3OSA0IDcgNEg5QzkuNDE0MjEgNCA5Ljc1IDMuNjY0MjEgOS43NSAzLjI1QzkuNzUgMi44MzU3OSA5LjQxNDIxIDIuNSA5IDIuNUg3WlwiPmApO1xuY29uc3QgTW9iaWxlSWNvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IGZpbGwgPSAoKSA9PiBwcm9wcy5maWxsIHx8IHRoZW1lLmNvbG9ycy5pY29uLnByaW1hcnk7XG4gIHJldHVybiAoKCkgPT4ge1xuICAgIHZhciBfZWwkID0gX3RtcGwkJGooKSwgX2VsJDIgPSBfZWwkLmZpcnN0Q2hpbGQ7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KCgpID0+IHNldEF0dHJpYnV0ZShfZWwkMiwgXCJmaWxsXCIsIGZpbGwoKSkpO1xuICAgIHJldHVybiBfZWwkO1xuICB9KSgpO1xufTtcbnZhciBfdG1wbCQkaSA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8c3ZnIHhtbG5zPWh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIHdpZHRoPTE2IGhlaWdodD0xNiB2aWV3Qm94PVwiMCAwIDE2IDE2XCJmaWxsPW5vbmU+PHBhdGggZmlsbC1ydWxlPWV2ZW5vZGQgY2xpcC1ydWxlPWV2ZW5vZGQgZD1cIk0xLjUgNi44QzEuNSA1LjExOTg0IDEuNSA0LjI3OTc2IDEuODI2OTggMy42MzgwM0MyLjExNDYgMy4wNzM1NCAyLjU3MzU0IDIuNjE0NiAzLjEzODAzIDIuMzI2OThDMy43Nzk3NiAyIDQuNjE5ODQgMiA2LjMgMkg5LjdDMTEuMzgwMiAyIDEyLjIyMDIgMiAxMi44NjIgMi4zMjY5OEMxMy40MjY1IDIuNjE0NiAxMy44ODU0IDMuMDczNTQgMTQuMTczIDMuNjM4MDNDMTQuNSA0LjI3OTc2IDE0LjUgNS4xMTk4NCAxNC41IDYuOFYxMS41SDE1LjI1QzE1LjY2NDIgMTEuNSAxNiAxMS44MzU4IDE2IDEyLjI1QzE2IDEyLjY2NDIgMTUuNjY0MiAxMyAxNS4yNSAxM0gwLjc1QzAuMzM1Nzg2IDEzIDAgMTIuNjY0MiAwIDEyLjI1QzAgMTEuODM1OCAwLjMzNTc4NiAxMS41IDAuNzUgMTEuNUgxLjVWNi44Wk0zIDExLjVIMTNWNS45QzEzIDUuMDU5OTIgMTMgNC42Mzk4OCAxMi44MzY1IDQuMzE5MDFDMTIuNjkyNyA0LjAzNjc3IDEyLjQ2MzIgMy44MDczIDEyLjE4MSAzLjY2MzQ5QzExLjg2MDEgMy41IDExLjQ0MDEgMy41IDEwLjYgMy41SDUuNEM0LjU1OTkyIDMuNSA0LjEzOTg4IDMuNSAzLjgxOTAxIDMuNjYzNDlDMy41MzY3NyAzLjgwNzMgMy4zMDczIDQuMDM2NzcgMy4xNjM0OSA0LjMxOTAxQzMgNC42Mzk4OCAzIDUuMDU5OTIgMyA1LjlWMTEuNVpcIj5gKTtcbmNvbnN0IERlc2t0b3BJY29uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3QgZmlsbCA9ICgpID0+IHByb3BzLmZpbGwgfHwgdGhlbWUuY29sb3JzLmljb24ucHJpbWFyeTtcbiAgcmV0dXJuICgoKSA9PiB7XG4gICAgdmFyIF9lbCQgPSBfdG1wbCQkaSgpLCBfZWwkMiA9IF9lbCQuZmlyc3RDaGlsZDtcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKCkgPT4gc2V0QXR0cmlidXRlKF9lbCQyLCBcImZpbGxcIiwgZmlsbCgpKSk7XG4gICAgcmV0dXJuIF9lbCQ7XG4gIH0pKCk7XG59O1xudmFyIF90bXBsJCRoID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcgd2lkdGg9MTcgaGVpZ2h0PTE2IHZpZXdCb3g9XCIwIDAgMTcgMTZcImZpbGw9bm9uZT48ZyBjbGlwLXBhdGg9dXJsKCNjbGlwMF8zNjc2XzE2MDMpPjxwYXRoIGZpbGwtcnVsZT1ldmVub2RkIGNsaXAtcnVsZT1ldmVub2RkIGQ9XCJNMTUuNSAxLjI1MDQ5QzE1LjUgMC44MzYyNzUgMTUuMTY0MiAwLjUwMDQ4OCAxNC43NSAwLjUwMDQ4OEMxNC4zMzU4IDAuNTAwNDg4IDE0IDAuODM2Mjc1IDE0IDEuMjUwNDlWMy42NzAxMkMxMi43MTg3IDIuMDQ0ODcgMTAuNzMxOCAxLjAwMDQ5IDguNSAxLjAwMDQ5QzQuNjM0MDEgMS4wMDA0OSAxLjUgNC4xMzQ1IDEuNSA4LjAwMDQ5QzEuNSAxMS44NjY1IDQuNjM0MDEgMTUuMDAwNSA4LjUgMTUuMDAwNUMxMS42ODQ0IDE1LjAwMDUgMTQuMzcwMyAxMi44NzQ4IDE1LjIxOTkgOS45NjY2MUMxNS4zMzYxIDkuNTY5MDIgMTUuMTA3OSA5LjE1MjU0IDE0LjcxMDMgOS4wMzYzOEMxNC4zMTI3IDguOTIwMjMgMTMuODk2MiA5LjE0ODM4IDEzLjc4MDEgOS41NDU5N0MxMy4xMTIzIDExLjgzMTkgMTEgMTMuNTAwNSA4LjUgMTMuNTAwNUM1LjQ2MjQzIDEzLjUwMDUgMyAxMS4wMzgxIDMgOC4wMDA0OUMzIDQuOTYyOTIgNS40NjI0MyAyLjUwMDQ5IDguNSAyLjUwMDQ5QzEwLjMyMSAyLjUwMDQ5IDExLjkzNjMgMy4zODU1IDEyLjkzNzcgNC43NTA0OUgxMC41QzEwLjA4NTggNC43NTA0OSA5Ljc1IDUuMDg2MjcgOS43NSA1LjUwMDQ5QzkuNzUgNS45MTQ3IDEwLjA4NTggNi4yNTA0OSAxMC41IDYuMjUwNDlIMTQuNzVDMTUuMTY0MiA2LjI1MDQ5IDE1LjUgNS45MTQ3IDE1LjUgNS41MDA0OVYxLjI1MDQ5WlwiPjwvcGF0aD48L2c+PGRlZnM+PGNsaXBQYXRoIGlkPWNsaXAwXzM2NzZfMTYwMz48cmVjdCB3aWR0aD0xNiBoZWlnaHQ9MTYgZmlsbD13aGl0ZSB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMC41IDAuMDAwNDg4MjgxKVwiPmApO1xuY29uc3QgUmV0cnlJY29uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3QgZmlsbCA9ICgpID0+IHByb3BzLmZpbGwgfHwgdGhlbWUuY29sb3JzLmFjY2VudDtcbiAgcmV0dXJuICgoKSA9PiB7XG4gICAgdmFyIF9lbCQgPSBfdG1wbCQkaCgpLCBfZWwkMiA9IF9lbCQuZmlyc3RDaGlsZCwgX2VsJDMgPSBfZWwkMi5maXJzdENoaWxkO1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoKSA9PiBzZXRBdHRyaWJ1dGUoX2VsJDMsIFwiZmlsbFwiLCBmaWxsKCkpKTtcbiAgICByZXR1cm4gX2VsJDtcbiAgfSkoKTtcbn07XG52YXIgX3RtcGwkJGcgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyB3aWR0aD0xNiBoZWlnaHQ9MTYgdmlld0JveD1cIjAgMCAxNiAxNlwiZmlsbD1ub25lPjxwYXRoIGZpbGwtcnVsZT1ldmVub2RkIGNsaXAtcnVsZT1ldmVub2RkIGQ9XCJNMTMgNC4wNjExOVY2Ljc1MDUzQzEzIDcuMTY0NzQgMTMuMzM1OCA3LjUwMDUzIDEzLjc1IDcuNTAwNTNDMTQuMTY0MiA3LjUwMDUzIDE0LjUgNy4xNjQ3NCAxNC41IDYuNzUwNTNWMi43NTA1M0wxNC41IDIuNzI4MDdDMTQuNTAwMSAyLjYzMTkxIDE0LjUwMDMgMi40OTYyNyAxNC40ODQyIDIuMzc2MjdDMTQuNDYzOCAyLjIyNTAzIDE0LjQwNjMgMS45OTI2MSAxNC4yMDcxIDEuNzkzNDJDMTQuMDA3OSAxLjU5NDIzIDEzLjc3NTUgMS41MzY3IDEzLjYyNDMgMS41MTYzN0MxMy41MDQzIDEuNTAwMjMgMTMuMzY4NiAxLjUwMDM5IDEzLjI3MjUgMS41MDA1MUwxMy4yNSAxLjUwMDUzSDkuMjVDOC44MzU3OSAxLjUwMDUzIDguNSAxLjgzNjMxIDguNSAyLjI1MDUzQzguNSAyLjY2NDc0IDguODM1NzkgMy4wMDA1MyA5LjI1IDMuMDAwNTNIMTEuOTM5M0w3LjIxOTY3IDcuNzIwMkM2LjkyNjc4IDguMDEzMDkgNi45MjY3OCA4LjQ4Nzk2IDcuMjE5NjcgOC43ODA4NkM3LjUxMjU2IDkuMDczNzUgNy45ODc0NCA5LjA3Mzc1IDguMjgwMzMgOC43ODA4NkwxMyA0LjA2MTE5Wk01Ljg1IDEuNTAwNTNINS44MTkwM0g1LjgxODk5QzUuMjE1MjggMS41MDA1MiA0LjcxNzAyIDEuNTAwNTEgNC4zMTExMyAxLjUzMzY3QzMuODg5NTYgMS41NjgxMiAzLjUwMjAzIDEuNjQyMDQgMy4xMzgwMyAxLjgyNzUxQzIuNTczNTQgMi4xMTUxMyAyLjExNDYgMi41NzQwNyAxLjgyNjk4IDMuMTM4NTZDMS42NDE1MSAzLjUwMjU2IDEuNTY3NTkgMy44OTAwOSAxLjUzMzE1IDQuMzExNjZDMS40OTk5OCA0LjcxNzU1IDEuNDk5OTkgNS4yMTU4MSAxLjUgNS44MTk1M1Y1LjgxOTU1VjUuODUwNTNWMTAuMTUwNVYxMC4xODE1VjEwLjE4MTVDMS40OTk5OSAxMC43ODUyIDEuNDk5OTggMTEuMjgzNSAxLjUzMzE1IDExLjY4OTRDMS41Njc1OSAxMi4xMTEgMS42NDE1MSAxMi40OTg1IDEuODI2OTggMTIuODYyNUMyLjExNDYgMTMuNDI3IDIuNTczNTQgMTMuODg1OSAzLjEzODAzIDE0LjE3MzVDMy41MDIwMyAxNC4zNTkgMy44ODk1NiAxNC40MzI5IDQuMzExMTMgMTQuNDY3NEM0LjcxNzAyIDE0LjUwMDUgNS4yMTUyNyAxNC41MDA1IDUuODE4OTcgMTQuNTAwNUg1LjgxOTAxSDUuODVIMTAuMTVIMTAuMTgxSDEwLjE4MUMxMC43ODQ3IDE0LjUwMDUgMTEuMjgzIDE0LjUwMDUgMTEuNjg4OSAxNC40Njc0QzEyLjExMDQgMTQuNDMyOSAxMi40OTggMTQuMzU5IDEyLjg2MiAxNC4xNzM1QzEzLjQyNjUgMTMuODg1OSAxMy44ODU0IDEzLjQyNyAxNC4xNzMgMTIuODYyNUMxNC4zNTg1IDEyLjQ5ODUgMTQuNDMyNCAxMi4xMTEgMTQuNDY2OSAxMS42ODk0QzE0LjUgMTEuMjgzNSAxNC41IDEwLjc4NTMgMTQuNSAxMC4xODE2VjEwLjE4MTVWMTAuMTUwNVY5Ljc1MDUzQzE0LjUgOS4zMzYzMSAxNC4xNjQyIDkuMDAwNTMgMTMuNzUgOS4wMDA1M0MxMy4zMzU4IDkuMDAwNTMgMTMgOS4zMzYzMSAxMyA5Ljc1MDUzVjEwLjE1MDVDMTMgMTAuNzkzIDEyLjk5OTQgMTEuMjI5NyAxMi45NzE4IDExLjU2NzJDMTIuOTQ1IDExLjg5NjEgMTIuODk2MyAxMi4wNjQyIDEyLjgzNjUgMTIuMTgxNUMxMi42OTI3IDEyLjQ2MzggMTIuNDYzMiAxMi42OTMyIDEyLjE4MSAxMi44MzdDMTIuMDYzNyAxMi44OTY4IDExLjg5NTUgMTIuOTQ1NSAxMS41NjY3IDEyLjk3MjRDMTEuMjI5MiAxMi45OTk5IDEwLjc5MjQgMTMuMDAwNSAxMC4xNSAxMy4wMDA1SDUuODVDNS4yMDc1NyAxMy4wMDA1IDQuNzcwODUgMTIuOTk5OSA0LjQzMzI4IDEyLjk3MjRDNC4xMDQ0NyAxMi45NDU1IDMuOTM2MzIgMTIuODk2OCAzLjgxOTAyIDEyLjgzN0MzLjUzNjc3IDEyLjY5MzIgMy4zMDczIDEyLjQ2MzggMy4xNjM0OSAxMi4xODE1QzMuMTAzNzIgMTIuMDY0MiAzLjA1NTAzIDExLjg5NjEgMy4wMjgxNiAxMS41NjcyQzMuMDAwNTggMTEuMjI5NyAzIDEwLjc5MyAzIDEwLjE1MDVWNS44NTA1M0MzIDUuMjA4MDkgMy4wMDA1OCA0Ljc3MTM3IDMuMDI4MTYgNC40MzM4MUMzLjA1NTAzIDQuMTA0OTkgMy4xMDM3MiAzLjkzNjg0IDMuMTYzNDkgMy44MTk1NEMzLjMwNzMgMy41MzczIDMuNTM2NzcgMy4zMDc4MyAzLjgxOTAyIDMuMTY0MDJDMy45MzYzMiAzLjEwNDI1IDQuMTA0NDcgMy4wNTU1NiA0LjQzMzI4IDMuMDI4NjlDNC43NzA4NSAzLjAwMTExIDUuMjA3NTcgMy4wMDA1MyA1Ljg1IDMuMDAwNTNINi4yNUM2LjY2NDIyIDMuMDAwNTMgNyAyLjY2NDc0IDcgMi4yNTA1M0M3IDEuODM2MzEgNi42NjQyMiAxLjUwMDUzIDYuMjUgMS41MDA1M0g1Ljg1WlwiPmApO1xuY29uc3QgTGlua0ljb24gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCBmaWxsID0gKCkgPT4gcHJvcHMuZmlsbCB8fCB0aGVtZS5jb2xvcnMuYWNjZW50O1xuICByZXR1cm4gKCgpID0+IHtcbiAgICB2YXIgX2VsJCA9IF90bXBsJCRnKCksIF9lbCQyID0gX2VsJC5maXJzdENoaWxkO1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoKSA9PiBzZXRBdHRyaWJ1dGUoX2VsJDIsIFwiZmlsbFwiLCBmaWxsKCkpKTtcbiAgICByZXR1cm4gX2VsJDtcbiAgfSkoKTtcbn07XG52YXIgX3RtcGwkJGYgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyB3aWR0aD0xNyBoZWlnaHQ9MTYgdmlld0JveD1cIjAgMCAxNyAxNlwiZmlsbD1ub25lPjxnIGNsaXAtcGF0aD11cmwoI2NsaXAwXzM2NzZfMTI3NCk+PHBhdGggZmlsbC1ydWxlPWV2ZW5vZGQgY2xpcC1ydWxlPWV2ZW5vZGQgZD1cIk0xLjgyNjk4IDIuNjM5MDFDMS41IDMuMjgwNzQgMS41IDQuMTIwODIgMS41IDUuODAwOThWOC44MDA5OFY5LjAwMDk4VjEwLjIwMUMxLjUgMTEuODgxMSAxLjUgMTIuNzIxMiAxLjgyNjk4IDEzLjM2MjlDMi4xMTQ2IDEzLjkyNzQgMi41NzM1NCAxNC4zODY0IDMuMTM4MDMgMTQuNjc0QzMuNzc5NzYgMTUuMDAxIDQuNjE5ODQgMTUuMDAxIDYuMyAxNS4wMDFIMTEuN0MxMy4zODAyIDE1LjAwMSAxNC4yMjAyIDE1LjAwMSAxNC44NjIgMTQuNjc0QzE1LjQyNjUgMTQuMzg2NCAxNS44ODU0IDEzLjkyNzQgMTYuMTczIDEzLjM2MjlDMTYuNSAxMi43MjEyIDE2LjUgMTEuODgxMSAxNi41IDEwLjIwMVY4LjgwMDk4QzE2LjUgNy4xMjA4MiAxNi41IDYuMjgwNzQgMTYuMTczIDUuNjM5MDFDMTUuODg1NCA1LjA3NDUyIDE1LjQyNjUgNC42MTU1OCAxNC44NjIgNC4zMjc5NkMxNC43NDMgNC4yNjczMyAxNC42MTcyIDQuMjE3OTUgMTQuNDgwNSA0LjE3NzcyQzE0LjQ1MDEgMy40OTQ0OSAxNC4zNzIyIDMuMDI5OTQgMTQuMTczIDIuNjM5MDFDMTMuODg1NCAyLjA3NDUyIDEzLjQyNjUgMS42MTU1OCAxMi44NjIgMS4zMjc5NkMxMi4yMjAyIDEuMDAwOTggMTEuMzgwMiAxLjAwMDk4IDkuNyAxLjAwMDk4SDYuM0M0LjYxOTg0IDEuMDAwOTggMy43Nzk3NiAxLjAwMDk4IDMuMTM4MDMgMS4zMjc5NkMyLjU3MzU0IDEuNjE1NTggMi4xMTQ2IDIuMDc0NTIgMS44MjY5OCAyLjYzOTAxWk0xMi45ODYxIDQuMDA5NDJDMTIuOTY4NCAzLjcxMDggMTIuOTI4MSAzLjQ5OTgyIDEyLjgzNjUgMy4zMTk5OUMxMi42OTI3IDMuMDM3NzUgMTIuNDYzMiAyLjgwODI4IDEyLjE4MSAyLjY2NDQ3QzExLjg2MDEgMi41MDA5OCAxMS40NDAxIDIuNTAwOTggMTAuNiAyLjUwMDk4SDUuNEM0LjU1OTkyIDIuNTAwOTggNC4xMzk4OCAyLjUwMDk4IDMuODE5MDEgMi42NjQ0N0MzLjUzNjc3IDIuODA4MjggMy4zMDczIDMuMDM3NzUgMy4xNjM0OSAzLjMxOTk5QzMuMDM2MTUgMy41Njk5MSAzLjAwNzk5IDMuODggMy4wMDE3NyA0LjQwMTg4QzMuMDQ2NDYgNC4zNzYxMiAzLjA5MTg5IDQuMzUxNDYgMy4xMzgwMyA0LjMyNzk2QzMuNzc5NzYgNC4wMDA5OCA0LjYxOTg0IDQuMDAwOTggNi4zIDQuMDAwOThIMTEuN0MxMi4xOTY2IDQuMDAwOTggMTIuNjE5NyA0LjAwMDk4IDEyLjk4NjEgNC4wMDk0MlpNMyA3LjkwMDk4VjguMTAwOThDMyA4LjQ3NDY4IDMgOC43NjUyNyAzLjAxNDM5IDkuMDAwOThIM1YxMS4xMDFDMyAxMS45NDExIDMgMTIuMzYxMSAzLjE2MzQ5IDEyLjY4MkMzLjMwNzMgMTIuOTY0MiAzLjUzNjc3IDEzLjE5MzcgMy44MTkwMSAxMy4zMzc1QzQuMTM5ODggMTMuNTAxIDQuNTU5OTIgMTMuNTAxIDUuNCAxMy41MDFIMTIuNkMxMy40NDAxIDEzLjUwMSAxMy44NjAxIDEzLjUwMSAxNC4xODEgMTMuMzM3NUMxNC40NjMyIDEzLjE5MzcgMTQuNjkyNyAxMi45NjQyIDE0LjgzNjUgMTIuNjgyQzE1IDEyLjM2MTEgMTUgMTEuOTQxMSAxNSAxMS4xMDFWNy45MDA5OEMxNSA3LjA2MDkgMTUgNi42NDA4NiAxNC44MzY1IDYuMzE5OTlDMTQuNjkyNyA2LjAzNzc1IDE0LjQ2MzIgNS44MDgyOCAxNC4xODEgNS42NjQ0N0MxMy44NjAxIDUuNTAwOTggMTMuNDQwMSA1LjUwMDk4IDEyLjYgNS41MDA5OEg1LjRDNC41NTk5MiA1LjUwMDk4IDQuMTM5ODggNS41MDA5OCAzLjgxOTAxIDUuNjY0NDdDMy41MzY3NyA1LjgwODI4IDMuMzA3MyA2LjAzNzc1IDMuMTYzNDkgNi4zMTk5OUMzIDYuNjQwODYgMyA3LjA2MDkgMyA3LjkwMDk4Wk0xMC41IDkuNzUwOThDMTAuNSA5LjMzNjc2IDEwLjgzNTggOS4wMDA5OCAxMS4yNSA5LjAwMDk4SDEyLjc1QzEzLjE2NDIgOS4wMDA5OCAxMy41IDkuMzM2NzYgMTMuNSA5Ljc1MDk4QzEzLjUgMTAuMTY1MiAxMy4xNjQyIDEwLjUwMSAxMi43NSAxMC41MDFIMTEuMjVDMTAuODM1OCAxMC41MDEgMTAuNSAxMC4xNjUyIDEwLjUgOS43NTA5OFpcIj48L3BhdGg+PC9nPjxkZWZzPjxjbGlwUGF0aCBpZD1jbGlwMF8zNjc2XzEyNzQ+PHJlY3Qgd2lkdGg9MTYgaGVpZ2h0PTE2IGZpbGw9d2hpdGUgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAuNSAwLjAwMDk3NjU2MilcIj5gKTtcbmNvbnN0IFdhbGxldEljb24gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCBmaWxsID0gKCkgPT4gcHJvcHMuZmlsbCB8fCB0aGVtZS5jb2xvcnMuYWNjZW50O1xuICByZXR1cm4gKCgpID0+IHtcbiAgICB2YXIgX2VsJCA9IF90bXBsJCRmKCksIF9lbCQyID0gX2VsJC5maXJzdENoaWxkLCBfZWwkMyA9IF9lbCQyLmZpcnN0Q2hpbGQ7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KCgpID0+IHNldEF0dHJpYnV0ZShfZWwkMywgXCJmaWxsXCIsIGZpbGwoKSkpO1xuICAgIHJldHVybiBfZWwkO1xuICB9KSgpO1xufTtcbnZhciBfdG1wbCQkZSA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8c3ZnIHhtbG5zPWh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIHdpZHRoPTQ4IGhlaWdodD00OCB2aWV3Qm94PVwiMCAwIDQ4IDQ4XCJmaWxsPW5vbmU+PHBhdGggZmlsbC1ydWxlPWV2ZW5vZGQgY2xpcC1ydWxlPWV2ZW5vZGQgZD1cIk0zOS42MzE5IDE2Ljg3MTlDMzguMzIxMiAxNi4yMDQxIDM2LjcwMDIgMTYuMDQ3OCAzNCAxNi4wMTEyVjExQzM0IDUuNDc3MTUgMjkuNTIyOCAxIDI0IDFDMTguNDc3MiAxIDE0IDUuNDc3MTUgMTQgMTFWMTYuMDExMkMxMS4yOTk4IDE2LjA0NzggOS42Nzg4IDE2LjIwNDEgOC4zNjgwOCAxNi44NzE5QzYuODYyNzggMTcuNjM4OSA1LjYzODkzIDE4Ljg2MjggNC44NzE5NSAyMC4zNjgxQzQgMjIuMDc5NCA0IDI0LjMxOTYgNCAyOC44VjMyLjJDNCAzNi42ODA0IDQgMzguOTIwNiA0Ljg3MTk1IDQwLjYzMTlDNS42Mzg5MyA0Mi4xMzcyIDYuODYyNzggNDMuMzYxMSA4LjM2ODA4IDQ0LjEyODFDMTAuMDc5NCA0NSAxMi4zMTk2IDQ1IDE2LjggNDVIMzEuMkMzNS42ODA0IDQ1IDM3LjkyMDYgNDUgMzkuNjMxOSA0NC4xMjgxQzQxLjEzNzIgNDMuMzYxMSA0Mi4zNjExIDQyLjEzNzIgNDMuMTI4MSA0MC42MzE5QzQ0IDM4LjkyMDYgNDQgMzYuNjgwNCA0NCAzMi4yVjI4LjhDNDQgMjQuMzE5NiA0NCAyMi4wNzk0IDQzLjEyODEgMjAuMzY4MUM0Mi4zNjExIDE4Ljg2MjggNDEuMTM3MiAxNy42Mzg5IDM5LjYzMTkgMTYuODcxOVpNMzEgMTFWMTZIMTdWMTFDMTcgNy4xMzQwMSAyMC4xMzQgNCAyNCA0QzI3Ljg2NiA0IDMxIDcuMTM0MDEgMzEgMTFaTTcuNTQ0OTcgMjEuNzNDNyAyMi43OTk2IDcgMjQuMTk5NyA3IDI3VjM0QzcgMzYuODAwMyA3IDM4LjIwMDQgNy41NDQ5NyAzOS4yN0M4LjAyNDMzIDQwLjIxMDggOC43ODkyNCA0MC45NzU3IDkuNzMwMDUgNDEuNDU1QzEwLjc5OTYgNDIgMTIuMTk5NyA0MiAxNSA0MkgzM0MzNS44MDAzIDQyIDM3LjIwMDQgNDIgMzguMjcgNDEuNDU1QzM5LjIxMDggNDAuOTc1NyAzOS45NzU3IDQwLjIxMDggNDAuNDU1IDM5LjI3QzQxIDM4LjIwMDQgNDEgMzYuODAwMyA0MSAzNFYyN0M0MSAyNC4xOTk3IDQxIDIyLjc5OTYgNDAuNDU1IDIxLjczQzM5Ljk3NTcgMjAuNzg5MiAzOS4yMTA4IDIwLjAyNDMgMzguMjcgMTkuNTQ1QzM3LjIwMDQgMTkgMzUuODAwMyAxOSAzMyAxOUgxNUMxMi4xOTk3IDE5IDEwLjc5OTYgMTkgOS43MzAwNSAxOS41NDVDOC43ODkyNCAyMC4wMjQzIDguMDI0MzMgMjAuNzg5MiA3LjU0NDk3IDIxLjczWk0yNCAyNEMyMy4xNzE2IDI0IDIyLjUgMjQuNjcxNiAyMi41IDI1LjVWMjkuNUMyMi41IDMwLjMyODQgMjMuMTcxNiAzMSAyNCAzMUMyNC44Mjg0IDMxIDI1LjUgMzAuMzI4NCAyNS41IDI5LjVWMjUuNUMyNS41IDI0LjY3MTYgMjQuODI4NCAyNCAyNCAyNFpcIj5gKTtcbmNvbnN0IFNlY3VyaXR5SWNvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IGZpbGwgPSAoKSA9PiBwcm9wcy5maWxsIHx8IHRoZW1lLmNvbG9ycy5pY29uLnNlY29uZGFyeTtcbiAgcmV0dXJuICgoKSA9PiB7XG4gICAgdmFyIF9lbCQgPSBfdG1wbCQkZSgpLCBfZWwkMiA9IF9lbCQuZmlyc3RDaGlsZDtcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKF9wJCkgPT4ge1xuICAgICAgdmFyIF92JCA9IHByb3BzLmNsYXNzLCBfdiQyID0gZmlsbCgpO1xuICAgICAgX3YkICE9PSBfcCQuZSAmJiBzZXRBdHRyaWJ1dGUoX2VsJCwgXCJjbGFzc1wiLCBfcCQuZSA9IF92JCk7XG4gICAgICBfdiQyICE9PSBfcCQudCAmJiBzZXRBdHRyaWJ1dGUoX2VsJDIsIFwiZmlsbFwiLCBfcCQudCA9IF92JDIpO1xuICAgICAgcmV0dXJuIF9wJDtcbiAgICB9LCB7XG4gICAgICBlOiB2b2lkIDAsXG4gICAgICB0OiB2b2lkIDBcbiAgICB9KTtcbiAgICByZXR1cm4gX2VsJDtcbiAgfSkoKTtcbn07XG52YXIgX3RtcGwkJGQgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyB3aWR0aD00OCBoZWlnaHQ9NDggdmlld0JveD1cIjAgMCA0OCA0OFwiZmlsbD1ub25lPjxwYXRoIGZpbGwtcnVsZT1ldmVub2RkIGNsaXAtcnVsZT1ldmVub2RkIGQ9XCJNMzcuNDg1IDM3LjM4NDlDNDAuODk0IDMzLjk1MDYgNDMgMjkuMjIxMiA0MyAyNEM0MyAxMy41MDY2IDM0LjQ5MzQgNSAyNCA1QzEzLjUwNjYgNSA1IDEzLjUwNjYgNSAyNEM1IDI5LjIyMTMgNy4xMDYxIDMzLjk1MDcgMTAuNTE1MSAzNy4zODVDMTMuMzU4MyAzMi45NDM4IDE4LjMzNTQgMzAgMjQuMDAwMSAzMEMyOS42NjQ3IDMwIDM0LjY0MTggMzIuOTQzNyAzNy40ODUgMzcuMzg0OVpNMzUuMTgwOSAzOS4zNjM1QzMyLjkxNDMgMzUuNTUzMiAyOC43NTU0IDMzIDI0LjAwMDEgMzNDMTkuMjQ0OCAzMyAxNS4wODU4IDM1LjU1MzMgMTIuODE5MyAzOS4zNjM2QzE1Ljk1NjQgNDEuNjUwNiAxOS44MjA2IDQzIDI0IDQzQzI4LjE3OTUgNDMgMzIuMDQzNyA0MS42NTA1IDM1LjE4MDkgMzkuMzYzNVpNMjQgNDZDMzYuMTUwMyA0NiA0NiAzNi4xNTAzIDQ2IDI0QzQ2IDExLjg0OTcgMzYuMTUwMyAyIDI0IDJDMTEuODQ5NyAyIDIgMTEuODQ5NyAyIDI0QzIgMzYuMTUwMyAxMS44NDk3IDQ2IDI0IDQ2Wk0yNCAyNEMyNi43NjE0IDI0IDI5IDIxLjc2MTQgMjkgMTlDMjkgMTYuMjM4NiAyNi43NjE0IDE0IDI0IDE0QzIxLjIzODYgMTQgMTkgMTYuMjM4NiAxOSAxOUMxOSAyMS43NjE0IDIxLjIzODYgMjQgMjQgMjRaTTI0IDI3QzI4LjQxODMgMjcgMzIgMjMuNDE4MyAzMiAxOUMzMiAxNC41ODE3IDI4LjQxODMgMTEgMjQgMTFDMTkuNTgxNyAxMSAxNiAxNC41ODE3IDE2IDE5QzE2IDIzLjQxODMgMTkuNTgxNyAyNyAyNCAyN1pcIj5gKTtcbmNvbnN0IFBlcnNvbmFsaXR5SWNvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IGZpbGwgPSAoKSA9PiBwcm9wcy5maWxsIHx8IHRoZW1lLmNvbG9ycy5pY29uLnNlY29uZGFyeTtcbiAgcmV0dXJuICgoKSA9PiB7XG4gICAgdmFyIF9lbCQgPSBfdG1wbCQkZCgpLCBfZWwkMiA9IF9lbCQuZmlyc3RDaGlsZDtcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKF9wJCkgPT4ge1xuICAgICAgdmFyIF92JCA9IHByb3BzLmNsYXNzLCBfdiQyID0gZmlsbCgpO1xuICAgICAgX3YkICE9PSBfcCQuZSAmJiBzZXRBdHRyaWJ1dGUoX2VsJCwgXCJjbGFzc1wiLCBfcCQuZSA9IF92JCk7XG4gICAgICBfdiQyICE9PSBfcCQudCAmJiBzZXRBdHRyaWJ1dGUoX2VsJDIsIFwiZmlsbFwiLCBfcCQudCA9IF92JDIpO1xuICAgICAgcmV0dXJuIF9wJDtcbiAgICB9LCB7XG4gICAgICBlOiB2b2lkIDAsXG4gICAgICB0OiB2b2lkIDBcbiAgICB9KTtcbiAgICByZXR1cm4gX2VsJDtcbiAgfSkoKTtcbn07XG52YXIgX3RtcGwkJGMgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyB3aWR0aD00OCBoZWlnaHQ9NDggdmlld0JveD1cIjAgMCA0OCA0OFwiZmlsbD1ub25lPjxwYXRoIGZpbGwtcnVsZT1ldmVub2RkIGNsaXAtcnVsZT1ldmVub2RkIGQ9XCJNMzQuNTYwNyA0LjQzOTM0QzMzLjk3NDkgMy44NTM1NSAzMy4wMjUxIDMuODUzNTUgMzIuNDM5MyA0LjQzOTM0QzMxLjg1MzYgNS4wMjUxMyAzMS44NTM2IDUuOTc0ODcgMzIuNDM5MyA2LjU2MDY2TDM3Ljg3ODcgMTJIMTAuNUM5LjY3MTU3IDEyIDkgMTIuNjcxNiA5IDEzLjVDOSAxNC4zMjg0IDkuNjcxNTcgMTUgMTAuNSAxNUgzNy44Nzg3TDMyLjQzOTMgMjAuNDM5M0MzMS44NTM2IDIxLjAyNTEgMzEuODUzNiAyMS45NzQ5IDMyLjQzOTMgMjIuNTYwN0MzMy4wMjUxIDIzLjE0NjQgMzMuOTc0OSAyMy4xNDY0IDM0LjU2MDcgMjIuNTYwN0w0Mi41NjA3IDE0LjU2MDdDNDMuMTQ2NCAxMy45NzQ5IDQzLjE0NjQgMTMuMDI1MSA0Mi41NjA3IDEyLjQzOTNMMzQuNTYwNyA0LjQzOTM0Wk0xMy40MzkzIDI1LjQzOTNDMTQuMDI1MSAyNC44NTM2IDE0Ljk3NDkgMjQuODUzNiAxNS41NjA3IDI1LjQzOTNDMTYuMTQ2NCAyNi4wMjUxIDE2LjE0NjQgMjYuOTc0OSAxNS41NjA3IDI3LjU2MDdMMTAuMTIxMyAzM0gzNy41QzM4LjMyODQgMzMgMzkgMzMuNjcxNiAzOSAzNC41QzM5IDM1LjMyODQgMzguMzI4NCAzNiAzNy41IDM2SDEwLjEyMTNMMTUuNTYwNyA0MS40MzkzQzE2LjE0NjQgNDIuMDI1MSAxNi4xNDY0IDQyLjk3NDkgMTUuNTYwNyA0My41NjA3QzE0Ljk3NDkgNDQuMTQ2NCAxNC4wMjUxIDQ0LjE0NjQgMTMuNDM5MyA0My41NjA3TDUuNDM5MzQgMzUuNTYwN0M0Ljg1MzU1IDM0Ljk3NDkgNC44NTM1NSAzNC4wMjUxIDUuNDM5MzQgMzMuNDM5M0wxMy40MzkzIDI1LjQzOTNaXCI+YCk7XG5jb25zdCBTd2FwSWNvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IGZpbGwgPSAoKSA9PiBwcm9wcy5maWxsIHx8IHRoZW1lLmNvbG9ycy5pY29uLnNlY29uZGFyeTtcbiAgcmV0dXJuICgoKSA9PiB7XG4gICAgdmFyIF9lbCQgPSBfdG1wbCQkYygpLCBfZWwkMiA9IF9lbCQuZmlyc3RDaGlsZDtcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKF9wJCkgPT4ge1xuICAgICAgdmFyIF92JCA9IHByb3BzLmNsYXNzLCBfdiQyID0gZmlsbCgpO1xuICAgICAgX3YkICE9PSBfcCQuZSAmJiBzZXRBdHRyaWJ1dGUoX2VsJCwgXCJjbGFzc1wiLCBfcCQuZSA9IF92JCk7XG4gICAgICBfdiQyICE9PSBfcCQudCAmJiBzZXRBdHRyaWJ1dGUoX2VsJDIsIFwiZmlsbFwiLCBfcCQudCA9IF92JDIpO1xuICAgICAgcmV0dXJuIF9wJDtcbiAgICB9LCB7XG4gICAgICBlOiB2b2lkIDAsXG4gICAgICB0OiB2b2lkIDBcbiAgICB9KTtcbiAgICByZXR1cm4gX2VsJDtcbiAgfSkoKTtcbn07XG52YXIgX3RtcGwkJGIgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyB3aWR0aD0yOCBoZWlnaHQ9Mjggdmlld0JveD1cIjAgMCAyOCAyOFwiZmlsbD1ub25lPjxwYXRoIGZpbGwtcnVsZT1ldmVub2RkIGNsaXAtcnVsZT1ldmVub2RkIGQ9XCJNMS43NSAxMi4wMDJDMS43NSA5LjIwMTY5IDEuNzUgNy44MDE1NiAyLjI5NDk3IDYuNzMyQzIuNzc0MzMgNS43OTExOSAzLjUzOTI0IDUuMDI2MjkgNC40ODAwNSA0LjU0NjkyQzUuNTQ5NjEgNC4wMDE5NSA2Ljk0OTc0IDQuMDAxOTUgOS43NSA0LjAwMTk1SDE3LjI1QzIwLjA1MDMgNC4wMDE5NSAyMS40NTA0IDQuMDAxOTUgMjIuNTIgNC41NDY5MkMyMy40NjA4IDUuMDI2MjkgMjQuMjI1NyA1Ljc5MTE5IDI0LjcwNSA2LjczMkMyNC44MjU2IDYuOTY4NjEgMjQuOTE5NSA3LjIyMTQgMjQuOTkyNiA3LjUwMTk1SDIxLjVDMTkuNjM3NyA3LjUwMTk1IDE4LjcwNjUgNy41MDE5NSAxNy45NjA5IDcuNzczMzRDMTYuNzExIDguMjI4MjggMTUuNzI2MyA5LjIxMjkxIDE1LjI3MTQgMTAuNDYyOUMxNSAxMS4yMDg1IDE1IDEyLjEzOTYgMTUgMTQuMDAyQzE1IDE1Ljg2NDMgMTUgMTYuNzk1NCAxNS4yNzE0IDE3LjU0MUMxNS43MjYzIDE4Ljc5MSAxNi43MTEgMTkuNzc1NiAxNy45NjA5IDIwLjIzMDZDMTguNzA2NSAyMC41MDIgMTkuNjM3NyAyMC41MDIgMjEuNSAyMC41MDJIMjQuOTkyNkMyNC45MTk1IDIwLjc4MjUgMjQuODI1NiAyMS4wMzUzIDI0LjcwNSAyMS4yNzE5QzI0LjIyNTcgMjIuMjEyNyAyMy40NjA4IDIyLjk3NzYgMjIuNTIgMjMuNDU3QzIxLjQ1MDQgMjQuMDAyIDIwLjA1MDMgMjQuMDAyIDE3LjI1IDI0LjAwMkg5Ljc1QzYuOTQ5NzQgMjQuMDAyIDUuNTQ5NjEgMjQuMDAyIDQuNDgwMDUgMjMuNDU3QzMuNTM5MjQgMjIuOTc3NiAyLjc3NDMzIDIyLjIxMjcgMi4yOTQ5NyAyMS4yNzE5QzEuNzUgMjAuMjAyMyAxLjc1IDE4LjgwMjIgMS43NSAxNi4wMDJWMTIuMDAyWk0xNi40OTk5IDEzLjgwMkMxNi40OTk5IDEyLjEyMTggMTYuNDk5OSAxMS4yODE3IDE2LjgyNjkgMTAuNjRDMTcuMTE0NSAxMC4wNzU1IDE3LjU3MzUgOS42MTY1NiAxOC4xMzggOS4zMjg5NEMxOC43Nzk3IDkuMDAxOTYgMTkuNjE5OCA5LjAwMTk2IDIxLjI5OTkgOS4wMDE5NkgyMy4xOTk5QzI0Ljg4MDEgOS4wMDE5NiAyNS43MjAyIDkuMDAxOTYgMjYuMzYxOSA5LjMyODk0QzI2LjkyNjQgOS42MTY1NiAyNy4zODUzIDEwLjA3NTUgMjcuNjczIDEwLjY0QzI3Ljk5OTkgMTEuMjgxNyAyNy45OTk5IDEyLjEyMTggMjcuOTk5OSAxMy44MDJWMTQuMjAyQzI3Ljk5OTkgMTUuODgyMSAyNy45OTk5IDE2LjcyMjIgMjcuNjczIDE3LjM2MzlDMjcuMzg1MyAxNy45Mjg0IDI2LjkyNjQgMTguMzg3NCAyNi4zNjE5IDE4LjY3NUMyNS43MjAyIDE5LjAwMiAyNC44ODAxIDE5LjAwMiAyMy4xOTk5IDE5LjAwMkgyMS4yOTk5QzE5LjYxOTggMTkuMDAyIDE4Ljc3OTcgMTkuMDAyIDE4LjEzOCAxOC42NzVDMTcuNTczNSAxOC4zODc0IDE3LjExNDUgMTcuOTI4NCAxNi44MjY5IDE3LjM2MzlDMTYuNDk5OSAxNi43MjIyIDE2LjQ5OTkgMTUuODgyMSAxNi40OTk5IDE0LjIwMlYxMy44MDJaTTIyLjQ5OTkgMTQuMDAyQzIyLjQ5OTkgMTQuOTY4NSAyMS43MTY0IDE1Ljc1MiAyMC43NDk5IDE1Ljc1MkMxOS43ODM0IDE1Ljc1MiAxOC45OTk5IDE0Ljk2ODUgMTguOTk5OSAxNC4wMDJDMTguOTk5OSAxMy4wMzU1IDE5Ljc4MzQgMTIuMjUyIDIwLjc0OTkgMTIuMjUyQzIxLjcxNjQgMTIuMjUyIDIyLjQ5OTkgMTMuMDM1NSAyMi40OTk5IDE0LjAwMlpcIj5gKTtcbmNvbnN0IEF0V2FsbGV0SWNvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IGZpbGwgPSAoKSA9PiBwcm9wcy5maWxsIHx8IHRoZW1lLmNvbG9ycy5jb25zdGFudC53aGl0ZTtcbiAgcmV0dXJuICgoKSA9PiB7XG4gICAgdmFyIF9lbCQgPSBfdG1wbCQkYigpLCBfZWwkMiA9IF9lbCQuZmlyc3RDaGlsZDtcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKF9wJCkgPT4ge1xuICAgICAgdmFyIF92JCA9IHByb3BzLmNsYXNzLCBfdiQyID0gZmlsbCgpO1xuICAgICAgX3YkICE9PSBfcCQuZSAmJiBzZXRBdHRyaWJ1dGUoX2VsJCwgXCJjbGFzc1wiLCBfcCQuZSA9IF92JCk7XG4gICAgICBfdiQyICE9PSBfcCQudCAmJiBzZXRBdHRyaWJ1dGUoX2VsJDIsIFwiZmlsbFwiLCBfcCQudCA9IF92JDIpO1xuICAgICAgcmV0dXJuIF9wJDtcbiAgICB9LCB7XG4gICAgICBlOiB2b2lkIDAsXG4gICAgICB0OiB2b2lkIDBcbiAgICB9KTtcbiAgICByZXR1cm4gX2VsJDtcbiAgfSkoKTtcbn07XG52YXIgX3RtcGwkJGEgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyB3aWR0aD0yOCBoZWlnaHQ9Mjggdmlld0JveD1cIjAgMCAyOCAyOFwiPjxwYXRoIGZpbGwtcnVsZT1ldmVub2RkIGNsaXAtcnVsZT1ldmVub2RkIGQ9XCJNMTAuMDAwMSAxMC4wMDAxQzEwLjAwMTYgOC4wMjMzMyAxMC4wMjY3IDYuOTg3MTkgMTAuNDM2IDYuMTg0MDRDMTAuODE5NSA1LjQzMTM5IDExLjQzMTQgNC44MTk0NyAxMi4xODQgNC40MzU5N0MxMy4wMzk3IDQgMTQuMTU5OCA0IDE2LjQgNEgxNy42QzE5Ljg0MDIgNCAyMC45NjAzIDQgMjEuODE2IDQuNDM1OTdDMjIuNTY4NiA0LjgxOTQ3IDIzLjE4MDUgNS40MzEzOSAyMy41NjQgNi4xODQwNEMyNCA3LjAzOTY5IDI0IDguMTU5NzkgMjQgMTAuNFYxMS42QzI0IDEzLjg0MDIgMjQgMTQuOTYwMyAyMy41NjQgMTUuODE2QzIzLjE4MDUgMTYuNTY4NiAyMi41Njg2IDE3LjE4MDUgMjEuODE2IDE3LjU2NEMyMS4wMTI4IDE3Ljk3MzMgMTkuOTc2NyAxNy45OTg0IDE3Ljk5OTkgMTcuOTk5OUMxNy45OTg0IDE5Ljk3NjcgMTcuOTczMyAyMS4wMTI4IDE3LjU2NCAyMS44MTZDMTcuMTgwNSAyMi41Njg2IDE2LjU2ODYgMjMuMTgwNSAxNS44MTYgMjMuNTY0QzE0Ljk2MDMgMjQgMTMuODQwMiAyNCAxMS42IDI0SDEwLjRDOC4xNTk3OSAyNCA3LjAzOTY5IDI0IDYuMTg0MDQgMjMuNTY0QzUuNDMxMzkgMjMuMTgwNSA0LjgxOTQ3IDIyLjU2ODYgNC40MzU5NyAyMS44MTZDNCAyMC45NjAzIDQgMTkuODQwMiA0IDE3LjZWMTYuNEM0IDE0LjE1OTggNCAxMy4wMzk3IDQuNDM1OTcgMTIuMTg0QzQuODE5NDcgMTEuNDMxNCA1LjQzMTM5IDEwLjgxOTUgNi4xODQwNCAxMC40MzZDNi45ODcxOSAxMC4wMjY3IDguMDIzMzMgMTAuMDAxNiAxMC4wMDAxIDEwLjAwMDFaTTEwIDExLjVIOS41QzguMDk5ODcgMTEuNSA3LjM5OTggMTEuNSA2Ljg2NTAyIDExLjc3MjVDNi4zOTQ2MiAxMi4wMTIyIDYuMDEyMTcgMTIuMzk0NiA1Ljc3MjQ4IDEyLjg2NUM1LjUgMTMuMzk5OCA1LjUgMTQuMDk5OSA1LjUgMTUuNVYxOC41QzUuNSAxOS45MDAxIDUuNSAyMC42MDAyIDUuNzcyNDggMjEuMTM1QzYuMDEyMTcgMjEuNjA1NCA2LjM5NDYyIDIxLjk4NzggNi44NjUwMiAyMi4yMjc1QzcuMzk5OCAyMi41IDguMDk5ODcgMjIuNSA5LjUgMjIuNUgxMi41QzEzLjkwMDEgMjIuNSAxNC42MDAyIDIyLjUgMTUuMTM1IDIyLjIyNzVDMTUuNjA1NCAyMS45ODc4IDE1Ljk4NzggMjEuNjA1NCAxNi4yMjc1IDIxLjEzNUMxNi41IDIwLjYwMDIgMTYuNSAxOS45MDAxIDE2LjUgMTguNVYxOEgxNi40QzE0LjE1OTggMTggMTMuMDM5NyAxOCAxMi4xODQgMTcuNTY0QzExLjQzMTQgMTcuMTgwNSAxMC44MTk1IDE2LjU2ODYgMTAuNDM2IDE1LjgxNkMxMCAxNC45NjAzIDEwIDEzLjg0MDIgMTAgMTEuNlYxMS41Wk0xMS41IDkuNUMxMS41IDguMDk5ODcgMTEuNSA3LjM5OTggMTEuNzcyNSA2Ljg2NTAyQzEyLjAxMjIgNi4zOTQ2MiAxMi4zOTQ2IDYuMDEyMTcgMTIuODY1IDUuNzcyNDhDMTMuMzk5OCA1LjUgMTQuMDk5OSA1LjUgMTUuNSA1LjVIMTguNUMxOS45MDAxIDUuNSAyMC42MDAyIDUuNSAyMS4xMzUgNS43NzI0OEMyMS42MDU0IDYuMDEyMTcgMjEuOTg3OCA2LjM5NDYyIDIyLjIyNzUgNi44NjUwMkMyMi41IDcuMzk5OCAyMi41IDguMDk5ODcgMjIuNSA5LjVWMTIuNUMyMi41IDEzLjkwMDEgMjIuNSAxNC42MDAyIDIyLjIyNzUgMTUuMTM1QzIxLjk4NzggMTUuNjA1NCAyMS42MDU0IDE1Ljk4NzggMjEuMTM1IDE2LjIyNzVDMjAuNjAwMiAxNi41IDE5LjkwMDEgMTYuNSAxOC41IDE2LjVIMTUuNUMxNC4wOTk5IDE2LjUgMTMuMzk5OCAxNi41IDEyLjg2NSAxNi4yMjc1QzEyLjM5NDYgMTUuOTg3OCAxMi4wMTIyIDE1LjYwNTQgMTEuNzcyNSAxNS4xMzVDMTEuNSAxNC42MDAyIDExLjUgMTMuOTAwMSAxMS41IDEyLjVWOS41WlwiPmApO1xuY29uc3QgQ29weUxpZ2h0SWNvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IGZpbGwgPSAoKSA9PiBwcm9wcy5maWxsIHx8IHRoZW1lLmNvbG9ycy5pY29uLnNlY29uZGFyeTtcbiAgcmV0dXJuICgoKSA9PiB7XG4gICAgdmFyIF9lbCQgPSBfdG1wbCQkYSgpLCBfZWwkMiA9IF9lbCQuZmlyc3RDaGlsZDtcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKF9wJCkgPT4ge1xuICAgICAgdmFyIF92JCA9IGZpbGwoKSwgX3YkMiA9IGZpbGwoKTtcbiAgICAgIF92JCAhPT0gX3AkLmUgJiYgc2V0QXR0cmlidXRlKF9lbCQsIFwiZmlsbFwiLCBfcCQuZSA9IF92JCk7XG4gICAgICBfdiQyICE9PSBfcCQudCAmJiBzZXRBdHRyaWJ1dGUoX2VsJDIsIFwiZmlsbFwiLCBfcCQudCA9IF92JDIpO1xuICAgICAgcmV0dXJuIF9wJDtcbiAgICB9LCB7XG4gICAgICBlOiB2b2lkIDAsXG4gICAgICB0OiB2b2lkIDBcbiAgICB9KTtcbiAgICByZXR1cm4gX2VsJDtcbiAgfSkoKTtcbn07XG52YXIgX3RtcGwkJDkgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyB3aWR0aD0xNiBoZWlnaHQ9MTcgdmlld0JveD1cIjAgMCAxNiAxN1wiZmlsbD1ub25lPjxwYXRoIGZpbGwtcnVsZT1ldmVub2RkIGNsaXAtcnVsZT1ldmVub2RkIGQ9XCJNMSA0LjEyNjk1QzEgMy4wNzc1NCAxIDIuNTUyODQgMS4xOTIwMiAyLjE0Njg0QzEuMzg5ODYgMS43Mjg1NiAxLjcyNjYgMS4zOTE4MSAyLjE0NDg5IDEuMTkzOTdDMi41NTA4OCAxLjAwMTk1IDMuMDc1NTkgMS4wMDE5NSA0LjEyNSAxLjAwMTk1QzUuMTc0NDEgMS4wMDE5NSA1LjY5OTEyIDEuMDAxOTUgNi4xMDUxMSAxLjE5Mzk3QzYuNTIzNCAxLjM5MTgxIDYuODYwMTQgMS43Mjg1NiA3LjA1Nzk4IDIuMTQ2ODRDNy4yNSAyLjU1Mjg0IDcuMjUgMy4wNzc1NCA3LjI1IDQuMTI2OTVDNy4yNSA1LjE3NjM2IDcuMjUgNS43MDEwNyA3LjA1Nzk4IDYuMTA3MDZDNi44NjAxNCA2LjUyNTM1IDYuNTIzNCA2Ljg2MjEgNi4xMDUxMSA3LjA1OTkzQzUuNjk5MTIgNy4yNTE5NSA1LjE3NDQxIDcuMjUxOTUgNC4xMjUgNy4yNTE5NUMzLjA3NTU5IDcuMjUxOTUgMi41NTA4OCA3LjI1MTk1IDIuMTQ0ODkgNy4wNTk5M0MxLjcyNjYgNi44NjIxIDEuMzg5ODYgNi41MjUzNSAxLjE5MjAyIDYuMTA3MDZDMSA1LjcwMTA3IDEgNS4xNzYzNiAxIDQuMTI2OTVaTTIuNSAzLjMwMTk1QzIuNSAzLjAyMTkzIDIuNSAyLjg4MTkxIDIuNTU0NSAyLjc3NDk2QzIuNjAyNDMgMi42ODA4OCAyLjY3ODkyIDIuNjA0MzkgMi43NzMgMi41NTY0NUMyLjg3OTk2IDIuNTAxOTUgMy4wMTk5NyAyLjUwMTk1IDMuMyAyLjUwMTk1SDQuOTVDNS4yMzAwMyAyLjUwMTk1IDUuMzcwMDQgMi41MDE5NSA1LjQ3NyAyLjU1NjQ1QzUuNTcxMDggMi42MDQzOSA1LjY0NzU3IDIuNjgwODggNS42OTU1IDIuNzc0OTZDNS43NSAyLjg4MTkxIDUuNzUgMy4wMjE5MyA1Ljc1IDMuMzAxOTVWNC45NTE5NUM1Ljc1IDUuMjMxOTggNS43NSA1LjM3MTk5IDUuNjk1NSA1LjQ3ODk1QzUuNjQ3NTcgNS41NzMwMyA1LjU3MTA4IDUuNjQ5NTIgNS40NzcgNS42OTc0NkM1LjM3MDA0IDUuNzUxOTUgNS4yMzAwMyA1Ljc1MTk1IDQuOTUgNS43NTE5NUgzLjNDMy4wMTk5NyA1Ljc1MTk1IDIuODc5OTYgNS43NTE5NSAyLjc3MyA1LjY5NzQ2QzIuNjc4OTIgNS42NDk1MiAyLjYwMjQzIDUuNTczMDMgMi41NTQ1IDUuNDc4OTVDMi41IDUuMzcxOTkgMi41IDUuMjMxOTggMi41IDQuOTUxOTVWMy4zMDE5NVpNMSAxMS44NzdDMSAxMC44Mjc1IDEgMTAuMzAyOCAxLjE5MjAyIDkuODk2ODRDMS4zODk4NiA5LjQ3ODU2IDEuNzI2NiA5LjE0MTgxIDIuMTQ0ODkgOC45NDM5N0MyLjU1MDg4IDguNzUxOTUgMy4wNzU1OSA4Ljc1MTk1IDQuMTI1IDguNzUxOTVDNS4xNzQ0MSA4Ljc1MTk1IDUuNjk5MTIgOC43NTE5NSA2LjEwNTExIDguOTQzOTdDNi41MjM0IDkuMTQxODEgNi44NjAxNCA5LjQ3ODU2IDcuMDU3OTggOS44OTY4NEM3LjI1IDEwLjMwMjggNy4yNSAxMC44Mjc1IDcuMjUgMTEuODc3QzcuMjUgMTIuOTI2NCA3LjI1IDEzLjQ1MTEgNy4wNTc5OCAxMy44NTcxQzYuODYwMTQgMTQuMjc1MyA2LjUyMzQgMTQuNjEyMSA2LjEwNTExIDE0LjgwOTlDNS42OTkxMiAxNS4wMDIgNS4xNzQ0MSAxNS4wMDIgNC4xMjUgMTUuMDAyQzMuMDc1NTkgMTUuMDAyIDIuNTUwODggMTUuMDAyIDIuMTQ0ODkgMTQuODA5OUMxLjcyNjYgMTQuNjEyMSAxLjM4OTg2IDE0LjI3NTMgMS4xOTIwMiAxMy44NTcxQzEgMTMuNDUxMSAxIDEyLjkyNjQgMSAxMS44NzdaTTIuNSAxMS4wNTJDMi41IDEwLjc3MTkgMi41IDEwLjYzMTkgMi41NTQ1IDEwLjUyNUMyLjYwMjQzIDEwLjQzMDkgMi42Nzg5MiAxMC4zNTQ0IDIuNzczIDEwLjMwNjRDMi44Nzk5NiAxMC4yNTIgMy4wMTk5NyAxMC4yNTIgMy4zIDEwLjI1Mkg0Ljk1QzUuMjMwMDMgMTAuMjUyIDUuMzcwMDQgMTAuMjUyIDUuNDc3IDEwLjMwNjRDNS41NzEwOCAxMC4zNTQ0IDUuNjQ3NTcgMTAuNDMwOSA1LjY5NTUgMTAuNTI1QzUuNzUgMTAuNjMxOSA1Ljc1IDEwLjc3MTkgNS43NSAxMS4wNTJWMTIuNzAyQzUuNzUgMTIuOTgyIDUuNzUgMTMuMTIyIDUuNjk1NSAxMy4yMjg5QzUuNjQ3NTcgMTMuMzIzIDUuNTcxMDggMTMuMzk5NSA1LjQ3NyAxMy40NDc1QzUuMzcwMDQgMTMuNTAyIDUuMjMwMDMgMTMuNTAyIDQuOTUgMTMuNTAySDMuM0MzLjAxOTk3IDEzLjUwMiAyLjg3OTk2IDEzLjUwMiAyLjc3MyAxMy40NDc1QzIuNjc4OTIgMTMuMzk5NSAyLjYwMjQzIDEzLjMyMyAyLjU1NDUgMTMuMjI4OUMyLjUgMTMuMTIyIDIuNSAxMi45ODIgMi41IDEyLjcwMlYxMS4wNTJaTTguOTQyMDIgMi4xNDY4NEM4Ljc1IDIuNTUyODQgOC43NSAzLjA3NzU0IDguNzUgNC4xMjY5NUM4Ljc1IDUuMTc2MzYgOC43NSA1LjcwMTA3IDguOTQyMDIgNi4xMDcwNkM5LjEzOTg2IDYuNTI1MzUgOS40NzY2IDYuODYyMSA5Ljg5NDg5IDcuMDU5OTNDMTAuMzAwOSA3LjI1MTk1IDEwLjgyNTYgNy4yNTE5NSAxMS44NzUgNy4yNTE5NUMxMi45MjQ0IDcuMjUxOTUgMTMuNDQ5MSA3LjI1MTk1IDEzLjg1NTEgNy4wNTk5M0MxNC4yNzM0IDYuODYyMSAxNC42MTAxIDYuNTI1MzUgMTQuODA4IDYuMTA3MDZDMTUgNS43MDEwNyAxNSA1LjE3NjM2IDE1IDQuMTI2OTVDMTUgMy4wNzc1NCAxNSAyLjU1Mjg0IDE0LjgwOCAyLjE0Njg0QzE0LjYxMDEgMS43Mjg1NiAxNC4yNzM0IDEuMzkxODEgMTMuODU1MSAxLjE5Mzk3QzEzLjQ0OTEgMS4wMDE5NSAxMi45MjQ0IDEuMDAxOTUgMTEuODc1IDEuMDAxOTVDMTAuODI1NiAxLjAwMTk1IDEwLjMwMDkgMS4wMDE5NSA5Ljg5NDg5IDEuMTkzOTdDOS40NzY2IDEuMzkxODEgOS4xMzk4NiAxLjcyODU2IDguOTQyMDIgMi4xNDY4NFpNMTAuMzA0NSAyLjc3NDk2QzEwLjI1IDIuODgxOTEgMTAuMjUgMy4wMjE5MyAxMC4yNSAzLjMwMTk1VjQuOTUxOTVDMTAuMjUgNS4yMzE5OCAxMC4yNSA1LjM3MTk5IDEwLjMwNDUgNS40Nzg5NUMxMC4zNTI0IDUuNTczMDMgMTAuNDI4OSA1LjY0OTUyIDEwLjUyMyA1LjY5NzQ2QzEwLjYzIDUuNzUxOTUgMTAuNzcgNS43NTE5NSAxMS4wNSA1Ljc1MTk1SDEyLjdDMTIuOTggNS43NTE5NSAxMy4xMiA1Ljc1MTk1IDEzLjIyNyA1LjY5NzQ2QzEzLjMyMTEgNS42NDk1MiAxMy4zOTc2IDUuNTczMDMgMTMuNDQ1NSA1LjQ3ODk1QzEzLjUgNS4zNzE5OSAxMy41IDUuMjMxOTggMTMuNSA0Ljk1MTk1VjMuMzAxOTVDMTMuNSAzLjAyMTkzIDEzLjUgMi44ODE5MSAxMy40NDU1IDIuNzc0OTZDMTMuMzk3NiAyLjY4MDg4IDEzLjMyMTEgMi42MDQzOSAxMy4yMjcgMi41NTY0NUMxMy4xMiAyLjUwMTk1IDEyLjk4IDIuNTAxOTUgMTIuNyAyLjUwMTk1SDExLjA1QzEwLjc3IDIuNTAxOTUgMTAuNjMgMi41MDE5NSAxMC41MjMgMi41NTY0NUMxMC40Mjg5IDIuNjA0MzkgMTAuMzUyNCAyLjY4MDg4IDEwLjMwNDUgMi43NzQ5NlpNOC44MDcyNyA5LjEzNTE4QzguNzUgOS4yNjI0MiA4Ljc1IDkuNDI1NiA4Ljc1IDkuNzUxOTVDOC43NSAxMC4wNzgzIDguNzUgMTAuMjQxNSA4LjgwNzI3IDEwLjM2ODdDOC44NzI0NSAxMC41MTM2IDguOTg4NCAxMC42Mjk1IDkuMTMzMjMgMTAuNjk0N0M5LjI2MDQ3IDEwLjc1MiA5LjQyMzY1IDEwLjc1MiA5Ljc1IDEwLjc1MkMxMC4wNzY0IDEwLjc1MiAxMC4yMzk1IDEwLjc1MiAxMC4zNjY4IDEwLjY5NDdDMTAuNTExNiAxMC42Mjk1IDEwLjYyNzYgMTAuNTEzNiAxMC42OTI3IDEwLjM2ODdDMTAuNzUgMTAuMjQxNSAxMC43NSAxMC4wNzgzIDEwLjc1IDkuNzUxOTVDMTAuNzUgOS40MjU2IDEwLjc1IDkuMjYyNDIgMTAuNjkyNyA5LjEzNTE4QzEwLjYyNzYgOC45OTAzNSAxMC41MTE2IDguODc0NCAxMC4zNjY4IDguODA5MjJDMTAuMjM5NSA4Ljc1MTk1IDEwLjA3NjQgOC43NTE5NSA5Ljc1IDguNzUxOTVDOS40MjM2NSA4Ljc1MTk1IDkuMjYwNDcgOC43NTE5NSA5LjEzMzIzIDguODA5MjJDOC45ODg0IDguODc0NCA4Ljg3MjQ1IDguOTkwMzUgOC44MDcyNyA5LjEzNTE4Wk0xMC44NyAxMS44NzcxQzEwLjg3IDExLjU0NiAxMC44NyAxMS4zODA1IDEwLjkyODkgMTEuMjUxN0MxMC45OTM4IDExLjEwOTggMTEuMTA3NyAxMC45OTU5IDExLjI0OTcgMTAuOTMxQzExLjM3ODQgMTAuODcyMSAxMS41NDM5IDEwLjg3MjEgMTEuODc1IDEwLjg3MjFDMTIuMjA2MSAxMC44NzIxIDEyLjM3MTYgMTAuODcyMSAxMi41MDAzIDEwLjkzMUMxMi42NDIzIDEwLjk5NTkgMTIuNzU2MiAxMS4xMDk4IDEyLjgyMTEgMTEuMjUxN0MxMi44OCAxMS4zODA1IDEyLjg4IDExLjU0NiAxMi44OCAxMS44NzcxQzEyLjg4IDEyLjIwODEgMTIuODggMTIuMzczNyAxMi44MjExIDEyLjUwMjRDMTIuNzU2MiAxMi42NDQ0IDEyLjY0MjMgMTIuNzU4MyAxMi41MDAzIDEyLjgyMzJDMTIuMzcxNiAxMi44ODIxIDEyLjIwNjEgMTIuODgyMSAxMS44NzUgMTIuODgyMUMxMS41NDM5IDEyLjg4MjEgMTEuMzc4NCAxMi44ODIxIDExLjI0OTcgMTIuODIzMkMxMS4xMDc3IDEyLjc1ODMgMTAuOTkzOCAxMi42NDQ0IDEwLjkyODkgMTIuNTAyNEMxMC44NyAxMi4zNzM3IDEwLjg3IDEyLjIwODEgMTAuODcgMTEuODc3MVpNOC44MDcyNyAxMy4zODUyQzguNzUgMTMuNTEyNCA4Ljc1IDEzLjY3NTYgOC43NSAxNC4wMDJDOC43NSAxNC4zMjgzIDguNzUgMTQuNDkxNSA4LjgwNzI3IDE0LjYxODdDOC44NzI0NSAxNC43NjM2IDguOTg4NCAxNC44Nzk1IDkuMTMzMjMgMTQuOTQ0N0M5LjI2MDQ3IDE1LjAwMiA5LjQyMzY1IDE1LjAwMiA5Ljc1IDE1LjAwMkMxMC4wNzY0IDE1LjAwMiAxMC4yMzk1IDE1LjAwMiAxMC4zNjY4IDE0Ljk0NDdDMTAuNTExNiAxNC44Nzk1IDEwLjYyNzYgMTQuNzYzNiAxMC42OTI3IDE0LjYxODdDMTAuNzUgMTQuNDkxNSAxMC43NSAxNC4zMjgzIDEwLjc1IDE0LjAwMkMxMC43NSAxMy42NzU2IDEwLjc1IDEzLjUxMjQgMTAuNjkyNyAxMy4zODUyQzEwLjYyNzYgMTMuMjQwNCAxMC41MTE2IDEzLjEyNDQgMTAuMzY2OCAxMy4wNTkyQzEwLjIzOTUgMTMuMDAyIDEwLjA3NjQgMTMuMDAyIDkuNzUgMTMuMDAyQzkuNDIzNjUgMTMuMDAyIDkuMjYwNDcgMTMuMDAyIDkuMTMzMjMgMTMuMDU5MkM4Ljk4ODQgMTMuMTI0NCA4Ljg3MjQ1IDEzLjI0MDQgOC44MDcyNyAxMy4zODUyWk0xMyA5Ljc1MTk1QzEzIDkuNDI1NiAxMyA5LjI2MjQyIDEzLjA1NzMgOS4xMzUxOEMxMy4xMjI0IDguOTkwMzUgMTMuMjM4NCA4Ljg3NDQgMTMuMzgzMiA4LjgwOTIyQzEzLjUxMDUgOC43NTE5NSAxMy42NzM2IDguNzUxOTUgMTQgOC43NTE5NUMxNC4zMjY0IDguNzUxOTUgMTQuNDg5NSA4Ljc1MTk1IDE0LjYxNjggOC44MDkyMkMxNC43NjE2IDguODc0NCAxNC44Nzc2IDguOTkwMzUgMTQuOTQyNyA5LjEzNTE4QzE1IDkuMjYyNDIgMTUgOS40MjU2IDE1IDkuNzUxOTVDMTUgMTAuMDc4MyAxNSAxMC4yNDE1IDE0Ljk0MjcgMTAuMzY4N0MxNC44Nzc2IDEwLjUxMzYgMTQuNzYxNiAxMC42Mjk1IDE0LjYxNjggMTAuNjk0N0MxNC40ODk1IDEwLjc1MiAxNC4zMjY0IDEwLjc1MiAxNCAxMC43NTJDMTMuNjczNiAxMC43NTIgMTMuNTEwNSAxMC43NTIgMTMuMzgzMiAxMC42OTQ3QzEzLjIzODQgMTAuNjI5NSAxMy4xMjI0IDEwLjUxMzYgMTMuMDU3MyAxMC4zNjg3QzEzIDEwLjI0MTUgMTMgMTAuMDc4MyAxMyA5Ljc1MTk1Wk0xMy4wNTczIDEzLjM4NTJDMTMgMTMuNTEyNCAxMyAxMy42NzU2IDEzIDE0LjAwMkMxMyAxNC4zMjgzIDEzIDE0LjQ5MTUgMTMuMDU3MyAxNC42MTg3QzEzLjEyMjQgMTQuNzYzNiAxMy4yMzg0IDE0Ljg3OTUgMTMuMzgzMiAxNC45NDQ3QzEzLjUxMDUgMTUuMDAyIDEzLjY3MzYgMTUuMDAyIDE0IDE1LjAwMkMxNC4zMjY0IDE1LjAwMiAxNC40ODk1IDE1LjAwMiAxNC42MTY4IDE0Ljk0NDdDMTQuNzYxNiAxNC44Nzk1IDE0Ljg3NzYgMTQuNzYzNiAxNC45NDI3IDE0LjYxODdDMTUgMTQuNDkxNSAxNSAxNC4zMjgzIDE1IDE0LjAwMkMxNSAxMy42NzU2IDE1IDEzLjUxMjQgMTQuOTQyNyAxMy4zODUyQzE0Ljg3NzYgMTMuMjQwNCAxNC43NjE2IDEzLjEyNDQgMTQuNjE2OCAxMy4wNTkyQzE0LjQ4OTUgMTMuMDAyIDE0LjMyNjQgMTMuMDAyIDE0IDEzLjAwMkMxMy42NzM2IDEzLjAwMiAxMy41MTA1IDEzLjAwMiAxMy4zODMyIDEzLjA1OTJDMTMuMjM4NCAxMy4xMjQ0IDEzLjEyMjQgMTMuMjQwNCAxMy4wNTczIDEzLjM4NTJaXCI+YCk7XG5jb25zdCBRUkljb24gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCBmaWxsID0gKCkgPT4gcHJvcHMuZmlsbCB8fCB0aGVtZS5jb2xvcnMuaWNvbi5zZWNvbmRhcnk7XG4gIHJldHVybiAoKCkgPT4ge1xuICAgIHZhciBfZWwkID0gX3RtcGwkJDkoKSwgX2VsJDIgPSBfZWwkLmZpcnN0Q2hpbGQ7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KCgpID0+IHNldEF0dHJpYnV0ZShfZWwkMiwgXCJmaWxsXCIsIGZpbGwoKSkpO1xuICAgIHJldHVybiBfZWwkO1xuICB9KSgpO1xufTtcbmNvbnN0IGNvbnRhaW5lckJvcmRlcnMgPSB7XG4gIG06IFwiMTZweFwiLFxuICBzOiBcIjEycHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCB3YWxsZXRCb3JkZXJzID0ge1xuICBtOiBcIjZweFwiLFxuICBzOiBcIjZweFwiLFxuICBub25lOiBcIjBcIlxufTtcbmNvbnN0IEZvdXJXYWxsZXRzQ2FyZCA9IHN0eWxlZC5kaXZgXG4gICAgd2lkdGg6IDYwcHg7XG4gICAgaGVpZ2h0OiA2MHB4O1xuICAgIHBhZGRpbmc6IDhweDtcbiAgICBtYXJnaW4tYm90dG9tOiA4cHg7XG4gICAgYm9yZGVyLXJhZGl1czogJHsocHJvcHMpID0+IGNvbnRhaW5lckJvcmRlcnNbcHJvcHMudGhlbWUuYm9yZGVyUmFkaXVzXX07XG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnRpbnR9O1xuICAgIGRpc3BsYXk6IGdyaWQ7XG4gICAgZ3JpZC10ZW1wbGF0ZTogMWZyIDFmciAvIDFmciAxZnI7XG4gICAgZ2FwOiA0cHg7XG5gO1xuY29uc3QgRm91cldhbGxldHNJbWFnZSA9IHN0eWxlZChXYWxsZXRJbWFnZSlgXG4gICAgd2lkdGg6IDIwcHg7XG4gICAgaGVpZ2h0OiAyMHB4O1xuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiB3YWxsZXRCb3JkZXJzW3Byb3BzLnRoZW1lLmJvcmRlclJhZGl1c119O1xuYDtcbmNvbnN0IEZvdXJXYWxsZXRzSXRlbSA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFdhbGxldEl0ZW0sIHtcbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5sYWJlbExpbmUxO1xuICAgIH0sXG4gICAgZ2V0IHNlY29uZExpbmUoKSB7XG4gICAgICByZXR1cm4gcHJvcHMubGFiZWxMaW5lMjtcbiAgICB9LFxuICAgIGdldCBpY29uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChGb3VyV2FsbGV0c0NhcmQsIHtcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoRm9yLCB7XG4gICAgICAgICAgICBlYWNoOiBbMCwgMSwgMiwgM10sXG4gICAgICAgICAgICBjaGlsZHJlbjogKGluZGV4KSA9PiBjcmVhdGVDb21wb25lbnQoRm91cldhbGxldHNJbWFnZSwge1xuICAgICAgICAgICAgICBnZXQgc3JjKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy5pbWFnZXNbaW5kZXhdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG9uQ2xpY2s6ICgpID0+IHByb3BzLm9uQ2xpY2soKVxuICB9KTtcbn07XG5jb25zdCBBVF9XQUxMRVRfQVBQX05BTUUgPSBcInRlbGVncmFtLXdhbGxldFwiO1xuY29uc3QgSU1HID0ge1xuICBUT046IFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3Rvbi1jb25uZWN0L3Nkay9tYWluL2Fzc2V0cy90b24taWNvbi00OC5wbmdcIixcbiAgVEc6IFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3Rvbi1jb25uZWN0L3Nkay9tYWluL2Fzc2V0cy90Zy5wbmdcIixcbiAgV0FMTEVUX0NPTk5FQ1Q6IFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3Rvbi1jb25uZWN0L3Nkay9tYWluL2Fzc2V0cy93YWxsZXRjb25uZWN0LWljb24tMjg4LnBuZ1wiXG59O1xuZnVuY3Rpb24gaXNXYWxsZXRVaSh3YWxsZXQpIHtcbiAgcmV0dXJuICEoXCJ0eXBlXCIgaW4gd2FsbGV0KSB8fCB3YWxsZXQudHlwZSAhPT0gXCJ3YWxsZXQtY29ubmVjdFwiO1xufVxuY29uc3QgV2FsbGV0TGFiZWxlZEl0ZW0gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgW3QyXSA9IHVzZUkxOG4oKTtcbiAgY29uc3Qgd2FsbGV0c1NlY29uZExpbmUgPSAoKSA9PiB7XG4gICAgaWYgKHByb3BzLndhbGxldC5hcHBOYW1lID09PSBBVF9XQUxMRVRfQVBQX05BTUUpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChcImlzUHJlZmVycmVkXCIgaW4gcHJvcHMud2FsbGV0ICYmIHByb3BzLndhbGxldC5pc1ByZWZlcnJlZCkge1xuICAgICAgcmV0dXJuIHQyKFwid2FsbGV0SXRlbS5yZWNlbnRcIiwge30sIFwiUmVjZW50XCIpO1xuICAgIH1cbiAgICBpZiAocHJvcHMud2FsbGV0Lm5hbWUgPT09IFwiVG9ua2VlcGVyXCIpIHtcbiAgICAgIHJldHVybiB0MihcIndhbGxldEl0ZW0ucG9wdWxhclwiLCB7fSwgXCJQb3B1bGFyXCIpO1xuICAgIH1cbiAgICBpZiAoaXNXYWxsZXRVaShwcm9wcy53YWxsZXQpICYmIGlzV2FsbGV0SW5mb0N1cnJlbnRseUluamVjdGVkKHByb3BzLndhbGxldCkpIHtcbiAgICAgIHJldHVybiB0MihcIndhbGxldEl0ZW0uaW5zdGFsbGVkXCIsIHt9LCBcIkluc3RhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfTtcbiAgcmV0dXJuIG1lbW8oKCkgPT4gbWVtbygoKSA9PiBwcm9wcy53YWxsZXQuYXBwTmFtZSA9PT0gQVRfV0FMTEVUX0FQUF9OQU1FKSgpID8gY3JlYXRlQ29tcG9uZW50KFdhbGxldEl0ZW0sIHtcbiAgICBnZXQgaWNvbigpIHtcbiAgICAgIHJldHVybiBwcm9wcy53YWxsZXQuaW1hZ2VVcmw7XG4gICAgfSxcbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgIHJldHVybiB0MihcIndhbGxldEl0ZW0ud2FsbGV0T25cIiwge30sIFwiV2FsbGV0IGluXCIpO1xuICAgIH0sXG4gICAgc2Vjb25kTGluZTogXCJUZWxlZ3JhbVwiLFxuICAgIGdldCBiYWRnZVVybCgpIHtcbiAgICAgIHJldHVybiBJTUcuVEc7XG4gICAgfSxcbiAgICBvbkNsaWNrOiAoKSA9PiBwcm9wcy5vbkNsaWNrKCksXG4gICAgZ2V0IFtcImNsYXNzXCJdKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgIH1cbiAgfSkgOiBjcmVhdGVDb21wb25lbnQoV2FsbGV0SXRlbSwge1xuICAgIGdldCBpY29uKCkge1xuICAgICAgcmV0dXJuIHByb3BzLndhbGxldC5pbWFnZVVybDtcbiAgICB9LFxuICAgIGdldCBuYW1lKCkge1xuICAgICAgcmV0dXJuIHByb3BzLndhbGxldC5uYW1lO1xuICAgIH0sXG4gICAgZ2V0IHNlY29uZExpbmUoKSB7XG4gICAgICByZXR1cm4gd2FsbGV0c1NlY29uZExpbmUoKTtcbiAgICB9LFxuICAgIHNlY29uZExpbmVDb2xvclByaW1hcnk6IGZhbHNlLFxuICAgIG9uQ2xpY2s6ICgpID0+IHByb3BzLm9uQ2xpY2soKSxcbiAgICBnZXQgW1wiY2xhc3NcIl0oKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2xhc3M7XG4gICAgfVxuICB9KSk7XG59O1xuY29uc3QgU2Nyb2xsQ29udGFpbmVyU3R5bGVkID0gc3R5bGVkLmRpdmBcbiAgICB3aWR0aDogMTAwJTtcbiAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgIG1heC1oZWlnaHQ6ICR7KHByb3BzKSA9PiBwcm9wcy5tYXhIZWlnaHR9O1xuXG4gICAgc2Nyb2xsYmFyLXdpZHRoOiBub25lO1xuICAgICYmOjotd2Via2l0LXNjcm9sbGJhciB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuXG4gICAgJiY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrIHtcbiAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgfVxuXG4gICAgJiY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG5gO1xuY29uc3QgU2Nyb2xsRGl2aWRlciA9IHN0eWxlZC5kaXZgXG4gICAgaGVpZ2h0OiAxcHg7XG4gICAgbWFyZ2luOiAwIC0yNHB4O1xuICAgIHdpZHRoOiBjYWxjKDEwMCUgKyA0OHB4KTtcbiAgICBvcGFjaXR5OiAwLjA4O1xuICAgIGJhY2tncm91bmQ6ICR7KHByb3BzKSA9PiBwcm9wcy5pc1Nob3duID8gcHJvcHMudGhlbWUuY29sb3JzLmljb24uc2Vjb25kYXJ5IDogXCJ0cmFuc3BhcmVudFwifTtcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kIDAuMTVzIGVhc2UtaW4tb3V0O1xuXG4gICAgJHttZWRpYShcIm1vYmlsZVwiKX0ge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgIH1cbmA7XG5jb25zdCBbd2luZG93SGVpZ2h0LCBzZXRXaW5kb3dIZWlnaHRdID0gY3JlYXRlU2lnbmFsKCgoX2ggPSBnZXRXaW5kb3ckMSgpKSA9PSBudWxsID8gdm9pZCAwIDogX2guaW5uZXJIZWlnaHQpIHx8IDApO1xuaWYgKGdldFdpbmRvdyQxKCkpIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgKCkgPT4gc2V0V2luZG93SGVpZ2h0KHdpbmRvdy5pbm5lckhlaWdodCkpO1xufVxuY29uc3QgW2lzTW9iaWxlLCBzZXRJc01vYmlsZV0gPSBjcmVhdGVTaWduYWwoaXNEZXZpY2UoXCJtb2JpbGVcIikpO1xuY29uc3QgdXBkYXRlSXNNb2JpbGUgPSAoKSA9PiBzZXRJc01vYmlsZShpc0RldmljZShcIm1vYmlsZVwiKSk7XG5pZiAoZ2V0V2luZG93JDEoKSkge1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCAoKSA9PiB1cGRhdGVJc01vYmlsZSgpKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHVwZGF0ZUlzTW9iaWxlKCksIHsgb25jZTogdHJ1ZSB9KTtcbn1cbmNvbnN0IFNjcm9sbENvbnRhaW5lciA9IChwcm9wcykgPT4ge1xuICBjb25zdCBbc2Nyb2xsZWQsIHNldFNjcm9sbGVkXSA9IGNyZWF0ZVNpZ25hbChmYWxzZSk7XG4gIGNvbnN0IG9uU2Nyb2xsID0gKGUyKSA9PiB7XG4gICAgc2V0U2Nyb2xsZWQoZTIudGFyZ2V0LnNjcm9sbFRvcCA+IDApO1xuICB9O1xuICBjb25zdCBvZmZzZXQgPSAoKSA9PiBpc01vYmlsZSgpID8gMTUwIDogMjAwO1xuICBjb25zdCBtYXhIZWlnaHQgPSAoKSA9PiBwcm9wcy5tYXhIZWlnaHQgIT09IHZvaWQgMCA/IGAke3Byb3BzLm1heEhlaWdodH1weGAgOiBgJHt3aW5kb3dIZWlnaHQoKSAtIG9mZnNldCgpfXB4YDtcbiAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoU2Nyb2xsRGl2aWRlciwge1xuICAgIGdldCBpc1Nob3duKCkge1xuICAgICAgcmV0dXJuIHNjcm9sbGVkKCk7XG4gICAgfVxuICB9KSwgY3JlYXRlQ29tcG9uZW50KFNjcm9sbENvbnRhaW5lclN0eWxlZCwge1xuICAgIGdldCBtYXhIZWlnaHQoKSB7XG4gICAgICByZXR1cm4gbWF4SGVpZ2h0KCk7XG4gICAgfSxcbiAgICBvblNjcm9sbCxcbiAgICBnZXQgW1wiY2xhc3NcIl0oKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2xhc3M7XG4gICAgfSxcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICB9KV07XG59O1xuY29uc3QgQVN0eWxlZCA9IHN0eWxlZC5hYFxuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHRleHQtZGVjb3JhdGlvbjogdW5zZXQ7XG5gO1xuY29uc3QgTGluayA9IChwcm9wcykgPT4ge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gKCkgPT4gcHJvcHMuYmxhbmsgPyB7XG4gICAgcmVsOiBcIm5vcmVmZXJyZXIgbm9vcGVuZXJcIlxuICB9IDoge307XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoQVN0eWxlZCwgbWVyZ2VQcm9wcyh7XG4gICAgZ2V0IGhyZWYoKSB7XG4gICAgICByZXR1cm4gcHJvcHMuaHJlZjtcbiAgICB9LFxuICAgIGdldCB0YXJnZXQoKSB7XG4gICAgICByZXR1cm4gcHJvcHMuYmxhbmsgPyBcIl9ibGFua1wiIDogXCJfc2VsZlwiO1xuICAgIH0sXG4gICAgZ2V0IFtcImNsYXNzXCJdKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgIH1cbiAgfSwgYXR0cmlidXRlcywge1xuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gIH0pKTtcbn07XG5jb25zdCBUb25Db25uZWN0VWlDb250ZXh0ID0gY3JlYXRlQ29udGV4dCgpO1xudmFyIF90bXBsJCQ4ID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgd2lkdGg9MjQgaGVpZ2h0PTI0IHZpZXdCb3g9XCIwIDAgMjQgMjRcImZpbGw9bm9uZSB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zz48cGF0aCBmaWxsLXJ1bGU9ZXZlbm9kZCBjbGlwLXJ1bGU9ZXZlbm9kZCBkPVwiTTcuNzYyMjggMi4wOTk5OEgxMC4yMzc4QzExLjA0NTggMi4wOTk5NyAxMS43MDY3IDIuMDk5OTYgMTIuMjQzOCAyLjE0Mzg0QzEyLjc5OTcgMi4xODkyNiAxMy4zMDE3IDIuMjg2MTQgMTMuNzcwNiAyLjUyNTA1QzE0LjUwNDUgMi44OTg5NiAxNS4xMDExIDMuNDk1NTggMTUuNDc1IDQuMjI5NDFDMTUuNzEzOSA0LjY5ODMgMTUuODEwOCA1LjIwMDM4IDE1Ljg1NjIgNS43NTYyOUMxNS45MDAxIDYuMjkzMzcgMTUuOTAwMSA2Ljk1NDIyIDE1LjkwMDEgNy43NjIyN1Y4LjFIMTYuMjM3N0MxNy4wNDU3IDguMDk5OTkgMTcuNzA2NiA4LjA5OTk4IDE4LjI0MzcgOC4xNDM4NkMxOC43OTk2IDguMTg5MjggMTkuMzAxNyA4LjI4NjE2IDE5Ljc3MDUgOC41MjUwN0MyMC41MDQ0IDguODk4OTggMjEuMTAxIDkuNDk1NiAyMS40NzQ5IDEwLjIyOTRDMjEuNzEzOCAxMC42OTgzIDIxLjgxMDcgMTEuMjAwNCAyMS44NTYxIDExLjc1NjNDMjEuOSAxMi4yOTM0IDIxLjkgMTIuOTU0MiAyMS45IDEzLjc2MjNWMTYuMjM3N0MyMS45IDE3LjA0NTggMjEuOSAxNy43MDY2IDIxLjg1NjEgMTguMjQzN0MyMS44MTA3IDE4Ljc5OTYgMjEuNzEzOCAxOS4zMDE3IDIxLjQ3NDkgMTkuNzcwNkMyMS4xMDEgMjAuNTA0NCAyMC41MDQ0IDIxLjEwMSAxOS43NzA1IDIxLjQ3NDlDMTkuMzAxNyAyMS43MTM4IDE4Ljc5OTYgMjEuODEwNyAxOC4yNDM3IDIxLjg1NjFDMTcuNzA2NiAyMS45IDE3LjA0NTggMjEuOSAxNi4yMzc4IDIxLjlIMTMuNzYyM0MxMi45NTQzIDIxLjkgMTIuMjkzNCAyMS45IDExLjc1NjMgMjEuODU2MUMxMS4yMDA0IDIxLjgxMDcgMTAuNjk4MyAyMS43MTM4IDEwLjIyOTQgMjEuNDc0OUM5LjQ5NTYxIDIxLjEwMSA4Ljg5ODk4IDIwLjUwNDQgOC41MjUwOCAxOS43NzA2QzguMjg2MTYgMTkuMzAxNyA4LjE4OTI4IDE4Ljc5OTYgOC4xNDM4NiAxOC4yNDM3QzguMDk5OTggMTcuNzA2NiA4LjA5OTk5IDE3LjA0NTggOC4xIDE2LjIzNzdWMTUuOUg3Ljc2MjI3QzYuOTU0MjYgMTUuOSA2LjI5MzM1IDE1LjkgNS43NTYyOSAxNS44NTYxQzUuMjAwMzggMTUuODEwNyA0LjY5ODMgMTUuNzEzOCA0LjIyOTQxIDE1LjQ3NDlDMy40OTU1OCAxNS4xMDEgMi44OTg5NiAxNC41MDQ0IDIuNTI1MDUgMTMuNzcwNUMyLjI4NjE0IDEzLjMwMTcgMi4xODkyNiAxMi43OTk2IDIuMTQzODQgMTIuMjQzN0MyLjA5OTk2IDExLjcwNjYgMi4wOTk5NyAxMS4wNDU4IDIuMDk5OTggMTAuMjM3N1Y3Ljc2MjI4QzIuMDk5OTcgNi45NTQyNCAyLjA5OTk2IDYuMjkzMzYgMi4xNDM4NCA1Ljc1NjI5QzIuMTg5MjYgNS4yMDAzOCAyLjI4NjE0IDQuNjk4MyAyLjUyNTA1IDQuMjI5NDFDMi44OTg5NiAzLjQ5NTU4IDMuNDk1NTggMi44OTg5NiA0LjIyOTQxIDIuNTI1MDVDNC42OTgzIDIuMjg2MTQgNS4yMDAzOCAyLjE4OTI2IDUuNzU2MjkgMi4xNDM4NEM2LjI5MzM2IDIuMDk5OTYgNi45NTQyNSAyLjA5OTk3IDcuNzYyMjggMi4wOTk5OFpNOC4xIDE0LjFWMTMuNzYyM0M4LjA5OTk5IDEyLjk1NDIgOC4wOTk5OCAxMi4yOTM0IDguMTQzODYgMTEuNzU2M0M4LjE4OTI4IDExLjIwMDQgOC4yODYxNiAxMC42OTgzIDguNTI1MDggMTAuMjI5NEM4Ljg5ODk4IDkuNDk1NiA5LjQ5NTYxIDguODk4OTggMTAuMjI5NCA4LjUyNTA3QzEwLjY5ODMgOC4yODYxNiAxMS4yMDA0IDguMTg5MjggMTEuNzU2MyA4LjE0Mzg2QzEyLjI5MzQgOC4wOTk5OCAxMi45NTQyIDguMDk5OTkgMTMuNzYyMyA4LjFIMTQuMTAwMVY3Ljc5OTk4QzE0LjEwMDEgNi45NDUwNSAxNC4wOTk0IDYuMzU3OTggMTQuMDYyMiA1LjkwMjg3QzE0LjAyNTkgNS40NTgyNyAxMy45NTkzIDUuMjE5NDQgMTMuODcxMiA1LjA0NjZDMTMuNjY5OSA0LjY1MTQ2IDEzLjM0ODYgNC4zMzAyIDEyLjk1MzUgNC4xMjg4NkMxMi43ODA2IDQuMDQwNzkgMTIuNTQxOCAzLjk3NDE5IDEyLjA5NzIgMy45Mzc4NkMxMS42NDIxIDMuOTAwNjggMTEuMDU1IDMuODk5OTggMTAuMjAwMSAzLjg5OTk4SDcuNzk5OThDNi45NDUwNSAzLjg5OTk4IDYuMzU3OTggMy45MDA2OCA1LjkwMjg3IDMuOTM3ODZDNS40NTgyNyAzLjk3NDE5IDUuMjE5NDQgNC4wNDA3OSA1LjA0NjYgNC4xMjg4NkM0LjY1MTQ2IDQuMzMwMiA0LjMzMDIgNC42NTE0NiA0LjEyODg2IDUuMDQ2NkM0LjA0MDc5IDUuMjE5NDQgMy45NzQxOSA1LjQ1ODI3IDMuOTM3ODYgNS45MDI4N0MzLjkwMDY4IDYuMzU3OTggMy44OTk5OCA2Ljk0NTA1IDMuODk5OTggNy43OTk5OFYxMC4yQzMuODk5OTggMTEuMDU0OSAzLjkwMDY4IDExLjY0MiAzLjkzNzg2IDEyLjA5NzFDMy45NzQxOSAxMi41NDE3IDQuMDQwNzkgMTIuNzgwNSA0LjEyODg2IDEyLjk1MzRDNC4zMzAyIDEzLjM0ODUgNC42NTE0NiAxMy42Njk4IDUuMDQ2NiAxMy44NzExQzUuMjE5NDQgMTMuOTU5MiA1LjQ1ODI3IDE0LjAyNTggNS45MDI4NyAxNC4wNjIxQzYuMzU3OTggMTQuMDk5MyA2Ljk0NTA1IDE0LjEgNy43OTk5OCAxNC4xSDguMVpNMTEuMDQ2NiAxMC4xMjg5QzExLjIxOTUgMTAuMDQwOCAxMS40NTgzIDkuOTc0MjEgMTEuOTAyOSA5LjkzNzg4QzEyLjM1OCA5LjkwMDcgMTIuOTQ1MSA5LjkgMTMuOCA5LjlIMTYuMkMxNy4wNTQ5IDkuOSAxNy42NDIgOS45MDA3IDE4LjA5NzEgOS45Mzc4OEMxOC41NDE3IDkuOTc0MjEgMTguNzgwNSAxMC4wNDA4IDE4Ljk1MzQgMTAuMTI4OUMxOS4zNDg1IDEwLjMzMDIgMTkuNjY5OCAxMC42NTE1IDE5Ljg3MTEgMTEuMDQ2NkMxOS45NTkyIDExLjIxOTUgMjAuMDI1OCAxMS40NTgzIDIwLjA2MjEgMTEuOTAyOUMyMC4wOTkzIDEyLjM1OCAyMC4xIDEyLjk0NTEgMjAuMSAxMy44VjE2LjJDMjAuMSAxNy4wNTQ5IDIwLjA5OTMgMTcuNjQyIDIwLjA2MjEgMTguMDk3MUMyMC4wMjU4IDE4LjU0MTcgMTkuOTU5MiAxOC43ODA1IDE5Ljg3MTEgMTguOTUzNEMxOS42Njk4IDE5LjM0ODUgMTkuMzQ4NSAxOS42Njk4IDE4Ljk1MzQgMTkuODcxMUMxOC43ODA1IDE5Ljk1OTIgMTguNTQxNyAyMC4wMjU4IDE4LjA5NzEgMjAuMDYyMUMxNy42NDIgMjAuMDk5MyAxNy4wNTQ5IDIwLjEgMTYuMiAyMC4xSDEzLjhDMTIuOTQ1MSAyMC4xIDEyLjM1OCAyMC4wOTkzIDExLjkwMjkgMjAuMDYyMUMxMS40NTgzIDIwLjAyNTggMTEuMjE5NSAxOS45NTkyIDExLjA0NjYgMTkuODcxMUMxMC42NTE1IDE5LjY2OTggMTAuMzMwMiAxOS4zNDg1IDEwLjEyODkgMTguOTUzNEMxMC4wNDA4IDE4Ljc4MDUgOS45NzQyMSAxOC41NDE3IDkuOTM3ODggMTguMDk3MUM5LjkwMDcgMTcuNjQyIDkuOSAxNy4wNTQ5IDkuOSAxNi4yVjEzLjhDOS45IDEyLjk0NTEgOS45MDA3IDEyLjM1OCA5LjkzNzg4IDExLjkwMjlDOS45NzQyMSAxMS40NTgzIDEwLjA0MDggMTEuMjE5NSAxMC4xMjg5IDExLjA0NjZDMTAuMzMwMiAxMC42NTE1IDEwLjY1MTUgMTAuMzMwMiAxMS4wNDY2IDEwLjEyODlaXCI+YCk7XG5jb25zdCBDb3B5SWNvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IGZpbGwgPSAoKSA9PiBwcm9wcy5maWxsIHx8IHRoZW1lLmNvbG9ycy5pY29uLnByaW1hcnk7XG4gIHJldHVybiAoKCkgPT4ge1xuICAgIHZhciBfZWwkID0gX3RtcGwkJDgoKSwgX2VsJDIgPSBfZWwkLmZpcnN0Q2hpbGQ7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KChfcCQpID0+IHtcbiAgICAgIHZhciBfdiQgPSBwcm9wcy5jbGFzcywgX3YkMiA9IGZpbGwoKTtcbiAgICAgIF92JCAhPT0gX3AkLmUgJiYgc2V0QXR0cmlidXRlKF9lbCQsIFwiY2xhc3NcIiwgX3AkLmUgPSBfdiQpO1xuICAgICAgX3YkMiAhPT0gX3AkLnQgJiYgc2V0QXR0cmlidXRlKF9lbCQyLCBcImZpbGxcIiwgX3AkLnQgPSBfdiQyKTtcbiAgICAgIHJldHVybiBfcCQ7XG4gICAgfSwge1xuICAgICAgZTogdm9pZCAwLFxuICAgICAgdDogdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIF9lbCQ7XG4gIH0pKCk7XG59O1xudmFyIF90bXBsJCQ3ID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgd2lkdGg9MjQgaGVpZ2h0PTI0IHZpZXdCb3g9XCIwIDAgMjQgMjRcImZpbGw9bm9uZSB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zz48cGF0aCBkPVwiTTguNzYyNCAzLjEwMDAxQzcuOTU0MzUgMy4xIDcuMjkzNDkgMy4wOTk5OSA2Ljc1NjQyIDMuMTQzODdDNi4yMDA1IDMuMTg5MjkgNS42OTg0MiAzLjI4NjE3IDUuMjI5NTQgMy41MjUwOEM0LjQ5NTcgMy44OTg5OSAzLjg5OTA4IDQuNDk1NjEgMy41MjUxNyA1LjIyOTQ0QzMuMjg2MjYgNS42OTgzMyAzLjE4OTM4IDYuMjAwNDEgMy4xNDM5NiA2Ljc1NjMyQzMuMTAwMDggNy4yOTM0IDMuMTAwMDkgNy45NTQyNCAzLjEwMDEgOC43NjIyOVYxNS4yMzc3QzMuMTAwMDkgMTYuMDQ1OCAzLjEwMDA4IDE2LjcwNjYgMy4xNDM5NiAxNy4yNDM3QzMuMTg5MzggMTcuNzk5NiAzLjI4NjI2IDE4LjMwMTcgMy41MjUxNyAxOC43NzA2QzMuODk5MDggMTkuNTA0NCA0LjQ5NTcgMjAuMTAxIDUuMjI5NTQgMjAuNDc0OUM1LjY5ODQyIDIwLjcxMzggNi4yMDA1IDIwLjgxMDcgNi43NTY0MiAyMC44NTYxQzcuMjkzNDkgMjAuOSA3Ljk1NDM0IDIwLjkgOC43NjIzOSAyMC45SDEyLjAwMDFDMTIuNDk3MiAyMC45IDEyLjkwMDEgMjAuNDk3MSAxMi45MDAxIDIwQzEyLjkwMDEgMTkuNTAzIDEyLjQ5NzIgMTkuMSAxMi4wMDAxIDE5LjFIOC44MDAxQzcuOTQ1MTcgMTkuMSA3LjM1ODEgMTkuMDk5MyA2LjkwMjk5IDE5LjA2MjFDNi40NTgzOSAxOS4wMjU4IDYuMjE5NTYgMTguOTU5MiA2LjA0NjcyIDE4Ljg3MTFDNS42NTE1OCAxOC42Njk4IDUuMzMwMzIgMTguMzQ4NSA1LjEyODk4IDE3Ljk1MzRDNS4wNDA5MiAxNy43ODA1IDQuOTc0MzEgMTcuNTQxNyA0LjkzNzk4IDE3LjA5NzFDNC45MDA4IDE2LjY0MiA0LjkwMDEgMTYuMDU0OSA0LjkwMDEgMTUuMlY4LjgwMDAxQzQuOTAwMSA3Ljk0NTA4IDQuOTAwOCA3LjM1ODAxIDQuOTM3OTggNi45MDI5QzQuOTc0MzEgNi40NTgzIDUuMDQwOTIgNi4yMTk0NyA1LjEyODk4IDYuMDQ2NjNDNS4zMzAzMiA1LjY1MTQ5IDUuNjUxNTggNS4zMzAyMyA2LjA0NjcyIDUuMTI4ODlDNi4yMTk1NiA1LjA0MDgyIDYuNDU4MzkgNC45NzQyMiA2LjkwMjk5IDQuOTM3ODlDNy4zNTgxIDQuOTAwNzEgNy45NDUxNyA0LjkwMDAxIDguODAwMSA0LjkwMDAxSDEyLjAwMDFDMTIuNDk3MiA0LjkwMDAxIDEyLjkwMDEgNC40OTcwNiAxMi45MDAxIDQuMDAwMDFDMTIuOTAwMSAzLjUwMjk1IDEyLjQ5NzIgMy4xMDAwMSAxMi4wMDAxIDMuMTAwMDFIOC43NjI0WlwiPjwvcGF0aD48cGF0aCBkPVwiTTE3LjYzNjQgNy4zNjM2QzE3LjI4NDkgNy4wMTIxMiAxNi43MTUxIDcuMDEyMTIgMTYuMzYzNiA3LjM2MzZDMTYuMDEyMSA3LjcxNTA3IDE2LjAxMjEgOC4yODQ5MiAxNi4zNjM2IDguNjM2MzlMMTguODI3MiAxMS4xSDkuMDAwMDFDOC41MDI5NSAxMS4xIDguMTAwMDEgMTEuNTAyOSA4LjEwMDAxIDEyQzguMTAwMDEgMTIuNDk3IDguNTAyOTUgMTIuOSA5LjAwMDAxIDEyLjlIMTguODI3MkwxNi4zNjM2IDE1LjM2MzZDMTYuMDEyMSAxNS43MTUxIDE2LjAxMjEgMTYuMjg0OSAxNi4zNjM2IDE2LjYzNjRDMTYuNzE1MSAxNi45ODc5IDE3LjI4NDkgMTYuOTg3OSAxNy42MzY0IDE2LjYzNjRMMjEuNjM2NCAxMi42MzY0QzIxLjk4NzkgMTIuMjg0OSAyMS45ODc5IDExLjcxNTEgMjEuNjM2NCAxMS4zNjM2TDE3LjYzNjQgNy4zNjM2WlwiPmApO1xuY29uc3QgRGlzY29ubmVjdEljb24gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCBmaWxsID0gKCkgPT4gcHJvcHMuZmlsbCB8fCB0aGVtZS5jb2xvcnMuaWNvbi5wcmltYXJ5O1xuICByZXR1cm4gKCgpID0+IHtcbiAgICB2YXIgX2VsJCA9IF90bXBsJCQ3KCksIF9lbCQyID0gX2VsJC5maXJzdENoaWxkLCBfZWwkMyA9IF9lbCQyLm5leHRTaWJsaW5nO1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoX3AkKSA9PiB7XG4gICAgICB2YXIgX3YkID0gZmlsbCgpLCBfdiQyID0gZmlsbCgpO1xuICAgICAgX3YkICE9PSBfcCQuZSAmJiBzZXRBdHRyaWJ1dGUoX2VsJDIsIFwiZmlsbFwiLCBfcCQuZSA9IF92JCk7XG4gICAgICBfdiQyICE9PSBfcCQudCAmJiBzZXRBdHRyaWJ1dGUoX2VsJDMsIFwiZmlsbFwiLCBfcCQudCA9IF92JDIpO1xuICAgICAgcmV0dXJuIF9wJDtcbiAgICB9LCB7XG4gICAgICBlOiB2b2lkIDAsXG4gICAgICB0OiB2b2lkIDBcbiAgICB9KTtcbiAgICByZXR1cm4gX2VsJDtcbiAgfSkoKTtcbn07XG5jb25zdCBob3ZlckJvcmRlcnMkMSA9IHtcbiAgbTogXCI4cHhcIixcbiAgczogXCI0cHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCBkcm9wZG93bkJvcmRlcnMgPSB7XG4gIG06IFwiMTZweFwiLFxuICBzOiBcIjhweFwiLFxuICBub25lOiBcIjBcIlxufTtcbmNvbnN0IEFjY291bnRCdXR0b25Ecm9wZG93blN0eWxlZCA9IHN0eWxlZC5kaXZgXG4gICAgd2lkdGg6IDI1NnB4O1xuICAgIGJveC1zaGFkb3c6IDAgNHB4IDI0cHggcmdiYSgwLCAwLCAwLCAwLjE2KTtcbiAgICBib3JkZXItcmFkaXVzOiAkeyhwcm9wcykgPT4gZHJvcGRvd25Cb3JkZXJzW3Byb3BzLnRoZW1lLmJvcmRlclJhZGl1c119O1xuXG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnByaW1hcnl9XG4gICAgICAgICAgIFxuICAgIGNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLnRleHQucHJpbWFyeX1cbmA7XG5jb25zdCBVbFN0eWxlZCA9IHN0eWxlZC51bGBcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmJhY2tncm91bmQucHJpbWFyeX07XG4gICAgcGFkZGluZzogOHB4O1xuYDtcbmNvbnN0IE1lbnVCdXR0b25TdHlsZWQgPSBzdHlsZWQuYnV0dG9uYFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBnYXA6IDhweDtcbiAgICBoZWlnaHQ6IDQwcHg7XG4gICAgcGFkZGluZy1sZWZ0OiA4cHg7XG4gICAgd2lkdGg6IDEwMCU7XG5cbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmJhY2tncm91bmQucHJpbWFyeX07XG4gICAgYm9yZGVyOiBub25lO1xuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiBob3ZlckJvcmRlcnMkMVtwcm9wcy50aGVtZS5ib3JkZXJSYWRpdXNdfTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICB0cmFuc2l0aW9uOlxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yLFxuICAgICAgICB0cmFuc2Zvcm0gMC4xcyBlYXNlLWluLW91dDtcblxuICAgICY6aG92ZXIge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmJhY2tncm91bmQuc2Vjb25kYXJ5fTtcbiAgICB9XG5cbiAgICAmOmFjdGl2ZSB7XG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC45Nik7XG4gICAgfVxuYDtcbnZhciBfdG1wbCQkNiA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8bGk+YCk7XG5jb25zdCBNZW51SXRlbVRleHQgPSAocHJvcHMpID0+IGNyZWF0ZUNvbXBvbmVudChUZXh0LCB7XG4gIGdldCB0cmFuc2xhdGlvbktleSgpIHtcbiAgICByZXR1cm4gcHJvcHMudHJhbnNsYXRpb25LZXk7XG4gIH0sXG4gIGZvbnRTaXplOiBcIjE1cHhcIixcbiAgZm9udFdlaWdodDogXCI1OTBcIixcbiAgZ2V0IGNoaWxkcmVuKCkge1xuICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbiAgfVxufSk7XG5jb25zdCBBY2NvdW50QnV0dG9uRHJvcGRvd24gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdG9uQ29ubmVjdFVpID0gdXNlQ29udGV4dChUb25Db25uZWN0VWlDb250ZXh0KTtcbiAgY29uc3QgW2lzQ29waWVkU2hvd24sIHNldElzQ29waWVkU2hvd25dID0gY3JlYXRlU2lnbmFsKGZhbHNlKTtcbiAgY29uc3Qgb25Db3B5ID0gKCkgPT4gX19hc3luYyhudWxsLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IHVzZXJGcmllbmRseUFkZHJlc3MgPSB0b1VzZXJGcmllbmRseUFkZHJlc3ModG9uQ29ubmVjdFVpLmFjY291bnQuYWRkcmVzcywgdG9uQ29ubmVjdFVpLmFjY291bnQuY2hhaW4gPT09IENIQUlOLlRFU1RORVQpO1xuICAgIHlpZWxkIGNvcHlUb0NsaXBib2FyZCh1c2VyRnJpZW5kbHlBZGRyZXNzKTtcbiAgICBzZXRJc0NvcGllZFNob3duKHRydWUpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0SXNDb3BpZWRTaG93bihmYWxzZSksIDFlMyk7XG4gIH0pO1xuICBjb25zdCBvbkRpc2Nvbm5lY3QgPSAoKSA9PiB7XG4gICAgdG9uQ29ubmVjdFVpLmRpc2Nvbm5lY3QoKTtcbiAgICBwcm9wcy5vbkNsb3NlKCk7XG4gIH07XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoQWNjb3VudEJ1dHRvbkRyb3Bkb3duU3R5bGVkLCB7XG4gICAgcmVmKHIkKSB7XG4gICAgICB2YXIgX3JlZiQgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlb2YgX3JlZiQgPT09IFwiZnVuY3Rpb25cIiA/IF9yZWYkKHIkKSA6IHByb3BzLnJlZiA9IHIkO1xuICAgIH0sXG4gICAgZ2V0IFtcImNsYXNzXCJdKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgIH0sXG4gICAgXCJkYXRhLXRjLWRyb3Bkb3duXCI6IFwidHJ1ZVwiLFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVWxTdHlsZWQsIHtcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBbKCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfZWwkID0gX3RtcGwkJDYoKTtcbiAgICAgICAgICAgIGluc2VydChfZWwkLCBjcmVhdGVDb21wb25lbnQoTWVudUJ1dHRvblN0eWxlZCwge1xuICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBvbkNvcHkoKSxcbiAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KENvcHlJY29uLCB7fSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFpc0NvcGllZFNob3duKCk7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KE1lbnVJdGVtVGV4dCwge1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcImJ1dHRvbi5kcm9wZG93bi5jb3B5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiQ29weSBhZGRyZXNzXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzQ29waWVkU2hvd24oKTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoTWVudUl0ZW1UZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwiYnV0dG9uLmRyb3Bkb3duLmNvcGllZFwiLFxuICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkFkZHJlc3MgY29waWVkIVwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIF9lbCQ7XG4gICAgICAgICAgfSkoKSwgKCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfZWwkMiA9IF90bXBsJCQ2KCk7XG4gICAgICAgICAgICBpbnNlcnQoX2VsJDIsIGNyZWF0ZUNvbXBvbmVudChNZW51QnV0dG9uU3R5bGVkLCB7XG4gICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IG9uRGlzY29ubmVjdCgpLFxuICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoRGlzY29ubmVjdEljb24sIHt9KSwgY3JlYXRlQ29tcG9uZW50KE1lbnVJdGVtVGV4dCwge1xuICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwiYnV0dG9uLmRyb3Bkb3duLmRpc2Nvbm5lY3RcIixcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkRpc2Nvbm5lY3RcIlxuICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIF9lbCQyO1xuICAgICAgICAgIH0pKCldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IGJvcmRlcnMkMyA9IHtcbiAgbTogXCIxNnB4XCIsXG4gIHM6IFwiOHB4XCIsXG4gIG5vbmU6IFwiMFwiXG59O1xuY29uc3QgTm90aWZpY2F0aW9uU3R5bGVkID0gc3R5bGVkLmRpdmBcbiAgICB3aWR0aDogMjU2cHg7XG4gICAgcGFkZGluZzogMTJweCAxNnB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZ2FwOiA5cHg7XG5cbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmJhY2tncm91bmQucHJpbWFyeX07XG4gICAgYm94LXNoYWRvdzogMCA0cHggMjRweCByZ2JhKDAsIDAsIDAsIDAuMTYpO1xuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiBib3JkZXJzJDNbcHJvcHMudGhlbWUuYm9yZGVyUmFkaXVzXX07XG5gO1xuY29uc3QgTm90aWZpY2F0aW9uQ29udGVudFN0eWxlZCA9IHN0eWxlZC5kaXZgXG4gICAgd2lkdGg6IDE5MnB4O1xuXG4gICAgPiBoMyB7XG4gICAgICAgIGZvbnQtc2l6ZTogMTVweDtcbiAgICB9XG5gO1xuY29uc3QgVGV4dFN0eWxlZCQzID0gc3R5bGVkKFRleHQpYFxuICAgIG1hcmdpbi10b3A6IDRweDtcbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeX07XG5gO1xuY29uc3QgTm90aWZpY2F0aW9uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IGRhdGFBdHRycyA9IHVzZURhdGFBdHRyaWJ1dGVzKHByb3BzKTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChOb3RpZmljYXRpb25TdHlsZWQsIG1lcmdlUHJvcHMoe1xuICAgIGdldCBbXCJjbGFzc1wiXSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5jbGFzcztcbiAgICB9LFxuICAgIFwiZGF0YS10Yy1ub3RpZmljYXRpb25cIjogXCJ0cnVlXCJcbiAgfSwgZGF0YUF0dHJzLCB7XG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoTm90aWZpY2F0aW9uQ29udGVudFN0eWxlZCwge1xuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoSDMsIHtcbiAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvbktleSgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLmhlYWRlci50cmFuc2xhdGlvbktleTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgdHJhbnNsYXRpb25WYWx1ZXMoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wcy5oZWFkZXIudHJhbnNsYXRpb25WYWx1ZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLnRleHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRleHRTdHlsZWQkMywge1xuICAgICAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvbktleSgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy50ZXh0LnRyYW5zbGF0aW9uS2V5O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLnRleHQudHJhbnNsYXRpb25WYWx1ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KV07XG4gICAgICAgIH1cbiAgICAgIH0pLCBtZW1vKCgpID0+IHByb3BzLmljb24pXTtcbiAgICB9XG4gIH0pKTtcbn07XG5jb25zdCBMb2FkZXJJY29uU3R5bGVkJDIgPSBzdHlsZWQoTG9hZGVySWNvbilgXG4gICAgYWxpZ24tc2VsZjogY2VudGVyO1xuYDtcbmNvbnN0IENvbmZpcm1PcGVyYXRpb25Ob3RpZmljYXRpb24gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdG9uQ29ubmVjdFVJID0gdXNlQ29udGV4dChUb25Db25uZWN0VWlDb250ZXh0KTtcbiAgY29uc3QgW3QyXSA9IHVzZUkxOG4oKTtcbiAgY29uc3QgbmFtZSA9ICgpID0+IHRvbkNvbm5lY3RVSS53YWxsZXQgJiYgXCJuYW1lXCIgaW4gdG9uQ29ubmVjdFVJLndhbGxldCA/IHRvbkNvbm5lY3RVSS53YWxsZXQubmFtZSA6IHQyKFwiY29tbW9uLnlvdXJXYWxsZXRcIiwge30sIFwiWW91ciB3YWxsZXRcIik7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoTm90aWZpY2F0aW9uLCB7XG4gICAgZ2V0IGhlYWRlcigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIm5vdGlmaWNhdGlvbnMuY29uZmlybS5oZWFkZXJcIixcbiAgICAgICAgdHJhbnNsYXRpb25WYWx1ZXM6IHtcbiAgICAgICAgICBuYW1lOiBuYW1lKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldCBbXCJjbGFzc1wiXSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5jbGFzcztcbiAgICB9LFxuICAgIGdldCBpY29uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChMb2FkZXJJY29uU3R5bGVkJDIsIHt9KTtcbiAgICB9LFxuICAgIFwiZGF0YS10Yy1ub3RpZmljYXRpb24tY29uZmlybVwiOiBcInRydWVcIixcbiAgICBjaGlsZHJlbjogXCJDb25maXJtIG9wZXJhdGlvbiBpbiB5b3VyIHdhbGxldFwiXG4gIH0pO1xufTtcbmNvbnN0IEVycm9ySWNvblN0eWxlZCQ0ID0gc3R5bGVkKEVycm9ySWNvbilgXG4gICAgbWFyZ2luLXRvcDogMnB4O1xuYDtcbmNvbnN0IEVycm9yVHJhbnNhY3Rpb25Ob3RpZmljYXRpb24gPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChOb3RpZmljYXRpb24sIHtcbiAgICBoZWFkZXI6IHtcbiAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIm5vdGlmaWNhdGlvbnMudHJhbnNhY3Rpb25DYW5jZWxlZC5oZWFkZXJcIlxuICAgIH0sXG4gICAgdGV4dDoge1xuICAgICAgdHJhbnNsYXRpb25LZXk6IFwibm90aWZpY2F0aW9ucy50cmFuc2FjdGlvbkNhbmNlbGVkLnRleHRcIlxuICAgIH0sXG4gICAgZ2V0IGljb24oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEVycm9ySWNvblN0eWxlZCQ0LCB7XG4gICAgICAgIHNpemU6IFwieHNcIlxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQgW1wiY2xhc3NcIl0oKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2xhc3M7XG4gICAgfSxcbiAgICBcImRhdGEtdGMtbm90aWZpY2F0aW9uLXR4LWNhbmNlbGxlZFwiOiBcInRydWVcIixcbiAgICBjaGlsZHJlbjogXCJUcmFuc2FjdGlvbiBjYW5jZWxsZWRcIlxuICB9KTtcbn07XG5jb25zdCBTdWNjZXNzSWNvblN0eWxlZCA9IHN0eWxlZChTdWNjZXNzSWNvbilgXG4gICAgbWFyZ2luLXRvcDogMnB4O1xuYDtcbmNvbnN0IFN1Y2Nlc3NUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbiA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KE5vdGlmaWNhdGlvbiwge1xuICAgIGhlYWRlcjoge1xuICAgICAgdHJhbnNsYXRpb25LZXk6IFwibm90aWZpY2F0aW9ucy50cmFuc2FjdGlvblNlbnQuaGVhZGVyXCJcbiAgICB9LFxuICAgIHRleHQ6IHtcbiAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIm5vdGlmaWNhdGlvbnMudHJhbnNhY3Rpb25TZW50LnRleHRcIlxuICAgIH0sXG4gICAgZ2V0IGljb24oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFN1Y2Nlc3NJY29uU3R5bGVkLCB7fSk7XG4gICAgfSxcbiAgICBnZXQgW1wiY2xhc3NcIl0oKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2xhc3M7XG4gICAgfSxcbiAgICBcImRhdGEtdGMtbm90aWZpY2F0aW9uLXR4LXNlbnRcIjogXCJ0cnVlXCIsXG4gICAgY2hpbGRyZW46IFwiVHJhbnNhY3Rpb24gc2VudFwiXG4gIH0pO1xufTtcbmNvbnN0IE5vdGlmaWNhdGlvbkNsYXNzID0gdWBcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLThweCk7XG4gICAgbWFyZ2luLWJvdHRvbTogMTJweDtcbmA7XG5jb25zdCBkZWZhdWx0Q29uZmlnID0ge1xuICB0aW1lb3V0OiA0NTAwXG59O1xuY29uc3QgW2xhdGVzdEFjdGlvbiwgc2V0TGF0ZXN0QWN0aW9uXSA9IGNyZWF0ZVNpZ25hbChudWxsKTtcbmZ1bmN0aW9uIHVzZU9wZW5lZE5vdGlmaWNhdGlvbnMoY29uZmlnKSB7XG4gIGNvbnN0IHsgdGltZW91dCB9ID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGRlZmF1bHRDb25maWcpLCBjb25maWcpO1xuICBjb25zdCBbb3BlbmVkTm90aWZpY2F0aW9ucywgc2V0T3BlbmVkTm90aWZpY2F0aW9uc10gPSBjcmVhdGVTaWduYWwoW10pO1xuICBjb25zdCBbdGltZW91dElkcywgc2V0VGltZW91dElkc10gPSBjcmVhdGVTaWduYWwoW10pO1xuICBjcmVhdGVFZmZlY3QoXG4gICAgb24oYWN0aW9uLCAoYWN0aW9uMikgPT4ge1xuICAgICAgdmFyIF9hMiwgX2IyO1xuICAgICAgaWYgKCFhY3Rpb24yIHx8ICFhY3Rpb24yLnNob3dOb3RpZmljYXRpb24pIHtcbiAgICAgICAgc2V0T3BlbmVkTm90aWZpY2F0aW9ucyhcbiAgICAgICAgICAob3BlbmVkTm90aWZpY2F0aW9uczIpID0+IG9wZW5lZE5vdGlmaWNhdGlvbnMyLmZpbHRlcigobjIpID0+IG4yLmFjdGlvbiAhPT0gXCJjb25maXJtLXRyYW5zYWN0aW9uXCIpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChsYXRlc3RBY3Rpb24oKSA9PT0gYWN0aW9uMikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpc0NvbmZpcm1UcmFuc2FjdGlvbkFjdGlvbiA9ICgoX2EyID0gbGF0ZXN0QWN0aW9uKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubmFtZSkgPT09IFwiY29uZmlybS10cmFuc2FjdGlvblwiICYmIGFjdGlvbjIubmFtZSA9PT0gXCJjb25maXJtLXRyYW5zYWN0aW9uXCI7XG4gICAgICBjb25zdCBpc0NvbmZpcm1TaWduRGF0YUFjdGlvbiA9ICgoX2IyID0gbGF0ZXN0QWN0aW9uKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYjIubmFtZSkgPT09IFwiY29uZmlybS1zaWduLWRhdGFcIiAmJiBhY3Rpb24yLm5hbWUgPT09IFwiY29uZmlybS1zaWduLWRhdGFcIjtcbiAgICAgIGlmIChpc0NvbmZpcm1UcmFuc2FjdGlvbkFjdGlvbiB8fCBpc0NvbmZpcm1TaWduRGF0YUFjdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRMYXRlc3RBY3Rpb24oYWN0aW9uMik7XG4gICAgICBzZXRPcGVuZWROb3RpZmljYXRpb25zKFxuICAgICAgICAob3BlbmVkTm90aWZpY2F0aW9uczIpID0+IG9wZW5lZE5vdGlmaWNhdGlvbnMyLmZpbHRlcihcbiAgICAgICAgICAobjIpID0+IG4yLmFjdGlvbiAhPT0gXCJjb25maXJtLXRyYW5zYWN0aW9uXCIgJiYgbjIuYWN0aW9uICE9PSBcImNvbmZpcm0tc2lnbi1kYXRhXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IHsgYWN0aW9uOiBhY3Rpb24yLm5hbWUgfTtcbiAgICAgIHNldE9wZW5lZE5vdGlmaWNhdGlvbnMoKG9wZW5lZE5vdGlmaWNhdGlvbnMyKSA9PiBbLi4ub3BlbmVkTm90aWZpY2F0aW9uczIsIG5vdGlmaWNhdGlvbl0pO1xuICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHNldE9wZW5lZE5vdGlmaWNhdGlvbnMoXG4gICAgICAgICAgKG9wZW5lZE5vdGlmaWNhdGlvbnMyKSA9PiBvcGVuZWROb3RpZmljYXRpb25zMi5maWx0ZXIoKG4yKSA9PiBuMiAhPT0gbm90aWZpY2F0aW9uKVxuICAgICAgICApO1xuICAgICAgICBzZXRUaW1lb3V0SWRzKCh0aW1lb3V0SWRzMikgPT4gdGltZW91dElkczIuZmlsdGVyKChpZCkgPT4gaWQgIT09IHRpbWVvdXRJZCkpO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgICBzZXRUaW1lb3V0SWRzKCh0aW1lb3V0SWRzMikgPT4gWy4uLnRpbWVvdXRJZHMyLCB0aW1lb3V0SWRdKTtcbiAgICB9KVxuICApO1xuICBvbkNsZWFudXAoKCkgPT4ge1xuICAgIHRpbWVvdXRJZHMoKS5mb3JFYWNoKChpZCkgPT4gY2xlYXJUaW1lb3V0KGlkKSk7XG4gIH0pO1xuICByZXR1cm4gb3BlbmVkTm90aWZpY2F0aW9ucztcbn1cbmNvbnN0IEVycm9ySWNvblN0eWxlZCQzID0gc3R5bGVkKEVycm9ySWNvbilgXG4gICAgbWFyZ2luLXRvcDogMnB4O1xuYDtcbmNvbnN0IEVycm9yU2lnbkRhdGFOb3RpZmljYXRpb24gPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChOb3RpZmljYXRpb24sIHtcbiAgICBoZWFkZXI6IHtcbiAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIm5vdGlmaWNhdGlvbnMuc2lnbkRhdGFDYW5jZWxlZC5oZWFkZXJcIlxuICAgIH0sXG4gICAgZ2V0IGljb24oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEVycm9ySWNvblN0eWxlZCQzLCB7XG4gICAgICAgIHNpemU6IFwieHNcIlxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQgW1wiY2xhc3NcIl0oKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2xhc3M7XG4gICAgfSxcbiAgICBcImRhdGEtdGMtbm90aWZpY2F0aW9uLXNpZ24tZGF0YS1jYW5jZWxsZWRcIjogXCJ0cnVlXCIsXG4gICAgY2hpbGRyZW46IFwiU2lnbiBkYXRhIGNhbmNlbGVkXCJcbiAgfSk7XG59O1xuY29uc3QgU3VjY2Vzc1NpZ25EYXRhTm90aWZpY2F0aW9uID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoTm90aWZpY2F0aW9uLCB7XG4gICAgaGVhZGVyOiB7XG4gICAgICB0cmFuc2xhdGlvbktleTogXCJub3RpZmljYXRpb25zLmRhdGFTaWduZWQuaGVhZGVyXCJcbiAgICB9LFxuICAgIGdldCBpY29uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChTdWNjZXNzSWNvblN0eWxlZCwge30pO1xuICAgIH0sXG4gICAgZ2V0IFtcImNsYXNzXCJdKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgIH0sXG4gICAgXCJkYXRhLXRjLW5vdGlmaWNhdGlvbi1kYXRhLXNpZ25lZFwiOiBcInRydWVcIixcbiAgICBjaGlsZHJlbjogXCJEYXRhIHNpZ25lZFwiXG4gIH0pO1xufTtcbnZhciBfdG1wbCQkNSA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8ZGl2IGRhdGEtdGMtbGlzdC1ub3RpZmljYXRpb25zPXRydWU+YCk7XG5jb25zdCBOb3RpZmljYXRpb25zID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IG9wZW5lZE5vdGlmaWNhdGlvbnMgPSB1c2VPcGVuZWROb3RpZmljYXRpb25zKCk7XG4gIHJldHVybiAoKCkgPT4ge1xuICAgIHZhciBfZWwkID0gX3RtcGwkJDUoKTtcbiAgICBpbnNlcnQoX2VsJCwgY3JlYXRlQ29tcG9uZW50KFRyYW5zaXRpb25Hcm91cCwge1xuICAgICAgb25CZWZvcmVFbnRlcjogKGVsKSA9PiB7XG4gICAgICAgIGFuaW1hdGUoZWwsIFt7XG4gICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSgwKVwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVZKC04cHgpXCJcbiAgICAgICAgfV0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogMjAwXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG9uRXhpdDogKGVsLCBkb25lKSA9PiB7XG4gICAgICAgIGNvbnN0IGEyID0gYW5pbWF0ZShlbCwgW3tcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVZKC04cHgpXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoLTMwcHgpXCJcbiAgICAgICAgfV0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogMjAwXG4gICAgICAgIH0pO1xuICAgICAgICBhMi5maW5pc2hlZC50aGVuKGRvbmUpO1xuICAgICAgfSxcbiAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChGb3IsIHtcbiAgICAgICAgICBnZXQgZWFjaCgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcGVuZWROb3RpZmljYXRpb25zKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGlsZHJlbjogKG9wZW5lZE5vdGlmaWNhdGlvbikgPT4gY3JlYXRlQ29tcG9uZW50KFN3aXRjaCwge1xuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZW5lZE5vdGlmaWNhdGlvbi5hY3Rpb24gPT09IFwidHJhbnNhY3Rpb24tc2VudFwiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChTdWNjZXNzVHJhbnNhY3Rpb25Ob3RpZmljYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgXCJjbGFzc1wiOiBOb3RpZmljYXRpb25DbGFzc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gb3BlbmVkTm90aWZpY2F0aW9uLmFjdGlvbiA9PT0gXCJ0cmFuc2FjdGlvbi1jYW5jZWxlZFwiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChFcnJvclRyYW5zYWN0aW9uTm90aWZpY2F0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIFwiY2xhc3NcIjogTm90aWZpY2F0aW9uQ2xhc3NcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZW5lZE5vdGlmaWNhdGlvbi5hY3Rpb24gPT09IFwiZGF0YS1zaWduZWRcIjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoU3VjY2Vzc1NpZ25EYXRhTm90aWZpY2F0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIFwiY2xhc3NcIjogTm90aWZpY2F0aW9uQ2xhc3NcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZW5lZE5vdGlmaWNhdGlvbi5hY3Rpb24gPT09IFwic2lnbi1kYXRhLWNhbmNlbGVkXCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEVycm9yU2lnbkRhdGFOb3RpZmljYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgXCJjbGFzc1wiOiBOb3RpZmljYXRpb25DbGFzc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gb3BlbmVkTm90aWZpY2F0aW9uLmFjdGlvbiA9PT0gXCJjb25maXJtLXRyYW5zYWN0aW9uXCIgfHwgb3BlbmVkTm90aWZpY2F0aW9uLmFjdGlvbiA9PT0gXCJjb25maXJtLXNpZ24tZGF0YVwiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChDb25maXJtT3BlcmF0aW9uTm90aWZpY2F0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIFwiY2xhc3NcIjogTm90aWZpY2F0aW9uQ2xhc3NcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKCkgPT4gY2xhc3NOYW1lKF9lbCQsIHByb3BzLmNsYXNzKSk7XG4gICAgcmV0dXJuIF9lbCQ7XG4gIH0pKCk7XG59O1xuY29uc3QgQWNjb3VudEJ1dHRvblN0eWxlZCA9IHN0eWxlZChCdXR0b24pYFxuICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuY29ubmVjdEJ1dHRvbi5iYWNrZ3JvdW5kfTtcbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5jb25uZWN0QnV0dG9uLmZvcmVncm91bmR9O1xuICAgIGJveC1zaGFkb3c6ICR7KHByb3BzKSA9PiBgMCA0cHggMjRweCAke3JnYmEocHJvcHMudGhlbWUuY29sb3JzLmNvbnN0YW50LmJsYWNrLCAwLjE2KX1gfTtcbiAgICBwYWRkaW5nOiA4cHggMTZweCA4cHggMTJweDtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBnYXA6IDRweDtcbiAgICBoZWlnaHQ6IDQwcHg7XG5gO1xuY29uc3QgRHJvcGRvd25CdXR0b25TdHlsZWQgPSBzdHlsZWQoQWNjb3VudEJ1dHRvblN0eWxlZClgXG4gICAgcGFkZGluZzogMTJweCAxNnB4O1xuICAgIG1pbi13aWR0aDogMTQ4cHg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnByaW1hcnl9O1xuYDtcbmNvbnN0IExvYWRlckJ1dHRvblN0eWxlZCQxID0gc3R5bGVkKEJ1dHRvbilgXG4gICAgbWluLXdpZHRoOiAxNDhweDtcbiAgICBoZWlnaHQ6IDQwcHg7XG5cbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmJhY2tncm91bmQucHJpbWFyeX07XG4gICAgY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuY29ubmVjdEJ1dHRvbi5mb3JlZ3JvdW5kfTtcbiAgICBib3gtc2hhZG93OiAkeyhwcm9wcykgPT4gYDAgNHB4IDI0cHggJHtyZ2JhKHByb3BzLnRoZW1lLmNvbG9ycy5jb25zdGFudC5ibGFjaywgMC4xNil9YH07XG5cbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5gO1xuY29uc3QgTG9hZGVySWNvblN0eWxlZCQxID0gc3R5bGVkKExvYWRlckljb24pYFxuICAgIGhlaWdodDogMThweDtcbiAgICB3aWR0aDogMThweDtcbmA7XG5jb25zdCBEcm9wZG93bkNvbnRhaW5lclN0eWxlZCA9IHN0eWxlZC5kaXZgXG4gICAgd2lkdGg6IGZpdC1jb250ZW50O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XG5gO1xuY29uc3QgRHJvcGRvd25TdHlsZWQgPSBzdHlsZWQoQWNjb3VudEJ1dHRvbkRyb3Bkb3duKWBcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgbWFyZ2luLXRvcDogMTJweDtcbmA7XG5jb25zdCBOb3RpZmljYXRpb25zU3R5bGVkID0gc3R5bGVkKE5vdGlmaWNhdGlvbnMpYFxuICAgID4gZGl2OmZpcnN0LWNoaWxkIHtcbiAgICAgICAgbWFyZ2luLXRvcDogMjBweDtcbiAgICB9XG5gO1xuY29uc3QgbWluID0gTWF0aC5taW47XG5jb25zdCBtYXggPSBNYXRoLm1heDtcbmNvbnN0IHJvdW5kID0gTWF0aC5yb3VuZDtcbmNvbnN0IGZsb29yID0gTWF0aC5mbG9vcjtcbmNvbnN0IGNyZWF0ZUNvb3JkcyA9ICh2KSA9PiAoe1xuICB4OiB2LFxuICB5OiB2XG59KTtcbmNvbnN0IG9wcG9zaXRlU2lkZU1hcCA9IHtcbiAgbGVmdDogXCJyaWdodFwiLFxuICByaWdodDogXCJsZWZ0XCIsXG4gIGJvdHRvbTogXCJ0b3BcIixcbiAgdG9wOiBcImJvdHRvbVwiXG59O1xuY29uc3Qgb3Bwb3NpdGVBbGlnbm1lbnRNYXAgPSB7XG4gIHN0YXJ0OiBcImVuZFwiLFxuICBlbmQ6IFwic3RhcnRcIlxufTtcbmZ1bmN0aW9uIGNsYW1wKHN0YXJ0LCB2YWx1ZSwgZW5kKSB7XG4gIHJldHVybiBtYXgoc3RhcnQsIG1pbih2YWx1ZSwgZW5kKSk7XG59XG5mdW5jdGlvbiBldmFsdWF0ZSh2YWx1ZSwgcGFyYW0pIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gdmFsdWUocGFyYW0pIDogdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRTaWRlKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KFwiLVwiKVswXTtcbn1cbmZ1bmN0aW9uIGdldEFsaWdubWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdChcIi1cIilbMV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gXCJ4XCIgPyBcInlcIiA6IFwieFwiO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0xlbmd0aChheGlzKSB7XG4gIHJldHVybiBheGlzID09PSBcInlcIiA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCI7XG59XG5jb25zdCB5QXhpc1NpZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1widG9wXCIsIFwiYm90dG9tXCJdKTtcbmZ1bmN0aW9uIGdldFNpZGVBeGlzKHBsYWNlbWVudCkge1xuICByZXR1cm4geUF4aXNTaWRlcy5oYXMoZ2V0U2lkZShwbGFjZW1lbnQpKSA/IFwieVwiIDogXCJ4XCI7XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCkge1xuICByZXR1cm4gZ2V0T3Bwb3NpdGVBeGlzKGdldFNpZGVBeGlzKHBsYWNlbWVudCkpO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKSB7XG4gIGlmIChydGwgPT09IHZvaWQgMCkge1xuICAgIHJ0bCA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnRBeGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICBjb25zdCBsZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpO1xuICBsZXQgbWFpbkFsaWdubWVudFNpZGUgPSBhbGlnbm1lbnRBeGlzID09PSBcInhcIiA/IGFsaWdubWVudCA9PT0gKHJ0bCA/IFwiZW5kXCIgOiBcInN0YXJ0XCIpID8gXCJyaWdodFwiIDogXCJsZWZ0XCIgOiBhbGlnbm1lbnQgPT09IFwic3RhcnRcIiA/IFwiYm90dG9tXCIgOiBcInRvcFwiO1xuICBpZiAocmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gPiByZWN0cy5mbG9hdGluZ1tsZW5ndGhdKSB7XG4gICAgbWFpbkFsaWdubWVudFNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluQWxpZ25tZW50U2lkZSk7XG4gIH1cbiAgcmV0dXJuIFttYWluQWxpZ25tZW50U2lkZSwgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpbkFsaWdubWVudFNpZGUpXTtcbn1cbmZ1bmN0aW9uIGdldEV4cGFuZGVkUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcbiAgY29uc3Qgb3Bwb3NpdGVQbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICByZXR1cm4gW2dldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIChhbGlnbm1lbnQpID0+IG9wcG9zaXRlQWxpZ25tZW50TWFwW2FsaWdubWVudF0pO1xufVxuY29uc3QgbHJQbGFjZW1lbnQgPSBbXCJsZWZ0XCIsIFwicmlnaHRcIl07XG5jb25zdCBybFBsYWNlbWVudCA9IFtcInJpZ2h0XCIsIFwibGVmdFwiXTtcbmNvbnN0IHRiUGxhY2VtZW50ID0gW1widG9wXCIsIFwiYm90dG9tXCJdO1xuY29uc3QgYnRQbGFjZW1lbnQgPSBbXCJib3R0b21cIiwgXCJ0b3BcIl07XG5mdW5jdGlvbiBnZXRTaWRlTGlzdChzaWRlLCBpc1N0YXJ0LCBydGwpIHtcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSBcInRvcFwiOlxuICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgIGlmIChydGwpIHJldHVybiBpc1N0YXJ0ID8gcmxQbGFjZW1lbnQgOiBsclBsYWNlbWVudDtcbiAgICAgIHJldHVybiBpc1N0YXJ0ID8gbHJQbGFjZW1lbnQgOiBybFBsYWNlbWVudDtcbiAgICBjYXNlIFwibGVmdFwiOlxuICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgcmV0dXJuIGlzU3RhcnQgPyB0YlBsYWNlbWVudCA6IGJ0UGxhY2VtZW50O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gW107XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMocGxhY2VtZW50LCBmbGlwQWxpZ25tZW50LCBkaXJlY3Rpb24sIHJ0bCkge1xuICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgbGV0IGxpc3QgPSBnZXRTaWRlTGlzdChnZXRTaWRlKHBsYWNlbWVudCksIGRpcmVjdGlvbiA9PT0gXCJzdGFydFwiLCBydGwpO1xuICBpZiAoYWxpZ25tZW50KSB7XG4gICAgbGlzdCA9IGxpc3QubWFwKChzaWRlKSA9PiBzaWRlICsgXCItXCIgKyBhbGlnbm1lbnQpO1xuICAgIGlmIChmbGlwQWxpZ25tZW50KSB7XG4gICAgICBsaXN0ID0gbGlzdC5jb25jYXQobGlzdC5tYXAoZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgKHNpZGUpID0+IG9wcG9zaXRlU2lkZU1hcFtzaWRlXSk7XG59XG5mdW5jdGlvbiBleHBhbmRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpIHtcbiAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfSwgcGFkZGluZyk7XG59XG5mdW5jdGlvbiBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBwYWRkaW5nICE9PSBcIm51bWJlclwiID8gZXhwYW5kUGFkZGluZ09iamVjdChwYWRkaW5nKSA6IHtcbiAgICB0b3A6IHBhZGRpbmcsXG4gICAgcmlnaHQ6IHBhZGRpbmcsXG4gICAgYm90dG9tOiBwYWRkaW5nLFxuICAgIGxlZnQ6IHBhZGRpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICBjb25zdCB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0gcmVjdDtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgdG9wOiB5LFxuICAgIGxlZnQ6IHgsXG4gICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICBib3R0b206IHkgKyBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5mdW5jdGlvbiBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChfcmVmLCBwbGFjZW1lbnQsIHJ0bCkge1xuICBsZXQge1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZ1xuICB9ID0gX3JlZjtcbiAgY29uc3Qgc2lkZUF4aXMgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnRBeGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbkxlbmd0aCA9IGdldEF4aXNMZW5ndGgoYWxpZ25tZW50QXhpcyk7XG4gIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBzaWRlQXhpcyA9PT0gXCJ5XCI7XG4gIGNvbnN0IGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBmbG9hdGluZy53aWR0aCAvIDI7XG4gIGNvbnN0IGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZmxvYXRpbmcuaGVpZ2h0IC8gMjtcbiAgY29uc3QgY29tbW9uQWxpZ24gPSByZWZlcmVuY2VbYWxpZ25MZW5ndGhdIC8gMiAtIGZsb2F0aW5nW2FsaWduTGVuZ3RoXSAvIDI7XG4gIGxldCBjb29yZHM7XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBmbG9hdGluZy5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZmxvYXRpbmcud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cbiAgc3dpdGNoIChnZXRBbGlnbm1lbnQocGxhY2VtZW50KSkge1xuICAgIGNhc2UgXCJzdGFydFwiOlxuICAgICAgY29vcmRzW2FsaWdubWVudEF4aXNdIC09IGNvbW1vbkFsaWduICogKHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgIGNvb3Jkc1thbGlnbm1lbnRBeGlzXSArPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gY29vcmRzO1xufVxuY29uc3QgY29tcHV0ZVBvc2l0aW9uJDEgPSAocmVmZXJlbmNlLCBmbG9hdGluZywgY29uZmlnKSA9PiBfX2FzeW5jKG51bGwsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQgPSBcImJvdHRvbVwiLFxuICAgIHN0cmF0ZWd5ID0gXCJhYnNvbHV0ZVwiLFxuICAgIG1pZGRsZXdhcmUgPSBbXSxcbiAgICBwbGF0Zm9ybTogcGxhdGZvcm0yXG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IHZhbGlkTWlkZGxld2FyZSA9IG1pZGRsZXdhcmUuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBydGwgPSB5aWVsZCBwbGF0Zm9ybTIuaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtMi5pc1JUTChmbG9hdGluZyk7XG4gIGxldCByZWN0cyA9IHlpZWxkIHBsYXRmb3JtMi5nZXRFbGVtZW50UmVjdHMoe1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZyxcbiAgICBzdHJhdGVneVxuICB9KTtcbiAgbGV0IHtcbiAgICB4LFxuICAgIHlcbiAgfSA9IGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KHJlY3RzLCBwbGFjZW1lbnQsIHJ0bCk7XG4gIGxldCBzdGF0ZWZ1bFBsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgbGV0IG1pZGRsZXdhcmVEYXRhID0ge307XG4gIGxldCByZXNldENvdW50ID0gMDtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHZhbGlkTWlkZGxld2FyZS5sZW5ndGg7IGkyKyspIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgZm5cbiAgICB9ID0gdmFsaWRNaWRkbGV3YXJlW2kyXTtcbiAgICBjb25zdCB7XG4gICAgICB4OiBuZXh0WCxcbiAgICAgIHk6IG5leHRZLFxuICAgICAgZGF0YSxcbiAgICAgIHJlc2V0XG4gICAgfSA9IHlpZWxkIGZuKHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgaW5pdGlhbFBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICAgIHN0cmF0ZWd5LFxuICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICByZWN0cyxcbiAgICAgIHBsYXRmb3JtOiBwbGF0Zm9ybTIsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgIGZsb2F0aW5nXG4gICAgICB9XG4gICAgfSk7XG4gICAgeCA9IG5leHRYICE9IG51bGwgPyBuZXh0WCA6IHg7XG4gICAgeSA9IG5leHRZICE9IG51bGwgPyBuZXh0WSA6IHk7XG4gICAgbWlkZGxld2FyZURhdGEgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBtaWRkbGV3YXJlRGF0YSksIHtcbiAgICAgIFtuYW1lXTogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIG1pZGRsZXdhcmVEYXRhW25hbWVdKSwgZGF0YSlcbiAgICB9KTtcbiAgICBpZiAocmVzZXQgJiYgcmVzZXRDb3VudCA8PSA1MCkge1xuICAgICAgcmVzZXRDb3VudCsrO1xuICAgICAgaWYgKHR5cGVvZiByZXNldCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAocmVzZXQucGxhY2VtZW50KSB7XG4gICAgICAgICAgc3RhdGVmdWxQbGFjZW1lbnQgPSByZXNldC5wbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2V0LnJlY3RzKSB7XG4gICAgICAgICAgcmVjdHMgPSByZXNldC5yZWN0cyA9PT0gdHJ1ZSA/IHlpZWxkIHBsYXRmb3JtMi5nZXRFbGVtZW50UmVjdHMoe1xuICAgICAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICAgICAgZmxvYXRpbmcsXG4gICAgICAgICAgICBzdHJhdGVneVxuICAgICAgICAgIH0pIDogcmVzZXQucmVjdHM7XG4gICAgICAgIH1cbiAgICAgICAgKHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfSA9IGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KHJlY3RzLCBzdGF0ZWZ1bFBsYWNlbWVudCwgcnRsKSk7XG4gICAgICB9XG4gICAgICBpMiA9IC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeSxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlZnVsUGxhY2VtZW50LFxuICAgIHN0cmF0ZWd5LFxuICAgIG1pZGRsZXdhcmVEYXRhXG4gIH07XG59KTtcbmZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgdmFyIF9hd2FpdCRwbGF0Zm9ybSRpc0VsZTtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcGxhdGZvcm06IHBsYXRmb3JtMixcbiAgICAgIHJlY3RzLFxuICAgICAgZWxlbWVudHMsXG4gICAgICBzdHJhdGVneVxuICAgIH0gPSBzdGF0ZTtcbiAgICBjb25zdCB7XG4gICAgICBib3VuZGFyeSA9IFwiY2xpcHBpbmdBbmNlc3RvcnNcIixcbiAgICAgIHJvb3RCb3VuZGFyeSA9IFwidmlld3BvcnRcIixcbiAgICAgIGVsZW1lbnRDb250ZXh0ID0gXCJmbG9hdGluZ1wiLFxuICAgICAgYWx0Qm91bmRhcnkgPSBmYWxzZSxcbiAgICAgIHBhZGRpbmcgPSAwXG4gICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKTtcbiAgICBjb25zdCBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09IFwiZmxvYXRpbmdcIiA/IFwicmVmZXJlbmNlXCIgOiBcImZsb2F0aW5nXCI7XG4gICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgICBjb25zdCBjbGlwcGluZ0NsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KHlpZWxkIHBsYXRmb3JtMi5nZXRDbGlwcGluZ1JlY3Qoe1xuICAgICAgZWxlbWVudDogKChfYXdhaXQkcGxhdGZvcm0kaXNFbGUgPSB5aWVsZCBwbGF0Zm9ybTIuaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybTIuaXNFbGVtZW50KGVsZW1lbnQpKSAhPSBudWxsID8gX2F3YWl0JHBsYXRmb3JtJGlzRWxlIDogdHJ1ZSkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCAoeWllbGQgcGxhdGZvcm0yLmdldERvY3VtZW50RWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0yLmdldERvY3VtZW50RWxlbWVudChlbGVtZW50cy5mbG9hdGluZykpLFxuICAgICAgYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnksXG4gICAgICBzdHJhdGVneVxuICAgIH0pKTtcbiAgICBjb25zdCByZWN0ID0gZWxlbWVudENvbnRleHQgPT09IFwiZmxvYXRpbmdcIiA/IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGg6IHJlY3RzLmZsb2F0aW5nLndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWN0cy5mbG9hdGluZy5oZWlnaHRcbiAgICB9IDogcmVjdHMucmVmZXJlbmNlO1xuICAgIGNvbnN0IG9mZnNldFBhcmVudCA9IHlpZWxkIHBsYXRmb3JtMi5nZXRPZmZzZXRQYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtMi5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudHMuZmxvYXRpbmcpO1xuICAgIGNvbnN0IG9mZnNldFNjYWxlID0gKHlpZWxkIHBsYXRmb3JtMi5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtMi5pc0VsZW1lbnQob2Zmc2V0UGFyZW50KSkgPyAoeWllbGQgcGxhdGZvcm0yLmdldFNjYWxlID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybTIuZ2V0U2NhbGUob2Zmc2V0UGFyZW50KSkgfHwge1xuICAgICAgeDogMSxcbiAgICAgIHk6IDFcbiAgICB9IDoge1xuICAgICAgeDogMSxcbiAgICAgIHk6IDFcbiAgICB9O1xuICAgIGNvbnN0IGVsZW1lbnRDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChwbGF0Zm9ybTIuY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QgPyB5aWVsZCBwbGF0Zm9ybTIuY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3Qoe1xuICAgICAgZWxlbWVudHMsXG4gICAgICByZWN0LFxuICAgICAgb2Zmc2V0UGFyZW50LFxuICAgICAgc3RyYXRlZ3lcbiAgICB9KSA6IHJlY3QpO1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IChjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3ApIC8gb2Zmc2V0U2NhbGUueSxcbiAgICAgIGJvdHRvbTogKGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSkgLyBvZmZzZXRTY2FsZS55LFxuICAgICAgbGVmdDogKGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCkgLyBvZmZzZXRTY2FsZS54LFxuICAgICAgcmlnaHQ6IChlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHQpIC8gb2Zmc2V0U2NhbGUueFxuICAgIH07XG4gIH0pO1xufVxuY29uc3QgZmxpcCQxID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogXCJmbGlwXCIsXG4gICAgb3B0aW9ucyxcbiAgICBmbihzdGF0ZSkge1xuICAgICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRhcnJvdywgX21pZGRsZXdhcmVEYXRhJGZsaXA7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICAgICAgcmVjdHMsXG4gICAgICAgICAgaW5pdGlhbFBsYWNlbWVudCxcbiAgICAgICAgICBwbGF0Zm9ybTogcGxhdGZvcm0yLFxuICAgICAgICAgIGVsZW1lbnRzXG4gICAgICAgIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgX2EzID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpLCB7XG4gICAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSB0cnVlLFxuICAgICAgICAgIGZhbGxiYWNrUGxhY2VtZW50czogc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgICAgIGZhbGxiYWNrU3RyYXRlZ3kgPSBcImJlc3RGaXRcIixcbiAgICAgICAgICBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uID0gXCJub25lXCIsXG4gICAgICAgICAgZmxpcEFsaWdubWVudCA9IHRydWVcbiAgICAgICAgfSA9IF9hMywgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zID0gX19vYmpSZXN0KF9hMywgW1xuICAgICAgICAgIFwibWFpbkF4aXNcIixcbiAgICAgICAgICBcImNyb3NzQXhpc1wiLFxuICAgICAgICAgIFwiZmFsbGJhY2tQbGFjZW1lbnRzXCIsXG4gICAgICAgICAgXCJmYWxsYmFja1N0cmF0ZWd5XCIsXG4gICAgICAgICAgXCJmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uXCIsXG4gICAgICAgICAgXCJmbGlwQWxpZ25tZW50XCJcbiAgICAgICAgXSk7XG4gICAgICAgIGlmICgoX21pZGRsZXdhcmVEYXRhJGFycm93ID0gbWlkZGxld2FyZURhdGEuYXJyb3cpICE9IG51bGwgJiYgX21pZGRsZXdhcmVEYXRhJGFycm93LmFsaWdubWVudE9mZnNldCkge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICAgICAgICBjb25zdCBpbml0aWFsU2lkZUF4aXMgPSBnZXRTaWRlQXhpcyhpbml0aWFsUGxhY2VtZW50KTtcbiAgICAgICAgY29uc3QgaXNCYXNlUGxhY2VtZW50ID0gZ2V0U2lkZShpbml0aWFsUGxhY2VtZW50KSA9PT0gaW5pdGlhbFBsYWNlbWVudDtcbiAgICAgICAgY29uc3QgcnRsID0geWllbGQgcGxhdGZvcm0yLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybTIuaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpO1xuICAgICAgICBjb25zdCBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcEFsaWdubWVudCA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChpbml0aWFsUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZFBsYWNlbWVudHMoaW5pdGlhbFBsYWNlbWVudCkpO1xuICAgICAgICBjb25zdCBoYXNGYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uID0gZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiAhPT0gXCJub25lXCI7XG4gICAgICAgIGlmICghc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzICYmIGhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24pIHtcbiAgICAgICAgICBmYWxsYmFja1BsYWNlbWVudHMucHVzaCguLi5nZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzKGluaXRpYWxQbGFjZW1lbnQsIGZsaXBBbGlnbm1lbnQsIGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24sIHJ0bCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBsYWNlbWVudHMgPSBbaW5pdGlhbFBsYWNlbWVudCwgLi4uZmFsbGJhY2tQbGFjZW1lbnRzXTtcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSB5aWVsZCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3dzID0gW107XG4gICAgICAgIGxldCBvdmVyZmxvd3NEYXRhID0gKChfbWlkZGxld2FyZURhdGEkZmxpcCA9IG1pZGRsZXdhcmVEYXRhLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkZmxpcC5vdmVyZmxvd3MpIHx8IFtdO1xuICAgICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICAgIG92ZXJmbG93cy5wdXNoKG92ZXJmbG93W3NpZGVdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgICBjb25zdCBzaWRlcyA9IGdldEFsaWdubWVudFNpZGVzKHBsYWNlbWVudCwgcmVjdHMsIHJ0bCk7XG4gICAgICAgICAgb3ZlcmZsb3dzLnB1c2gob3ZlcmZsb3dbc2lkZXNbMF1dLCBvdmVyZmxvd1tzaWRlc1sxXV0pO1xuICAgICAgICB9XG4gICAgICAgIG92ZXJmbG93c0RhdGEgPSBbLi4ub3ZlcmZsb3dzRGF0YSwge1xuICAgICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgICBvdmVyZmxvd3NcbiAgICAgICAgfV07XG4gICAgICAgIGlmICghb3ZlcmZsb3dzLmV2ZXJ5KChzaWRlMikgPT4gc2lkZTIgPD0gMCkpIHtcbiAgICAgICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJGZsaXAyLCBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXI7XG4gICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gKCgoX21pZGRsZXdhcmVEYXRhJGZsaXAyID0gbWlkZGxld2FyZURhdGEuZmxpcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRmbGlwMi5pbmRleCkgfHwgMCkgKyAxO1xuICAgICAgICAgIGNvbnN0IG5leHRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzW25leHRJbmRleF07XG4gICAgICAgICAgaWYgKG5leHRQbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGlnbm9yZUNyb3NzQXhpc092ZXJmbG93ID0gY2hlY2tDcm9zc0F4aXMgPT09IFwiYWxpZ25tZW50XCIgPyBpbml0aWFsU2lkZUF4aXMgIT09IGdldFNpZGVBeGlzKG5leHRQbGFjZW1lbnQpIDogZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWlnbm9yZUNyb3NzQXhpc092ZXJmbG93IHx8IC8vIFdlIGxlYXZlIHRoZSBjdXJyZW50IG1haW4gYXhpcyBvbmx5IGlmIGV2ZXJ5IHBsYWNlbWVudCBvbiB0aGF0IGF4aXNcbiAgICAgICAgICAgIC8vIG92ZXJmbG93cyB0aGUgbWFpbiBheGlzLlxuICAgICAgICAgICAgb3ZlcmZsb3dzRGF0YS5ldmVyeSgoZCkgPT4gZ2V0U2lkZUF4aXMoZC5wbGFjZW1lbnQpID09PSBpbml0aWFsU2lkZUF4aXMgPyBkLm92ZXJmbG93c1swXSA+IDAgOiB0cnVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgIGluZGV4OiBuZXh0SW5kZXgsXG4gICAgICAgICAgICAgICAgICBvdmVyZmxvd3M6IG92ZXJmbG93c0RhdGFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCByZXNldFBsYWNlbWVudCA9IChfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIgPSBvdmVyZmxvd3NEYXRhLmZpbHRlcigoZCkgPT4gZC5vdmVyZmxvd3NbMF0gPD0gMCkuc29ydCgoYTIsIGIpID0+IGEyLm92ZXJmbG93c1sxXSAtIGIub3ZlcmZsb3dzWzFdKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vdmVyZmxvd3NEYXRhJGZpbHRlci5wbGFjZW1lbnQ7XG4gICAgICAgICAgaWYgKCFyZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgICAgc3dpdGNoIChmYWxsYmFja1N0cmF0ZWd5KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJiZXN0Rml0XCI6IHtcbiAgICAgICAgICAgICAgICB2YXIgX292ZXJmbG93c0RhdGEkZmlsdGVyMjtcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZW1lbnQyID0gKF9vdmVyZmxvd3NEYXRhJGZpbHRlcjIgPSBvdmVyZmxvd3NEYXRhLmZpbHRlcigoZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNpZGVBeGlzID0gZ2V0U2lkZUF4aXMoZC5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFNpZGVBeGlzID09PSBpbml0aWFsU2lkZUF4aXMgfHwgLy8gQ3JlYXRlIGEgYmlhcyB0byB0aGUgYHlgIHNpZGUgYXhpcyBkdWUgdG8gaG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICAvLyByZWFkaW5nIGRpcmVjdGlvbnMgZmF2b3JpbmcgZ3JlYXRlciB3aWR0aC5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNpZGVBeGlzID09PSBcInlcIjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0pLm1hcCgoZCkgPT4gW2QucGxhY2VtZW50LCBkLm92ZXJmbG93cy5maWx0ZXIoKG92ZXJmbG93MikgPT4gb3ZlcmZsb3cyID4gMCkucmVkdWNlKChhY2MsIG92ZXJmbG93MikgPT4gYWNjICsgb3ZlcmZsb3cyLCAwKV0pLnNvcnQoKGEyLCBiKSA9PiBhMlsxXSAtIGJbMV0pWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX292ZXJmbG93c0RhdGEkZmlsdGVyMlswXTtcbiAgICAgICAgICAgICAgICBpZiAocGxhY2VtZW50Mikge1xuICAgICAgICAgICAgICAgICAgcmVzZXRQbGFjZW1lbnQgPSBwbGFjZW1lbnQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwiaW5pdGlhbFBsYWNlbWVudFwiOlxuICAgICAgICAgICAgICAgIHJlc2V0UGxhY2VtZW50ID0gaW5pdGlhbFBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBsYWNlbWVudCAhPT0gcmVzZXRQbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50OiByZXNldFBsYWNlbWVudFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59O1xuY29uc3Qgc2hpZnQkMSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6IFwic2hpZnRcIixcbiAgICBvcHRpb25zLFxuICAgIGZuKHN0YXRlKSB7XG4gICAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgeCxcbiAgICAgICAgICB5LFxuICAgICAgICAgIHBsYWNlbWVudFxuICAgICAgICB9ID0gc3RhdGU7XG4gICAgICAgIGNvbnN0IF9hMyA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKSwge1xuICAgICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gZmFsc2UsXG4gICAgICAgICAgbGltaXRlciA9IHtcbiAgICAgICAgICAgIGZuOiAoX3JlZikgPT4ge1xuICAgICAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgICAgIHg6IHgyLFxuICAgICAgICAgICAgICAgIHk6IHkyXG4gICAgICAgICAgICAgIH0gPSBfcmVmO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHgyLFxuICAgICAgICAgICAgICAgIHk6IHkyXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9ID0gX2EzLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMgPSBfX29ialJlc3QoX2EzLCBbXG4gICAgICAgICAgXCJtYWluQXhpc1wiLFxuICAgICAgICAgIFwiY3Jvc3NBeGlzXCIsXG4gICAgICAgICAgXCJsaW1pdGVyXCJcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSB5aWVsZCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0U2lkZUF4aXMoZ2V0U2lkZShwbGFjZW1lbnQpKTtcbiAgICAgICAgY29uc3QgbWFpbkF4aXMgPSBnZXRPcHBvc2l0ZUF4aXMoY3Jvc3NBeGlzKTtcbiAgICAgICAgbGV0IG1haW5BeGlzQ29vcmQgPSBjb29yZHNbbWFpbkF4aXNdO1xuICAgICAgICBsZXQgY3Jvc3NBeGlzQ29vcmQgPSBjb29yZHNbY3Jvc3NBeGlzXTtcbiAgICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgICBjb25zdCBtaW5TaWRlID0gbWFpbkF4aXMgPT09IFwieVwiID8gXCJ0b3BcIiA6IFwibGVmdFwiO1xuICAgICAgICAgIGNvbnN0IG1heFNpZGUgPSBtYWluQXhpcyA9PT0gXCJ5XCIgPyBcImJvdHRvbVwiIDogXCJyaWdodFwiO1xuICAgICAgICAgIGNvbnN0IG1pbjIgPSBtYWluQXhpc0Nvb3JkICsgb3ZlcmZsb3dbbWluU2lkZV07XG4gICAgICAgICAgY29uc3QgbWF4MiA9IG1haW5BeGlzQ29vcmQgLSBvdmVyZmxvd1ttYXhTaWRlXTtcbiAgICAgICAgICBtYWluQXhpc0Nvb3JkID0gY2xhbXAobWluMiwgbWFpbkF4aXNDb29yZCwgbWF4Mik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgICAgY29uc3QgbWluU2lkZSA9IGNyb3NzQXhpcyA9PT0gXCJ5XCIgPyBcInRvcFwiIDogXCJsZWZ0XCI7XG4gICAgICAgICAgY29uc3QgbWF4U2lkZSA9IGNyb3NzQXhpcyA9PT0gXCJ5XCIgPyBcImJvdHRvbVwiIDogXCJyaWdodFwiO1xuICAgICAgICAgIGNvbnN0IG1pbjIgPSBjcm9zc0F4aXNDb29yZCArIG92ZXJmbG93W21pblNpZGVdO1xuICAgICAgICAgIGNvbnN0IG1heDIgPSBjcm9zc0F4aXNDb29yZCAtIG92ZXJmbG93W21heFNpZGVdO1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gY2xhbXAobWluMiwgY3Jvc3NBeGlzQ29vcmQsIG1heDIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbWl0ZWRDb29yZHMgPSBsaW1pdGVyLmZuKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHN0YXRlKSwge1xuICAgICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgICAgW2Nyb3NzQXhpc106IGNyb3NzQXhpc0Nvb3JkXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGxpbWl0ZWRDb29yZHMpLCB7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgeDogbGltaXRlZENvb3Jkcy54IC0geCxcbiAgICAgICAgICAgIHk6IGxpbWl0ZWRDb29yZHMueSAtIHksXG4gICAgICAgICAgICBlbmFibGVkOiB7XG4gICAgICAgICAgICAgIFttYWluQXhpc106IGNoZWNrTWFpbkF4aXMsXG4gICAgICAgICAgICAgIFtjcm9zc0F4aXNdOiBjaGVja0Nyb3NzQXhpc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59O1xuZnVuY3Rpb24gaGFzV2luZG93KCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn1cbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG5vZGUpIHtcbiAgaWYgKGlzTm9kZShub2RlKSkge1xuICAgIHJldHVybiAobm9kZS5ub2RlTmFtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIHJldHVybiBcIiNkb2N1bWVudFwiO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgdmFyIF9ub2RlJG93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiAobm9kZSA9PSBudWxsIHx8IChfbm9kZSRvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgfHwgd2luZG93O1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KG5vZGUpIHtcbiAgdmFyIF9yZWY7XG4gIHJldHVybiAoX3JlZiA9IChpc05vZGUobm9kZSkgPyBub2RlLm93bmVyRG9jdW1lbnQgOiBub2RlLmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVmLmRvY3VtZW50RWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzTm9kZSh2YWx1ZSkge1xuICBpZiAoIWhhc1dpbmRvdygpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE5vZGUgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLk5vZGU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5FbGVtZW50O1xufVxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudCh2YWx1ZSkge1xuICBpZiAoIWhhc1dpbmRvdygpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5IVE1MRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdCh2YWx1ZSkge1xuICBpZiAoIWhhc1dpbmRvdygpIHx8IHR5cGVvZiBTaGFkb3dSb290ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLlNoYWRvd1Jvb3Q7XG59XG5jb25zdCBpbnZhbGlkT3ZlcmZsb3dEaXNwbGF5VmFsdWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiaW5saW5lXCIsIFwiY29udGVudHNcIl0pO1xuZnVuY3Rpb24gaXNPdmVyZmxvd0VsZW1lbnQoZWxlbWVudCkge1xuICBjb25zdCB7XG4gICAgb3ZlcmZsb3csXG4gICAgb3ZlcmZsb3dYLFxuICAgIG92ZXJmbG93WSxcbiAgICBkaXNwbGF5XG4gIH0gPSBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCk7XG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW58Y2xpcC8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkgJiYgIWludmFsaWRPdmVyZmxvd0Rpc3BsYXlWYWx1ZXMuaGFzKGRpc3BsYXkpO1xufVxuY29uc3QgdGFibGVFbGVtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRhYmxlXCIsIFwidGRcIiwgXCJ0aFwiXSk7XG5mdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiB0YWJsZUVsZW1lbnRzLmhhcyhnZXROb2RlTmFtZShlbGVtZW50KSk7XG59XG5jb25zdCB0b3BMYXllclNlbGVjdG9ycyA9IFtcIjpwb3BvdmVyLW9wZW5cIiwgXCI6bW9kYWxcIl07XG5mdW5jdGlvbiBpc1RvcExheWVyKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHRvcExheWVyU2VsZWN0b3JzLnNvbWUoKHNlbGVjdG9yKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgIH0gY2F0Y2ggKF9lMikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG59XG5jb25zdCB0cmFuc2Zvcm1Qcm9wZXJ0aWVzID0gW1widHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlXCIsIFwic2NhbGVcIiwgXCJyb3RhdGVcIiwgXCJwZXJzcGVjdGl2ZVwiXTtcbmNvbnN0IHdpbGxDaGFuZ2VWYWx1ZXMgPSBbXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGVcIiwgXCJzY2FsZVwiLCBcInJvdGF0ZVwiLCBcInBlcnNwZWN0aXZlXCIsIFwiZmlsdGVyXCJdO1xuY29uc3QgY29udGFpblZhbHVlcyA9IFtcInBhaW50XCIsIFwibGF5b3V0XCIsIFwic3RyaWN0XCIsIFwiY29udGVudFwiXTtcbmZ1bmN0aW9uIGlzQ29udGFpbmluZ0Jsb2NrKGVsZW1lbnRPckNzcykge1xuICBjb25zdCB3ZWJraXQgPSBpc1dlYktpdCgpO1xuICBjb25zdCBjc3MgPSBpc0VsZW1lbnQoZWxlbWVudE9yQ3NzKSA/IGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50T3JDc3MpIDogZWxlbWVudE9yQ3NzO1xuICByZXR1cm4gdHJhbnNmb3JtUHJvcGVydGllcy5zb21lKCh2YWx1ZSkgPT4gY3NzW3ZhbHVlXSA/IGNzc1t2YWx1ZV0gIT09IFwibm9uZVwiIDogZmFsc2UpIHx8IChjc3MuY29udGFpbmVyVHlwZSA/IGNzcy5jb250YWluZXJUeXBlICE9PSBcIm5vcm1hbFwiIDogZmFsc2UpIHx8ICF3ZWJraXQgJiYgKGNzcy5iYWNrZHJvcEZpbHRlciA/IGNzcy5iYWNrZHJvcEZpbHRlciAhPT0gXCJub25lXCIgOiBmYWxzZSkgfHwgIXdlYmtpdCAmJiAoY3NzLmZpbHRlciA/IGNzcy5maWx0ZXIgIT09IFwibm9uZVwiIDogZmFsc2UpIHx8IHdpbGxDaGFuZ2VWYWx1ZXMuc29tZSgodmFsdWUpID0+IChjc3Mud2lsbENoYW5nZSB8fCBcIlwiKS5pbmNsdWRlcyh2YWx1ZSkpIHx8IGNvbnRhaW5WYWx1ZXMuc29tZSgodmFsdWUpID0+IChjc3MuY29udGFpbiB8fCBcIlwiKS5pbmNsdWRlcyh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgbGV0IGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgaWYgKGlzQ29udGFpbmluZ0Jsb2NrKGN1cnJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSBpZiAoaXNUb3BMYXllcihjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNXZWJLaXQoKSB7XG4gIGlmICh0eXBlb2YgQ1NTID09PSBcInVuZGVmaW5lZFwiIHx8ICFDU1Muc3VwcG9ydHMpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIENTUy5zdXBwb3J0cyhcIi13ZWJraXQtYmFja2Ryb3AtZmlsdGVyXCIsIFwibm9uZVwiKTtcbn1cbmNvbnN0IGxhc3RUcmF2ZXJzYWJsZU5vZGVOYW1lcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImh0bWxcIiwgXCJib2R5XCIsIFwiI2RvY3VtZW50XCJdKTtcbmZ1bmN0aW9uIGlzTGFzdFRyYXZlcnNhYmxlTm9kZShub2RlKSB7XG4gIHJldHVybiBsYXN0VHJhdmVyc2FibGVOb2RlTmFtZXMuaGFzKGdldE5vZGVOYW1lKG5vZGUpKTtcbn1cbmZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVTY3JvbGwoZWxlbWVudCkge1xuICBpZiAoaXNFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxYLFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxZXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKG5vZGUpIHtcbiAgaWYgKGdldE5vZGVOYW1lKG5vZGUpID09PSBcImh0bWxcIikge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IChcbiAgICAvLyBTdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZS5cbiAgICBub2RlLmFzc2lnbmVkU2xvdCB8fCAvLyBET00gRWxlbWVudCBkZXRlY3RlZC5cbiAgICBub2RlLnBhcmVudE5vZGUgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZC5cbiAgICBpc1NoYWRvd1Jvb3Qobm9kZSkgJiYgbm9kZS5ob3N0IHx8IC8vIEZhbGxiYWNrLlxuICAgIGdldERvY3VtZW50RWxlbWVudChub2RlKVxuICApO1xuICByZXR1cm4gaXNTaGFkb3dSb290KHJlc3VsdCkgPyByZXN1bHQuaG9zdCA6IHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKG5vZGUpIHtcbiAgY29uc3QgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUobm9kZSk7XG4gIGlmIChpc0xhc3RUcmF2ZXJzYWJsZU5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50ID8gbm9kZS5vd25lckRvY3VtZW50LmJvZHkgOiBub2RlLmJvZHk7XG4gIH1cbiAgaWYgKGlzSFRNTEVsZW1lbnQocGFyZW50Tm9kZSkgJiYgaXNPdmVyZmxvd0VsZW1lbnQocGFyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gcGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3IocGFyZW50Tm9kZSk7XG59XG5mdW5jdGlvbiBnZXRPdmVyZmxvd0FuY2VzdG9ycyhub2RlLCBsaXN0LCB0cmF2ZXJzZUlmcmFtZXMpIHtcbiAgdmFyIF9ub2RlJG93bmVyRG9jdW1lbnQyO1xuICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgbGlzdCA9IFtdO1xuICB9XG4gIGlmICh0cmF2ZXJzZUlmcmFtZXMgPT09IHZvaWQgMCkge1xuICAgIHRyYXZlcnNlSWZyYW1lcyA9IHRydWU7XG4gIH1cbiAgY29uc3Qgc2Nyb2xsYWJsZUFuY2VzdG9yID0gZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3Iobm9kZSk7XG4gIGNvbnN0IGlzQm9keSA9IHNjcm9sbGFibGVBbmNlc3RvciA9PT0gKChfbm9kZSRvd25lckRvY3VtZW50MiA9IG5vZGUub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJG93bmVyRG9jdW1lbnQyLmJvZHkpO1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coc2Nyb2xsYWJsZUFuY2VzdG9yKTtcbiAgaWYgKGlzQm9keSkge1xuICAgIGNvbnN0IGZyYW1lRWxlbWVudCA9IGdldEZyYW1lRWxlbWVudCh3aW4pO1xuICAgIHJldHVybiBsaXN0LmNvbmNhdCh3aW4sIHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNPdmVyZmxvd0VsZW1lbnQoc2Nyb2xsYWJsZUFuY2VzdG9yKSA/IHNjcm9sbGFibGVBbmNlc3RvciA6IFtdLCBmcmFtZUVsZW1lbnQgJiYgdHJhdmVyc2VJZnJhbWVzID8gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZnJhbWVFbGVtZW50KSA6IFtdKTtcbiAgfVxuICByZXR1cm4gbGlzdC5jb25jYXQoc2Nyb2xsYWJsZUFuY2VzdG9yLCBnZXRPdmVyZmxvd0FuY2VzdG9ycyhzY3JvbGxhYmxlQW5jZXN0b3IsIFtdLCB0cmF2ZXJzZUlmcmFtZXMpKTtcbn1cbmZ1bmN0aW9uIGdldEZyYW1lRWxlbWVudCh3aW4pIHtcbiAgcmV0dXJuIHdpbi5wYXJlbnQgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHdpbi5wYXJlbnQpID8gd2luLmZyYW1lRWxlbWVudCA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRDc3NEaW1lbnNpb25zKGVsZW1lbnQpIHtcbiAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpO1xuICBsZXQgd2lkdGggPSBwYXJzZUZsb2F0KGNzcy53aWR0aCkgfHwgMDtcbiAgbGV0IGhlaWdodCA9IHBhcnNlRmxvYXQoY3NzLmhlaWdodCkgfHwgMDtcbiAgY29uc3QgaGFzT2Zmc2V0ID0gaXNIVE1MRWxlbWVudChlbGVtZW50KTtcbiAgY29uc3Qgb2Zmc2V0V2lkdGggPSBoYXNPZmZzZXQgPyBlbGVtZW50Lm9mZnNldFdpZHRoIDogd2lkdGg7XG4gIGNvbnN0IG9mZnNldEhlaWdodCA9IGhhc09mZnNldCA/IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IDogaGVpZ2h0O1xuICBjb25zdCBzaG91bGRGYWxsYmFjayA9IHJvdW5kKHdpZHRoKSAhPT0gb2Zmc2V0V2lkdGggfHwgcm91bmQoaGVpZ2h0KSAhPT0gb2Zmc2V0SGVpZ2h0O1xuICBpZiAoc2hvdWxkRmFsbGJhY2spIHtcbiAgICB3aWR0aCA9IG9mZnNldFdpZHRoO1xuICAgIGhlaWdodCA9IG9mZnNldEhlaWdodDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICAkOiBzaG91bGRGYWxsYmFja1xuICB9O1xufVxuZnVuY3Rpb24gdW53cmFwRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiAhaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudC5jb250ZXh0RWxlbWVudCA6IGVsZW1lbnQ7XG59XG5mdW5jdGlvbiBnZXRTY2FsZShlbGVtZW50KSB7XG4gIGNvbnN0IGRvbUVsZW1lbnQgPSB1bndyYXBFbGVtZW50KGVsZW1lbnQpO1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZG9tRWxlbWVudCkpIHtcbiAgICByZXR1cm4gY3JlYXRlQ29vcmRzKDEpO1xuICB9XG4gIGNvbnN0IHJlY3QgPSBkb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgICRcbiAgfSA9IGdldENzc0RpbWVuc2lvbnMoZG9tRWxlbWVudCk7XG4gIGxldCB4ID0gKCQgPyByb3VuZChyZWN0LndpZHRoKSA6IHJlY3Qud2lkdGgpIC8gd2lkdGg7XG4gIGxldCB5ID0gKCQgPyByb3VuZChyZWN0LmhlaWdodCkgOiByZWN0LmhlaWdodCkgLyBoZWlnaHQ7XG4gIGlmICgheCB8fCAhTnVtYmVyLmlzRmluaXRlKHgpKSB7XG4gICAgeCA9IDE7XG4gIH1cbiAgaWYgKCF5IHx8ICFOdW1iZXIuaXNGaW5pdGUoeSkpIHtcbiAgICB5ID0gMTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeVxuICB9O1xufVxuY29uc3Qgbm9PZmZzZXRzID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUNvb3JkcygwKTtcbmZ1bmN0aW9uIGdldFZpc3VhbE9mZnNldHMoZWxlbWVudCkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGlmICghaXNXZWJLaXQoKSB8fCAhd2luLnZpc3VhbFZpZXdwb3J0KSB7XG4gICAgcmV0dXJuIG5vT2Zmc2V0cztcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHdpbi52aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0LFxuICAgIHk6IHdpbi52aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3BcbiAgfTtcbn1cbmZ1bmN0aW9uIHNob3VsZEFkZFZpc3VhbE9mZnNldHMoZWxlbWVudCwgaXNGaXhlZCwgZmxvYXRpbmdPZmZzZXRQYXJlbnQpIHtcbiAgaWYgKGlzRml4ZWQgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWQgPSBmYWxzZTtcbiAgfVxuICBpZiAoIWZsb2F0aW5nT2Zmc2V0UGFyZW50IHx8IGlzRml4ZWQgJiYgZmxvYXRpbmdPZmZzZXRQYXJlbnQgIT09IGdldFdpbmRvdyhlbGVtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNGaXhlZDtcbn1cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUsIGlzRml4ZWRTdHJhdGVneSwgb2Zmc2V0UGFyZW50KSB7XG4gIGlmIChpbmNsdWRlU2NhbGUgPT09IHZvaWQgMCkge1xuICAgIGluY2x1ZGVTY2FsZSA9IGZhbHNlO1xuICB9XG4gIGlmIChpc0ZpeGVkU3RyYXRlZ3kgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWRTdHJhdGVneSA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBkb21FbGVtZW50ID0gdW53cmFwRWxlbWVudChlbGVtZW50KTtcbiAgbGV0IHNjYWxlID0gY3JlYXRlQ29vcmRzKDEpO1xuICBpZiAoaW5jbHVkZVNjYWxlKSB7XG4gICAgaWYgKG9mZnNldFBhcmVudCkge1xuICAgICAgaWYgKGlzRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICAgIHNjYWxlID0gZ2V0U2NhbGUob2Zmc2V0UGFyZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSBnZXRTY2FsZShlbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdmlzdWFsT2Zmc2V0cyA9IHNob3VsZEFkZFZpc3VhbE9mZnNldHMoZG9tRWxlbWVudCwgaXNGaXhlZFN0cmF0ZWd5LCBvZmZzZXRQYXJlbnQpID8gZ2V0VmlzdWFsT2Zmc2V0cyhkb21FbGVtZW50KSA6IGNyZWF0ZUNvb3JkcygwKTtcbiAgbGV0IHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgdmlzdWFsT2Zmc2V0cy54KSAvIHNjYWxlLng7XG4gIGxldCB5ID0gKGNsaWVudFJlY3QudG9wICsgdmlzdWFsT2Zmc2V0cy55KSAvIHNjYWxlLnk7XG4gIGxldCB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGggLyBzY2FsZS54O1xuICBsZXQgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZS55O1xuICBpZiAoZG9tRWxlbWVudCkge1xuICAgIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhkb21FbGVtZW50KTtcbiAgICBjb25zdCBvZmZzZXRXaW4gPSBvZmZzZXRQYXJlbnQgJiYgaXNFbGVtZW50KG9mZnNldFBhcmVudCkgPyBnZXRXaW5kb3cob2Zmc2V0UGFyZW50KSA6IG9mZnNldFBhcmVudDtcbiAgICBsZXQgY3VycmVudFdpbiA9IHdpbjtcbiAgICBsZXQgY3VycmVudElGcmFtZSA9IGdldEZyYW1lRWxlbWVudChjdXJyZW50V2luKTtcbiAgICB3aGlsZSAoY3VycmVudElGcmFtZSAmJiBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0V2luICE9PSBjdXJyZW50V2luKSB7XG4gICAgICBjb25zdCBpZnJhbWVTY2FsZSA9IGdldFNjYWxlKGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY29uc3QgaWZyYW1lUmVjdCA9IGN1cnJlbnRJRnJhbWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlJDEoY3VycmVudElGcmFtZSk7XG4gICAgICBjb25zdCBsZWZ0ID0gaWZyYW1lUmVjdC5sZWZ0ICsgKGN1cnJlbnRJRnJhbWUuY2xpZW50TGVmdCArIHBhcnNlRmxvYXQoY3NzLnBhZGRpbmdMZWZ0KSkgKiBpZnJhbWVTY2FsZS54O1xuICAgICAgY29uc3QgdG9wID0gaWZyYW1lUmVjdC50b3AgKyAoY3VycmVudElGcmFtZS5jbGllbnRUb3AgKyBwYXJzZUZsb2F0KGNzcy5wYWRkaW5nVG9wKSkgKiBpZnJhbWVTY2FsZS55O1xuICAgICAgeCAqPSBpZnJhbWVTY2FsZS54O1xuICAgICAgeSAqPSBpZnJhbWVTY2FsZS55O1xuICAgICAgd2lkdGggKj0gaWZyYW1lU2NhbGUueDtcbiAgICAgIGhlaWdodCAqPSBpZnJhbWVTY2FsZS55O1xuICAgICAgeCArPSBsZWZ0O1xuICAgICAgeSArPSB0b3A7XG4gICAgICBjdXJyZW50V2luID0gZ2V0V2luZG93KGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY3VycmVudElGcmFtZSA9IGdldEZyYW1lRWxlbWVudChjdXJyZW50V2luKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlY3RUb0NsaWVudFJlY3Qoe1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQsIHJlY3QpIHtcbiAgY29uc3QgbGVmdFNjcm9sbCA9IGdldE5vZGVTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbiAgaWYgKCFyZWN0KSB7XG4gICAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBsZWZ0U2Nyb2xsO1xuICB9XG4gIHJldHVybiByZWN0LmxlZnQgKyBsZWZ0U2Nyb2xsO1xufVxuZnVuY3Rpb24gZ2V0SFRNTE9mZnNldChkb2N1bWVudEVsZW1lbnQsIHNjcm9sbCwgaWdub3JlU2Nyb2xsYmFyWCkge1xuICBpZiAoaWdub3JlU2Nyb2xsYmFyWCA9PT0gdm9pZCAwKSB7XG4gICAgaWdub3JlU2Nyb2xsYmFyWCA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGh0bWxSZWN0ID0gZG9jdW1lbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCB4ID0gaHRtbFJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gKGlnbm9yZVNjcm9sbGJhclggPyAwIDogKFxuICAgIC8vIFJUTCA8Ym9keT4gc2Nyb2xsYmFyLlxuICAgIGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50LCBodG1sUmVjdClcbiAgKSk7XG4gIGNvbnN0IHkgPSBodG1sUmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wO1xuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeVxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QoX3JlZikge1xuICBsZXQge1xuICAgIGVsZW1lbnRzLFxuICAgIHJlY3QsXG4gICAgb2Zmc2V0UGFyZW50LFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBfcmVmO1xuICBjb25zdCBpc0ZpeGVkID0gc3RyYXRlZ3kgPT09IFwiZml4ZWRcIjtcbiAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IHRvcExheWVyID0gZWxlbWVudHMgPyBpc1RvcExheWVyKGVsZW1lbnRzLmZsb2F0aW5nKSA6IGZhbHNlO1xuICBpZiAob2Zmc2V0UGFyZW50ID09PSBkb2N1bWVudEVsZW1lbnQgfHwgdG9wTGF5ZXIgJiYgaXNGaXhlZCkge1xuICAgIHJldHVybiByZWN0O1xuICB9XG4gIGxldCBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgbGV0IHNjYWxlID0gY3JlYXRlQ29vcmRzKDEpO1xuICBjb25zdCBvZmZzZXRzID0gY3JlYXRlQ29vcmRzKDApO1xuICBjb25zdCBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSBcImJvZHlcIiB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50KTtcbiAgICAgIHNjYWxlID0gZ2V0U2NhbGUob2Zmc2V0UGFyZW50KTtcbiAgICAgIG9mZnNldHMueCA9IG9mZnNldFJlY3QueCArIG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ID0gb2Zmc2V0UmVjdC55ICsgb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9XG4gIH1cbiAgY29uc3QgaHRtbE9mZnNldCA9IGRvY3VtZW50RWxlbWVudCAmJiAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQgPyBnZXRIVE1MT2Zmc2V0KGRvY3VtZW50RWxlbWVudCwgc2Nyb2xsLCB0cnVlKSA6IGNyZWF0ZUNvb3JkcygwKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCAqIHNjYWxlLngsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodCAqIHNjYWxlLnksXG4gICAgeDogcmVjdC54ICogc2NhbGUueCAtIHNjcm9sbC5zY3JvbGxMZWZ0ICogc2NhbGUueCArIG9mZnNldHMueCArIGh0bWxPZmZzZXQueCxcbiAgICB5OiByZWN0LnkgKiBzY2FsZS55IC0gc2Nyb2xsLnNjcm9sbFRvcCAqIHNjYWxlLnkgKyBvZmZzZXRzLnkgKyBodG1sT2Zmc2V0LnlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RzKGVsZW1lbnQpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5nZXRDbGllbnRSZWN0cygpKTtcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHNjcm9sbCA9IGdldE5vZGVTY3JvbGwoZWxlbWVudCk7XG4gIGNvbnN0IGJvZHkgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgY29uc3Qgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keS5zY3JvbGxXaWR0aCwgYm9keS5jbGllbnRXaWR0aCk7XG4gIGNvbnN0IGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkuc2Nyb2xsSGVpZ2h0LCBib2R5LmNsaWVudEhlaWdodCk7XG4gIGxldCB4ID0gLXNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgY29uc3QgeSA9IC1zY3JvbGwuc2Nyb2xsVG9wO1xuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZSQxKGJvZHkpLmRpcmVjdGlvbiA9PT0gXCJydGxcIikge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkuY2xpZW50V2lkdGgpIC0gd2lkdGg7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5mdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgbGV0IHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgbGV0IGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcbiAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7XG4gICAgY29uc3QgdmlzdWFsVmlld3BvcnRCYXNlZCA9IGlzV2ViS2l0KCk7XG4gICAgaWYgKCF2aXN1YWxWaWV3cG9ydEJhc2VkIHx8IHZpc3VhbFZpZXdwb3J0QmFzZWQgJiYgc3RyYXRlZ3kgPT09IFwiZml4ZWRcIikge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cbmNvbnN0IGFic29sdXRlT3JGaXhlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImFic29sdXRlXCIsIFwiZml4ZWRcIl0pO1xuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3QgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCB0cnVlLCBzdHJhdGVneSA9PT0gXCJmaXhlZFwiKTtcbiAgY29uc3QgdG9wID0gY2xpZW50UmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgY29uc3QgbGVmdCA9IGNsaWVudFJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgY29uc3Qgc2NhbGUgPSBpc0hUTUxFbGVtZW50KGVsZW1lbnQpID8gZ2V0U2NhbGUoZWxlbWVudCkgOiBjcmVhdGVDb29yZHMoMSk7XG4gIGNvbnN0IHdpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aCAqIHNjYWxlLng7XG4gIGNvbnN0IGhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0ICogc2NhbGUueTtcbiAgY29uc3QgeCA9IGxlZnQgKiBzY2FsZS54O1xuICBjb25zdCB5ID0gdG9wICogc2NhbGUueTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgY2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpIHtcbiAgbGV0IHJlY3Q7XG4gIGlmIChjbGlwcGluZ0FuY2VzdG9yID09PSBcInZpZXdwb3J0XCIpIHtcbiAgICByZWN0ID0gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KTtcbiAgfSBlbHNlIGlmIChjbGlwcGluZ0FuY2VzdG9yID09PSBcImRvY3VtZW50XCIpIHtcbiAgICByZWN0ID0gZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSk7XG4gIH0gZWxzZSBpZiAoaXNFbGVtZW50KGNsaXBwaW5nQW5jZXN0b3IpKSB7XG4gICAgcmVjdCA9IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB2aXN1YWxPZmZzZXRzID0gZ2V0VmlzdWFsT2Zmc2V0cyhlbGVtZW50KTtcbiAgICByZWN0ID0ge1xuICAgICAgeDogY2xpcHBpbmdBbmNlc3Rvci54IC0gdmlzdWFsT2Zmc2V0cy54LFxuICAgICAgeTogY2xpcHBpbmdBbmNlc3Rvci55IC0gdmlzdWFsT2Zmc2V0cy55LFxuICAgICAgd2lkdGg6IGNsaXBwaW5nQW5jZXN0b3Iud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNsaXBwaW5nQW5jZXN0b3IuaGVpZ2h0XG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVjdFRvQ2xpZW50UmVjdChyZWN0KTtcbn1cbmZ1bmN0aW9uIGhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvcihlbGVtZW50LCBzdG9wTm9kZSkge1xuICBjb25zdCBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgaWYgKHBhcmVudE5vZGUgPT09IHN0b3BOb2RlIHx8ICFpc0VsZW1lbnQocGFyZW50Tm9kZSkgfHwgaXNMYXN0VHJhdmVyc2FibGVOb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlJDEocGFyZW50Tm9kZSkucG9zaXRpb24gPT09IFwiZml4ZWRcIiB8fCBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IocGFyZW50Tm9kZSwgc3RvcE5vZGUpO1xufVxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzKGVsZW1lbnQsIGNhY2hlKSB7XG4gIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGNhY2hlLmdldChlbGVtZW50KTtcbiAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IGdldE92ZXJmbG93QW5jZXN0b3JzKGVsZW1lbnQsIFtdLCBmYWxzZSkuZmlsdGVyKChlbCkgPT4gaXNFbGVtZW50KGVsKSAmJiBnZXROb2RlTmFtZShlbCkgIT09IFwiYm9keVwiKTtcbiAgbGV0IGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gbnVsbDtcbiAgY29uc3QgZWxlbWVudElzRml4ZWQgPSBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkucG9zaXRpb24gPT09IFwiZml4ZWRcIjtcbiAgbGV0IGN1cnJlbnROb2RlID0gZWxlbWVudElzRml4ZWQgPyBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIDogZWxlbWVudDtcbiAgd2hpbGUgKGlzRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGN1cnJlbnROb2RlKTtcbiAgICBjb25zdCBjdXJyZW50Tm9kZUlzQ29udGFpbmluZyA9IGlzQ29udGFpbmluZ0Jsb2NrKGN1cnJlbnROb2RlKTtcbiAgICBpZiAoIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmIGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09IFwiZml4ZWRcIikge1xuICAgICAgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzaG91bGREcm9wQ3VycmVudE5vZGUgPSBlbGVtZW50SXNGaXhlZCA/ICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiAhY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgOiAhY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgY29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiAmJiAhIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlICYmIGFic29sdXRlT3JGaXhlZC5oYXMoY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUucG9zaXRpb24pIHx8IGlzT3ZlcmZsb3dFbGVtZW50KGN1cnJlbnROb2RlKSAmJiAhY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKGVsZW1lbnQsIGN1cnJlbnROb2RlKTtcbiAgICBpZiAoc2hvdWxkRHJvcEN1cnJlbnROb2RlKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQuZmlsdGVyKChhbmNlc3RvcikgPT4gYW5jZXN0b3IgIT09IGN1cnJlbnROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBjb21wdXRlZFN0eWxlO1xuICAgIH1cbiAgICBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpO1xuICB9XG4gIGNhY2hlLnNldChlbGVtZW50LCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50LFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgZWxlbWVudENsaXBwaW5nQW5jZXN0b3JzID0gYm91bmRhcnkgPT09IFwiY2xpcHBpbmdBbmNlc3RvcnNcIiA/IGlzVG9wTGF5ZXIoZWxlbWVudCkgPyBbXSA6IGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9ycyhlbGVtZW50LCB0aGlzLl9jKSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIGNvbnN0IGNsaXBwaW5nQW5jZXN0b3JzID0gWy4uLmVsZW1lbnRDbGlwcGluZ0FuY2VzdG9ycywgcm9vdEJvdW5kYXJ5XTtcbiAgY29uc3QgZmlyc3RDbGlwcGluZ0FuY2VzdG9yID0gY2xpcHBpbmdBbmNlc3RvcnNbMF07XG4gIGNvbnN0IGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nQW5jZXN0b3JzLnJlZHVjZSgoYWNjUmVjdCwgY2xpcHBpbmdBbmNlc3RvcikgPT4ge1xuICAgIGNvbnN0IHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgY2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBmaXJzdENsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KSk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIGhlaWdodDogY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3AsXG4gICAgeDogY2xpcHBpbmdSZWN0LmxlZnQsXG4gICAgeTogY2xpcHBpbmdSZWN0LnRvcFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IGdldENzc0RpbWVuc2lvbnMoZWxlbWVudCk7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiBnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudChlbGVtZW50LCBvZmZzZXRQYXJlbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgaXNGaXhlZCA9IHN0cmF0ZWd5ID09PSBcImZpeGVkXCI7XG4gIGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgaXNGaXhlZCwgb2Zmc2V0UGFyZW50KTtcbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBjb25zdCBvZmZzZXRzID0gY3JlYXRlQ29vcmRzKDApO1xuICBmdW5jdGlvbiBzZXRMZWZ0UlRMU2Nyb2xsYmFyT2Zmc2V0KCkge1xuICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgfVxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09IFwiYm9keVwiIHx8IGlzT3ZlcmZsb3dFbGVtZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG4gICAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50KSB7XG4gICAgICBjb25zdCBvZmZzZXRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSwgaXNGaXhlZCwgb2Zmc2V0UGFyZW50KTtcbiAgICAgIG9mZnNldHMueCA9IG9mZnNldFJlY3QueCArIG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ID0gb2Zmc2V0UmVjdC55ICsgb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgc2V0TGVmdFJUTFNjcm9sbGJhck9mZnNldCgpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNGaXhlZCAmJiAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgc2V0TGVmdFJUTFNjcm9sbGJhck9mZnNldCgpO1xuICB9XG4gIGNvbnN0IGh0bWxPZmZzZXQgPSBkb2N1bWVudEVsZW1lbnQgJiYgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkID8gZ2V0SFRNTE9mZnNldChkb2N1bWVudEVsZW1lbnQsIHNjcm9sbCkgOiBjcmVhdGVDb29yZHMoMCk7XG4gIGNvbnN0IHggPSByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCAtIGh0bWxPZmZzZXQueDtcbiAgY29uc3QgeSA9IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSAtIGh0bWxPZmZzZXQueTtcbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHksXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gaXNTdGF0aWNQb3NpdGlvbmVkKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KS5wb3NpdGlvbiA9PT0gXCJzdGF0aWNcIjtcbn1cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCwgcG9seWZpbGwpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHBvbHlmaWxsKSB7XG4gICAgcmV0dXJuIHBvbHlmaWxsKGVsZW1lbnQpO1xuICB9XG4gIGxldCByYXdPZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcbiAgaWYgKGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSA9PT0gcmF3T2Zmc2V0UGFyZW50KSB7XG4gICAgcmF3T2Zmc2V0UGFyZW50ID0gcmF3T2Zmc2V0UGFyZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgfVxuICByZXR1cm4gcmF3T2Zmc2V0UGFyZW50O1xufVxuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgaWYgKGlzVG9wTGF5ZXIoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gd2luO1xuICB9XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIGxldCBzdmdPZmZzZXRQYXJlbnQgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICAgIHdoaWxlIChzdmdPZmZzZXRQYXJlbnQgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShzdmdPZmZzZXRQYXJlbnQpKSB7XG4gICAgICBpZiAoaXNFbGVtZW50KHN2Z09mZnNldFBhcmVudCkgJiYgIWlzU3RhdGljUG9zaXRpb25lZChzdmdPZmZzZXRQYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBzdmdPZmZzZXRQYXJlbnQ7XG4gICAgICB9XG4gICAgICBzdmdPZmZzZXRQYXJlbnQgPSBnZXRQYXJlbnROb2RlKHN2Z09mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIHJldHVybiB3aW47XG4gIH1cbiAgbGV0IG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCwgcG9seWZpbGwpO1xuICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIGlzVGFibGVFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgaXNTdGF0aWNQb3NpdGlvbmVkKG9mZnNldFBhcmVudCkpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCwgcG9seWZpbGwpO1xuICB9XG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgaXNMYXN0VHJhdmVyc2FibGVOb2RlKG9mZnNldFBhcmVudCkgJiYgaXNTdGF0aWNQb3NpdGlvbmVkKG9mZnNldFBhcmVudCkgJiYgIWlzQ29udGFpbmluZ0Jsb2NrKG9mZnNldFBhcmVudCkpIHtcbiAgICByZXR1cm4gd2luO1xuICB9XG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbjtcbn1cbmNvbnN0IGdldEVsZW1lbnRSZWN0cyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBnZXRPZmZzZXRQYXJlbnRGbiA9IHRoaXMuZ2V0T2Zmc2V0UGFyZW50IHx8IGdldE9mZnNldFBhcmVudDtcbiAgICBjb25zdCBnZXREaW1lbnNpb25zRm4gPSB0aGlzLmdldERpbWVuc2lvbnM7XG4gICAgY29uc3QgZmxvYXRpbmdEaW1lbnNpb25zID0geWllbGQgZ2V0RGltZW5zaW9uc0ZuKGRhdGEuZmxvYXRpbmcpO1xuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KGRhdGEucmVmZXJlbmNlLCB5aWVsZCBnZXRPZmZzZXRQYXJlbnRGbihkYXRhLmZsb2F0aW5nKSwgZGF0YS5zdHJhdGVneSksXG4gICAgICBmbG9hdGluZzoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogZmxvYXRpbmdEaW1lbnNpb25zLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGZsb2F0aW5nRGltZW5zaW9ucy5oZWlnaHRcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn07XG5mdW5jdGlvbiBpc1JUTChlbGVtZW50KSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkuZGlyZWN0aW9uID09PSBcInJ0bFwiO1xufVxuY29uc3QgcGxhdGZvcm0gPSB7XG4gIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0LFxuICBnZXREb2N1bWVudEVsZW1lbnQsXG4gIGdldENsaXBwaW5nUmVjdCxcbiAgZ2V0T2Zmc2V0UGFyZW50LFxuICBnZXRFbGVtZW50UmVjdHMsXG4gIGdldENsaWVudFJlY3RzLFxuICBnZXREaW1lbnNpb25zLFxuICBnZXRTY2FsZSxcbiAgaXNFbGVtZW50LFxuICBpc1JUTFxufTtcbmZ1bmN0aW9uIHJlY3RzQXJlRXF1YWwoYTIsIGIpIHtcbiAgcmV0dXJuIGEyLnggPT09IGIueCAmJiBhMi55ID09PSBiLnkgJiYgYTIud2lkdGggPT09IGIud2lkdGggJiYgYTIuaGVpZ2h0ID09PSBiLmhlaWdodDtcbn1cbmZ1bmN0aW9uIG9ic2VydmVNb3ZlKGVsZW1lbnQsIG9uTW92ZSkge1xuICBsZXQgaW8gPSBudWxsO1xuICBsZXQgdGltZW91dElkO1xuICBjb25zdCByb290ID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHZhciBfaW87XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgKF9pbyA9IGlvKSA9PSBudWxsIHx8IF9pby5kaXNjb25uZWN0KCk7XG4gICAgaW8gPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHJlZnJlc2goc2tpcCwgdGhyZXNob2xkKSB7XG4gICAgaWYgKHNraXAgPT09IHZvaWQgMCkge1xuICAgICAgc2tpcCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHtcbiAgICAgIHRocmVzaG9sZCA9IDE7XG4gICAgfVxuICAgIGNsZWFudXAoKTtcbiAgICBjb25zdCBlbGVtZW50UmVjdEZvclJvb3RNYXJnaW4gPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQsXG4gICAgICB0b3AsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBlbGVtZW50UmVjdEZvclJvb3RNYXJnaW47XG4gICAgaWYgKCFza2lwKSB7XG4gICAgICBvbk1vdmUoKTtcbiAgICB9XG4gICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluc2V0VG9wID0gZmxvb3IodG9wKTtcbiAgICBjb25zdCBpbnNldFJpZ2h0ID0gZmxvb3Iocm9vdC5jbGllbnRXaWR0aCAtIChsZWZ0ICsgd2lkdGgpKTtcbiAgICBjb25zdCBpbnNldEJvdHRvbSA9IGZsb29yKHJvb3QuY2xpZW50SGVpZ2h0IC0gKHRvcCArIGhlaWdodCkpO1xuICAgIGNvbnN0IGluc2V0TGVmdCA9IGZsb29yKGxlZnQpO1xuICAgIGNvbnN0IHJvb3RNYXJnaW4gPSAtaW5zZXRUb3AgKyBcInB4IFwiICsgLWluc2V0UmlnaHQgKyBcInB4IFwiICsgLWluc2V0Qm90dG9tICsgXCJweCBcIiArIC1pbnNldExlZnQgKyBcInB4XCI7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHJvb3RNYXJnaW4sXG4gICAgICB0aHJlc2hvbGQ6IG1heCgwLCBtaW4oMSwgdGhyZXNob2xkKSkgfHwgMVxuICAgIH07XG4gICAgbGV0IGlzRmlyc3RVcGRhdGUgPSB0cnVlO1xuICAgIGZ1bmN0aW9uIGhhbmRsZU9ic2VydmUoZW50cmllcykge1xuICAgICAgY29uc3QgcmF0aW8gPSBlbnRyaWVzWzBdLmludGVyc2VjdGlvblJhdGlvO1xuICAgICAgaWYgKHJhdGlvICE9PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgaWYgKCFpc0ZpcnN0VXBkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJhdGlvKSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZWZyZXNoKGZhbHNlLCAxZS03KTtcbiAgICAgICAgICB9LCAxZTMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnJlc2goZmFsc2UsIHJhdGlvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJhdGlvID09PSAxICYmICFyZWN0c0FyZUVxdWFsKGVsZW1lbnRSZWN0Rm9yUm9vdE1hcmdpbiwgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkpIHtcbiAgICAgICAgcmVmcmVzaCgpO1xuICAgICAgfVxuICAgICAgaXNGaXJzdFVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaW8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaGFuZGxlT2JzZXJ2ZSwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgICAgLy8gSGFuZGxlIDxpZnJhbWU+c1xuICAgICAgICByb290OiByb290Lm93bmVyRG9jdW1lbnRcbiAgICAgIH0pKTtcbiAgICB9IGNhdGNoIChfZTIpIHtcbiAgICAgIGlvID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZU9ic2VydmUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpby5vYnNlcnZlKGVsZW1lbnQpO1xuICB9XG4gIHJlZnJlc2godHJ1ZSk7XG4gIHJldHVybiBjbGVhbnVwO1xufVxuZnVuY3Rpb24gYXV0b1VwZGF0ZShyZWZlcmVuY2UsIGZsb2F0aW5nLCB1cGRhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgYW5jZXN0b3JTY3JvbGwgPSB0cnVlLFxuICAgIGFuY2VzdG9yUmVzaXplID0gdHJ1ZSxcbiAgICBlbGVtZW50UmVzaXplID0gdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSBcImZ1bmN0aW9uXCIsXG4gICAgbGF5b3V0U2hpZnQgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09IFwiZnVuY3Rpb25cIixcbiAgICBhbmltYXRpb25GcmFtZSA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCByZWZlcmVuY2VFbCA9IHVud3JhcEVsZW1lbnQocmVmZXJlbmNlKTtcbiAgY29uc3QgYW5jZXN0b3JzID0gYW5jZXN0b3JTY3JvbGwgfHwgYW5jZXN0b3JSZXNpemUgPyBbLi4ucmVmZXJlbmNlRWwgPyBnZXRPdmVyZmxvd0FuY2VzdG9ycyhyZWZlcmVuY2VFbCkgOiBbXSwgLi4uZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZmxvYXRpbmcpXSA6IFtdO1xuICBhbmNlc3RvcnMuZm9yRWFjaCgoYW5jZXN0b3IpID0+IHtcbiAgICBhbmNlc3RvclNjcm9sbCAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHVwZGF0ZSwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdXBkYXRlKTtcbiAgfSk7XG4gIGNvbnN0IGNsZWFudXBJbyA9IHJlZmVyZW5jZUVsICYmIGxheW91dFNoaWZ0ID8gb2JzZXJ2ZU1vdmUocmVmZXJlbmNlRWwsIHVwZGF0ZSkgOiBudWxsO1xuICBsZXQgcmVvYnNlcnZlRnJhbWUgPSAtMTtcbiAgbGV0IHJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgaWYgKGVsZW1lbnRSZXNpemUpIHtcbiAgICByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoX3JlZikgPT4ge1xuICAgICAgbGV0IFtmaXJzdEVudHJ5XSA9IF9yZWY7XG4gICAgICBpZiAoZmlyc3RFbnRyeSAmJiBmaXJzdEVudHJ5LnRhcmdldCA9PT0gcmVmZXJlbmNlRWwgJiYgcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVvYnNlcnZlRnJhbWUpO1xuICAgICAgICByZW9ic2VydmVGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgdmFyIF9yZXNpemVPYnNlcnZlcjtcbiAgICAgICAgICAoX3Jlc2l6ZU9ic2VydmVyID0gcmVzaXplT2JzZXJ2ZXIpID09IG51bGwgfHwgX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUoZmxvYXRpbmcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZSgpO1xuICAgIH0pO1xuICAgIGlmIChyZWZlcmVuY2VFbCAmJiAhYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUocmVmZXJlbmNlRWwpO1xuICAgIH1cbiAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgfVxuICBsZXQgZnJhbWVJZDtcbiAgbGV0IHByZXZSZWZSZWN0ID0gYW5pbWF0aW9uRnJhbWUgPyBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKSA6IG51bGw7XG4gIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgIGZyYW1lTG9vcCgpO1xuICB9XG4gIGZ1bmN0aW9uIGZyYW1lTG9vcCgpIHtcbiAgICBjb25zdCBuZXh0UmVmUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChyZWZlcmVuY2UpO1xuICAgIGlmIChwcmV2UmVmUmVjdCAmJiAhcmVjdHNBcmVFcXVhbChwcmV2UmVmUmVjdCwgbmV4dFJlZlJlY3QpKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gICAgcHJldlJlZlJlY3QgPSBuZXh0UmVmUmVjdDtcbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lTG9vcCk7XG4gIH1cbiAgdXBkYXRlKCk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdmFyIF9yZXNpemVPYnNlcnZlcjI7XG4gICAgYW5jZXN0b3JzLmZvckVhY2goKGFuY2VzdG9yKSA9PiB7XG4gICAgICBhbmNlc3RvclNjcm9sbCAmJiBhbmNlc3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHVwZGF0ZSk7XG4gICAgICBhbmNlc3RvclJlc2l6ZSAmJiBhbmNlc3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHVwZGF0ZSk7XG4gICAgfSk7XG4gICAgY2xlYW51cElvID09IG51bGwgfHwgY2xlYW51cElvKCk7XG4gICAgKF9yZXNpemVPYnNlcnZlcjIgPSByZXNpemVPYnNlcnZlcikgPT0gbnVsbCB8fCBfcmVzaXplT2JzZXJ2ZXIyLmRpc2Nvbm5lY3QoKTtcbiAgICByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBzaGlmdCA9IHNoaWZ0JDE7XG5jb25zdCBmbGlwID0gZmxpcCQxO1xuY29uc3QgY29tcHV0ZVBvc2l0aW9uID0gKHJlZmVyZW5jZSwgZmxvYXRpbmcsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBtZXJnZWRPcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgIHBsYXRmb3JtXG4gIH0sIG9wdGlvbnMpO1xuICBjb25zdCBwbGF0Zm9ybVdpdGhDYWNoZSA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG1lcmdlZE9wdGlvbnMucGxhdGZvcm0pLCB7XG4gICAgX2M6IGNhY2hlXG4gIH0pO1xuICByZXR1cm4gY29tcHV0ZVBvc2l0aW9uJDEocmVmZXJlbmNlLCBmbG9hdGluZywgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgbWVyZ2VkT3B0aW9ucyksIHtcbiAgICBwbGF0Zm9ybTogcGxhdGZvcm1XaXRoQ2FjaGVcbiAgfSkpO1xufTtcbmZ1bmN0aW9uIEMobDIsIHUyLCBlMikge1xuICBsZXQgYzIgPSAoKSA9PiB7XG4gICAgdmFyIHQyO1xuICAgIHJldHVybiAodDIgPSBlMiA9PSBudWxsID8gdm9pZCAwIDogZTIucGxhY2VtZW50KSAhPSBudWxsID8gdDIgOiBcImJvdHRvbVwiO1xuICB9LCBkID0gKCkgPT4ge1xuICAgIHZhciB0MjtcbiAgICByZXR1cm4gKHQyID0gZTIgPT0gbnVsbCA/IHZvaWQgMCA6IGUyLnN0cmF0ZWd5KSAhPSBudWxsID8gdDIgOiBcImFic29sdXRlXCI7XG4gIH0sIFtuMiwgbzJdID0gY3JlYXRlU2lnbmFsKHsgeDogbnVsbCwgeTogbnVsbCwgcGxhY2VtZW50OiBjMigpLCBzdHJhdGVneTogZCgpLCBtaWRkbGV3YXJlRGF0YToge30gfSksIFt4LCBGXSA9IGNyZWF0ZVNpZ25hbCgpO1xuICBjcmVhdGVFZmZlY3QoKCkgPT4ge1xuICAgIGxldCB0MiA9IHgoKTtcbiAgICBpZiAodDIpIHRocm93IHQyLnZhbHVlO1xuICB9KTtcbiAgbGV0IHMyID0gY3JlYXRlTWVtbygoKSA9PiAobDIoKSwgdTIoKSwge30pKTtcbiAgZnVuY3Rpb24gbSgpIHtcbiAgICBsZXQgdDIgPSBsMigpLCByID0gdTIoKTtcbiAgICBpZiAodDIgJiYgcikge1xuICAgICAgbGV0IGEyID0gczIoKTtcbiAgICAgIGNvbXB1dGVQb3NpdGlvbih0MiwgciwgeyBtaWRkbGV3YXJlOiBlMiA9PSBudWxsID8gdm9pZCAwIDogZTIubWlkZGxld2FyZSwgcGxhY2VtZW50OiBjMigpLCBzdHJhdGVneTogZCgpIH0pLnRoZW4oKGkyKSA9PiB7XG4gICAgICAgIGEyID09PSBzMigpICYmIG8yKGkyKTtcbiAgICAgIH0sIChpMikgPT4ge1xuICAgICAgICBGKGkyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgdDIgPSBsMigpLCByID0gdTIoKTtcbiAgICBpZiAoYzIoKSwgZCgpLCB0MiAmJiByKSBpZiAoZTIgIT0gbnVsbCAmJiBlMi53aGlsZUVsZW1lbnRzTW91bnRlZCkge1xuICAgICAgbGV0IGEyID0gZTIud2hpbGVFbGVtZW50c01vdW50ZWQodDIsIHIsIG0pO1xuICAgICAgYTIgJiYgb25DbGVhbnVwKGEyKTtcbiAgICB9IGVsc2UgbSgpO1xuICB9KSwgeyBnZXQgeCgpIHtcbiAgICByZXR1cm4gbjIoKS54O1xuICB9LCBnZXQgeSgpIHtcbiAgICByZXR1cm4gbjIoKS55O1xuICB9LCBnZXQgcGxhY2VtZW50KCkge1xuICAgIHJldHVybiBuMigpLnBsYWNlbWVudDtcbiAgfSwgZ2V0IHN0cmF0ZWd5KCkge1xuICAgIHJldHVybiBuMigpLnN0cmF0ZWd5O1xuICB9LCBnZXQgbWlkZGxld2FyZURhdGEoKSB7XG4gICAgcmV0dXJuIG4yKCkubWlkZGxld2FyZURhdGE7XG4gIH0sIHVwZGF0ZTogbSB9O1xufVxudmFyIF90bXBsJCQ0ID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDx0Yy1yb290IGRhdGEtdGMtZHJvcGRvd24tY29udGFpbmVyPXRydWU+YCwgdHJ1ZSwgZmFsc2UsIGZhbHNlKTtcbmNvbnN0IEFjY291bnRCdXR0b24gPSAoKSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3QgY29ubmVjdG9yID0gdXNlQ29udGV4dChDb25uZWN0b3JDb250ZXh0KTtcbiAgY29uc3QgdG9uQ29ubmVjdFVJID0gdXNlQ29udGV4dChUb25Db25uZWN0VWlDb250ZXh0KTtcbiAgY29uc3QgW2lzT3BlbmVkLCBzZXRJc09wZW5lZF0gPSBjcmVhdGVTaWduYWwoZmFsc2UpO1xuICBjb25zdCBbYWNjb3VudCwgc2V0QWNjb3VudF0gPSBjcmVhdGVTaWduYWwoY29ubmVjdG9yLmFjY291bnQpO1xuICBjb25zdCBbcmVzdG9yaW5nUHJvY2Vzcywgc2V0UmVzdG9yaW5nUHJvY2Vzc10gPSBjcmVhdGVTaWduYWwoIWNvbm5lY3Rvci5hY2NvdW50KTtcbiAgbGV0IGRyb3BEb3duUmVmO1xuICBjb25zdCBbZmxvYXRpbmcsIHNldEZsb2F0aW5nXSA9IGNyZWF0ZVNpZ25hbCgpO1xuICBjb25zdCBbYW5jaG9yLCBzZXRBbmNob3JdID0gY3JlYXRlU2lnbmFsKCk7XG4gIGNvbnN0IHBvc2l0aW9uID0gQyhhbmNob3IsIGZsb2F0aW5nLCB7XG4gICAgd2hpbGVFbGVtZW50c01vdW50ZWQ6IGF1dG9VcGRhdGUsXG4gICAgcGxhY2VtZW50OiBcImJvdHRvbS1lbmRcIixcbiAgICBtaWRkbGV3YXJlOiBbZmxpcCgpLCBzaGlmdCgpXVxuICB9KTtcbiAgY29uc3Qgbm9ybWFsaXplZEFkZHJlc3MgPSAoKSA9PiB7XG4gICAgY29uc3QgYWNjID0gYWNjb3VudCgpO1xuICAgIGlmIChhY2MpIHtcbiAgICAgIGNvbnN0IHVzZXJGcmllbmRseUFkZHJlc3MgPSB0b1VzZXJGcmllbmRseUFkZHJlc3MoYWNjLmFkZHJlc3MsIGFjYy5jaGFpbiA9PT0gQ0hBSU4uVEVTVE5FVCk7XG4gICAgICByZXR1cm4gdXNlckZyaWVuZGx5QWRkcmVzcy5zbGljZSgwLCA0KSArIFwi4oCmXCIgKyB1c2VyRnJpZW5kbHlBZGRyZXNzLnNsaWNlKC00KTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG4gIH07XG4gIHRvbkNvbm5lY3RVSS5jb25uZWN0aW9uUmVzdG9yZWQudGhlbigoKSA9PiBzZXRSZXN0b3JpbmdQcm9jZXNzKGZhbHNlKSk7XG4gIGNvbnN0IHVuc3Vic2NyaWJlID0gY29ubmVjdG9yLm9uU3RhdHVzQ2hhbmdlKCh3YWxsZXQpID0+IHtcbiAgICBpZiAoIXdhbGxldCkge1xuICAgICAgc2V0SXNPcGVuZWQoZmFsc2UpO1xuICAgICAgc2V0QWNjb3VudChudWxsKTtcbiAgICAgIHNldFJlc3RvcmluZ1Byb2Nlc3MoZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRBY2NvdW50KHdhbGxldC5hY2NvdW50KTtcbiAgICBzZXRSZXN0b3JpbmdQcm9jZXNzKGZhbHNlKTtcbiAgfSk7XG4gIGNvbnN0IG9uQ2xpY2sgPSAoZTIpID0+IHtcbiAgICBpZiAoIWFjY291bnQoKSB8fCAhaXNPcGVuZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjbGlja1RvQnV0dG9uID0gYW5jaG9yKCkuY29udGFpbnMoZTIudGFyZ2V0KTtcbiAgICBjb25zdCBjbGlja1RvRHJvcGRvd24gPSBkcm9wRG93blJlZi5jb250YWlucyhlMi50YXJnZXQpO1xuICAgIGlmICghY2xpY2tUb0J1dHRvbiAmJiAhY2xpY2tUb0Ryb3Bkb3duKSB7XG4gICAgICBzZXRJc09wZW5lZChmYWxzZSk7XG4gICAgfVxuICB9O1xuICBvbk1vdW50KCgpID0+IHtcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBvbkNsaWNrKTtcbiAgfSk7XG4gIG9uQ2xlYW51cCgoKSA9PiB7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb25DbGljayk7XG4gICAgdW5zdWJzY3JpYmUoKTtcbiAgfSk7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoRHluYW1pYywge1xuICAgIGNvbXBvbmVudDogZ2xvYmFsU3R5bGVzVGFnLFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3RvcmluZ1Byb2Nlc3MoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoTG9hZGVyQnV0dG9uU3R5bGVkJDEsIHtcbiAgICAgICAgICAgIGRpc2FibGVkOiB0cnVlLFxuICAgICAgICAgICAgXCJkYXRhLXRjLWNvbm5lY3QtYnV0dG9uLWxvYWRpbmdcIjogXCJ0cnVlXCIsXG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoTG9hZGVySWNvblN0eWxlZCQxLCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICByZXR1cm4gIXJlc3RvcmluZ1Byb2Nlc3MoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gIWFjY291bnQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQWNjb3VudEJ1dHRvblN0eWxlZCwge1xuICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHRvbkNvbm5lY3RVSS5vcGVuTW9kYWwoKSxcbiAgICAgICAgICAgICAgICBcImRhdGEtdGMtY29ubmVjdC1idXR0b25cIjogXCJ0cnVlXCIsXG4gICAgICAgICAgICAgICAgc2NhbGU6IFwic1wiLFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFRvbkljb24sIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGZpbGwoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoZW1lLmNvbG9ycy5jb25uZWN0QnV0dG9uLmZvcmVncm91bmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoVGV4dCwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJidXR0b24uY29ubmVjdFdhbGxldFwiLFxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogXCIxNXB4XCIsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IFwiMThweFwiLFxuICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiBcIjU5MFwiLFxuICAgICAgICAgICAgICAgICAgICBnZXQgY29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoZW1lLmNvbG9ycy5jb25uZWN0QnV0dG9uLmZvcmVncm91bmQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkNvbm5lY3Qgd2FsbGV0XCJcbiAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhY2NvdW50KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KERyb3Bkb3duQ29udGFpbmVyU3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoRHJvcGRvd25CdXR0b25TdHlsZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gc2V0SXNPcGVuZWQoKHYpID0+ICF2KSxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiBzZXRBbmNob3IsXG4gICAgICAgICAgICAgICAgICAgIFwiZGF0YS10Yy1kcm9wZG93bi1idXR0b25cIjogXCJ0cnVlXCIsXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlOiBcInNcIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBcIjE1cHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IFwiNTkwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiBcIjE4cHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRBZGRyZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChBcnJvd0ljb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogXCJib3R0b21cIlxuICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChQb3J0YWwsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBfZWwkID0gX3RtcGwkJDQoKTtcbiAgICAgICAgICAgICAgICAgICAgICB1c2Uoc2V0RmxvYXRpbmcsIF9lbCQpO1xuICAgICAgICAgICAgICAgICAgICAgIF9lbCQuc3R5bGUuc2V0UHJvcGVydHkoXCJ6LWluZGV4XCIsIFwiOTk5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgIF9lbCQuXyRvd25lciA9IGdldE93bmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0KF9lbCQsIGNyZWF0ZUNvbXBvbmVudChUcmFuc2l0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkJlZm9yZUVudGVyOiAoZWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZShlbCwgW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVZKC04cHgpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoMClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAxNTBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25FeGl0OiAoZWwsIGRvbmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYTIgPSBhbmltYXRlKGVsLCBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoMClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSgtOHB4KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1dLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IDE1MFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYTIuZmluaXNoZWQudGhlbihkb25lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzT3BlbmVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KERyb3Bkb3duU3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBoaWRkZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFpc09wZW5lZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsb3NlOiAoKSA9PiBzZXRJc09wZW5lZChmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZihyJCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmJCA9IGRyb3BEb3duUmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBfcmVmJCA9PT0gXCJmdW5jdGlvblwiID8gX3JlZiQociQpIDogZHJvcERvd25SZWYgPSByJDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0KF9lbCQsIGNyZWF0ZUNvbXBvbmVudChOb3RpZmljYXRpb25zU3R5bGVkLCB7fSksIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoX3AkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EyLCBfYjI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3YkID0gcG9zaXRpb24uc3RyYXRlZ3ksIF92JDIgPSBgJHsoX2EyID0gcG9zaXRpb24ueSkgIT0gbnVsbCA/IF9hMiA6IDB9cHhgLCBfdiQzID0gYCR7KF9iMiA9IHBvc2l0aW9uLngpICE9IG51bGwgPyBfYjIgOiAwfXB4YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF92JCAhPT0gX3AkLmUgJiYgKChfcCQuZSA9IF92JCkgIT0gbnVsbCA/IF9lbCQuc3R5bGUuc2V0UHJvcGVydHkoXCJwb3NpdGlvblwiLCBfdiQpIDogX2VsJC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcInBvc2l0aW9uXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF92JDIgIT09IF9wJC50ICYmICgoX3AkLnQgPSBfdiQyKSAhPSBudWxsID8gX2VsJC5zdHlsZS5zZXRQcm9wZXJ0eShcInRvcFwiLCBfdiQyKSA6IF9lbCQuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ0b3BcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3YkMyAhPT0gX3AkLmEgJiYgKChfcCQuYSA9IF92JDMpICE9IG51bGwgPyBfZWwkLnN0eWxlLnNldFByb3BlcnR5KFwibGVmdFwiLCBfdiQzKSA6IF9lbCQuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJsZWZ0XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcCQ7XG4gICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZTogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYTogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lbCQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXTtcbiAgICAgICAgfVxuICAgICAgfSldO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3QgU3R5bGVkTW9kYWwgPSBzdHlsZWQoTW9kYWwpYFxuICAgIHBhZGRpbmctbGVmdDogMjRweDtcbiAgICBwYWRkaW5nLXJpZ2h0OiAyNHB4O1xuICAgIHBhZGRpbmctdG9wOiAxOHB4O1xuICAgIHBhZGRpbmctYm90dG9tOiAwO1xuXG4gICAgJHttZWRpYShcIm1vYmlsZVwiKX0ge1xuICAgICAgICBwYWRkaW5nLWxlZnQ6IDA7XG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDA7XG4gICAgfVxuYDtcbmNvbnN0IEgxU3R5bGVkJGEgPSBzdHlsZWQoSDEpYFxuICAgIG1hcmdpbi10b3A6IDEycHg7XG5cbiAgICAke21lZGlhKFwibW9iaWxlXCIpfSB7XG4gICAgICAgIHBhZGRpbmc6IDAgMTBweDtcbiAgICB9XG5gO1xuY29uc3QgTG9hZGVyQ29udGFpbmVyU3R5bGVkID0gc3R5bGVkLmRpdmBcbiAgICBtYXJnaW46IDMwcHggMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXG4gICAgJHttZWRpYShcIm1vYmlsZVwiKX0ge1xuICAgICAgICBoZWlnaHQ6IDE2MHB4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIH1cbmA7XG5zdHlsZWQoVGV4dClgXG4gICAgbWluLXdpZHRoOiA4NHB4O1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBmb250LXdlaWdodDogNTkwO1xuYDtcbnN0eWxlZChUYWJCYXIpYFxuICAgIG1hcmdpbjogMCBhdXRvIDIycHg7XG5gO1xuY29uc3QgW2FwcFN0YXRlLCBzZXRBcHBTdGF0ZV0gPSBjcmVhdGVTdG9yZSh7XG4gIGJ1dHRvblJvb3RJZDogbnVsbCxcbiAgbGFuZ3VhZ2U6IFwiZW5cIixcbiAgcmV0dXJuU3RyYXRlZ3k6IFwiYmFja1wiLFxuICB0d2FSZXR1cm5Vcmw6IHZvaWQgMCxcbiAgd2FsbGV0c0xpc3RDb25maWd1cmF0aW9uOiB7fSxcbiAgZW5hYmxlQW5kcm9pZEJhY2tIYW5kbGVyOiB0cnVlXG59KTtcbmZ1bmN0aW9uIHVuaXEoYXJyYXkpIHtcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KGFycmF5KV07XG59XG5mdW5jdGlvbiBtZXJnZUNvbmNhdChpZEtleSwgYXJyYXkxLCBhcnJheTIpIHtcbiAgcmV0dXJuIGFycmF5MS5tYXAoKGl0ZW0xKSA9PiB7XG4gICAgY29uc3QgaXRlbTIgPSBhcnJheTIuZmluZCgoZWxlbSkgPT4gZWxlbVtpZEtleV0gPT09IGl0ZW0xW2lkS2V5XSk7XG4gICAgYXJyYXkyID0gYXJyYXkyLmZpbHRlcigoZWxlbSkgPT4gZWxlbVtpZEtleV0gIT09IGl0ZW0xW2lkS2V5XSk7XG4gICAgcmV0dXJuIGl0ZW0yID09PSB2b2lkIDAgPyBpdGVtMSA6IGl0ZW0yO1xuICB9KS5jb25jYXQoYXJyYXkyKTtcbn1cbmZ1bmN0aW9uIHVpV2FsbGV0VG9XYWxsZXRJbmZvKHVpV2FsbGV0KSB7XG4gIGlmIChcImpzQnJpZGdlS2V5XCIgaW4gdWlXYWxsZXQpIHtcbiAgICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgdWlXYWxsZXQpLCB7XG4gICAgICBpbmplY3RlZDogVG9uQ29ubmVjdC5pc1dhbGxldEluamVjdGVkKHVpV2FsbGV0LmpzQnJpZGdlS2V5KSxcbiAgICAgIGVtYmVkZGVkOiBUb25Db25uZWN0LmlzSW5zaWRlV2FsbGV0QnJvd3Nlcih1aVdhbGxldC5qc0JyaWRnZUtleSlcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdWlXYWxsZXQ7XG59XG5mdW5jdGlvbiBhcHBseVdhbGxldHNMaXN0Q29uZmlndXJhdGlvbih3YWxsZXRzTGlzdCwgY29uZmlndXJhdGlvbikge1xuICB2YXIgX2EyO1xuICBpZiAoIWNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4gd2FsbGV0c0xpc3Q7XG4gIH1cbiAgaWYgKChfYTIgPSBjb25maWd1cmF0aW9uLmluY2x1ZGVXYWxsZXRzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmxlbmd0aCkge1xuICAgIHdhbGxldHNMaXN0ID0gbWVyZ2VDb25jYXQoXG4gICAgICBcIm5hbWVcIixcbiAgICAgIHdhbGxldHNMaXN0LFxuICAgICAgY29uZmlndXJhdGlvbi5pbmNsdWRlV2FsbGV0cy5tYXAodWlXYWxsZXRUb1dhbGxldEluZm8pXG4gICAgKTtcbiAgfVxuICByZXR1cm4gd2FsbGV0c0xpc3Q7XG59XG5mdW5jdGlvbiBzdXBwb3J0c0Rlc2t0b3Aod2FsbGV0SW5mbykge1xuICByZXR1cm4gd2FsbGV0SW5mby5wbGF0Zm9ybXMuc29tZSgodykgPT4gW1wibWFjb3NcIiwgXCJsaW51eFwiLCBcIndpbmRvd3NcIl0uaW5jbHVkZXModykpO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNNb2JpbGUod2FsbGV0SW5mbykge1xuICByZXR1cm4gd2FsbGV0SW5mby5wbGF0Zm9ybXMuc29tZSgodykgPT4gW1wiaW9zXCIsIFwiYW5kcm9pZFwiXS5pbmNsdWRlcyh3KSk7XG59XG5mdW5jdGlvbiBzdXBwb3J0c0V4dGVuc2lvbih3YWxsZXRJbmZvKSB7XG4gIHJldHVybiB3YWxsZXRJbmZvLnBsYXRmb3Jtcy5zb21lKCh3KSA9PiBbXCJjaHJvbWVcIiwgXCJmaXJlZm94XCIsIFwic2FmYXJpXCJdLmluY2x1ZGVzKHcpKTtcbn1cbmZ1bmN0aW9uIGVxV2FsbGV0TmFtZSh3YWxsZXQxLCBuYW1lKSB7XG4gIGlmICghbmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gd2FsbGV0MS5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKSB8fCB3YWxsZXQxLmFwcE5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufVxuY29uc3QgRGVza3RvcFNlbGVjdFdhbGxldE1vZGFsU3R5bGVkID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbmA7XG5jb25zdCBIMVN0eWxlZCQ5ID0gc3R5bGVkKEgxKWBcbiAgICBtYXJnaW4tYm90dG9tOiAxOHB4O1xuYDtcbnN0eWxlZC5kaXZgXG4gICAgaGVpZ2h0OiAxcHg7XG4gICAgbWFyZ2luOiAwIC0yNHB4O1xuICAgIHdpZHRoOiBjYWxjKDEwMCUgKyA0OHB4KTtcbiAgICBvcGFjaXR5OiAwLjEyO1xuICAgIGJhY2tncm91bmQ6ICR7KHByb3BzKSA9PiBwcm9wcy5pc1Nob3duID8gcHJvcHMudGhlbWUuY29sb3JzLmljb24uc2Vjb25kYXJ5IDogXCJ0cmFuc3BhcmVudFwifTtcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kIDAuMTVzIGVhc2UtaW4tb3V0O1xuXG4gICAgJHttZWRpYShcIm1vYmlsZVwiKX0ge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICB9XG5gO1xuY29uc3QgV2FsbGV0c1VsID0gc3R5bGVkLnVsYFxuICAgIGRpc3BsYXk6IGdyaWQ7XG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoYXV0by1maXQsIDkycHgpO1xuICAgIGdyaWQtdGVtcGxhdGUtcm93czogYXV0bztcbiAgICBhbGlnbi1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgIHJvdy1nYXA6IDhweDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBwYWRkaW5nOiAwIDAgMTZweDtcbiAgICBhbGlnbi1zZWxmOiBmbGV4LXN0YXJ0O1xuICAgIG1heC13aWR0aDogNDAwcHg7XG4gICAgbWFyZ2luOiAwIGF1dG87XG4gICAgbGlzdC1zdHlsZTogbm9uZTtcblxuICAgID4gbGkge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgaGVpZ2h0OiBmaXQtY29udGVudDtcbiAgICB9XG5cbiAgICAke21lZGlhKFwibW9iaWxlXCIpfSB7XG4gICAgICAgIGRpc3BsYXk6IGdyaWQ7XG4gICAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDQsIDFmcik7XG4gICAgICAgIGdhcDogMDtcbiAgICAgICAgcGFkZGluZzogOHB4IDEycHggMTZweDtcbiAgICAgICAgbWF4LXdpZHRoOiBub25lO1xuXG4gICAgICAgID4gbGkge1xuICAgICAgICAgICAgbWluLXdpZHRoOiA3OHB4O1xuICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgfVxuXG4gICAgICAgID4gbGkgPiAqIHtcbiAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICB9XG4gICAgfVxuYDtcbnN0eWxlZChCdXR0b24pYFxuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIG1hcmdpbjogMCBhdXRvIDFweDtcbiAgICBmb250LXNpemU6IDE1cHg7XG5gO1xuY29uc3QgU3R5bGVkSWNvbkJ1dHRvbiQ1ID0gc3R5bGVkKEljb25CdXR0b24pYFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDE2cHg7XG4gICAgbGVmdDogMTZweDtcbmA7XG5jb25zdCBXYWxsZXRMYWJlbGVkSXRlbVN0eWxlZCA9IHN0eWxlZChXYWxsZXRMYWJlbGVkSXRlbSlgXG4gICAgb3BhY2l0eTogJHsocHJvcHMpID0+IHByb3BzLndpdGhPcGFjaXR5ID8gXCIwLjRcIiA6IFwiMVwifTtcbmA7XG5jb25zdCBXYWxsZXRzTm90U3VwcG9ydGVkTm90aWZpZXIgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGdyaWQ7XG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiBhdXRvIDI4cHg7XG4gICAgZ2FwOiAxNnB4O1xuICAgIHBhZGRpbmc6IDE2cHg7XG4gICAgbWFyZ2luLWJvdHRvbTogMTZweDtcbiAgICBib3JkZXItcmFkaXVzOiAxNnB4O1xuICAgIGNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5fTtcbiAgICBiYWNrZ3JvdW5kOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmJhY2tncm91bmQudGludH07XG5cbiAgICAke21lZGlhKFwibW9iaWxlXCIpfSB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiAxNnB4O1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IDE2cHg7XG4gICAgfVxuYDtcbmNvbnN0IFdhbGxldHNOb3RTdXBwb3J0ZWROb3RpZmllclRleHQgPSBzdHlsZWQoSDIpYFxuICAgIGNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5fTtcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xuICAgIG1hcmdpbjogMDtcbmA7XG5jb25zdCBFcnJvckJveFN0eWxlZCA9IHN0eWxlZC5kaXZgXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGJvdHRvbTogMTRweDtcbiAgICBsZWZ0OiA1MCU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgMCk7XG5cbiAgICB0ZXh0LXdyYXA6IG5vd3JhcDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGdhcDogNnB4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgYm9yZGVyLXJhZGl1czogMThweDtcbiAgICBtaW4td2lkdGg6IDEyNnB4O1xuICAgIHBhZGRpbmc6IDlweCAxNnB4IDlweCAxMHB4O1xuXG4gICAgZmlsdGVyOiBkcm9wLXNoYWRvdygwcHggMnB4IDhweCByZ2JhKDAsIDAsIDAsIDAuMDgpKTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmJhY2tncm91bmQuc2VnbWVudH07XG5gO1xudmFyIF90bXBsJCQzID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgd2lkdGg9MTYgaGVpZ2h0PTE2IHZpZXdCb3g9XCIwIDAgMTYgMTZcImZpbGw9bm9uZSB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zz48ZyBjbGlwLXBhdGg9dXJsKCNjbGlwMF81MTIyXzEwMzU1KT48Y2lyY2xlIGN4PTggY3k9OCByPTg+PC9jaXJjbGU+PGNpcmNsZSBjeD04IGN5PTExIHI9MT48L2NpcmNsZT48cGF0aCBkPVwiTTcuMDQ5OTQgNC45OTg3NUM3LjAyMjc3IDQuNDU1NDIgNy40NTU5OCA0IDggNEM4LjU0NDAyIDQgOC45NzcyMyA0LjQ1NTQxIDguOTUwMDYgNC45OTg3NUw4Ljc4NzQ1IDguMjUwOTRDOC43NjY0NyA4LjY3MDU1IDguNDIwMTQgOSA4IDlDNy41Nzk4NiA5IDcuMjMzNTMgOC42NzA1NSA3LjIxMjU1IDguMjUwOTRMNy4wNDk5NCA0Ljk5ODc1WlwiPjwvcGF0aD48L2c+PGRlZnM+PGNsaXBQYXRoIGlkPWNsaXAwXzUxMjJfMTAzNTU+PHJlY3Qgd2lkdGg9MTYgaGVpZ2h0PTE2PmApLCBfdG1wbCQyJDEgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyB3aWR0aD0yOCBoZWlnaHQ9Mjggdmlld0JveD1cIjAgMCAyOCAyOFwiZmlsbD1ub25lPjxjaXJjbGUgY3g9MTQgY3k9MTQgcj0xMj48L2NpcmNsZT48Y2lyY2xlIGN4PTE0IGN5PTE4Ljkgcj0xLjQ+PC9jaXJjbGU+PHBhdGggZD1cIk0xMi42NjU4IDguODk4NDVDMTIuNjMgOC4xMzY5OCAxMy4yMzc3IDcuNSAxNCA3LjVDMTQuNzYyMyA3LjUgMTUuMzcgOC4xMzY5OCAxNS4zMzQyIDguODk4NDVMMTUuMDQ3IDE1LjAwMTNDMTUuMDIwNyAxNS41NjA0IDE0LjU1OTcgMTYuMDAwMiAxNCAxNi4wMDAyQzEzLjQ0MDMgMTYuMDAwMiAxMi45NzkzIDE1LjU2MDQgMTIuOTUzIDE1LjAwMTNMMTIuNjY1OCA4Ljg5ODQ1WlwiPmApO1xuY29uc3QgRXhjbGFtYXRpb25JY29uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3Qgc2l6ZSA9ICgpID0+IHByb3BzLnNpemU7XG4gIGNvbnN0IGZpbGwgPSAoKSA9PiBwcm9wcy5maWxsIHx8IHRoZW1lLmNvbG9ycy5pY29uLmVycm9yO1xuICByZXR1cm4gbWVtbygoKSA9PiBtZW1vKCgpID0+IHNpemUoKSA9PT0gXCIxNlwiKSgpID8gKCgpID0+IHtcbiAgICB2YXIgX2VsJCA9IF90bXBsJCQzKCksIF9lbCQyID0gX2VsJC5maXJzdENoaWxkLCBfZWwkMyA9IF9lbCQyLmZpcnN0Q2hpbGQsIF9lbCQ0ID0gX2VsJDMubmV4dFNpYmxpbmcsIF9lbCQ1ID0gX2VsJDQubmV4dFNpYmxpbmcsIF9lbCQ2ID0gX2VsJDIubmV4dFNpYmxpbmcsIF9lbCQ3ID0gX2VsJDYuZmlyc3RDaGlsZCwgX2VsJDggPSBfZWwkNy5maXJzdENoaWxkO1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoX3AkKSA9PiB7XG4gICAgICB2YXIgX3YkID0gZmlsbCgpLCBfdiQyID0gdGhlbWUuY29sb3JzLmNvbnN0YW50LndoaXRlLCBfdiQzID0gdGhlbWUuY29sb3JzLmNvbnN0YW50LndoaXRlLCBfdiQ0ID0gdGhlbWUuY29sb3JzLmNvbnN0YW50LndoaXRlO1xuICAgICAgX3YkICE9PSBfcCQuZSAmJiBzZXRBdHRyaWJ1dGUoX2VsJDMsIFwiZmlsbFwiLCBfcCQuZSA9IF92JCk7XG4gICAgICBfdiQyICE9PSBfcCQudCAmJiBzZXRBdHRyaWJ1dGUoX2VsJDQsIFwiZmlsbFwiLCBfcCQudCA9IF92JDIpO1xuICAgICAgX3YkMyAhPT0gX3AkLmEgJiYgc2V0QXR0cmlidXRlKF9lbCQ1LCBcImZpbGxcIiwgX3AkLmEgPSBfdiQzKTtcbiAgICAgIF92JDQgIT09IF9wJC5vICYmIHNldEF0dHJpYnV0ZShfZWwkOCwgXCJmaWxsXCIsIF9wJC5vID0gX3YkNCk7XG4gICAgICByZXR1cm4gX3AkO1xuICAgIH0sIHtcbiAgICAgIGU6IHZvaWQgMCxcbiAgICAgIHQ6IHZvaWQgMCxcbiAgICAgIGE6IHZvaWQgMCxcbiAgICAgIG86IHZvaWQgMFxuICAgIH0pO1xuICAgIHJldHVybiBfZWwkO1xuICB9KSgpIDogbWVtbygoKSA9PiBzaXplKCkgPT09IFwiMjhcIikoKSA/ICgoKSA9PiB7XG4gICAgdmFyIF9lbCQ5ID0gX3RtcGwkMiQxKCksIF9lbCQwID0gX2VsJDkuZmlyc3RDaGlsZCwgX2VsJDEgPSBfZWwkMC5uZXh0U2libGluZywgX2VsJDEwID0gX2VsJDEubmV4dFNpYmxpbmc7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KChfcCQpID0+IHtcbiAgICAgIHZhciBfdiQ1ID0gcHJvcHMuY2xhc3MsIF92JDYgPSBmaWxsKCksIF92JDcgPSB0aGVtZS5jb2xvcnMuY29uc3RhbnQud2hpdGUsIF92JDggPSB0aGVtZS5jb2xvcnMuY29uc3RhbnQud2hpdGU7XG4gICAgICBfdiQ1ICE9PSBfcCQuZSAmJiBzZXRBdHRyaWJ1dGUoX2VsJDksIFwiY2xhc3NcIiwgX3AkLmUgPSBfdiQ1KTtcbiAgICAgIF92JDYgIT09IF9wJC50ICYmIHNldEF0dHJpYnV0ZShfZWwkMCwgXCJmaWxsXCIsIF9wJC50ID0gX3YkNik7XG4gICAgICBfdiQ3ICE9PSBfcCQuYSAmJiBzZXRBdHRyaWJ1dGUoX2VsJDEsIFwiZmlsbFwiLCBfcCQuYSA9IF92JDcpO1xuICAgICAgX3YkOCAhPT0gX3AkLm8gJiYgc2V0QXR0cmlidXRlKF9lbCQxMCwgXCJmaWxsXCIsIF9wJC5vID0gX3YkOCk7XG4gICAgICByZXR1cm4gX3AkO1xuICAgIH0sIHtcbiAgICAgIGU6IHZvaWQgMCxcbiAgICAgIHQ6IHZvaWQgMCxcbiAgICAgIGE6IHZvaWQgMCxcbiAgICAgIG86IHZvaWQgMFxuICAgIH0pO1xuICAgIHJldHVybiBfZWwkOTtcbiAgfSkoKSA6IG51bGwpO1xufTtcbmNvbnN0IFdBTExFVF9DT05ORUNUX0FQUF9OQU1FID0gXCJ3YWxsZXRfY29ubmVjdFwiO1xuY29uc3QgV0FMTEVUX0NPTk5FQ1RfV0FMTEVUX05BTUUgPSBcIldhbGxldENvbm5lY3RcIjtcbmNvbnN0IFdBTExFVF9DT05ORUNUX0FCT1VUX1VSTCA9IFwiaHR0cHM6Ly9yZW93bi5jb20vXCI7XG52YXIgX3RtcGwkJDIgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPGxpPmApO1xuY29uc3QgQWxsV2FsbGV0c0xpc3RNb2RhbCA9IChwcm9wcykgPT4ge1xuICBjb25zdCBtYXhIZWlnaHQgPSAoKSA9PiBpc01vYmlsZSgpID8gdm9pZCAwIDogNTEwO1xuICBjb25zdCBjb25uZWN0b3IgPSBhcHBTdGF0ZS5jb25uZWN0b3I7XG4gIGNvbnN0IGFkZGl0aW9uYWxSZXF1ZXN0ID0gYXBwU3RhdGUuY29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzO1xuICBjb25zdCBjb25uZWN0V2FsbGV0Q29ubmVjdCA9ICgpID0+IHtcbiAgICBjb25uZWN0b3IuY29ubmVjdCh7XG4gICAgICB0eXBlOiBcIndhbGxldC1jb25uZWN0XCJcbiAgICB9LCAoYWRkaXRpb25hbFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IGFkZGl0aW9uYWxSZXF1ZXN0LnN0YXRlKSA9PT0gXCJyZWFkeVwiID8gYWRkaXRpb25hbFJlcXVlc3QudmFsdWUgOiB2b2lkIDApO1xuICB9O1xuICBjb25zdCBbZXJyb3JTdXBwb3J0T3BlbmVkLCBzZXRFcnJvclN1cHBvcnRPcGVuZWRdID0gY3JlYXRlU2lnbmFsKG51bGwpO1xuICBsZXQgdGltZW91dElkID0gbnVsbDtcbiAgY29uc3Qgb25FcnJvckNsaWNrID0gKHdhbGxldCkgPT4ge1xuICAgIHNldEVycm9yU3VwcG9ydE9wZW5lZCh3YWxsZXQpO1xuICAgIGlmICh0aW1lb3V0SWQgIT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfVxuICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gc2V0RXJyb3JTdXBwb3J0T3BlbmVkKG51bGwpLCAxNTAwKTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlU2VsZWN0V2FsbGV0ID0gKHdhbGxldCkgPT4ge1xuICAgIGlmICghd2FsbGV0LmlzU3VwcG9ydFJlcXVpcmVkRmVhdHVyZXMgJiYgcHJvcHMuZmVhdHVyZUNoZWNrTW9kZSA9PT0gXCJzdHJpY3RcIikge1xuICAgICAgb25FcnJvckNsaWNrKHdhbGxldCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByb3BzLm9uU2VsZWN0KHdhbGxldCk7XG4gIH07XG4gIGNvbnN0IHdhbGxldHNMaXN0ID0gKCkgPT4gaXNNb2JpbGUoKSA/IHByb3BzLndhbGxldHNMaXN0LmZpbHRlcihzdXBwb3J0c01vYmlsZSkgOiBwcm9wcy53YWxsZXRzTGlzdDtcbiAgY29uc3Qgc3VwcG9ydGVkV2FsbGV0cyA9ICgpID0+IHdhbGxldHNMaXN0KCkuZmlsdGVyKCh3YWxsZXQpID0+IHdhbGxldC5pc1N1cHBvcnRSZXF1aXJlZEZlYXR1cmVzKTtcbiAgc2V0TGFzdFZpc2libGVXYWxsZXRzSW5mbyh7XG4gICAgd2FsbGV0c01lbnU6IFwib3RoZXJfd2FsbGV0c1wiLFxuICAgIHdhbGxldHM6IHN1cHBvcnRlZFdhbGxldHMoKVxuICB9KTtcbiAgY29uc3QgdW5zdXBwb3J0ZWRXYWxsZXRzID0gKCkgPT4gd2FsbGV0c0xpc3QoKS5maWx0ZXIoKHdhbGxldCkgPT4gIXdhbGxldC5pc1N1cHBvcnRSZXF1aXJlZEZlYXR1cmVzKTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChEZXNrdG9wU2VsZWN0V2FsbGV0TW9kYWxTdHlsZWQsIHtcbiAgICBcImRhdGEtdGMtd2FsbGV0cy1tb2RhbC1saXN0XCI6IFwidHJ1ZVwiLFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFN0eWxlZEljb25CdXR0b24kNSwge1xuICAgICAgICBpY29uOiBcImFycm93XCIsXG4gICAgICAgIG9uQ2xpY2s6ICgpID0+IHByb3BzLm9uQmFjaygpXG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEgxU3R5bGVkJDksIHtcbiAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwud2FsbGV0c1wiLFxuICAgICAgICBjaGlsZHJlbjogXCJXYWxsZXRzXCJcbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2Nyb2xsQ29udGFpbmVyLCB7XG4gICAgICAgIGdldCBtYXhIZWlnaHQoKSB7XG4gICAgICAgICAgcmV0dXJuIG1heEhlaWdodCgpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoV2FsbGV0c1VsLCB7XG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KEZvciwge1xuICAgICAgICAgICAgICAgIGdldCBlYWNoKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnRlZFdhbGxldHMoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAod2FsbGV0KSA9PiAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgdmFyIF9lbCQgPSBfdG1wbCQkMigpO1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0KF9lbCQsIGNyZWF0ZUNvbXBvbmVudChXYWxsZXRMYWJlbGVkSXRlbVN0eWxlZCwge1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXQsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHByb3BzLm9uU2VsZWN0KHdhbGxldClcbiAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfZWwkO1xuICAgICAgICAgICAgICAgIH0pKClcbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbWVtbygoKSA9PiAhISFpc0luVE1BKCkpKCkgJiYgaXNXYWxsZXRDb25uZWN0SW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoV2FsbGV0TGFiZWxlZEl0ZW1TdHlsZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IHdhbGxldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ3YWxsZXQtY29ubmVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogV0FMTEVUX0NPTk5FQ1RfV0FMTEVUX05BTUUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBOYW1lOiBXQUxMRVRfQ09OTkVDVF9BUFBfTkFNRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlVXJsOiBJTUcuV0FMTEVUX0NPTk5FQ1RcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBjb25uZWN0V2FsbGV0Q29ubmVjdFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVuc3VwcG9ydGVkV2FsbGV0cygpLmxlbmd0aCA+IDAgJiYgcHJvcHMuZmVhdHVyZUNoZWNrTW9kZSAhPT0gXCJoaWRlXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChXYWxsZXRzTm90U3VwcG9ydGVkTm90aWZpZXIsIHtcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChXYWxsZXRzTm90U3VwcG9ydGVkTm90aWZpZXJUZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmFsbFdhbGxldHMud2FsbGV0c0JlbG93Tm90U3VwcG9ydGVkXCIsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlRoZSB3YWxsZXRzIGJlbG93IGRvbuKAmXQgc3VwcG9ydCBhbGwgZmVhdHVyZXMgb2YgdGhlIGNvbm5lY3RlZCBzZXJ2aWNlLiBZb3UgY2FuIHVzZSB5b3VyIHJlY292ZXJ5IHBocmFzZSBpbiBvbmUgb2YgdGhlIHN1cHBvcnRlZCB3YWxsZXRzIGFib3ZlLlwiXG4gICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEV4Y2xhbWF0aW9uSWNvbiwge1xuICAgICAgICAgICAgICAgICAgICBzaXplOiBcIjI4XCJcbiAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoV2FsbGV0c1VsLCB7XG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChGb3IsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGVhY2goKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuc3VwcG9ydGVkV2FsbGV0cygpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogKHdhbGxldCkgPT4gKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgX2VsJDIgPSBfdG1wbCQkMigpO1xuICAgICAgICAgICAgICAgICAgICAgIGluc2VydChfZWwkMiwgY3JlYXRlQ29tcG9uZW50KFdhbGxldExhYmVsZWRJdGVtU3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBoYW5kbGVTZWxlY3RXYWxsZXQod2FsbGV0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCB3aXRoT3BhY2l0eSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLmZlYXR1cmVDaGVja01vZGUgPT09IFwic3RyaWN0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZWwkMjtcbiAgICAgICAgICAgICAgICAgICAgfSkoKVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFRyYW5zaXRpb24sIHtcbiAgICAgICAgICAgICAgICBvbkJlZm9yZUVudGVyOiAoZWwpID0+IHtcbiAgICAgICAgICAgICAgICAgIGFuaW1hdGUoZWwsIFt7XG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoLTUwJSwgNDRweClcIlxuICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKC01MCUsIDApXCJcbiAgICAgICAgICAgICAgICAgIH1dLCB7XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIGVhc2luZzogXCJlYXNlLW91dFwiXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uRXhpdDogKGVsLCBkb25lKSA9PiB7XG4gICAgICAgICAgICAgICAgICBhbmltYXRlKGVsLCBbe1xuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKC01MCUsIDApXCJcbiAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgtNTAlLCA0NHB4KVwiXG4gICAgICAgICAgICAgICAgICB9XSwge1xuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogMTUwLFxuICAgICAgICAgICAgICAgICAgICBlYXNpbmc6IFwiZWFzZS1vdXRcIlxuICAgICAgICAgICAgICAgICAgfSkuZmluaXNoZWQudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvclN1cHBvcnRPcGVuZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoRXJyb3JCb3hTdHlsZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoRXJyb3JJY29uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogXCJ4c1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoVGV4dCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmFsbFdhbGxldHMud2FsbGV0Tm90U3VwcG9ydFNlcnZpY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgdHJhbnNsYXRpb25WYWx1ZXMoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBlcnJvclN1cHBvcnRPcGVuZWQoKS5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttZW1vKCgpID0+IGVycm9yU3VwcG9ydE9wZW5lZCgpLm5hbWUpLCBcIiBkb2VzbuKAmXQgc3VwcG9ydCBjb25uZWN0ZWQgc2VydmljZVwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSldO1xuICAgICAgICB9XG4gICAgICB9KV07XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCB0Z0J1dHRvbkJvcmRlcnMgPSB7XG4gIG06IFwiMTZweFwiLFxuICBzOiBcIjEycHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCB0Z0ljb25Cb3JkZXJzID0ge1xuICBtOiBcIjZweFwiLFxuICBzOiBcIjZweFwiLFxuICBub25lOiBcIjBcIlxufTtcbmNvbnN0IERlc2t0b3BDb25uZWN0aW9uTW9kYWxTdHlsZWQgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbmA7XG5jb25zdCBCb2R5U3R5bGVkJDEgPSBzdHlsZWQuZGl2YFxuICAgIGZsZXg6IDE7XG4gICAgbWFyZ2luLXRvcDogJHsocHJvcHMpID0+IHByb3BzLnFyID8gXCIwXCIgOiBcIjE4cHhcIn07XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgbWluLWhlaWdodDogMjMycHg7XG5gO1xuY29uc3QgUVJDb2RlU3R5bGVkJDEgPSBzdHlsZWQoUVJDb2RlKWBcbiAgICBtYXJnaW4tYm90dG9tOiAyNHB4O1xuYDtcbmNvbnN0IEgxU3R5bGVkJDggPSBzdHlsZWQoSDEpYFxuICAgIG1heC13aWR0aDogMjg4cHg7XG4gICAgbWFyZ2luOiAwIGF1dG8gMnB4O1xuYDtcbmNvbnN0IEgyU3R5bGVkJDQgPSBzdHlsZWQoSDIpYFxuICAgIG1heC13aWR0aDogMjg4cHg7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIG1hcmdpbjogMCBhdXRvIDIwcHg7XG5gO1xuY29uc3QgU3R5bGVkSWNvbkJ1dHRvbiQ0ID0gc3R5bGVkKEljb25CdXR0b24pYFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDE2cHg7XG4gICAgbGVmdDogMTZweDtcbmA7XG5jb25zdCBCdXR0b25zQ29udGFpbmVyU3R5bGVkJDIgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZ2FwOiA4cHg7XG4gICAgcGFkZGluZy1ib3R0b206IDE2cHg7XG5gO1xuY29uc3QgQm90dG9tQnV0dG9uc0NvbnRhaW5lclN0eWxlZCA9IHN0eWxlZChCdXR0b25zQ29udGFpbmVyU3R5bGVkJDIpYFxuICAgIHBhZGRpbmctYm90dG9tOiAwO1xuYDtcbmNvbnN0IEZvb3RlckJ1dHRvbiQxID0gc3R5bGVkKEJ1dHRvbilgXG4gICAgbWFyZ2luLWJvdHRvbTogMjRweDtcbmA7XG5jb25zdCBMb2FkZXJTdHlsZWQkMSA9IHN0eWxlZChMb2FkZXJJY29uKWBcbiAgICBtYXJnaW4tYm90dG9tOiAxOHB4O1xuICAgIG1hcmdpbi10b3A6IDJweDtcbmA7XG5jb25zdCBFcnJvckljb25TdHlsZWQkMiA9IHN0eWxlZChFcnJvckljb24pYFxuICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XG5gO1xuY29uc3QgQm9keVRleHRTdHlsZWQkMiA9IHN0eWxlZChIMilgXG4gICAgY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnl9O1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBtYXJnaW4tYm90dG9tOiAyMHB4O1xuYDtcbmNvbnN0IFRnQnV0dG9uU3R5bGVkID0gc3R5bGVkKEJ1dHRvbilgXG4gICAgbWFyZ2luLXRvcDogLThweDtcbiAgICBtYXJnaW4tYm90dG9tOiAyNHB4O1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIHBhZGRpbmc6IDEycHggMTJweCAxMnB4IDIwcHg7XG4gICAgYm9yZGVyLXJhZGl1czogJHsocHJvcHMpID0+IHRnQnV0dG9uQm9yZGVyc1twcm9wcy50aGVtZS5ib3JkZXJSYWRpdXNdfTtcbiAgICBmb250LXNpemU6IDE2cHg7XG4gICAgbGluZS1oZWlnaHQ6IDIwcHg7XG5gO1xuY29uc3QgVGdJbWFnZVN0eWxlZCA9IHN0eWxlZChJbWFnZSlgXG4gICAgd2lkdGg6IDMycHg7XG4gICAgaGVpZ2h0OiAzMnB4O1xuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiB0Z0ljb25Cb3JkZXJzW3Byb3BzLnRoZW1lLmJvcmRlclJhZGl1c119O1xuYDtcbmNvbnN0IFRyYW5zbGF0aW9uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IFt0Ml0gPSB1c2VJMThuKCk7XG4gIHJldHVybiBtZW1vKCgpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIHJldHVybiB0Mihwcm9wcy50cmFuc2xhdGlvbktleSwgcHJvcHMudHJhbnNsYXRpb25WYWx1ZXMsIChfYTIgPSBwcm9wcy5jaGlsZHJlbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi50b1N0cmluZygpKTtcbiAgfSk7XG59O1xuZnVuY3Rpb24gYWRkUmV0dXJuU3RyYXRlZ3kodXJsLCBzdHJhdGVneSkge1xuICBsZXQgcmV0dXJuU3RyYXRlZ3k7XG4gIGlmICh0eXBlb2Ygc3RyYXRlZ3kgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm5TdHJhdGVneSA9IHN0cmF0ZWd5O1xuICB9IGVsc2Uge1xuICAgIHJldHVyblN0cmF0ZWd5ID0gaXNJblRNQSgpID8gc3RyYXRlZ3kudHdhUmV0dXJuVXJsIHx8IHN0cmF0ZWd5LnJldHVyblN0cmF0ZWd5IDogXCJub25lXCI7XG4gIH1cbiAgY29uc3QgbmV3VXJsID0gYWRkUXVlcnlQYXJhbWV0ZXIodXJsLCBcInJldFwiLCByZXR1cm5TdHJhdGVneSk7XG4gIGlmICghaXNUZWxlZ3JhbVVybCh1cmwpKSB7XG4gICAgcmV0dXJuIG5ld1VybDtcbiAgfVxuICBjb25zdCBsYXN0UGFyYW0gPSBuZXdVcmwuc2xpY2UobmV3VXJsLmxhc3RJbmRleE9mKFwiJlwiKSArIDEpO1xuICByZXR1cm4gbmV3VXJsLnNsaWNlKDAsIG5ld1VybC5sYXN0SW5kZXhPZihcIiZcIikpICsgXCItXCIgKyBlbmNvZGVUZWxlZ3JhbVVybFBhcmFtZXRlcnMobGFzdFBhcmFtKTtcbn1cbmZ1bmN0aW9uIHJlZGlyZWN0VG9UZWxlZ3JhbSh1bml2ZXJzYWxMaW5rLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyk7XG4gIGNvbnN0IGRpcmVjdExpbmsgPSBjb252ZXJ0VG9UR0RpcmVjdExpbmsodW5pdmVyc2FsTGluayk7XG4gIGNvbnN0IGRpcmVjdExpbmtVcmwgPSBuZXcgVVJMKGRpcmVjdExpbmspO1xuICBpZiAoIWRpcmVjdExpbmtVcmwuc2VhcmNoUGFyYW1zLmhhcyhcInN0YXJ0YXBwXCIpKSB7XG4gICAgZGlyZWN0TGlua1VybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwic3RhcnRhcHBcIiwgXCJ0b25jb25uZWN0XCIpO1xuICB9XG4gIGlmIChpc0luVGVsZWdyYW1Ccm93c2VyKCkpIHtcbiAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJiYWNrXCI7XG4gICAgY29uc3QgbGlua1dpdGhTdHJhdGVneSA9IGFkZFJldHVyblN0cmF0ZWd5KFxuICAgICAgZGlyZWN0TGlua1VybC50b1N0cmluZygpLFxuICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneVxuICAgICk7XG4gICAgb3BlbkxpbmtCbGFuayhsaW5rV2l0aFN0cmF0ZWd5KTtcbiAgfSBlbHNlIGlmIChpc0luVE1BKCkpIHtcbiAgICBpZiAoaXNUbWFQbGF0Zm9ybShcImlvc1wiLCBcImFuZHJvaWRcIiwgXCJtYWNvc1wiLCBcInRkZXNrdG9wXCIsIFwid2ViXCIpKSB7XG4gICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJiYWNrXCI7XG4gICAgICBjb25zdCBsaW5rV2l0aFN0cmF0ZWd5ID0gYWRkUmV0dXJuU3RyYXRlZ3koXG4gICAgICAgIGRpcmVjdExpbmtVcmwudG9TdHJpbmcoKSxcbiAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneVxuICAgICAgKTtcbiAgICAgIHNlbmRPcGVuVGVsZWdyYW1MaW5rKGxpbmtXaXRoU3RyYXRlZ3kpO1xuICAgIH0gZWxzZSBpZiAoaXNUbWFQbGF0Zm9ybShcIndlYmFcIikpIHtcbiAgICAgIHNlbmRPcGVuVGVsZWdyYW1MaW5rKGFkZFJldHVyblN0cmF0ZWd5KGRpcmVjdExpbmtVcmwudG9TdHJpbmcoKSwgb3B0aW9ucykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcGVuTGlua0JsYW5rKGFkZFJldHVyblN0cmF0ZWd5KGRpcmVjdExpbmtVcmwudG9TdHJpbmcoKSwgb3B0aW9ucykpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNPUyhcImlvc1wiKSkge1xuICAgICAgaWYgKG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPT09IFwiYmFja1wiKSB7XG4gICAgICAgIGlmIChpc0Jyb3dzZXIoXCJzYWZhcmlcIikpIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJiYWNrXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKFwiY2hyb21lXCIpKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwiZ29vZ2xlY2hyb21lOi8vXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKFwiZmlyZWZveFwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcImZpcmVmb3g6Ly9cIjtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jyb3dzZXIoXCJvcGVyYVwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcIm9wZXJhLWh0dHA6Ly9cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gbG9jYXRpb24uaHJlZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaXNDaHJvbWUgPSBpc0Jyb3dzZXIoXCJjaHJvbWVcIik7XG4gICAgICBjb25zdCBpc0ZpcmVmb3ggPSBpc0Jyb3dzZXIoXCJmaXJlZm94XCIpO1xuICAgICAgY29uc3QgdXNlRGVlcExpbmsgPSAoaXNDaHJvbWUgfHwgaXNGaXJlZm94KSAmJiAhb3B0aW9ucy5mb3JjZVJlZGlyZWN0O1xuICAgICAgaWYgKHVzZURlZXBMaW5rKSB7XG4gICAgICAgIGNvbnN0IGxpbmtXaXRoU3RyYXRlZ3kgPSBhZGRSZXR1cm5TdHJhdGVneShcbiAgICAgICAgICBkaXJlY3RMaW5rVXJsLnRvU3RyaW5nKCksXG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBkZWVwTGluayA9IGNvbnZlcnRUb1RHRGVlcExpbmsobGlua1dpdGhTdHJhdGVneSk7XG4gICAgICAgIG9wZW5EZWVwbGlua1dpdGhGYWxsYmFjayhkZWVwTGluaywgKCkgPT4gb3BlbkxpbmtCbGFuayhsaW5rV2l0aFN0cmF0ZWd5KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsaW5rV2l0aFN0cmF0ZWd5ID0gYWRkUmV0dXJuU3RyYXRlZ3koXG4gICAgICAgICAgZGlyZWN0TGlua1VybC50b1N0cmluZygpLFxuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3lcbiAgICAgICAgKTtcbiAgICAgICAgb3BlbkxpbmtCbGFuayhsaW5rV2l0aFN0cmF0ZWd5KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzT1MoXCJhbmRyb2lkXCIpKSB7XG4gICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJiYWNrXCI7XG4gICAgICBjb25zdCBpc0Nocm9tZSA9IGlzQnJvd3NlcihcImNocm9tZVwiKTtcbiAgICAgIGNvbnN0IGlzRmlyZWZveCA9IGlzQnJvd3NlcihcImZpcmVmb3hcIik7XG4gICAgICBjb25zdCB1c2VEZWVwTGluayA9IChpc0Nocm9tZSB8fCBpc0ZpcmVmb3gpICYmICFvcHRpb25zLmZvcmNlUmVkaXJlY3Q7XG4gICAgICBpZiAodXNlRGVlcExpbmspIHtcbiAgICAgICAgY29uc3QgbGlua1dpdGhTdHJhdGVneSA9IGFkZFJldHVyblN0cmF0ZWd5KFxuICAgICAgICAgIGRpcmVjdExpbmtVcmwudG9TdHJpbmcoKSxcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5XG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGRlZXBMaW5rID0gY29udmVydFRvVEdEZWVwTGluayhsaW5rV2l0aFN0cmF0ZWd5KTtcbiAgICAgICAgb3BlbkRlZXBsaW5rV2l0aEZhbGxiYWNrKGRlZXBMaW5rLCAoKSA9PiBvcGVuTGlua0JsYW5rKGxpbmtXaXRoU3RyYXRlZ3kpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGxpbmtXaXRoU3RyYXRlZ3kgPSBhZGRSZXR1cm5TdHJhdGVneShcbiAgICAgICAgICBkaXJlY3RMaW5rVXJsLnRvU3RyaW5nKCksXG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneVxuICAgICAgICApO1xuICAgICAgICBvcGVuTGlua0JsYW5rKGxpbmtXaXRoU3RyYXRlZ3kpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNPUyhcImlwYWRcIikpIHtcbiAgICAgIGlmIChvcHRpb25zLnJldHVyblN0cmF0ZWd5ID09PSBcImJhY2tcIikge1xuICAgICAgICBpZiAoaXNCcm93c2VyKFwic2FmYXJpXCIpKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwiYmFja1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQnJvd3NlcihcImNocm9tZVwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcImdvb2dsZWNocm9tZTovL1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQnJvd3NlcihcImZpcmVmb3hcIikpIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJmaXJlZm94Oi8vXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKFwib3BlcmFcIikpIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJvcGVyYS1odHRwOi8vXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IGxvY2F0aW9uLmhyZWY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzQ2hyb21lID0gaXNCcm93c2VyKFwiY2hyb21lXCIpO1xuICAgICAgY29uc3QgaXNGaXJlZm94ID0gaXNCcm93c2VyKFwiZmlyZWZveFwiKTtcbiAgICAgIGNvbnN0IHVzZURlZXBMaW5rID0gKGlzQ2hyb21lIHx8IGlzRmlyZWZveCkgJiYgIW9wdGlvbnMuZm9yY2VSZWRpcmVjdDtcbiAgICAgIGNvbnN0IGxpbmtXaXRoU3RyYXRlZ3kgPSBhZGRSZXR1cm5TdHJhdGVneShcbiAgICAgICAgZGlyZWN0TGlua1VybC50b1N0cmluZygpLFxuICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5XG4gICAgICApO1xuICAgICAgaWYgKHVzZURlZXBMaW5rKSB7XG4gICAgICAgIGNvbnN0IGRlZXBMaW5rID0gY29udmVydFRvVEdEZWVwTGluayhsaW5rV2l0aFN0cmF0ZWd5KTtcbiAgICAgICAgb3BlbkRlZXBsaW5rV2l0aEZhbGxiYWNrKGRlZXBMaW5rLCAoKSA9PiBvcGVuTGlua0JsYW5rKGxpbmtXaXRoU3RyYXRlZ3kpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wZW5MaW5rQmxhbmsobGlua1dpdGhTdHJhdGVneSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc09TKFwibWFjb3NcIiwgXCJ3aW5kb3dzXCIsIFwibGludXhcIikpIHtcbiAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcImJhY2tcIjtcbiAgICAgIG9wdGlvbnMudHdhUmV0dXJuVXJsID0gdm9pZCAwO1xuICAgICAgY29uc3QgbGlua1dpdGhTdHJhdGVneSA9IGFkZFJldHVyblN0cmF0ZWd5KFxuICAgICAgICBkaXJlY3RMaW5rVXJsLnRvU3RyaW5nKCksXG4gICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3lcbiAgICAgICk7XG4gICAgICBpZiAob3B0aW9ucy5mb3JjZVJlZGlyZWN0KSB7XG4gICAgICAgIG9wZW5MaW5rQmxhbmsobGlua1dpdGhTdHJhdGVneSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkZWVwTGluayA9IGNvbnZlcnRUb1RHRGVlcExpbmsobGlua1dpdGhTdHJhdGVneSk7XG4gICAgICAgIG9wZW5EZWVwbGlua1dpdGhGYWxsYmFjayhkZWVwTGluaywgKCkgPT4gb3BlbkxpbmtCbGFuayhsaW5rV2l0aFN0cmF0ZWd5KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wZW5MaW5rQmxhbmsoYWRkUmV0dXJuU3RyYXRlZ3koZGlyZWN0TGlua1VybC50b1N0cmluZygpLCBvcHRpb25zKSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZWRpcmVjdFRvV2FsbGV0KHVuaXZlcnNhbExpbmssIGRlZXBMaW5rLCBvcHRpb25zLCBzZXRPcGVuTWV0aG9kKSB7XG4gIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyk7XG4gIGlmIChpc0luVGVsZWdyYW1Ccm93c2VyKCkpIHtcbiAgICBpZiAoaXNPUyhcImlvc1wiLCBcImFuZHJvaWRcIikpIHtcbiAgICAgIGlmIChvcHRpb25zLnJldHVyblN0cmF0ZWd5ID09PSBcImJhY2tcIikge1xuICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJ0ZzovL3Jlc29sdmVcIjtcbiAgICAgIH1cbiAgICAgIHNldE9wZW5NZXRob2QoXCJ1bml2ZXJzYWwtbGlua1wiKTtcbiAgICAgIG9wZW5MaW5rKGFkZFJldHVyblN0cmF0ZWd5KHVuaXZlcnNhbExpbmssIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kpLCBcIl9zZWxmXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRPcGVuTWV0aG9kKFwidW5pdmVyc2FsLWxpbmtcIik7XG4gICAgICBjb25zdCBsaW5rV2l0aFN0cmF0ZWd5ID0gYWRkUmV0dXJuU3RyYXRlZ3kodW5pdmVyc2FsTGluaywgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSk7XG4gICAgICBvcGVuTGlua0JsYW5rKGxpbmtXaXRoU3RyYXRlZ3kpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0luVE1BKCkpIHtcbiAgICBpZiAoaXNUbWFQbGF0Zm9ybShcImlvc1wiLCBcImFuZHJvaWRcIikpIHtcbiAgICAgIGlmIChvcHRpb25zLnJldHVyblN0cmF0ZWd5ID09PSBcImJhY2tcIikge1xuICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJ0ZzovL3Jlc29sdmVcIjtcbiAgICAgIH1cbiAgICAgIHNldE9wZW5NZXRob2QoXCJ1bml2ZXJzYWwtbGlua1wiKTtcbiAgICAgIGNvbnN0IGxpbmtXaXRoU3RyYXRlZ3kgPSBhZGRSZXR1cm5TdHJhdGVneSh1bml2ZXJzYWxMaW5rLCBvcHRpb25zLnJldHVyblN0cmF0ZWd5KTtcbiAgICAgIHNlbmRPcGVuVGVsZWdyYW1MaW5rKGxpbmtXaXRoU3RyYXRlZ3ksICgpID0+IHtcbiAgICAgICAgc2V0T3Blbk1ldGhvZChcInVuaXZlcnNhbC1saW5rXCIpO1xuICAgICAgICBvcGVuTGlua0JsYW5rKGxpbmtXaXRoU3RyYXRlZ3kpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc1RtYVBsYXRmb3JtKFwibWFjb3NcIiwgXCJ0ZGVza3RvcFwiKSkge1xuICAgICAgaWYgKG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPT09IFwiYmFja1wiKSB7XG4gICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcInRnOi8vcmVzb2x2ZVwiO1xuICAgICAgfVxuICAgICAgY29uc3QgbGlua1dpdGhTdHJhdGVneSA9IGFkZFJldHVyblN0cmF0ZWd5KHVuaXZlcnNhbExpbmssIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kpO1xuICAgICAgY29uc3QgdXNlRGVlcExpbmsgPSAhIWRlZXBMaW5rICYmICFvcHRpb25zLmZvcmNlUmVkaXJlY3Q7XG4gICAgICBpZiAodXNlRGVlcExpbmspIHtcbiAgICAgICAgc2V0T3Blbk1ldGhvZChcImN1c3RvbS1kZWVwbGlua1wiKTtcbiAgICAgICAgb3BlbkRlZXBsaW5rV2l0aEZhbGxiYWNrKHRvRGVlcGxpbmsobGlua1dpdGhTdHJhdGVneSwgZGVlcExpbmspLCAoKSA9PiB7XG4gICAgICAgICAgc2V0T3Blbk1ldGhvZChcInVuaXZlcnNhbC1saW5rXCIpO1xuICAgICAgICAgIG9wZW5MaW5rQmxhbmsobGlua1dpdGhTdHJhdGVneSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0T3Blbk1ldGhvZChcInVuaXZlcnNhbC1saW5rXCIpO1xuICAgICAgICBvcGVuTGlua0JsYW5rKGxpbmtXaXRoU3RyYXRlZ3kpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUbWFQbGF0Zm9ybShcIndlYmFcIikpIHtcbiAgICAgIGlmIChvcHRpb25zLnJldHVyblN0cmF0ZWd5ID09PSBcImJhY2tcIikge1xuICAgICAgICBpZiAoaXNCcm93c2VyKFwic2FmYXJpXCIpKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IGxvY2F0aW9uLmhyZWY7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKFwiY2hyb21lXCIpKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwiZ29vZ2xlY2hyb21lOi8vXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKFwiZmlyZWZveFwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcImZpcmVmb3g6Ly9cIjtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jyb3dzZXIoXCJvcGVyYVwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcIm9wZXJhLWh0dHA6Ly9cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gbG9jYXRpb24uaHJlZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbGlua1dpdGhTdHJhdGVneSA9IGFkZFJldHVyblN0cmF0ZWd5KHVuaXZlcnNhbExpbmssIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kpO1xuICAgICAgY29uc3QgdXNlRGVlcExpbmsgPSAhIWRlZXBMaW5rICYmICFvcHRpb25zLmZvcmNlUmVkaXJlY3Q7XG4gICAgICBpZiAodXNlRGVlcExpbmspIHtcbiAgICAgICAgc2V0T3Blbk1ldGhvZChcImN1c3RvbS1kZWVwbGlua1wiKTtcbiAgICAgICAgb3BlbkRlZXBsaW5rV2l0aEZhbGxiYWNrKHRvRGVlcGxpbmsobGlua1dpdGhTdHJhdGVneSwgZGVlcExpbmspLCAoKSA9PiB7XG4gICAgICAgICAgc2V0T3Blbk1ldGhvZChcInVuaXZlcnNhbC1saW5rXCIpO1xuICAgICAgICAgIG9wZW5MaW5rQmxhbmsobGlua1dpdGhTdHJhdGVneSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0T3Blbk1ldGhvZChcInVuaXZlcnNhbC1saW5rXCIpO1xuICAgICAgICBvcGVuTGlua0JsYW5rKGxpbmtXaXRoU3RyYXRlZ3kpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUbWFQbGF0Zm9ybShcIndlYlwiKSkge1xuICAgICAgaWYgKG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPT09IFwiYmFja1wiKSB7XG4gICAgICAgIGlmIChpc0Jyb3dzZXIoXCJzYWZhcmlcIikpIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gbG9jYXRpb24uaHJlZjtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jyb3dzZXIoXCJjaHJvbWVcIikpIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJnb29nbGVjaHJvbWU6Ly9cIjtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jyb3dzZXIoXCJmaXJlZm94XCIpKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwiZmlyZWZveDovL1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQnJvd3NlcihcIm9wZXJhXCIpKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwib3BlcmEtaHR0cDovL1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBsb2NhdGlvbi5ocmVmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBsaW5rV2l0aFN0cmF0ZWd5ID0gYWRkUmV0dXJuU3RyYXRlZ3kodW5pdmVyc2FsTGluaywgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSk7XG4gICAgICBjb25zdCB1c2VEZWVwTGluayA9ICEhZGVlcExpbmsgJiYgIW9wdGlvbnMuZm9yY2VSZWRpcmVjdDtcbiAgICAgIGlmICh1c2VEZWVwTGluaykge1xuICAgICAgICBzZXRPcGVuTWV0aG9kKFwiY3VzdG9tLWRlZXBsaW5rXCIpO1xuICAgICAgICBvcGVuRGVlcGxpbmtXaXRoRmFsbGJhY2sodG9EZWVwbGluayhsaW5rV2l0aFN0cmF0ZWd5LCBkZWVwTGluayksICgpID0+IHtcbiAgICAgICAgICBzZXRPcGVuTWV0aG9kKFwidW5pdmVyc2FsLWxpbmtcIik7XG4gICAgICAgICAgb3BlbkxpbmtCbGFuayhsaW5rV2l0aFN0cmF0ZWd5KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRPcGVuTWV0aG9kKFwidW5pdmVyc2FsLWxpbmtcIik7XG4gICAgICAgIG9wZW5MaW5rQmxhbmsobGlua1dpdGhTdHJhdGVneSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldE9wZW5NZXRob2QoXCJ1bml2ZXJzYWwtbGlua1wiKTtcbiAgICAgIGNvbnN0IGxpbmtXaXRoU3RyYXRlZ3kgPSBhZGRSZXR1cm5TdHJhdGVneSh1bml2ZXJzYWxMaW5rLCBvcHRpb25zLnJldHVyblN0cmF0ZWd5KTtcbiAgICAgIG9wZW5MaW5rQmxhbmsobGlua1dpdGhTdHJhdGVneSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc09TKFwiaW9zXCIpKSB7XG4gICAgICBpZiAob3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9PT0gXCJiYWNrXCIpIHtcbiAgICAgICAgaWYgKGlzQnJvd3NlcihcInNhZmFyaVwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcIm5vbmVcIjtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jyb3dzZXIoXCJjaHJvbWVcIikpIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJnb29nbGVjaHJvbWU6Ly9cIjtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jyb3dzZXIoXCJmaXJlZm94XCIpKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwiZmlyZWZveDovL1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQnJvd3NlcihcIm9wZXJhXCIpKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwib3BlcmEtaHR0cDovL1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBsb2NhdGlvbi5ocmVmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNCcm93c2VyKFwiY2hyb21lXCIpKSB7XG4gICAgICAgIHNldE9wZW5NZXRob2QoXCJ1bml2ZXJzYWwtbGlua1wiKTtcbiAgICAgICAgb3BlbkxpbmsoYWRkUmV0dXJuU3RyYXRlZ3kodW5pdmVyc2FsTGluaywgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSksIFwiX3NlbGZcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRPcGVuTWV0aG9kKFwidW5pdmVyc2FsLWxpbmtcIik7XG4gICAgICAgIG9wZW5MaW5rQmxhbmsoYWRkUmV0dXJuU3RyYXRlZ3kodW5pdmVyc2FsTGluaywgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNPUyhcImFuZHJvaWRcIikpIHtcbiAgICAgIGlmIChvcHRpb25zLnJldHVyblN0cmF0ZWd5ID09PSBcImJhY2tcIikge1xuICAgICAgICBpZiAoaXNCcm93c2VyKFwiY2hyb21lXCIpKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwiZ29vZ2xlY2hyb21lOi8vXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKFwiZmlyZWZveFwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcImZpcmVmb3g6Ly9cIjtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jyb3dzZXIoXCJvcGVyYVwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcIm9wZXJhLWh0dHA6Ly9cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gbG9jYXRpb24uaHJlZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0T3Blbk1ldGhvZChcInVuaXZlcnNhbC1saW5rXCIpO1xuICAgICAgb3BlbkxpbmtCbGFuayhhZGRSZXR1cm5TdHJhdGVneSh1bml2ZXJzYWxMaW5rLCBvcHRpb25zLnJldHVyblN0cmF0ZWd5KSk7XG4gICAgfSBlbHNlIGlmIChpc09TKFwiaXBhZFwiKSkge1xuICAgICAgaWYgKG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPT09IFwiYmFja1wiKSB7XG4gICAgICAgIGlmIChpc0Jyb3dzZXIoXCJzYWZhcmlcIikpIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJub25lXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKFwiY2hyb21lXCIpKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwiZ29vZ2xlY2hyb21lOi8vXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKFwiZmlyZWZveFwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcImZpcmVmb3g6Ly9cIjtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jyb3dzZXIoXCJvcGVyYVwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcIm9wZXJhLWh0dHA6Ly9cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gbG9jYXRpb24uaHJlZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQnJvd3NlcihcImNocm9tZVwiKSkge1xuICAgICAgICBzZXRPcGVuTWV0aG9kKFwidW5pdmVyc2FsLWxpbmtcIik7XG4gICAgICAgIG9wZW5MaW5rKGFkZFJldHVyblN0cmF0ZWd5KHVuaXZlcnNhbExpbmssIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kpLCBcIl9zZWxmXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0T3Blbk1ldGhvZChcInVuaXZlcnNhbC1saW5rXCIpO1xuICAgICAgICBvcGVuTGlua0JsYW5rKGFkZFJldHVyblN0cmF0ZWd5KHVuaXZlcnNhbExpbmssIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzT1MoXCJtYWNvc1wiLCBcIndpbmRvd3NcIiwgXCJsaW51eFwiKSkge1xuICAgICAgaWYgKG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPT09IFwiYmFja1wiKSB7XG4gICAgICAgIGlmIChpc0Jyb3dzZXIoXCJzYWZhcmlcIikpIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJub25lXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKFwiY2hyb21lXCIpKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5TdHJhdGVneSA9IFwiZ29vZ2xlY2hyb21lOi8vXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKFwiZmlyZWZveFwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcImZpcmVmb3g6Ly9cIjtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jyb3dzZXIoXCJvcGVyYVwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuU3RyYXRlZ3kgPSBcIm9wZXJhLWh0dHA6Ly9cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVyblN0cmF0ZWd5ID0gXCJub25lXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbmtXaXRoU3RyYXRlZ3kgPSBhZGRSZXR1cm5TdHJhdGVneSh1bml2ZXJzYWxMaW5rLCBvcHRpb25zLnJldHVyblN0cmF0ZWd5KTtcbiAgICAgIGNvbnN0IHVzZURlZXBMaW5rID0gISFkZWVwTGluayAmJiAhb3B0aW9ucy5mb3JjZVJlZGlyZWN0O1xuICAgICAgaWYgKHVzZURlZXBMaW5rKSB7XG4gICAgICAgIHNldE9wZW5NZXRob2QoXCJjdXN0b20tZGVlcGxpbmtcIik7XG4gICAgICAgIG9wZW5EZWVwbGlua1dpdGhGYWxsYmFjayh0b0RlZXBsaW5rKGxpbmtXaXRoU3RyYXRlZ3ksIGRlZXBMaW5rKSwgKCkgPT4ge1xuICAgICAgICAgIHNldE9wZW5NZXRob2QoXCJ1bml2ZXJzYWwtbGlua1wiKTtcbiAgICAgICAgICBvcGVuTGlua0JsYW5rKGxpbmtXaXRoU3RyYXRlZ3kpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldE9wZW5NZXRob2QoXCJ1bml2ZXJzYWwtbGlua1wiKTtcbiAgICAgICAgb3BlbkxpbmtCbGFuayhsaW5rV2l0aFN0cmF0ZWd5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0T3Blbk1ldGhvZChcInVuaXZlcnNhbC1saW5rXCIpO1xuICAgICAgb3BlbkxpbmtCbGFuayhhZGRSZXR1cm5TdHJhdGVneSh1bml2ZXJzYWxMaW5rLCBvcHRpb25zLnJldHVyblN0cmF0ZWd5KSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlbnJpY2hVbml2ZXJzYWxMaW5rKHVuaXZlcnNhbExpbmssIHBhcmFtcykge1xuICB2YXIgX2EyLCBfYjI7XG4gIGlmICghaXNUZWxlZ3JhbVVybCh1bml2ZXJzYWxMaW5rKSkge1xuICAgIHJldHVybiBhZGRRdWVyeVBhcmFtZXRlcnNJZk5vdFByZXNlbnRlZCh1bml2ZXJzYWxMaW5rLCB7XG4gICAgICBpZDogcGFyYW1zLnNlc3Npb25JZCxcbiAgICAgIHRyYWNlX2lkOiBwYXJhbXMudHJhY2VJZFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGRpcmVjdExpbmsgPSBjb252ZXJ0VG9UR0RpcmVjdExpbmsodW5pdmVyc2FsTGluayk7XG4gIGNvbnN0IGRpcmVjdExpbmtVcmwgPSBuZXcgVVJMKGRpcmVjdExpbmspO1xuICBjb25zdCBwcmV2aW91c1N0YXJ0QXBwID0gZGVjb2RlVGVsZWdyYW1VcmxQYXJhbWV0ZXJzKFxuICAgIChfYTIgPSBkaXJlY3RMaW5rVXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJzdGFydGFwcFwiKSkgIT0gbnVsbCA/IF9hMiA6IFwiXCJcbiAgKTtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IGJ1aWxkU2VhcmNoUGFyYW1zKHByZXZpb3VzU3RhcnRBcHApO1xuICBjb25zdCBzZXNzaW9uSWQgPSAoX2IyID0gcGFyYW1zLnNlc3Npb25JZCkgIT0gbnVsbCA/IF9iMiA6IHNlYXJjaFBhcmFtcy5nZXQoXCJpZFwiKTtcbiAgY29uc3QgdHJhY2VJZCA9IHBhcmFtcy50cmFjZUlkO1xuICBjb25zdCBvcmRlcmVkS2V5cyA9IFtcInRvbmNvbm5lY3RcIiwgXCJ2XCIsIFwiaWRcIiwgXCJ0cmFjZV9pZFwiXTtcbiAgY29uc3QgdW5vcmRlcmVkUGFyYW1zID0gQXJyYXkuZnJvbShzZWFyY2hQYXJhbXMuZW50cmllcygpKS5maWx0ZXIoXG4gICAgKFtrZXldKSA9PiAhb3JkZXJlZEtleXMuaW5jbHVkZXMoa2V5KVxuICApO1xuICBjb25zdCBzdGFydEFwcCA9IGJ1aWxkUXVlcnlQYXJhbXMoX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgdG9uY29ubmVjdDogXCJcIixcbiAgICB2OiBcIjJcIixcbiAgICBpZDogc2Vzc2lvbklkXG4gIH0sIE9iamVjdC5mcm9tRW50cmllcyh1bm9yZGVyZWRQYXJhbXMpKSwge1xuICAgIHRyYWNlX2lkOiB0cmFjZUlkXG4gIH0pKS5yZXBsYWNlKFwiPSZcIiwgXCImXCIpO1xuICBkaXJlY3RMaW5rVXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJzdGFydGFwcFwiLCBlbmNvZGVUZWxlZ3JhbVVybFBhcmFtZXRlcnMoc3RhcnRBcHApKTtcbiAgcmV0dXJuIGRpcmVjdExpbmtVcmwudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGFkZFF1ZXJ5UGFyYW1ldGVyKHVybCwga2V5LCB2YWx1ZSkge1xuICBjb25zdCBwYXJzZWQgPSBuZXcgVVJMKHVybCk7XG4gIHBhcnNlZC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICByZXR1cm4gcGFyc2VkLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBhZGRRdWVyeVBhcmFtZXRlcnNJZk5vdFByZXNlbnRlZCh1cmwsIHBhcmFtcykge1xuICBjb25zdCBwYXJzZWQgPSBuZXcgVVJMKHVybCk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtcykpIHtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgcGFyc2VkLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJzZWQudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1RHRGlyZWN0TGluayh1bml2ZXJzYWxMaW5rKSB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwodW5pdmVyc2FsTGluayk7XG4gIGlmICh1cmwuc2VhcmNoUGFyYW1zLmhhcyhcImF0dGFjaFwiKSkge1xuICAgIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKFwiYXR0YWNoXCIpO1xuICAgIHVybC5wYXRobmFtZSArPSBcIi9zdGFydFwiO1xuICB9XG4gIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkU2VhcmNoUGFyYW1zKHNlYXJjaCA9IFwiXCIpIHtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChcImh0dHBzOi8vZXhhbXBsZS5jb21cIik7XG4gIHVybC5zZWFyY2ggPSBzZWFyY2g7XG4gIHJldHVybiB1cmwuc2VhcmNoUGFyYW1zO1xufVxuZnVuY3Rpb24gYnVpbGRRdWVyeVBhcmFtcyhwYXJhbXMpIHtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gYnVpbGRTZWFyY2hQYXJhbXMoKTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyYW1zKSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VhcmNoUGFyYW1zLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9UR0RlZXBMaW5rKGRpcmVjdExpbmspIHtcbiAgY29uc3QgcGFyc2VkID0gbmV3IFVSTChkaXJlY3RMaW5rKTtcbiAgY29uc3QgWywgZG9tYWluLCBhcHBuYW1lXSA9IHBhcnNlZC5wYXRobmFtZS5zcGxpdChcIi9cIik7XG4gIGNvbnN0IHN0YXJ0YXBwID0gcGFyc2VkLnNlYXJjaFBhcmFtcy5nZXQoXCJzdGFydGFwcFwiKTtcbiAgcmV0dXJuIGB0ZzovL3Jlc29sdmU/ZG9tYWluPSR7ZG9tYWlufSZhcHBuYW1lPSR7YXBwbmFtZX0mc3RhcnRhcHA9JHtzdGFydGFwcH1gO1xufVxuY29uc3QgRGVza3RvcENvbm5lY3Rpb25Nb2RhbCA9IChwcm9wcykgPT4ge1xuICBjb25zdCBbbW9kZSwgc2V0TW9kZV0gPSBjcmVhdGVTaWduYWwoXCJtb2JpbGVcIik7XG4gIGNvbnN0IFtjb25uZWN0aW9uRXJyb3JlZCwgc2V0Q29ubmVjdGlvbkVycm9yZWRdID0gY3JlYXRlU2lnbmFsKG51bGwpO1xuICBjcmVhdGVFZmZlY3QoKCkgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgc2V0Q29ubmVjdGlvbkVycm9yZWQoKF9hMiA9IHByb3BzLmRlZmF1bHRFcnJvcikgIT0gbnVsbCA/IF9hMiA6IG51bGwpO1xuICB9KTtcbiAgY29uc3QgW3VuaXZlcnNhbExpbmssIHNldFVuaXZlcnNhbExpbmtdID0gY3JlYXRlU2lnbmFsKCk7XG4gIGNvbnN0IFtmaXJzdENsaWNrLCBzZXRGaXJzdENsaWNrXSA9IGNyZWF0ZVNpZ25hbCh0cnVlKTtcbiAgY29uc3QgY29ubmVjdG9yID0gdXNlQ29udGV4dChDb25uZWN0b3JDb250ZXh0KTtcbiAgY29uc3QgdW5zdWJzY3JpYmUgPSBjb25uZWN0b3Iub25TdGF0dXNDaGFuZ2UoKCkgPT4ge1xuICB9LCAoZXJyb3IpID0+IHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBXYWxsZXRNaXNzaW5nUmVxdWlyZWRGZWF0dXJlc0Vycm9yKSB7XG4gICAgICBzZXRDb25uZWN0aW9uRXJyb3JlZChcIm1pc3NpbmctZmVhdHVyZXNcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFdhbGxldFdyb25nTmV0d29ya0Vycm9yKSB7XG4gICAgICBzZXRDb25uZWN0aW9uRXJyb3JlZChcIndyb25nLW5ldHdvcmtcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcm9wcy53YWxsZXQuYXBwTmFtZSAhPT0gQVRfV0FMTEVUX0FQUF9OQU1FKSB7XG4gICAgICBzZXRDb25uZWN0aW9uRXJyb3JlZChcImNvbm5lY3Rpb24tZGVjbGluZWRcIik7XG4gICAgfVxuICB9KTtcbiAgb25DbGVhbnVwKHVuc3Vic2NyaWJlKTtcbiAgY29uc3QgZ2VuZXJhdGVVbml2ZXJzYWxMaW5rID0gKCkgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVuaXZlcnNhbExpbmsyID0gY29ubmVjdG9yLmNvbm5lY3Qoe1xuICAgICAgICB1bml2ZXJzYWxMaW5rOiBwcm9wcy53YWxsZXQudW5pdmVyc2FsTGluayxcbiAgICAgICAgYnJpZGdlVXJsOiBwcm9wcy53YWxsZXQuYnJpZGdlVXJsXG4gICAgICB9LCBwcm9wcy5hZGRpdGlvbmFsUmVxdWVzdCwge1xuICAgICAgICB0cmFjZUlkOiAoX2EyID0gcHJvcHMud2FsbGV0c01vZGFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIudHJhY2VJZFxuICAgICAgfSk7XG4gICAgICBzZXRVbml2ZXJzYWxMaW5rKHVuaXZlcnNhbExpbmsyKTtcbiAgICB9IGNhdGNoIChlMikge1xuICAgIH1cbiAgfTtcbiAgY3JlYXRlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodW50cmFjayhtb2RlKSAhPT0gXCJleHRlbnNpb25cIiAmJiAoc3VwcG9ydHNNb2JpbGUocHJvcHMud2FsbGV0KSB8fCBzdXBwb3J0c0Rlc2t0b3AocHJvcHMud2FsbGV0KSkpIHtcbiAgICAgIGdlbmVyYXRlVW5pdmVyc2FsTGluaygpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IG9uQ2xpY2tNb2JpbGUgPSAoKSA9PiB7XG4gICAgc2V0Q29ubmVjdGlvbkVycm9yZWQobnVsbCk7XG4gICAgaWYgKG1vZGUoKSA9PT0gXCJleHRlbnNpb25cIikge1xuICAgICAgZ2VuZXJhdGVVbml2ZXJzYWxMaW5rKCk7XG4gICAgfVxuICAgIHNldE1vZGUoXCJtb2JpbGVcIik7XG4gICAgc2V0TGFzdFNlbGVjdGVkV2FsbGV0SW5mbyhfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcm9wcy53YWxsZXQpLCB7XG4gICAgICBvcGVuTWV0aG9kOiBcInFyY29kZVwiXG4gICAgfSkpO1xuICB9O1xuICBjb25zdCBvbkNsaWNrRGVza3RvcCA9ICgpID0+IHtcbiAgICBzZXRDb25uZWN0aW9uRXJyb3JlZChudWxsKTtcbiAgICBpZiAobW9kZSgpID09PSBcImV4dGVuc2lvblwiKSB7XG4gICAgICBnZW5lcmF0ZVVuaXZlcnNhbExpbmsoKTtcbiAgICB9XG4gICAgc2V0TW9kZShcImRlc2t0b3BcIik7XG4gICAgaWYgKGlzVGVsZWdyYW1VcmwodW5pdmVyc2FsTGluaygpKSkge1xuICAgICAgb25DbGlja1RlbGVncmFtKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZvcmNlUmVkaXJlY3QgPSAhZmlyc3RDbGljaygpO1xuICAgICAgc2V0Rmlyc3RDbGljayhmYWxzZSk7XG4gICAgICByZWRpcmVjdFRvV2FsbGV0KHVuaXZlcnNhbExpbmsoKSwgcHJvcHMud2FsbGV0LmRlZXBMaW5rLCB7XG4gICAgICAgIHJldHVyblN0cmF0ZWd5OiBhcHBTdGF0ZS5yZXR1cm5TdHJhdGVneSxcbiAgICAgICAgZm9yY2VSZWRpcmVjdFxuICAgICAgfSwgKG1ldGhvZCkgPT4ge1xuICAgICAgICBzZXRMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHByb3BzLndhbGxldCksIHtcbiAgICAgICAgICBvcGVuTWV0aG9kOiBtZXRob2RcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBvbkNsaWNrVGVsZWdyYW0gPSAoKSA9PiB7XG4gICAgY29uc3QgZm9yY2VSZWRpcmVjdCA9ICFmaXJzdENsaWNrKCk7XG4gICAgc2V0Rmlyc3RDbGljayhmYWxzZSk7XG4gICAgc2V0TGFzdFNlbGVjdGVkV2FsbGV0SW5mbyhfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcm9wcy53YWxsZXQpLCB7XG4gICAgICBvcGVuTWV0aG9kOiBcInVuaXZlcnNhbC1saW5rXCJcbiAgICB9KSk7XG4gICAgcmVkaXJlY3RUb1RlbGVncmFtKHVuaXZlcnNhbExpbmsoKSwge1xuICAgICAgcmV0dXJuU3RyYXRlZ3k6IGFwcFN0YXRlLnJldHVyblN0cmF0ZWd5LFxuICAgICAgdHdhUmV0dXJuVXJsOiBhcHBTdGF0ZS50d2FSZXR1cm5VcmwsXG4gICAgICBmb3JjZVJlZGlyZWN0XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IG9uQ2xpY2tFeHRlbnNpb24gPSAoKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICBzZXRDb25uZWN0aW9uRXJyb3JlZChudWxsKTtcbiAgICBzZXRNb2RlKFwiZXh0ZW5zaW9uXCIpO1xuICAgIGlmIChpc1dhbGxldEluZm9DdXJyZW50bHlJbmplY3RlZChwcm9wcy53YWxsZXQpKSB7XG4gICAgICBzZXRMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvKHByb3BzLndhbGxldCk7XG4gICAgICBjb25uZWN0b3IuY29ubmVjdCh7XG4gICAgICAgIGpzQnJpZGdlS2V5OiBwcm9wcy53YWxsZXQuanNCcmlkZ2VLZXlcbiAgICAgIH0sIHByb3BzLmFkZGl0aW9uYWxSZXF1ZXN0LCB7XG4gICAgICAgIHRyYWNlSWQ6IChfYTIgPSBwcm9wcy53YWxsZXRzTW9kYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi50cmFjZUlkXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGlmIChzdXBwb3J0c01vYmlsZShwcm9wcy53YWxsZXQpKSB7XG4gICAgb25DbGlja01vYmlsZSgpO1xuICB9IGVsc2UgaWYgKHN1cHBvcnRzRXh0ZW5zaW9uKHByb3BzLndhbGxldCkpIHtcbiAgICBvbkNsaWNrRXh0ZW5zaW9uKCk7XG4gIH0gZWxzZSB7XG4gICAgb25DbGlja0Rlc2t0b3AoKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KERlc2t0b3BDb25uZWN0aW9uTW9kYWxTdHlsZWQsIHtcbiAgICBcImRhdGEtdGMtd2FsbGV0cy1tb2RhbC1jb25uZWN0aW9uLWRlc2t0b3BcIjogXCJ0cnVlXCIsXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICByZXR1cm4gIXByb3BzLmJhY2tEaXNhYmxlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoU3R5bGVkSWNvbkJ1dHRvbiQ0LCB7XG4gICAgICAgICAgICBpY29uOiBcImFycm93XCIsXG4gICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBwcm9wcy5vbkJhY2tDbGljaygpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoSDFTdHlsZWQkOCwge1xuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLndhbGxldC5uYW1lO1xuICAgICAgICB9XG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIG1lbW8oKCkgPT4gbW9kZSgpID09PSBcIm1vYmlsZVwiKSgpICYmICFjb25uZWN0aW9uRXJyb3JlZCgpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChIMlN0eWxlZCQ0LCB7XG4gICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5kZXNrdG9wQ29ubmVjdGlvbk1vZGFsLnNjYW5RUlwiLFxuICAgICAgICAgICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHByb3BzLndhbGxldC5uYW1lXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW1wiU2NhbiB0aGUgUVIgY29kZSBiZWxvdyB3aXRoIHlvdXIgcGhvbmXigJlzIG9yIFwiLCBtZW1vKCgpID0+IHByb3BzLndhbGxldC5uYW1lKSwgXCLigJlzIGNhbWVyYVwiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChCb2R5U3R5bGVkJDEsIHtcbiAgICAgICAgZ2V0IHFyKCkge1xuICAgICAgICAgIHJldHVybiBtb2RlKCkgPT09IFwibW9iaWxlXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFN3aXRjaCwge1xuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25FcnJvcmVkKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChFcnJvckljb25TdHlsZWQkMiwge1xuICAgICAgICAgICAgICAgICAgICBzaXplOiBcInNcIlxuICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTd2l0Y2gsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25FcnJvcmVkKCkgPT09IFwibWlzc2luZy1mZWF0dXJlc1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChCb2R5VGV4dFN0eWxlZCQyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwuZGVza3RvcENvbm5lY3Rpb25Nb2RhbC5taXNzaW5nRmVhdHVyZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgdHJhbnNsYXRpb25WYWx1ZXMoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwcm9wcy53YWxsZXQubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlBsZWFzZSB1cGRhdGUgV2FsbGV0LCB5b3VyIHZlcnNpb24gZG9lcyBub3Qgc3VwcG9ydCByZXF1aXJlZCBmZWF0dXJlcyBmb3IgdGhpcyBkQXBwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uRXJyb3JlZCgpID09PSBcImNvbm5lY3Rpb24tZGVjbGluZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQm9keVRleHRTdHlsZWQkMiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmRlc2t0b3BDb25uZWN0aW9uTW9kYWwuY29ubmVjdGlvbkRlY2xpbmVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiQ29ubmVjdGlvbiBkZWNsaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbkVycm9yZWQoKSA9PT0gXCJub3Qtc3VwcG9ydGVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEJvZHlUZXh0U3R5bGVkJDIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5kZXNrdG9wQ29ubmVjdGlvbk1vZGFsLm5vdFN1cHBvcnRlZFdhbGxldFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHByb3BzLndhbGxldC5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttZW1vKCgpID0+IHByb3BzLndhbGxldC5uYW1lKSwgXCIgZG9lc27igJl0IHN1cHBvcnQgdGhlIHJlcXVlc3RlZCBhY3Rpb24uIFBsZWFzZSBjb25uZWN0IGFub3RoZXIgd2FsbGV0IHRoYXQgc3VwcG9ydHMgaXQuXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uRXJyb3JlZCgpID09PSBcIndyb25nLW5ldHdvcmtcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQm9keVRleHRTdHlsZWQkMiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmRlc2t0b3BDb25uZWN0aW9uTW9kYWwud3JvbmdOZXR3b3JrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcHJvcHMud2FsbGV0Lm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiQ29ubmVjdGVkIHdhbGxldCBpcyBvbiBhIGRpZmZlcmVudCBuZXR3b3JrLiBQbGVhc2Ugc3dpdGNoIG5ldHdvcmsgaW4gXCIsIG1lbW8oKCkgPT4gcHJvcHMud2FsbGV0Lm5hbWUpLCBcIiBhbmQgdHJ5IGFnYWluLlwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChCdXR0b25zQ29udGFpbmVyU3R5bGVkJDIsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbkVycm9yZWQoKSAhPT0gXCJub3Qtc3VwcG9ydGVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBsZWZ0SWNvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoUmV0cnlJY29uLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgb25DbGljaygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtb2RlKCkgPT09IFwiZXh0ZW5zaW9uXCIgPyBvbkNsaWNrRXh0ZW5zaW9uIDogb25DbGlja0Rlc2t0b3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcImNvbW1vbi5yZXRyeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJSZXRyeVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uRXJyb3JlZCgpID09PSBcIm1pc3NpbmctZmVhdHVyZXNcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoTGluaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBocmVmKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLndhbGxldC5hYm91dFVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsYW5rOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQnV0dG9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBsZWZ0SWNvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KExpbmtJY29uLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5kZXNrdG9wQ29ubmVjdGlvbk1vZGFsLnVwZGF0ZVdhbGxldFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHByb3BzLndhbGxldC5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiVXBkYXRlIFwiLCBtZW1vKCgpID0+IHByb3BzLndhbGxldC5uYW1lKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25FcnJvcmVkKCkgPT09IFwibm90LXN1cHBvcnRlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChCdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBwcm9wcy5vbkJhY2tDbGljaygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNsYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwuZGVza3RvcENvbm5lY3Rpb25Nb2RhbC5jaG9vc2VBbm90aGVyV2FsbGV0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkNob29zZSBBbm90aGVyIFdhbGxldFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZGUoKSA9PT0gXCJtb2JpbGVcIjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoUVJDb2RlU3R5bGVkJDEsIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZUNvcHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBnZXQgc291cmNlVXJsKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRSZXR1cm5TdHJhdGVneSh1bml2ZXJzYWxMaW5rKCksIFwibm9uZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGltYWdlVXJsKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy53YWxsZXQuaW1hZ2VVcmw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZGUoKSA9PT0gXCJleHRlbnNpb25cIjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzV2FsbGV0SW5mb0N1cnJlbnRseUluamVjdGVkKHByb3BzLndhbGxldCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChMb2FkZXJTdHlsZWQkMSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogXCJzXCJcbiAgICAgICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEJvZHlUZXh0U3R5bGVkJDIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmRlc2t0b3BDb25uZWN0aW9uTW9kYWwuY29udGludWVJbkV4dGVuc2lvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHByb3BzLndhbGxldC5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiQ29udGludWUgaW4gXCIsIG1lbW8oKCkgPT4gcHJvcHMud2FsbGV0Lm5hbWUpLCBcIiBicm93c2VyIGV4dGVuc2lvbuKAplwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEJ1dHRvbnNDb250YWluZXJTdHlsZWQkMiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBsZWZ0SWNvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoUmV0cnlJY29uLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBvbkNsaWNrRXh0ZW5zaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNsYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwiY29tbW9uLnJldHJ5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlJldHJ5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFpc1dhbGxldEluZm9DdXJyZW50bHlJbmplY3RlZChwcm9wcy53YWxsZXQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoQm9keVRleHRTdHlsZWQkMiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwuZGVza3RvcENvbm5lY3Rpb25Nb2RhbC5kb250SGF2ZUV4dGVuc2lvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHByb3BzLndhbGxldC5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiU2VlbXMgeW91IGRvbid0IGhhdmUgaW5zdGFsbGVkIFwiLCBtZW1vKCgpID0+IHByb3BzLndhbGxldC5uYW1lKSwgXCIgYnJvd3NlciBleHRlbnNpb25cIl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChCdXR0b25zQ29udGFpbmVyU3R5bGVkJDIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChMaW5rLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGhyZWYoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMud2FsbGV0LmFib3V0VXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxhbms6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChCdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHJpZ2h0SWNvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KExpbmtJY29uLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IG9uQ2xpY2tFeHRlbnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5kZXNrdG9wQ29ubmVjdGlvbk1vZGFsLmdldFdhbGxldFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHByb3BzLndhbGxldC5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiR2V0IFwiLCBtZW1vKCgpID0+IHByb3BzLndhbGxldC5uYW1lKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbW9kZSgpID09PSBcImRlc2t0b3BcIjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KExvYWRlckljb24sIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogXCJtXCJcbiAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoQm9keVRleHRTdHlsZWQkMiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5kZXNrdG9wQ29ubmVjdGlvbk1vZGFsLmNvbnRpbnVlT25EZXNrdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcHJvcHMud2FsbGV0Lm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcIkNvbnRpbnVlIGluIFwiLCBtZW1vKCgpID0+IHByb3BzLndhbGxldC5uYW1lKSwgXCIgb24gZGVza3RvcOKAplwiXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChCdXR0b25zQ29udGFpbmVyU3R5bGVkJDIsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KEJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGxlZnRJY29uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFJldHJ5SWNvbiwge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IG9uQ2xpY2tEZXNrdG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwiY29tbW9uLnJldHJ5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiUmV0cnlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KExpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBocmVmKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMud2FsbGV0LmFib3V0VXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsYW5rOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCByaWdodEljb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KExpbmtJY29uLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmRlc2t0b3BDb25uZWN0aW9uTW9kYWwuZ2V0V2FsbGV0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcHJvcHMud2FsbGV0Lm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcIkdldCBcIiwgbWVtbygoKSA9PiBwcm9wcy53YWxsZXQubmFtZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLndhbGxldC5hcHBOYW1lID09PSBBVF9XQUxMRVRfQVBQX05BTUU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRnQnV0dG9uU3R5bGVkLCB7XG4gICAgICAgICAgICBnZXQgcmlnaHRJY29uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRnSW1hZ2VTdHlsZWQsIHtcbiAgICAgICAgICAgICAgICBnZXQgc3JjKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIElNRy5URztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNjYWxlOiBcInNcIixcbiAgICAgICAgICAgIG9uQ2xpY2s6IG9uQ2xpY2tUZWxlZ3JhbSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmRlc2t0b3BDb25uZWN0aW9uTW9kYWwub3BlbldhbGxldE9uVGVsZWdyYW1cIixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJPcGVuIFdhbGxldCBpbiBUZWxlZ3JhbSBvbiBkZXNrdG9wXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcHMud2FsbGV0LmFwcE5hbWUgIT09IEFUX1dBTExFVF9BUFBfTkFNRTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQm90dG9tQnV0dG9uc0NvbnRhaW5lclN0eWxlZCwge1xuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbWVtbygoKSA9PiBtb2RlKCkgIT09IFwibW9iaWxlXCIpKCkgJiYgc3VwcG9ydHNNb2JpbGUocHJvcHMud2FsbGV0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoRm9vdGVyQnV0dG9uJDEsIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwZWFyYW5jZTogXCJzZWNvbmRhcnlcIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGxlZnRJY29uKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoTW9iaWxlSWNvbiwge30pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBvbkNsaWNrTW9iaWxlLFxuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwiY29tbW9uLm1vYmlsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiTW9iaWxlXCJcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtZW1vKCgpID0+IG1vZGUoKSAhPT0gXCJleHRlbnNpb25cIikoKSAmJiBzdXBwb3J0c0V4dGVuc2lvbihwcm9wcy53YWxsZXQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChGb290ZXJCdXR0b24kMSwge1xuICAgICAgICAgICAgICAgICAgICBhcHBlYXJhbmNlOiBcInNlY29uZGFyeVwiLFxuICAgICAgICAgICAgICAgICAgICBnZXQgbGVmdEljb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChCcm93c2VySWNvbiwge30pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBvbkNsaWNrRXh0ZW5zaW9uLFxuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwiY29tbW9uLmJyb3dzZXJFeHRlbnNpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkJyb3dzZXIgRXh0ZW5zaW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtZW1vKCgpID0+IG1vZGUoKSAhPT0gXCJkZXNrdG9wXCIpKCkgJiYgc3VwcG9ydHNEZXNrdG9wKHByb3BzLndhbGxldCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEZvb3RlckJ1dHRvbiQxLCB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGVhcmFuY2U6IFwic2Vjb25kYXJ5XCIsXG4gICAgICAgICAgICAgICAgICAgIGdldCBsZWZ0SWNvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KERlc2t0b3BJY29uLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IG9uQ2xpY2tEZXNrdG9wLFxuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwiY29tbW9uLmRlc2t0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkRlc2t0b3BcIlxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSldO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3QgSW5mb01vZGFsU3R5bGVkID0gc3R5bGVkLmRpdmBgO1xuY29uc3QgU3R5bGVkSWNvbkJ1dHRvbiQzID0gc3R5bGVkKEljb25CdXR0b24pYFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDE2cHg7XG4gICAgbGVmdDogMTZweDtcbmA7XG5jb25zdCBIMVN0eWxlZCQ3ID0gc3R5bGVkKEgxKWBcbiAgICBtYXJnaW4tYm90dG9tOiAxOHB4O1xuYDtcbmNvbnN0IEluZm9CbG9jayA9IHN0eWxlZC5kaXZgXG4gICAgcGFkZGluZzogMTZweCAwO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuYDtcbmNvbnN0IEluZm9CbG9ja0ljb25DbGFzcyA9IHVgXG4gICAgbWFyZ2luLWJvdHRvbTogMTJweDtcbmA7XG5jb25zdCBIM1N0eWxlZCQxID0gc3R5bGVkKEgzKWBcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgbWFyZ2luLWJvdHRvbTogNHB4O1xuYDtcbmNvbnN0IFRleHRTdHlsZWQkMiA9IHN0eWxlZChUZXh0KWBcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgbWF4LXdpZHRoOiAzNTJweDtcbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeX07XG5gO1xuY29uc3QgQnV0dG9uc0Jsb2NrID0gc3R5bGVkLmRpdmBcbiAgICBwYWRkaW5nOiAxNnB4IDI0cHggMjRweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZ2FwOiA4cHg7XG5gO1xuY29uc3QgTElOS1MgPSB7XG4gIEdFVF9BX1dBTExFVDogXCJodHRwczovL3Rvbi5vcmcvd2FsbGV0cz9maWx0ZXJzW3dhbGxldF9mZWF0dXJlc11bc2x1Z11bJGluXT1kYXBwLWF1dGgmcGFnaW5hdGlvbltsaW1pdF09LTFcIlxufTtcbmNvbnN0IEluZm9Nb2RhbCA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEluZm9Nb2RhbFN0eWxlZCwge1xuICAgIFwiZGF0YS10Yy13YWxsZXRzLW1vZGFsLWluZm9cIjogXCJ0cnVlXCIsXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoU3R5bGVkSWNvbkJ1dHRvbiQzLCB7XG4gICAgICAgIGljb246IFwiYXJyb3dcIixcbiAgICAgICAgb25DbGljazogKCkgPT4gcHJvcHMub25CYWNrQ2xpY2soKVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChIMVN0eWxlZCQ3LCB7XG4gICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmluZm9Nb2RhbC53aGF0SXNBV2FsbGV0XCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIldoYXQgaXMgYSB3YWxsZXRcIlxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTY3JvbGxDb250YWluZXIsIHtcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KEluZm9CbG9jaywge1xuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTZWN1cml0eUljb24sIHtcbiAgICAgICAgICAgICAgICBcImNsYXNzXCI6IEluZm9CbG9ja0ljb25DbGFzc1xuICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEgzU3R5bGVkJDEsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5pbmZvTW9kYWwuc2VjdXJlRGlnaXRhbEFzc2V0c1wiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlNlY3VyZSBkaWdpdGFsIGFzc2V0cyBzdG9yYWdlXCJcbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChUZXh0U3R5bGVkJDIsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5pbmZvTW9kYWwud2FsbGV0UHJvdGVjdHNcIixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJBIHdhbGxldCBwcm90ZWN0cyBhbmQgbWFuYWdlcyB5b3VyIGRpZ2l0YWwgYXNzZXRzIGluY2x1ZGluZyBUT04sIHRva2VucyBhbmQgY29sbGVjdGFibGVzLlwiXG4gICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEluZm9CbG9jaywge1xuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChQZXJzb25hbGl0eUljb24sIHtcbiAgICAgICAgICAgICAgICBcImNsYXNzXCI6IEluZm9CbG9ja0ljb25DbGFzc1xuICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEgzU3R5bGVkJDEsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5pbmZvTW9kYWwuY29udHJvbElkZW50aXR5XCIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiQ29udHJvbCB5b3VyIFdlYjMgaWRlbnRpdHlcIlxuICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFRleHRTdHlsZWQkMiwge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmluZm9Nb2RhbC5tYW5hZ2VJZGVudGl0eVwiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIk1hbmFnZSB5b3VyIGRpZ2l0YWwgaWRlbnRpdHkgYW5kIGFjY2VzcyBkZWNlbnRyYWxpemVkIGFwcGxpY2F0aW9ucyB3aXRoIGVhc2UuIE1haW50YWluIGNvbnRyb2wgb3ZlciB5b3VyIGRhdGEgYW5kIGVuZ2FnZSBzZWN1cmVseSBpbiB0aGUgYmxvY2tjaGFpbiBlY29zeXN0ZW0uXCJcbiAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoSW5mb0Jsb2NrLCB7XG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFN3YXBJY29uLCB7XG4gICAgICAgICAgICAgICAgXCJjbGFzc1wiOiBJbmZvQmxvY2tJY29uQ2xhc3NcbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChIM1N0eWxlZCQxLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwuaW5mb01vZGFsLmVmZm9ydGxlc3NDcnlwdG9UcmFuc2FjdGlvbnNcIixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJFZmZvcnRsZXNzIGNyeXB0byB0cmFuc2FjdGlvbnNcIlxuICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFRleHRTdHlsZWQkMiwge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmluZm9Nb2RhbC5lYXNpbHlTZW5kXCIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiRWFzaWx5IHNlbmQsIHJlY2VpdmUsIG1vbml0b3IgeW91ciBjcnlwdG9jdXJyZW5jaWVzLiBTdHJlYW1saW5lIHlvdXIgb3BlcmF0aW9ucyB3aXRoIGRlY2VudHJhbGl6ZWQgYXBwbGljYXRpb25zLlwiXG4gICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEJ1dHRvbnNCbG9jaywge1xuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KExpbmssIHtcbiAgICAgICAgICAgICAgICBnZXQgaHJlZigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBMSU5LUy5HRVRfQV9XQUxMRVQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBibGFuazogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICBnZXQgcmlnaHRJY29uKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoV2FsbGV0SWNvbiwge30pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwuaW5mb01vZGFsLmdldEFXYWxsZXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkdldCBhIFdhbGxldFwiXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSldO1xuICAgICAgICB9XG4gICAgICB9KV07XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBNb2JpbGVDb25uZWN0aW9uTW9kYWxTdHlsZWQgPSBzdHlsZWQuZGl2YGA7XG5jb25zdCBCb2R5U3R5bGVkID0gc3R5bGVkLmRpdmBcbiAgICBmbGV4OiAxO1xuICAgIG1hcmdpbi10b3A6IDE4cHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgbWluLWhlaWdodDogMjMycHg7XG5gO1xuY29uc3QgSDFTdHlsZWQkNiA9IHN0eWxlZChIMSlgXG4gICAgbWF4LXdpZHRoOiAyNjJweDtcbiAgICBtYXJnaW46IDAgYXV0byA4cHg7XG5gO1xuY29uc3QgU3R5bGVkSWNvbkJ1dHRvbiQyID0gc3R5bGVkKEljb25CdXR0b24pYFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDE2cHg7XG4gICAgbGVmdDogMTZweDtcbmA7XG5jb25zdCBGb290ZXJTdHlsZWQgPSBzdHlsZWQuZGl2YFxuICAgIHBhZGRpbmc6IDE2cHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGdhcDogMTJweDtcbiAgICBib3JkZXItdG9wOiAwLjVweCBzb2xpZCAkeyhwcm9wcykgPT4gcmdiYShwcm9wcy50aGVtZS5jb2xvcnMuaWNvbi5zZWNvbmRhcnksIDAuMil9O1xuYDtcbmNvbnN0IEltYWdlU3R5bGVkID0gc3R5bGVkKEltYWdlKWBcbiAgICB3aWR0aDogMzZweDtcbiAgICBoZWlnaHQ6IDM2cHg7XG4gICAgYm9yZGVyLXJhZGl1czogMTBweDtcbmA7XG5jb25zdCBGb290ZXJCdXR0b24gPSBzdHlsZWQoTGluaylgXG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XG5gO1xuY29uc3QgTG9hZGVyU3R5bGVkID0gc3R5bGVkKExvYWRlckljb24pYFxuICAgIG1hcmdpbi1ib3R0b206IDE4cHg7XG4gICAgbWFyZ2luLXRvcDogMnB4O1xuYDtcbmNvbnN0IEVycm9ySWNvblN0eWxlZCQxID0gc3R5bGVkKEVycm9ySWNvbilgXG4gICAgbWFyZ2luLWJvdHRvbTogMTZweDtcbmA7XG5jb25zdCBCb2R5VGV4dFN0eWxlZCQxID0gc3R5bGVkKEgyKWBcbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeX07XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIG1hcmdpbi1ib3R0b206IDIwcHg7XG5gO1xuY29uc3QgQnV0dG9uc0NvbnRhaW5lclN0eWxlZCQxID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGdhcDogOHB4O1xuICAgIHBhZGRpbmctYm90dG9tOiAxNnB4O1xuYDtcbmNvbnN0IGFjdGlvbkJ1dHRvbkJvcmRlclJhZGl1cyQxID0ge1xuICBtOiBcIjE2cHhcIixcbiAgczogXCI4cHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCBIMVN0eWxlZCQ1ID0gc3R5bGVkKEgxKWBcbiAgICBtYXJnaW4tYm90dG9tOiAycHg7XG4gICAgcGFkZGluZzogMCA1MnB4O1xuYDtcbmNvbnN0IEgyU3R5bGVkJDMgPSBzdHlsZWQoSDIpYFxuICAgIG1hcmdpbi1ib3R0b206IDIwcHg7XG4gICAgcGFkZGluZzogMCA2NHB4O1xuYDtcbmNvbnN0IFFyQ29kZVdyYXBwZXIkMSA9IHN0eWxlZC5kaXZgXG4gICAgcGFkZGluZzogMCAyNHB4IDE2cHg7XG5gO1xuY29uc3QgQnV0dG9uc1dyYXBwZXIkMSA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICAgIGdhcDogMTZweDtcbiAgICBwYWRkaW5nOiAwIDI0cHggMjRweDtcbiAgICBtYXJnaW4tdG9wOiAwO1xuYDtcbmNvbnN0IEFjdGlvbkJ1dHRvbiQxID0gc3R5bGVkKEJ1dHRvbilgXG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiA1NnB4O1xuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiBhY3Rpb25CdXR0b25Cb3JkZXJSYWRpdXMkMVtwcm9wcy50aGVtZS5ib3JkZXJSYWRpdXNdfTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4gcmdiYShwcm9wcy50aGVtZS5jb2xvcnMuYWNjZW50LCAwLjEyKX07XG4gICAgY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuYWNjZW50fTtcbiAgICBmb250LXNpemU6IDE2cHg7XG4gICAgbGluZS1oZWlnaHQ6IDIwcHg7XG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgICBwYWRkaW5nOiAxN3B4IDIwcHggMTlweCAyMHB4O1xuYDtcbmNvbnN0IE1vYmlsZUNvbm5lY3Rpb25RUiA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChIMVN0eWxlZCQ1LCB7XG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIHByb3BzLndhbGxldEluZm8ubmFtZTtcbiAgICB9XG4gIH0pLCBjcmVhdGVDb21wb25lbnQoSDJTdHlsZWQkMywge1xuICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLm1vYmlsZUNvbm5lY3Rpb25Nb2RhbC5zY2FuUVJcIixcbiAgICBnZXQgdHJhbnNsYXRpb25WYWx1ZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBwcm9wcy53YWxsZXRJbmZvLm5hbWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gW1wiU2NhbiB0aGUgUVIgY29kZSBiZWxvdyB3aXRoIHlvdXIgcGhvbmXigJlzIG9yIFwiLCBtZW1vKCgpID0+IHByb3BzLndhbGxldEluZm8ubmFtZSksIFwi4oCZcyBjYW1lcmFcIl07XG4gICAgfVxuICB9KSwgY3JlYXRlQ29tcG9uZW50KFFyQ29kZVdyYXBwZXIkMSwge1xuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoUVJDb2RlLCB7XG4gICAgICAgIGdldCBpbWFnZVVybCgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcHMud2FsbGV0SW5mby5pbWFnZVVybDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHNvdXJjZVVybCgpIHtcbiAgICAgICAgICByZXR1cm4gYWRkUmV0dXJuU3RyYXRlZ3kocHJvcHMudW5pdmVyc2FsTGluaywgXCJub25lXCIpO1xuICAgICAgICB9LFxuICAgICAgICBkaXNhYmxlQ29weTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KSwgY3JlYXRlQ29tcG9uZW50KEJ1dHRvbnNXcmFwcGVyJDEsIHtcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChBY3Rpb25CdXR0b24kMSwge1xuICAgICAgICBhcHBlYXJhbmNlOiBcInNlY29uZGFyeVwiLFxuICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICByZXR1cm4gKF9hMiA9IHByb3BzLm9uT3BlbkxpbmspID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChwcm9wcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5tb2JpbGVVbml2ZXJzYWxNb2RhbC5vcGVuTGlua1wiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiT3BlbiBMaW5rXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChBY3Rpb25CdXR0b24kMSwge1xuICAgICAgICBhcHBlYXJhbmNlOiBcInNlY29uZGFyeVwiLFxuICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICByZXR1cm4gKF9hMiA9IHByb3BzLm9uQ29weSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYWxsKHByb3BzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNsYXRpb24sIHtcbiAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvbktleSgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLmlzQ29waWVkU2hvd24gIT09IHZvaWQgMCA/IFwiY29tbW9uLmNvcGllZFwiIDogXCJjb21tb24uY29weUxpbmtcIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wcy5pc0NvcGllZFNob3duICE9PSB2b2lkIDAgPyBcIkNvcGllZFwiIDogXCJDb3B5IExpbmtcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSldO1xuICAgIH1cbiAgfSldO1xufTtcbmNvbnN0IE1vYmlsZUNvbm5lY3Rpb25Nb2RhbCA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IFtmaXJzdENsaWNrLCBzZXRGaXJzdENsaWNrXSA9IGNyZWF0ZVNpZ25hbCh0cnVlKTtcbiAgY29uc3QgW3Nob3dRUiwgc2V0U2hvd1FSXSA9IGNyZWF0ZVNpZ25hbChmYWxzZSk7XG4gIGNvbnN0IFtjb25uZWN0aW9uRXJyb3JlZCwgc2V0Q29ubmVjdGlvbkVycm9yZWRdID0gY3JlYXRlU2lnbmFsKG51bGwpO1xuICBjcmVhdGVFZmZlY3QoKCkgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgc2V0Q29ubmVjdGlvbkVycm9yZWQoKF9hMiA9IHByb3BzLmRlZmF1bHRFcnJvcikgIT0gbnVsbCA/IF9hMiA6IG51bGwpO1xuICB9KTtcbiAgY29uc3QgY29ubmVjdG9yID0gdXNlQ29udGV4dChDb25uZWN0b3JDb250ZXh0KTtcbiAgY29uc3QgdW5zdWJzY3JpYmUgPSBjb25uZWN0b3Iub25TdGF0dXNDaGFuZ2UoKCkgPT4ge1xuICB9LCAoZXJyb3IpID0+IHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBXYWxsZXRNaXNzaW5nUmVxdWlyZWRGZWF0dXJlc0Vycm9yKSB7XG4gICAgICBzZXRDb25uZWN0aW9uRXJyb3JlZChcIm1pc3NpbmctZmVhdHVyZXNcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFdhbGxldFdyb25nTmV0d29ya0Vycm9yKSB7XG4gICAgICBzZXRDb25uZWN0aW9uRXJyb3JlZChcIndyb25nLW5ldHdvcmtcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldENvbm5lY3Rpb25FcnJvcmVkKG51bGwpO1xuICB9KTtcbiAgY29uc3QgdW5pdmVyc2FsTGluayA9IGNyZWF0ZU1lbW8oKCkgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgcmV0dXJuIGNvbm5lY3Rvci5jb25uZWN0KHtcbiAgICAgIHVuaXZlcnNhbExpbms6IHByb3BzLndhbGxldC51bml2ZXJzYWxMaW5rLFxuICAgICAgYnJpZGdlVXJsOiBwcm9wcy53YWxsZXQuYnJpZGdlVXJsXG4gICAgfSwgcHJvcHMuYWRkaXRpb25hbFJlcXVlc3QsIHtcbiAgICAgIHRyYWNlSWQ6IChfYTIgPSBwcm9wcy53YWxsZXRNb2RhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnRyYWNlSWRcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IG9uQ2xpY2tUZWxlZ3JhbSA9ICgpID0+IHtcbiAgICBjb25zdCBhbHdheXNGb3JjZVJlZGlyZWN0ID0gdHJ1ZTtcbiAgICBzZXRMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHByb3BzLndhbGxldCksIHtcbiAgICAgIG9wZW5NZXRob2Q6IFwidW5pdmVyc2FsLWxpbmtcIlxuICAgIH0pKTtcbiAgICByZWRpcmVjdFRvVGVsZWdyYW0odW5pdmVyc2FsTGluaygpLCB7XG4gICAgICByZXR1cm5TdHJhdGVneTogYXBwU3RhdGUucmV0dXJuU3RyYXRlZ3ksXG4gICAgICB0d2FSZXR1cm5Vcmw6IGFwcFN0YXRlLnR3YVJldHVyblVybCxcbiAgICAgIGZvcmNlUmVkaXJlY3Q6IGFsd2F5c0ZvcmNlUmVkaXJlY3RcbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgb25SZXRyeSA9ICgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50VW5pdmVyc2FsTGluayA9IHVuaXZlcnNhbExpbmsoKTtcbiAgICBpZiAoaXNUZWxlZ3JhbVVybChjdXJyZW50VW5pdmVyc2FsTGluaykpIHtcbiAgICAgIHJldHVybiBvbkNsaWNrVGVsZWdyYW0oKTtcbiAgICB9XG4gICAgc2V0Q29ubmVjdGlvbkVycm9yZWQobnVsbCk7XG4gICAgY29uc3QgZm9yY2VSZWRpcmVjdCA9ICFmaXJzdENsaWNrKCk7XG4gICAgc2V0Rmlyc3RDbGljayhmYWxzZSk7XG4gICAgcmVkaXJlY3RUb1dhbGxldCh1bml2ZXJzYWxMaW5rKCksIHByb3BzLndhbGxldC5kZWVwTGluaywge1xuICAgICAgcmV0dXJuU3RyYXRlZ3k6IGFwcFN0YXRlLnJldHVyblN0cmF0ZWd5LFxuICAgICAgZm9yY2VSZWRpcmVjdFxuICAgIH0sIChtZXRob2QpID0+IHtcbiAgICAgIHNldExhc3RTZWxlY3RlZFdhbGxldEluZm8oX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMud2FsbGV0KSwge1xuICAgICAgICBvcGVuTWV0aG9kOiBtZXRob2RcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgW2lzQ29waWVkU2hvd24sIHNldElzQ29waWVkU2hvd25dID0gY3JlYXRlU2lnbmFsKHZvaWQgMCk7XG4gIGNvbnN0IG9uQ29weSA9ICgpID0+IF9fYXN5bmMobnVsbCwgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBpZiAoaXNDb3BpZWRTaG93bigpICE9PSB2b2lkIDApIHtcbiAgICAgIGNsZWFyVGltZW91dChpc0NvcGllZFNob3duKCkpO1xuICAgIH1cbiAgICB5aWVsZCBjb3B5VG9DbGlwYm9hcmQodW5pdmVyc2FsTGluaygpKTtcbiAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHNldElzQ29waWVkU2hvd24odm9pZCAwKSwgMTUwMCk7XG4gICAgc2V0SXNDb3BpZWRTaG93bih0aW1lb3V0SWQpO1xuICB9KTtcbiAgY29uc3Qgb25PcGVuUVIgPSAoKSA9PiB7XG4gICAgc2V0Q29ubmVjdGlvbkVycm9yZWQobnVsbCk7XG4gICAgc2V0U2hvd1FSKHRydWUpO1xuICAgIHNldExhc3RTZWxlY3RlZFdhbGxldEluZm8oX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMud2FsbGV0KSwge1xuICAgICAgb3Blbk1ldGhvZDogXCJxcmNvZGVcIlxuICAgIH0pKTtcbiAgfTtcbiAgY29uc3Qgb25DbG9zZVFSID0gKCkgPT4ge1xuICAgIHNldFNob3dRUihmYWxzZSk7XG4gICAgc2V0TGFzdFNlbGVjdGVkV2FsbGV0SW5mbyhfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcm9wcy53YWxsZXQpLCB7XG4gICAgICBvcGVuTWV0aG9kOiBcInVuaXZlcnNhbC1saW5rXCJcbiAgICB9KSk7XG4gIH07XG4gIGNvbnN0IG9uQmFjayA9ICgpID0+IHtcbiAgICBpZiAoc2hvd1FSKCkpIHtcbiAgICAgIG9uQ2xvc2VRUigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wcy5vbkJhY2tDbGljaygpO1xuICAgIH1cbiAgfTtcbiAgb25DbGVhbnVwKHVuc3Vic2NyaWJlKTtcbiAgb25SZXRyeSgpO1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KE1vYmlsZUNvbm5lY3Rpb25Nb2RhbFN0eWxlZCwge1xuICAgIFwiZGF0YS10Yy13YWxsZXRzLW1vZGFsLWNvbm5lY3Rpb24tbW9iaWxlXCI6IFwidHJ1ZVwiLFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgcmV0dXJuICFwcm9wcy5iYWNrRGlzYWJsZWQgfHwgc2hvd1FSKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFN0eWxlZEljb25CdXR0b24kMiwge1xuICAgICAgICAgICAgaWNvbjogXCJhcnJvd1wiLFxuICAgICAgICAgICAgb25DbGljazogb25CYWNrXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICByZXR1cm4gc2hvd1FSKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KE1vYmlsZUNvbm5lY3Rpb25RUiwge1xuICAgICAgICAgICAgZ2V0IHVuaXZlcnNhbExpbmsoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bml2ZXJzYWxMaW5rKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHdhbGxldEluZm8oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wcy53YWxsZXQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25PcGVuTGluazogb25SZXRyeSxcbiAgICAgICAgICAgIG9uQ29weSxcbiAgICAgICAgICAgIGdldCBpc0NvcGllZFNob3duKCkge1xuICAgICAgICAgICAgICByZXR1cm4gaXNDb3BpZWRTaG93bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgcmV0dXJuICFzaG93UVIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KEgxU3R5bGVkJDYsIHtcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLndhbGxldC5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoQm9keVN0eWxlZCwge1xuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbkVycm9yZWQoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KEVycm9ySWNvblN0eWxlZCQxLCB7XG4gICAgICAgICAgICAgICAgICAgIHNpemU6IFwic1wiXG4gICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFN3aXRjaCwge1xuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbkVycm9yZWQoKSA9PT0gXCJtaXNzaW5nLWZlYXR1cmVzXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEJvZHlUZXh0U3R5bGVkJDEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5tb2JpbGVDb25uZWN0aW9uTW9kYWwubWlzc2luZ0ZlYXR1cmVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcHJvcHMud2FsbGV0Lm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJQbGVhc2UgdXBkYXRlIFdhbGxldCwgeW91ciB2ZXJzaW9uIGRvZXMgbm90IHN1cHBvcnQgcmVxdWlyZWQgZmVhdHVyZXMgZm9yIHRoaXMgZEFwcFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbkVycm9yZWQoKSA9PT0gXCJjb25uZWN0aW9uLWRlY2xpbmVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEJvZHlUZXh0U3R5bGVkJDEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5tb2JpbGVDb25uZWN0aW9uTW9kYWwuY29ubmVjdGlvbkRlY2xpbmVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiQ29ubmVjdGlvbiBkZWNsaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbkVycm9yZWQoKSA9PT0gXCJ3cm9uZy1uZXR3b3JrXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEJvZHlUZXh0U3R5bGVkJDEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5tb2JpbGVDb25uZWN0aW9uTW9kYWwud3JvbmdOZXR3b3JrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcHJvcHMud2FsbGV0Lm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiQ29ubmVjdGVkIHdhbGxldCBpcyBvbiBhIGRpZmZlcmVudCBuZXR3b3JrLiBQbGVhc2Ugc3dpdGNoIG5ldHdvcmsgaW4gXCIsIG1lbW8oKCkgPT4gcHJvcHMud2FsbGV0Lm5hbWUpLCBcIiBhbmQgdHJ5IGFnYWluLlwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbkVycm9yZWQoKSA9PT0gXCJub3Qtc3VwcG9ydGVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEJvZHlUZXh0U3R5bGVkJDEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5tb2JpbGVDb25uZWN0aW9uTW9kYWwubm90U3VwcG9ydGVkV2FsbGV0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcHJvcHMud2FsbGV0Lm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW21lbW8oKCkgPT4gcHJvcHMud2FsbGV0Lm5hbWUpLCBcIiBkb2Vzbid0IHN1cHBvcnQgdGhlIHJlcXVlc3RlZCBhY3Rpb24uIFBsZWFzZSBjb25uZWN0IGFub3RoZXIgd2FsbGV0IHRoYXQgc3VwcG9ydHMgaXQuXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEJ1dHRvbnNDb250YWluZXJTdHlsZWQkMSwge1xuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChTd2l0Y2gsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uRXJyb3JlZCgpID09PSBcIm1pc3NpbmctZmVhdHVyZXNcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KEJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgbGVmdEljb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChSZXRyeUljb24sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogb25SZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNsYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcImNvbW1vbi5yZXRyeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiUmV0cnlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KExpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGhyZWYoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLndhbGxldC5hYm91dFVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxhbms6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGxlZnRJY29uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KExpbmtJY29uLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwubW9iaWxlQ29ubmVjdGlvbk1vZGFsLnVwZGF0ZVdhbGxldFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHByb3BzLndhbGxldC5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcIlVwZGF0ZSBcIiwgbWVtbygoKSA9PiBwcm9wcy53YWxsZXQubmFtZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uRXJyb3JlZCgpID09PSBcIm5vdC1zdXBwb3J0ZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQnV0dG9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHByb3BzLm9uQmFja0NsaWNrKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5tb2JpbGVDb25uZWN0aW9uTW9kYWwuY2hvb3NlQW5vdGhlcldhbGxldFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiQ2hvb3NlIEFub3RoZXIgV2FsbGV0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbkVycm9yZWQoKSA9PT0gXCJ3cm9uZy1uZXR3b3JrXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgbGVmdEljb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChSZXRyeUljb24sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogb25SZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNsYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcImNvbW1vbi5yZXRyeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiUmV0cnlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uRXJyb3JlZCgpID09PSBcImNvbm5lY3Rpb24tZGVjbGluZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KEJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgbGVmdEljb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChSZXRyeUljb24sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogb25SZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNsYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcImNvbW1vbi5yZXRyeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiUmV0cnlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgbGVmdEljb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChRUkljb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBmaWxsKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhlbWUuY29sb3JzLmFjY2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogb25PcGVuUVIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5tb2JpbGVDb25uZWN0aW9uTW9kYWwuc2hvd1FSXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJTaG93IFFSIENvZGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICFjb25uZWN0aW9uRXJyb3JlZCgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoTG9hZGVyU3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgICAgIHNpemU6IFwic1wiXG4gICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEJvZHlUZXh0U3R5bGVkJDEsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwubW9iaWxlQ29ubmVjdGlvbk1vZGFsLmNvbnRpbnVlSW5cIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwcm9wcy53YWxsZXQubmFtZVxuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiQ29udGludWUgaW4gXCIsIG1lbW8oKCkgPT4gcHJvcHMud2FsbGV0Lm5hbWUpLCBcIuKAplwiXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChCdXR0b25zQ29udGFpbmVyU3R5bGVkJDEsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KEJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGxlZnRJY29uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFJldHJ5SWNvbiwge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IG9uUmV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNsYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJjb21tb24ucmV0cnlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJSZXRyeVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoQnV0dG9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgbGVmdEljb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoUVJJY29uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGZpbGwoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhlbWUuY29sb3JzLmFjY2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IG9uT3BlblFSLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwubW9iaWxlQ29ubmVjdGlvbk1vZGFsLnNob3dRUlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlNob3cgUVIgQ29kZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoRm9vdGVyU3R5bGVkLCB7XG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KEltYWdlU3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgZ2V0IHNyYygpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy53YWxsZXQuaW1hZ2VVcmw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEgzLCB7XG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLndhbGxldC5uYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChGb290ZXJCdXR0b24sIHtcbiAgICAgICAgICAgICAgICBnZXQgaHJlZigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy53YWxsZXQuYWJvdXRVcmw7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBibGFuazogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEJ1dHRvbiwge1xuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwiY29tbW9uLmdldFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiR0VUXCJcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSldO1xuICAgICAgICB9XG4gICAgICB9KV07XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBib3JkZXJzJDIgPSB7XG4gIG06IFwiMTZweFwiLFxuICBzOiBcIjEycHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCB0Z0JvcmRlcnMgPSB7XG4gIG06IFwiNnB4XCIsXG4gIHM6IFwiNnB4XCIsXG4gIG5vbmU6IFwiMFwiXG59O1xuc3R5bGVkLmxpYFxuICAgIHdpZHRoOiA4MnB4O1xuICAgIG1pbi13aWR0aDogODJweDtcbiAgICBoZWlnaHQ6IDEyNHB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIHBhZGRpbmc6IDhweCA0cHg7XG5cbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMXMgZWFzZS1pbi1vdXQ7XG5cbiAgICAke21lZGlhTm90VG91Y2h9IHtcbiAgICAgICAgJjpob3ZlciB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMDQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJjphY3RpdmUge1xuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuOTYpO1xuICAgIH1cblxuICAgICR7bWVkaWFUb3VjaH0ge1xuICAgICAgICAmOmFjdGl2ZSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuOTIpO1xuICAgICAgICB9XG4gICAgfVxuYDtcbmNvbnN0IEgxU3R5bGVkJDQgPSBzdHlsZWQoSDEpYFxuICAgIG1hcmdpbi10b3A6IDM4cHg7XG4gICAgbWFyZ2luLWJvdHRvbTogNHB4O1xuICAgIHBhZGRpbmc6IDAgMjRweDtcbmA7XG5jb25zdCBIMlN0eWxlZCQyID0gc3R5bGVkKEgyKWBcbiAgICBtYXJnaW46ICR7KHByb3BzKSA9PiB7XG4gIHZhciBfYTI7XG4gIHJldHVybiAoX2EyID0gcHJvcHMubWFyZ2luKSAhPSBudWxsID8gX2EyIDogXCIwIDAgMjhweCAwXCI7XG59fTtcbiAgICBwYWRkaW5nOiAkeyhwcm9wcykgPT4ge1xuICB2YXIgX2EyO1xuICByZXR1cm4gKF9hMiA9IHByb3BzLnBhZGRpbmcpICE9IG51bGwgPyBfYTIgOiBcIjAgMjRweFwiO1xufX07XG4gICAgbWluLWhlaWdodDogJHsocHJvcHMpID0+IHtcbiAgdmFyIF9hMjtcbiAgcmV0dXJuIChfYTIgPSBwcm9wcy5wYWRkaW5nKSAhPSBudWxsID8gX2EyIDogXCI0NHB4XCI7XG59fTtcbiAgICBtYXgtd2lkdGg6ICR7KHByb3BzKSA9PiBwcm9wcy5tYXhXaWR0aH1weDtcbiAgICBtYXJnaW4tbGVmdDogJHsocHJvcHMpID0+IHByb3BzLm1heFdpZHRoID8gXCJhdXRvXCIgOiBcIjBweFwifTtcbiAgICBtYXJnaW4tcmlnaHQ6ICR7KHByb3BzKSA9PiBwcm9wcy5tYXhXaWR0aCA/IFwiYXV0b1wiIDogXCIwcHhcIn07XG5gO1xuc3R5bGVkKEJ1dHRvbilgXG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgbWFyZ2luOiAwIGF1dG87XG5gO1xuY29uc3QgVGVsZWdyYW1CdXR0b25TdHlsZWQgPSBzdHlsZWQoQnV0dG9uKWBcbiAgICBtYXJnaW46IDAgMjhweCAyNHB4O1xuICAgIHdpZHRoOiBjYWxjKDEwMCUgLSA1NnB4KTtcbiAgICBib3JkZXItcmFkaXVzOiAkeyhwcm9wcykgPT4gYm9yZGVycyQyW3Byb3BzLnRoZW1lLmJvcmRlclJhZGl1c119O1xuICAgIHBhZGRpbmc6IDE0cHggMTZweCAxNHB4IDE0cHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy50ZWxlZ3JhbUJ1dHRvbn07XG5cbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5jb25zdGFudC53aGl0ZX07XG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgICBmb250LXNpemU6IDE2cHg7XG4gICAgbGluZS1oZWlnaHQ6IDIwcHg7XG5cbiAgICBAbWVkaWEgKG1heC13aWR0aDogMzc1cHgpIHtcbiAgICAgICAgbWFyZ2luOiAwIDE2cHggMjRweDtcbiAgICAgICAgd2lkdGg6IGNhbGMoMTAwJSAtIDMycHgpO1xuICAgIH1cbmA7XG5jb25zdCBUR0ltYWdlU3R5bGVkID0gc3R5bGVkKEltYWdlKWBcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICBib3JkZXItcmFkaXVzOiAkeyhwcm9wcykgPT4gdGdCb3JkZXJzW3Byb3BzLnRoZW1lLmJvcmRlclJhZGl1c119O1xuICAgIHdpZHRoOiAyNHB4O1xuICAgIGhlaWdodDogMjRweDtcbmA7XG5jb25zdCBTdHlsZWRMZWZ0QWN0aW9uQnV0dG9uID0gc3R5bGVkKEljb25CdXR0b24pYFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDE2cHg7XG4gICAgbGVmdDogMTZweDtcbmA7XG5jb25zdCBhY3Rpb25CdXR0b25Cb3JkZXJSYWRpdXMgPSB7XG4gIG06IFwiMTZweFwiLFxuICBzOiBcIjhweFwiLFxuICBub25lOiBcIjBcIlxufTtcbmNvbnN0IEgxU3R5bGVkJDMgPSBzdHlsZWQoSDEpYFxuICAgIG1hcmdpbi1ib3R0b206IDJweDtcbiAgICBwYWRkaW5nOiAwIDUycHg7XG5gO1xuY29uc3QgSDJTdHlsZWQkMSA9IHN0eWxlZChIMilgXG4gICAgbWFyZ2luLWJvdHRvbTogMjBweDtcbiAgICBwYWRkaW5nOiAwIDY0cHg7XG5gO1xuY29uc3QgUXJDb2RlV3JhcHBlciA9IHN0eWxlZC5kaXZgXG4gICAgcGFkZGluZzogMCAyNHB4IDE2cHg7XG5gO1xuY29uc3QgQnV0dG9uc1dyYXBwZXIgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICBnYXA6IDE2cHg7XG4gICAgcGFkZGluZzogMCAyNHB4IDI0cHg7XG4gICAgbWFyZ2luLXRvcDogMDtcbmA7XG5jb25zdCBBY3Rpb25CdXR0b24gPSBzdHlsZWQoQnV0dG9uKWBcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDU2cHg7XG4gICAgYm9yZGVyLXJhZGl1czogJHsocHJvcHMpID0+IGFjdGlvbkJ1dHRvbkJvcmRlclJhZGl1c1twcm9wcy50aGVtZS5ib3JkZXJSYWRpdXNdfTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4gcmdiYShwcm9wcy50aGVtZS5jb2xvcnMuYWNjZW50LCAwLjEyKX07XG4gICAgY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuYWNjZW50fTtcbiAgICBmb250LXNpemU6IDE2cHg7XG4gICAgbGluZS1oZWlnaHQ6IDIwcHg7XG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgICBwYWRkaW5nOiAxN3B4IDIwcHggMTlweCAyMHB4O1xuYDtcbmNvbnN0IE1vYmlsZVVuaXZlcnNhbFFSID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KEgxU3R5bGVkJDMsIHtcbiAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5tb2JpbGVVbml2ZXJzYWxNb2RhbC5jb25uZWN0WW91cldhbGxldFwiLFxuICAgIGNoaWxkcmVuOiBcIkNvbm5lY3QgeW91ciBUT04gd2FsbGV0XCJcbiAgfSksIGNyZWF0ZUNvbXBvbmVudChIMlN0eWxlZCQxLCB7XG4gICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwubW9iaWxlVW5pdmVyc2FsTW9kYWwuc2NhblwiLFxuICAgIGNoaWxkcmVuOiBcIlNjYW4gd2l0aCB5b3VyIG1vYmlsZSB3YWxsZXRcIlxuICB9KSwgY3JlYXRlQ29tcG9uZW50KFFyQ29kZVdyYXBwZXIsIHtcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFFSQ29kZSwge1xuICAgICAgICBnZXQgaW1hZ2VVcmwoKSB7XG4gICAgICAgICAgcmV0dXJuIElNRy5UT047XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBzb3VyY2VVcmwoKSB7XG4gICAgICAgICAgcmV0dXJuIGFkZFJldHVyblN0cmF0ZWd5KHByb3BzLnVuaXZlcnNhbExpbmssIFwibm9uZVwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzYWJsZUNvcHk6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSksIGNyZWF0ZUNvbXBvbmVudChCdXR0b25zV3JhcHBlciwge1xuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KEFjdGlvbkJ1dHRvbiwge1xuICAgICAgICBhcHBlYXJhbmNlOiBcInNlY29uZGFyeVwiLFxuICAgICAgICBvbkNsaWNrOiAoKSA9PiBwcm9wcy5vbk9wZW5MaW5rKCksXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5tb2JpbGVVbml2ZXJzYWxNb2RhbC5vcGVuTGlua1wiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiT3BlbiBMaW5rXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChBY3Rpb25CdXR0b24sIHtcbiAgICAgICAgYXBwZWFyYW5jZTogXCJzZWNvbmRhcnlcIixcbiAgICAgICAgb25DbGljazogKCkgPT4gcHJvcHMub25Db3B5KCksXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICBnZXQgdHJhbnNsYXRpb25LZXkoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wcy5pc0NvcGllZFNob3duICE9PSB2b2lkIDAgPyBcImNvbW1vbi5jb3BpZWRcIiA6IFwiY29tbW9uLmNvcHlMaW5rXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuaXNDb3BpZWRTaG93biAhPT0gdm9pZCAwID8gXCJDb3BpZWRcIiA6IFwiQ29weSBMaW5rXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pXTtcbiAgICB9XG4gIH0pXTtcbn07XG5mdW5jdGlvbiBnZXRVbmlxdWVCcmlkZ2VzKHdhbGxldHNMaXN0KSB7XG4gIGNvbnN0IHVuaXF1ZUJyaWRnZXMgPSBuZXcgU2V0KFxuICAgIHdhbGxldHNMaXN0LmZpbHRlcihpc1dhbGxldEluZm9SZW1vdGUpLm1hcCgoaXRlbSkgPT4gaXRlbS5icmlkZ2VVcmwpXG4gICk7XG4gIHJldHVybiBBcnJheS5mcm9tKHVuaXF1ZUJyaWRnZXMpLm1hcCgoYnJpZGdlVXJsKSA9PiAoeyBicmlkZ2VVcmwgfSkpO1xufVxuZnVuY3Rpb24gYnJpZGdlc0lzRXF1YWwobGVmdCwgcmlnaHQpIHtcbiAgY29uc3QgbGVmdFNldCA9IG5ldyBTZXQobGVmdCA9PSBudWxsID8gdm9pZCAwIDogbGVmdC5tYXAoKGkyKSA9PiBpMi5icmlkZ2VVcmwpKTtcbiAgY29uc3QgcmlnaHRTZXQgPSBuZXcgU2V0KHJpZ2h0ID09IG51bGwgPyB2b2lkIDAgOiByaWdodC5tYXAoKGkyKSA9PiBpMi5icmlkZ2VVcmwpKTtcbiAgcmV0dXJuIGxlZnRTZXQuc2l6ZSA9PT0gcmlnaHRTZXQuc2l6ZSAmJiBbLi4ubGVmdFNldF0uZXZlcnkoKHZhbHVlKSA9PiByaWdodFNldC5oYXModmFsdWUpKTtcbn1cbnZhciBfdG1wbCQkMSA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8bGk+YCksIF90bXBsJDIgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPGRpdiBkYXRhLXRjLXdhbGxldHMtbW9kYWwtdW5pdmVyc2FsLW1vYmlsZT10cnVlPmApO1xuY29uc3QgTW9iaWxlVW5pdmVyc2FsTW9kYWwgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgW3Nob3dRUiwgc2V0U2hvd1FSXSA9IGNyZWF0ZVNpZ25hbChmYWxzZSk7XG4gIGNvbnN0IFtmaXJzdENsaWNrLCBzZXRGaXJzdENsaWNrXSA9IGNyZWF0ZVNpZ25hbCh0cnVlKTtcbiAgY29uc3QgW3VuaXZlcnNhbExpbmssIHNldFVuaXZlcnNhbExpbmtdID0gY3JlYXRlU2lnbmFsKG51bGwpO1xuICBjb25zdCBjb25uZWN0b3IgPSBhcHBTdGF0ZS5jb25uZWN0b3I7XG4gIGNvbnN0IHdhbGxldHNMaXN0ID0gKCkgPT4gcHJvcHMud2FsbGV0c0xpc3QuZmlsdGVyKCh3KSA9PiBzdXBwb3J0c01vYmlsZSh3KSAmJiB3LmFwcE5hbWUgIT09IEFUX1dBTExFVF9BUFBfTkFNRSk7XG4gIGNvbnN0IHNob3VsZFNob3dNb3JlQnV0dG9uID0gKCkgPT4gd2FsbGV0c0xpc3QoKS5sZW5ndGggPiA3O1xuICBjb25zdCB3YWxsZXRzQnJpZGdlcyA9IGNyZWF0ZU1lbW8oKCkgPT4gZ2V0VW5pcXVlQnJpZGdlcyhwcm9wcy53YWxsZXRzTGlzdCksIG51bGwsIHtcbiAgICBlcXVhbHM6IGJyaWRnZXNJc0VxdWFsXG4gIH0pO1xuICBjb25zdCBhdFdhbGxldFN1cHBvcnRGZWF0dXJlcyA9IGNyZWF0ZU1lbW8oKCkgPT4ge1xuICAgIHZhciBfYTIsIF9iMjtcbiAgICByZXR1cm4gKF9iMiA9IChfYTIgPSBwcm9wcy53YWxsZXRzTGlzdC5maW5kKCh3YWxsZXQpID0+IHdhbGxldC5hcHBOYW1lID09PSBBVF9XQUxMRVRfQVBQX05BTUUpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmlzU3VwcG9ydFJlcXVpcmVkRmVhdHVyZXMpICE9IG51bGwgPyBfYjIgOiBmYWxzZTtcbiAgfSwgbnVsbCk7XG4gIGNvbnN0IGdldFVuaXZlcnNhbExpbmsgPSAoKSA9PiB7XG4gICAgaWYgKCF1bml2ZXJzYWxMaW5rKCkpIHtcbiAgICAgIHNldFVuaXZlcnNhbExpbmsoY29ubmVjdG9yLmNvbm5lY3Qod2FsbGV0c0JyaWRnZXMoKSwgcHJvcHMuYWRkaXRpb25hbFJlcXVlc3QsIHtcbiAgICAgICAgdHJhY2VJZDogcHJvcHMud2FsbGV0TW9kYWxTdGF0ZS50cmFjZUlkXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiB1bml2ZXJzYWxMaW5rKCk7XG4gIH07XG4gIHNldExhc3RTZWxlY3RlZFdhbGxldEluZm8oe1xuICAgIG9wZW5NZXRob2Q6IFwidW5pdmVyc2FsLWxpbmtcIlxuICB9KTtcbiAgY29uc3QgW2lzQ29waWVkU2hvd24sIHNldElzQ29waWVkU2hvd25dID0gY3JlYXRlU2lnbmFsKHZvaWQgMCk7XG4gIGNvbnN0IG9uQ29weSA9ICgpID0+IF9fYXN5bmMobnVsbCwgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBpZiAoaXNDb3BpZWRTaG93bigpICE9PSB2b2lkIDApIHtcbiAgICAgIGNsZWFyVGltZW91dChpc0NvcGllZFNob3duKCkpO1xuICAgIH1cbiAgICB5aWVsZCBjb3B5VG9DbGlwYm9hcmQoZ2V0VW5pdmVyc2FsTGluaygpKTtcbiAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHNldElzQ29waWVkU2hvd24odm9pZCAwKSwgMTUwMCk7XG4gICAgc2V0SXNDb3BpZWRTaG93bih0aW1lb3V0SWQpO1xuICB9KTtcbiAgY29uc3Qgb25TZWxlY3RVbml2ZXJzYWwgPSAoKSA9PiB7XG4gICAgY29uc3QgZm9yY2VSZWRpcmVjdCA9ICFmaXJzdENsaWNrKCk7XG4gICAgc2V0Rmlyc3RDbGljayhmYWxzZSk7XG4gICAgcmVkaXJlY3RUb1dhbGxldChnZXRVbml2ZXJzYWxMaW5rKCksIHZvaWQgMCwge1xuICAgICAgcmV0dXJuU3RyYXRlZ3k6IGFwcFN0YXRlLnJldHVyblN0cmF0ZWd5LFxuICAgICAgZm9yY2VSZWRpcmVjdFxuICAgIH0sIChtZXRob2QpID0+IHtcbiAgICAgIHNldExhc3RTZWxlY3RlZFdhbGxldEluZm8oe1xuICAgICAgICBvcGVuTWV0aG9kOiBtZXRob2RcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBvblNlbGVjdFRlbGVncmFtID0gKCkgPT4ge1xuICAgIHNldFVuaXZlcnNhbExpbmsobnVsbCk7XG4gICAgY29uc3QgYXRXYWxsZXQgPSBwcm9wcy53YWxsZXRzTGlzdC5maW5kKCh3YWxsZXQpID0+IHdhbGxldC5hcHBOYW1lID09PSBBVF9XQUxMRVRfQVBQX05BTUUpO1xuICAgIGlmICghYXRXYWxsZXQgfHwgIWlzV2FsbGV0SW5mb1JlbW90ZShhdFdhbGxldCkpIHtcbiAgICAgIHRocm93IG5ldyBUb25Db25uZWN0VUlFcnJvcihcIkB3YWxsZXQgYm90IG5vdCBmb3VuZCBpbiB0aGUgd2FsbGV0cyBsaXN0XCIpO1xuICAgIH1cbiAgICBjb25zdCB3YWxsZXRMaW5rID0gY29ubmVjdG9yLmNvbm5lY3Qoe1xuICAgICAgYnJpZGdlVXJsOiBhdFdhbGxldC5icmlkZ2VVcmwsXG4gICAgICB1bml2ZXJzYWxMaW5rOiBhdFdhbGxldC51bml2ZXJzYWxMaW5rXG4gICAgfSwgcHJvcHMuYWRkaXRpb25hbFJlcXVlc3QsIHtcbiAgICAgIHRyYWNlSWQ6IHByb3BzLndhbGxldE1vZGFsU3RhdGUudHJhY2VJZFxuICAgIH0pO1xuICAgIGNvbnN0IGZvcmNlUmVkaXJlY3QgPSAhZmlyc3RDbGljaygpO1xuICAgIHNldEZpcnN0Q2xpY2soZmFsc2UpO1xuICAgIHJlZGlyZWN0VG9UZWxlZ3JhbSh3YWxsZXRMaW5rLCB7XG4gICAgICByZXR1cm5TdHJhdGVneTogYXBwU3RhdGUucmV0dXJuU3RyYXRlZ3ksXG4gICAgICB0d2FSZXR1cm5Vcmw6IGFwcFN0YXRlLnR3YVJldHVyblVybCxcbiAgICAgIGZvcmNlUmVkaXJlY3RcbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgb25PcGVuUVIgPSAoKSA9PiB7XG4gICAgc2V0U2hvd1FSKHRydWUpO1xuICAgIHNldExhc3RTZWxlY3RlZFdhbGxldEluZm8oe1xuICAgICAgb3Blbk1ldGhvZDogXCJxcmNvZGVcIlxuICAgIH0pO1xuICB9O1xuICBjb25zdCBvbkNsb3NlUVIgPSAoKSA9PiB7XG4gICAgc2V0U2hvd1FSKGZhbHNlKTtcbiAgICBzZXRMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvKHtcbiAgICAgIG9wZW5NZXRob2Q6IFwidW5pdmVyc2FsLWxpbmtcIlxuICAgIH0pO1xuICB9O1xuICBjb25zdCBzdXBwb3J0ZWRXYWxsZXRzID0gY3JlYXRlTWVtbygoKSA9PiB3YWxsZXRzTGlzdCgpLmZpbHRlcigod2FsbGV0KSA9PiB3YWxsZXQuaXNTdXBwb3J0UmVxdWlyZWRGZWF0dXJlcyksIG51bGwpO1xuICBjb25zdCB2aXNpYmxlV2FsbGV0cyA9IGNyZWF0ZU1lbW8oKCkgPT4gc3VwcG9ydGVkV2FsbGV0cygpLnNsaWNlKDAsIDMpLCBudWxsKTtcbiAgc2V0TGFzdFZpc2libGVXYWxsZXRzSW5mbyh7XG4gICAgd2FsbGV0c01lbnU6IFwibWFpbl9zY3JlZW5cIixcbiAgICB3YWxsZXRzOiBhdFdhbGxldFN1cHBvcnRGZWF0dXJlcygpID8gW3Byb3BzLndhbGxldHNMaXN0LmZpbmQoKHdhbGxldCkgPT4gd2FsbGV0LmFwcE5hbWUgPT09IEFUX1dBTExFVF9BUFBfTkFNRSksIC4uLnZpc2libGVXYWxsZXRzKCldIDogdmlzaWJsZVdhbGxldHMoKVxuICB9KTtcbiAgY29uc3QgZm91cldhbGxldHNJdGVtID0gY3JlYXRlTWVtbygoKSA9PiB3YWxsZXRzTGlzdCgpLmZpbHRlcigod2FsbGV0KSA9PiAhdmlzaWJsZVdhbGxldHMoKS5maW5kKCh3KSA9PiB3LmFwcE5hbWUgPT09IHdhbGxldC5hcHBOYW1lKSkuc2xpY2UoMCwgNCksIG51bGwpO1xuICByZXR1cm4gKCgpID0+IHtcbiAgICB2YXIgX2VsJCA9IF90bXBsJDIoKTtcbiAgICBpbnNlcnQoX2VsJCwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICByZXR1cm4gc2hvd1FSKCk7XG4gICAgICB9LFxuICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTdHlsZWRMZWZ0QWN0aW9uQnV0dG9uLCB7XG4gICAgICAgICAgaWNvbjogXCJhcnJvd1wiLFxuICAgICAgICAgIG9uQ2xpY2s6IG9uQ2xvc2VRUlxuICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KE1vYmlsZVVuaXZlcnNhbFFSLCB7XG4gICAgICAgICAgZ2V0IHVuaXZlcnNhbExpbmsoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VW5pdmVyc2FsTGluaygpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGlzQ29waWVkU2hvd24oKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNDb3BpZWRTaG93bigpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25PcGVuTGluazogb25TZWxlY3RVbml2ZXJzYWwsXG4gICAgICAgICAgb25Db3B5XG4gICAgICAgIH0pXTtcbiAgICAgIH1cbiAgICB9KSwgbnVsbCk7XG4gICAgaW5zZXJ0KF9lbCQsIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgcmV0dXJuICFzaG93UVIoKTtcbiAgICAgIH0sXG4gICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFN0eWxlZExlZnRBY3Rpb25CdXR0b24sIHtcbiAgICAgICAgICBnZXQgaWNvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoUVJJY29uLCB7fSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkNsaWNrOiBvbk9wZW5RUlxuICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEgxU3R5bGVkJDQsIHtcbiAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5tb2JpbGVVbml2ZXJzYWxNb2RhbC5jb25uZWN0WW91cldhbGxldFwiLFxuICAgICAgICAgIGNoaWxkcmVuOiBcIkNvbm5lY3QgeW91ciBUT04gd2FsbGV0XCJcbiAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICByZXR1cm4gYXRXYWxsZXRTdXBwb3J0RmVhdHVyZXMoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KEgyU3R5bGVkJDIsIHtcbiAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwubW9iaWxlVW5pdmVyc2FsTW9kYWwub3BlbldhbGxldE9uVGVsZWdyYW1PclNlbGVjdFwiLFxuICAgICAgICAgICAgICBtYXhXaWR0aDogMzIwLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogXCJVc2UgV2FsbGV0IGluIFRlbGVncmFtIG9yIGNob29zZSBvdGhlciBhcHBsaWNhdGlvblwiXG4gICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFRlbGVncmFtQnV0dG9uU3R5bGVkLCB7XG4gICAgICAgICAgICAgIGdldCBsZWZ0SWNvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEF0V2FsbGV0SWNvbiwge30pO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBnZXQgcmlnaHRJY29uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVEdJbWFnZVN0eWxlZCwge1xuICAgICAgICAgICAgICAgICAgZ2V0IHNyYygpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElNRy5URztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb25DbGljazogb25TZWxlY3RUZWxlZ3JhbSxcbiAgICAgICAgICAgICAgc2NhbGU6IFwic1wiLFxuICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwubW9iaWxlVW5pdmVyc2FsTW9kYWwub3BlbldhbGxldE9uVGVsZWdyYW1cIixcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkNvbm5lY3QgV2FsbGV0IGluIFRlbGVncmFtXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChIMlN0eWxlZCQyLCB7XG4gICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwubW9iaWxlVW5pdmVyc2FsTW9kYWwuY2hvb3NlT3RoZXJBcHBsaWNhdGlvblwiLFxuICAgICAgICAgIG1heFdpZHRoOiAzNDIsXG4gICAgICAgICAgcGFkZGluZzogXCIwIDI0cHggOHB4IDI0cHhcIixcbiAgICAgICAgICBtYXJnaW46IFwiMFwiLFxuICAgICAgICAgIGNoaWxkcmVuOiBcIkNob29zZSBvdGhlciBhcHBsaWNhdGlvblwiXG4gICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoV2FsbGV0VWxDb250YWluZXIsIHtcbiAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChGb3IsIHtcbiAgICAgICAgICAgICAgZ2V0IGVhY2goKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lbW8oKCkgPT4gISFzaG91bGRTaG93TW9yZUJ1dHRvbigpKSgpID8gdmlzaWJsZVdhbGxldHMoKSA6IHN1cHBvcnRlZFdhbGxldHMoKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgY2hpbGRyZW46ICh3YWxsZXQpID0+ICgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9lbCQzID0gX3RtcGwkJDEoKTtcbiAgICAgICAgICAgICAgICBpbnNlcnQoX2VsJDMsIGNyZWF0ZUNvbXBvbmVudChXYWxsZXRJdGVtLCB7XG4gICAgICAgICAgICAgICAgICBnZXQgaWNvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGxldC5pbWFnZVVybDtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGxldC5uYW1lO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHByb3BzLm9uU2VsZWN0KHdhbGxldClcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9lbCQzO1xuICAgICAgICAgICAgICB9KSgpXG4gICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNob3VsZFNob3dNb3JlQnV0dG9uKCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2VsJDIgPSBfdG1wbCQkMSgpO1xuICAgICAgICAgICAgICAgIGluc2VydChfZWwkMiwgY3JlYXRlQ29tcG9uZW50KEZvdXJXYWxsZXRzSXRlbSwge1xuICAgICAgICAgICAgICAgICAgbGFiZWxMaW5lMTogXCJWaWV3IGFsbFwiLFxuICAgICAgICAgICAgICAgICAgbGFiZWxMaW5lMjogXCJ3YWxsZXRzXCIsXG4gICAgICAgICAgICAgICAgICBnZXQgaW1hZ2VzKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91cldhbGxldHNJdGVtKCkubWFwKChpMikgPT4gaTIuaW1hZ2VVcmwpO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHByb3BzLm9uU2VsZWN0QWxsV2FsbGV0cygpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfZWwkMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSldO1xuICAgICAgfVxuICAgIH0pLCBudWxsKTtcbiAgICByZXR1cm4gX2VsJDtcbiAgfSkoKTtcbn07XG5jb25zdCBib3JkZXJzJDEgPSB7XG4gIG06IFwiMTZweFwiLFxuICBzOiBcIjhweFwiLFxuICBub25lOiBcIjBcIlxufTtcbmNvbnN0IGhvdmVyQm9yZGVycyA9IHtcbiAgbTogXCI4cHhcIixcbiAgczogXCI0cHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCBEZXNrdG9wVW5pdmVyc2FsTW9kYWxTdHlsZWQgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIHBhZGRpbmctYm90dG9tOiAxNnB4O1xuYDtcbmNvbnN0IEgyU3R5bGVkID0gc3R5bGVkKEgyKWBcbiAgICBtYXgtd2lkdGg6IDMyMHB4O1xuICAgIG1hcmdpbi10b3A6IDJweDtcbiAgICBtYXJnaW4tYm90dG9tOiAyMHB4O1xuYDtcbmNvbnN0IEgyQXZhaWxhYmxlV2FsbGV0c1N0eWxlZCA9IHN0eWxlZChIMilgXG4gICAgbWFyZ2luLWJvdHRvbTogMTZweDtcbmA7XG5jb25zdCBRUkNvZGVTdHlsZWQgPSBzdHlsZWQoUVJDb2RlKWBcbiAgICBtYXJnaW4tYm90dG9tOiAyNHB4O1xuYDtcbmNvbnN0IFdhbGxldHNDb250YWluZXJTdHlsZWQgPSBzdHlsZWQudWxgXG4gICAgZGlzcGxheTogZmxleDtcbmA7XG5zdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZ2FwOiAxNnB4O1xuICAgIHdpZHRoOiAxMDAlO1xuYDtcbnN0eWxlZChCdXR0b24pYFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBmb250LXNpemU6IDE2cHg7XG4gICAgbGluZS1oZWlnaHQ6IDIwcHg7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgcGFkZGluZzogMCAxNnB4O1xuICAgIGhlaWdodDogNTZweDtcbiAgICBib3JkZXItcmFkaXVzOiAkeyhwcm9wcykgPT4gYm9yZGVycyQxW3Byb3BzLnRoZW1lLmJvcmRlclJhZGl1c119O1xuXG4gICAgJjpob3ZlciB7XG4gICAgICAgICR7KHByb3BzKSA9PiBwcm9wcy5kaXNhYmxlRXZlbnRzQW5pbWF0aW9uID8gXCJ0cmFuc2Zvcm06IHVuc2V0O1wiIDogXCJcIn1cbiAgICB9XG5cbiAgICAmOmFjdGl2ZSB7XG4gICAgICAgICR7KHByb3BzKSA9PiBwcm9wcy5kaXNhYmxlRXZlbnRzQW5pbWF0aW9uID8gXCJ0cmFuc2Zvcm06IHVuc2V0O1wiIDogXCJcIn1cbiAgICB9XG5gO1xuc3R5bGVkLnVsYFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBib3R0b206IDEwMCU7XG4gICAgbGVmdDogMDtcbiAgICBtYXJnaW46IDA7XG4gICAgcGFkZGluZzogOHB4O1xuICAgIHdpZHRoOiAxODhweDtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTE2cHgpO1xuXG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnByaW1hcnl9O1xuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiBib3JkZXJzJDFbcHJvcHMudGhlbWUuYm9yZGVyUmFkaXVzXX07XG4gICAgYm94LXNoYWRvdzogMCA0cHggMjRweCByZ2JhKDAsIDAsIDAsIDAuMTYpO1xuYDtcbnN0eWxlZC5saWBcbiAgICBwYWRkaW5nOiA4cHg7XG5cbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZ2FwOiA4cHg7XG5cbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgYm9yZGVyLXJhZGl1czogJHsocHJvcHMpID0+IGhvdmVyQm9yZGVyc1twcm9wcy50aGVtZS5ib3JkZXJSYWRpdXNdfTtcblxuICAgIHRyYW5zaXRpb246XG4gICAgICAgIGJhY2tncm91bmQtY29sb3IsXG4gICAgICAgIHRyYW5zZm9ybSAwLjFzIGVhc2UtaW4tb3V0O1xuXG4gICAgJjpob3ZlciB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5zZWNvbmRhcnl9O1xuICAgIH1cblxuICAgICY6YWN0aXZlIHtcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjk2KTtcbiAgICB9XG5gO1xuc3R5bGVkKEltYWdlKWBcbiAgICB3aWR0aDogMjRweDtcbiAgICBoZWlnaHQ6IDI0cHg7XG5cbiAgICBib3JkZXItcmFkaXVzOiA2cHg7XG5gO1xuc3R5bGVkLmRpdmBcbiAgICBtYXJnaW4tdG9wOiAyM3B4O1xuICAgIG1hcmdpbi1ib3R0b206IDFweDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5gO1xuc3R5bGVkKFRleHQpYFxuICAgIGNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5fTtcbiAgICBmb250LXNpemU6IDE2cHg7XG5gO1xudmFyIF90bXBsJCA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8bGk+YCk7XG5jb25zdCBEZXNrdG9wVW5pdmVyc2FsTW9kYWwgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgW3BvcHVwT3BlbmVkLCBzZXRQb3B1cE9wZW5lZF0gPSBjcmVhdGVTaWduYWwoZmFsc2UpO1xuICBjb25zdCBjb25uZWN0b3IgPSBhcHBTdGF0ZS5jb25uZWN0b3I7XG4gIGNvbnN0IHdhbGxldHNCcmlkZ2VzID0gY3JlYXRlTWVtbygoKSA9PiBnZXRVbmlxdWVCcmlkZ2VzKHByb3BzLndhbGxldHNMaXN0KSwgbnVsbCwge1xuICAgIGVxdWFsczogYnJpZGdlc0lzRXF1YWxcbiAgfSk7XG4gIHNldExhc3RTZWxlY3RlZFdhbGxldEluZm8oe1xuICAgIG9wZW5NZXRob2Q6IFwicXJjb2RlXCJcbiAgfSk7XG4gIGNvbnN0IHJlcXVlc3QgPSBjcmVhdGVNZW1vKCgpID0+IGNvbm5lY3Rvci5jb25uZWN0KHdhbGxldHNCcmlkZ2VzKCksIHByb3BzLmFkZGl0aW9uYWxSZXF1ZXN0LCB7XG4gICAgdHJhY2VJZDogcHJvcHMud2FsbGV0TW9kYWxTdGF0ZS50cmFjZUlkXG4gIH0pKTtcbiAgY29uc3Qgc3VwcG9ydGVkV2FsbGV0cyA9IGNyZWF0ZU1lbW8oKCkgPT4gcHJvcHMud2FsbGV0c0xpc3QuZmlsdGVyKCh3YWxsZXQpID0+IHdhbGxldC5pc1N1cHBvcnRSZXF1aXJlZEZlYXR1cmVzKSwgbnVsbCk7XG4gIGNvbnN0IHZpc2libGVXYWxsZXRzID0gY3JlYXRlTWVtbygoKSA9PiBzdXBwb3J0ZWRXYWxsZXRzKCkuc2xpY2UoMCwgMyksIG51bGwpO1xuICBzZXRMYXN0VmlzaWJsZVdhbGxldHNJbmZvKHtcbiAgICB3YWxsZXRzTWVudTogXCJtYWluX3NjcmVlblwiLFxuICAgIHdhbGxldHM6IHZpc2libGVXYWxsZXRzKClcbiAgfSk7XG4gIGNvbnN0IGZvdXJXYWxsZXRzSXRlbSA9IGNyZWF0ZU1lbW8oKCkgPT4gcHJvcHMud2FsbGV0c0xpc3QuZmlsdGVyKCh3YWxsZXQpID0+ICF2aXNpYmxlV2FsbGV0cygpLmZpbmQoKHcpID0+IHcuYXBwTmFtZSA9PT0gd2FsbGV0LmFwcE5hbWUpKS5zbGljZSgwLCA0KSwgbnVsbCk7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoRGVza3RvcFVuaXZlcnNhbE1vZGFsU3R5bGVkLCB7XG4gICAgb25DbGljazogKCkgPT4gc2V0UG9wdXBPcGVuZWQoZmFsc2UpLFxuICAgIFwiZGF0YS10Yy13YWxsZXRzLW1vZGFsLXVuaXZlcnNhbC1kZXNrdG9wXCI6IFwidHJ1ZVwiLFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KEgxLCB7XG4gICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmRlc2t0b3BVbml2ZXJzYWxNb2RhbC5jb25uZWN0WW91cldhbGxldFwiLFxuICAgICAgICBjaGlsZHJlbjogXCJDb25uZWN0IHlvdXIgd2FsbGV0XCJcbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoSDJTdHlsZWQsIHtcbiAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwuZGVza3RvcFVuaXZlcnNhbE1vZGFsLnNjYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiU2NhbiB3aXRoIHlvdXIgbW9iaWxlIHdhbGxldFwiXG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFFSQ29kZVN0eWxlZCwge1xuICAgICAgICBnZXQgc291cmNlVXJsKCkge1xuICAgICAgICAgIHJldHVybiBhZGRSZXR1cm5TdHJhdGVneShyZXF1ZXN0KCksIFwibm9uZVwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGRpc2FibGVDb3B5KCkge1xuICAgICAgICAgIHJldHVybiBwb3B1cE9wZW5lZCgpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaW1hZ2VVcmwoKSB7XG4gICAgICAgICAgcmV0dXJuIElNRy5UT047XG4gICAgICAgIH1cbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoSDJBdmFpbGFibGVXYWxsZXRzU3R5bGVkLCB7XG4gICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmRlc2t0b3BVbml2ZXJzYWxNb2RhbC5hdmFpbGFibGVXYWxsZXRzXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkF2YWlsYWJsZSB3YWxsZXRzXCJcbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoV2FsbGV0c0NvbnRhaW5lclN0eWxlZCwge1xuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoRm9yLCB7XG4gICAgICAgICAgICBnZXQgZWFjaCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZpc2libGVXYWxsZXRzKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRyZW46ICh3YWxsZXQpID0+ICgoKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfZWwkID0gX3RtcGwkKCk7XG4gICAgICAgICAgICAgIGluc2VydChfZWwkLCBjcmVhdGVDb21wb25lbnQoV2FsbGV0TGFiZWxlZEl0ZW0sIHtcbiAgICAgICAgICAgICAgICB3YWxsZXQsXG4gICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gcHJvcHMub25TZWxlY3Qod2FsbGV0KVxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIHJldHVybiBfZWwkO1xuICAgICAgICAgICAgfSkoKVxuICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoRm91cldhbGxldHNJdGVtLCB7XG4gICAgICAgICAgICBsYWJlbExpbmUxOiBcIlZpZXcgYWxsXCIsXG4gICAgICAgICAgICBsYWJlbExpbmUyOiBcIndhbGxldHNcIixcbiAgICAgICAgICAgIGdldCBpbWFnZXMoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmb3VyV2FsbGV0c0l0ZW0oKS5tYXAoKGkyKSA9PiBpMi5pbWFnZVVybCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DbGljazogKCkgPT4gcHJvcHMub25TZWxlY3RBbGxXYWxsZXRzKClcbiAgICAgICAgICB9KV07XG4gICAgICAgIH1cbiAgICAgIH0pXTtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IGJvcmRlcnMgPSB7XG4gIG06IFwiMTZweFwiLFxuICBzOiBcIjhweFwiLFxuICBub25lOiBcIjBcIlxufTtcbmNvbnN0IEgxU3R5bGVkJDIgPSBzdHlsZWQoSDEpYFxuICAgIG1heC13aWR0aDogMjg4cHg7XG4gICAgbWFyZ2luOiAwIGF1dG8gMzhweDtcbmA7XG5jb25zdCBEZXNrdG9wRmVhdHVyZU5vdFN1cHBvcnRNb2RhbFN0eWxlZCA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5gO1xuY29uc3QgU3R5bGVkSWNvbkJ1dHRvbiQxID0gc3R5bGVkKEljb25CdXR0b24pYFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDE2cHg7XG4gICAgbGVmdDogMTZweDtcbmA7XG5jb25zdCBUaXRsZVN0eWxlZCA9IHN0eWxlZChIMSlgXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMjBweDtcbiAgICBsaW5lLWhlaWdodDogMjhweDtcbmA7XG5jb25zdCBEZXNjcmlwdGlvblN0eWxlZCA9IHN0eWxlZChUZXh0KWBcbiAgICBtYXJnaW4tdG9wOiAxMnB4O1xuICAgIG1hcmdpbi1ib3R0b206IDI0cHg7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIG1heC13aWR0aDogMzYwcHg7XG4gICAgZm9udC13ZWlnaHQ6IDQwMDtcbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeX07XG5gO1xuc3R5bGVkLmJ1dHRvbmBcbiAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgICBib3JkZXI6IG5vbmU7XG4gICAgcGFkZGluZzogMDtcbiAgICBtYXJnaW46IDA7XG4gICAgY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuYWNjZW50fTtcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgZm9udDogaW5oZXJpdDtcbmA7XG5jb25zdCBTcGFjZXIgPSBzdHlsZWQuZGl2YFxuICAgIG1hcmdpbi1ib3R0b206IDQ2cHg7XG5gO1xuY29uc3QgRXJyb3JJY29uU3R5bGVkID0gc3R5bGVkKEVycm9ySWNvbilgXG4gICAgbWFyZ2luLWJvdHRvbTogMTZweDtcbmA7XG5zdHlsZWQudWxgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBnYXA6IDhweDtcbiAgICBtYXJnaW4tYm90dG9tOiAyNHB4O1xuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgcGFkZGluZzogMDtcbmA7XG5jb25zdCBEaXNjb25uZWN0QnV0dG9uU3R5bGVkID0gc3R5bGVkKEJ1dHRvbilgXG4gICAgbWF4LXdpZHRoOiAzMjBweDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDQ4cHg7XG4gICAgZm9udC1zaXplOiAxNnB4O1xuICAgIGxpbmUtaGVpZ2h0OiAyMHB4O1xuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiBib3JkZXJzW3Byb3BzLnRoZW1lLmJvcmRlclJhZGl1c119O1xuICAgIG1hcmdpbi1ib3R0b206IDI4cHg7XG5gO1xuY29uc3QgQm9keVRleHRTdHlsZWQgPSBzdHlsZWQoSDIpYFxuICAgIGNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5fTtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgbWFyZ2luLWJvdHRvbTogMjBweDtcbmA7XG5jb25zdCBCdXR0b25zQ29udGFpbmVyU3R5bGVkID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGdhcDogOHB4O1xuICAgIHBhZGRpbmctYm90dG9tOiAzMXB4O1xuYDtcbmNvbnN0IFJlc3RvcmVJbmZvTW9kYWxTdHlsZWQgPSBzdHlsZWQuZGl2YFxuICAgIG1hcmdpbjogMCA4cHggMTZweCA4cHg7XG5gO1xuY29uc3QgU3R5bGVkSWNvbkJ1dHRvbiA9IHN0eWxlZChJY29uQnV0dG9uKWBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAxNnB4O1xuICAgIGxlZnQ6IDE2cHg7XG5gO1xuY29uc3QgSDFTdHlsZWQkMSA9IHN0eWxlZChIMSlgXG4gICAgbWFyZ2luLWJvdHRvbTogMThweDtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG5gO1xuY29uc3QgU3RlcEJsb2NrID0gc3R5bGVkLmRpdmBcbiAgICBwYWRkaW5nOiAxNnB4IDA7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5gO1xuc3R5bGVkLmRpdmBcbiAgICBtYXJnaW4tYm90dG9tOiAxMnB4O1xuYDtcbmNvbnN0IEgzU3R5bGVkID0gc3R5bGVkKEgzKWBcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgbWFyZ2luLWJvdHRvbTogNHB4O1xuYDtcbmNvbnN0IFRleHRTdHlsZWQkMSA9IHN0eWxlZChUZXh0KWBcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgbWF4LXdpZHRoOiAzNTJweDtcbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeX07XG5gO1xuY29uc3QgQ2lyY2xlTnVtYmVyID0gc3R5bGVkLmRpdmBcbiAgICB3aWR0aDogNDRweDtcbiAgICBoZWlnaHQ6IDQ0cHg7XG4gICAgYm9yZGVyLXJhZGl1czogMjBweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4ge1xuICB2YXIgX2EyO1xuICByZXR1cm4gKF9hMiA9IHByb3BzLnRoZW1lKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNvbG9ycy5pY29uLnNlY29uZGFyeTtcbn19O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBtYXJnaW4tYm90dG9tOiAxMnB4O1xuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XG4gICAgZm9udC1zaXplOiAyMnB4O1xuICAgIGNvbG9yOiAkeyhwcm9wcykgPT4ge1xuICB2YXIgX2EyO1xuICByZXR1cm4gKF9hMiA9IHByb3BzLnRoZW1lKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNvbG9ycy50ZXh0LnByaW1hcnk7XG59fTtcbmA7XG5jb25zdCBSZXN0b3JlSW5mb01vZGFsID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoUmVzdG9yZUluZm9Nb2RhbFN0eWxlZCwge1xuICAgIFwiZGF0YS10Yy13YWxsZXRzLW1vZGFsLXJlc3RvcmVcIjogXCJ0cnVlXCIsXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoU3R5bGVkSWNvbkJ1dHRvbiwge1xuICAgICAgICBpY29uOiBcImFycm93XCIsXG4gICAgICAgIGdldCBvbkNsaWNrKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wcy5vbkJhY2tDbGljaztcbiAgICAgICAgfVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChIMVN0eWxlZCQxLCB7XG4gICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLnJlc3RvcmVJbmZvTW9kYWwudGl0bGVcIixcbiAgICAgICAgY2hpbGRyZW46IFwiUmVzdG9yZVwiXG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNjcm9sbENvbnRhaW5lciwge1xuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoU3RlcEJsb2NrLCB7XG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KENpcmNsZU51bWJlciwge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIjFcIlxuICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEgzU3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwucmVzdG9yZU1vZGFsLnN0ZXAxLnRpdGxlXCIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiRmluZCB5b3VyIGN1cnJlbnQgcmVjb3ZlcnkgcGhyYXNlXCJcbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChUZXh0U3R5bGVkJDEsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5yZXN0b3JlTW9kYWwuc3RlcDEudGV4dFwiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIk9wZW4geW91ciB3YWxsZXQgc2V0dGluZ3MgYW5kIGxvY2F0ZSB0aGXCoHJlY292ZXJ5wqBwaHJhc2VcIlxuICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTdGVwQmxvY2ssIHtcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoQ2lyY2xlTnVtYmVyLCB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiMlwiXG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoSDNTdHlsZWQsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5yZXN0b3JlTW9kYWwuc3RlcDIudGl0bGVcIixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJDb3B5IHlvdXIgcmVjb3ZlcnkgcGhyYXNlXCJcbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChUZXh0U3R5bGVkJDEsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5yZXN0b3JlTW9kYWwuc3RlcDIudGV4dFwiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIldyaXRlIGl0IGRvd24gb3IgY29weSBpdCB0byBhIHNhZmUgcGxhY2VcIlxuICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTdGVwQmxvY2ssIHtcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoQ2lyY2xlTnVtYmVyLCB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiM1wiXG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoSDNTdHlsZWQsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5yZXN0b3JlTW9kYWwuc3RlcDMudGl0bGVcIixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJSZXN0b3JlIGluIGEgc3VwcG9ydGVkIHdhbGxldCBmcm9twqB0aGXCoGxpc3TCoGJlbG93XCJcbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChUZXh0U3R5bGVkJDEsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5yZXN0b3JlTW9kYWwuc3RlcDMudGV4dFwiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkVudGVyIHRoZSByZWNvdmVyeSBwaHJhc2UgdG8gYWNjZXNzIHlvdXIgd2FsbGV0XCJcbiAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXTtcbiAgICAgICAgfVxuICAgICAgfSldO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3QgRGVza3RvcEZlYXR1cmVOb3RTdXBwb3J0TW9kYWwgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgW3NlbGVjdGVkV2FsbGV0LCBzZXRTZWxlY3RlZFdhbGxldF0gPSBjcmVhdGVTaWduYWwobnVsbCk7XG4gIGNvbnN0IFtpbmZvTW9kYWxPcGVuLCBzZXRJbmZvTW9kYWxPcGVuXSA9IGNyZWF0ZVNpZ25hbChmYWxzZSk7XG4gIGNvbnN0IGN1cnJlbnRXYWxsZXRVSSA9IGNyZWF0ZU1lbW8oKCkgPT4gcHJvcHMud2FsbGV0c0xpc3QuZmluZCgod2FsbGV0KSA9PiB3YWxsZXQuYXBwTmFtZSA9PT0gcHJvcHMuY3VycmVudFdhbGxldC5kZXZpY2UuYXBwTmFtZSB8fCB3YWxsZXQubmFtZSA9PT0gcHJvcHMuY3VycmVudFdhbGxldC5kZXZpY2UuYXBwTmFtZSkpO1xuICBjb25zdCBjdXJyZW50V2FsbGV0TmFtZSA9IGNyZWF0ZU1lbW8oKCkgPT4ge1xuICAgIHZhciBfYTIsIF9iMiwgX2MyLCBfZDI7XG4gICAgY29uc3QgYXBwTmFtZSA9IChfYjIgPSAoX2EyID0gY3VycmVudFdhbGxldFVJKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuYXBwTmFtZSkgIT0gbnVsbCA/IF9iMiA6IHByb3BzLmN1cnJlbnRXYWxsZXQuZGV2aWNlLmFwcE5hbWU7XG4gICAgaWYgKGFwcE5hbWUgPT09IEFUX1dBTExFVF9BUFBfTkFNRSkge1xuICAgICAgcmV0dXJuIFwiV2FsbGV0IGluIFRlbGVncmFtXCI7XG4gICAgfVxuICAgIHJldHVybiAoX2QyID0gKF9jMiA9IGN1cnJlbnRXYWxsZXRVSSgpKSA9PSBudWxsID8gdm9pZCAwIDogX2MyLm5hbWUpICE9IG51bGwgPyBfZDIgOiBwcm9wcy5jdXJyZW50V2FsbGV0LmRldmljZS5hcHBOYW1lO1xuICB9KTtcbiAgY29uc3QgY3VycmVudFdhbGxldFZlcnNpb25Ob3RTdXBwb3J0ZWQgPSBjcmVhdGVNZW1vKCgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50V2FsbGV0VUlWYXIgPSBjdXJyZW50V2FsbGV0VUkoKTtcbiAgICBpZiAoIShjdXJyZW50V2FsbGV0VUlWYXIgPT0gbnVsbCA/IHZvaWQgMCA6IGN1cnJlbnRXYWxsZXRVSVZhci5mZWF0dXJlcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWlyZWRGZWF0dXJlID0gcHJvcHMud2FsbGV0c01vZGFsU3RhdGUucmVxdWlyZWRGZWF0dXJlO1xuICAgIGNvbnN0IHJlcXVpcmVkRmVhdHVyZXMgPSByZXF1aXJlZEZlYXR1cmUgPyB7XG4gICAgICBbcmVxdWlyZWRGZWF0dXJlLmZlYXR1cmVOYW1lXTogcmVxdWlyZWRGZWF0dXJlLnZhbHVlXG4gICAgfSA6IHt9O1xuICAgIGNvbnN0IHZhbGlkSW5MaXN0ID0gY2hlY2tSZXF1aXJlZFdhbGxldEZlYXR1cmVzKGN1cnJlbnRXYWxsZXRVSVZhci5mZWF0dXJlcywgcmVxdWlyZWRGZWF0dXJlcyk7XG4gICAgY29uc3QgdmFsaWRDdXJyZW50V2FsbGV0ID0gY2hlY2tSZXF1aXJlZFdhbGxldEZlYXR1cmVzKHByb3BzLmN1cnJlbnRXYWxsZXQuZGV2aWNlLmZlYXR1cmVzLCByZXF1aXJlZEZlYXR1cmVzKTtcbiAgICByZXR1cm4gdmFsaWRJbkxpc3QgJiYgIXZhbGlkQ3VycmVudFdhbGxldDtcbiAgfSk7XG4gIGNvbnN0IGhhbmRsZURpc2Nvbm5lY3QgPSAoKSA9PiBfX2FzeW5jKG51bGwsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgeWllbGQgcHJvcHMub25EaXNjb25uZWN0KCk7XG4gICAgcHJvcHMub25TZWxlY3Qoc2VsZWN0ZWRXYWxsZXQoKSk7XG4gIH0pO1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KERlc2t0b3BGZWF0dXJlTm90U3VwcG9ydE1vZGFsU3R5bGVkLCB7XG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChTd2l0Y2gsIHtcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGluZm9Nb2RhbE9wZW4oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoUmVzdG9yZUluZm9Nb2RhbCwge1xuICAgICAgICAgICAgICAgIG9uQmFja0NsaWNrOiAoKSA9PiBzZXRJbmZvTW9kYWxPcGVuKGZhbHNlKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkV2FsbGV0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTcGFjZXIsIHt9KSwgY3JlYXRlQ29tcG9uZW50KERlc2t0b3BGZWF0dXJlTm90U3VwcG9ydE1vZGFsU3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoU3R5bGVkSWNvbkJ1dHRvbiQxLCB7XG4gICAgICAgICAgICAgICAgICAgIGljb246IFwiYXJyb3dcIixcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gc2V0U2VsZWN0ZWRXYWxsZXQobnVsbClcbiAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoVGl0bGVTdHlsZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwuZmVhdHVyZU5vdFN1cHBvcnRlZC5kaXNjb25uZWN0LnRpdGxlXCIsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkNvbmZpcm0gRGlzY29ubmVjdFwiXG4gICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KERlc2NyaXB0aW9uU3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmZlYXR1cmVOb3RTdXBwb3J0ZWQuZGlzY29ubmVjdC5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBnZXQgdHJhbnNsYXRpb25WYWx1ZXMoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHNlbGVjdGVkV2FsbGV0KCkubmFtZVxuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiWW91IHdpbGwgYmUgZGlzY29ubmVjdGVkIGZyb20geW91ciBjdXJyZW50IHdhbGxldCBhbmQgcmVkaXJlY3RlZCB0byBjb25uZWN0IFwiLCBtZW1vKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9hMiA9IHNlbGVjdGVkV2FsbGV0KCkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICB9KSwgXCIuXCJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KERpc2Nvbm5lY3RCdXR0b25TdHlsZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gaGFuZGxlRGlzY29ubmVjdCgpLFxuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwuZmVhdHVyZU5vdFN1cHBvcnRlZC5kaXNjb25uZWN0LmJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiRGlzY29ubmVjdFwiXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRXYWxsZXRWZXJzaW9uTm90U3VwcG9ydGVkKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChIMVN0eWxlZCQyLCB7XG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRXYWxsZXROYW1lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEVycm9ySWNvblN0eWxlZCwge1xuICAgICAgICAgICAgICAgIHNpemU6IFwic1wiXG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoQm9keVRleHRTdHlsZWQsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5mZWF0dXJlTm90U3VwcG9ydGVkLnZlcnNpb24uZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgICAgICBnZXQgdHJhbnNsYXRpb25WYWx1ZXMoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBjdXJyZW50V2FsbGV0TmFtZSgpXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcIllvdXIgY3VycmVudCB2ZXJzaW9uIG9mIFwiLCBtZW1vKCgpID0+IGN1cnJlbnRXYWxsZXROYW1lKCkpLCBcIiBvciB3YWxsZXQgY29udHJhY3QgdHlwZSBkb2Vzbid0IHN1cHBvcnQgdGhlIHJlcXVpcmVkIGZlYXR1cmVzLiBQbGVhc2UgdXBkYXRlIGl0IHRvIGNvbnRpbnVlLlwiXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoQnV0dG9uc0NvbnRhaW5lclN0eWxlZCwge1xuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KExpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGhyZWYoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRXYWxsZXRVSSgpLmFib3V0VXJsO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBibGFuazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQnV0dG9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgbGVmdEljb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoTGlua0ljb24sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNsYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5mZWF0dXJlTm90U3VwcG9ydGVkLnZlcnNpb24udXBkYXRlQnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogY3VycmVudFdhbGxldE5hbWUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJVcGRhdGUgXCIsIG1lbW8oKCkgPT4gY3VycmVudFdhbGxldE5hbWUoKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTGluaywge1xuICAgICAgICAgICAgICAgICAgICBocmVmOiBcImh0dHBzOi8vdG9ua2VlcGVyLmhlbHBzY291dGRvY3MuY29tL2FydGljbGUvMTAyLXc1XCIsXG4gICAgICAgICAgICAgICAgICAgIGJsYW5rOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChCdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBsZWZ0SWNvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChMaW5rSWNvbiwge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmZlYXR1cmVOb3RTdXBwb3J0ZWQudmVyc2lvbi5hYm91dFc1XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiQWJvdXQgVzVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgIHdoZW46IHRydWUsXG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFNwYWNlciwge30pLCBjcmVhdGVDb21wb25lbnQoRXJyb3JJY29uU3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgc2l6ZTogXCJzXCJcbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChUaXRsZVN0eWxlZCwge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmZlYXR1cmVOb3RTdXBwb3J0ZWQud2FsbGV0LnRpdGxlXCIsXG4gICAgICAgICAgICAgICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogY3VycmVudFdhbGxldE5hbWUoKVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbbWVtbygoKSA9PiBjdXJyZW50V2FsbGV0TmFtZSgpKSwgXCIgZG9lc27igJl0IHN1cHBvcnQgdGhlIHJlcXVlc3RlZMKgYWN0aW9uXCJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTcGFjZXIsIHt9KV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IFdhbGxldHNNb2RhbCA9ICgpID0+IHtcbiAgY29uc3Qge1xuICAgIGxvY2FsZVxuICB9ID0gdXNlSTE4bigpWzFdO1xuICBjcmVhdGVFZmZlY3QoKCkgPT4gbG9jYWxlKGFwcFN0YXRlLmxhbmd1YWdlKSk7XG4gIGNyZWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGdldFdhbGxldHNNb2RhbElzT3BlbmVkKCkpIHtcbiAgICAgIHVwZGF0ZUlzTW9iaWxlKCk7XG4gICAgICByZWZldGNoV2FsbGV0cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRTZWxlY3RlZFdhbGxldEluZm8obnVsbCk7XG4gICAgICBzZXRTZWxlY3RlZFRhYihcInVuaXZlcnNhbFwiKTtcbiAgICAgIHNldEluZm9UYWIoZmFsc2UpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGNvbm5lY3RvciA9IHVzZUNvbnRleHQoQ29ubmVjdG9yQ29udGV4dCk7XG4gIGNvbnN0IHRvbkNvbm5lY3RVSSA9IHVzZUNvbnRleHQoVG9uQ29ubmVjdFVpQ29udGV4dCk7XG4gIGNvbnN0IFtmZXRjaGVkV2FsbGV0c0xpc3QsIHtcbiAgICByZWZldGNoOiByZWZldGNoV2FsbGV0c1xuICB9XSA9IGNyZWF0ZVJlc291cmNlKCgpID0+IHtcbiAgICByZXR1cm4gdG9uQ29ubmVjdFVJLmdldFdhbGxldHMoKTtcbiAgfSk7XG4gIGNvbnN0IFtzZWxlY3RlZFdhbGxldEluZm8sIHNldFNlbGVjdGVkV2FsbGV0SW5mb10gPSBjcmVhdGVTaWduYWwobnVsbCk7XG4gIGNvbnN0IFtzZWxlY3RlZFdhbGxldEVycm9yLCBzZXRTZWxlY3RlZFdhbGxldEVycm9yXSA9IGNyZWF0ZVNpZ25hbChudWxsKTtcbiAgY29uc3QgW3NlbGVjdGVkVGFiLCBzZXRTZWxlY3RlZFRhYl0gPSBjcmVhdGVTaWduYWwoXCJ1bml2ZXJzYWxcIik7XG4gIGNvbnN0IFtpbmZvVGFiLCBzZXRJbmZvVGFiXSA9IGNyZWF0ZVNpZ25hbChmYWxzZSk7XG4gIGNvbnN0IHdhbGxldHNNb2RhbElzV2FsbGV0Tm90U3VwcG9ydEZlYXR1cmUgPSBjcmVhdGVNZW1vKCgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHdhbGxldHNNb2RhbFN0YXRlKCk7XG4gICAgcmV0dXJuIFwidHlwZVwiIGluIHN0YXRlICYmIHN0YXRlLnR5cGUgPT09IFwid2FsbGV0LW5vdC1zdXBwb3J0LWZlYXR1cmVcIjtcbiAgfSk7XG4gIGNvbnN0IHdhbGxldHNMaXN0ID0gY3JlYXRlTWVtbygoKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAoZmV0Y2hlZFdhbGxldHNMaXN0LnN0YXRlICE9PSBcInJlYWR5XCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgd2FsbGV0c0xpc3QyID0gYXBwbHlXYWxsZXRzTGlzdENvbmZpZ3VyYXRpb24oZmV0Y2hlZFdhbGxldHNMaXN0KCksIGFwcFN0YXRlLndhbGxldHNMaXN0Q29uZmlndXJhdGlvbik7XG4gICAgY29uc3QgaW5qZWN0ZWRXYWxsZXRzID0gd2FsbGV0c0xpc3QyLmZpbHRlcihpc1dhbGxldEluZm9DdXJyZW50bHlJbmplY3RlZCk7XG4gICAgY29uc3Qgbm90SW5qZWN0ZWRXYWxsZXRzID0gd2FsbGV0c0xpc3QyLmZpbHRlcigodykgPT4gIWlzV2FsbGV0SW5mb0N1cnJlbnRseUluamVjdGVkKHcpKTtcbiAgICB3YWxsZXRzTGlzdDIgPSAoaW5qZWN0ZWRXYWxsZXRzIHx8IFtdKS5jb25jYXQobm90SW5qZWN0ZWRXYWxsZXRzKTtcbiAgICBjb25zdCBwcmVmZXJyZWRXYWxsZXRBcHBOYW1lID0gYXBwU3RhdGUucHJlZmVycmVkV2FsbGV0QXBwTmFtZTtcbiAgICBjb25zdCBwcmVmZXJyZWRXYWxsZXQgPSB3YWxsZXRzTGlzdDIuZmluZCgoaXRlbSkgPT4gZXFXYWxsZXROYW1lKGl0ZW0sIHByZWZlcnJlZFdhbGxldEFwcE5hbWUpKTtcbiAgICBjb25zdCBzb21lV2FsbGV0c1dpdGhTYW1lTmFtZSA9IHdhbGxldHNMaXN0Mi5maWx0ZXIoKGl0ZW0pID0+IGVxV2FsbGV0TmFtZShpdGVtLCBwcmVmZXJyZWRXYWxsZXRBcHBOYW1lKSkubGVuZ3RoID49IDI7XG4gICAgaWYgKHByZWZlcnJlZFdhbGxldEFwcE5hbWUgJiYgcHJlZmVycmVkV2FsbGV0ICYmICFzb21lV2FsbGV0c1dpdGhTYW1lTmFtZSkge1xuICAgICAgd2FsbGV0c0xpc3QyID0gW19fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHByZWZlcnJlZFdhbGxldCksIHtcbiAgICAgICAgaXNQcmVmZXJyZWQ6IHRydWVcbiAgICAgIH0pXS5jb25jYXQod2FsbGV0c0xpc3QyLmZpbHRlcigoaXRlbSkgPT4gIWVxV2FsbGV0TmFtZShpdGVtLCBwcmVmZXJyZWRXYWxsZXRBcHBOYW1lKSkpO1xuICAgIH1cbiAgICBjb25zdCBhdFdhbGxldCA9IHdhbGxldHNMaXN0Mi5maW5kKChpdGVtKSA9PiBlcVdhbGxldE5hbWUoaXRlbSwgQVRfV0FMTEVUX0FQUF9OQU1FKSk7XG4gICAgaWYgKGF0V2FsbGV0KSB7XG4gICAgICB3YWxsZXRzTGlzdDIgPSBbYXRXYWxsZXRdLmNvbmNhdCh3YWxsZXRzTGlzdDIuZmlsdGVyKChpdGVtKSA9PiAhZXFXYWxsZXROYW1lKGl0ZW0sIEFUX1dBTExFVF9BUFBfTkFNRSkpKTtcbiAgICB9XG4gICAgY29uc3Qgd2FsbGV0c0ZlYXR1cmVzUmVxdWVzdGVkID0gKF9hMiA9IHRvbkNvbm5lY3RVSSA9PSBudWxsID8gdm9pZCAwIDogdG9uQ29ubmVjdFVJLndhbGxldHNSZXF1aXJlZEZlYXR1cmVzKSAhPSBudWxsID8gX2EyIDogdG9uQ29ubmVjdFVJID09IG51bGwgPyB2b2lkIDAgOiB0b25Db25uZWN0VUkud2FsbGV0c1ByZWZlcnJlZEZlYXR1cmVzO1xuICAgIGNvbnN0IHVpV2FsbGV0cyA9IHdhbGxldHNMaXN0Mi5tYXAoKHdhbGxldCkgPT4ge1xuICAgICAgdmFyIF9hMztcbiAgICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCB3YWxsZXQpLCB7XG4gICAgICAgIGlzU3VwcG9ydFJlcXVpcmVkRmVhdHVyZXM6IHdhbGxldHNGZWF0dXJlc1JlcXVlc3RlZCA/IGNoZWNrUmVxdWlyZWRXYWxsZXRGZWF0dXJlcygoX2EzID0gd2FsbGV0LmZlYXR1cmVzKSAhPSBudWxsID8gX2EzIDogW10sIHdhbGxldHNGZWF0dXJlc1JlcXVlc3RlZCkgOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdWlXYWxsZXRzO1xuICB9KTtcbiAgY29uc3QgYWRkaXRpb25hbFJlcXVlc3RMb2FkaW5nID0gKCkgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgcmV0dXJuICgoX2EyID0gYXBwU3RhdGUuY29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnN0YXRlKSA9PT0gXCJsb2FkaW5nXCI7XG4gIH07XG4gIGNvbnN0IGFkZGl0aW9uYWxSZXF1ZXN0ID0gY3JlYXRlTWVtbygoKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAoYWRkaXRpb25hbFJlcXVlc3RMb2FkaW5nKCkpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiAoX2EyID0gYXBwU3RhdGUuY29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnZhbHVlO1xuICB9KTtcbiAgY29uc3Qgb25DbG9zZSA9IChjbG9zZVJlYXNvbikgPT4ge1xuICAgIHRvbkNvbm5lY3RVSS5jbG9zZU1vZGFsKGNsb3NlUmVhc29uKTtcbiAgfTtcbiAgY29uc3QgdW5zdWJzY3JpYmUgPSBjb25uZWN0b3Iub25TdGF0dXNDaGFuZ2UoKHdhbGxldCkgPT4ge1xuICAgIGlmICh3YWxsZXQpIHtcbiAgICAgIG9uQ2xvc2UoXCJ3YWxsZXQtc2VsZWN0ZWRcIik7XG4gICAgfVxuICB9LCAoZXJyKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgV2FsbGV0TWlzc2luZ1JlcXVpcmVkRmVhdHVyZXNFcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JBcHBOYW1lID0gZXJyLmNhdXNlLmNvbm5lY3RFdmVudC5kZXZpY2UuYXBwTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3Qgd2FsbGV0ID0gKF9hMiA9IHdhbGxldHNMaXN0KCkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZmluZCgodykgPT4gdy5hcHBOYW1lLnRvTG93ZXJDYXNlKCkgPT09IGVycm9yQXBwTmFtZSk7XG4gICAgICBpZiAoIXdhbGxldCkge1xuICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKFwiV2FsbGV0IG5vdCBmb3VuZFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdhbGxldEVycm9yVHlwZSA9IHdhbGxldC5pc1N1cHBvcnRSZXF1aXJlZEZlYXR1cmVzID8gXCJtaXNzaW5nLWZlYXR1cmVzXCIgOiBcIm5vdC1zdXBwb3J0ZWRcIjtcbiAgICAgIHNldFNlbGVjdGVkV2FsbGV0RXJyb3Iod2FsbGV0RXJyb3JUeXBlKTtcbiAgICAgIHNldFNlbGVjdGVkV2FsbGV0SW5mbyh3YWxsZXQpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IG9uU2VsZWN0QWxsV2FsbGV0cyA9ICgpID0+IHtcbiAgICBzZXRTZWxlY3RlZFRhYihcImFsbC13YWxsZXRzXCIpO1xuICB9O1xuICBjb25zdCBvblNlbGVjdFVuaXZlcnNhbCA9ICgpID0+IHtcbiAgICBzZXRTZWxlY3RlZFRhYihcInVuaXZlcnNhbFwiKTtcbiAgfTtcbiAgY29uc3Qgb25TZWxlY3RXYWxsZXQgPSAod2FsbGV0KSA9PiB7XG4gICAgc2V0U2VsZWN0ZWRXYWxsZXRJbmZvKHdhbGxldCk7XG4gICAgd2lkZ2V0Q29udHJvbGxlci5vcGVuV2FsbGV0c01vZGFsKCk7XG4gIH07XG4gIGNvbnN0IGNsZWFyU2VsZWN0ZWRXYWxsZXRJbmZvID0gKCkgPT4ge1xuICAgIHNldFNlbGVjdGVkV2FsbGV0SW5mbyhudWxsKTtcbiAgICBzZXRTZWxlY3RlZFdhbGxldEVycm9yKG51bGwpO1xuICB9O1xuICBvbkNsZWFudXAoKCkgPT4ge1xuICAgIHNldFNlbGVjdGVkV2FsbGV0SW5mbyhudWxsKTtcbiAgICBzZXRTZWxlY3RlZFdhbGxldEVycm9yKG51bGwpO1xuICAgIHNldEluZm9UYWIoZmFsc2UpO1xuICB9KTtcbiAgb25DbGVhbnVwKHVuc3Vic2NyaWJlKTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChTdHlsZWRNb2RhbCwge1xuICAgIGdldCBvcGVuZWQoKSB7XG4gICAgICByZXR1cm4gZ2V0V2FsbGV0c01vZGFsSXNPcGVuZWQoKTtcbiAgICB9LFxuICAgIGdldCBlbmFibGVBbmRyb2lkQmFja0hhbmRsZXIoKSB7XG4gICAgICByZXR1cm4gYXBwU3RhdGUuZW5hYmxlQW5kcm9pZEJhY2tIYW5kbGVyO1xuICAgIH0sXG4gICAgb25DbG9zZTogKCkgPT4gb25DbG9zZShcImFjdGlvbi1jYW5jZWxsZWRcIiksXG4gICAgb25DbGlja1F1ZXN0aW9uOiAoKSA9PiBzZXRJbmZvVGFiKCh2KSA9PiAhdiksXG4gICAgZ2V0IHNob3dGb290ZXIoKSB7XG4gICAgICByZXR1cm4gIXdhbGxldHNNb2RhbElzV2FsbGV0Tm90U3VwcG9ydEZlYXR1cmUoKTtcbiAgICB9LFxuICAgIFwiZGF0YS10Yy13YWxsZXRzLW1vZGFsLWNvbnRhaW5lclwiOiBcInRydWVcIixcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgIHJldHVybiBpbmZvVGFiKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEluZm9Nb2RhbCwge1xuICAgICAgICAgICAgb25CYWNrQ2xpY2s6ICgpID0+IHNldEluZm9UYWIoZmFsc2UpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICByZXR1cm4gIWluZm9UYWIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gYWRkaXRpb25hbFJlcXVlc3RMb2FkaW5nKCkgfHwgIXdhbGxldHNMaXN0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChIMVN0eWxlZCRhLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwubG9hZGluZ1wiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIldhbGxldHMgbGlzdCBpcyBsb2FkaW5nXCJcbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChMb2FkZXJDb250YWluZXJTdHlsZWQsIHtcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KExvYWRlckljb24sIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogXCJtXCJcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBtZW1vKCgpID0+ICEhIWFkZGl0aW9uYWxSZXF1ZXN0TG9hZGluZygpKSgpICYmIHdhbGxldHNMaXN0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFN3aXRjaCwge1xuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3YWxsZXRzTW9kYWxJc1dhbGxldE5vdFN1cHBvcnRGZWF0dXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KERlc2t0b3BGZWF0dXJlTm90U3VwcG9ydE1vZGFsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2FsbGV0c0xpc3QoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3YWxsZXRzTGlzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjdXJyZW50V2FsbGV0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9uQ29ubmVjdFVJID09IG51bGwgPyB2b2lkIDAgOiB0b25Db25uZWN0VUkud2FsbGV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0OiBvblNlbGVjdFdhbGxldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0QWxsV2FsbGV0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRGlzY29ubmVjdDogKCkgPT4gY29ubmVjdG9yLmRpc2Nvbm5lY3QoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCB3YWxsZXRzTW9kYWxTdGF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGxldHNNb2RhbFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbG9zZTogKCkgPT4gb25DbG9zZShcImFjdGlvbi1jYW5jZWxsZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWRXYWxsZXRJbmZvKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KER5bmFtaWMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjb21wb25lbnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc01vYmlsZSgpID8gTW9iaWxlQ29ubmVjdGlvbk1vZGFsIDogRGVza3RvcENvbm5lY3Rpb25Nb2RhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2FsbGV0c01vZGFsU3RhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3YWxsZXRzTW9kYWxTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCB3YWxsZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZFdhbGxldEluZm8oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgYWRkaXRpb25hbFJlcXVlc3QoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRpdGlvbmFsUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQmFja0NsaWNrOiBjbGVhclNlbGVjdGVkV2FsbGV0SW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBkZWZhdWx0RXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZFdhbGxldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkVGFiKCkgPT09IFwidW5pdmVyc2FsXCI7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KER5bmFtaWMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjb21wb25lbnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc01vYmlsZSgpID8gTW9iaWxlVW5pdmVyc2FsTW9kYWwgOiBEZXNrdG9wVW5pdmVyc2FsTW9kYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Q6IHNldFNlbGVjdGVkV2FsbGV0SW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCB3YWxsZXRNb2RhbFN0YXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2FsbGV0c01vZGFsU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2FsbGV0c0xpc3QoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3YWxsZXRzTGlzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBhZGRpdGlvbmFsUmVxdWVzdCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZGl0aW9uYWxSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25TZWxlY3RBbGxXYWxsZXRzXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkVGFiKCkgPT09IFwiYWxsLXdhbGxldHNcIjtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQWxsV2FsbGV0c0xpc3RNb2RhbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHdhbGxldHNMaXN0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2FsbGV0c0xpc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgZmVhdHVyZUNoZWNrTW9kZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0b25Db25uZWN0VUkgPT0gbnVsbCA/IHZvaWQgMCA6IHRvbkNvbm5lY3RVSS53YWxsZXRzUmVxdWlyZWRGZWF0dXJlcykgPyBcInN0cmljdFwiIDogXCJzb2Z0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25CYWNrOiBvblNlbGVjdFVuaXZlcnNhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0OiBzZXRTZWxlY3RlZFdhbGxldEluZm9cbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSldO1xuICAgICAgICB9XG4gICAgICB9KV07XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBBY3Rpb25Nb2RhbFN0eWxlZCA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgcGFkZGluZy1ib3R0b206IDhweDtcbmA7XG5jb25zdCBIMVN0eWxlZCA9IHN0eWxlZChIMSlgXG4gICAgbWFyZ2luLXRvcDogMTZweDtcbmA7XG5jb25zdCBUZXh0U3R5bGVkID0gc3R5bGVkKFRleHQpYFxuICAgIGZvbnQtd2VpZ2h0OiA1MTA7XG4gICAgZm9udC1zaXplOiAxNnB4O1xuICAgIGxpbmUtaGVpZ2h0OiAyMHB4O1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBtYXgtd2lkdGg6IDI1MHB4O1xuXG4gICAgY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnl9O1xuYDtcbmNvbnN0IExvYWRlckJ1dHRvblN0eWxlZCA9IHN0eWxlZChCdXR0b24pYFxuICAgIG1pbi13aWR0aDogMTEycHg7XG4gICAgbWFyZ2luLXRvcDogMzJweDtcbmA7XG5jb25zdCBMb2FkZXJJY29uU3R5bGVkID0gc3R5bGVkKExvYWRlckljb24pYFxuICAgIGhlaWdodDogMTZweDtcbiAgICB3aWR0aDogMTZweDtcbmA7XG5jb25zdCBCdXR0b25TdHlsZWQgPSBzdHlsZWQoQnV0dG9uKWBcbiAgICBtYXJnaW4tdG9wOiAzMnB4O1xuYDtcbmNvbnN0IEFjdGlvbk1vZGFsID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IGRhdGFBdHRycyA9IHVzZURhdGFBdHRyaWJ1dGVzKHByb3BzKTtcbiAgY29uc3QgdG9uQ29ubmVjdFVJID0gdXNlQ29udGV4dChUb25Db25uZWN0VWlDb250ZXh0KTtcbiAgY29uc3QgW2ZpcnN0Q2xpY2ssIHNldEZpcnN0Q2xpY2tdID0gY3JlYXRlU2lnbmFsKHRydWUpO1xuICBjb25zdCBbc2VudCwgc2V0U2VudF0gPSBjcmVhdGVTaWduYWwoZmFsc2UpO1xuICBjb25zdCBbc2lnbmVkLCBzZXRTaWduZWRdID0gY3JlYXRlU2lnbmFsKGZhbHNlKTtcbiAgY29uc3QgW2NhbmNlbGVkLCBzZXRDYW5jZWxlZF0gPSBjcmVhdGVTaWduYWwoZmFsc2UpO1xuICBjcmVhdGVFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRBY3Rpb24gPSBhY3Rpb24oKTtcbiAgICBzZXRTZW50KCEhY3VycmVudEFjdGlvbiAmJiAoXCJzZW50XCIgaW4gY3VycmVudEFjdGlvbiAmJiBjdXJyZW50QWN0aW9uLnNlbnQgfHwgY3VycmVudEFjdGlvbi5uYW1lID09PSBcInRyYW5zYWN0aW9uLXNlbnRcIikpO1xuICAgIHNldFNpZ25lZCghIWN1cnJlbnRBY3Rpb24gJiYgKFwic2lnbmVkXCIgaW4gY3VycmVudEFjdGlvbiAmJiBjdXJyZW50QWN0aW9uLnNpZ25lZCB8fCBjdXJyZW50QWN0aW9uLm5hbWUgPT09IFwiZGF0YS1zaWduZWRcIikpO1xuICAgIHNldENhbmNlbGVkKCEhY3VycmVudEFjdGlvbiAmJiAoY3VycmVudEFjdGlvbi5uYW1lID09PSBcInRyYW5zYWN0aW9uLWNhbmNlbGVkXCIgfHwgY3VycmVudEFjdGlvbi5uYW1lID09PSBcInNpZ24tZGF0YS1jYW5jZWxlZFwiKSk7XG4gIH0pO1xuICBsZXQgdW5pdmVyc2FsTGluaztcbiAgaWYgKCh0b25Db25uZWN0VUkgPT0gbnVsbCA/IHZvaWQgMCA6IHRvbkNvbm5lY3RVSS53YWxsZXQpICYmIFwidW5pdmVyc2FsTGlua1wiIGluIHRvbkNvbm5lY3RVSS53YWxsZXQgJiYgKHRvbkNvbm5lY3RVSS53YWxsZXQub3Blbk1ldGhvZCA9PT0gXCJ1bml2ZXJzYWwtbGlua1wiIHx8IGlzVGVsZWdyYW1VcmwodG9uQ29ubmVjdFVJLndhbGxldC51bml2ZXJzYWxMaW5rKSAmJiBpc0luVE1BKCkpKSB7XG4gICAgdW5pdmVyc2FsTGluayA9IHRvbkNvbm5lY3RVSS53YWxsZXQudW5pdmVyc2FsTGluaztcbiAgfVxuICBsZXQgZGVlcExpbms7XG4gIGlmICgodG9uQ29ubmVjdFVJID09IG51bGwgPyB2b2lkIDAgOiB0b25Db25uZWN0VUkud2FsbGV0KSAmJiBcImRlZXBMaW5rXCIgaW4gdG9uQ29ubmVjdFVJLndhbGxldCAmJiAodG9uQ29ubmVjdFVJLndhbGxldC5vcGVuTWV0aG9kID09PSBcImN1c3RvbS1kZWVwbGlua1wiIHx8IGlzVGVsZWdyYW1VcmwodG9uQ29ubmVjdFVJLndhbGxldC5kZWVwTGluaykgJiYgaXNJblRNQSgpKSkge1xuICAgIGRlZXBMaW5rID0gdG9uQ29ubmVjdFVJLndhbGxldC5kZWVwTGluaztcbiAgfVxuICBjb25zdCBvbk9wZW5XYWxsZXQgPSAoKSA9PiB7XG4gICAgY29uc3QgY3VycmVudEFjdGlvbiA9IGFjdGlvbigpO1xuICAgIGNvbnN0IHJldHVyblN0cmF0ZWd5ID0gXCJyZXR1cm5TdHJhdGVneVwiIGluIGN1cnJlbnRBY3Rpb24gPyBjdXJyZW50QWN0aW9uLnJldHVyblN0cmF0ZWd5IDogYXBwU3RhdGUucmV0dXJuU3RyYXRlZ3k7XG4gICAgY29uc3QgZm9yY2VSZWRpcmVjdCA9ICFmaXJzdENsaWNrKCk7XG4gICAgc2V0Rmlyc3RDbGljayhmYWxzZSk7XG4gICAgY29uc3QgbGlua1dpdGhTZXNzaW9uSWQgPSBlbnJpY2hVbml2ZXJzYWxMaW5rKHVuaXZlcnNhbExpbmssIHtcbiAgICAgIHNlc3Npb25JZDogY3VycmVudEFjdGlvbi5zZXNzaW9uSWQsXG4gICAgICB0cmFjZUlkOiBjdXJyZW50QWN0aW9uLnRyYWNlSWRcbiAgICB9KTtcbiAgICBpZiAoaXNUZWxlZ3JhbVVybCh1bml2ZXJzYWxMaW5rKSkge1xuICAgICAgcmVkaXJlY3RUb1RlbGVncmFtKGxpbmtXaXRoU2Vzc2lvbklkLCB7XG4gICAgICAgIHJldHVyblN0cmF0ZWd5LFxuICAgICAgICB0d2FSZXR1cm5Vcmw6IFwidHdhUmV0dXJuVXJsXCIgaW4gY3VycmVudEFjdGlvbiA/IGN1cnJlbnRBY3Rpb24udHdhUmV0dXJuVXJsIDogYXBwU3RhdGUudHdhUmV0dXJuVXJsLFxuICAgICAgICBmb3JjZVJlZGlyZWN0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVkaXJlY3RUb1dhbGxldChsaW5rV2l0aFNlc3Npb25JZCwgZGVlcExpbmssIHtcbiAgICAgICAgcmV0dXJuU3RyYXRlZ3ksXG4gICAgICAgIGZvcmNlUmVkaXJlY3RcbiAgICAgIH0sICgpID0+IHtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChBY3Rpb25Nb2RhbFN0eWxlZCwgbWVyZ2VQcm9wcyhkYXRhQXR0cnMsIHtcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gW21lbW8oKCkgPT4gcHJvcHMuaWNvbiksIGNyZWF0ZUNvbXBvbmVudChIMVN0eWxlZCwge1xuICAgICAgICBnZXQgdHJhbnNsYXRpb25LZXkoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLmhlYWRlclRyYW5zbGF0aW9uS2V5O1xuICAgICAgICB9LFxuICAgICAgICBnZXQgdHJhbnNsYXRpb25WYWx1ZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLmhlYWRlclRyYW5zbGF0aW9uVmFsdWVzO1xuICAgICAgICB9XG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFRleHRTdHlsZWQsIHtcbiAgICAgICAgZ2V0IHRyYW5zbGF0aW9uS2V5KCkge1xuICAgICAgICAgIHJldHVybiBwcm9wcy50ZXh0VHJhbnNsYXRpb25LZXk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCB0cmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcHMudGV4dFRyYW5zbGF0aW9uVmFsdWVzO1xuICAgICAgICB9XG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgcmV0dXJuICFzZW50KCkgJiYgIXNpZ25lZCgpICYmICFjYW5jZWxlZCgpICYmIChwcm9wcy5zaG93QnV0dG9uID09PSBcIm9wZW4td2FsbGV0XCIgJiYgdW5pdmVyc2FsTGluayB8fCBwcm9wcy5zaG93QnV0dG9uICE9PSBcIm9wZW4td2FsbGV0XCIpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChMb2FkZXJCdXR0b25TdHlsZWQsIHtcbiAgICAgICAgICAgIGRpc2FibGVkOiB0cnVlLFxuICAgICAgICAgICAgXCJkYXRhLXRjLWNvbm5lY3QtYnV0dG9uLWxvYWRpbmdcIjogXCJ0cnVlXCIsXG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoTG9hZGVySWNvblN0eWxlZCwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbnQoKSB8fCBzaWduZWQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuc2hvd0J1dHRvbiAhPT0gXCJvcGVuLXdhbGxldFwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChCdXR0b25TdHlsZWQsIHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBwcm9wcy5vbkNsb3NlKCksXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJjb21tb24uY2xvc2VcIixcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiQ2xvc2VcIlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuc2hvd0J1dHRvbiA9PT0gXCJvcGVuLXdhbGxldFwiICYmIHVuaXZlcnNhbExpbms7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEJ1dHRvblN0eWxlZCwge1xuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IG9uT3BlbldhbGxldCxcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcImNvbW1vbi5vcGVuV2FsbGV0XCIsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIk9wZW4gd2FsbGV0XCJcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSldO1xuICAgICAgICB9XG4gICAgICB9KV07XG4gICAgfVxuICB9KSk7XG59O1xuY29uc3QgQ29uZmlybVRyYW5zYWN0aW9uTW9kYWwgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdG9uQ29ubmVjdFVJID0gdXNlQ29udGV4dChUb25Db25uZWN0VWlDb250ZXh0KTtcbiAgY29uc3QgW3QyXSA9IHVzZUkxOG4oKTtcbiAgY29uc3QgbmFtZSA9ICgpID0+IHRvbkNvbm5lY3RVSS53YWxsZXQgJiYgXCJuYW1lXCIgaW4gdG9uQ29ubmVjdFVJLndhbGxldCA/IHRvbkNvbm5lY3RVSS53YWxsZXQubmFtZSA6IHQyKFwiY29tbW9uLnlvdXJXYWxsZXRcIiwge30sIFwiWW91ciB3YWxsZXRcIik7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoQWN0aW9uTW9kYWwsIHtcbiAgICBoZWFkZXJUcmFuc2xhdGlvbktleTogXCJhY3Rpb25Nb2RhbC5jb25maXJtVHJhbnNhY3Rpb24uaGVhZGVyXCIsXG4gICAgZ2V0IGhlYWRlclRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSgpXG4gICAgICB9O1xuICAgIH0sXG4gICAgdGV4dFRyYW5zbGF0aW9uS2V5OiBcImFjdGlvbk1vZGFsLmNvbmZpcm1UcmFuc2FjdGlvbi50ZXh0XCIsXG4gICAgZ2V0IGljb24oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KExvYWRlckljb24sIHtcbiAgICAgICAgc2l6ZTogXCJtXCJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgb25DbG9zZTogKCkgPT4gcHJvcHMub25DbG9zZSgpLFxuICAgIHNob3dCdXR0b246IFwib3Blbi13YWxsZXRcIixcbiAgICBcImRhdGEtdGMtY29uZmlybS1tb2RhbFwiOiBcInRydWVcIlxuICB9KTtcbn07XG5jb25zdCBUcmFuc2FjdGlvbkNhbmNlbGVkTW9kYWwgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChBY3Rpb25Nb2RhbCwge1xuICAgIGhlYWRlclRyYW5zbGF0aW9uS2V5OiBcImFjdGlvbk1vZGFsLnRyYW5zYWN0aW9uQ2FuY2VsZWQuaGVhZGVyXCIsXG4gICAgdGV4dFRyYW5zbGF0aW9uS2V5OiBcImFjdGlvbk1vZGFsLnRyYW5zYWN0aW9uQ2FuY2VsZWQudGV4dFwiLFxuICAgIGdldCBpY29uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChFcnJvckljb24sIHtcbiAgICAgICAgc2l6ZTogXCJtXCJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgb25DbG9zZTogKCkgPT4gcHJvcHMub25DbG9zZSgpLFxuICAgIFwiZGF0YS10Yy10cmFuc2FjdGlvbi1jYW5jZWxlZC1tb2RhbFwiOiBcInRydWVcIlxuICB9KTtcbn07XG5jb25zdCBUcmFuc2FjdGlvblNlbnRNb2RhbCA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEFjdGlvbk1vZGFsLCB7XG4gICAgaGVhZGVyVHJhbnNsYXRpb25LZXk6IFwiYWN0aW9uTW9kYWwudHJhbnNhY3Rpb25TZW50LmhlYWRlclwiLFxuICAgIHRleHRUcmFuc2xhdGlvbktleTogXCJhY3Rpb25Nb2RhbC50cmFuc2FjdGlvblNlbnQudGV4dFwiLFxuICAgIGdldCBpY29uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChTdWNjZXNzSWNvbiwge1xuICAgICAgICBzaXplOiBcIm1cIlxuICAgICAgfSk7XG4gICAgfSxcbiAgICBzaG93QnV0dG9uOiBcIm9wZW4td2FsbGV0XCIsXG4gICAgb25DbG9zZTogKCkgPT4gcHJvcHMub25DbG9zZSgpLFxuICAgIFwiZGF0YS10Yy10cmFuc2FjdGlvbi1zZW50LW1vZGFsXCI6IFwidHJ1ZVwiXG4gIH0pO1xufTtcbmNvbnN0IENvbmZpcm1TaWduRGF0YU1vZGFsID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRvbkNvbm5lY3RVSSA9IHVzZUNvbnRleHQoVG9uQ29ubmVjdFVpQ29udGV4dCk7XG4gIGNvbnN0IFt0Ml0gPSB1c2VJMThuKCk7XG4gIGNvbnN0IG5hbWUgPSAoKSA9PiB0b25Db25uZWN0VUkud2FsbGV0ICYmIFwibmFtZVwiIGluIHRvbkNvbm5lY3RVSS53YWxsZXQgPyB0b25Db25uZWN0VUkud2FsbGV0Lm5hbWUgOiB0MihcImNvbW1vbi55b3VyV2FsbGV0XCIsIHt9LCBcIllvdXIgd2FsbGV0XCIpO1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEFjdGlvbk1vZGFsLCB7XG4gICAgaGVhZGVyVHJhbnNsYXRpb25LZXk6IFwiYWN0aW9uTW9kYWwuc2lnbkRhdGEuaGVhZGVyXCIsXG4gICAgZ2V0IGhlYWRlclRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSgpXG4gICAgICB9O1xuICAgIH0sXG4gICAgdGV4dFRyYW5zbGF0aW9uS2V5OiBcImFjdGlvbk1vZGFsLnNpZ25EYXRhLnRleHRcIixcbiAgICBnZXQgaWNvbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoTG9hZGVySWNvbiwge1xuICAgICAgICBzaXplOiBcIm1cIlxuICAgICAgfSk7XG4gICAgfSxcbiAgICBvbkNsb3NlOiAoKSA9PiBwcm9wcy5vbkNsb3NlKCksXG4gICAgc2hvd0J1dHRvbjogXCJvcGVuLXdhbGxldFwiLFxuICAgIFwiZGF0YS10Yy1zaWduLWRhdGEtY29uZmlybS1tb2RhbFwiOiBcInRydWVcIlxuICB9KTtcbn07XG5jb25zdCBTaWduRGF0YUNhbmNlbGVkTW9kYWwgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChBY3Rpb25Nb2RhbCwge1xuICAgIGhlYWRlclRyYW5zbGF0aW9uS2V5OiBcImFjdGlvbk1vZGFsLnNpZ25EYXRhQ2FuY2VsZWQuaGVhZGVyXCIsXG4gICAgZ2V0IGljb24oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEVycm9ySWNvbiwge1xuICAgICAgICBzaXplOiBcIm1cIlxuICAgICAgfSk7XG4gICAgfSxcbiAgICBvbkNsb3NlOiAoKSA9PiBwcm9wcy5vbkNsb3NlKCksXG4gICAgXCJkYXRhLXRjLXNpZ24tZGF0YS1jYW5jZWxlZC1tb2RhbFwiOiBcInRydWVcIlxuICB9KTtcbn07XG5jb25zdCBEYXRhU2lnbmVkTW9kYWwgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChBY3Rpb25Nb2RhbCwge1xuICAgIGhlYWRlclRyYW5zbGF0aW9uS2V5OiBcImFjdGlvbk1vZGFsLmRhdGFTaWduZWQuaGVhZGVyXCIsXG4gICAgZ2V0IGljb24oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFN1Y2Nlc3NJY29uLCB7XG4gICAgICAgIHNpemU6IFwibVwiXG4gICAgICB9KTtcbiAgICB9LFxuICAgIG9uQ2xvc2U6ICgpID0+IHByb3BzLm9uQ2xvc2UoKSxcbiAgICBcImRhdGEtdGMtZGF0YS1zaWduZWQtbW9kYWxcIjogXCJ0cnVlXCJcbiAgfSk7XG59O1xuY29uc3QgQWN0aW9uc01vZGFsID0gKCkgPT4ge1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KE1vZGFsLCB7XG4gICAgZ2V0IG9wZW5lZCgpIHtcbiAgICAgIHZhciBfYTI7XG4gICAgICByZXR1cm4gbWVtbygoKSA9PiBhY3Rpb24oKSAhPT0gbnVsbCkoKSAmJiAoKF9hMiA9IGFjdGlvbigpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLm9wZW5Nb2RhbCkgPT09IHRydWU7XG4gICAgfSxcbiAgICBnZXQgZW5hYmxlQW5kcm9pZEJhY2tIYW5kbGVyKCkge1xuICAgICAgcmV0dXJuIGFwcFN0YXRlLmVuYWJsZUFuZHJvaWRCYWNrSGFuZGxlcjtcbiAgICB9LFxuICAgIG9uQ2xvc2U6ICgpID0+IHNldEFjdGlvbihudWxsKSxcbiAgICBzaG93Rm9vdGVyOiBmYWxzZSxcbiAgICBcImRhdGEtdGMtYWN0aW9ucy1tb2RhbC1jb250YWluZXJcIjogXCJ0cnVlXCIsXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChTd2l0Y2gsIHtcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbigpLm5hbWUgPT09IFwidHJhbnNhY3Rpb24tc2VudFwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2FjdGlvblNlbnRNb2RhbCwge1xuICAgICAgICAgICAgICAgIG9uQ2xvc2U6ICgpID0+IHNldEFjdGlvbihudWxsKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbigpLm5hbWUgPT09IFwidHJhbnNhY3Rpb24tY2FuY2VsZWRcIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNhY3Rpb25DYW5jZWxlZE1vZGFsLCB7XG4gICAgICAgICAgICAgICAgb25DbG9zZTogKCkgPT4gc2V0QWN0aW9uKG51bGwpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uKCkubmFtZSA9PT0gXCJjb25maXJtLXRyYW5zYWN0aW9uXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KENvbmZpcm1UcmFuc2FjdGlvbk1vZGFsLCB7XG4gICAgICAgICAgICAgICAgb25DbG9zZTogKCkgPT4gc2V0QWN0aW9uKG51bGwpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uKCkubmFtZSA9PT0gXCJkYXRhLXNpZ25lZFwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChEYXRhU2lnbmVkTW9kYWwsIHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlOiAoKSA9PiBzZXRBY3Rpb24obnVsbClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhY3Rpb24oKS5uYW1lID09PSBcInNpZ24tZGF0YS1jYW5jZWxlZFwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChTaWduRGF0YUNhbmNlbGVkTW9kYWwsIHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlOiAoKSA9PiBzZXRBY3Rpb24obnVsbClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhY3Rpb24oKS5uYW1lID09PSBcImNvbmZpcm0tc2lnbi1kYXRhXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KENvbmZpcm1TaWduRGF0YU1vZGFsLCB7XG4gICAgICAgICAgICAgICAgb25DbG9zZTogKCkgPT4gc2V0QWN0aW9uKG51bGwpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBTaW5nbGVXYWxsZXRNb2RhbCA9ICgpID0+IHtcbiAgY29uc3Qge1xuICAgIGxvY2FsZVxuICB9ID0gdXNlSTE4bigpWzFdO1xuICBjcmVhdGVFZmZlY3QoKCkgPT4gbG9jYWxlKGFwcFN0YXRlLmxhbmd1YWdlKSk7XG4gIGNyZWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGdldFNpbmdsZVdhbGxldE1vZGFsSXNPcGVuZWQoKSkge1xuICAgICAgdXBkYXRlSXNNb2JpbGUoKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBjb25uZWN0b3IgPSB1c2VDb250ZXh0KENvbm5lY3RvckNvbnRleHQpO1xuICBjb25zdCB0b25Db25uZWN0VUkgPSB1c2VDb250ZXh0KFRvbkNvbm5lY3RVaUNvbnRleHQpO1xuICBjb25zdCBbaW5mb1RhYiwgc2V0SW5mb1RhYl0gPSBjcmVhdGVTaWduYWwoZmFsc2UpO1xuICBjb25zdCBhZGRpdGlvbmFsUmVxdWVzdExvYWRpbmcgPSAoKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICByZXR1cm4gKChfYTIgPSBhcHBTdGF0ZS5jb25uZWN0UmVxdWVzdFBhcmFtZXRlcnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc3RhdGUpID09PSBcImxvYWRpbmdcIjtcbiAgfTtcbiAgY29uc3QgYWRkaXRpb25hbFJlcXVlc3QgPSBjcmVhdGVNZW1vKCgpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIGlmIChhZGRpdGlvbmFsUmVxdWVzdExvYWRpbmcoKSkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIChfYTIgPSBhcHBTdGF0ZS5jb25uZWN0UmVxdWVzdFBhcmFtZXRlcnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIudmFsdWU7XG4gIH0pO1xuICBjb25zdCBvbkNsb3NlID0gKGNsb3NlUmVhc29uKSA9PiB7XG4gICAgdG9uQ29ubmVjdFVJLmNsb3NlU2luZ2xlV2FsbGV0TW9kYWwoY2xvc2VSZWFzb24pO1xuICB9O1xuICBjb25zdCB1bnN1YnNjcmliZSA9IGNvbm5lY3Rvci5vblN0YXR1c0NoYW5nZSgod2FsbGV0KSA9PiB7XG4gICAgaWYgKHdhbGxldCkge1xuICAgICAgb25DbG9zZShcIndhbGxldC1zZWxlY3RlZFwiKTtcbiAgICB9XG4gIH0pO1xuICBvbkNsZWFudXAodW5zdWJzY3JpYmUpO1xuICBvbkNsZWFudXAoKCkgPT4ge1xuICAgIHNldEluZm9UYWIoZmFsc2UpO1xuICB9KTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChTdHlsZWRNb2RhbCwge1xuICAgIGdldCBvcGVuZWQoKSB7XG4gICAgICByZXR1cm4gZ2V0U2luZ2xlV2FsbGV0TW9kYWxJc09wZW5lZCgpO1xuICAgIH0sXG4gICAgZ2V0IGVuYWJsZUFuZHJvaWRCYWNrSGFuZGxlcigpIHtcbiAgICAgIHJldHVybiBhcHBTdGF0ZS5lbmFibGVBbmRyb2lkQmFja0hhbmRsZXI7XG4gICAgfSxcbiAgICBvbkNsb3NlOiAoKSA9PiBvbkNsb3NlKFwiYWN0aW9uLWNhbmNlbGxlZFwiKSxcbiAgICBvbkNsaWNrUXVlc3Rpb246ICgpID0+IHNldEluZm9UYWIoKHYpID0+ICF2KSxcbiAgICBzaG93Rm9vdGVyOiB0cnVlLFxuICAgIFwiZGF0YS10Yy13YWxsZXRzLW1vZGFsLWNvbnRhaW5lclwiOiBcInRydWVcIixcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgIHJldHVybiBpbmZvVGFiKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEluZm9Nb2RhbCwge1xuICAgICAgICAgICAgb25CYWNrQ2xpY2s6ICgpID0+IHNldEluZm9UYWIoZmFsc2UpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICByZXR1cm4gIWluZm9UYWIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gYWRkaXRpb25hbFJlcXVlc3RMb2FkaW5nKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChIMVN0eWxlZCRhLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwubG9hZGluZ1wiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIldhbGxldHMgbGlzdCBpcyBsb2FkaW5nXCJcbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChMb2FkZXJDb250YWluZXJTdHlsZWQsIHtcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KExvYWRlckljb24sIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogXCJtXCJcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhYWRkaXRpb25hbFJlcXVlc3RMb2FkaW5nKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KER5bmFtaWMsIHtcbiAgICAgICAgICAgICAgICBnZXQgY29tcG9uZW50KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTW9iaWxlKCkgPyBNb2JpbGVDb25uZWN0aW9uTW9kYWwgOiBEZXNrdG9wQ29ubmVjdGlvbk1vZGFsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IHdhbGxldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRTaW5nbGVXYWxsZXRNb2RhbFdhbGxldEluZm8oKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBhZGRpdGlvbmFsUmVxdWVzdCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRpdGlvbmFsUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25CYWNrQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJhY2tEaXNhYmxlZDogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KV07XG4gICAgICAgIH1cbiAgICAgIH0pXTtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IEFwcCA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0cmFuc2xhdGlvbnMgPSBjcmVhdGVJMThuQ29udGV4dChpMThuRGljdGlvbmFyeSwgYXBwU3RhdGUubGFuZ3VhZ2UpO1xuICBkZWZpbmVTdHlsZXNSb290KCk7XG4gIGZpeE1vYmlsZVNhZmFyaUFjdGl2ZVRyYW5zaXRpb24oKTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChJMThuQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB0cmFuc2xhdGlvbnMsXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUb25Db25uZWN0VWlDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcHMudG9uQ29ubmVjdFVJO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChDb25uZWN0b3JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhcHBTdGF0ZS5jb25uZWN0b3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChHbG9iYWxTdHlsZXMsIHt9KSwgY3JlYXRlQ29tcG9uZW50KFRoZW1lUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICB0aGVtZTogdGhlbWVTdGF0ZSxcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcHBTdGF0ZS5idXR0b25Sb290SWQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFBvcnRhbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IG1vdW50KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYXBwU3RhdGUuYnV0dG9uUm9vdElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQWNjb3VudEJ1dHRvbiwge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KER5bmFtaWMsIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBnbG9iYWxTdHlsZXNUYWcsXG4gICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChXYWxsZXRzTW9kYWwsIHt9KSwgY3JlYXRlQ29tcG9uZW50KFNpbmdsZVdhbGxldE1vZGFsLCB7fSksIGNyZWF0ZUNvbXBvbmVudChBY3Rpb25zTW9kYWwsIHt9KV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCB3aWRnZXRDb250cm9sbGVyID0ge1xuICBvcGVuV2FsbGV0c01vZGFsOiAob3B0aW9ucykgPT4gdm9pZCBzZXRUaW1lb3V0KCgpID0+IHNldFdhbGxldHNNb2RhbFN0YXRlKChwcmV2KSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiBcIm9wZW5lZFwiLFxuICAgICAgdHJhY2VJZDogKF9hMiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZCkgIT0gbnVsbCA/IF9hMiA6IHByZXYgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXYudHJhY2VJZCxcbiAgICAgIGNsb3NlUmVhc29uOiBudWxsXG4gICAgfTtcbiAgfSkpLFxuICBjbG9zZVdhbGxldHNNb2RhbDogKHJlYXNvbikgPT4gdm9pZCBzZXRUaW1lb3V0KCgpID0+IHNldFdhbGxldHNNb2RhbFN0YXRlKHtcbiAgICBzdGF0dXM6IFwiY2xvc2VkXCIsXG4gICAgY2xvc2VSZWFzb246IHJlYXNvblxuICB9KSksXG4gIG9wZW5TaW5nbGVXYWxsZXRNb2RhbDogKHdhbGxldEluZm8pID0+IHtcbiAgICB2b2lkIHNldFRpbWVvdXQoKCkgPT4gc2V0U2luZ2xlV2FsbGV0TW9kYWxTdGF0ZSh7XG4gICAgICBzdGF0dXM6IFwib3BlbmVkXCIsXG4gICAgICBjbG9zZVJlYXNvbjogbnVsbCxcbiAgICAgIHdhbGxldEluZm9cbiAgICB9KSk7XG4gIH0sXG4gIGNsb3NlU2luZ2xlV2FsbGV0TW9kYWw6IChyZWFzb24pID0+IHZvaWQgc2V0VGltZW91dCgoKSA9PiBzZXRTaW5nbGVXYWxsZXRNb2RhbFN0YXRlKHtcbiAgICBzdGF0dXM6IFwiY2xvc2VkXCIsXG4gICAgY2xvc2VSZWFzb246IHJlYXNvblxuICB9KSksXG4gIG9wZW5XYWxsZXROb3RTdXBwb3J0RmVhdHVyZU1vZGFsOiAoY2F1c2UsIG9wdGlvbnMpID0+IHZvaWQgc2V0VGltZW91dCgoKSA9PiBzZXRXYWxsZXRzTW9kYWxTdGF0ZSh7XG4gICAgc3RhdHVzOiBcIm9wZW5lZFwiLFxuICAgIHRyYWNlSWQ6IG9wdGlvbnMudHJhY2VJZCxcbiAgICBjbG9zZVJlYXNvbjogbnVsbCxcbiAgICB0eXBlOiBcIndhbGxldC1ub3Qtc3VwcG9ydC1mZWF0dXJlXCIsXG4gICAgcmVxdWlyZWRGZWF0dXJlOiBjYXVzZS5yZXF1aXJlZEZlYXR1cmVcbiAgfSkpLFxuICBzZXRBY3Rpb246IChhY3Rpb24yKSA9PiB2b2lkIHNldFRpbWVvdXQoKCkgPT4gc2V0QWN0aW9uKGFjdGlvbjIpKSxcbiAgY2xlYXJBY3Rpb246ICgpID0+IHZvaWQgc2V0VGltZW91dCgoKSA9PiBzZXRBY3Rpb24obnVsbCkpLFxuICBnZXRTZWxlY3RlZFdhbGxldEluZm86ICgpID0+IGxhc3RTZWxlY3RlZFdhbGxldEluZm8oKSxcbiAgZ2V0TGFzdFZpc2libGVXYWxsZXRzOiAoKSA9PiBsYXN0VmlzaWJsZVdhbGxldHNJbmZvKCksXG4gIHJlbW92ZVNlbGVjdGVkV2FsbGV0SW5mbzogKCkgPT4gc2V0TGFzdFNlbGVjdGVkV2FsbGV0SW5mbyhudWxsKSxcbiAgcmVuZGVyQXBwOiAocm9vdCwgdG9uQ29ubmVjdFVJKSA9PiByZW5kZXIoKCkgPT4gY3JlYXRlQ29tcG9uZW50KEFwcCwge1xuICAgIHRvbkNvbm5lY3RVSVxuICB9KSwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocm9vdCkpXG59O1xuY2xhc3MgV2FsbGV0c01vZGFsTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbnN1bWVycyA9IFtdO1xuICAgIHRoaXMuc3RhdGUgPSB3YWxsZXRzTW9kYWxTdGF0ZSgpO1xuICAgIHRoaXMuY29ubmVjdG9yID0gb3B0aW9ucy5jb25uZWN0b3I7XG4gICAgdGhpcy50cmFja2VyID0gb3B0aW9ucy50cmFja2VyO1xuICAgIHRoaXMuc2V0Q29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzQ2FsbGJhY2sgPSBvcHRpb25zLnNldENvbm5lY3RSZXF1ZXN0UGFyYW1ldGVyc0NhbGxiYWNrO1xuICAgIGNyZWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHdhbGxldHNNb2RhbFN0YXRlKCk7XG4gICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICB0aGlzLmNvbnN1bWVycy5mb3JFYWNoKChjb25zdW1lcikgPT4gY29uc3VtZXIoc3RhdGUpKTtcbiAgICB9KTtcbiAgICBjcmVhdGVFZmZlY3QoXG4gICAgICBvbihsYXN0U2VsZWN0ZWRXYWxsZXRJbmZvLCAoc2VsZWN0ZWRXYWxsZXQsIHByZXZpb3VzV2FsbGV0KSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyB3YWxsZXRzLCB3YWxsZXRzTWVudSB9ID0gd2lkZ2V0Q29udHJvbGxlci5nZXRMYXN0VmlzaWJsZVdhbGxldHMoKTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWRXYWxsZXQgJiYgXCJhcHBOYW1lXCIgaW4gc2VsZWN0ZWRXYWxsZXQpIHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c1dhbGxldCAmJiBcImFwcE5hbWVcIiBpbiBwcmV2aW91c1dhbGxldCAmJiBwcmV2aW91c1dhbGxldC5hcHBOYW1lID09PSBzZWxlY3RlZFdhbGxldC5hcHBOYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNsaWVudElkID0geWllbGQgdGhpcy5jb25uZWN0b3IuZ2V0U2Vzc2lvbklkKCk7XG4gICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tTZWxlY3RlZFdhbGxldChcbiAgICAgICAgICAgICAgd2FsbGV0cy5tYXAoKHdhbGxldCkgPT4gd2FsbGV0Lm5hbWUpLFxuICAgICAgICAgICAgICBzZWxlY3RlZFdhbGxldCxcbiAgICAgICAgICAgICAgd2FsbGV0c01lbnUsXG4gICAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgICAgY2xpZW50SWQsXG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUudHJhY2VJZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgbG9nRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KSlcbiAgICApO1xuICAgIGNyZWF0ZUVmZmVjdChcbiAgICAgIG9uKGxhc3RPcGVuZWRMaW5rLCAob3BlbmVkTGluaykgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHsgd2FsbGV0cywgd2FsbGV0c01lbnUgfSA9IHdpZGdldENvbnRyb2xsZXIuZ2V0TGFzdFZpc2libGVXYWxsZXRzKCk7XG4gICAgICAgICAgaWYgKGlzQ29ubmVjdFVybChvcGVuZWRMaW5rLmxpbmspKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZFdhbGxldCA9IGxhc3RTZWxlY3RlZFdhbGxldEluZm8oKTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudElkID0geWllbGQgdGhpcy5jb25uZWN0b3IuZ2V0U2Vzc2lvbklkKCk7XG4gICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tTZWxlY3RlZFdhbGxldChcbiAgICAgICAgICAgICAgd2FsbGV0cy5tYXAoKHdhbGxldCkgPT4gd2FsbGV0Lm5hbWUpLFxuICAgICAgICAgICAgICBzZWxlY3RlZFdhbGxldCAmJiBcImFwcE5hbWVcIiBpbiBzZWxlY3RlZFdhbGxldCA/IHNlbGVjdGVkV2FsbGV0IDogbnVsbCxcbiAgICAgICAgICAgICAgd2FsbGV0c01lbnUsXG4gICAgICAgICAgICAgIG9wZW5lZExpbmsubGluayxcbiAgICAgICAgICAgICAgb3BlbmVkTGluay50eXBlLFxuICAgICAgICAgICAgICBjbGllbnRJZCxcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZS50cmFjZUlkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBsb2dFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBtb2RhbCB3aW5kb3cuXG4gICAqL1xuICBvcGVuKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGNvbnN0IHRyYWNlSWQgPSAoX2EyID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50cmFjZUlkKSAhPSBudWxsID8gX2EyIDogVVVJRHY3KCk7XG4gICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uU3RhcnRlZCgpO1xuICAgICAgY29uc3Qgd2FsbGV0c0xpc3QgPSB5aWVsZCB0aGlzLmNvbm5lY3Rvci5nZXRXYWxsZXRzKCk7XG4gICAgICBjb25zdCBlbWJlZGRlZFdhbGxldCA9IHdhbGxldHNMaXN0LmZpbmQoaXNXYWxsZXRJbmZvQ3VycmVudGx5RW1iZWRkZWQpO1xuICAgICAgaWYgKGVtYmVkZGVkV2FsbGV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RFbWJlZGRlZFdhbGxldChlbWJlZGRlZFdhbGxldCwgeyB0cmFjZUlkIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlbldhbGxldHNNb2RhbCh7IHRyYWNlSWQgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgbW9kYWwgd2luZG93LlxuICAgKiBAZGVmYXVsdCAnYWN0aW9uLWNhbmNlbGxlZCdcbiAgICovXG4gIGNsb3NlKHJlYXNvbiA9IFwiYWN0aW9uLWNhbmNlbGxlZFwiKSB7XG4gICAgaWYgKHJlYXNvbiA9PT0gXCJhY3Rpb24tY2FuY2VsbGVkXCIpIHtcbiAgICAgIHRoaXMudHJhY2tlci50cmFja0Nvbm5lY3Rpb25FcnJvcihcIkNvbm5lY3Rpb24gd2FzIGNhbmNlbGxlZFwiKTtcbiAgICB9XG4gICAgd2lkZ2V0Q29udHJvbGxlci5jbG9zZVdhbGxldHNNb2RhbChyZWFzb24pO1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gdGhlIG1vZGFsIHdpbmRvdyBzdGF0ZSBjaGFuZ2VzLCByZXR1cm5zIHVuc3Vic2NyaWJlIGZ1bmN0aW9uLlxuICAgKi9cbiAgb25TdGF0ZUNoYW5nZShvbkNoYW5nZSkge1xuICAgIHRoaXMuY29uc3VtZXJzLnB1c2gob25DaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLmNvbnN1bWVycyA9IHRoaXMuY29uc3VtZXJzLmZpbHRlcigoY29uc3VtZXIpID0+IGNvbnN1bWVyICE9PSBvbkNoYW5nZSk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGVzIGEgY29ubmVjdGlvbiB3aXRoIGFuIGVtYmVkZGVkIHdhbGxldC5cbiAgICogQHBhcmFtIGVtYmVkZGVkV2FsbGV0IC0gSW5mb3JtYXRpb24gYWJvdXQgdGhlIGVtYmVkZGVkIHdhbGxldCB0byBjb25uZWN0IHRvLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbm5lY3RFbWJlZGRlZFdhbGxldChlbWJlZGRlZFdhbGxldCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNvbm5lY3QgPSAocGFyYW1ldGVycykgPT4ge1xuICAgICAgc2V0TGFzdFNlbGVjdGVkV2FsbGV0SW5mbyhlbWJlZGRlZFdhbGxldCk7XG4gICAgICB0aGlzLmNvbm5lY3Rvci5jb25uZWN0KHsganNCcmlkZ2VLZXk6IGVtYmVkZGVkV2FsbGV0LmpzQnJpZGdlS2V5IH0sIHBhcmFtZXRlcnMsIHtcbiAgICAgICAgdHJhY2VJZDogb3B0aW9ucy50cmFjZUlkXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGFkZGl0aW9uYWxSZXF1ZXN0ID0gYXBwU3RhdGUuY29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzO1xuICAgIGlmICgoYWRkaXRpb25hbFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IGFkZGl0aW9uYWxSZXF1ZXN0LnN0YXRlKSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgIHRoaXMuc2V0Q29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzQ2FsbGJhY2soY29ubmVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbm5lY3QoYWRkaXRpb25hbFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IGFkZGl0aW9uYWxSZXF1ZXN0LnZhbHVlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBtb2RhbCB3aW5kb3cgdG8gY29ubmVjdCB0byBhbiBleHRlcm5hbCB3YWxsZXQsIGFuZCB3YWl0cyB3aGVuIG1vZGFsIHdpbmRvdyBpcyBvcGVuZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb3BlbldhbGxldHNNb2RhbChvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmIChpc0luVE1BKCkpIHtcbiAgICAgICAgc2VuZEV4cGFuZCgpO1xuICAgICAgfVxuICAgICAgd2lkZ2V0Q29udHJvbGxlci5vcGVuV2FsbGV0c01vZGFsKHsgdHJhY2VJZDogb3B0aW9ucy50cmFjZUlkIH0pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5vblN0YXRlQ2hhbmdlKChzdGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgc3RhdHVzIH0gPSBzdGF0ZTtcbiAgICAgICAgICBpZiAoc3RhdHVzID09PSBcIm9wZW5lZFwiKSB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgVHJhbnNhY3Rpb25Nb2RhbE1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5jb25zdW1lcnMgPSBbXTtcbiAgICB0aGlzLmNvbm5lY3RvciA9IG9wdGlvbnMuY29ubmVjdG9yO1xuICAgIGNyZWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50QWN0aW9uID0gYWN0aW9uKCk7XG4gICAgICB0aGlzLmNvbnN1bWVycy5mb3JFYWNoKChjb25zdW1lcikgPT4gY29uc3VtZXIoY3VycmVudEFjdGlvbikpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gdGhlIG1vZGFsIHdpbmRvdyBzdGF0ZSBjaGFuZ2VzLCByZXR1cm5zIHVuc3Vic2NyaWJlIGZ1bmN0aW9uLlxuICAgKi9cbiAgb25TdGF0ZUNoYW5nZShjb25zdW1lcikge1xuICAgIHRoaXMuY29uc3VtZXJzLnB1c2goY29uc3VtZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLmNvbnN1bWVycyA9IHRoaXMuY29uc3VtZXJzLmZpbHRlcigoYzIpID0+IGMyICE9PSBjb25zdW1lcik7XG4gICAgfTtcbiAgfVxufVxuY2xhc3MgU2luZ2xlV2FsbGV0TW9kYWxNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuY29uc3VtZXJzID0gW107XG4gICAgdGhpcy5zdGF0ZSA9IHNpbmdsZVdhbGxldE1vZGFsU3RhdGUoKTtcbiAgICB0aGlzLmNvbm5lY3RvciA9IG9wdGlvbnMuY29ubmVjdG9yO1xuICAgIHRoaXMudHJhY2tlciA9IG9wdGlvbnMudHJhY2tlcjtcbiAgICB0aGlzLnNldENvbm5lY3RSZXF1ZXN0UGFyYW1ldGVyc0NhbGxiYWNrID0gb3B0aW9ucy5zZXRDb25uZWN0UmVxdWVzdFBhcmFtZXRlcnNDYWxsYmFjaztcbiAgICBjcmVhdGVFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdGUgPSBzaW5nbGVXYWxsZXRNb2RhbFN0YXRlKCk7XG4gICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICB0aGlzLmNvbnN1bWVycy5mb3JFYWNoKChjb25zdW1lcikgPT4gY29uc3VtZXIoc3RhdGUpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogT3BlbnMgdGhlIG1vZGFsIHdpbmRvdyB3aXRoIHRoZSBzcGVjaWZpZWQgd2FsbGV0LlxuICAgKiBAcGFyYW0gd2FsbGV0IC0gV2FsbGV0IGFwcCBuYW1lLlxuICAgKiBAdGhyb3dzIFRvbkNvbm5lY3RVSUVycm9yIGlmIHRoZSBzcGVjaWZpZWQgd2FsbGV0IGlzIG5vdCBmb3VuZC5cbiAgICovXG4gIG9wZW4od2FsbGV0KSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMudHJhY2tlci50cmFja0Nvbm5lY3Rpb25TdGFydGVkKCk7XG4gICAgICBjb25zdCBmZXRjaGVkV2FsbGV0c0xpc3QgPSB5aWVsZCB0aGlzLmNvbm5lY3Rvci5nZXRXYWxsZXRzKCk7XG4gICAgICBjb25zdCB3YWxsZXRzTGlzdCA9IGFwcGx5V2FsbGV0c0xpc3RDb25maWd1cmF0aW9uKFxuICAgICAgICBmZXRjaGVkV2FsbGV0c0xpc3QsXG4gICAgICAgIGFwcFN0YXRlLndhbGxldHNMaXN0Q29uZmlndXJhdGlvblxuICAgICAgKTtcbiAgICAgIGNvbnN0IGVtYmVkZGVkV2FsbGV0ID0gd2FsbGV0c0xpc3QuZmluZChpc1dhbGxldEluZm9DdXJyZW50bHlFbWJlZGRlZCk7XG4gICAgICBjb25zdCBpc0VtYmVkZGVkV2FsbGV0RXhpc3QgPSAhIWVtYmVkZGVkV2FsbGV0O1xuICAgICAgaWYgKGlzRW1iZWRkZWRXYWxsZXRFeGlzdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0RW1iZWRkZWRXYWxsZXQoZW1iZWRkZWRXYWxsZXQpO1xuICAgICAgfVxuICAgICAgY29uc3QgZXh0ZXJuYWxXYWxsZXRzID0gd2FsbGV0c0xpc3QuZmlsdGVyKGlzV2FsbGV0SW5mb1JlbW90ZSk7XG4gICAgICBjb25zdCBleHRlcm5hbFdhbGxldCA9IGV4dGVybmFsV2FsbGV0cy5maW5kKCh3YWxsZXRJbmZvKSA9PiBlcVdhbGxldE5hbWUod2FsbGV0SW5mbywgd2FsbGV0KSk7XG4gICAgICBjb25zdCBpc0V4dGVybmFsV2FsbGV0RXhpc3QgPSAhIWV4dGVybmFsV2FsbGV0O1xuICAgICAgaWYgKGlzRXh0ZXJuYWxXYWxsZXRFeGlzdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuU2luZ2xlV2FsbGV0TW9kYWwoZXh0ZXJuYWxXYWxsZXQpO1xuICAgICAgfVxuICAgICAgY29uc3QgZXJyb3IgPSBgVHJ5aW5nIHRvIG9wZW4gbW9kYWwgd2luZG93IHdpdGggdW5rbm93biB3YWxsZXQgXCIke3dhbGxldH1cIi5gO1xuICAgICAgdGhpcy50cmFja2VyLnRyYWNrQ29ubmVjdGlvbkVycm9yKGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBUb25Db25uZWN0VUlFcnJvcihlcnJvcik7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgbW9kYWwgd2luZG93LlxuICAgKiBAZGVmYXVsdCAnYWN0aW9uLWNhbmNlbGxlZCdcbiAgICovXG4gIGNsb3NlKHJlYXNvbiA9IFwiYWN0aW9uLWNhbmNlbGxlZFwiKSB7XG4gICAgaWYgKHJlYXNvbiA9PT0gXCJhY3Rpb24tY2FuY2VsbGVkXCIpIHtcbiAgICAgIHRoaXMudHJhY2tlci50cmFja0Nvbm5lY3Rpb25FcnJvcihcIkNvbm5lY3Rpb24gd2FzIGNhbmNlbGxlZFwiKTtcbiAgICB9XG4gICAgd2lkZ2V0Q29udHJvbGxlci5jbG9zZVNpbmdsZVdhbGxldE1vZGFsKFwiYWN0aW9uLWNhbmNlbGxlZFwiKTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIHRoZSBtb2RhbCB3aW5kb3cgc3RhdGUgY2hhbmdlcywgcmV0dXJucyB1bnN1YnNjcmliZSBmdW5jdGlvbi5cbiAgICovXG4gIG9uU3RhdGVDaGFuZ2Uob25DaGFuZ2UpIHtcbiAgICB0aGlzLmNvbnN1bWVycy5wdXNoKG9uQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpcy5jb25zdW1lcnMgPSB0aGlzLmNvbnN1bWVycy5maWx0ZXIoKGNvbnN1bWVyKSA9PiBjb25zdW1lciAhPT0gb25DaGFuZ2UpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBhIGNvbm5lY3Rpb24gd2l0aCBhbiBlbWJlZGRlZCB3YWxsZXQuXG4gICAqIEBwYXJhbSBlbWJlZGRlZFdhbGxldCAtIEluZm9ybWF0aW9uIGFib3V0IHRoZSBlbWJlZGRlZCB3YWxsZXQgdG8gY29ubmVjdCB0by5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25uZWN0RW1iZWRkZWRXYWxsZXQoZW1iZWRkZWRXYWxsZXQpIHtcbiAgICBjb25zdCBjb25uZWN0ID0gKHBhcmFtZXRlcnMpID0+IHtcbiAgICAgIHNldExhc3RTZWxlY3RlZFdhbGxldEluZm8oZW1iZWRkZWRXYWxsZXQpO1xuICAgICAgdGhpcy5jb25uZWN0b3IuY29ubmVjdCh7IGpzQnJpZGdlS2V5OiBlbWJlZGRlZFdhbGxldC5qc0JyaWRnZUtleSB9LCBwYXJhbWV0ZXJzKTtcbiAgICB9O1xuICAgIGNvbnN0IGFkZGl0aW9uYWxSZXF1ZXN0ID0gYXBwU3RhdGUuY29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzO1xuICAgIGlmICgoYWRkaXRpb25hbFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IGFkZGl0aW9uYWxSZXF1ZXN0LnN0YXRlKSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgIHRoaXMuc2V0Q29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzQ2FsbGJhY2soY29ubmVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbm5lY3QoYWRkaXRpb25hbFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IGFkZGl0aW9uYWxSZXF1ZXN0LnZhbHVlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBtb2RhbCB3aW5kb3cgdG8gY29ubmVjdCB0byBhIHNwZWNpZmllZCB3YWxsZXQsIGFuZCB3YWl0cyB3aGVuIG1vZGFsIHdpbmRvdyBpcyBvcGVuZWQuXG4gICAqL1xuICBvcGVuU2luZ2xlV2FsbGV0TW9kYWwod2FsbGV0KSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmIChpc0luVE1BKCkpIHtcbiAgICAgICAgc2VuZEV4cGFuZCgpO1xuICAgICAgfVxuICAgICAgd2lkZ2V0Q29udHJvbGxlci5vcGVuU2luZ2xlV2FsbGV0TW9kYWwod2FsbGV0KTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMub25TdGF0ZUNoYW5nZSgoc3RhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHN0YXR1cyB9ID0gc3RhdGU7XG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gXCJvcGVuZWRcIikge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFRvbkNvbm5lY3RVSVRyYWNrZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5ldmVudFByZWZpeCA9IFwidG9uLWNvbm5lY3QtdWktXCI7XG4gICAgdGhpcy50b25Db25uZWN0U2RrVmVyc2lvbiA9IG51bGw7XG4gICAgdGhpcy5ldmVudERpc3BhdGNoZXIgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmV2ZW50RGlzcGF0Y2hlcjtcbiAgICB0aGlzLnRvbkNvbm5lY3RVaVZlcnNpb24gPSBvcHRpb25zLnRvbkNvbm5lY3RVaVZlcnNpb247XG4gICAgdGhpcy5pbml0KCkuY2F0Y2goKTtcbiAgfVxuICAvKipcbiAgICogVmVyc2lvbiBvZiB0aGUgbGlicmFyeS5cbiAgICovXG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiBjcmVhdGVWZXJzaW9uSW5mbyh7XG4gICAgICB0b25fY29ubmVjdF9zZGtfbGliOiB0aGlzLnRvbkNvbm5lY3RTZGtWZXJzaW9uLFxuICAgICAgdG9uX2Nvbm5lY3RfdWlfbGliOiB0aGlzLnRvbkNvbm5lY3RVaVZlcnNpb25cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIG9uY2Ugd2hlbiB0aGUgdHJhY2tlciBpcyBjcmVhdGVkIGFuZCByZXF1ZXN0IHZlcnNpb24gb3RoZXIgbGlicmFyaWVzLlxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgdGhpcy5zZXRSZXF1ZXN0VmVyc2lvbkhhbmRsZXIoKTtcbiAgICAgICAgdGhpcy50b25Db25uZWN0U2RrVmVyc2lvbiA9IHlpZWxkIHRoaXMucmVxdWVzdFRvbkNvbm5lY3RTZGtWZXJzaW9uKCk7XG4gICAgICB9IGNhdGNoIChlMikge1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgcmVxdWVzdCB2ZXJzaW9uIGhhbmRsZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRSZXF1ZXN0VmVyc2lvbkhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIHRoaXMuZXZlbnREaXNwYXRjaGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b24tY29ubmVjdC11aS1yZXF1ZXN0LXZlcnNpb25cIiwgKCkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB5aWVsZCB0aGlzLmV2ZW50RGlzcGF0Y2hlci5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgIFwidG9uLWNvbm5lY3QtdWktcmVzcG9uc2UtdmVyc2lvblwiLFxuICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlVmVyc2lvbkV2ZW50KHRoaXMudG9uQ29ubmVjdFVpVmVyc2lvbilcbiAgICAgICAgKTtcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdCBUb25Db25uZWN0IFNESyB2ZXJzaW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVxdWVzdFRvbkNvbm5lY3RTZGtWZXJzaW9uKCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHlpZWxkIHRoaXMuZXZlbnREaXNwYXRjaGVyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICBcInRvbi1jb25uZWN0LXJlc3BvbnNlLXZlcnNpb25cIixcbiAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKGV2ZW50LmRldGFpbC52ZXJzaW9uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IG9uY2U6IHRydWUgfVxuICAgICAgICAgICk7XG4gICAgICAgICAgeWllbGQgdGhpcy5ldmVudERpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgIFwidG9uLWNvbm5lY3QtcmVxdWVzdC12ZXJzaW9uXCIsXG4gICAgICAgICAgICBjcmVhdGVSZXF1ZXN0VmVyc2lvbkV2ZW50KClcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgIHJlamVjdChlMik7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW1pdCB1c2VyIGFjdGlvbiBldmVudCB0byB0aGUgd2luZG93LlxuICAgKiBAcGFyYW0gZXZlbnREZXRhaWxzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkaXNwYXRjaFVzZXJBY3Rpb25FdmVudChldmVudERldGFpbHMpIHtcbiAgICB2YXIgX2EyO1xuICAgIHRyeSB7XG4gICAgICAoX2EyID0gdGhpcy5ldmVudERpc3BhdGNoZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZGlzcGF0Y2hFdmVudChgJHt0aGlzLmV2ZW50UHJlZml4fSR7ZXZlbnREZXRhaWxzLnR5cGV9YCwgZXZlbnREZXRhaWxzKS5jYXRjaCgpO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUcmFjayB3YWxsZXQgb3BlbmVkIGV2ZW50LlxuICAgKiBAcGFyYW0gYXJnc1xuICAgKi9cbiAgdHJhY2tXYWxsZXRNb2RhbE9wZW5lZCguLi5hcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlV2FsbGV0TW9kYWxPcGVuZWRFdmVudCh0aGlzLnZlcnNpb24sIC4uLmFyZ3MpO1xuICAgICAgdGhpcy5kaXNwYXRjaFVzZXJBY3Rpb25FdmVudChldmVudCk7XG4gICAgfSBjYXRjaCAoZTIpIHtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRyYWNrIHdhbGxldCBzZWxlY3RlZCBldmVudC5cbiAgICogQHBhcmFtIGFyZ3NcbiAgICovXG4gIHRyYWNrU2VsZWN0ZWRXYWxsZXQoLi4uYXJncykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBldmVudCA9IGNyZWF0ZVNlbGVjdGVkV2FsbGV0RXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICBsb2dFcnJvcihlMik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUcmFjayBjb25uZWN0aW9uIGluaXQgZXZlbnQuXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqL1xuICB0cmFja0Nvbm5lY3Rpb25TdGFydGVkKC4uLmFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVDb25uZWN0aW9uU3RhcnRlZEV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICB9IGNhdGNoIChlMikge1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVHJhY2sgY29ubmVjdGlvbiBzdWNjZXNzIGV2ZW50LlxuICAgKiBAcGFyYW0gYXJnc1xuICAgKi9cbiAgdHJhY2tDb25uZWN0aW9uQ29tcGxldGVkKC4uLmFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVDb25uZWN0aW9uQ29tcGxldGVkRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUcmFjayBjb25uZWN0aW9uIGVycm9yIGV2ZW50LlxuICAgKiBAcGFyYW0gYXJnc1xuICAgKi9cbiAgdHJhY2tDb25uZWN0aW9uRXJyb3IoLi4uYXJncykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBldmVudCA9IGNyZWF0ZUNvbm5lY3Rpb25FcnJvckV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICB9IGNhdGNoIChlMikge1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVHJhY2sgY29ubmVjdGlvbiByZXN0b3JpbmcgaW5pdCBldmVudC5cbiAgICogQHBhcmFtIGFyZ3NcbiAgICovXG4gIHRyYWNrQ29ubmVjdGlvblJlc3RvcmluZ1N0YXJ0ZWQoLi4uYXJncykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBldmVudCA9IGNyZWF0ZUNvbm5lY3Rpb25SZXN0b3JpbmdTdGFydGVkRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUcmFjayBjb25uZWN0aW9uIHJlc3RvcmluZyBzdWNjZXNzIGV2ZW50LlxuICAgKiBAcGFyYW0gYXJnc1xuICAgKi9cbiAgdHJhY2tDb25uZWN0aW9uUmVzdG9yaW5nQ29tcGxldGVkKC4uLmFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVDb25uZWN0aW9uUmVzdG9yaW5nQ29tcGxldGVkRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUcmFjayBjb25uZWN0aW9uIHJlc3RvcmluZyBlcnJvciBldmVudC5cbiAgICogQHBhcmFtIGFyZ3NcbiAgICovXG4gIHRyYWNrQ29ubmVjdGlvblJlc3RvcmluZ0Vycm9yKC4uLmFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVDb25uZWN0aW9uUmVzdG9yaW5nRXJyb3JFdmVudCh0aGlzLnZlcnNpb24sIC4uLmFyZ3MpO1xuICAgICAgdGhpcy5kaXNwYXRjaFVzZXJBY3Rpb25FdmVudChldmVudCk7XG4gICAgfSBjYXRjaCAoZTIpIHtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRyYWNrIGRpc2Nvbm5lY3QgZXZlbnQuXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqL1xuICB0cmFja0Rpc2Nvbm5lY3Rpb24oLi4uYXJncykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBldmVudCA9IGNyZWF0ZURpc2Nvbm5lY3Rpb25FdmVudCh0aGlzLnZlcnNpb24sIC4uLmFyZ3MpO1xuICAgICAgdGhpcy5kaXNwYXRjaFVzZXJBY3Rpb25FdmVudChldmVudCk7XG4gICAgfSBjYXRjaCAoZTIpIHtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRyYWNrIHRyYW5zYWN0aW9uIGluaXQgZXZlbnQuXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqL1xuICB0cmFja1RyYW5zYWN0aW9uU2VudEZvclNpZ25hdHVyZSguLi5hcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlVHJhbnNhY3Rpb25TZW50Rm9yU2lnbmF0dXJlRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUcmFjayB0cmFuc2FjdGlvbiBzaWduZWQgZXZlbnQuXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqL1xuICB0cmFja1RyYW5zYWN0aW9uU2lnbmVkKC4uLmFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVUcmFuc2FjdGlvblNpZ25lZEV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICB9IGNhdGNoIChlMikge1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVHJhY2sgdHJhbnNhY3Rpb24gZXJyb3IgZXZlbnQuXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqL1xuICB0cmFja1RyYW5zYWN0aW9uU2lnbmluZ0ZhaWxlZCguLi5hcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlVHJhbnNhY3Rpb25TaWduaW5nRmFpbGVkRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUcmFjayBkYXRhIHNlbnQgZm9yIHNpZ25hdHVyZSBldmVudC5cbiAgICogQHBhcmFtIGFyZ3NcbiAgICovXG4gIHRyYWNrRGF0YVNlbnRGb3JTaWduYXR1cmUoLi4uYXJncykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBldmVudCA9IGNyZWF0ZURhdGFTZW50Rm9yU2lnbmF0dXJlRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUcmFjayBkYXRhIHNpZ25lZCBldmVudC5cbiAgICogQHBhcmFtIGFyZ3NcbiAgICovXG4gIHRyYWNrRGF0YVNpZ25lZCguLi5hcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlRGF0YVNpZ25lZEV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICB9IGNhdGNoIChlMikge1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVHJhY2sgZGF0YSBzaWduaW5nIGVycm9yIGV2ZW50LlxuICAgKiBAcGFyYW0gYXJnc1xuICAgKi9cbiAgdHJhY2tEYXRhU2lnbmluZ0ZhaWxlZCguLi5hcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlRGF0YVNpZ25pbmdGYWlsZWRFdmVudCh0aGlzLnZlcnNpb24sIC4uLmFyZ3MpO1xuICAgICAgdGhpcy5kaXNwYXRjaFVzZXJBY3Rpb25FdmVudChldmVudCk7XG4gICAgfSBjYXRjaCAoZTIpIHtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IHRvbkNvbm5lY3RVaVZlcnNpb24gPSBcIjIuNC4yXCI7XG5jbGFzcyBUb25Db25uZWN0RW52aXJvbm1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnVzZXJBZ2VudCA9IGdldFVzZXJBZ2VudCgpO1xuICB9XG4gIGdldExvY2FsZSgpIHtcbiAgICB2YXIgX2EyO1xuICAgIHJldHVybiAoKF9hMiA9IG5hdmlnYXRvci5sYW5ndWFnZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYTJbMF0pIHx8IG5hdmlnYXRvci5sYW5ndWFnZSB8fCBcIlwiO1xuICB9XG4gIGdldEJyb3dzZXIoKSB7XG4gICAgdmFyIF9hMjtcbiAgICByZXR1cm4gKF9hMiA9IHRoaXMudXNlckFnZW50LmJyb3dzZXIpICE9IG51bGwgPyBfYTIgOiBcIlwiO1xuICB9XG4gIGdldFBsYXRmb3JtKCkge1xuICAgIHZhciBfYTI7XG4gICAgcmV0dXJuIChfYTIgPSB0aGlzLnVzZXJBZ2VudC5vcykgIT0gbnVsbCA/IF9hMiA6IFwiXCI7XG4gIH1cbiAgZ2V0VGVsZWdyYW1Vc2VyKCkge1xuICAgIHJldHVybiBnZXRUZ1VzZXIoKTtcbiAgfVxuICBnZXRDbGllbnRFbnZpcm9ubWVudCgpIHtcbiAgICByZXR1cm4gaXNJblRNQSgpID8gXCJtaW5pYXBwXCIgOiBcIndlYlwiO1xuICB9XG59XG5jbGFzcyBUb25Db25uZWN0VUkge1xuICAvLyBUT0RPOiBgYWN0aW9uc0NvbmZpZ3VyYXRpb24udHdhUmV0dXJuVXJsYCBpcyB1c2VkIG9ubHkgaW4gYGNvbm5lY3RXYWxsZXRgIG1ldGhvZCwgYnV0IGl0J3Mgbm90IHVzZWQgaW4gYHNlbmRUcmFuc2FjdGlvbmAgbWV0aG9kLCBORUVEIFRPIEZJWCBJVFxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hMjtcbiAgICB0aGlzLndhbGxldEluZm9TdG9yYWdlID0gbmV3IFdhbGxldEluZm9TdG9yYWdlKCk7XG4gICAgdGhpcy5wcmVmZXJyZWRXYWxsZXRTdG9yYWdlID0gbmV3IFByZWZlcnJlZFdhbGxldFN0b3JhZ2UoKTtcbiAgICB0aGlzLndhbGxldEluZm8gPSBudWxsO1xuICAgIHRoaXMuc3lzdGVtVGhlbWVDaGFuZ2VVbnN1YnNjcmliZSA9IG51bGw7XG4gICAgdGhpcy5jb25uZWN0aW9uUmVzdG9yZWQgPSBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIGxldCBldmVudERpc3BhdGNoZXIgPSAoX2EyID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5ldmVudERpc3BhdGNoZXIpICE9IG51bGwgPyBfYTIgOiBuZXcgQnJvd3NlckV2ZW50RGlzcGF0Y2hlcigpO1xuICAgIGlmIChvcHRpb25zICYmIFwiY29ubmVjdG9yXCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmNvbm5lY3Rvcikge1xuICAgICAgdGhpcy5jb25uZWN0b3IgPSBvcHRpb25zLmNvbm5lY3RvcjtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMgJiYgXCJtYW5pZmVzdFVybFwiIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5tYW5pZmVzdFVybCkge1xuICAgICAgdGhpcy5jb25uZWN0b3IgPSBuZXcgVG9uQ29ubmVjdCh7XG4gICAgICAgIG1hbmlmZXN0VXJsOiBvcHRpb25zLm1hbmlmZXN0VXJsLFxuICAgICAgICBldmVudERpc3BhdGNoZXIsXG4gICAgICAgIHdhbGxldHNSZXF1aXJlZEZlYXR1cmVzOiBvcHRpb25zLndhbGxldHNSZXF1aXJlZEZlYXR1cmVzLFxuICAgICAgICBlbnZpcm9ubWVudDogbmV3IFRvbkNvbm5lY3RFbnZpcm9ubWVudCgpLFxuICAgICAgICBhbmFseXRpY3M6IG9wdGlvbnMuYW5hbHl0aWNzXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RVSUVycm9yKFxuICAgICAgICBcIllvdSBoYXZlIHRvIHNwZWNpZnkgYSBgbWFuaWZlc3RVcmxgIG9yIGEgYGNvbm5lY3RvcmAgaW4gdGhlIG9wdGlvbnMuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMudHJhY2tlciA9IG5ldyBUb25Db25uZWN0VUlUcmFja2VyKHtcbiAgICAgIGV2ZW50RGlzcGF0Y2hlcixcbiAgICAgIHRvbkNvbm5lY3RVaVZlcnNpb25cbiAgICB9KTtcbiAgICB0aGlzLm1vZGFsID0gbmV3IFdhbGxldHNNb2RhbE1hbmFnZXIoe1xuICAgICAgY29ubmVjdG9yOiB0aGlzLmNvbm5lY3RvcixcbiAgICAgIHRyYWNrZXI6IHRoaXMudHJhY2tlcixcbiAgICAgIHNldENvbm5lY3RSZXF1ZXN0UGFyYW1ldGVyc0NhbGxiYWNrOiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgdGhpcy5jb25uZWN0UmVxdWVzdFBhcmFtZXRlcnNDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2luZ2xlV2FsbGV0TW9kYWwgPSBuZXcgU2luZ2xlV2FsbGV0TW9kYWxNYW5hZ2VyKHtcbiAgICAgIGNvbm5lY3RvcjogdGhpcy5jb25uZWN0b3IsXG4gICAgICB0cmFja2VyOiB0aGlzLnRyYWNrZXIsXG4gICAgICBzZXRDb25uZWN0UmVxdWVzdFBhcmFtZXRlcnNDYWxsYmFjazogKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHRoaXMuY29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnRyYW5zYWN0aW9uTW9kYWwgPSBuZXcgVHJhbnNhY3Rpb25Nb2RhbE1hbmFnZXIoe1xuICAgICAgY29ubmVjdG9yOiB0aGlzLmNvbm5lY3RvclxuICAgIH0pO1xuICAgIHRoaXMuX3dhbGxldHNSZXF1aXJlZEZlYXR1cmVzID0gb3B0aW9ucy53YWxsZXRzUmVxdWlyZWRGZWF0dXJlcztcbiAgICB0aGlzLl93YWxsZXRzUHJlZmVycmVkRmVhdHVyZXMgPSBvcHRpb25zLndhbGxldHNQcmVmZXJyZWRGZWF0dXJlcztcbiAgICB0aGlzLndhbGxldHNMaXN0ID0gdGhpcy5nZXRXYWxsZXRzKCk7XG4gICAgdGhpcy53YWxsZXRzTGlzdC50aGVuKChsaXN0KSA9PiBwcmVsb2FkSW1hZ2VzKHVuaXEobGlzdC5tYXAoKGl0ZW0pID0+IGl0ZW0uaW1hZ2VVcmwpKSkpO1xuICAgIGNvbnN0IHJvb3RJZCA9IHRoaXMubm9ybWFsaXplV2lkZ2V0Um9vdChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLndpZGdldFJvb3RJZCk7XG4gICAgdGhpcy5zdWJzY3JpYmVUb1dhbGxldENoYW5nZSgpO1xuICAgIGlmICgob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5yZXN0b3JlQ29ubmVjdGlvbikgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25SZXN0b3JlZCA9IGNyZWF0ZU1hY3JvdGFza0FzeW5jKCgpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrQ29ubmVjdGlvblJlc3RvcmluZ1N0YXJ0ZWQoKTtcbiAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0b3IucmVzdG9yZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3Rvci5jb25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uUmVzdG9yaW5nRXJyb3IoXCJDb25uZWN0aW9uIHdhcyBub3QgcmVzdG9yZWRcIik7XG4gICAgICAgICAgdGhpcy53YWxsZXRJbmZvU3RvcmFnZS5yZW1vdmVXYWxsZXRJbmZvKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrQ29ubmVjdGlvblJlc3RvcmluZ0NvbXBsZXRlZCh0aGlzLndhbGxldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdG9yLmNvbm5lY3RlZDtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgdGhpcy51aU9wdGlvbnMgPSBtZXJnZU9wdGlvbnMob3B0aW9ucywgeyB1aVByZWZlcmVuY2VzOiB7IHRoZW1lOiBcIlNZU1RFTVwiIH0gfSk7XG4gICAgY29uc3QgcHJlZmVycmVkV2FsbGV0TmFtZSA9IHRoaXMucHJlZmVycmVkV2FsbGV0U3RvcmFnZS5nZXRQcmVmZXJyZWRXYWxsZXRBcHBOYW1lKCk7XG4gICAgc2V0QXBwU3RhdGUoe1xuICAgICAgY29ubmVjdG9yOiB0aGlzLmNvbm5lY3RvcixcbiAgICAgIHByZWZlcnJlZFdhbGxldEFwcE5hbWU6IHByZWZlcnJlZFdhbGxldE5hbWVcbiAgICB9KTtcbiAgICB3aWRnZXRDb250cm9sbGVyLnJlbmRlckFwcChyb290SWQsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBnZXRXYWxsZXRzKCkge1xuICAgIHJldHVybiBUb25Db25uZWN0LmdldFdhbGxldHMoKTtcbiAgfVxuICBnZXQgd2FsbGV0c1JlcXVpcmVkRmVhdHVyZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldHNSZXF1aXJlZEZlYXR1cmVzO1xuICB9XG4gIGdldCB3YWxsZXRzUHJlZmVycmVkRmVhdHVyZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldHNQcmVmZXJyZWRGZWF0dXJlcztcbiAgfVxuICAvKipcbiAgICogQ3VycmVudCBjb25uZWN0aW9uIHN0YXR1cy5cbiAgICovXG4gIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdG9yLmNvbm5lY3RlZDtcbiAgfVxuICAvKipcbiAgICogQ3VycmVudCBjb25uZWN0ZWQgYWNjb3VudCBvciBudWxsLlxuICAgKi9cbiAgZ2V0IGFjY291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdG9yLmFjY291bnQ7XG4gIH1cbiAgLyoqXG4gICAqIEN1cnJlbiBjb25uZWN0ZWQgd2FsbGV0IGFwcCBhbmQgaXRzIGluZm8gb3IgbnVsbC5cbiAgICovXG4gIGdldCB3YWxsZXQoKSB7XG4gICAgaWYgKCF0aGlzLmNvbm5lY3Rvci53YWxsZXQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMuY29ubmVjdG9yLndhbGxldCksIHRoaXMud2FsbGV0SW5mbyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBhbmQgYXBwbHkgbmV3IFVJIG9wdGlvbnMuIE9iamVjdCB3aXRoIHBhcnRpYWwgb3B0aW9ucyBzaG91bGQgYmUgcGFzc2VkLiBQYXNzZWQgb3B0aW9ucyB3aWxsIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgb3B0aW9ucy5cbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICovXG4gIHNldCB1aU9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciBfYTIsIF9iMiwgX2MyLCBfZDIsIF9lMjtcbiAgICB0aGlzLmNoZWNrQnV0dG9uUm9vdEV4aXN0KG9wdGlvbnMuYnV0dG9uUm9vdElkKTtcbiAgICB0aGlzLmFjdGlvbnNDb25maWd1cmF0aW9uID0gb3B0aW9ucy5hY3Rpb25zQ29uZmlndXJhdGlvbjtcbiAgICBpZiAoXCJ3YWxsZXRzUmVxdWlyZWRGZWF0dXJlc1wiIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX3dhbGxldHNSZXF1aXJlZEZlYXR1cmVzID0gb3B0aW9ucy53YWxsZXRzUmVxdWlyZWRGZWF0dXJlcztcbiAgICB9XG4gICAgaWYgKFwid2FsbGV0c1ByZWZlcnJlZEZlYXR1cmVzXCIgaW4gb3B0aW9ucykge1xuICAgICAgdGhpcy5fd2FsbGV0c1ByZWZlcnJlZEZlYXR1cmVzID0gb3B0aW9ucy53YWxsZXRzUHJlZmVycmVkRmVhdHVyZXM7XG4gICAgfVxuICAgIGlmICgoX2EyID0gb3B0aW9ucy51aVByZWZlcmVuY2VzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnRoZW1lKSB7XG4gICAgICBpZiAoKChfYjIgPSBvcHRpb25zLnVpUHJlZmVyZW5jZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYjIudGhlbWUpICE9PSBcIlNZU1RFTVwiKSB7XG4gICAgICAgIChfYzIgPSB0aGlzLnN5c3RlbVRoZW1lQ2hhbmdlVW5zdWJzY3JpYmUpID09IG51bGwgPyB2b2lkIDAgOiBfYzIuY2FsbCh0aGlzKTtcbiAgICAgICAgc2V0VGhlbWUob3B0aW9ucy51aVByZWZlcmVuY2VzLnRoZW1lLCBvcHRpb25zLnVpUHJlZmVyZW5jZXMuY29sb3JzU2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRoZW1lKGdldFN5c3RlbVRoZW1lKCksIG9wdGlvbnMudWlQcmVmZXJlbmNlcy5jb2xvcnNTZXQpO1xuICAgICAgICBpZiAoIXRoaXMuc3lzdGVtVGhlbWVDaGFuZ2VVbnN1YnNjcmliZSkge1xuICAgICAgICAgIHRoaXMuc3lzdGVtVGhlbWVDaGFuZ2VVbnN1YnNjcmliZSA9IHN1YnNjcmliZVRvVGhlbWVDaGFuZ2Uoc2V0VGhlbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgoX2QyID0gb3B0aW9ucy51aVByZWZlcmVuY2VzKSA9PSBudWxsID8gdm9pZCAwIDogX2QyLmNvbG9yc1NldCkge1xuICAgICAgICBzZXRDb2xvcnMob3B0aW9ucy51aVByZWZlcmVuY2VzLmNvbG9yc1NldCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgoX2UyID0gb3B0aW9ucy51aVByZWZlcmVuY2VzKSA9PSBudWxsID8gdm9pZCAwIDogX2UyLmJvcmRlclJhZGl1cykge1xuICAgICAgc2V0Qm9yZGVyUmFkaXVzKG9wdGlvbnMudWlQcmVmZXJlbmNlcy5ib3JkZXJSYWRpdXMpO1xuICAgIH1cbiAgICBzZXRBcHBTdGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgIHZhciBfYTMsIF9iMztcbiAgICAgIGNvbnN0IG1lcmdlZCA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMubGFuZ3VhZ2UgJiYgeyBsYW5ndWFnZTogb3B0aW9ucy5sYW5ndWFnZSB9KSwgISEoKF9hMyA9IG9wdGlvbnMuYWN0aW9uc0NvbmZpZ3VyYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYTMucmV0dXJuU3RyYXRlZ3kpICYmIHtcbiAgICAgICAgICByZXR1cm5TdHJhdGVneTogb3B0aW9ucy5hY3Rpb25zQ29uZmlndXJhdGlvbi5yZXR1cm5TdHJhdGVneVxuICAgICAgICB9KSwgISEoKF9iMyA9IG9wdGlvbnMuYWN0aW9uc0NvbmZpZ3VyYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYjMudHdhUmV0dXJuVXJsKSAmJiB7XG4gICAgICAgICAgdHdhUmV0dXJuVXJsOiBvcHRpb25zLmFjdGlvbnNDb25maWd1cmF0aW9uLnR3YVJldHVyblVybFxuICAgICAgICB9KSwgISFvcHRpb25zLndhbGxldHNMaXN0Q29uZmlndXJhdGlvbiAmJiB7XG4gICAgICAgICAgd2FsbGV0c0xpc3RDb25maWd1cmF0aW9uOiBvcHRpb25zLndhbGxldHNMaXN0Q29uZmlndXJhdGlvblxuICAgICAgICB9KSxcbiAgICAgICAgdW53cmFwKHN0YXRlKVxuICAgICAgKTtcbiAgICAgIGlmIChvcHRpb25zLmJ1dHRvblJvb3RJZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIG1lcmdlZC5idXR0b25Sb290SWQgPSBvcHRpb25zLmJ1dHRvblJvb3RJZDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmVuYWJsZUFuZHJvaWRCYWNrSGFuZGxlciAhPT0gdm9pZCAwKSB7XG4gICAgICAgIG1lcmdlZC5lbmFibGVBbmRyb2lkQmFja0hhbmRsZXIgPSBvcHRpb25zLmVuYWJsZUFuZHJvaWRCYWNrSGFuZGxlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVzZSBpdCB0byBjdXN0b21pemUgQ29ubmVjdFJlcXVlc3QgYW5kIGFkZCBgdG9uUHJvb2ZgIHBheWxvYWQuXG4gICAqIFlvdSBjYW4gY2FsbCBpdCBtdWx0aXBseSB0aW1lcyB0byBzZXQgdXBkYXRlZCB0b25Qcm9vZiBwYXlsb2FkIGlmIHByZXZpb3VzIG9uZSBpcyBvdXRkYXRlZC5cbiAgICogSWYgYGNvbm5lY3RSZXF1ZXN0UGFyYW1ldGVycy5zdGF0ZSA9PT0gJ2xvYWRpbmcnYCBsb2FkZXIgd2lsbCBhcHBlYXIgaW5zdGVhZCBvZiB0aGUgcXIgY29kZSBpbiB0aGUgd2FsbGV0cyBtb2RhbC5cbiAgICogSWYgYGNvbm5lY3RSZXF1ZXN0UGFyYW1ldGVycy5zdGF0ZWAgd2FzIGNoYW5nZWQgdG8gJ3JlYWR5JyBvciBpdCdzIHZhbHVlIGhhcyBiZWVuIGNoYW5nZWQsIFFSIHdpbGwgYmUgcmUtcmVuZGVyZWQuXG4gICAqL1xuICBzZXRDb25uZWN0UmVxdWVzdFBhcmFtZXRlcnMoY29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzKSB7XG4gICAgdmFyIF9hMjtcbiAgICBzZXRBcHBTdGF0ZSh7IGNvbm5lY3RSZXF1ZXN0UGFyYW1ldGVycyB9KTtcbiAgICBpZiAoKGNvbm5lY3RSZXF1ZXN0UGFyYW1ldGVycyA9PSBudWxsID8gdm9pZCAwIDogY29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzLnN0YXRlKSA9PT0gXCJyZWFkeVwiIHx8ICFjb25uZWN0UmVxdWVzdFBhcmFtZXRlcnMpIHtcbiAgICAgIChfYTIgPSB0aGlzLmNvbm5lY3RSZXF1ZXN0UGFyYW1ldGVyc0NhbGxiYWNrKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwodGhpcywgY29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzID09IG51bGwgPyB2b2lkIDAgOiBjb25uZWN0UmVxdWVzdFBhcmFtZXRlcnMudmFsdWUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0IGRlc2lyZWQgbmV0d29yayBmb3IgdGhlIGNvbm5lY3Rpb24uIENhbiBvbmx5IGJlIHNldCBiZWZvcmUgY29ubmVjdGluZy5cbiAgICogSWYgd2FsbGV0IGNvbm5lY3RzIHdpdGggYSBkaWZmZXJlbnQgY2hhaW4sIHRoZSBTREsgd2lsbCB0aHJvdyBhbiBlcnJvciBhbmQgYWJvcnQgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIG5ldHdvcmsgZGVzaXJlZCBuZXR3b3JrIGlkIChlLmcuLCAnLTIzOScsICctMycsIG9yIGN1c3RvbSkuIFBhc3MgdW5kZWZpbmVkIHRvIGFsbG93IGFueSBuZXR3b3JrLlxuICAgKi9cbiAgc2V0Q29ubmVjdGlvbk5ldHdvcmsobmV0d29yaykge1xuICAgIHRoaXMuY29ubmVjdG9yLnNldENvbm5lY3Rpb25OZXR3b3JrKG5ldHdvcmspO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGF2YWlsYWJsZSB3YWxsZXRzIGxpc3QuXG4gICAqL1xuICBnZXRXYWxsZXRzKCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25uZWN0b3IuZ2V0V2FsbGV0cygpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gY29ubmVjdGlvbiBzdGF0dXMgY2hhbmdlLlxuICAgKiBAcmV0dXJuIGZ1bmN0aW9uIHdoaWNoIGhhcyB0byBiZSBjYWxsZWQgdG8gdW5zdWJzY3JpYmUuXG4gICAqL1xuICBvblN0YXR1c0NoYW5nZShjYWxsYmFjaywgZXJyb3JzSGFuZGxlcikge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rvci5vblN0YXR1c0NoYW5nZSgod2FsbGV0KSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAod2FsbGV0KSB7XG4gICAgICAgIGNvbnN0IGxhc3RTZWxlY3RlZFdhbGxldEluZm8yID0geWllbGQgdGhpcy5nZXRTZWxlY3RlZFdhbGxldEluZm8od2FsbGV0KTtcbiAgICAgICAgY2FsbGJhY2soX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHdhbGxldCksIGxhc3RTZWxlY3RlZFdhbGxldEluZm8yIHx8IHRoaXMud2FsbGV0SW5mb1N0b3JhZ2UuZ2V0V2FsbGV0SW5mbygpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayh3YWxsZXQpO1xuICAgICAgfVxuICAgIH0pLCBlcnJvcnNIYW5kbGVyKTtcbiAgfVxuICAvKipcbiAgICogT3BlbnMgdGhlIG1vZGFsIHdpbmRvdywgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB0aGUgbW9kYWwgd2luZG93IGlzIG9wZW5lZC5cbiAgICovXG4gIG9wZW5Nb2RhbChvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBjb25zdCB0cmFjZUlkID0gKF9hMiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZCkgIT0gbnVsbCA/IF9hMiA6IFVVSUR2NygpO1xuICAgICAgeWllbGQgdGhpcy5tb2RhbC5vcGVuKHsgdHJhY2VJZCB9KTtcbiAgICAgIGNvbnN0IHNlc3Npb25JZCA9IHlpZWxkIHRoaXMuZ2V0U2Vzc2lvbklkKCk7XG4gICAgICBjb25zdCB2aXNpYmxlV2FsbGV0cyA9IHdpZGdldENvbnRyb2xsZXIuZ2V0TGFzdFZpc2libGVXYWxsZXRzKCk7XG4gICAgICB0aGlzLnRyYWNrZXIudHJhY2tXYWxsZXRNb2RhbE9wZW5lZChcbiAgICAgICAgdmlzaWJsZVdhbGxldHMud2FsbGV0cy5tYXAoKHdhbGxldCkgPT4gd2FsbGV0Lm5hbWUpLFxuICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhY2VJZFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBtb2RhbCB3aW5kb3cuXG4gICAqL1xuICBjbG9zZU1vZGFsKHJlYXNvbikge1xuICAgIHRoaXMubW9kYWwuY2xvc2UocmVhc29uKTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIHRoZSBtb2RhbCB3aW5kb3cgc3RhdGUgY2hhbmdlcywgcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGhhcyB0byBiZSBjYWxsZWQgdG8gdW5zdWJzY3JpYmUuXG4gICAqL1xuICBvbk1vZGFsU3RhdGVDaGFuZ2Uob25DaGFuZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RhbC5vblN0YXRlQ2hhbmdlKG9uQ2hhbmdlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBjdXJyZW50IG1vZGFsIHdpbmRvdyBzdGF0ZS5cbiAgICovXG4gIGdldCBtb2RhbFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLm1vZGFsLnN0YXRlO1xuICB9XG4gIC8qKlxuICAgKiBPcGVucyB0aGUgc2luZ2xlIHdhbGxldCBtb2RhbCB3aW5kb3csIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgdGhlIG1vZGFsIHdpbmRvdyBpcyBvcGVuZWQuXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIG9wZW5TaW5nbGVXYWxsZXRNb2RhbCh3YWxsZXQpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2luZ2xlV2FsbGV0TW9kYWwub3Blbih3YWxsZXQpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgc2luZ2xlIHdhbGxldCBtb2RhbCB3aW5kb3cuXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIGNsb3NlU2luZ2xlV2FsbGV0TW9kYWwoY2xvc2VSZWFzb24pIHtcbiAgICB0aGlzLnNpbmdsZVdhbGxldE1vZGFsLmNsb3NlKGNsb3NlUmVhc29uKTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIHRoZSBzaW5nbGUgd2FsbGV0IG1vZGFsIHdpbmRvdyBzdGF0ZSBjaGFuZ2VzLCByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggaGFzIHRvIGJlIGNhbGxlZCB0byB1bnN1YnNjcmliZS5cbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgb25TaW5nbGVXYWxsZXRNb2RhbFN0YXRlQ2hhbmdlKG9uQ2hhbmdlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2luZ2xlV2FsbGV0TW9kYWwub25TdGF0ZUNoYW5nZShvbkNoYW5nZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgY3VycmVudCBzaW5nbGUgd2FsbGV0IG1vZGFsIHdpbmRvdyBzdGF0ZS5cbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgZ2V0IHNpbmdsZVdhbGxldE1vZGFsU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2luZ2xlV2FsbGV0TW9kYWwuc3RhdGU7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgdG9uQ29ubmVjdFVJLm9wZW5Nb2RhbCgpYCBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICogT3BlbnMgdGhlIG1vZGFsIHdpbmRvdyBhbmQgaGFuZGxlcyBhIHdhbGxldCBjb25uZWN0aW9uLlxuICAgKiBAcmV0dXJuIENvbm5lY3RlZCB3YWxsZXQuXG4gICAqIEB0aHJvd3MgVG9uQ29ubmVjdFVJRXJyb3IgaWYgY29ubmVjdGlvbiB3YXMgYWJvcnRlZC5cbiAgICovXG4gIGNvbm5lY3RXYWxsZXQob3B0aW9ucykge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgY29uc3QgdHJhY2VJZCA9IChfYTIgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnRyYWNlSWQpICE9IG51bGwgPyBfYTIgOiBVVUlEdjcoKTtcbiAgICAgIGNvbnN0IHdhbGxldHNMaXN0ID0geWllbGQgdGhpcy5nZXRXYWxsZXRzKCk7XG4gICAgICBjb25zdCBlbWJlZGRlZFdhbGxldCA9IHdhbGxldHNMaXN0LmZpbmQoaXNXYWxsZXRJbmZvQ3VycmVudGx5RW1iZWRkZWQpO1xuICAgICAgaWYgKGVtYmVkZGVkV2FsbGV0KSB7XG4gICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNvbm5lY3RFbWJlZGRlZFdhbGxldChlbWJlZGRlZFdhbGxldCwgeyB0cmFjZUlkIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY29ubmVjdEV4dGVybmFsV2FsbGV0KHsgdHJhY2VJZCB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGlzY29ubmVjdCB3YWxsZXQgYW5kIGNsZWFuIGxvY2Fsc3RvcmFnZS5cbiAgICovXG4gIGRpc2Nvbm5lY3Qob3B0aW9ucykge1xuICAgIHZhciBfYTI7XG4gICAgY29uc3QgdHJhY2VJZCA9IChfYTIgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnRyYWNlSWQpICE9IG51bGwgPyBfYTIgOiBVVUlEdjcoKTtcbiAgICB0aGlzLnRyYWNrZXIudHJhY2tEaXNjb25uZWN0aW9uKHRoaXMud2FsbGV0LCBcImRhcHBcIik7XG4gICAgd2lkZ2V0Q29udHJvbGxlci5jbGVhckFjdGlvbigpO1xuICAgIHdpZGdldENvbnRyb2xsZXIucmVtb3ZlU2VsZWN0ZWRXYWxsZXRJbmZvKCk7XG4gICAgdGhpcy53YWxsZXRJbmZvU3RvcmFnZS5yZW1vdmVXYWxsZXRJbmZvKCk7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdG9yLmRpc2Nvbm5lY3QoeyB0cmFjZUlkIH0pO1xuICB9XG4gIC8qKlxuICAgKiBPcGVucyB0aGUgbW9kYWwgd2luZG93IGFuZCBoYW5kbGVzIHRoZSB0cmFuc2FjdGlvbiBzZW5kaW5nLlxuICAgKiBAcGFyYW0gdHggdHJhbnNhY3Rpb24gdG8gc2VuZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgbW9kYWwgYW5kIG5vdGlmaWNhdGlvbnMgYmVoYXZpb3VyIHNldHRpbmdzLiBEZWZhdWx0IGlzIHNob3cgb25seSAnYmVmb3JlJyBtb2RhbCBhbmQgYWxsIG5vdGlmaWNhdGlvbnMuXG4gICAqL1xuICBzZW5kVHJhbnNhY3Rpb24odHgsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGNvbnN0IHRyYWNlSWQgPSAoX2EyID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50cmFjZUlkKSAhPSBudWxsID8gX2EyIDogVVVJRHY3KCk7XG4gICAgICB0aGlzLnRyYWNrZXIudHJhY2tUcmFuc2FjdGlvblNlbnRGb3JTaWduYXR1cmUodGhpcy53YWxsZXQsIHR4KTtcbiAgICAgIGlmICghdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrVHJhbnNhY3Rpb25TaWduaW5nRmFpbGVkKHRoaXMud2FsbGV0LCB0eCwgXCJXYWxsZXQgd2FzIG5vdCBjb25uZWN0ZWRcIik7XG4gICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0VUlFcnJvcihcIkNvbm5lY3Qgd2FsbGV0IHRvIHNlbmQgYSB0cmFuc2FjdGlvbi5cIik7XG4gICAgICB9XG4gICAgICBpZiAoaXNJblRNQSgpKSB7XG4gICAgICAgIHNlbmRFeHBhbmQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgbm90aWZpY2F0aW9uczogbm90aWZpY2F0aW9uczIsIG1vZGFscywgcmV0dXJuU3RyYXRlZ3ksIHR3YVJldHVyblVybCB9ID0gdGhpcy5nZXRNb2RhbHNBbmROb3RpZmljYXRpb25zQ29uZmlndXJhdGlvbihvcHRpb25zKTtcbiAgICAgIGNvbnN0IHNlc3Npb25JZCA9IHlpZWxkIHRoaXMuZ2V0U2Vzc2lvbklkKCk7XG4gICAgICB3aWRnZXRDb250cm9sbGVyLnNldEFjdGlvbih7XG4gICAgICAgIG5hbWU6IFwiY29uZmlybS10cmFuc2FjdGlvblwiLFxuICAgICAgICBzaG93Tm90aWZpY2F0aW9uOiBub3RpZmljYXRpb25zMi5pbmNsdWRlcyhcImJlZm9yZVwiKSxcbiAgICAgICAgb3Blbk1vZGFsOiBtb2RhbHMuaW5jbHVkZXMoXCJiZWZvcmVcIiksXG4gICAgICAgIHNlbnQ6IGZhbHNlLFxuICAgICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZCB8fCB2b2lkIDAsXG4gICAgICAgIHRyYWNlSWRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgb25SZXF1ZXN0U2VudCA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hMztcbiAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aWRnZXRDb250cm9sbGVyLnNldEFjdGlvbih7XG4gICAgICAgICAgbmFtZTogXCJjb25maXJtLXRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgc2hvd05vdGlmaWNhdGlvbjogbm90aWZpY2F0aW9uczIuaW5jbHVkZXMoXCJiZWZvcmVcIiksXG4gICAgICAgICAgb3Blbk1vZGFsOiBtb2RhbHMuaW5jbHVkZXMoXCJiZWZvcmVcIiksXG4gICAgICAgICAgc2VudDogdHJ1ZSxcbiAgICAgICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZCB8fCB2b2lkIDAsXG4gICAgICAgICAgdHJhY2VJZFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWRpcmVjdEFmdGVyUmVxdWVzdFNlbnQoe1xuICAgICAgICAgIHJldHVyblN0cmF0ZWd5LFxuICAgICAgICAgIHR3YVJldHVyblVybCxcbiAgICAgICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZCB8fCB2b2lkIDAsXG4gICAgICAgICAgdHJhY2VJZFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGZpcnN0Q2xpY2sgPSB0cnVlO1xuICAgICAgICBjb25zdCByZWRpcmVjdFRvV2FsbGV0MiA9ICgpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZvcmNlUmVkaXJlY3QgPSAhZmlyc3RDbGljaztcbiAgICAgICAgICBmaXJzdENsaWNrID0gZmFsc2U7XG4gICAgICAgICAgeWllbGQgdGhpcy5yZWRpcmVjdEFmdGVyUmVxdWVzdFNlbnQoe1xuICAgICAgICAgICAgcmV0dXJuU3RyYXRlZ3ksXG4gICAgICAgICAgICB0d2FSZXR1cm5VcmwsXG4gICAgICAgICAgICBmb3JjZVJlZGlyZWN0LFxuICAgICAgICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWQgfHwgdm9pZCAwLFxuICAgICAgICAgICAgdHJhY2VJZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgKF9hMyA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMub25SZXF1ZXN0U2VudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jYWxsKG9wdGlvbnMsIHJlZGlyZWN0VG9XYWxsZXQyKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMub25UcmFuc2FjdGlvbk1vZGFsU3RhdGVDaGFuZ2UoKGFjdGlvbjIpID0+IHtcbiAgICAgICAgaWYgKGFjdGlvbjIgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGlvbjIub3Blbk1vZGFsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGlmICghYWN0aW9uMikge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMud2FpdEZvclNlbmRUcmFuc2FjdGlvbihcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHgsXG4gICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICB0cmFjZUlkXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblJlcXVlc3RTZW50XG4gICAgICAgICk7XG4gICAgICAgIHRoaXMudHJhY2tlci50cmFja1RyYW5zYWN0aW9uU2lnbmVkKHRoaXMud2FsbGV0LCB0eCwgcmVzdWx0KTtcbiAgICAgICAgd2lkZ2V0Q29udHJvbGxlci5zZXRBY3Rpb24oe1xuICAgICAgICAgIG5hbWU6IFwidHJhbnNhY3Rpb24tc2VudFwiLFxuICAgICAgICAgIHNob3dOb3RpZmljYXRpb246IG5vdGlmaWNhdGlvbnMyLmluY2x1ZGVzKFwic3VjY2Vzc1wiKSxcbiAgICAgICAgICBvcGVuTW9kYWw6IG1vZGFscy5pbmNsdWRlcyhcInN1Y2Nlc3NcIiksXG4gICAgICAgICAgdHJhY2VJZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIGlmIChlMiBpbnN0YW5jZW9mIFdhbGxldE5vdFN1cHBvcnRGZWF0dXJlRXJyb3IpIHtcbiAgICAgICAgICB3aWRnZXRDb250cm9sbGVyLmNsZWFyQWN0aW9uKCk7XG4gICAgICAgICAgd2lkZ2V0Q29udHJvbGxlci5vcGVuV2FsbGV0Tm90U3VwcG9ydEZlYXR1cmVNb2RhbChlMi5jYXVzZSwgeyB0cmFjZUlkIH0pO1xuICAgICAgICAgIHRocm93IGUyO1xuICAgICAgICB9XG4gICAgICAgIHdpZGdldENvbnRyb2xsZXIuc2V0QWN0aW9uKHtcbiAgICAgICAgICBuYW1lOiBcInRyYW5zYWN0aW9uLWNhbmNlbGVkXCIsXG4gICAgICAgICAgc2hvd05vdGlmaWNhdGlvbjogbm90aWZpY2F0aW9uczIuaW5jbHVkZXMoXCJlcnJvclwiKSxcbiAgICAgICAgICBvcGVuTW9kYWw6IG1vZGFscy5pbmNsdWRlcyhcImVycm9yXCIpLFxuICAgICAgICAgIHRyYWNlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlMiBpbnN0YW5jZW9mIFRvbkNvbm5lY3RFcnJvcikge1xuICAgICAgICAgIHRocm93IGUyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZTIpO1xuICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0VUlFcnJvcihcIlVuaGFuZGxlZCBlcnJvcjpcIiArIGUyKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2lnbnMgdGhlIGRhdGEgYW5kIHJldHVybnMgdGhlIHNpZ25hdHVyZS5cbiAgICogQHBhcmFtIGRhdGEgZGF0YSB0byBzaWduLlxuICAgKi9cbiAgc2lnbkRhdGEoZGF0YSwgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgY29uc3QgdHJhY2VJZCA9IChfYTIgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnRyYWNlSWQpICE9IG51bGwgPyBfYTIgOiBVVUlEdjcoKTtcbiAgICAgIHRoaXMudHJhY2tlci50cmFja0RhdGFTZW50Rm9yU2lnbmF0dXJlKHRoaXMud2FsbGV0LCBkYXRhKTtcbiAgICAgIGlmICghdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrRGF0YVNpZ25pbmdGYWlsZWQodGhpcy53YWxsZXQsIGRhdGEsIFwiV2FsbGV0IHdhcyBub3QgY29ubmVjdGVkXCIpO1xuICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdFVJRXJyb3IoXCJDb25uZWN0IHdhbGxldCB0byBzZW5kIGEgdHJhbnNhY3Rpb24uXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGlzSW5UTUEoKSkge1xuICAgICAgICBzZW5kRXhwYW5kKCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IG5vdGlmaWNhdGlvbnM6IG5vdGlmaWNhdGlvbnMyLCBtb2RhbHMsIHJldHVyblN0cmF0ZWd5LCB0d2FSZXR1cm5VcmwgfSA9IHRoaXMuZ2V0TW9kYWxzQW5kTm90aWZpY2F0aW9uc0NvbmZpZ3VyYXRpb24oKTtcbiAgICAgIGNvbnN0IHNlc3Npb25JZCA9IHlpZWxkIHRoaXMuZ2V0U2Vzc2lvbklkKCk7XG4gICAgICB3aWRnZXRDb250cm9sbGVyLnNldEFjdGlvbih7XG4gICAgICAgIG5hbWU6IFwiY29uZmlybS1zaWduLWRhdGFcIixcbiAgICAgICAgc2hvd05vdGlmaWNhdGlvbjogbm90aWZpY2F0aW9uczIuaW5jbHVkZXMoXCJiZWZvcmVcIiksXG4gICAgICAgIG9wZW5Nb2RhbDogbW9kYWxzLmluY2x1ZGVzKFwiYmVmb3JlXCIpLFxuICAgICAgICBzaWduZWQ6IGZhbHNlLFxuICAgICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZCB8fCB2b2lkIDAsXG4gICAgICAgIHRyYWNlSWRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgb25SZXF1ZXN0U2VudCA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hMztcbiAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aWRnZXRDb250cm9sbGVyLnNldEFjdGlvbih7XG4gICAgICAgICAgbmFtZTogXCJjb25maXJtLXNpZ24tZGF0YVwiLFxuICAgICAgICAgIHNob3dOb3RpZmljYXRpb246IG5vdGlmaWNhdGlvbnMyLmluY2x1ZGVzKFwiYmVmb3JlXCIpLFxuICAgICAgICAgIG9wZW5Nb2RhbDogbW9kYWxzLmluY2x1ZGVzKFwiYmVmb3JlXCIpLFxuICAgICAgICAgIHNpZ25lZDogdHJ1ZSxcbiAgICAgICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZCB8fCB2b2lkIDAsXG4gICAgICAgICAgdHJhY2VJZFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWRpcmVjdEFmdGVyUmVxdWVzdFNlbnQoe1xuICAgICAgICAgIHJldHVyblN0cmF0ZWd5LFxuICAgICAgICAgIHR3YVJldHVyblVybCxcbiAgICAgICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZCB8fCB2b2lkIDAsXG4gICAgICAgICAgdHJhY2VJZFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGZpcnN0Q2xpY2sgPSB0cnVlO1xuICAgICAgICBjb25zdCByZWRpcmVjdFRvV2FsbGV0MiA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZvcmNlUmVkaXJlY3QgPSAhZmlyc3RDbGljaztcbiAgICAgICAgICBmaXJzdENsaWNrID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5yZWRpcmVjdEFmdGVyUmVxdWVzdFNlbnQoe1xuICAgICAgICAgICAgcmV0dXJuU3RyYXRlZ3ksXG4gICAgICAgICAgICB0d2FSZXR1cm5VcmwsXG4gICAgICAgICAgICBmb3JjZVJlZGlyZWN0LFxuICAgICAgICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWQgfHwgdm9pZCAwLFxuICAgICAgICAgICAgdHJhY2VJZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAoX2EzID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5vblJlcXVlc3RTZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNhbGwob3B0aW9ucywgcmVkaXJlY3RUb1dhbGxldDIpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5vblRyYW5zYWN0aW9uTW9kYWxTdGF0ZUNoYW5nZSgoYWN0aW9uMikgPT4ge1xuICAgICAgICBpZiAoYWN0aW9uMiA9PSBudWxsID8gdm9pZCAwIDogYWN0aW9uMi5vcGVuTW9kYWwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgaWYgKCFhY3Rpb24yKSB7XG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy53YWl0Rm9yU2lnbkRhdGEoXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHNpZ25hbDogbmV3IEFib3J0Q29udHJvbGxlcigpLnNpZ25hbCxcbiAgICAgICAgICAgIHRyYWNlSWRcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uUmVxdWVzdFNlbnRcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrRGF0YVNpZ25lZCh0aGlzLndhbGxldCwgZGF0YSwgcmVzdWx0KTtcbiAgICAgICAgd2lkZ2V0Q29udHJvbGxlci5zZXRBY3Rpb24oe1xuICAgICAgICAgIG5hbWU6IFwiZGF0YS1zaWduZWRcIixcbiAgICAgICAgICBzaG93Tm90aWZpY2F0aW9uOiBub3RpZmljYXRpb25zMi5pbmNsdWRlcyhcInN1Y2Nlc3NcIiksXG4gICAgICAgICAgb3Blbk1vZGFsOiBtb2RhbHMuaW5jbHVkZXMoXCJzdWNjZXNzXCIpLFxuICAgICAgICAgIHRyYWNlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICBpZiAoZTIgaW5zdGFuY2VvZiBXYWxsZXROb3RTdXBwb3J0RmVhdHVyZUVycm9yKSB7XG4gICAgICAgICAgd2lkZ2V0Q29udHJvbGxlci5jbGVhckFjdGlvbigpO1xuICAgICAgICAgIHdpZGdldENvbnRyb2xsZXIub3BlbldhbGxldE5vdFN1cHBvcnRGZWF0dXJlTW9kYWwoZTIuY2F1c2UsIHsgdHJhY2VJZCB9KTtcbiAgICAgICAgICB0aHJvdyBlMjtcbiAgICAgICAgfVxuICAgICAgICB3aWRnZXRDb250cm9sbGVyLnNldEFjdGlvbih7XG4gICAgICAgICAgbmFtZTogXCJzaWduLWRhdGEtY2FuY2VsZWRcIixcbiAgICAgICAgICBzaG93Tm90aWZpY2F0aW9uOiBub3RpZmljYXRpb25zMi5pbmNsdWRlcyhcImVycm9yXCIpLFxuICAgICAgICAgIG9wZW5Nb2RhbDogbW9kYWxzLmluY2x1ZGVzKFwiZXJyb3JcIiksXG4gICAgICAgICAgdHJhY2VJZFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGUyIGluc3RhbmNlb2YgVG9uQ29ubmVjdEVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlMik7XG4gICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RVSUVycm9yKFwiVW5oYW5kbGVkIGVycm9yOlwiICsgZTIpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHNlc3Npb24gSUQgaWYgYXZhaWxhYmxlLlxuICAgKiBAcmV0dXJucyBzZXNzaW9uIElEIHN0cmluZyBvciBudWxsIGlmIG5vdCBhdmFpbGFibGUuXG4gICAqL1xuICBnZXRTZXNzaW9uSWQoKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTIsIF9iMjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2UgPSAoX2EyID0gdGhpcy5jb25uZWN0b3IuZGFwcFNldHRpbmdzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnN0b3JhZ2U7XG4gICAgICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICAgICAgY29uc3Qgc3RvcmVkID0geWllbGQgc3RvcmFnZS5nZXRJdGVtKFwidG9uLWNvbm5lY3Qtc3RvcmFnZV9icmlkZ2UtY29ubmVjdGlvblwiKTtcbiAgICAgICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gSlNPTi5wYXJzZShzdG9yZWQpO1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24udHlwZSA9PT0gXCJodHRwXCIgJiYgY29ubmVjdGlvbi5zZXNzaW9uQ3J5cHRvKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25DcnlwdG8gPSBuZXcgU2Vzc2lvbkNyeXB0byhjb25uZWN0aW9uLnNlc3Npb25DcnlwdG8pO1xuICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSBzZXNzaW9uQ3J5cHRvLnNlc3Npb25JZDtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25JZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvbi50eXBlID09PSBcImh0dHBcIiAmJiAoKF9iMiA9IGNvbm5lY3Rpb24uc2Vzc2lvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5zZXNzaW9uS2V5UGFpcikpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbkNyeXB0byA9IG5ldyBTZXNzaW9uQ3J5cHRvKGNvbm5lY3Rpb24uc2Vzc2lvbi5zZXNzaW9uS2V5UGFpcik7XG4gICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9IHNlc3Npb25DcnlwdG8uc2Vzc2lvbklkO1xuICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvbklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuICB9XG4gIHJlZGlyZWN0QWZ0ZXJSZXF1ZXN0U2VudCh7XG4gICAgcmV0dXJuU3RyYXRlZ3ksXG4gICAgdHdhUmV0dXJuVXJsLFxuICAgIGZvcmNlUmVkaXJlY3QsXG4gICAgc2Vzc2lvbklkLFxuICAgIHRyYWNlSWRcbiAgfSkge1xuICAgIGlmICh0aGlzLndhbGxldEluZm8gJiYgXCJ1bml2ZXJzYWxMaW5rXCIgaW4gdGhpcy53YWxsZXRJbmZvICYmICh0aGlzLndhbGxldEluZm8ub3Blbk1ldGhvZCA9PT0gXCJ1bml2ZXJzYWwtbGlua1wiIHx8IHRoaXMud2FsbGV0SW5mby5vcGVuTWV0aG9kID09PSBcImN1c3RvbS1kZWVwbGlua1wiKSkge1xuICAgICAgY29uc3QgbGlua1dpdGhTZXNzaW9uSWQgPSBlbnJpY2hVbml2ZXJzYWxMaW5rKHRoaXMud2FsbGV0SW5mby51bml2ZXJzYWxMaW5rLCB7XG4gICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgdHJhY2VJZFxuICAgICAgfSk7XG4gICAgICBpZiAoaXNUZWxlZ3JhbVVybCh0aGlzLndhbGxldEluZm8udW5pdmVyc2FsTGluaykpIHtcbiAgICAgICAgcmVkaXJlY3RUb1RlbGVncmFtKGxpbmtXaXRoU2Vzc2lvbklkLCB7XG4gICAgICAgICAgcmV0dXJuU3RyYXRlZ3ksXG4gICAgICAgICAgdHdhUmV0dXJuVXJsOiB0d2FSZXR1cm5VcmwgfHwgYXBwU3RhdGUudHdhUmV0dXJuVXJsLFxuICAgICAgICAgIGZvcmNlUmVkaXJlY3Q6IGZvcmNlUmVkaXJlY3QgfHwgZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWRpcmVjdFRvV2FsbGV0KFxuICAgICAgICAgIGxpbmtXaXRoU2Vzc2lvbklkLFxuICAgICAgICAgIHRoaXMud2FsbGV0SW5mby5kZWVwTGluayxcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm5TdHJhdGVneSxcbiAgICAgICAgICAgIGZvcmNlUmVkaXJlY3Q6IGZvcmNlUmVkaXJlY3QgfHwgZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUT0RPOiByZW1vdmUgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICogSW5pdGlhdGVzIGEgY29ubmVjdGlvbiB3aXRoIGFuIGVtYmVkZGVkIHdhbGxldCwgYXdhaXRzIGl0cyBjb21wbGV0aW9uLCBhbmQgcmV0dXJucyB0aGUgY29ubmVjdGVkIHdhbGxldCBpbmZvcm1hdGlvbi5cbiAgICogQHBhcmFtIGVtYmVkZGVkV2FsbGV0IC0gSW5mb3JtYXRpb24gYWJvdXQgdGhlIGVtYmVkZGVkIHdhbGxldCB0byBjb25uZWN0IHRvLlxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBjb25uZWN0aW9uIHByb2Nlc3MgZmFpbHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29ubmVjdEVtYmVkZGVkV2FsbGV0KGVtYmVkZGVkV2FsbGV0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGNvbm5lY3QgPSAocGFyYW1ldGVycykgPT4ge1xuICAgICAgICBzZXRMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvKGVtYmVkZGVkV2FsbGV0KTtcbiAgICAgICAgdGhpcy5jb25uZWN0b3IuY29ubmVjdCh7IGpzQnJpZGdlS2V5OiBlbWJlZGRlZFdhbGxldC5qc0JyaWRnZUtleSB9LCBwYXJhbWV0ZXJzLCB7XG4gICAgICAgICAgdHJhY2VJZDogb3B0aW9ucy50cmFjZUlkXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZGl0aW9uYWxSZXF1ZXN0ID0gYXBwU3RhdGUuY29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzO1xuICAgICAgaWYgKChhZGRpdGlvbmFsUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogYWRkaXRpb25hbFJlcXVlc3Quc3RhdGUpID09PSBcImxvYWRpbmdcIikge1xuICAgICAgICB0aGlzLmNvbm5lY3RSZXF1ZXN0UGFyYW1ldGVyc0NhbGxiYWNrID0gY29ubmVjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbm5lY3QoYWRkaXRpb25hbFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IGFkZGl0aW9uYWxSZXF1ZXN0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB5aWVsZCB0aGlzLndhaXRGb3JXYWxsZXRDb25uZWN0aW9uKHtcbiAgICAgICAgaWdub3JlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgdHJhY2VJZDogb3B0aW9ucy50cmFjZUlkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVE9ETzogcmVtb3ZlIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqIEluaXRpYXRlcyB0aGUgY29ubmVjdGlvbiBwcm9jZXNzIGZvciBhbiBleHRlcm5hbCB3YWxsZXQgYnkgb3BlbmluZyB0aGUgd2FsbGV0IG1vZGFsXG4gICAqIGFuZCByZXR1cm5zIHRoZSBjb25uZWN0ZWQgd2FsbGV0IGluZm9ybWF0aW9uIHVwb24gc3VjY2Vzc2Z1bCBjb25uZWN0aW9uLlxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSB1c2VyIGNhbmNlbHMgdGhlIGNvbm5lY3Rpb24gcHJvY2VzcyBvciBpZiB0aGUgY29ubmVjdGlvbiBwcm9jZXNzIGZhaWxzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbm5lY3RFeHRlcm5hbFdhbGxldChvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIHdpZGdldENvbnRyb2xsZXIub3BlbldhbGxldHNNb2RhbCh7IHRyYWNlSWQ6IG9wdGlvbnMudHJhY2VJZCB9KTtcbiAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5vbk1vZGFsU3RhdGVDaGFuZ2UoKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjbG9zZVJlYXNvbiB9ID0gc3RhdGU7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IFwib3BlbmVkXCIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgaWYgKGNsb3NlUmVhc29uID09PSBcImFjdGlvbi1jYW5jZWxsZWRcIikge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB5aWVsZCB0aGlzLndhaXRGb3JXYWxsZXRDb25uZWN0aW9uKHtcbiAgICAgICAgaWdub3JlRXJyb3JzOiB0cnVlLFxuICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgIHRyYWNlSWQ6IG9wdGlvbnMudHJhY2VJZFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRPRE86IHJlbW92ZSBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKiBXYWl0cyBmb3IgYSB3YWxsZXQgY29ubmVjdGlvbiBiYXNlZCBvbiBwcm92aWRlZCBvcHRpb25zLCByZXR1cm5pbmcgY29ubmVjdGVkIHdhbGxldCBpbmZvcm1hdGlvbi5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIGZvciBjb25uZWN0aW9uIHN0YXR1c2VzIGFuZCBlcnJvcnMgaGFuZGxpbmcuXG4gICAqIEBvcHRpb25zLmlnbm9yZUVycm9ycyAtIElmIHRydWUsIGlnbm9yZXMgZXJyb3JzIGR1cmluZyB3YWl0aW5nLCB3YWl0aW5nIGNvbnRpbnVlcyB1bnRpbCBhIHZhbGlkIHdhbGxldCBjb25uZWN0cy4gRGVmYXVsdCBpcyBmYWxzZS5cbiAgICogQG9wdGlvbnMuYWJvcnRTaWduYWwgLSBPcHRpb25hbCBBYm9ydFNpZ25hbCBmb3IgZXh0ZXJuYWwgY2FuY2VsbGF0aW9uLiBUaHJvd3MgVG9uQ29ubmVjdFVJRXJyb3IgaWYgYWJvcnRlZC5cbiAgICogQHRocm93cyBUb25Db25uZWN0VUlFcnJvciBpZiB3YWl0aW5nIGlzIGFib3J0ZWQgb3Igbm8gdmFsaWQgd2FsbGV0IGNvbm5lY3Rpb24gaXMgcmVjZWl2ZWQgYW5kIGlnbm9yZUVycm9ycyBpcyBmYWxzZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB3YWl0Rm9yV2FsbGV0Q29ubmVjdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMudHJhY2tlci50cmFja0Nvbm5lY3Rpb25TdGFydGVkKCk7XG4gICAgICAgIGNvbnN0IHsgaWdub3JlRXJyb3JzID0gZmFsc2UsIHNpZ25hbCA9IG51bGwgfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uRXJyb3IoXCJDb25uZWN0aW9uIHdhcyBjYW5jZWxsZWRcIik7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgVG9uQ29ubmVjdFVJRXJyb3IoXCJXYWxsZXQgd2FzIG5vdCBjb25uZWN0ZWRcIikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uU3RhdHVzQ2hhbmdlSGFuZGxlciA9ICh3YWxsZXQpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICBpZiAoIXdhbGxldCkge1xuICAgICAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrQ29ubmVjdGlvbkVycm9yKFwiQ29ubmVjdGlvbiB3YXMgY2FuY2VsbGVkXCIpO1xuICAgICAgICAgICAgaWYgKGlnbm9yZUVycm9ycykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBUb25Db25uZWN0VUlFcnJvcihcIldhbGxldCB3YXMgbm90IGNvbm5lY3RlZFwiKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2tlci50cmFja0Nvbm5lY3Rpb25Db21wbGV0ZWQod2FsbGV0KTtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICByZXNvbHZlKHdhbGxldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb25FcnJvcnNIYW5kbGVyID0gKHJlYXNvbikgPT4ge1xuICAgICAgICAgIHRoaXMudHJhY2tlci50cmFja0Nvbm5lY3Rpb25FcnJvcihyZWFzb24ubWVzc2FnZSk7XG4gICAgICAgICAgaWYgKGlnbm9yZUVycm9ycykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMub25TdGF0dXNDaGFuZ2UoXG4gICAgICAgICAgKHdhbGxldCkgPT4gb25TdGF0dXNDaGFuZ2VIYW5kbGVyKHdhbGxldCksXG4gICAgICAgICAgKHJlYXNvbikgPT4gb25FcnJvcnNIYW5kbGVyKHJlYXNvbilcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgXCJhYm9ydFwiLFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICByZWplY3QobmV3IFRvbkNvbm5lY3RVSUVycm9yKFwiV2FsbGV0IHdhcyBub3QgY29ubmVjdGVkXCIpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IG9uY2U6IHRydWUgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgYSB0cmFuc2FjdGlvbiB0byBiZSBzZW50IGJhc2VkIG9uIHByb3ZpZGVkIG9wdGlvbnMsIHJldHVybmluZyB0aGUgdHJhbnNhY3Rpb24gcmVzcG9uc2UuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbiBmb3IgdHJhbnNhY3Rpb24gc3RhdHVzZXMgYW5kIGVycm9ycyBoYW5kbGluZy5cbiAgICogQG9wdGlvbnMudHJhbnNhY3Rpb24gLSBUcmFuc2FjdGlvbiB0byBzZW5kLlxuICAgKiBAb3B0aW9ucy5pZ25vcmVFcnJvcnMgLSBJZiB0cnVlLCBpZ25vcmVzIGVycm9ycyBkdXJpbmcgd2FpdGluZywgd2FpdGluZyBjb250aW51ZXMgdW50aWwgYSB2YWxpZCB0cmFuc2FjdGlvbiBpcyBzZW50LiBEZWZhdWx0IGlzIGZhbHNlLlxuICAgKiBAb3B0aW9ucy5hYm9ydFNpZ25hbCAtIE9wdGlvbmFsIEFib3J0U2lnbmFsIGZvciBleHRlcm5hbCBjYW5jZWxsYXRpb24uIFRocm93cyBUb25Db25uZWN0VUlFcnJvciBpZiBhYm9ydGVkLlxuICAgKiBAcGFyYW0gb25SZXF1ZXN0U2VudCAob3B0aW9uYWwpIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFuc2FjdGlvbiBpcyBzZW50IHRvIHRoZSB3YWxsZXQuXG4gICAqIEB0aHJvd3MgVG9uQ29ubmVjdFVJRXJyb3IgaWYgd2FpdGluZyBpcyBhYm9ydGVkIG9yIG5vIHZhbGlkIHRyYW5zYWN0aW9uIHJlc3BvbnNlIGlzIHJlY2VpdmVkIGFuZCBpZ25vcmVFcnJvcnMgaXMgZmFsc2UuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgd2FpdEZvclNlbmRUcmFuc2FjdGlvbihvcHRpb25zLCBvblJlcXVlc3RTZW50KSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb24sIHNpZ25hbCB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrVHJhbnNhY3Rpb25TaWduaW5nRmFpbGVkKFxuICAgICAgICAgICAgdGhpcy53YWxsZXQsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgIFwiVHJhbnNhY3Rpb24gd2FzIGNhbmNlbGxlZFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBUb25Db25uZWN0VUlFcnJvcihcIlRyYW5zYWN0aW9uIHdhcyBub3Qgc2VudFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb25UcmFuc2FjdGlvbkhhbmRsZXIgPSAodHJhbnNhY3Rpb24yKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZSh0cmFuc2FjdGlvbjIpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb25FcnJvcnNIYW5kbGVyID0gKHJlYXNvbikgPT4ge1xuICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkNhbmNlbGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tUcmFuc2FjdGlvblNpZ25pbmdGYWlsZWQoXG4gICAgICAgICAgICB0aGlzLndhbGxldCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgXCJUcmFuc2FjdGlvbiB3YXMgY2FuY2VsbGVkXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlamVjdChuZXcgVG9uQ29ubmVjdFVJRXJyb3IoXCJUcmFuc2FjdGlvbiB3YXMgbm90IHNlbnRcIikpO1xuICAgICAgICB9O1xuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQ2FuY2VsZWRIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdG9yLnNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwge1xuICAgICAgICAgIG9uUmVxdWVzdFNlbnQsXG4gICAgICAgICAgc2lnbmFsLFxuICAgICAgICAgIHRyYWNlSWQ6IG9wdGlvbnMudHJhY2VJZFxuICAgICAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQ2FuY2VsZWRIYW5kbGVyKTtcbiAgICAgICAgICByZXR1cm4gb25UcmFuc2FjdGlvbkhhbmRsZXIocmVzdWx0KTtcbiAgICAgICAgfSkuY2F0Y2goKHJlYXNvbikgPT4ge1xuICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25DYW5jZWxlZEhhbmRsZXIpO1xuICAgICAgICAgIHJldHVybiBvbkVycm9yc0hhbmRsZXIocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogV2FpdHMgZm9yIGEgdHJhbnNhY3Rpb24gdG8gYmUgc2VudCBiYXNlZCBvbiBwcm92aWRlZCBvcHRpb25zLCByZXR1cm5pbmcgdGhlIHRyYW5zYWN0aW9uIHJlc3BvbnNlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gZm9yIHRyYW5zYWN0aW9uIHN0YXR1c2VzIGFuZCBlcnJvcnMgaGFuZGxpbmcuXG4gICAqIEBvcHRpb25zLnRyYW5zYWN0aW9uIC0gVHJhbnNhY3Rpb24gdG8gc2VuZC5cbiAgICogQG9wdGlvbnMuaWdub3JlRXJyb3JzIC0gSWYgdHJ1ZSwgaWdub3JlcyBlcnJvcnMgZHVyaW5nIHdhaXRpbmcsIHdhaXRpbmcgY29udGludWVzIHVudGlsIGEgdmFsaWQgdHJhbnNhY3Rpb24gaXMgc2VudC4gRGVmYXVsdCBpcyBmYWxzZS5cbiAgICogQG9wdGlvbnMuYWJvcnRTaWduYWwgLSBPcHRpb25hbCBBYm9ydFNpZ25hbCBmb3IgZXh0ZXJuYWwgY2FuY2VsbGF0aW9uLiBUaHJvd3MgVG9uQ29ubmVjdFVJRXJyb3IgaWYgYWJvcnRlZC5cbiAgICogQHBhcmFtIG9uUmVxdWVzdFNlbnQgKG9wdGlvbmFsKSB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgdHJhbnNhY3Rpb24gaXMgc2VudCB0byB0aGUgd2FsbGV0LlxuICAgKiBAdGhyb3dzIFRvbkNvbm5lY3RVSUVycm9yIGlmIHdhaXRpbmcgaXMgYWJvcnRlZCBvciBubyB2YWxpZCB0cmFuc2FjdGlvbiByZXNwb25zZSBpcyByZWNlaXZlZCBhbmQgaWdub3JlRXJyb3JzIGlzIGZhbHNlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHdhaXRGb3JTaWduRGF0YShvcHRpb25zLCBvblJlcXVlc3RTZW50KSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgc2lnbmFsIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tEYXRhU2lnbmluZ0ZhaWxlZCh0aGlzLndhbGxldCwgZGF0YSwgXCJTaWduRGF0YSB3YXMgY2FuY2VsbGVkXCIpO1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IFRvbkNvbm5lY3RVSUVycm9yKFwiU2lnbkRhdGEgd2FzIG5vdCBzZW50XCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvblNpZ25IYW5kbGVyID0gKGRhdGEyKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZShkYXRhMik7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBvbkVycm9yc0hhbmRsZXIgPSAocmVhc29uKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uQ2FuY2VsZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMudHJhY2tlci50cmFja0RhdGFTaWduaW5nRmFpbGVkKHRoaXMud2FsbGV0LCBkYXRhLCBcIlNpZ25EYXRhIHdhcyBjYW5jZWxsZWRcIik7XG4gICAgICAgICAgcmVqZWN0KG5ldyBUb25Db25uZWN0VUlFcnJvcihcIlNpZ25EYXRhIHdhcyBub3Qgc2VudFwiKSk7XG4gICAgICAgIH07XG4gICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25DYW5jZWxlZEhhbmRsZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0b3Iuc2lnbkRhdGEoZGF0YSwgeyBvblJlcXVlc3RTZW50LCBzaWduYWwgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG9uU2lnbkhhbmRsZXIocmVzdWx0KTtcbiAgICAgICAgfSkuY2F0Y2goKHJlYXNvbikgPT4ge1xuICAgICAgICAgIHJldHVybiBvbkVycm9yc0hhbmRsZXIocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIHRoZSB0cmFuc2FjdGlvbiBtb2RhbCB3aW5kb3cgc3RhdGUgY2hhbmdlcywgcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGhhcyB0byBiZSBjYWxsZWQgdG8gdW5zdWJzY3JpYmUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb25UcmFuc2FjdGlvbk1vZGFsU3RhdGVDaGFuZ2Uob25DaGFuZ2UpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbk1vZGFsLm9uU3RhdGVDaGFuZ2Uob25DaGFuZ2UpO1xuICB9XG4gIHN1YnNjcmliZVRvV2FsbGV0Q2hhbmdlKCkge1xuICAgIHRoaXMuY29ubmVjdG9yLm9uU3RhdHVzQ2hhbmdlKCh3YWxsZXQpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBpZiAod2FsbGV0KSB7XG4gICAgICAgIHlpZWxkIHRoaXMudXBkYXRlV2FsbGV0SW5mbyh3YWxsZXQpO1xuICAgICAgICB0aGlzLnNldFByZWZlcnJlZFdhbGxldEFwcE5hbWUoKChfYTIgPSB0aGlzLndhbGxldEluZm8pID09IG51bGwgPyB2b2lkIDAgOiBfYTIuYXBwTmFtZSkgfHwgd2FsbGV0LmRldmljZS5hcHBOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud2FsbGV0SW5mb1N0b3JhZ2UucmVtb3ZlV2FsbGV0SW5mbygpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuICBzZXRQcmVmZXJyZWRXYWxsZXRBcHBOYW1lKHZhbHVlKSB7XG4gICAgdGhpcy5wcmVmZXJyZWRXYWxsZXRTdG9yYWdlLnNldFByZWZlcnJlZFdhbGxldEFwcE5hbWUodmFsdWUpO1xuICAgIHNldEFwcFN0YXRlKHsgcHJlZmVycmVkV2FsbGV0QXBwTmFtZTogdmFsdWUgfSk7XG4gIH1cbiAgZ2V0U2VsZWN0ZWRXYWxsZXRJbmZvKHdhbGxldCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBsZXQgbGFzdFNlbGVjdGVkV2FsbGV0SW5mbzIgPSB3aWRnZXRDb250cm9sbGVyLmdldFNlbGVjdGVkV2FsbGV0SW5mbygpO1xuICAgICAgaWYgKCFsYXN0U2VsZWN0ZWRXYWxsZXRJbmZvMikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghKFwibmFtZVwiIGluIGxhc3RTZWxlY3RlZFdhbGxldEluZm8yKSkge1xuICAgICAgICBpZiAod2FsbGV0LmRldmljZS5hcHBOYW1lID09PSBXQUxMRVRfQ09OTkVDVF9BUFBfTkFNRSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIndhbGxldC1jb25uZWN0XCIsXG4gICAgICAgICAgICBuYW1lOiBXQUxMRVRfQ09OTkVDVF9XQUxMRVRfTkFNRSxcbiAgICAgICAgICAgIGFwcE5hbWU6IFdBTExFVF9DT05ORUNUX0FQUF9OQU1FLFxuICAgICAgICAgICAgaW1hZ2VVcmw6IElNRy5XQUxMRVRfQ09OTkVDVCxcbiAgICAgICAgICAgIGFib3V0VXJsOiBXQUxMRVRfQ09OTkVDVF9BQk9VVF9VUkwsXG4gICAgICAgICAgICBmZWF0dXJlczogd2FsbGV0LmRldmljZS5mZWF0dXJlcyxcbiAgICAgICAgICAgIHBsYXRmb3JtczogW11cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhbGxldHNMaXN0ID0gYXBwbHlXYWxsZXRzTGlzdENvbmZpZ3VyYXRpb24oXG4gICAgICAgICAgeWllbGQgdGhpcy53YWxsZXRzTGlzdCxcbiAgICAgICAgICBhcHBTdGF0ZS53YWxsZXRzTGlzdENvbmZpZ3VyYXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgd2FsbGV0SW5mbyA9IHdhbGxldHNMaXN0LmZpbmQoKGl0ZW0pID0+IGVxV2FsbGV0TmFtZShpdGVtLCB3YWxsZXQuZGV2aWNlLmFwcE5hbWUpKTtcbiAgICAgICAgaWYgKCF3YWxsZXRJbmZvKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RVSUVycm9yKFxuICAgICAgICAgICAgYENhbm5vdCBmaW5kIFdhbGxldEluZm8gZm9yIHRoZSAnJHt3YWxsZXQuZGV2aWNlLmFwcE5hbWV9JyB3YWxsZXRgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHdhbGxldEluZm8pLCBsYXN0U2VsZWN0ZWRXYWxsZXRJbmZvMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFzdFNlbGVjdGVkV2FsbGV0SW5mbzI7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlV2FsbGV0SW5mbyh3YWxsZXQpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRXYWxsZXRJbmZvID0geWllbGQgdGhpcy5nZXRTZWxlY3RlZFdhbGxldEluZm8od2FsbGV0KTtcbiAgICAgIGlmIChzZWxlY3RlZFdhbGxldEluZm8pIHtcbiAgICAgICAgdGhpcy53YWxsZXRJbmZvID0gc2VsZWN0ZWRXYWxsZXRJbmZvO1xuICAgICAgICB0aGlzLndhbGxldEluZm9TdG9yYWdlLnNldFdhbGxldEluZm8oc2VsZWN0ZWRXYWxsZXRJbmZvKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RvcmVkV2FsbGV0SW5mbyA9IHRoaXMud2FsbGV0SW5mb1N0b3JhZ2UuZ2V0V2FsbGV0SW5mbygpO1xuICAgICAgaWYgKHN0b3JlZFdhbGxldEluZm8pIHtcbiAgICAgICAgdGhpcy53YWxsZXRJbmZvID0gc3RvcmVkV2FsbGV0SW5mbztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy53YWxsZXRJbmZvID0gKHlpZWxkIHRoaXMud2FsbGV0c0xpc3QpLmZpbmQoXG4gICAgICAgICh3YWxsZXRJbmZvKSA9PiBlcVdhbGxldE5hbWUod2FsbGV0SW5mbywgd2FsbGV0LmRldmljZS5hcHBOYW1lKVxuICAgICAgKSB8fCBudWxsO1xuICAgIH0pO1xuICB9XG4gIG5vcm1hbGl6ZVdpZGdldFJvb3Qocm9vdElkKSB7XG4gICAgaWYgKCFyb290SWQgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHJvb3RJZCkpIHtcbiAgICAgIHJvb3RJZCA9IFwidGMtd2lkZ2V0LXJvb3RcIjtcbiAgICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHJvb3RFbGVtZW50LmlkID0gcm9vdElkO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyb290RWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiByb290SWQ7XG4gIH1cbiAgY2hlY2tCdXR0b25Sb290RXhpc3QoYnV0dG9uUm9vdElkKSB7XG4gICAgaWYgKGJ1dHRvblJvb3RJZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYnV0dG9uUm9vdElkKSkge1xuICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RVSUVycm9yKGAke2J1dHRvblJvb3RJZH0gZWxlbWVudCBub3QgZm91bmQgaW4gdGhlIGRvY3VtZW50LmApO1xuICAgIH1cbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBnZXRNb2RhbHNBbmROb3RpZmljYXRpb25zQ29uZmlndXJhdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIF9hMiwgX2IyLCBfYzIsIF9kMiwgX2UyLCBfZjI7XG4gICAgY29uc3QgYWxsQWN0aW9ucyA9IFtcbiAgICAgIFwiYmVmb3JlXCIsXG4gICAgICBcInN1Y2Nlc3NcIixcbiAgICAgIFwiZXJyb3JcIlxuICAgIF07XG4gICAgbGV0IG5vdGlmaWNhdGlvbnMyID0gYWxsQWN0aW9ucztcbiAgICBpZiAoKChfYTIgPSB0aGlzLmFjdGlvbnNDb25maWd1cmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLm5vdGlmaWNhdGlvbnMpICYmICgoX2IyID0gdGhpcy5hY3Rpb25zQ29uZmlndXJhdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5ub3RpZmljYXRpb25zKSAhPT0gXCJhbGxcIikge1xuICAgICAgbm90aWZpY2F0aW9uczIgPSB0aGlzLmFjdGlvbnNDb25maWd1cmF0aW9uLm5vdGlmaWNhdGlvbnM7XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm5vdGlmaWNhdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLm5vdGlmaWNhdGlvbnMgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgbm90aWZpY2F0aW9uczIgPSBhbGxBY3Rpb25zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm90aWZpY2F0aW9uczIgPSBvcHRpb25zLm5vdGlmaWNhdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBtb2RhbHMgPSBbXCJiZWZvcmVcIl07XG4gICAgaWYgKChfYzIgPSB0aGlzLmFjdGlvbnNDb25maWd1cmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2MyLm1vZGFscykge1xuICAgICAgaWYgKHRoaXMuYWN0aW9uc0NvbmZpZ3VyYXRpb24ubW9kYWxzID09PSBcImFsbFwiKSB7XG4gICAgICAgIG1vZGFscyA9IGFsbEFjdGlvbnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RhbHMgPSB0aGlzLmFjdGlvbnNDb25maWd1cmF0aW9uLm1vZGFscztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kYWxzKSB7XG4gICAgICBpZiAob3B0aW9ucy5tb2RhbHMgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgbW9kYWxzID0gYWxsQWN0aW9ucztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZGFscyA9IG9wdGlvbnMubW9kYWxzO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXR1cm5TdHJhdGVneSA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnJldHVyblN0cmF0ZWd5KSB8fCAoKF9kMiA9IHRoaXMuYWN0aW9uc0NvbmZpZ3VyYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZDIucmV0dXJuU3RyYXRlZ3kpIHx8IFwiYmFja1wiO1xuICAgIGNvbnN0IHR3YVJldHVyblVybCA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnR3YVJldHVyblVybCkgfHwgKChfZTIgPSB0aGlzLmFjdGlvbnNDb25maWd1cmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2UyLnR3YVJldHVyblVybCk7XG4gICAgbGV0IHNraXBSZWRpcmVjdFRvV2FsbGV0ID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc2tpcFJlZGlyZWN0VG9XYWxsZXQpIHx8ICgoX2YyID0gdGhpcy5hY3Rpb25zQ29uZmlndXJhdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9mMi5za2lwUmVkaXJlY3RUb1dhbGxldCkgfHwgXCJpb3NcIjtcbiAgICBpZiAoaXNJblRNQSgpKSB7XG4gICAgICBza2lwUmVkaXJlY3RUb1dhbGxldCA9IFwibmV2ZXJcIjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vdGlmaWNhdGlvbnM6IG5vdGlmaWNhdGlvbnMyLFxuICAgICAgbW9kYWxzLFxuICAgICAgcmV0dXJuU3RyYXRlZ3ksXG4gICAgICB0d2FSZXR1cm5VcmwsXG4gICAgICBza2lwUmVkaXJlY3RUb1dhbGxldFxuICAgIH07XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFRIRU1FLFxuICBUb25Db25uZWN0VUksXG4gIFRvbkNvbm5lY3RVSUVycm9yXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tonconnect/ui/lib/index.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["css-src_app_globals_css","main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C123%5C%5CDesktop%5C%5Ctma-project%5C%5Cfrontend%5C%5Csrc%5C%5Capp%5C%5Clayout.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);